// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from MK65F18.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/NXP

//go:build nxp && mk65f18
// +build nxp,mk65f18

// MK65F18 NXP Microcontroller
//
//     Copyright 2016-2018 NXP SPDX-License-Identifier: BSD-3-Clause
package nxp

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "MK65F18"
	CPU          = "CM4"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// Enhanced direct memory access controller
	IRQ_DMA0_DMA16 = 0

	// Enhanced direct memory access controller
	IRQ_DMA1_DMA17 = 1

	// Enhanced direct memory access controller
	IRQ_DMA2_DMA18 = 2

	// Enhanced direct memory access controller
	IRQ_DMA3_DMA19 = 3

	// Enhanced direct memory access controller
	IRQ_DMA4_DMA20 = 4

	// Enhanced direct memory access controller
	IRQ_DMA5_DMA21 = 5

	// Enhanced direct memory access controller
	IRQ_DMA6_DMA22 = 6

	// Enhanced direct memory access controller
	IRQ_DMA7_DMA23 = 7

	// Enhanced direct memory access controller
	IRQ_DMA8_DMA24 = 8

	// Enhanced direct memory access controller
	IRQ_DMA9_DMA25 = 9

	// Enhanced direct memory access controller
	IRQ_DMA10_DMA26 = 10

	// Enhanced direct memory access controller
	IRQ_DMA11_DMA27 = 11

	// Enhanced direct memory access controller
	IRQ_DMA12_DMA28 = 12

	// Enhanced direct memory access controller
	IRQ_DMA13_DMA29 = 13

	// Enhanced direct memory access controller
	IRQ_DMA14_DMA30 = 14

	// Enhanced direct memory access controller
	IRQ_DMA15_DMA31 = 15

	// Enhanced direct memory access controller
	IRQ_DMA_Error = 16

	// Core Platform Miscellaneous Control Module
	IRQ_MCM = 17

	// Flash Memory Interface
	IRQ_FTFE = 18

	// Flash Memory Interface
	IRQ_Read_Collision = 19

	// Power Management Controller
	IRQ_LVD_LVW = 20

	// Low leakage wakeup unit
	IRQ_LLWU = 21

	// Generation 2008 Watchdog Timer // External Watchdog Monitor
	IRQ_WDOG_EWM = 22

	// Random Number Generator Accelerator
	IRQ_RNG = 23

	// Inter-Integrated Circuit
	IRQ_I2C0 = 24

	// Inter-Integrated Circuit
	IRQ_I2C1 = 25

	// Serial Peripheral Interface
	IRQ_SPI0 = 26

	// Serial Peripheral Interface
	IRQ_SPI1 = 27

	// Inter-IC Sound / Synchronous Audio Interface
	IRQ_I2S0_Tx = 28

	// Inter-IC Sound / Synchronous Audio Interface
	IRQ_I2S0_Rx = 29

	// Serial Communication Interface
	IRQ_UART0_RX_TX = 31

	// Serial Communication Interface
	IRQ_UART0_ERR = 32

	// Serial Communication Interface
	IRQ_UART1_RX_TX = 33

	// Serial Communication Interface
	IRQ_UART1_ERR = 34

	// Serial Communication Interface
	IRQ_UART2_RX_TX = 35

	// Serial Communication Interface
	IRQ_UART2_ERR = 36

	// Serial Communication Interface
	IRQ_UART3_RX_TX = 37

	// Serial Communication Interface
	IRQ_UART3_ERR = 38

	// Analog-to-Digital Converter
	IRQ_ADC0 = 39

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_CMP0 = 40

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_CMP1 = 41

	// FlexTimer Module
	IRQ_FTM0 = 42

	// FlexTimer Module
	IRQ_FTM1 = 43

	// FlexTimer Module
	IRQ_FTM2 = 44

	// Carrier Modulator Transmitter
	IRQ_CMT = 45

	// Secure Real Time Clock
	IRQ_RTC = 46

	// Secure Real Time Clock
	IRQ_RTC_Seconds = 47

	// Periodic Interrupt Timer
	IRQ_PIT0 = 48

	// Periodic Interrupt Timer
	IRQ_PIT1 = 49

	// Periodic Interrupt Timer
	IRQ_PIT2 = 50

	// Periodic Interrupt Timer
	IRQ_PIT3 = 51

	// Programmable Delay Block
	IRQ_PDB0 = 52

	// Universal Serial Bus, OTG Capable Controller
	IRQ_USB0 = 53

	// USB Device Charger Detection module
	IRQ_USBDCD = 54

	// 12-Bit Digital-to-Analog Converter
	IRQ_DAC0 = 56

	// Low Power Timer
	IRQ_LPTMR0 = 58

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTA = 59

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTB = 60

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTC = 61

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTD = 62

	// Pin Control and Interrupts // General Purpose Input/Output
	IRQ_PORTE = 63

	// Serial Peripheral Interface
	IRQ_SPI2 = 65

	// Serial Communication Interface
	IRQ_UART4_RX_TX = 66

	// Serial Communication Interface
	IRQ_UART4_ERR = 67

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_CMP2 = 70

	// FlexTimer Module
	IRQ_FTM3 = 71

	// 12-Bit Digital-to-Analog Converter
	IRQ_DAC1 = 72

	// Analog-to-Digital Converter
	IRQ_ADC1 = 73

	// Inter-Integrated Circuit
	IRQ_I2C2 = 74

	// Flex Controller Area Network module
	IRQ_CAN0_ORed_Message_buffer = 75

	// Flex Controller Area Network module
	IRQ_CAN0_Bus_Off = 76

	// Flex Controller Area Network module
	IRQ_CAN0_Error = 77

	// Flex Controller Area Network module
	IRQ_CAN0_Tx_Warning = 78

	// Flex Controller Area Network module
	IRQ_CAN0_Rx_Warning = 79

	// Flex Controller Area Network module
	IRQ_CAN0_Wake_Up = 80

	// Secured Digital Host Controller
	IRQ_SDHC = 81

	// Ethernet MAC-NET Core
	IRQ_ENET_1588_Timer = 82

	// Ethernet MAC-NET Core
	IRQ_ENET_Transmit = 83

	// Ethernet MAC-NET Core
	IRQ_ENET_Receive = 84

	// Ethernet MAC-NET Core
	IRQ_ENET_Error = 85

	// Universal Asynchronous Receiver/Transmitter
	IRQ_LPUART0 = 86

	// Touch sense input
	IRQ_TSI0 = 87

	// Timer/PWM Module
	IRQ_TPM1 = 88

	// Timer/PWM Module
	IRQ_TPM2 = 89

	// USB Device Charger Detection module
	IRQ_USBHSDCD = 90

	// Inter-Integrated Circuit
	IRQ_I2C3 = 91

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	IRQ_CMP3 = 92

	// USB HS/FS/LS OTG Controller
	IRQ_USBHS = 93

	// Flex Controller Area Network module
	IRQ_CAN1_ORed_Message_buffer = 94

	// Flex Controller Area Network module
	IRQ_CAN1_Bus_Off = 95

	// Flex Controller Area Network module
	IRQ_CAN1_Error = 96

	// Flex Controller Area Network module
	IRQ_CAN1_Tx_Warning = 97

	// Flex Controller Area Network module
	IRQ_CAN1_Rx_Warning = 98

	// Flex Controller Area Network module
	IRQ_CAN1_Wake_Up = 99

	// Highest interrupt number on this device.
	IRQ_max = 99
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export DMA0_DMA16_IRQHandler
func interruptDMA0_DMA16() {
	callHandlers(IRQ_DMA0_DMA16)
}

//export DMA1_DMA17_IRQHandler
func interruptDMA1_DMA17() {
	callHandlers(IRQ_DMA1_DMA17)
}

//export DMA2_DMA18_IRQHandler
func interruptDMA2_DMA18() {
	callHandlers(IRQ_DMA2_DMA18)
}

//export DMA3_DMA19_IRQHandler
func interruptDMA3_DMA19() {
	callHandlers(IRQ_DMA3_DMA19)
}

//export DMA4_DMA20_IRQHandler
func interruptDMA4_DMA20() {
	callHandlers(IRQ_DMA4_DMA20)
}

//export DMA5_DMA21_IRQHandler
func interruptDMA5_DMA21() {
	callHandlers(IRQ_DMA5_DMA21)
}

//export DMA6_DMA22_IRQHandler
func interruptDMA6_DMA22() {
	callHandlers(IRQ_DMA6_DMA22)
}

//export DMA7_DMA23_IRQHandler
func interruptDMA7_DMA23() {
	callHandlers(IRQ_DMA7_DMA23)
}

//export DMA8_DMA24_IRQHandler
func interruptDMA8_DMA24() {
	callHandlers(IRQ_DMA8_DMA24)
}

//export DMA9_DMA25_IRQHandler
func interruptDMA9_DMA25() {
	callHandlers(IRQ_DMA9_DMA25)
}

//export DMA10_DMA26_IRQHandler
func interruptDMA10_DMA26() {
	callHandlers(IRQ_DMA10_DMA26)
}

//export DMA11_DMA27_IRQHandler
func interruptDMA11_DMA27() {
	callHandlers(IRQ_DMA11_DMA27)
}

//export DMA12_DMA28_IRQHandler
func interruptDMA12_DMA28() {
	callHandlers(IRQ_DMA12_DMA28)
}

//export DMA13_DMA29_IRQHandler
func interruptDMA13_DMA29() {
	callHandlers(IRQ_DMA13_DMA29)
}

//export DMA14_DMA30_IRQHandler
func interruptDMA14_DMA30() {
	callHandlers(IRQ_DMA14_DMA30)
}

//export DMA15_DMA31_IRQHandler
func interruptDMA15_DMA31() {
	callHandlers(IRQ_DMA15_DMA31)
}

//export DMA_Error_IRQHandler
func interruptDMA_Error() {
	callHandlers(IRQ_DMA_Error)
}

//export MCM_IRQHandler
func interruptMCM() {
	callHandlers(IRQ_MCM)
}

//export FTFE_IRQHandler
func interruptFTFE() {
	callHandlers(IRQ_FTFE)
}

//export Read_Collision_IRQHandler
func interruptRead_Collision() {
	callHandlers(IRQ_Read_Collision)
}

//export LVD_LVW_IRQHandler
func interruptLVD_LVW() {
	callHandlers(IRQ_LVD_LVW)
}

//export LLWU_IRQHandler
func interruptLLWU() {
	callHandlers(IRQ_LLWU)
}

//export WDOG_EWM_IRQHandler
func interruptWDOG_EWM() {
	callHandlers(IRQ_WDOG_EWM)
}

//export RNG_IRQHandler
func interruptRNG() {
	callHandlers(IRQ_RNG)
}

//export I2C0_IRQHandler
func interruptI2C0() {
	callHandlers(IRQ_I2C0)
}

//export I2C1_IRQHandler
func interruptI2C1() {
	callHandlers(IRQ_I2C1)
}

//export SPI0_IRQHandler
func interruptSPI0() {
	callHandlers(IRQ_SPI0)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export I2S0_Tx_IRQHandler
func interruptI2S0_Tx() {
	callHandlers(IRQ_I2S0_Tx)
}

//export I2S0_Rx_IRQHandler
func interruptI2S0_Rx() {
	callHandlers(IRQ_I2S0_Rx)
}

//export UART0_RX_TX_IRQHandler
func interruptUART0_RX_TX() {
	callHandlers(IRQ_UART0_RX_TX)
}

//export UART0_ERR_IRQHandler
func interruptUART0_ERR() {
	callHandlers(IRQ_UART0_ERR)
}

//export UART1_RX_TX_IRQHandler
func interruptUART1_RX_TX() {
	callHandlers(IRQ_UART1_RX_TX)
}

//export UART1_ERR_IRQHandler
func interruptUART1_ERR() {
	callHandlers(IRQ_UART1_ERR)
}

//export UART2_RX_TX_IRQHandler
func interruptUART2_RX_TX() {
	callHandlers(IRQ_UART2_RX_TX)
}

//export UART2_ERR_IRQHandler
func interruptUART2_ERR() {
	callHandlers(IRQ_UART2_ERR)
}

//export UART3_RX_TX_IRQHandler
func interruptUART3_RX_TX() {
	callHandlers(IRQ_UART3_RX_TX)
}

//export UART3_ERR_IRQHandler
func interruptUART3_ERR() {
	callHandlers(IRQ_UART3_ERR)
}

//export ADC0_IRQHandler
func interruptADC0() {
	callHandlers(IRQ_ADC0)
}

//export CMP0_IRQHandler
func interruptCMP0() {
	callHandlers(IRQ_CMP0)
}

//export CMP1_IRQHandler
func interruptCMP1() {
	callHandlers(IRQ_CMP1)
}

//export FTM0_IRQHandler
func interruptFTM0() {
	callHandlers(IRQ_FTM0)
}

//export FTM1_IRQHandler
func interruptFTM1() {
	callHandlers(IRQ_FTM1)
}

//export FTM2_IRQHandler
func interruptFTM2() {
	callHandlers(IRQ_FTM2)
}

//export CMT_IRQHandler
func interruptCMT() {
	callHandlers(IRQ_CMT)
}

//export RTC_IRQHandler
func interruptRTC() {
	callHandlers(IRQ_RTC)
}

//export RTC_Seconds_IRQHandler
func interruptRTC_Seconds() {
	callHandlers(IRQ_RTC_Seconds)
}

//export PIT0_IRQHandler
func interruptPIT0() {
	callHandlers(IRQ_PIT0)
}

//export PIT1_IRQHandler
func interruptPIT1() {
	callHandlers(IRQ_PIT1)
}

//export PIT2_IRQHandler
func interruptPIT2() {
	callHandlers(IRQ_PIT2)
}

//export PIT3_IRQHandler
func interruptPIT3() {
	callHandlers(IRQ_PIT3)
}

//export PDB0_IRQHandler
func interruptPDB0() {
	callHandlers(IRQ_PDB0)
}

//export USB0_IRQHandler
func interruptUSB0() {
	callHandlers(IRQ_USB0)
}

//export USBDCD_IRQHandler
func interruptUSBDCD() {
	callHandlers(IRQ_USBDCD)
}

//export DAC0_IRQHandler
func interruptDAC0() {
	callHandlers(IRQ_DAC0)
}

//export LPTMR0_IRQHandler
func interruptLPTMR0() {
	callHandlers(IRQ_LPTMR0)
}

//export PORTA_IRQHandler
func interruptPORTA() {
	callHandlers(IRQ_PORTA)
}

//export PORTB_IRQHandler
func interruptPORTB() {
	callHandlers(IRQ_PORTB)
}

//export PORTC_IRQHandler
func interruptPORTC() {
	callHandlers(IRQ_PORTC)
}

//export PORTD_IRQHandler
func interruptPORTD() {
	callHandlers(IRQ_PORTD)
}

//export PORTE_IRQHandler
func interruptPORTE() {
	callHandlers(IRQ_PORTE)
}

//export SPI2_IRQHandler
func interruptSPI2() {
	callHandlers(IRQ_SPI2)
}

//export UART4_RX_TX_IRQHandler
func interruptUART4_RX_TX() {
	callHandlers(IRQ_UART4_RX_TX)
}

//export UART4_ERR_IRQHandler
func interruptUART4_ERR() {
	callHandlers(IRQ_UART4_ERR)
}

//export CMP2_IRQHandler
func interruptCMP2() {
	callHandlers(IRQ_CMP2)
}

//export FTM3_IRQHandler
func interruptFTM3() {
	callHandlers(IRQ_FTM3)
}

//export DAC1_IRQHandler
func interruptDAC1() {
	callHandlers(IRQ_DAC1)
}

//export ADC1_IRQHandler
func interruptADC1() {
	callHandlers(IRQ_ADC1)
}

//export I2C2_IRQHandler
func interruptI2C2() {
	callHandlers(IRQ_I2C2)
}

//export CAN0_ORed_Message_buffer_IRQHandler
func interruptCAN0_ORed_Message_buffer() {
	callHandlers(IRQ_CAN0_ORed_Message_buffer)
}

//export CAN0_Bus_Off_IRQHandler
func interruptCAN0_Bus_Off() {
	callHandlers(IRQ_CAN0_Bus_Off)
}

//export CAN0_Error_IRQHandler
func interruptCAN0_Error() {
	callHandlers(IRQ_CAN0_Error)
}

//export CAN0_Tx_Warning_IRQHandler
func interruptCAN0_Tx_Warning() {
	callHandlers(IRQ_CAN0_Tx_Warning)
}

//export CAN0_Rx_Warning_IRQHandler
func interruptCAN0_Rx_Warning() {
	callHandlers(IRQ_CAN0_Rx_Warning)
}

//export CAN0_Wake_Up_IRQHandler
func interruptCAN0_Wake_Up() {
	callHandlers(IRQ_CAN0_Wake_Up)
}

//export SDHC_IRQHandler
func interruptSDHC() {
	callHandlers(IRQ_SDHC)
}

//export ENET_1588_Timer_IRQHandler
func interruptENET_1588_Timer() {
	callHandlers(IRQ_ENET_1588_Timer)
}

//export ENET_Transmit_IRQHandler
func interruptENET_Transmit() {
	callHandlers(IRQ_ENET_Transmit)
}

//export ENET_Receive_IRQHandler
func interruptENET_Receive() {
	callHandlers(IRQ_ENET_Receive)
}

//export ENET_Error_IRQHandler
func interruptENET_Error() {
	callHandlers(IRQ_ENET_Error)
}

//export LPUART0_IRQHandler
func interruptLPUART0() {
	callHandlers(IRQ_LPUART0)
}

//export TSI0_IRQHandler
func interruptTSI0() {
	callHandlers(IRQ_TSI0)
}

//export TPM1_IRQHandler
func interruptTPM1() {
	callHandlers(IRQ_TPM1)
}

//export TPM2_IRQHandler
func interruptTPM2() {
	callHandlers(IRQ_TPM2)
}

//export USBHSDCD_IRQHandler
func interruptUSBHSDCD() {
	callHandlers(IRQ_USBHSDCD)
}

//export I2C3_IRQHandler
func interruptI2C3() {
	callHandlers(IRQ_I2C3)
}

//export CMP3_IRQHandler
func interruptCMP3() {
	callHandlers(IRQ_CMP3)
}

//export USBHS_IRQHandler
func interruptUSBHS() {
	callHandlers(IRQ_USBHS)
}

//export CAN1_ORed_Message_buffer_IRQHandler
func interruptCAN1_ORed_Message_buffer() {
	callHandlers(IRQ_CAN1_ORed_Message_buffer)
}

//export CAN1_Bus_Off_IRQHandler
func interruptCAN1_Bus_Off() {
	callHandlers(IRQ_CAN1_Bus_Off)
}

//export CAN1_Error_IRQHandler
func interruptCAN1_Error() {
	callHandlers(IRQ_CAN1_Error)
}

//export CAN1_Tx_Warning_IRQHandler
func interruptCAN1_Tx_Warning() {
	callHandlers(IRQ_CAN1_Tx_Warning)
}

//export CAN1_Rx_Warning_IRQHandler
func interruptCAN1_Rx_Warning() {
	callHandlers(IRQ_CAN1_Rx_Warning)
}

//export CAN1_Wake_Up_IRQHandler
func interruptCAN1_Wake_Up() {
	callHandlers(IRQ_CAN1_Wake_Up)
}

// Peripherals.
var (
	// Flash configuration field
	FTFE_FlashConfig = (*FTFE_FlashConfig_Type)(unsafe.Pointer(uintptr(0x400)))

	// AIPS-Lite Bridge
	AIPS0 = (*AIPS_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// AIPS-Lite Bridge
	AIPS1 = (*AIPS_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// Crossbar switch
	AXBS = (*AXBS_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Enhanced direct memory access controller
	DMA = (*DMA_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// FlexBus external bus interface
	FB = (*FB_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// Memory protection unit
	SYSMPU = (*SYSMPU_Type)(unsafe.Pointer(uintptr(0x4000d000)))

	// Synchronous DRAM Controller
	SDRAM = (*SDRAM_Type)(unsafe.Pointer(uintptr(0x4000f000)))

	// Flash Memory Controller-greg
	FMC = (*FMC_Type)(unsafe.Pointer(uintptr(0x4001f000)))

	// Flash Memory Interface
	FTFE = (*FTFE_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// DMA channel multiplexor
	DMAMUX = (*DMAMUX_Type)(unsafe.Pointer(uintptr(0x40021000)))

	// Flex Controller Area Network module
	CAN0 = (*CAN_Type)(unsafe.Pointer(uintptr(0x40024000)))

	// Flex Controller Area Network module
	CAN1 = (*CAN_Type)(unsafe.Pointer(uintptr(0x400a4000)))

	// Serial Peripheral Interface
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0x4002c000)))

	// Serial Peripheral Interface
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x4002d000)))

	// Serial Peripheral Interface
	SPI2 = (*SPI_Type)(unsafe.Pointer(uintptr(0x400ac000)))

	// Inter-IC Sound / Synchronous Audio Interface
	I2S0 = (*I2S0_Type)(unsafe.Pointer(uintptr(0x4002f000)))

	// Cyclic Redundancy Check
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40032000)))

	// USB Device Charger Detection module
	USBDCD = (*USBDCD_Type)(unsafe.Pointer(uintptr(0x40035000)))

	// Programmable Delay Block
	PDB0 = (*PDB0_Type)(unsafe.Pointer(uintptr(0x40036000)))

	// Periodic Interrupt Timer
	PIT = (*PIT_Type)(unsafe.Pointer(uintptr(0x40037000)))

	// FlexTimer Module
	FTM0 = (*FTM_Type)(unsafe.Pointer(uintptr(0x40038000)))

	// FlexTimer Module
	FTM1 = (*FTM_Type)(unsafe.Pointer(uintptr(0x40039000)))

	// FlexTimer Module
	FTM2 = (*FTM_Type)(unsafe.Pointer(uintptr(0x4003a000)))

	// FlexTimer Module
	FTM3 = (*FTM_Type)(unsafe.Pointer(uintptr(0x400b9000)))

	// Analog-to-Digital Converter
	ADC0 = (*ADC_Type)(unsafe.Pointer(uintptr(0x4003b000)))

	// Analog-to-Digital Converter
	ADC1 = (*ADC_Type)(unsafe.Pointer(uintptr(0x400bb000)))

	// Secure Real Time Clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x4003d000)))

	// VBAT register file
	RFVBAT = (*RFVBAT_Type)(unsafe.Pointer(uintptr(0x4003e000)))

	// Low Power Timer
	LPTMR0 = (*LPTMR0_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// System register file
	RFSYS = (*RFSYS_Type)(unsafe.Pointer(uintptr(0x40041000)))

	// Touch sense input
	TSI0 = (*TSI0_Type)(unsafe.Pointer(uintptr(0x40045000)))

	// System Integration Module
	SIM = (*SIM_Type)(unsafe.Pointer(uintptr(0x40047000)))

	// Pin Control and Interrupts
	PORTA = (*PORT_Type)(unsafe.Pointer(uintptr(0x40049000)))

	// Pin Control and Interrupts
	PORTB = (*PORT_Type)(unsafe.Pointer(uintptr(0x4004a000)))

	// Pin Control and Interrupts
	PORTC = (*PORT_Type)(unsafe.Pointer(uintptr(0x4004b000)))

	// Pin Control and Interrupts
	PORTD = (*PORT_Type)(unsafe.Pointer(uintptr(0x4004c000)))

	// Pin Control and Interrupts
	PORTE = (*PORT_Type)(unsafe.Pointer(uintptr(0x4004d000)))

	// Generation 2008 Watchdog Timer
	WDOG = (*WDOG_Type)(unsafe.Pointer(uintptr(0x40052000)))

	// External Watchdog Monitor
	EWM = (*EWM_Type)(unsafe.Pointer(uintptr(0x40061000)))

	// Carrier Modulator Transmitter
	CMT = (*CMT_Type)(unsafe.Pointer(uintptr(0x40062000)))

	// Multipurpose Clock Generator module
	MCG = (*MCG_Type)(unsafe.Pointer(uintptr(0x40064000)))

	// Oscillator
	OSC = (*OSC_Type)(unsafe.Pointer(uintptr(0x40065000)))

	// Inter-Integrated Circuit
	I2C0 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40066000)))

	// Inter-Integrated Circuit
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40067000)))

	// Inter-Integrated Circuit
	I2C2 = (*I2C_Type)(unsafe.Pointer(uintptr(0x400e6000)))

	// Inter-Integrated Circuit
	I2C3 = (*I2C_Type)(unsafe.Pointer(uintptr(0x400e7000)))

	// Serial Communication Interface
	UART0 = (*UART_Type)(unsafe.Pointer(uintptr(0x4006a000)))

	// Serial Communication Interface
	UART1 = (*UART_Type)(unsafe.Pointer(uintptr(0x4006b000)))

	// Serial Communication Interface
	UART2 = (*UART_Type)(unsafe.Pointer(uintptr(0x4006c000)))

	// Serial Communication Interface
	UART3 = (*UART_Type)(unsafe.Pointer(uintptr(0x4006d000)))

	// Serial Communication Interface
	UART4 = (*UART_Type)(unsafe.Pointer(uintptr(0x400ea000)))

	// Universal Serial Bus, OTG Capable Controller
	USB0 = (*USB0_Type)(unsafe.Pointer(uintptr(0x40072000)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP0 = (*CMP_Type)(unsafe.Pointer(uintptr(0x40073000)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP1 = (*CMP_Type)(unsafe.Pointer(uintptr(0x40073008)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP2 = (*CMP_Type)(unsafe.Pointer(uintptr(0x40073010)))

	// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
	CMP3 = (*CMP_Type)(unsafe.Pointer(uintptr(0x40073018)))

	// Voltage Reference
	VREF = (*VREF_Type)(unsafe.Pointer(uintptr(0x40074000)))

	// Low leakage wakeup unit
	LLWU = (*LLWU_Type)(unsafe.Pointer(uintptr(0x4007c000)))

	// Power Management Controller
	PMC = (*PMC_Type)(unsafe.Pointer(uintptr(0x4007d000)))

	// System Mode Controller
	SMC = (*SMC_Type)(unsafe.Pointer(uintptr(0x4007e000)))

	// Reset Control Module
	RCM = (*RCM_Type)(unsafe.Pointer(uintptr(0x4007f000)))

	// Random Number Generator Accelerator
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x400a0000)))

	// USB HS/FS/LS OTG Controller
	USBHS = (*USBHS_Type)(unsafe.Pointer(uintptr(0x400a1000)))

	// USBPHY Register Reference Index
	USBPHY = (*USBPHY_Type)(unsafe.Pointer(uintptr(0x400a2000)))

	// USB Device Charger Detection module
	USBHSDCD = (*USBHSDCD_Type)(unsafe.Pointer(uintptr(0x400a3000)))

	// Secured Digital Host Controller
	SDHC = (*SDHC_Type)(unsafe.Pointer(uintptr(0x400b1000)))

	// Ethernet MAC-NET Core
	ENET = (*ENET_Type)(unsafe.Pointer(uintptr(0x400c0000)))

	// Universal Asynchronous Receiver/Transmitter
	LPUART0 = (*LPUART0_Type)(unsafe.Pointer(uintptr(0x400c4000)))

	// Timer/PWM Module
	TPM1 = (*TPM_Type)(unsafe.Pointer(uintptr(0x400c9000)))

	// Timer/PWM Module
	TPM2 = (*TPM_Type)(unsafe.Pointer(uintptr(0x400ca000)))

	// 12-Bit Digital-to-Analog Converter
	DAC0 = (*DAC_Type)(unsafe.Pointer(uintptr(0x400cc000)))

	// 12-Bit Digital-to-Analog Converter
	DAC1 = (*DAC_Type)(unsafe.Pointer(uintptr(0x400cd000)))

	// General Purpose Input/Output
	GPIOA = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff000)))

	// General Purpose Input/Output
	GPIOB = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff040)))

	// General Purpose Input/Output
	GPIOC = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff080)))

	// General Purpose Input/Output
	GPIOD = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff0c0)))

	// General Purpose Input/Output
	GPIOE = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400ff100)))

	// System Control Block
	SystemControl = (*SystemControl_Type)(unsafe.Pointer(uintptr(0xe000e000)))

	// System timer
	SysTick = (*SysTick_Type)(unsafe.Pointer(uintptr(0xe000e010)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// Core Platform Miscellaneous Control Module
	MCM = (*MCM_Type)(unsafe.Pointer(uintptr(0xe0080000)))

	// Memory Mapped Cryptographic Acceleration Unit (MMCAU)
	CAU = (*CAU_Type)(unsafe.Pointer(uintptr(0xe0081000)))

	// Local Memory Controller
	LMEM = (*LMEM_Type)(unsafe.Pointer(uintptr(0xe0082000)))
)

// Flash configuration field
type FTFE_FlashConfig_Type struct {
	BACKKEY3 volatile.Register8 // 0x0
	BACKKEY2 volatile.Register8 // 0x1
	BACKKEY1 volatile.Register8 // 0x2
	BACKKEY0 volatile.Register8 // 0x3
	BACKKEY7 volatile.Register8 // 0x4
	BACKKEY6 volatile.Register8 // 0x5
	BACKKEY5 volatile.Register8 // 0x6
	BACKKEY4 volatile.Register8 // 0x7
	FPROT3   volatile.Register8 // 0x8
	FPROT2   volatile.Register8 // 0x9
	FPROT1   volatile.Register8 // 0xA
	FPROT0   volatile.Register8 // 0xB
	FSEC     volatile.Register8 // 0xC
	FOPT     volatile.Register8 // 0xD
	FEPROT   volatile.Register8 // 0xE
	FDPROT   volatile.Register8 // 0xF
}

// FTFE_FlashConfig.BACKKEY3: Backdoor Comparison Key 3.
func (o *FTFE_FlashConfig_Type) SetBACKKEY3(value uint8) {
	volatile.StoreUint8(&o.BACKKEY3.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY3() uint8 {
	return volatile.LoadUint8(&o.BACKKEY3.Reg)
}

// FTFE_FlashConfig.BACKKEY2: Backdoor Comparison Key 2.
func (o *FTFE_FlashConfig_Type) SetBACKKEY2(value uint8) {
	volatile.StoreUint8(&o.BACKKEY2.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY2() uint8 {
	return volatile.LoadUint8(&o.BACKKEY2.Reg)
}

// FTFE_FlashConfig.BACKKEY1: Backdoor Comparison Key 1.
func (o *FTFE_FlashConfig_Type) SetBACKKEY1(value uint8) {
	volatile.StoreUint8(&o.BACKKEY1.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY1() uint8 {
	return volatile.LoadUint8(&o.BACKKEY1.Reg)
}

// FTFE_FlashConfig.BACKKEY0: Backdoor Comparison Key 0.
func (o *FTFE_FlashConfig_Type) SetBACKKEY0(value uint8) {
	volatile.StoreUint8(&o.BACKKEY0.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY0() uint8 {
	return volatile.LoadUint8(&o.BACKKEY0.Reg)
}

// FTFE_FlashConfig.BACKKEY7: Backdoor Comparison Key 7.
func (o *FTFE_FlashConfig_Type) SetBACKKEY7(value uint8) {
	volatile.StoreUint8(&o.BACKKEY7.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY7() uint8 {
	return volatile.LoadUint8(&o.BACKKEY7.Reg)
}

// FTFE_FlashConfig.BACKKEY6: Backdoor Comparison Key 6.
func (o *FTFE_FlashConfig_Type) SetBACKKEY6(value uint8) {
	volatile.StoreUint8(&o.BACKKEY6.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY6() uint8 {
	return volatile.LoadUint8(&o.BACKKEY6.Reg)
}

// FTFE_FlashConfig.BACKKEY5: Backdoor Comparison Key 5.
func (o *FTFE_FlashConfig_Type) SetBACKKEY5(value uint8) {
	volatile.StoreUint8(&o.BACKKEY5.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY5() uint8 {
	return volatile.LoadUint8(&o.BACKKEY5.Reg)
}

// FTFE_FlashConfig.BACKKEY4: Backdoor Comparison Key 4.
func (o *FTFE_FlashConfig_Type) SetBACKKEY4(value uint8) {
	volatile.StoreUint8(&o.BACKKEY4.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetBACKKEY4() uint8 {
	return volatile.LoadUint8(&o.BACKKEY4.Reg)
}

// FTFE_FlashConfig.FPROT3: Non-volatile P-Flash Protection 1 - Low Register
func (o *FTFE_FlashConfig_Type) SetFPROT3(value uint8) {
	volatile.StoreUint8(&o.FPROT3.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFPROT3() uint8 {
	return volatile.LoadUint8(&o.FPROT3.Reg)
}

// FTFE_FlashConfig.FPROT2: Non-volatile P-Flash Protection 1 - High Register
func (o *FTFE_FlashConfig_Type) SetFPROT2(value uint8) {
	volatile.StoreUint8(&o.FPROT2.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFPROT2() uint8 {
	return volatile.LoadUint8(&o.FPROT2.Reg)
}

// FTFE_FlashConfig.FPROT1: Non-volatile P-Flash Protection 0 - Low Register
func (o *FTFE_FlashConfig_Type) SetFPROT1(value uint8) {
	volatile.StoreUint8(&o.FPROT1.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFPROT1() uint8 {
	return volatile.LoadUint8(&o.FPROT1.Reg)
}

// FTFE_FlashConfig.FPROT0: Non-volatile P-Flash Protection 0 - High Register
func (o *FTFE_FlashConfig_Type) SetFPROT0(value uint8) {
	volatile.StoreUint8(&o.FPROT0.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFPROT0() uint8 {
	return volatile.LoadUint8(&o.FPROT0.Reg)
}

// FTFE_FlashConfig.FSEC: Non-volatile Flash Security Register
func (o *FTFE_FlashConfig_Type) SetFSEC_SEC(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0x3)|value)
}
func (o *FTFE_FlashConfig_Type) GetFSEC_SEC() uint8 {
	return volatile.LoadUint8(&o.FSEC.Reg) & 0x3
}
func (o *FTFE_FlashConfig_Type) SetFSEC_FSLACC(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0xc)|value<<2)
}
func (o *FTFE_FlashConfig_Type) GetFSEC_FSLACC() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0xc) >> 2
}
func (o *FTFE_FlashConfig_Type) SetFSEC_MEEN(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0x30)|value<<4)
}
func (o *FTFE_FlashConfig_Type) GetFSEC_MEEN() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0x30) >> 4
}
func (o *FTFE_FlashConfig_Type) SetFSEC_KEYEN(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0xc0)|value<<6)
}
func (o *FTFE_FlashConfig_Type) GetFSEC_KEYEN() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0xc0) >> 6
}

// FTFE_FlashConfig.FOPT: Non-volatile Flash Option Register
func (o *FTFE_FlashConfig_Type) SetFOPT_LPBOOT(value uint8) {
	volatile.StoreUint8(&o.FOPT.Reg, volatile.LoadUint8(&o.FOPT.Reg)&^(0x1)|value)
}
func (o *FTFE_FlashConfig_Type) GetFOPT_LPBOOT() uint8 {
	return volatile.LoadUint8(&o.FOPT.Reg) & 0x1
}
func (o *FTFE_FlashConfig_Type) SetFOPT_EZPORT_DIS(value uint8) {
	volatile.StoreUint8(&o.FOPT.Reg, volatile.LoadUint8(&o.FOPT.Reg)&^(0x2)|value<<1)
}
func (o *FTFE_FlashConfig_Type) GetFOPT_EZPORT_DIS() uint8 {
	return (volatile.LoadUint8(&o.FOPT.Reg) & 0x2) >> 1
}
func (o *FTFE_FlashConfig_Type) SetFOPT_NMI_DIS(value uint8) {
	volatile.StoreUint8(&o.FOPT.Reg, volatile.LoadUint8(&o.FOPT.Reg)&^(0x4)|value<<2)
}
func (o *FTFE_FlashConfig_Type) GetFOPT_NMI_DIS() uint8 {
	return (volatile.LoadUint8(&o.FOPT.Reg) & 0x4) >> 2
}

// FTFE_FlashConfig.FEPROT: Non-volatile EERAM Protection Register
func (o *FTFE_FlashConfig_Type) SetFEPROT(value uint8) {
	volatile.StoreUint8(&o.FEPROT.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFEPROT() uint8 {
	return volatile.LoadUint8(&o.FEPROT.Reg)
}

// FTFE_FlashConfig.FDPROT: Non-volatile D-Flash Protection Register
func (o *FTFE_FlashConfig_Type) SetFDPROT(value uint8) {
	volatile.StoreUint8(&o.FDPROT.Reg, value)
}
func (o *FTFE_FlashConfig_Type) GetFDPROT() uint8 {
	return volatile.LoadUint8(&o.FDPROT.Reg)
}

// AIPS-Lite Bridge
type AIPS_Type struct {
	MPRA  volatile.Register32 // 0x0
	_     [28]byte
	PACRA volatile.Register32 // 0x20
	PACRB volatile.Register32 // 0x24
	PACRC volatile.Register32 // 0x28
	PACRD volatile.Register32 // 0x2C
	_     [16]byte
	PACRE volatile.Register32 // 0x40
	PACRF volatile.Register32 // 0x44
	PACRG volatile.Register32 // 0x48
	PACRH volatile.Register32 // 0x4C
	PACRI volatile.Register32 // 0x50
	PACRJ volatile.Register32 // 0x54
	PACRK volatile.Register32 // 0x58
	PACRL volatile.Register32 // 0x5C
	PACRM volatile.Register32 // 0x60
	PACRN volatile.Register32 // 0x64
	PACRO volatile.Register32 // 0x68
	PACRP volatile.Register32 // 0x6C
}

// AIPS.MPRA: Master Privilege Register A
func (o *AIPS_Type) SetMPRA_MPL6(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetMPRA_MPL6() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetMPRA_MTW6(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetMPRA_MTW6() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetMPRA_MTR6(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetMPRA_MTR6() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetMPRA_MPL5(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetMPRA_MPL5() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetMPRA_MTW5(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetMPRA_MTW5() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetMPRA_MTR5(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetMPRA_MTR5() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetMPRA_MPL4(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetMPRA_MPL4() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetMPRA_MTW4(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetMPRA_MTW4() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetMPRA_MTR4(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetMPRA_MTR4() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetMPRA_MPL3(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetMPRA_MPL3() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetMPRA_MTW3(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetMPRA_MTW3() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetMPRA_MTR3(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetMPRA_MTR3() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetMPRA_MPL2(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetMPRA_MPL2() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetMPRA_MTW2(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetMPRA_MTW2() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetMPRA_MTR2(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetMPRA_MTR2() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetMPRA_MPL1(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetMPRA_MPL1() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetMPRA_MTW1(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetMPRA_MTW1() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetMPRA_MTR1(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetMPRA_MTR1() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetMPRA_MPL0(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetMPRA_MPL0() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetMPRA_MTW0(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetMPRA_MTW0() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetMPRA_MTR0(value uint32) {
	volatile.StoreUint32(&o.MPRA.Reg, volatile.LoadUint32(&o.MPRA.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetMPRA_MTR0() uint32 {
	return (volatile.LoadUint32(&o.MPRA.Reg) & 0x40000000) >> 30
}

// AIPS.PACRA: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRA_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRA_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRA.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRA_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRA_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRA_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRA_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRA_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRA_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRA_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRA_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRA_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRA_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRA_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRA_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRA_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRA_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRA_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRA_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRA_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRA_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRA_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRA_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRA_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRA_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRA_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRA_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRA_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRA_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRA_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRA_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRA_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRA_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRA_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRA_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRA_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRA_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRA_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRA_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRA_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRA_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRA_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRA_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRA_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRA_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRA_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRA_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRA_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRA.Reg, volatile.LoadUint32(&o.PACRA.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRA_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRA.Reg) & 0x40000000) >> 30
}

// AIPS.PACRB: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRB_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRB_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRB.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRB_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRB_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRB_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRB_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRB_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRB_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRB_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRB_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRB_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRB_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRB_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRB_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRB_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRB_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRB_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRB_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRB_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRB_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRB_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRB_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRB_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRB_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRB_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRB_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRB_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRB_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRB_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRB_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRB_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRB_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRB_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRB_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRB_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRB_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRB_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRB_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRB_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRB_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRB_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRB_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRB_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRB_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRB_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRB_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRB_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRB.Reg, volatile.LoadUint32(&o.PACRB.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRB_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRB.Reg) & 0x40000000) >> 30
}

// AIPS.PACRC: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRC_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRC_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRC.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRC_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRC_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRC_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRC_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRC_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRC_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRC_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRC_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRC_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRC_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRC_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRC_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRC_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRC_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRC_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRC_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRC_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRC_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRC_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRC_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRC_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRC_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRC_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRC_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRC_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRC_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRC_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRC_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRC_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRC_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRC_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRC_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRC_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRC_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRC_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRC_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRC_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRC_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRC_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRC_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRC_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRC_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRC_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRC_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRC_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRC.Reg, volatile.LoadUint32(&o.PACRC.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRC_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRC.Reg) & 0x40000000) >> 30
}

// AIPS.PACRD: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRD_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRD_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRD.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRD_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRD_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRD_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRD_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRD_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRD_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRD_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRD_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRD_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRD_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRD_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRD_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRD_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRD_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRD_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRD_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRD_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRD_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRD_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRD_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRD_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRD_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRD_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRD_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRD_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRD_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRD_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRD_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRD_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRD_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRD_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRD_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRD_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRD_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRD_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRD_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRD_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRD_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRD_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRD_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRD_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRD_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRD_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRD_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRD_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRD.Reg, volatile.LoadUint32(&o.PACRD.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRD_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRD.Reg) & 0x40000000) >> 30
}

// AIPS.PACRE: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRE_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRE_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRE.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRE_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRE_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRE_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRE_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRE_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRE_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRE_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRE_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRE_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRE_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRE_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRE_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRE_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRE_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRE_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRE_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRE_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRE_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRE_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRE_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRE_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRE_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRE_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRE_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRE_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRE_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRE_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRE_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRE_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRE_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRE_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRE_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRE_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRE_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRE_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRE_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRE_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRE_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRE_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRE_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRE_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRE_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRE_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRE_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRE_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRE.Reg, volatile.LoadUint32(&o.PACRE.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRE_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRE.Reg) & 0x40000000) >> 30
}

// AIPS.PACRF: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRF_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRF_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRF.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRF_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRF_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRF_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRF_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRF_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRF_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRF_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRF_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRF_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRF_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRF_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRF_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRF_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRF_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRF_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRF_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRF_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRF_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRF_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRF_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRF_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRF_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRF_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRF_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRF_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRF_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRF_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRF_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRF_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRF_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRF_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRF_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRF_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRF_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRF_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRF_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRF_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRF_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRF_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRF_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRF_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRF_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRF_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRF_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRF_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRF.Reg, volatile.LoadUint32(&o.PACRF.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRF_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRF.Reg) & 0x40000000) >> 30
}

// AIPS.PACRG: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRG_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRG_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRG.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRG_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRG_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRG_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRG_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRG_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRG_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRG_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRG_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRG_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRG_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRG_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRG_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRG_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRG_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRG_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRG_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRG_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRG_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRG_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRG_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRG_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRG_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRG_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRG_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRG_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRG_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRG_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRG_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRG_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRG_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRG_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRG_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRG_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRG_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRG_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRG_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRG_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRG_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRG_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRG_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRG_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRG_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRG_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRG_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRG_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRG.Reg, volatile.LoadUint32(&o.PACRG.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRG_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRG.Reg) & 0x40000000) >> 30
}

// AIPS.PACRH: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRH_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRH_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRH.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRH_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRH_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRH_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRH_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRH_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRH_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRH_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRH_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRH_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRH_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRH_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRH_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRH_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRH_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRH_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRH_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRH_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRH_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRH_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRH_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRH_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRH_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRH_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRH_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRH_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRH_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRH_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRH_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRH_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRH_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRH_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRH_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRH_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRH_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRH_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRH_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRH_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRH_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRH_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRH_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRH_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRH_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRH_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRH_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRH_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRH.Reg, volatile.LoadUint32(&o.PACRH.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRH_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRH.Reg) & 0x40000000) >> 30
}

// AIPS.PACRI: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRI_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRI_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRI.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRI_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRI_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRI_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRI_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRI_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRI_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRI_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRI_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRI_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRI_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRI_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRI_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRI_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRI_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRI_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRI_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRI_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRI_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRI_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRI_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRI_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRI_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRI_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRI_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRI_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRI_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRI_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRI_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRI_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRI_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRI_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRI_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRI_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRI_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRI_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRI_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRI_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRI_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRI_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRI_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRI_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRI_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRI_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRI_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRI_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRI.Reg, volatile.LoadUint32(&o.PACRI.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRI_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRI.Reg) & 0x40000000) >> 30
}

// AIPS.PACRJ: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRJ_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRJ_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRJ.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRJ_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRJ_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRJ_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRJ_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRJ_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRJ_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRJ_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRJ_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRJ_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRJ_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRJ_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRJ_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRJ_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRJ_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRJ_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRJ_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRJ_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRJ_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRJ_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRJ_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRJ_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRJ_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRJ_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRJ_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRJ_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRJ_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRJ_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRJ_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRJ_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRJ_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRJ_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRJ_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRJ_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRJ_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRJ_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRJ_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRJ_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRJ_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRJ_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRJ_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRJ_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRJ_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRJ_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRJ_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRJ_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRJ.Reg, volatile.LoadUint32(&o.PACRJ.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRJ_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRJ.Reg) & 0x40000000) >> 30
}

// AIPS.PACRK: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRK_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRK_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRK.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRK_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRK_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRK_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRK_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRK_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRK_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRK_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRK_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRK_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRK_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRK_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRK_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRK_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRK_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRK_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRK_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRK_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRK_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRK_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRK_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRK_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRK_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRK_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRK_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRK_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRK_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRK_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRK_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRK_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRK_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRK_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRK_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRK_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRK_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRK_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRK_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRK_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRK_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRK_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRK_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRK_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRK_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRK_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRK_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRK_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRK.Reg, volatile.LoadUint32(&o.PACRK.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRK_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRK.Reg) & 0x40000000) >> 30
}

// AIPS.PACRL: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRL_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRL_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRL.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRL_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRL_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRL_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRL_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRL_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRL_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRL_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRL_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRL_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRL_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRL_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRL_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRL_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRL_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRL_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRL_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRL_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRL_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRL_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRL_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRL_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRL_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRL_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRL_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRL_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRL_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRL_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRL_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRL_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRL_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRL_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRL_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRL_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRL_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRL_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRL_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRL_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRL_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRL_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRL_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRL_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRL_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRL_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRL_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRL_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRL.Reg, volatile.LoadUint32(&o.PACRL.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRL_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRL.Reg) & 0x40000000) >> 30
}

// AIPS.PACRM: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRM_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRM_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRM.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRM_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRM_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRM_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRM_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRM_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRM_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRM_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRM_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRM_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRM_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRM_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRM_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRM_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRM_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRM_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRM_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRM_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRM_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRM_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRM_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRM_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRM_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRM_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRM_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRM_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRM_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRM_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRM_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRM_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRM_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRM_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRM_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRM_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRM_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRM_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRM_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRM_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRM_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRM_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRM_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRM_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRM_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRM_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRM_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRM_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRM.Reg, volatile.LoadUint32(&o.PACRM.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRM_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRM.Reg) & 0x40000000) >> 30
}

// AIPS.PACRN: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRN_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRN_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRN.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRN_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRN_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRN_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRN_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRN_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRN_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRN_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRN_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRN_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRN_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRN_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRN_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRN_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRN_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRN_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRN_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRN_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRN_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRN_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRN_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRN_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRN_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRN_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRN_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRN_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRN_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRN_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRN_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRN_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRN_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRN_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRN_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRN_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRN_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRN_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRN_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRN_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRN_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRN_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRN_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRN_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRN_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRN_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRN_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRN_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRN.Reg, volatile.LoadUint32(&o.PACRN.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRN_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRN.Reg) & 0x40000000) >> 30
}

// AIPS.PACRO: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRO_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRO_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRO.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRO_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRO_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRO_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRO_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRO_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRO_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRO_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRO_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRO_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRO_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRO_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRO_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRO_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRO_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRO_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRO_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRO_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRO_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRO_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRO_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRO_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRO_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRO_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRO_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRO_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRO_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRO_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRO_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRO_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRO_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRO_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRO_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRO_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRO_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRO_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRO_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRO_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRO_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRO_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRO_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRO_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRO_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRO_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRO_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRO_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRO.Reg, volatile.LoadUint32(&o.PACRO.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRO_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRO.Reg) & 0x40000000) >> 30
}

// AIPS.PACRP: Peripheral Access Control Register
func (o *AIPS_Type) SetPACRP_TP7(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x1)|value)
}
func (o *AIPS_Type) GetPACRP_TP7() uint32 {
	return volatile.LoadUint32(&o.PACRP.Reg) & 0x1
}
func (o *AIPS_Type) SetPACRP_WP7(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x2)|value<<1)
}
func (o *AIPS_Type) GetPACRP_WP7() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x2) >> 1
}
func (o *AIPS_Type) SetPACRP_SP7(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x4)|value<<2)
}
func (o *AIPS_Type) GetPACRP_SP7() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x4) >> 2
}
func (o *AIPS_Type) SetPACRP_TP6(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x10)|value<<4)
}
func (o *AIPS_Type) GetPACRP_TP6() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x10) >> 4
}
func (o *AIPS_Type) SetPACRP_WP6(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x20)|value<<5)
}
func (o *AIPS_Type) GetPACRP_WP6() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x20) >> 5
}
func (o *AIPS_Type) SetPACRP_SP6(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x40)|value<<6)
}
func (o *AIPS_Type) GetPACRP_SP6() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x40) >> 6
}
func (o *AIPS_Type) SetPACRP_TP5(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x100)|value<<8)
}
func (o *AIPS_Type) GetPACRP_TP5() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x100) >> 8
}
func (o *AIPS_Type) SetPACRP_WP5(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x200)|value<<9)
}
func (o *AIPS_Type) GetPACRP_WP5() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x200) >> 9
}
func (o *AIPS_Type) SetPACRP_SP5(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x400)|value<<10)
}
func (o *AIPS_Type) GetPACRP_SP5() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x400) >> 10
}
func (o *AIPS_Type) SetPACRP_TP4(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x1000)|value<<12)
}
func (o *AIPS_Type) GetPACRP_TP4() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x1000) >> 12
}
func (o *AIPS_Type) SetPACRP_WP4(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x2000)|value<<13)
}
func (o *AIPS_Type) GetPACRP_WP4() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x2000) >> 13
}
func (o *AIPS_Type) SetPACRP_SP4(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x4000)|value<<14)
}
func (o *AIPS_Type) GetPACRP_SP4() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x4000) >> 14
}
func (o *AIPS_Type) SetPACRP_TP3(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x10000)|value<<16)
}
func (o *AIPS_Type) GetPACRP_TP3() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x10000) >> 16
}
func (o *AIPS_Type) SetPACRP_WP3(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x20000)|value<<17)
}
func (o *AIPS_Type) GetPACRP_WP3() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x20000) >> 17
}
func (o *AIPS_Type) SetPACRP_SP3(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x40000)|value<<18)
}
func (o *AIPS_Type) GetPACRP_SP3() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x40000) >> 18
}
func (o *AIPS_Type) SetPACRP_TP2(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x100000)|value<<20)
}
func (o *AIPS_Type) GetPACRP_TP2() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x100000) >> 20
}
func (o *AIPS_Type) SetPACRP_WP2(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x200000)|value<<21)
}
func (o *AIPS_Type) GetPACRP_WP2() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x200000) >> 21
}
func (o *AIPS_Type) SetPACRP_SP2(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x400000)|value<<22)
}
func (o *AIPS_Type) GetPACRP_SP2() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x400000) >> 22
}
func (o *AIPS_Type) SetPACRP_TP1(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x1000000)|value<<24)
}
func (o *AIPS_Type) GetPACRP_TP1() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x1000000) >> 24
}
func (o *AIPS_Type) SetPACRP_WP1(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x2000000)|value<<25)
}
func (o *AIPS_Type) GetPACRP_WP1() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x2000000) >> 25
}
func (o *AIPS_Type) SetPACRP_SP1(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x4000000)|value<<26)
}
func (o *AIPS_Type) GetPACRP_SP1() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x4000000) >> 26
}
func (o *AIPS_Type) SetPACRP_TP0(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x10000000)|value<<28)
}
func (o *AIPS_Type) GetPACRP_TP0() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x10000000) >> 28
}
func (o *AIPS_Type) SetPACRP_WP0(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x20000000)|value<<29)
}
func (o *AIPS_Type) GetPACRP_WP0() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x20000000) >> 29
}
func (o *AIPS_Type) SetPACRP_SP0(value uint32) {
	volatile.StoreUint32(&o.PACRP.Reg, volatile.LoadUint32(&o.PACRP.Reg)&^(0x40000000)|value<<30)
}
func (o *AIPS_Type) GetPACRP_SP0() uint32 {
	return (volatile.LoadUint32(&o.PACRP.Reg) & 0x40000000) >> 30
}

// Crossbar switch
type AXBS_Type struct {
	PRS0   volatile.Register32 // 0x0
	_      [12]byte
	CRS0   volatile.Register32 // 0x10
	_      [236]byte
	PRS1   volatile.Register32 // 0x100
	_      [12]byte
	CRS1   volatile.Register32 // 0x110
	_      [236]byte
	PRS2   volatile.Register32 // 0x200
	_      [12]byte
	CRS2   volatile.Register32 // 0x210
	_      [236]byte
	PRS3   volatile.Register32 // 0x300
	_      [12]byte
	CRS3   volatile.Register32 // 0x310
	_      [236]byte
	PRS4   volatile.Register32 // 0x400
	_      [12]byte
	CRS4   volatile.Register32 // 0x410
	_      [1004]byte
	MGPCR0 volatile.Register32 // 0x800
	_      [252]byte
	MGPCR1 volatile.Register32 // 0x900
	_      [252]byte
	MGPCR2 volatile.Register32 // 0xA00
	_      [252]byte
	MGPCR3 volatile.Register32 // 0xB00
	_      [252]byte
	MGPCR4 volatile.Register32 // 0xC00
	_      [252]byte
	MGPCR5 volatile.Register32 // 0xD00
	_      [252]byte
	MGPCR6 volatile.Register32 // 0xE00
}

// AXBS.PRS0: Priority Registers Slave
func (o *AXBS_Type) SetPRS0_M0(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS0_M0() uint32 {
	return volatile.LoadUint32(&o.PRS0.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS0_M1(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS0_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS0_M2(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS0_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS0_M3(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS0_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS0_M4(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS0_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS0_M5(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS0_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x700000) >> 20
}
func (o *AXBS_Type) SetPRS0_M6(value uint32) {
	volatile.StoreUint32(&o.PRS0.Reg, volatile.LoadUint32(&o.PRS0.Reg)&^(0x7000000)|value<<24)
}
func (o *AXBS_Type) GetPRS0_M6() uint32 {
	return (volatile.LoadUint32(&o.PRS0.Reg) & 0x7000000) >> 24
}

// AXBS.CRS0: Control Register
func (o *AXBS_Type) SetCRS0_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS0_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS0.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS0_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS0_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS0.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS0_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS0_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS0.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS0_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS0_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS0.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS0_RO(value uint32) {
	volatile.StoreUint32(&o.CRS0.Reg, volatile.LoadUint32(&o.CRS0.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS0_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS0.Reg) & 0x80000000) >> 31
}

// AXBS.PRS1: Priority Registers Slave
func (o *AXBS_Type) SetPRS1_M0(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS1_M0() uint32 {
	return volatile.LoadUint32(&o.PRS1.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS1_M1(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS1_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS1_M2(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS1_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS1_M3(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS1_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS1_M4(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS1_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS1_M5(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS1_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x700000) >> 20
}
func (o *AXBS_Type) SetPRS1_M6(value uint32) {
	volatile.StoreUint32(&o.PRS1.Reg, volatile.LoadUint32(&o.PRS1.Reg)&^(0x7000000)|value<<24)
}
func (o *AXBS_Type) GetPRS1_M6() uint32 {
	return (volatile.LoadUint32(&o.PRS1.Reg) & 0x7000000) >> 24
}

// AXBS.CRS1: Control Register
func (o *AXBS_Type) SetCRS1_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS1_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS1.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS1_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS1_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS1.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS1_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS1_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS1.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS1_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS1_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS1.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS1_RO(value uint32) {
	volatile.StoreUint32(&o.CRS1.Reg, volatile.LoadUint32(&o.CRS1.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS1_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS1.Reg) & 0x80000000) >> 31
}

// AXBS.PRS2: Priority Registers Slave
func (o *AXBS_Type) SetPRS2_M0(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS2_M0() uint32 {
	return volatile.LoadUint32(&o.PRS2.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS2_M1(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS2_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS2_M2(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS2_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS2_M3(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS2_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS2_M4(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS2_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS2_M5(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS2_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x700000) >> 20
}
func (o *AXBS_Type) SetPRS2_M6(value uint32) {
	volatile.StoreUint32(&o.PRS2.Reg, volatile.LoadUint32(&o.PRS2.Reg)&^(0x7000000)|value<<24)
}
func (o *AXBS_Type) GetPRS2_M6() uint32 {
	return (volatile.LoadUint32(&o.PRS2.Reg) & 0x7000000) >> 24
}

// AXBS.CRS2: Control Register
func (o *AXBS_Type) SetCRS2_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS2_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS2.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS2_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS2_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS2.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS2_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS2_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS2.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS2_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS2_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS2.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS2_RO(value uint32) {
	volatile.StoreUint32(&o.CRS2.Reg, volatile.LoadUint32(&o.CRS2.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS2_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS2.Reg) & 0x80000000) >> 31
}

// AXBS.PRS3: Priority Registers Slave
func (o *AXBS_Type) SetPRS3_M0(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS3_M0() uint32 {
	return volatile.LoadUint32(&o.PRS3.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS3_M1(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS3_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS3_M2(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS3_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS3_M3(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS3_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS3_M4(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS3_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS3_M5(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS3_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x700000) >> 20
}
func (o *AXBS_Type) SetPRS3_M6(value uint32) {
	volatile.StoreUint32(&o.PRS3.Reg, volatile.LoadUint32(&o.PRS3.Reg)&^(0x7000000)|value<<24)
}
func (o *AXBS_Type) GetPRS3_M6() uint32 {
	return (volatile.LoadUint32(&o.PRS3.Reg) & 0x7000000) >> 24
}

// AXBS.CRS3: Control Register
func (o *AXBS_Type) SetCRS3_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS3_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS3.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS3_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS3_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS3.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS3_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS3_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS3.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS3_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS3_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS3.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS3_RO(value uint32) {
	volatile.StoreUint32(&o.CRS3.Reg, volatile.LoadUint32(&o.CRS3.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS3_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS3.Reg) & 0x80000000) >> 31
}

// AXBS.PRS4: Priority Registers Slave
func (o *AXBS_Type) SetPRS4_M0(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetPRS4_M0() uint32 {
	return volatile.LoadUint32(&o.PRS4.Reg) & 0x7
}
func (o *AXBS_Type) SetPRS4_M1(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x70)|value<<4)
}
func (o *AXBS_Type) GetPRS4_M1() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x70) >> 4
}
func (o *AXBS_Type) SetPRS4_M2(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x700)|value<<8)
}
func (o *AXBS_Type) GetPRS4_M2() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x700) >> 8
}
func (o *AXBS_Type) SetPRS4_M3(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x7000)|value<<12)
}
func (o *AXBS_Type) GetPRS4_M3() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x7000) >> 12
}
func (o *AXBS_Type) SetPRS4_M4(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x70000)|value<<16)
}
func (o *AXBS_Type) GetPRS4_M4() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x70000) >> 16
}
func (o *AXBS_Type) SetPRS4_M5(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x700000)|value<<20)
}
func (o *AXBS_Type) GetPRS4_M5() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x700000) >> 20
}
func (o *AXBS_Type) SetPRS4_M6(value uint32) {
	volatile.StoreUint32(&o.PRS4.Reg, volatile.LoadUint32(&o.PRS4.Reg)&^(0x7000000)|value<<24)
}
func (o *AXBS_Type) GetPRS4_M6() uint32 {
	return (volatile.LoadUint32(&o.PRS4.Reg) & 0x7000000) >> 24
}

// AXBS.CRS4: Control Register
func (o *AXBS_Type) SetCRS4_PARK(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetCRS4_PARK() uint32 {
	return volatile.LoadUint32(&o.CRS4.Reg) & 0x7
}
func (o *AXBS_Type) SetCRS4_PCTL(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x30)|value<<4)
}
func (o *AXBS_Type) GetCRS4_PCTL() uint32 {
	return (volatile.LoadUint32(&o.CRS4.Reg) & 0x30) >> 4
}
func (o *AXBS_Type) SetCRS4_ARB(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x300)|value<<8)
}
func (o *AXBS_Type) GetCRS4_ARB() uint32 {
	return (volatile.LoadUint32(&o.CRS4.Reg) & 0x300) >> 8
}
func (o *AXBS_Type) SetCRS4_HLP(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x40000000)|value<<30)
}
func (o *AXBS_Type) GetCRS4_HLP() uint32 {
	return (volatile.LoadUint32(&o.CRS4.Reg) & 0x40000000) >> 30
}
func (o *AXBS_Type) SetCRS4_RO(value uint32) {
	volatile.StoreUint32(&o.CRS4.Reg, volatile.LoadUint32(&o.CRS4.Reg)&^(0x80000000)|value<<31)
}
func (o *AXBS_Type) GetCRS4_RO() uint32 {
	return (volatile.LoadUint32(&o.CRS4.Reg) & 0x80000000) >> 31
}

// AXBS.MGPCR0: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR0_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR0.Reg, volatile.LoadUint32(&o.MGPCR0.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR0_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR0.Reg) & 0x7
}

// AXBS.MGPCR1: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR1_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR1.Reg, volatile.LoadUint32(&o.MGPCR1.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR1_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR1.Reg) & 0x7
}

// AXBS.MGPCR2: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR2_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR2.Reg, volatile.LoadUint32(&o.MGPCR2.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR2_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR2.Reg) & 0x7
}

// AXBS.MGPCR3: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR3_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR3.Reg, volatile.LoadUint32(&o.MGPCR3.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR3_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR3.Reg) & 0x7
}

// AXBS.MGPCR4: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR4_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR4.Reg, volatile.LoadUint32(&o.MGPCR4.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR4_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR4.Reg) & 0x7
}

// AXBS.MGPCR5: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR5_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR5.Reg, volatile.LoadUint32(&o.MGPCR5.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR5_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR5.Reg) & 0x7
}

// AXBS.MGPCR6: Master General Purpose Control Register
func (o *AXBS_Type) SetMGPCR6_AULB(value uint32) {
	volatile.StoreUint32(&o.MGPCR6.Reg, volatile.LoadUint32(&o.MGPCR6.Reg)&^(0x7)|value)
}
func (o *AXBS_Type) GetMGPCR6_AULB() uint32 {
	return volatile.LoadUint32(&o.MGPCR6.Reg) & 0x7
}

// Enhanced direct memory access controller
type DMA_Type struct {
	CR                  volatile.Register32 // 0x0
	ES                  volatile.Register32 // 0x4
	_                   [4]byte
	ERQ                 volatile.Register32 // 0xC
	_                   [4]byte
	EEI                 volatile.Register32 // 0x14
	CEEI                volatile.Register8  // 0x18
	SEEI                volatile.Register8  // 0x19
	CERQ                volatile.Register8  // 0x1A
	SERQ                volatile.Register8  // 0x1B
	CDNE                volatile.Register8  // 0x1C
	SSRT                volatile.Register8  // 0x1D
	CERR                volatile.Register8  // 0x1E
	CINT                volatile.Register8  // 0x1F
	_                   [4]byte
	INT                 volatile.Register32 // 0x24
	_                   [4]byte
	ERR                 volatile.Register32 // 0x2C
	_                   [4]byte
	HRS                 volatile.Register32 // 0x34
	_                   [12]byte
	EARS                volatile.Register32 // 0x44
	_                   [184]byte
	DCHPRI3             volatile.Register8 // 0x100
	DCHPRI2             volatile.Register8 // 0x101
	DCHPRI1             volatile.Register8 // 0x102
	DCHPRI0             volatile.Register8 // 0x103
	DCHPRI7             volatile.Register8 // 0x104
	DCHPRI6             volatile.Register8 // 0x105
	DCHPRI5             volatile.Register8 // 0x106
	DCHPRI4             volatile.Register8 // 0x107
	DCHPRI11            volatile.Register8 // 0x108
	DCHPRI10            volatile.Register8 // 0x109
	DCHPRI9             volatile.Register8 // 0x10A
	DCHPRI8             volatile.Register8 // 0x10B
	DCHPRI15            volatile.Register8 // 0x10C
	DCHPRI14            volatile.Register8 // 0x10D
	DCHPRI13            volatile.Register8 // 0x10E
	DCHPRI12            volatile.Register8 // 0x10F
	DCHPRI19            volatile.Register8 // 0x110
	DCHPRI18            volatile.Register8 // 0x111
	DCHPRI17            volatile.Register8 // 0x112
	DCHPRI16            volatile.Register8 // 0x113
	DCHPRI23            volatile.Register8 // 0x114
	DCHPRI22            volatile.Register8 // 0x115
	DCHPRI21            volatile.Register8 // 0x116
	DCHPRI20            volatile.Register8 // 0x117
	DCHPRI27            volatile.Register8 // 0x118
	DCHPRI26            volatile.Register8 // 0x119
	DCHPRI25            volatile.Register8 // 0x11A
	DCHPRI24            volatile.Register8 // 0x11B
	DCHPRI31            volatile.Register8 // 0x11C
	DCHPRI30            volatile.Register8 // 0x11D
	DCHPRI29            volatile.Register8 // 0x11E
	DCHPRI28            volatile.Register8 // 0x11F
	_                   [3808]byte
	TCD0_SADDR          volatile.Register32 // 0x1000
	TCD0_SOFF           volatile.Register16 // 0x1004
	TCD0_ATTR           volatile.Register16 // 0x1006
	TCD0_NBYTES_MLNO    volatile.Register32 // 0x1008
	TCD0_SLAST          volatile.Register32 // 0x100C
	TCD0_DADDR          volatile.Register32 // 0x1010
	TCD0_DOFF           volatile.Register16 // 0x1014
	TCD0_CITER_ELINKNO  volatile.Register16 // 0x1016
	TCD0_DLASTSGA       volatile.Register32 // 0x1018
	TCD0_CSR            volatile.Register16 // 0x101C
	TCD0_BITER_ELINKNO  volatile.Register16 // 0x101E
	TCD1_SADDR          volatile.Register32 // 0x1020
	TCD1_SOFF           volatile.Register16 // 0x1024
	TCD1_ATTR           volatile.Register16 // 0x1026
	TCD1_NBYTES_MLNO    volatile.Register32 // 0x1028
	TCD1_SLAST          volatile.Register32 // 0x102C
	TCD1_DADDR          volatile.Register32 // 0x1030
	TCD1_DOFF           volatile.Register16 // 0x1034
	TCD1_CITER_ELINKNO  volatile.Register16 // 0x1036
	TCD1_DLASTSGA       volatile.Register32 // 0x1038
	TCD1_CSR            volatile.Register16 // 0x103C
	TCD1_BITER_ELINKNO  volatile.Register16 // 0x103E
	TCD2_SADDR          volatile.Register32 // 0x1040
	TCD2_SOFF           volatile.Register16 // 0x1044
	TCD2_ATTR           volatile.Register16 // 0x1046
	TCD2_NBYTES_MLNO    volatile.Register32 // 0x1048
	TCD2_SLAST          volatile.Register32 // 0x104C
	TCD2_DADDR          volatile.Register32 // 0x1050
	TCD2_DOFF           volatile.Register16 // 0x1054
	TCD2_CITER_ELINKNO  volatile.Register16 // 0x1056
	TCD2_DLASTSGA       volatile.Register32 // 0x1058
	TCD2_CSR            volatile.Register16 // 0x105C
	TCD2_BITER_ELINKNO  volatile.Register16 // 0x105E
	TCD3_SADDR          volatile.Register32 // 0x1060
	TCD3_SOFF           volatile.Register16 // 0x1064
	TCD3_ATTR           volatile.Register16 // 0x1066
	TCD3_NBYTES_MLNO    volatile.Register32 // 0x1068
	TCD3_SLAST          volatile.Register32 // 0x106C
	TCD3_DADDR          volatile.Register32 // 0x1070
	TCD3_DOFF           volatile.Register16 // 0x1074
	TCD3_CITER_ELINKNO  volatile.Register16 // 0x1076
	TCD3_DLASTSGA       volatile.Register32 // 0x1078
	TCD3_CSR            volatile.Register16 // 0x107C
	TCD3_BITER_ELINKNO  volatile.Register16 // 0x107E
	TCD4_SADDR          volatile.Register32 // 0x1080
	TCD4_SOFF           volatile.Register16 // 0x1084
	TCD4_ATTR           volatile.Register16 // 0x1086
	TCD4_NBYTES_MLNO    volatile.Register32 // 0x1088
	TCD4_SLAST          volatile.Register32 // 0x108C
	TCD4_DADDR          volatile.Register32 // 0x1090
	TCD4_DOFF           volatile.Register16 // 0x1094
	TCD4_CITER_ELINKNO  volatile.Register16 // 0x1096
	TCD4_DLASTSGA       volatile.Register32 // 0x1098
	TCD4_CSR            volatile.Register16 // 0x109C
	TCD4_BITER_ELINKNO  volatile.Register16 // 0x109E
	TCD5_SADDR          volatile.Register32 // 0x10A0
	TCD5_SOFF           volatile.Register16 // 0x10A4
	TCD5_ATTR           volatile.Register16 // 0x10A6
	TCD5_NBYTES_MLNO    volatile.Register32 // 0x10A8
	TCD5_SLAST          volatile.Register32 // 0x10AC
	TCD5_DADDR          volatile.Register32 // 0x10B0
	TCD5_DOFF           volatile.Register16 // 0x10B4
	TCD5_CITER_ELINKNO  volatile.Register16 // 0x10B6
	TCD5_DLASTSGA       volatile.Register32 // 0x10B8
	TCD5_CSR            volatile.Register16 // 0x10BC
	TCD5_BITER_ELINKNO  volatile.Register16 // 0x10BE
	TCD6_SADDR          volatile.Register32 // 0x10C0
	TCD6_SOFF           volatile.Register16 // 0x10C4
	TCD6_ATTR           volatile.Register16 // 0x10C6
	TCD6_NBYTES_MLNO    volatile.Register32 // 0x10C8
	TCD6_SLAST          volatile.Register32 // 0x10CC
	TCD6_DADDR          volatile.Register32 // 0x10D0
	TCD6_DOFF           volatile.Register16 // 0x10D4
	TCD6_CITER_ELINKNO  volatile.Register16 // 0x10D6
	TCD6_DLASTSGA       volatile.Register32 // 0x10D8
	TCD6_CSR            volatile.Register16 // 0x10DC
	TCD6_BITER_ELINKNO  volatile.Register16 // 0x10DE
	TCD7_SADDR          volatile.Register32 // 0x10E0
	TCD7_SOFF           volatile.Register16 // 0x10E4
	TCD7_ATTR           volatile.Register16 // 0x10E6
	TCD7_NBYTES_MLNO    volatile.Register32 // 0x10E8
	TCD7_SLAST          volatile.Register32 // 0x10EC
	TCD7_DADDR          volatile.Register32 // 0x10F0
	TCD7_DOFF           volatile.Register16 // 0x10F4
	TCD7_CITER_ELINKNO  volatile.Register16 // 0x10F6
	TCD7_DLASTSGA       volatile.Register32 // 0x10F8
	TCD7_CSR            volatile.Register16 // 0x10FC
	TCD7_BITER_ELINKNO  volatile.Register16 // 0x10FE
	TCD8_SADDR          volatile.Register32 // 0x1100
	TCD8_SOFF           volatile.Register16 // 0x1104
	TCD8_ATTR           volatile.Register16 // 0x1106
	TCD8_NBYTES_MLNO    volatile.Register32 // 0x1108
	TCD8_SLAST          volatile.Register32 // 0x110C
	TCD8_DADDR          volatile.Register32 // 0x1110
	TCD8_DOFF           volatile.Register16 // 0x1114
	TCD8_CITER_ELINKNO  volatile.Register16 // 0x1116
	TCD8_DLASTSGA       volatile.Register32 // 0x1118
	TCD8_CSR            volatile.Register16 // 0x111C
	TCD8_BITER_ELINKNO  volatile.Register16 // 0x111E
	TCD9_SADDR          volatile.Register32 // 0x1120
	TCD9_SOFF           volatile.Register16 // 0x1124
	TCD9_ATTR           volatile.Register16 // 0x1126
	TCD9_NBYTES_MLNO    volatile.Register32 // 0x1128
	TCD9_SLAST          volatile.Register32 // 0x112C
	TCD9_DADDR          volatile.Register32 // 0x1130
	TCD9_DOFF           volatile.Register16 // 0x1134
	TCD9_CITER_ELINKNO  volatile.Register16 // 0x1136
	TCD9_DLASTSGA       volatile.Register32 // 0x1138
	TCD9_CSR            volatile.Register16 // 0x113C
	TCD9_BITER_ELINKNO  volatile.Register16 // 0x113E
	TCD10_SADDR         volatile.Register32 // 0x1140
	TCD10_SOFF          volatile.Register16 // 0x1144
	TCD10_ATTR          volatile.Register16 // 0x1146
	TCD10_NBYTES_MLNO   volatile.Register32 // 0x1148
	TCD10_SLAST         volatile.Register32 // 0x114C
	TCD10_DADDR         volatile.Register32 // 0x1150
	TCD10_DOFF          volatile.Register16 // 0x1154
	TCD10_CITER_ELINKNO volatile.Register16 // 0x1156
	TCD10_DLASTSGA      volatile.Register32 // 0x1158
	TCD10_CSR           volatile.Register16 // 0x115C
	TCD10_BITER_ELINKNO volatile.Register16 // 0x115E
	TCD11_SADDR         volatile.Register32 // 0x1160
	TCD11_SOFF          volatile.Register16 // 0x1164
	TCD11_ATTR          volatile.Register16 // 0x1166
	TCD11_NBYTES_MLNO   volatile.Register32 // 0x1168
	TCD11_SLAST         volatile.Register32 // 0x116C
	TCD11_DADDR         volatile.Register32 // 0x1170
	TCD11_DOFF          volatile.Register16 // 0x1174
	TCD11_CITER_ELINKNO volatile.Register16 // 0x1176
	TCD11_DLASTSGA      volatile.Register32 // 0x1178
	TCD11_CSR           volatile.Register16 // 0x117C
	TCD11_BITER_ELINKNO volatile.Register16 // 0x117E
	TCD12_SADDR         volatile.Register32 // 0x1180
	TCD12_SOFF          volatile.Register16 // 0x1184
	TCD12_ATTR          volatile.Register16 // 0x1186
	TCD12_NBYTES_MLNO   volatile.Register32 // 0x1188
	TCD12_SLAST         volatile.Register32 // 0x118C
	TCD12_DADDR         volatile.Register32 // 0x1190
	TCD12_DOFF          volatile.Register16 // 0x1194
	TCD12_CITER_ELINKNO volatile.Register16 // 0x1196
	TCD12_DLASTSGA      volatile.Register32 // 0x1198
	TCD12_CSR           volatile.Register16 // 0x119C
	TCD12_BITER_ELINKNO volatile.Register16 // 0x119E
	TCD13_SADDR         volatile.Register32 // 0x11A0
	TCD13_SOFF          volatile.Register16 // 0x11A4
	TCD13_ATTR          volatile.Register16 // 0x11A6
	TCD13_NBYTES_MLNO   volatile.Register32 // 0x11A8
	TCD13_SLAST         volatile.Register32 // 0x11AC
	TCD13_DADDR         volatile.Register32 // 0x11B0
	TCD13_DOFF          volatile.Register16 // 0x11B4
	TCD13_CITER_ELINKNO volatile.Register16 // 0x11B6
	TCD13_DLASTSGA      volatile.Register32 // 0x11B8
	TCD13_CSR           volatile.Register16 // 0x11BC
	TCD13_BITER_ELINKNO volatile.Register16 // 0x11BE
	TCD14_SADDR         volatile.Register32 // 0x11C0
	TCD14_SOFF          volatile.Register16 // 0x11C4
	TCD14_ATTR          volatile.Register16 // 0x11C6
	TCD14_NBYTES_MLNO   volatile.Register32 // 0x11C8
	TCD14_SLAST         volatile.Register32 // 0x11CC
	TCD14_DADDR         volatile.Register32 // 0x11D0
	TCD14_DOFF          volatile.Register16 // 0x11D4
	TCD14_CITER_ELINKNO volatile.Register16 // 0x11D6
	TCD14_DLASTSGA      volatile.Register32 // 0x11D8
	TCD14_CSR           volatile.Register16 // 0x11DC
	TCD14_BITER_ELINKNO volatile.Register16 // 0x11DE
	TCD15_SADDR         volatile.Register32 // 0x11E0
	TCD15_SOFF          volatile.Register16 // 0x11E4
	TCD15_ATTR          volatile.Register16 // 0x11E6
	TCD15_NBYTES_MLNO   volatile.Register32 // 0x11E8
	TCD15_SLAST         volatile.Register32 // 0x11EC
	TCD15_DADDR         volatile.Register32 // 0x11F0
	TCD15_DOFF          volatile.Register16 // 0x11F4
	TCD15_CITER_ELINKNO volatile.Register16 // 0x11F6
	TCD15_DLASTSGA      volatile.Register32 // 0x11F8
	TCD15_CSR           volatile.Register16 // 0x11FC
	TCD15_BITER_ELINKNO volatile.Register16 // 0x11FE
	TCD16_SADDR         volatile.Register32 // 0x1200
	TCD16_SOFF          volatile.Register16 // 0x1204
	TCD16_ATTR          volatile.Register16 // 0x1206
	TCD16_NBYTES_MLNO   volatile.Register32 // 0x1208
	TCD16_SLAST         volatile.Register32 // 0x120C
	TCD16_DADDR         volatile.Register32 // 0x1210
	TCD16_DOFF          volatile.Register16 // 0x1214
	TCD16_CITER_ELINKNO volatile.Register16 // 0x1216
	TCD16_DLASTSGA      volatile.Register32 // 0x1218
	TCD16_CSR           volatile.Register16 // 0x121C
	TCD16_BITER_ELINKNO volatile.Register16 // 0x121E
	TCD17_SADDR         volatile.Register32 // 0x1220
	TCD17_SOFF          volatile.Register16 // 0x1224
	TCD17_ATTR          volatile.Register16 // 0x1226
	TCD17_NBYTES_MLNO   volatile.Register32 // 0x1228
	TCD17_SLAST         volatile.Register32 // 0x122C
	TCD17_DADDR         volatile.Register32 // 0x1230
	TCD17_DOFF          volatile.Register16 // 0x1234
	TCD17_CITER_ELINKNO volatile.Register16 // 0x1236
	TCD17_DLASTSGA      volatile.Register32 // 0x1238
	TCD17_CSR           volatile.Register16 // 0x123C
	TCD17_BITER_ELINKNO volatile.Register16 // 0x123E
	TCD18_SADDR         volatile.Register32 // 0x1240
	TCD18_SOFF          volatile.Register16 // 0x1244
	TCD18_ATTR          volatile.Register16 // 0x1246
	TCD18_NBYTES_MLNO   volatile.Register32 // 0x1248
	TCD18_SLAST         volatile.Register32 // 0x124C
	TCD18_DADDR         volatile.Register32 // 0x1250
	TCD18_DOFF          volatile.Register16 // 0x1254
	TCD18_CITER_ELINKNO volatile.Register16 // 0x1256
	TCD18_DLASTSGA      volatile.Register32 // 0x1258
	TCD18_CSR           volatile.Register16 // 0x125C
	TCD18_BITER_ELINKNO volatile.Register16 // 0x125E
	TCD19_SADDR         volatile.Register32 // 0x1260
	TCD19_SOFF          volatile.Register16 // 0x1264
	TCD19_ATTR          volatile.Register16 // 0x1266
	TCD19_NBYTES_MLNO   volatile.Register32 // 0x1268
	TCD19_SLAST         volatile.Register32 // 0x126C
	TCD19_DADDR         volatile.Register32 // 0x1270
	TCD19_DOFF          volatile.Register16 // 0x1274
	TCD19_CITER_ELINKNO volatile.Register16 // 0x1276
	TCD19_DLASTSGA      volatile.Register32 // 0x1278
	TCD19_CSR           volatile.Register16 // 0x127C
	TCD19_BITER_ELINKNO volatile.Register16 // 0x127E
	TCD20_SADDR         volatile.Register32 // 0x1280
	TCD20_SOFF          volatile.Register16 // 0x1284
	TCD20_ATTR          volatile.Register16 // 0x1286
	TCD20_NBYTES_MLNO   volatile.Register32 // 0x1288
	TCD20_SLAST         volatile.Register32 // 0x128C
	TCD20_DADDR         volatile.Register32 // 0x1290
	TCD20_DOFF          volatile.Register16 // 0x1294
	TCD20_CITER_ELINKNO volatile.Register16 // 0x1296
	TCD20_DLASTSGA      volatile.Register32 // 0x1298
	TCD20_CSR           volatile.Register16 // 0x129C
	TCD20_BITER_ELINKNO volatile.Register16 // 0x129E
	TCD21_SADDR         volatile.Register32 // 0x12A0
	TCD21_SOFF          volatile.Register16 // 0x12A4
	TCD21_ATTR          volatile.Register16 // 0x12A6
	TCD21_NBYTES_MLNO   volatile.Register32 // 0x12A8
	TCD21_SLAST         volatile.Register32 // 0x12AC
	TCD21_DADDR         volatile.Register32 // 0x12B0
	TCD21_DOFF          volatile.Register16 // 0x12B4
	TCD21_CITER_ELINKNO volatile.Register16 // 0x12B6
	TCD21_DLASTSGA      volatile.Register32 // 0x12B8
	TCD21_CSR           volatile.Register16 // 0x12BC
	TCD21_BITER_ELINKNO volatile.Register16 // 0x12BE
	TCD22_SADDR         volatile.Register32 // 0x12C0
	TCD22_SOFF          volatile.Register16 // 0x12C4
	TCD22_ATTR          volatile.Register16 // 0x12C6
	TCD22_NBYTES_MLNO   volatile.Register32 // 0x12C8
	TCD22_SLAST         volatile.Register32 // 0x12CC
	TCD22_DADDR         volatile.Register32 // 0x12D0
	TCD22_DOFF          volatile.Register16 // 0x12D4
	TCD22_CITER_ELINKNO volatile.Register16 // 0x12D6
	TCD22_DLASTSGA      volatile.Register32 // 0x12D8
	TCD22_CSR           volatile.Register16 // 0x12DC
	TCD22_BITER_ELINKNO volatile.Register16 // 0x12DE
	TCD23_SADDR         volatile.Register32 // 0x12E0
	TCD23_SOFF          volatile.Register16 // 0x12E4
	TCD23_ATTR          volatile.Register16 // 0x12E6
	TCD23_NBYTES_MLNO   volatile.Register32 // 0x12E8
	TCD23_SLAST         volatile.Register32 // 0x12EC
	TCD23_DADDR         volatile.Register32 // 0x12F0
	TCD23_DOFF          volatile.Register16 // 0x12F4
	TCD23_CITER_ELINKNO volatile.Register16 // 0x12F6
	TCD23_DLASTSGA      volatile.Register32 // 0x12F8
	TCD23_CSR           volatile.Register16 // 0x12FC
	TCD23_BITER_ELINKNO volatile.Register16 // 0x12FE
	TCD24_SADDR         volatile.Register32 // 0x1300
	TCD24_SOFF          volatile.Register16 // 0x1304
	TCD24_ATTR          volatile.Register16 // 0x1306
	TCD24_NBYTES_MLNO   volatile.Register32 // 0x1308
	TCD24_SLAST         volatile.Register32 // 0x130C
	TCD24_DADDR         volatile.Register32 // 0x1310
	TCD24_DOFF          volatile.Register16 // 0x1314
	TCD24_CITER_ELINKNO volatile.Register16 // 0x1316
	TCD24_DLASTSGA      volatile.Register32 // 0x1318
	TCD24_CSR           volatile.Register16 // 0x131C
	TCD24_BITER_ELINKNO volatile.Register16 // 0x131E
	TCD25_SADDR         volatile.Register32 // 0x1320
	TCD25_SOFF          volatile.Register16 // 0x1324
	TCD25_ATTR          volatile.Register16 // 0x1326
	TCD25_NBYTES_MLNO   volatile.Register32 // 0x1328
	TCD25_SLAST         volatile.Register32 // 0x132C
	TCD25_DADDR         volatile.Register32 // 0x1330
	TCD25_DOFF          volatile.Register16 // 0x1334
	TCD25_CITER_ELINKNO volatile.Register16 // 0x1336
	TCD25_DLASTSGA      volatile.Register32 // 0x1338
	TCD25_CSR           volatile.Register16 // 0x133C
	TCD25_BITER_ELINKNO volatile.Register16 // 0x133E
	TCD26_SADDR         volatile.Register32 // 0x1340
	TCD26_SOFF          volatile.Register16 // 0x1344
	TCD26_ATTR          volatile.Register16 // 0x1346
	TCD26_NBYTES_MLNO   volatile.Register32 // 0x1348
	TCD26_SLAST         volatile.Register32 // 0x134C
	TCD26_DADDR         volatile.Register32 // 0x1350
	TCD26_DOFF          volatile.Register16 // 0x1354
	TCD26_CITER_ELINKNO volatile.Register16 // 0x1356
	TCD26_DLASTSGA      volatile.Register32 // 0x1358
	TCD26_CSR           volatile.Register16 // 0x135C
	TCD26_BITER_ELINKNO volatile.Register16 // 0x135E
	TCD27_SADDR         volatile.Register32 // 0x1360
	TCD27_SOFF          volatile.Register16 // 0x1364
	TCD27_ATTR          volatile.Register16 // 0x1366
	TCD27_NBYTES_MLNO   volatile.Register32 // 0x1368
	TCD27_SLAST         volatile.Register32 // 0x136C
	TCD27_DADDR         volatile.Register32 // 0x1370
	TCD27_DOFF          volatile.Register16 // 0x1374
	TCD27_CITER_ELINKNO volatile.Register16 // 0x1376
	TCD27_DLASTSGA      volatile.Register32 // 0x1378
	TCD27_CSR           volatile.Register16 // 0x137C
	TCD27_BITER_ELINKNO volatile.Register16 // 0x137E
	TCD28_SADDR         volatile.Register32 // 0x1380
	TCD28_SOFF          volatile.Register16 // 0x1384
	TCD28_ATTR          volatile.Register16 // 0x1386
	TCD28_NBYTES_MLNO   volatile.Register32 // 0x1388
	TCD28_SLAST         volatile.Register32 // 0x138C
	TCD28_DADDR         volatile.Register32 // 0x1390
	TCD28_DOFF          volatile.Register16 // 0x1394
	TCD28_CITER_ELINKNO volatile.Register16 // 0x1396
	TCD28_DLASTSGA      volatile.Register32 // 0x1398
	TCD28_CSR           volatile.Register16 // 0x139C
	TCD28_BITER_ELINKNO volatile.Register16 // 0x139E
	TCD29_SADDR         volatile.Register32 // 0x13A0
	TCD29_SOFF          volatile.Register16 // 0x13A4
	TCD29_ATTR          volatile.Register16 // 0x13A6
	TCD29_NBYTES_MLNO   volatile.Register32 // 0x13A8
	TCD29_SLAST         volatile.Register32 // 0x13AC
	TCD29_DADDR         volatile.Register32 // 0x13B0
	TCD29_DOFF          volatile.Register16 // 0x13B4
	TCD29_CITER_ELINKNO volatile.Register16 // 0x13B6
	TCD29_DLASTSGA      volatile.Register32 // 0x13B8
	TCD29_CSR           volatile.Register16 // 0x13BC
	TCD29_BITER_ELINKNO volatile.Register16 // 0x13BE
	TCD30_SADDR         volatile.Register32 // 0x13C0
	TCD30_SOFF          volatile.Register16 // 0x13C4
	TCD30_ATTR          volatile.Register16 // 0x13C6
	TCD30_NBYTES_MLNO   volatile.Register32 // 0x13C8
	TCD30_SLAST         volatile.Register32 // 0x13CC
	TCD30_DADDR         volatile.Register32 // 0x13D0
	TCD30_DOFF          volatile.Register16 // 0x13D4
	TCD30_CITER_ELINKNO volatile.Register16 // 0x13D6
	TCD30_DLASTSGA      volatile.Register32 // 0x13D8
	TCD30_CSR           volatile.Register16 // 0x13DC
	TCD30_BITER_ELINKNO volatile.Register16 // 0x13DE
	TCD31_SADDR         volatile.Register32 // 0x13E0
	TCD31_SOFF          volatile.Register16 // 0x13E4
	TCD31_ATTR          volatile.Register16 // 0x13E6
	TCD31_NBYTES_MLNO   volatile.Register32 // 0x13E8
	TCD31_SLAST         volatile.Register32 // 0x13EC
	TCD31_DADDR         volatile.Register32 // 0x13F0
	TCD31_DOFF          volatile.Register16 // 0x13F4
	TCD31_CITER_ELINKNO volatile.Register16 // 0x13F6
	TCD31_DLASTSGA      volatile.Register32 // 0x13F8
	TCD31_CSR           volatile.Register16 // 0x13FC
	TCD31_BITER_ELINKNO volatile.Register16 // 0x13FE
}

// DMA.CR: Control Register
func (o *DMA_Type) SetCR_EDBG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCR_EDBG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCR_ERCA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCR_ERCA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCR_ERGA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCR_ERGA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCR_HOE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCR_HOE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCR_HALT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCR_HALT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCR_CLM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCR_CLM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCR_EMLM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCR_EMLM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCR_GRP0PRI(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetCR_GRP0PRI() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetCR_GRP1PRI(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCR_GRP1PRI() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCR_ECX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetCR_ECX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetCR_CX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCR_CX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}

// DMA.ES: Error Status Register
func (o *DMA_Type) SetES_DBE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetES_DBE() uint32 {
	return volatile.LoadUint32(&o.ES.Reg) & 0x1
}
func (o *DMA_Type) SetES_SBE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetES_SBE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetES_SGE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetES_SGE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetES_NCE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetES_NCE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetES_DOE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetES_DOE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetES_DAE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetES_DAE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetES_SOE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetES_SOE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetES_SAE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetES_SAE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetES_ERRCHN(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetES_ERRCHN() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetES_CPE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetES_CPE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetES_GPE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetES_GPE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetES_ECX(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetES_ECX() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetES_VLD(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetES_VLD() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x80000000) >> 31
}

// DMA.ERQ: Enable Request Register
func (o *DMA_Type) SetERQ_ERQ0(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetERQ_ERQ0() uint32 {
	return volatile.LoadUint32(&o.ERQ.Reg) & 0x1
}
func (o *DMA_Type) SetERQ_ERQ1(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetERQ_ERQ1() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetERQ_ERQ2(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetERQ_ERQ2() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetERQ_ERQ3(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetERQ_ERQ3() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetERQ_ERQ4(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetERQ_ERQ4() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetERQ_ERQ5(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetERQ_ERQ5() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetERQ_ERQ6(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetERQ_ERQ6() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetERQ_ERQ7(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetERQ_ERQ7() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetERQ_ERQ8(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetERQ_ERQ8() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetERQ_ERQ9(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetERQ_ERQ9() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetERQ_ERQ10(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetERQ_ERQ10() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetERQ_ERQ11(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetERQ_ERQ11() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetERQ_ERQ12(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetERQ_ERQ12() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetERQ_ERQ13(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetERQ_ERQ13() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetERQ_ERQ14(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetERQ_ERQ14() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetERQ_ERQ15(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetERQ_ERQ15() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetERQ_ERQ16(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetERQ_ERQ16() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetERQ_ERQ17(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetERQ_ERQ17() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetERQ_ERQ18(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetERQ_ERQ18() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetERQ_ERQ19(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetERQ_ERQ19() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetERQ_ERQ20(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetERQ_ERQ20() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetERQ_ERQ21(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetERQ_ERQ21() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetERQ_ERQ22(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetERQ_ERQ22() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetERQ_ERQ23(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetERQ_ERQ23() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetERQ_ERQ24(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetERQ_ERQ24() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetERQ_ERQ25(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetERQ_ERQ25() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetERQ_ERQ26(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetERQ_ERQ26() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetERQ_ERQ27(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetERQ_ERQ27() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetERQ_ERQ28(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x10000000)|value<<28)
}
func (o *DMA_Type) GetERQ_ERQ28() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x10000000) >> 28
}
func (o *DMA_Type) SetERQ_ERQ29(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetERQ_ERQ29() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetERQ_ERQ30(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetERQ_ERQ30() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetERQ_ERQ31(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetERQ_ERQ31() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x80000000) >> 31
}

// DMA.EEI: Enable Error Interrupt Register
func (o *DMA_Type) SetEEI_EEI0(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetEEI_EEI0() uint32 {
	return volatile.LoadUint32(&o.EEI.Reg) & 0x1
}
func (o *DMA_Type) SetEEI_EEI1(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetEEI_EEI1() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetEEI_EEI2(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetEEI_EEI2() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetEEI_EEI3(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetEEI_EEI3() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetEEI_EEI4(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetEEI_EEI4() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetEEI_EEI5(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetEEI_EEI5() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetEEI_EEI6(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetEEI_EEI6() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetEEI_EEI7(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetEEI_EEI7() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetEEI_EEI8(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetEEI_EEI8() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetEEI_EEI9(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetEEI_EEI9() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetEEI_EEI10(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetEEI_EEI10() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetEEI_EEI11(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetEEI_EEI11() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetEEI_EEI12(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetEEI_EEI12() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetEEI_EEI13(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetEEI_EEI13() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetEEI_EEI14(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetEEI_EEI14() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetEEI_EEI15(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetEEI_EEI15() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetEEI_EEI16(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetEEI_EEI16() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetEEI_EEI17(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetEEI_EEI17() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetEEI_EEI18(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetEEI_EEI18() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetEEI_EEI19(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetEEI_EEI19() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetEEI_EEI20(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetEEI_EEI20() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetEEI_EEI21(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetEEI_EEI21() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetEEI_EEI22(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetEEI_EEI22() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetEEI_EEI23(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetEEI_EEI23() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetEEI_EEI24(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetEEI_EEI24() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetEEI_EEI25(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetEEI_EEI25() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetEEI_EEI26(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetEEI_EEI26() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetEEI_EEI27(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetEEI_EEI27() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetEEI_EEI28(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x10000000)|value<<28)
}
func (o *DMA_Type) GetEEI_EEI28() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x10000000) >> 28
}
func (o *DMA_Type) SetEEI_EEI29(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetEEI_EEI29() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetEEI_EEI30(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetEEI_EEI30() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetEEI_EEI31(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetEEI_EEI31() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x80000000) >> 31
}

// DMA.CEEI: Clear Enable Error Interrupt Register
func (o *DMA_Type) SetCEEI(value uint8) {
	volatile.StoreUint8(&o.CEEI.Reg, volatile.LoadUint8(&o.CEEI.Reg)&^(0x1f)|value)
}
func (o *DMA_Type) GetCEEI() uint8 {
	return volatile.LoadUint8(&o.CEEI.Reg) & 0x1f
}
func (o *DMA_Type) SetCEEI_CAEE(value uint8) {
	volatile.StoreUint8(&o.CEEI.Reg, volatile.LoadUint8(&o.CEEI.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCEEI_CAEE() uint8 {
	return (volatile.LoadUint8(&o.CEEI.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCEEI_NOP(value uint8) {
	volatile.StoreUint8(&o.CEEI.Reg, volatile.LoadUint8(&o.CEEI.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCEEI_NOP() uint8 {
	return (volatile.LoadUint8(&o.CEEI.Reg) & 0x80) >> 7
}

// DMA.SEEI: Set Enable Error Interrupt Register
func (o *DMA_Type) SetSEEI(value uint8) {
	volatile.StoreUint8(&o.SEEI.Reg, volatile.LoadUint8(&o.SEEI.Reg)&^(0x1f)|value)
}
func (o *DMA_Type) GetSEEI() uint8 {
	return volatile.LoadUint8(&o.SEEI.Reg) & 0x1f
}
func (o *DMA_Type) SetSEEI_SAEE(value uint8) {
	volatile.StoreUint8(&o.SEEI.Reg, volatile.LoadUint8(&o.SEEI.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetSEEI_SAEE() uint8 {
	return (volatile.LoadUint8(&o.SEEI.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetSEEI_NOP(value uint8) {
	volatile.StoreUint8(&o.SEEI.Reg, volatile.LoadUint8(&o.SEEI.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetSEEI_NOP() uint8 {
	return (volatile.LoadUint8(&o.SEEI.Reg) & 0x80) >> 7
}

// DMA.CERQ: Clear Enable Request Register
func (o *DMA_Type) SetCERQ(value uint8) {
	volatile.StoreUint8(&o.CERQ.Reg, volatile.LoadUint8(&o.CERQ.Reg)&^(0x1f)|value)
}
func (o *DMA_Type) GetCERQ() uint8 {
	return volatile.LoadUint8(&o.CERQ.Reg) & 0x1f
}
func (o *DMA_Type) SetCERQ_CAER(value uint8) {
	volatile.StoreUint8(&o.CERQ.Reg, volatile.LoadUint8(&o.CERQ.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCERQ_CAER() uint8 {
	return (volatile.LoadUint8(&o.CERQ.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCERQ_NOP(value uint8) {
	volatile.StoreUint8(&o.CERQ.Reg, volatile.LoadUint8(&o.CERQ.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCERQ_NOP() uint8 {
	return (volatile.LoadUint8(&o.CERQ.Reg) & 0x80) >> 7
}

// DMA.SERQ: Set Enable Request Register
func (o *DMA_Type) SetSERQ(value uint8) {
	volatile.StoreUint8(&o.SERQ.Reg, volatile.LoadUint8(&o.SERQ.Reg)&^(0x1f)|value)
}
func (o *DMA_Type) GetSERQ() uint8 {
	return volatile.LoadUint8(&o.SERQ.Reg) & 0x1f
}
func (o *DMA_Type) SetSERQ_SAER(value uint8) {
	volatile.StoreUint8(&o.SERQ.Reg, volatile.LoadUint8(&o.SERQ.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetSERQ_SAER() uint8 {
	return (volatile.LoadUint8(&o.SERQ.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetSERQ_NOP(value uint8) {
	volatile.StoreUint8(&o.SERQ.Reg, volatile.LoadUint8(&o.SERQ.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetSERQ_NOP() uint8 {
	return (volatile.LoadUint8(&o.SERQ.Reg) & 0x80) >> 7
}

// DMA.CDNE: Clear DONE Status Bit Register
func (o *DMA_Type) SetCDNE(value uint8) {
	volatile.StoreUint8(&o.CDNE.Reg, volatile.LoadUint8(&o.CDNE.Reg)&^(0x1f)|value)
}
func (o *DMA_Type) GetCDNE() uint8 {
	return volatile.LoadUint8(&o.CDNE.Reg) & 0x1f
}
func (o *DMA_Type) SetCDNE_CADN(value uint8) {
	volatile.StoreUint8(&o.CDNE.Reg, volatile.LoadUint8(&o.CDNE.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCDNE_CADN() uint8 {
	return (volatile.LoadUint8(&o.CDNE.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCDNE_NOP(value uint8) {
	volatile.StoreUint8(&o.CDNE.Reg, volatile.LoadUint8(&o.CDNE.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCDNE_NOP() uint8 {
	return (volatile.LoadUint8(&o.CDNE.Reg) & 0x80) >> 7
}

// DMA.SSRT: Set START Bit Register
func (o *DMA_Type) SetSSRT(value uint8) {
	volatile.StoreUint8(&o.SSRT.Reg, volatile.LoadUint8(&o.SSRT.Reg)&^(0x1f)|value)
}
func (o *DMA_Type) GetSSRT() uint8 {
	return volatile.LoadUint8(&o.SSRT.Reg) & 0x1f
}
func (o *DMA_Type) SetSSRT_SAST(value uint8) {
	volatile.StoreUint8(&o.SSRT.Reg, volatile.LoadUint8(&o.SSRT.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetSSRT_SAST() uint8 {
	return (volatile.LoadUint8(&o.SSRT.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetSSRT_NOP(value uint8) {
	volatile.StoreUint8(&o.SSRT.Reg, volatile.LoadUint8(&o.SSRT.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetSSRT_NOP() uint8 {
	return (volatile.LoadUint8(&o.SSRT.Reg) & 0x80) >> 7
}

// DMA.CERR: Clear Error Register
func (o *DMA_Type) SetCERR(value uint8) {
	volatile.StoreUint8(&o.CERR.Reg, volatile.LoadUint8(&o.CERR.Reg)&^(0x1f)|value)
}
func (o *DMA_Type) GetCERR() uint8 {
	return volatile.LoadUint8(&o.CERR.Reg) & 0x1f
}
func (o *DMA_Type) SetCERR_CAEI(value uint8) {
	volatile.StoreUint8(&o.CERR.Reg, volatile.LoadUint8(&o.CERR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCERR_CAEI() uint8 {
	return (volatile.LoadUint8(&o.CERR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCERR_NOP(value uint8) {
	volatile.StoreUint8(&o.CERR.Reg, volatile.LoadUint8(&o.CERR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCERR_NOP() uint8 {
	return (volatile.LoadUint8(&o.CERR.Reg) & 0x80) >> 7
}

// DMA.CINT: Clear Interrupt Request Register
func (o *DMA_Type) SetCINT(value uint8) {
	volatile.StoreUint8(&o.CINT.Reg, volatile.LoadUint8(&o.CINT.Reg)&^(0x1f)|value)
}
func (o *DMA_Type) GetCINT() uint8 {
	return volatile.LoadUint8(&o.CINT.Reg) & 0x1f
}
func (o *DMA_Type) SetCINT_CAIR(value uint8) {
	volatile.StoreUint8(&o.CINT.Reg, volatile.LoadUint8(&o.CINT.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCINT_CAIR() uint8 {
	return (volatile.LoadUint8(&o.CINT.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCINT_NOP(value uint8) {
	volatile.StoreUint8(&o.CINT.Reg, volatile.LoadUint8(&o.CINT.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCINT_NOP() uint8 {
	return (volatile.LoadUint8(&o.CINT.Reg) & 0x80) >> 7
}

// DMA.INT: Interrupt Request Register
func (o *DMA_Type) SetINT_INT0(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetINT_INT0() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0x1
}
func (o *DMA_Type) SetINT_INT1(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetINT_INT1() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetINT_INT2(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetINT_INT2() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetINT_INT3(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetINT_INT3() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetINT_INT4(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetINT_INT4() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetINT_INT5(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetINT_INT5() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetINT_INT6(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetINT_INT6() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetINT_INT7(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetINT_INT7() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetINT_INT8(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetINT_INT8() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetINT_INT9(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetINT_INT9() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetINT_INT10(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetINT_INT10() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetINT_INT11(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetINT_INT11() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetINT_INT12(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetINT_INT12() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetINT_INT13(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetINT_INT13() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetINT_INT14(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetINT_INT14() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetINT_INT15(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetINT_INT15() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetINT_INT16(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetINT_INT16() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetINT_INT17(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetINT_INT17() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetINT_INT18(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetINT_INT18() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetINT_INT19(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetINT_INT19() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetINT_INT20(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetINT_INT20() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetINT_INT21(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetINT_INT21() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetINT_INT22(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetINT_INT22() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetINT_INT23(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetINT_INT23() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetINT_INT24(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetINT_INT24() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetINT_INT25(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetINT_INT25() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetINT_INT26(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetINT_INT26() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetINT_INT27(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetINT_INT27() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetINT_INT28(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x10000000)|value<<28)
}
func (o *DMA_Type) GetINT_INT28() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x10000000) >> 28
}
func (o *DMA_Type) SetINT_INT29(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetINT_INT29() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetINT_INT30(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetINT_INT30() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetINT_INT31(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetINT_INT31() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x80000000) >> 31
}

// DMA.ERR: Error Register
func (o *DMA_Type) SetERR_ERR0(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetERR_ERR0() uint32 {
	return volatile.LoadUint32(&o.ERR.Reg) & 0x1
}
func (o *DMA_Type) SetERR_ERR1(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetERR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetERR_ERR2(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetERR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetERR_ERR3(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetERR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetERR_ERR4(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetERR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetERR_ERR5(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetERR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetERR_ERR6(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetERR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetERR_ERR7(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetERR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetERR_ERR8(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetERR_ERR8() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetERR_ERR9(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetERR_ERR9() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetERR_ERR10(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetERR_ERR10() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetERR_ERR11(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetERR_ERR11() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetERR_ERR12(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetERR_ERR12() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetERR_ERR13(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetERR_ERR13() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetERR_ERR14(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetERR_ERR14() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetERR_ERR15(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetERR_ERR15() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetERR_ERR16(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetERR_ERR16() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetERR_ERR17(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetERR_ERR17() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetERR_ERR18(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetERR_ERR18() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetERR_ERR19(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetERR_ERR19() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetERR_ERR20(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetERR_ERR20() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetERR_ERR21(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetERR_ERR21() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetERR_ERR22(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetERR_ERR22() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetERR_ERR23(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetERR_ERR23() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetERR_ERR24(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetERR_ERR24() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetERR_ERR25(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetERR_ERR25() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetERR_ERR26(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetERR_ERR26() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetERR_ERR27(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetERR_ERR27() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetERR_ERR28(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMA_Type) GetERR_ERR28() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x10000000) >> 28
}
func (o *DMA_Type) SetERR_ERR29(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetERR_ERR29() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetERR_ERR30(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetERR_ERR30() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetERR_ERR31(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetERR_ERR31() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x80000000) >> 31
}

// DMA.HRS: Hardware Request Status Register
func (o *DMA_Type) SetHRS_HRS0(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetHRS_HRS0() uint32 {
	return volatile.LoadUint32(&o.HRS.Reg) & 0x1
}
func (o *DMA_Type) SetHRS_HRS1(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetHRS_HRS1() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetHRS_HRS2(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetHRS_HRS2() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetHRS_HRS3(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetHRS_HRS3() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetHRS_HRS4(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetHRS_HRS4() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetHRS_HRS5(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetHRS_HRS5() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetHRS_HRS6(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetHRS_HRS6() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetHRS_HRS7(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetHRS_HRS7() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetHRS_HRS8(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetHRS_HRS8() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetHRS_HRS9(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetHRS_HRS9() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetHRS_HRS10(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetHRS_HRS10() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetHRS_HRS11(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetHRS_HRS11() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetHRS_HRS12(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetHRS_HRS12() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetHRS_HRS13(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetHRS_HRS13() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetHRS_HRS14(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetHRS_HRS14() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetHRS_HRS15(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetHRS_HRS15() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetHRS_HRS16(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetHRS_HRS16() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetHRS_HRS17(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetHRS_HRS17() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetHRS_HRS18(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetHRS_HRS18() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetHRS_HRS19(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetHRS_HRS19() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetHRS_HRS20(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetHRS_HRS20() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetHRS_HRS21(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetHRS_HRS21() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetHRS_HRS22(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetHRS_HRS22() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetHRS_HRS23(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetHRS_HRS23() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetHRS_HRS24(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetHRS_HRS24() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetHRS_HRS25(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetHRS_HRS25() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetHRS_HRS26(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetHRS_HRS26() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetHRS_HRS27(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetHRS_HRS27() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetHRS_HRS28(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x10000000)|value<<28)
}
func (o *DMA_Type) GetHRS_HRS28() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x10000000) >> 28
}
func (o *DMA_Type) SetHRS_HRS29(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetHRS_HRS29() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetHRS_HRS30(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetHRS_HRS30() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetHRS_HRS31(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetHRS_HRS31() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x80000000) >> 31
}

// DMA.EARS: Enable Asynchronous Request in Stop Register
func (o *DMA_Type) SetEARS_EDREQ_0(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetEARS_EDREQ_0() uint32 {
	return volatile.LoadUint32(&o.EARS.Reg) & 0x1
}
func (o *DMA_Type) SetEARS_EDREQ_1(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetEARS_EDREQ_1() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetEARS_EDREQ_2(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetEARS_EDREQ_2() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetEARS_EDREQ_3(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetEARS_EDREQ_3() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetEARS_EDREQ_4(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetEARS_EDREQ_4() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetEARS_EDREQ_5(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetEARS_EDREQ_5() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetEARS_EDREQ_6(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetEARS_EDREQ_6() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetEARS_EDREQ_7(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetEARS_EDREQ_7() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetEARS_EDREQ_8(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetEARS_EDREQ_8() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetEARS_EDREQ_9(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetEARS_EDREQ_9() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetEARS_EDREQ_10(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetEARS_EDREQ_10() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetEARS_EDREQ_11(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetEARS_EDREQ_11() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetEARS_EDREQ_12(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetEARS_EDREQ_12() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetEARS_EDREQ_13(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetEARS_EDREQ_13() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetEARS_EDREQ_14(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetEARS_EDREQ_14() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetEARS_EDREQ_15(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetEARS_EDREQ_15() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetEARS_EDREQ_16(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetEARS_EDREQ_16() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetEARS_EDREQ_17(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetEARS_EDREQ_17() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetEARS_EDREQ_18(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetEARS_EDREQ_18() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetEARS_EDREQ_19(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetEARS_EDREQ_19() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetEARS_EDREQ_20(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetEARS_EDREQ_20() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetEARS_EDREQ_21(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetEARS_EDREQ_21() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetEARS_EDREQ_22(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetEARS_EDREQ_22() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetEARS_EDREQ_23(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetEARS_EDREQ_23() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetEARS_EDREQ_24(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetEARS_EDREQ_24() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetEARS_EDREQ_25(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetEARS_EDREQ_25() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetEARS_EDREQ_26(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetEARS_EDREQ_26() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetEARS_EDREQ_27(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetEARS_EDREQ_27() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetEARS_EDREQ_28(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x10000000)|value<<28)
}
func (o *DMA_Type) GetEARS_EDREQ_28() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x10000000) >> 28
}
func (o *DMA_Type) SetEARS_EDREQ_29(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetEARS_EDREQ_29() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetEARS_EDREQ_30(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetEARS_EDREQ_30() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetEARS_EDREQ_31(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetEARS_EDREQ_31() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x80000000) >> 31
}

// DMA.DCHPRI3: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI3_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI3_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI3.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI3_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI3_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI3.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI3_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI3_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI3.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI3_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI3_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI3.Reg) & 0x80) >> 7
}

// DMA.DCHPRI2: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI2_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI2_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI2.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI2_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI2_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI2.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI2_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI2_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI2.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI2_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI2_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI2.Reg) & 0x80) >> 7
}

// DMA.DCHPRI1: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI1_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI1_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI1.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI1_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI1_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI1.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI1_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI1_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI1.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI1_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI1_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI1.Reg) & 0x80) >> 7
}

// DMA.DCHPRI0: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI0_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI0_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI0.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI0_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI0_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI0.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI0_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI0_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI0.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI0_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI0_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI0.Reg) & 0x80) >> 7
}

// DMA.DCHPRI7: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI7_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI7_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI7.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI7_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI7_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI7.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI7_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI7_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI7.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI7_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI7_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI7.Reg) & 0x80) >> 7
}

// DMA.DCHPRI6: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI6_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI6_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI6.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI6_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI6_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI6.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI6_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI6_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI6.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI6_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI6_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI6.Reg) & 0x80) >> 7
}

// DMA.DCHPRI5: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI5_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI5_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI5.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI5_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI5_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI5.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI5_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI5_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI5.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI5_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI5_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI5.Reg) & 0x80) >> 7
}

// DMA.DCHPRI4: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI4_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI4_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI4.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI4_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI4_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI4.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI4_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI4_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI4.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI4_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI4_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI4.Reg) & 0x80) >> 7
}

// DMA.DCHPRI11: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI11_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI11_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI11.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI11_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI11_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI11.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI11_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI11_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI11.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI11_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI11_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI11.Reg) & 0x80) >> 7
}

// DMA.DCHPRI10: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI10_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI10_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI10.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI10_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI10_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI10.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI10_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI10_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI10.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI10_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI10_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI10.Reg) & 0x80) >> 7
}

// DMA.DCHPRI9: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI9_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI9_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI9.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI9_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI9_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI9.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI9_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI9_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI9.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI9_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI9_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI9.Reg) & 0x80) >> 7
}

// DMA.DCHPRI8: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI8_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI8_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI8.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI8_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI8_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI8.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI8_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI8_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI8.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI8_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI8_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI8.Reg) & 0x80) >> 7
}

// DMA.DCHPRI15: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI15_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI15_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI15.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI15_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI15_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI15.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI15_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI15_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI15.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI15_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI15_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI15.Reg) & 0x80) >> 7
}

// DMA.DCHPRI14: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI14_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI14_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI14.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI14_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI14_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI14.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI14_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI14_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI14.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI14_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI14_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI14.Reg) & 0x80) >> 7
}

// DMA.DCHPRI13: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI13_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI13_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI13.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI13_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI13_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI13.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI13_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI13_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI13.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI13_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI13_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI13.Reg) & 0x80) >> 7
}

// DMA.DCHPRI12: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI12_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI12_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI12.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI12_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI12_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI12.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI12_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI12_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI12.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI12_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI12_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI12.Reg) & 0x80) >> 7
}

// DMA.DCHPRI19: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI19_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI19.Reg, volatile.LoadUint8(&o.DCHPRI19.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI19_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI19.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI19_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI19.Reg, volatile.LoadUint8(&o.DCHPRI19.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI19_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI19.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI19_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI19.Reg, volatile.LoadUint8(&o.DCHPRI19.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI19_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI19.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI19_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI19.Reg, volatile.LoadUint8(&o.DCHPRI19.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI19_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI19.Reg) & 0x80) >> 7
}

// DMA.DCHPRI18: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI18_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI18.Reg, volatile.LoadUint8(&o.DCHPRI18.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI18_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI18.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI18_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI18.Reg, volatile.LoadUint8(&o.DCHPRI18.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI18_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI18.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI18_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI18.Reg, volatile.LoadUint8(&o.DCHPRI18.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI18_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI18.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI18_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI18.Reg, volatile.LoadUint8(&o.DCHPRI18.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI18_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI18.Reg) & 0x80) >> 7
}

// DMA.DCHPRI17: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI17_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI17.Reg, volatile.LoadUint8(&o.DCHPRI17.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI17_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI17.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI17_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI17.Reg, volatile.LoadUint8(&o.DCHPRI17.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI17_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI17.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI17_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI17.Reg, volatile.LoadUint8(&o.DCHPRI17.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI17_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI17.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI17_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI17.Reg, volatile.LoadUint8(&o.DCHPRI17.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI17_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI17.Reg) & 0x80) >> 7
}

// DMA.DCHPRI16: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI16_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI16.Reg, volatile.LoadUint8(&o.DCHPRI16.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI16_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI16.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI16_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI16.Reg, volatile.LoadUint8(&o.DCHPRI16.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI16_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI16.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI16_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI16.Reg, volatile.LoadUint8(&o.DCHPRI16.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI16_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI16.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI16_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI16.Reg, volatile.LoadUint8(&o.DCHPRI16.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI16_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI16.Reg) & 0x80) >> 7
}

// DMA.DCHPRI23: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI23_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI23.Reg, volatile.LoadUint8(&o.DCHPRI23.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI23_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI23.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI23_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI23.Reg, volatile.LoadUint8(&o.DCHPRI23.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI23_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI23.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI23_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI23.Reg, volatile.LoadUint8(&o.DCHPRI23.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI23_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI23.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI23_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI23.Reg, volatile.LoadUint8(&o.DCHPRI23.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI23_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI23.Reg) & 0x80) >> 7
}

// DMA.DCHPRI22: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI22_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI22.Reg, volatile.LoadUint8(&o.DCHPRI22.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI22_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI22.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI22_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI22.Reg, volatile.LoadUint8(&o.DCHPRI22.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI22_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI22.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI22_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI22.Reg, volatile.LoadUint8(&o.DCHPRI22.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI22_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI22.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI22_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI22.Reg, volatile.LoadUint8(&o.DCHPRI22.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI22_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI22.Reg) & 0x80) >> 7
}

// DMA.DCHPRI21: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI21_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI21.Reg, volatile.LoadUint8(&o.DCHPRI21.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI21_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI21.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI21_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI21.Reg, volatile.LoadUint8(&o.DCHPRI21.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI21_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI21.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI21_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI21.Reg, volatile.LoadUint8(&o.DCHPRI21.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI21_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI21.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI21_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI21.Reg, volatile.LoadUint8(&o.DCHPRI21.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI21_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI21.Reg) & 0x80) >> 7
}

// DMA.DCHPRI20: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI20_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI20.Reg, volatile.LoadUint8(&o.DCHPRI20.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI20_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI20.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI20_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI20.Reg, volatile.LoadUint8(&o.DCHPRI20.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI20_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI20.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI20_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI20.Reg, volatile.LoadUint8(&o.DCHPRI20.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI20_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI20.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI20_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI20.Reg, volatile.LoadUint8(&o.DCHPRI20.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI20_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI20.Reg) & 0x80) >> 7
}

// DMA.DCHPRI27: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI27_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI27.Reg, volatile.LoadUint8(&o.DCHPRI27.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI27_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI27.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI27_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI27.Reg, volatile.LoadUint8(&o.DCHPRI27.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI27_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI27.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI27_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI27.Reg, volatile.LoadUint8(&o.DCHPRI27.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI27_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI27.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI27_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI27.Reg, volatile.LoadUint8(&o.DCHPRI27.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI27_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI27.Reg) & 0x80) >> 7
}

// DMA.DCHPRI26: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI26_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI26.Reg, volatile.LoadUint8(&o.DCHPRI26.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI26_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI26.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI26_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI26.Reg, volatile.LoadUint8(&o.DCHPRI26.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI26_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI26.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI26_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI26.Reg, volatile.LoadUint8(&o.DCHPRI26.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI26_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI26.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI26_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI26.Reg, volatile.LoadUint8(&o.DCHPRI26.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI26_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI26.Reg) & 0x80) >> 7
}

// DMA.DCHPRI25: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI25_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI25.Reg, volatile.LoadUint8(&o.DCHPRI25.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI25_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI25.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI25_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI25.Reg, volatile.LoadUint8(&o.DCHPRI25.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI25_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI25.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI25_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI25.Reg, volatile.LoadUint8(&o.DCHPRI25.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI25_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI25.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI25_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI25.Reg, volatile.LoadUint8(&o.DCHPRI25.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI25_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI25.Reg) & 0x80) >> 7
}

// DMA.DCHPRI24: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI24_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI24.Reg, volatile.LoadUint8(&o.DCHPRI24.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI24_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI24.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI24_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI24.Reg, volatile.LoadUint8(&o.DCHPRI24.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI24_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI24.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI24_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI24.Reg, volatile.LoadUint8(&o.DCHPRI24.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI24_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI24.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI24_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI24.Reg, volatile.LoadUint8(&o.DCHPRI24.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI24_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI24.Reg) & 0x80) >> 7
}

// DMA.DCHPRI31: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI31_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI31.Reg, volatile.LoadUint8(&o.DCHPRI31.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI31_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI31.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI31_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI31.Reg, volatile.LoadUint8(&o.DCHPRI31.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI31_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI31.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI31_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI31.Reg, volatile.LoadUint8(&o.DCHPRI31.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI31_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI31.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI31_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI31.Reg, volatile.LoadUint8(&o.DCHPRI31.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI31_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI31.Reg) & 0x80) >> 7
}

// DMA.DCHPRI30: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI30_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI30.Reg, volatile.LoadUint8(&o.DCHPRI30.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI30_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI30.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI30_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI30.Reg, volatile.LoadUint8(&o.DCHPRI30.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI30_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI30.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI30_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI30.Reg, volatile.LoadUint8(&o.DCHPRI30.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI30_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI30.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI30_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI30.Reg, volatile.LoadUint8(&o.DCHPRI30.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI30_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI30.Reg) & 0x80) >> 7
}

// DMA.DCHPRI29: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI29_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI29.Reg, volatile.LoadUint8(&o.DCHPRI29.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI29_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI29.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI29_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI29.Reg, volatile.LoadUint8(&o.DCHPRI29.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI29_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI29.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI29_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI29.Reg, volatile.LoadUint8(&o.DCHPRI29.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI29_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI29.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI29_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI29.Reg, volatile.LoadUint8(&o.DCHPRI29.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI29_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI29.Reg) & 0x80) >> 7
}

// DMA.DCHPRI28: Channel n Priority Register
func (o *DMA_Type) SetDCHPRI28_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI28.Reg, volatile.LoadUint8(&o.DCHPRI28.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI28_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI28.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI28_GRPPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI28.Reg, volatile.LoadUint8(&o.DCHPRI28.Reg)&^(0x30)|value<<4)
}
func (o *DMA_Type) GetDCHPRI28_GRPPRI() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI28.Reg) & 0x30) >> 4
}
func (o *DMA_Type) SetDCHPRI28_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI28.Reg, volatile.LoadUint8(&o.DCHPRI28.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI28_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI28.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI28_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI28.Reg, volatile.LoadUint8(&o.DCHPRI28.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI28_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI28.Reg) & 0x80) >> 7
}

// DMA.TCD0_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD0_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD0_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD0_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD0_SADDR.Reg)
}

// DMA.TCD0_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD0_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD0_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD0_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD0_SOFF.Reg)
}

// DMA.TCD0_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD0_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD0_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD0_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD0_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD0_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD0_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD0_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD0_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD0_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD0_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD0_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD0_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD0_NBYTES_MLNO.Reg)
}

// DMA.TCD0_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD0_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD0_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD0_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD0_SLAST.Reg)
}

// DMA.TCD0_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD0_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD0_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD0_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD0_DADDR.Reg)
}

// DMA.TCD0_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD0_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD0_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD0_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD0_DOFF.Reg)
}

// DMA.TCD0_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD0_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD0_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD0_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD0_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD0_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD0_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD0_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD0_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD0_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD0_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD0_DLASTSGA.Reg)
}

// DMA.TCD0_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD0_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD0_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD0_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD0_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD0_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD0_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD0_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD0_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD0_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD0_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD0_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD0_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD0_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD0_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD0_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD0_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD0_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD0_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD0_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD0_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD0_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD0_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD0_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD0_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD0_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD0_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD0_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD1_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD1_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD1_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD1_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD1_SADDR.Reg)
}

// DMA.TCD1_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD1_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD1_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD1_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD1_SOFF.Reg)
}

// DMA.TCD1_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD1_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD1_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD1_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD1_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD1_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD1_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD1_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD1_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD1_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD1_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD1_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD1_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD1_NBYTES_MLNO.Reg)
}

// DMA.TCD1_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD1_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD1_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD1_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD1_SLAST.Reg)
}

// DMA.TCD1_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD1_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD1_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD1_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD1_DADDR.Reg)
}

// DMA.TCD1_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD1_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD1_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD1_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD1_DOFF.Reg)
}

// DMA.TCD1_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD1_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD1_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD1_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD1_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD1_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD1_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD1_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD1_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD1_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD1_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD1_DLASTSGA.Reg)
}

// DMA.TCD1_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD1_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD1_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD1_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD1_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD1_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD1_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD1_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD1_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD1_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD1_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD1_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD1_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD1_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD1_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD1_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD1_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD1_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD1_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD1_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD1_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD1_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD1_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD1_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD1_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD1_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD1_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD1_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD2_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD2_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD2_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD2_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD2_SADDR.Reg)
}

// DMA.TCD2_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD2_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD2_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD2_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD2_SOFF.Reg)
}

// DMA.TCD2_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD2_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD2_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD2_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD2_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD2_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD2_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD2_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD2_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD2_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD2_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD2_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD2_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD2_NBYTES_MLNO.Reg)
}

// DMA.TCD2_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD2_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD2_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD2_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD2_SLAST.Reg)
}

// DMA.TCD2_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD2_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD2_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD2_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD2_DADDR.Reg)
}

// DMA.TCD2_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD2_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD2_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD2_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD2_DOFF.Reg)
}

// DMA.TCD2_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD2_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD2_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD2_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD2_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD2_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD2_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD2_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD2_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD2_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD2_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD2_DLASTSGA.Reg)
}

// DMA.TCD2_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD2_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD2_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD2_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD2_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD2_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD2_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD2_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD2_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD2_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD2_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD2_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD2_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD2_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD2_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD2_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD2_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD2_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD2_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD2_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD2_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD2_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD2_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD2_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD2_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD2_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD2_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD2_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD3_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD3_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD3_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD3_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD3_SADDR.Reg)
}

// DMA.TCD3_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD3_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD3_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD3_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD3_SOFF.Reg)
}

// DMA.TCD3_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD3_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD3_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD3_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD3_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD3_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD3_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD3_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD3_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD3_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD3_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD3_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD3_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD3_NBYTES_MLNO.Reg)
}

// DMA.TCD3_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD3_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD3_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD3_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD3_SLAST.Reg)
}

// DMA.TCD3_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD3_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD3_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD3_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD3_DADDR.Reg)
}

// DMA.TCD3_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD3_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD3_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD3_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD3_DOFF.Reg)
}

// DMA.TCD3_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD3_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD3_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD3_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD3_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD3_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD3_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD3_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD3_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD3_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD3_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD3_DLASTSGA.Reg)
}

// DMA.TCD3_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD3_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD3_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD3_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD3_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD3_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD3_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD3_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD3_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD3_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD3_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD3_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD3_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD3_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD3_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD3_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD3_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD3_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD3_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD3_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD3_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD3_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD3_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD3_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD3_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD3_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD3_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD3_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD4_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD4_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD4_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD4_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD4_SADDR.Reg)
}

// DMA.TCD4_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD4_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD4_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD4_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD4_SOFF.Reg)
}

// DMA.TCD4_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD4_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD4_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD4_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD4_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD4_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD4_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD4_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD4_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD4_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD4_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD4_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD4_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD4_NBYTES_MLNO.Reg)
}

// DMA.TCD4_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD4_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD4_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD4_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD4_SLAST.Reg)
}

// DMA.TCD4_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD4_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD4_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD4_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD4_DADDR.Reg)
}

// DMA.TCD4_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD4_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD4_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD4_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD4_DOFF.Reg)
}

// DMA.TCD4_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD4_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD4_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD4_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD4_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD4_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD4_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD4_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD4_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD4_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD4_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD4_DLASTSGA.Reg)
}

// DMA.TCD4_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD4_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD4_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD4_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD4_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD4_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD4_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD4_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD4_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD4_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD4_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD4_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD4_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD4_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD4_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD4_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD4_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD4_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD4_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD4_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD4_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD4_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD4_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD4_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD4_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD4_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD4_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD4_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD5_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD5_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD5_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD5_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD5_SADDR.Reg)
}

// DMA.TCD5_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD5_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD5_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD5_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD5_SOFF.Reg)
}

// DMA.TCD5_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD5_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD5_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD5_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD5_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD5_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD5_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD5_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD5_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD5_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD5_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD5_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD5_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD5_NBYTES_MLNO.Reg)
}

// DMA.TCD5_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD5_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD5_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD5_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD5_SLAST.Reg)
}

// DMA.TCD5_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD5_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD5_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD5_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD5_DADDR.Reg)
}

// DMA.TCD5_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD5_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD5_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD5_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD5_DOFF.Reg)
}

// DMA.TCD5_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD5_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD5_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD5_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD5_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD5_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD5_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD5_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD5_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD5_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD5_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD5_DLASTSGA.Reg)
}

// DMA.TCD5_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD5_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD5_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD5_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD5_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD5_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD5_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD5_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD5_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD5_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD5_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD5_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD5_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD5_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD5_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD5_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD5_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD5_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD5_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD5_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD5_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD5_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD5_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD5_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD5_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD5_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD5_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD5_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD6_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD6_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD6_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD6_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD6_SADDR.Reg)
}

// DMA.TCD6_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD6_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD6_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD6_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD6_SOFF.Reg)
}

// DMA.TCD6_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD6_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD6_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD6_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD6_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD6_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD6_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD6_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD6_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD6_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD6_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD6_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD6_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD6_NBYTES_MLNO.Reg)
}

// DMA.TCD6_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD6_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD6_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD6_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD6_SLAST.Reg)
}

// DMA.TCD6_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD6_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD6_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD6_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD6_DADDR.Reg)
}

// DMA.TCD6_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD6_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD6_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD6_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD6_DOFF.Reg)
}

// DMA.TCD6_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD6_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD6_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD6_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD6_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD6_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD6_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD6_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD6_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD6_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD6_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD6_DLASTSGA.Reg)
}

// DMA.TCD6_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD6_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD6_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD6_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD6_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD6_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD6_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD6_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD6_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD6_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD6_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD6_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD6_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD6_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD6_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD6_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD6_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD6_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD6_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD6_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD6_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD6_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD6_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD6_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD6_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD6_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD6_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD6_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD7_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD7_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD7_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD7_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD7_SADDR.Reg)
}

// DMA.TCD7_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD7_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD7_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD7_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD7_SOFF.Reg)
}

// DMA.TCD7_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD7_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD7_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD7_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD7_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD7_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD7_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD7_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD7_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD7_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD7_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD7_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD7_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD7_NBYTES_MLNO.Reg)
}

// DMA.TCD7_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD7_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD7_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD7_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD7_SLAST.Reg)
}

// DMA.TCD7_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD7_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD7_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD7_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD7_DADDR.Reg)
}

// DMA.TCD7_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD7_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD7_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD7_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD7_DOFF.Reg)
}

// DMA.TCD7_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD7_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD7_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD7_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD7_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD7_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD7_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD7_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD7_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD7_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD7_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD7_DLASTSGA.Reg)
}

// DMA.TCD7_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD7_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD7_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD7_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD7_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD7_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD7_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD7_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD7_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD7_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD7_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD7_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD7_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD7_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD7_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD7_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD7_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD7_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD7_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD7_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD7_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD7_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD7_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD7_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD7_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD7_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD7_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD7_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD8_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD8_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD8_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD8_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD8_SADDR.Reg)
}

// DMA.TCD8_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD8_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD8_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD8_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD8_SOFF.Reg)
}

// DMA.TCD8_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD8_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD8_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD8_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD8_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD8_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD8_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD8_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD8_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD8_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD8_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD8_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD8_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD8_NBYTES_MLNO.Reg)
}

// DMA.TCD8_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD8_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD8_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD8_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD8_SLAST.Reg)
}

// DMA.TCD8_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD8_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD8_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD8_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD8_DADDR.Reg)
}

// DMA.TCD8_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD8_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD8_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD8_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD8_DOFF.Reg)
}

// DMA.TCD8_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD8_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD8_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD8_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD8_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD8_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD8_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD8_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD8_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD8_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD8_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD8_DLASTSGA.Reg)
}

// DMA.TCD8_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD8_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD8_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD8_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD8_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD8_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD8_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD8_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD8_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD8_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD8_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD8_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD8_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD8_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD8_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD8_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD8_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD8_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD8_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD8_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD8_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD8_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD8_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD8_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD8_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD8_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD8_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD8_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD9_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD9_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD9_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD9_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD9_SADDR.Reg)
}

// DMA.TCD9_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD9_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD9_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD9_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD9_SOFF.Reg)
}

// DMA.TCD9_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD9_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD9_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD9_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD9_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD9_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD9_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD9_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD9_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD9_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD9_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD9_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD9_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD9_NBYTES_MLNO.Reg)
}

// DMA.TCD9_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD9_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD9_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD9_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD9_SLAST.Reg)
}

// DMA.TCD9_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD9_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD9_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD9_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD9_DADDR.Reg)
}

// DMA.TCD9_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD9_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD9_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD9_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD9_DOFF.Reg)
}

// DMA.TCD9_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD9_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD9_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD9_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD9_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD9_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD9_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD9_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD9_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD9_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD9_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD9_DLASTSGA.Reg)
}

// DMA.TCD9_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD9_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD9_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD9_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD9_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD9_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD9_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD9_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD9_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD9_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD9_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD9_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD9_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD9_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD9_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD9_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD9_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD9_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD9_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD9_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD9_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD9_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD9_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD9_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD9_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD9_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD9_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD9_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD10_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD10_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD10_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD10_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD10_SADDR.Reg)
}

// DMA.TCD10_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD10_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD10_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD10_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD10_SOFF.Reg)
}

// DMA.TCD10_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD10_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD10_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD10_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD10_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD10_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD10_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD10_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD10_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD10_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD10_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD10_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD10_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD10_NBYTES_MLNO.Reg)
}

// DMA.TCD10_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD10_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD10_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD10_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD10_SLAST.Reg)
}

// DMA.TCD10_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD10_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD10_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD10_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD10_DADDR.Reg)
}

// DMA.TCD10_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD10_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD10_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD10_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD10_DOFF.Reg)
}

// DMA.TCD10_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD10_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD10_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD10_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD10_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD10_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD10_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD10_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD10_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD10_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD10_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD10_DLASTSGA.Reg)
}

// DMA.TCD10_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD10_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD10_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD10_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD10_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD10_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD10_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD10_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD10_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD10_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD10_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD10_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD10_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD10_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD10_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD10_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD10_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD10_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD10_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD10_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD10_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD10_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD10_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD10_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD10_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD10_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD10_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD10_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD11_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD11_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD11_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD11_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD11_SADDR.Reg)
}

// DMA.TCD11_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD11_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD11_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD11_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD11_SOFF.Reg)
}

// DMA.TCD11_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD11_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD11_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD11_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD11_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD11_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD11_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD11_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD11_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD11_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD11_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD11_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD11_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD11_NBYTES_MLNO.Reg)
}

// DMA.TCD11_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD11_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD11_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD11_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD11_SLAST.Reg)
}

// DMA.TCD11_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD11_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD11_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD11_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD11_DADDR.Reg)
}

// DMA.TCD11_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD11_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD11_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD11_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD11_DOFF.Reg)
}

// DMA.TCD11_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD11_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD11_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD11_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD11_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD11_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD11_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD11_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD11_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD11_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD11_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD11_DLASTSGA.Reg)
}

// DMA.TCD11_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD11_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD11_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD11_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD11_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD11_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD11_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD11_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD11_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD11_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD11_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD11_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD11_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD11_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD11_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD11_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD11_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD11_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD11_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD11_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD11_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD11_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD11_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD11_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD11_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD11_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD11_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD11_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD12_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD12_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD12_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD12_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD12_SADDR.Reg)
}

// DMA.TCD12_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD12_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD12_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD12_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD12_SOFF.Reg)
}

// DMA.TCD12_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD12_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD12_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD12_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD12_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD12_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD12_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD12_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD12_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD12_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD12_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD12_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD12_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD12_NBYTES_MLNO.Reg)
}

// DMA.TCD12_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD12_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD12_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD12_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD12_SLAST.Reg)
}

// DMA.TCD12_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD12_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD12_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD12_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD12_DADDR.Reg)
}

// DMA.TCD12_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD12_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD12_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD12_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD12_DOFF.Reg)
}

// DMA.TCD12_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD12_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD12_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD12_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD12_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD12_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD12_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD12_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD12_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD12_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD12_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD12_DLASTSGA.Reg)
}

// DMA.TCD12_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD12_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD12_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD12_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD12_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD12_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD12_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD12_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD12_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD12_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD12_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD12_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD12_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD12_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD12_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD12_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD12_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD12_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD12_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD12_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD12_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD12_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD12_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD12_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD12_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD12_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD12_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD12_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD13_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD13_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD13_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD13_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD13_SADDR.Reg)
}

// DMA.TCD13_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD13_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD13_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD13_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD13_SOFF.Reg)
}

// DMA.TCD13_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD13_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD13_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD13_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD13_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD13_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD13_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD13_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD13_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD13_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD13_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD13_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD13_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD13_NBYTES_MLNO.Reg)
}

// DMA.TCD13_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD13_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD13_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD13_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD13_SLAST.Reg)
}

// DMA.TCD13_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD13_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD13_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD13_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD13_DADDR.Reg)
}

// DMA.TCD13_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD13_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD13_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD13_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD13_DOFF.Reg)
}

// DMA.TCD13_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD13_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD13_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD13_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD13_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD13_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD13_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD13_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD13_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD13_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD13_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD13_DLASTSGA.Reg)
}

// DMA.TCD13_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD13_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD13_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD13_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD13_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD13_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD13_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD13_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD13_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD13_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD13_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD13_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD13_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD13_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD13_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD13_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD13_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD13_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD13_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD13_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD13_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD13_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD13_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD13_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD13_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD13_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD13_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD13_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD14_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD14_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD14_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD14_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD14_SADDR.Reg)
}

// DMA.TCD14_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD14_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD14_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD14_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD14_SOFF.Reg)
}

// DMA.TCD14_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD14_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD14_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD14_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD14_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD14_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD14_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD14_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD14_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD14_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD14_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD14_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD14_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD14_NBYTES_MLNO.Reg)
}

// DMA.TCD14_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD14_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD14_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD14_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD14_SLAST.Reg)
}

// DMA.TCD14_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD14_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD14_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD14_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD14_DADDR.Reg)
}

// DMA.TCD14_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD14_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD14_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD14_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD14_DOFF.Reg)
}

// DMA.TCD14_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD14_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD14_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD14_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD14_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD14_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD14_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD14_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD14_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD14_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD14_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD14_DLASTSGA.Reg)
}

// DMA.TCD14_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD14_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD14_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD14_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD14_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD14_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD14_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD14_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD14_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD14_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD14_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD14_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD14_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD14_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD14_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD14_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD14_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD14_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD14_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD14_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD14_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD14_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD14_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD14_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD14_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD14_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD14_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD14_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD15_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD15_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD15_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD15_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD15_SADDR.Reg)
}

// DMA.TCD15_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD15_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD15_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD15_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD15_SOFF.Reg)
}

// DMA.TCD15_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD15_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD15_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD15_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD15_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD15_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD15_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD15_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD15_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD15_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD15_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD15_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD15_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD15_NBYTES_MLNO.Reg)
}

// DMA.TCD15_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD15_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD15_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD15_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD15_SLAST.Reg)
}

// DMA.TCD15_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD15_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD15_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD15_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD15_DADDR.Reg)
}

// DMA.TCD15_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD15_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD15_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD15_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD15_DOFF.Reg)
}

// DMA.TCD15_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD15_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD15_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD15_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD15_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD15_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD15_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD15_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD15_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD15_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD15_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD15_DLASTSGA.Reg)
}

// DMA.TCD15_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD15_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD15_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD15_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD15_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD15_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD15_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD15_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD15_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD15_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD15_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD15_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD15_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD15_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD15_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD15_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD15_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD15_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD15_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD15_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD15_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD15_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD15_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD15_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD15_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD15_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD15_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD15_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD16_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD16_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD16_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD16_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD16_SADDR.Reg)
}

// DMA.TCD16_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD16_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD16_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD16_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD16_SOFF.Reg)
}

// DMA.TCD16_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD16_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD16_ATTR.Reg, volatile.LoadUint16(&o.TCD16_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD16_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD16_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD16_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD16_ATTR.Reg, volatile.LoadUint16(&o.TCD16_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD16_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD16_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD16_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD16_ATTR.Reg, volatile.LoadUint16(&o.TCD16_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD16_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD16_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD16_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD16_ATTR.Reg, volatile.LoadUint16(&o.TCD16_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD16_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD16_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD16_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD16_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD16_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD16_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD16_NBYTES_MLNO.Reg)
}

// DMA.TCD16_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD16_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD16_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD16_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD16_SLAST.Reg)
}

// DMA.TCD16_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD16_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD16_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD16_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD16_DADDR.Reg)
}

// DMA.TCD16_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD16_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD16_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD16_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD16_DOFF.Reg)
}

// DMA.TCD16_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD16_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD16_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD16_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD16_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD16_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD16_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD16_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD16_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD16_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD16_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD16_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD16_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD16_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD16_DLASTSGA.Reg)
}

// DMA.TCD16_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD16_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD16_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD16_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD16_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD16_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD16_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD16_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD16_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD16_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD16_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD16_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD16_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD16_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD16_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD16_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD16_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD16_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD16_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD16_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD16_CSR.Reg, volatile.LoadUint16(&o.TCD16_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD16_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD16_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD16_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD16_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD16_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD16_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD16_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD16_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD16_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD16_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD16_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD16_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD16_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD17_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD17_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD17_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD17_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD17_SADDR.Reg)
}

// DMA.TCD17_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD17_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD17_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD17_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD17_SOFF.Reg)
}

// DMA.TCD17_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD17_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD17_ATTR.Reg, volatile.LoadUint16(&o.TCD17_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD17_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD17_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD17_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD17_ATTR.Reg, volatile.LoadUint16(&o.TCD17_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD17_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD17_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD17_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD17_ATTR.Reg, volatile.LoadUint16(&o.TCD17_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD17_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD17_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD17_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD17_ATTR.Reg, volatile.LoadUint16(&o.TCD17_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD17_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD17_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD17_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD17_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD17_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD17_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD17_NBYTES_MLNO.Reg)
}

// DMA.TCD17_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD17_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD17_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD17_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD17_SLAST.Reg)
}

// DMA.TCD17_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD17_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD17_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD17_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD17_DADDR.Reg)
}

// DMA.TCD17_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD17_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD17_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD17_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD17_DOFF.Reg)
}

// DMA.TCD17_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD17_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD17_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD17_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD17_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD17_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD17_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD17_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD17_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD17_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD17_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD17_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD17_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD17_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD17_DLASTSGA.Reg)
}

// DMA.TCD17_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD17_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD17_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD17_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD17_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD17_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD17_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD17_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD17_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD17_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD17_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD17_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD17_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD17_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD17_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD17_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD17_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD17_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD17_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD17_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD17_CSR.Reg, volatile.LoadUint16(&o.TCD17_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD17_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD17_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD17_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD17_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD17_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD17_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD17_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD17_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD17_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD17_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD17_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD17_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD17_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD18_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD18_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD18_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD18_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD18_SADDR.Reg)
}

// DMA.TCD18_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD18_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD18_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD18_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD18_SOFF.Reg)
}

// DMA.TCD18_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD18_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD18_ATTR.Reg, volatile.LoadUint16(&o.TCD18_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD18_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD18_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD18_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD18_ATTR.Reg, volatile.LoadUint16(&o.TCD18_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD18_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD18_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD18_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD18_ATTR.Reg, volatile.LoadUint16(&o.TCD18_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD18_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD18_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD18_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD18_ATTR.Reg, volatile.LoadUint16(&o.TCD18_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD18_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD18_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD18_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD18_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD18_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD18_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD18_NBYTES_MLNO.Reg)
}

// DMA.TCD18_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD18_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD18_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD18_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD18_SLAST.Reg)
}

// DMA.TCD18_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD18_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD18_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD18_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD18_DADDR.Reg)
}

// DMA.TCD18_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD18_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD18_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD18_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD18_DOFF.Reg)
}

// DMA.TCD18_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD18_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD18_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD18_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD18_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD18_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD18_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD18_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD18_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD18_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD18_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD18_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD18_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD18_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD18_DLASTSGA.Reg)
}

// DMA.TCD18_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD18_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD18_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD18_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD18_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD18_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD18_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD18_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD18_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD18_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD18_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD18_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD18_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD18_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD18_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD18_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD18_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD18_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD18_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD18_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD18_CSR.Reg, volatile.LoadUint16(&o.TCD18_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD18_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD18_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD18_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD18_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD18_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD18_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD18_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD18_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD18_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD18_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD18_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD18_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD18_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD19_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD19_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD19_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD19_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD19_SADDR.Reg)
}

// DMA.TCD19_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD19_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD19_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD19_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD19_SOFF.Reg)
}

// DMA.TCD19_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD19_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD19_ATTR.Reg, volatile.LoadUint16(&o.TCD19_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD19_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD19_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD19_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD19_ATTR.Reg, volatile.LoadUint16(&o.TCD19_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD19_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD19_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD19_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD19_ATTR.Reg, volatile.LoadUint16(&o.TCD19_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD19_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD19_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD19_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD19_ATTR.Reg, volatile.LoadUint16(&o.TCD19_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD19_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD19_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD19_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD19_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD19_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD19_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD19_NBYTES_MLNO.Reg)
}

// DMA.TCD19_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD19_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD19_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD19_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD19_SLAST.Reg)
}

// DMA.TCD19_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD19_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD19_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD19_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD19_DADDR.Reg)
}

// DMA.TCD19_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD19_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD19_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD19_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD19_DOFF.Reg)
}

// DMA.TCD19_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD19_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD19_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD19_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD19_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD19_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD19_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD19_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD19_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD19_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD19_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD19_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD19_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD19_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD19_DLASTSGA.Reg)
}

// DMA.TCD19_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD19_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD19_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD19_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD19_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD19_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD19_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD19_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD19_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD19_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD19_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD19_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD19_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD19_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD19_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD19_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD19_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD19_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD19_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD19_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD19_CSR.Reg, volatile.LoadUint16(&o.TCD19_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD19_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD19_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD19_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD19_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD19_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD19_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD19_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD19_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD19_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD19_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD19_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD19_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD19_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD20_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD20_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD20_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD20_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD20_SADDR.Reg)
}

// DMA.TCD20_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD20_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD20_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD20_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD20_SOFF.Reg)
}

// DMA.TCD20_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD20_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD20_ATTR.Reg, volatile.LoadUint16(&o.TCD20_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD20_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD20_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD20_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD20_ATTR.Reg, volatile.LoadUint16(&o.TCD20_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD20_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD20_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD20_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD20_ATTR.Reg, volatile.LoadUint16(&o.TCD20_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD20_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD20_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD20_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD20_ATTR.Reg, volatile.LoadUint16(&o.TCD20_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD20_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD20_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD20_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD20_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD20_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD20_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD20_NBYTES_MLNO.Reg)
}

// DMA.TCD20_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD20_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD20_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD20_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD20_SLAST.Reg)
}

// DMA.TCD20_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD20_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD20_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD20_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD20_DADDR.Reg)
}

// DMA.TCD20_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD20_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD20_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD20_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD20_DOFF.Reg)
}

// DMA.TCD20_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD20_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD20_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD20_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD20_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD20_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD20_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD20_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD20_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD20_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD20_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD20_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD20_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD20_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD20_DLASTSGA.Reg)
}

// DMA.TCD20_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD20_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD20_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD20_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD20_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD20_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD20_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD20_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD20_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD20_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD20_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD20_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD20_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD20_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD20_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD20_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD20_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD20_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD20_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD20_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD20_CSR.Reg, volatile.LoadUint16(&o.TCD20_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD20_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD20_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD20_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD20_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD20_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD20_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD20_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD20_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD20_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD20_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD20_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD20_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD20_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD21_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD21_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD21_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD21_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD21_SADDR.Reg)
}

// DMA.TCD21_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD21_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD21_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD21_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD21_SOFF.Reg)
}

// DMA.TCD21_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD21_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD21_ATTR.Reg, volatile.LoadUint16(&o.TCD21_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD21_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD21_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD21_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD21_ATTR.Reg, volatile.LoadUint16(&o.TCD21_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD21_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD21_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD21_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD21_ATTR.Reg, volatile.LoadUint16(&o.TCD21_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD21_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD21_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD21_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD21_ATTR.Reg, volatile.LoadUint16(&o.TCD21_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD21_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD21_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD21_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD21_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD21_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD21_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD21_NBYTES_MLNO.Reg)
}

// DMA.TCD21_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD21_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD21_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD21_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD21_SLAST.Reg)
}

// DMA.TCD21_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD21_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD21_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD21_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD21_DADDR.Reg)
}

// DMA.TCD21_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD21_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD21_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD21_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD21_DOFF.Reg)
}

// DMA.TCD21_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD21_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD21_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD21_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD21_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD21_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD21_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD21_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD21_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD21_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD21_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD21_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD21_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD21_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD21_DLASTSGA.Reg)
}

// DMA.TCD21_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD21_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD21_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD21_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD21_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD21_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD21_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD21_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD21_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD21_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD21_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD21_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD21_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD21_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD21_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD21_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD21_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD21_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD21_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD21_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD21_CSR.Reg, volatile.LoadUint16(&o.TCD21_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD21_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD21_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD21_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD21_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD21_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD21_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD21_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD21_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD21_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD21_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD21_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD21_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD21_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD22_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD22_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD22_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD22_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD22_SADDR.Reg)
}

// DMA.TCD22_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD22_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD22_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD22_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD22_SOFF.Reg)
}

// DMA.TCD22_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD22_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD22_ATTR.Reg, volatile.LoadUint16(&o.TCD22_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD22_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD22_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD22_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD22_ATTR.Reg, volatile.LoadUint16(&o.TCD22_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD22_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD22_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD22_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD22_ATTR.Reg, volatile.LoadUint16(&o.TCD22_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD22_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD22_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD22_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD22_ATTR.Reg, volatile.LoadUint16(&o.TCD22_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD22_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD22_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD22_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD22_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD22_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD22_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD22_NBYTES_MLNO.Reg)
}

// DMA.TCD22_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD22_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD22_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD22_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD22_SLAST.Reg)
}

// DMA.TCD22_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD22_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD22_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD22_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD22_DADDR.Reg)
}

// DMA.TCD22_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD22_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD22_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD22_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD22_DOFF.Reg)
}

// DMA.TCD22_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD22_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD22_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD22_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD22_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD22_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD22_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD22_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD22_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD22_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD22_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD22_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD22_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD22_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD22_DLASTSGA.Reg)
}

// DMA.TCD22_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD22_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD22_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD22_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD22_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD22_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD22_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD22_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD22_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD22_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD22_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD22_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD22_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD22_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD22_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD22_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD22_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD22_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD22_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD22_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD22_CSR.Reg, volatile.LoadUint16(&o.TCD22_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD22_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD22_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD22_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD22_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD22_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD22_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD22_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD22_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD22_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD22_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD22_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD22_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD22_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD23_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD23_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD23_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD23_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD23_SADDR.Reg)
}

// DMA.TCD23_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD23_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD23_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD23_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD23_SOFF.Reg)
}

// DMA.TCD23_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD23_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD23_ATTR.Reg, volatile.LoadUint16(&o.TCD23_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD23_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD23_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD23_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD23_ATTR.Reg, volatile.LoadUint16(&o.TCD23_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD23_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD23_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD23_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD23_ATTR.Reg, volatile.LoadUint16(&o.TCD23_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD23_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD23_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD23_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD23_ATTR.Reg, volatile.LoadUint16(&o.TCD23_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD23_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD23_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD23_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD23_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD23_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD23_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD23_NBYTES_MLNO.Reg)
}

// DMA.TCD23_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD23_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD23_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD23_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD23_SLAST.Reg)
}

// DMA.TCD23_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD23_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD23_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD23_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD23_DADDR.Reg)
}

// DMA.TCD23_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD23_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD23_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD23_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD23_DOFF.Reg)
}

// DMA.TCD23_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD23_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD23_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD23_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD23_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD23_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD23_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD23_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD23_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD23_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD23_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD23_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD23_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD23_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD23_DLASTSGA.Reg)
}

// DMA.TCD23_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD23_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD23_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD23_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD23_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD23_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD23_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD23_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD23_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD23_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD23_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD23_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD23_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD23_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD23_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD23_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD23_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD23_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD23_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD23_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD23_CSR.Reg, volatile.LoadUint16(&o.TCD23_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD23_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD23_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD23_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD23_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD23_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD23_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD23_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD23_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD23_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD23_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD23_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD23_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD23_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD24_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD24_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD24_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD24_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD24_SADDR.Reg)
}

// DMA.TCD24_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD24_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD24_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD24_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD24_SOFF.Reg)
}

// DMA.TCD24_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD24_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD24_ATTR.Reg, volatile.LoadUint16(&o.TCD24_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD24_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD24_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD24_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD24_ATTR.Reg, volatile.LoadUint16(&o.TCD24_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD24_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD24_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD24_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD24_ATTR.Reg, volatile.LoadUint16(&o.TCD24_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD24_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD24_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD24_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD24_ATTR.Reg, volatile.LoadUint16(&o.TCD24_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD24_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD24_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD24_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD24_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD24_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD24_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD24_NBYTES_MLNO.Reg)
}

// DMA.TCD24_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD24_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD24_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD24_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD24_SLAST.Reg)
}

// DMA.TCD24_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD24_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD24_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD24_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD24_DADDR.Reg)
}

// DMA.TCD24_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD24_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD24_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD24_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD24_DOFF.Reg)
}

// DMA.TCD24_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD24_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD24_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD24_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD24_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD24_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD24_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD24_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD24_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD24_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD24_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD24_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD24_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD24_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD24_DLASTSGA.Reg)
}

// DMA.TCD24_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD24_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD24_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD24_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD24_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD24_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD24_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD24_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD24_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD24_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD24_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD24_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD24_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD24_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD24_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD24_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD24_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD24_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD24_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD24_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD24_CSR.Reg, volatile.LoadUint16(&o.TCD24_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD24_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD24_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD24_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD24_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD24_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD24_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD24_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD24_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD24_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD24_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD24_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD24_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD24_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD25_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD25_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD25_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD25_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD25_SADDR.Reg)
}

// DMA.TCD25_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD25_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD25_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD25_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD25_SOFF.Reg)
}

// DMA.TCD25_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD25_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD25_ATTR.Reg, volatile.LoadUint16(&o.TCD25_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD25_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD25_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD25_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD25_ATTR.Reg, volatile.LoadUint16(&o.TCD25_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD25_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD25_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD25_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD25_ATTR.Reg, volatile.LoadUint16(&o.TCD25_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD25_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD25_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD25_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD25_ATTR.Reg, volatile.LoadUint16(&o.TCD25_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD25_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD25_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD25_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD25_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD25_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD25_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD25_NBYTES_MLNO.Reg)
}

// DMA.TCD25_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD25_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD25_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD25_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD25_SLAST.Reg)
}

// DMA.TCD25_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD25_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD25_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD25_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD25_DADDR.Reg)
}

// DMA.TCD25_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD25_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD25_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD25_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD25_DOFF.Reg)
}

// DMA.TCD25_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD25_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD25_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD25_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD25_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD25_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD25_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD25_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD25_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD25_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD25_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD25_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD25_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD25_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD25_DLASTSGA.Reg)
}

// DMA.TCD25_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD25_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD25_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD25_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD25_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD25_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD25_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD25_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD25_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD25_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD25_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD25_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD25_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD25_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD25_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD25_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD25_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD25_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD25_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD25_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD25_CSR.Reg, volatile.LoadUint16(&o.TCD25_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD25_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD25_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD25_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD25_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD25_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD25_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD25_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD25_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD25_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD25_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD25_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD25_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD25_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD26_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD26_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD26_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD26_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD26_SADDR.Reg)
}

// DMA.TCD26_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD26_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD26_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD26_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD26_SOFF.Reg)
}

// DMA.TCD26_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD26_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD26_ATTR.Reg, volatile.LoadUint16(&o.TCD26_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD26_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD26_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD26_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD26_ATTR.Reg, volatile.LoadUint16(&o.TCD26_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD26_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD26_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD26_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD26_ATTR.Reg, volatile.LoadUint16(&o.TCD26_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD26_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD26_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD26_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD26_ATTR.Reg, volatile.LoadUint16(&o.TCD26_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD26_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD26_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD26_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD26_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD26_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD26_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD26_NBYTES_MLNO.Reg)
}

// DMA.TCD26_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD26_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD26_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD26_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD26_SLAST.Reg)
}

// DMA.TCD26_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD26_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD26_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD26_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD26_DADDR.Reg)
}

// DMA.TCD26_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD26_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD26_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD26_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD26_DOFF.Reg)
}

// DMA.TCD26_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD26_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD26_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD26_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD26_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD26_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD26_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD26_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD26_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD26_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD26_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD26_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD26_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD26_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD26_DLASTSGA.Reg)
}

// DMA.TCD26_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD26_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD26_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD26_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD26_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD26_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD26_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD26_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD26_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD26_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD26_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD26_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD26_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD26_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD26_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD26_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD26_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD26_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD26_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD26_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD26_CSR.Reg, volatile.LoadUint16(&o.TCD26_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD26_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD26_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD26_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD26_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD26_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD26_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD26_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD26_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD26_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD26_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD26_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD26_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD26_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD27_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD27_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD27_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD27_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD27_SADDR.Reg)
}

// DMA.TCD27_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD27_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD27_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD27_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD27_SOFF.Reg)
}

// DMA.TCD27_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD27_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD27_ATTR.Reg, volatile.LoadUint16(&o.TCD27_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD27_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD27_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD27_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD27_ATTR.Reg, volatile.LoadUint16(&o.TCD27_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD27_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD27_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD27_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD27_ATTR.Reg, volatile.LoadUint16(&o.TCD27_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD27_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD27_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD27_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD27_ATTR.Reg, volatile.LoadUint16(&o.TCD27_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD27_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD27_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD27_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD27_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD27_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD27_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD27_NBYTES_MLNO.Reg)
}

// DMA.TCD27_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD27_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD27_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD27_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD27_SLAST.Reg)
}

// DMA.TCD27_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD27_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD27_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD27_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD27_DADDR.Reg)
}

// DMA.TCD27_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD27_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD27_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD27_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD27_DOFF.Reg)
}

// DMA.TCD27_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD27_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD27_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD27_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD27_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD27_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD27_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD27_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD27_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD27_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD27_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD27_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD27_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD27_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD27_DLASTSGA.Reg)
}

// DMA.TCD27_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD27_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD27_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD27_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD27_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD27_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD27_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD27_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD27_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD27_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD27_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD27_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD27_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD27_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD27_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD27_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD27_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD27_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD27_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD27_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD27_CSR.Reg, volatile.LoadUint16(&o.TCD27_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD27_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD27_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD27_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD27_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD27_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD27_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD27_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD27_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD27_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD27_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD27_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD27_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD27_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD28_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD28_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD28_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD28_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD28_SADDR.Reg)
}

// DMA.TCD28_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD28_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD28_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD28_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD28_SOFF.Reg)
}

// DMA.TCD28_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD28_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD28_ATTR.Reg, volatile.LoadUint16(&o.TCD28_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD28_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD28_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD28_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD28_ATTR.Reg, volatile.LoadUint16(&o.TCD28_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD28_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD28_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD28_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD28_ATTR.Reg, volatile.LoadUint16(&o.TCD28_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD28_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD28_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD28_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD28_ATTR.Reg, volatile.LoadUint16(&o.TCD28_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD28_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD28_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD28_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD28_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD28_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD28_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD28_NBYTES_MLNO.Reg)
}

// DMA.TCD28_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD28_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD28_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD28_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD28_SLAST.Reg)
}

// DMA.TCD28_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD28_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD28_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD28_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD28_DADDR.Reg)
}

// DMA.TCD28_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD28_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD28_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD28_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD28_DOFF.Reg)
}

// DMA.TCD28_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD28_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD28_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD28_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD28_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD28_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD28_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD28_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD28_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD28_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD28_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD28_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD28_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD28_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD28_DLASTSGA.Reg)
}

// DMA.TCD28_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD28_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD28_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD28_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD28_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD28_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD28_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD28_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD28_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD28_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD28_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD28_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD28_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD28_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD28_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD28_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD28_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD28_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD28_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD28_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD28_CSR.Reg, volatile.LoadUint16(&o.TCD28_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD28_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD28_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD28_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD28_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD28_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD28_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD28_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD28_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD28_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD28_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD28_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD28_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD28_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD29_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD29_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD29_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD29_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD29_SADDR.Reg)
}

// DMA.TCD29_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD29_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD29_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD29_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD29_SOFF.Reg)
}

// DMA.TCD29_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD29_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD29_ATTR.Reg, volatile.LoadUint16(&o.TCD29_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD29_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD29_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD29_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD29_ATTR.Reg, volatile.LoadUint16(&o.TCD29_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD29_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD29_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD29_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD29_ATTR.Reg, volatile.LoadUint16(&o.TCD29_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD29_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD29_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD29_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD29_ATTR.Reg, volatile.LoadUint16(&o.TCD29_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD29_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD29_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD29_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD29_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD29_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD29_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD29_NBYTES_MLNO.Reg)
}

// DMA.TCD29_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD29_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD29_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD29_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD29_SLAST.Reg)
}

// DMA.TCD29_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD29_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD29_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD29_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD29_DADDR.Reg)
}

// DMA.TCD29_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD29_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD29_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD29_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD29_DOFF.Reg)
}

// DMA.TCD29_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD29_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD29_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD29_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD29_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD29_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD29_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD29_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD29_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD29_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD29_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD29_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD29_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD29_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD29_DLASTSGA.Reg)
}

// DMA.TCD29_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD29_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD29_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD29_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD29_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD29_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD29_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD29_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD29_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD29_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD29_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD29_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD29_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD29_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD29_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD29_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD29_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD29_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD29_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD29_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD29_CSR.Reg, volatile.LoadUint16(&o.TCD29_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD29_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD29_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD29_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD29_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD29_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD29_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD29_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD29_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD29_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD29_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD29_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD29_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD29_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD30_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD30_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD30_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD30_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD30_SADDR.Reg)
}

// DMA.TCD30_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD30_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD30_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD30_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD30_SOFF.Reg)
}

// DMA.TCD30_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD30_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD30_ATTR.Reg, volatile.LoadUint16(&o.TCD30_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD30_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD30_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD30_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD30_ATTR.Reg, volatile.LoadUint16(&o.TCD30_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD30_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD30_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD30_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD30_ATTR.Reg, volatile.LoadUint16(&o.TCD30_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD30_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD30_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD30_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD30_ATTR.Reg, volatile.LoadUint16(&o.TCD30_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD30_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD30_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD30_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD30_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD30_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD30_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD30_NBYTES_MLNO.Reg)
}

// DMA.TCD30_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD30_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD30_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD30_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD30_SLAST.Reg)
}

// DMA.TCD30_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD30_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD30_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD30_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD30_DADDR.Reg)
}

// DMA.TCD30_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD30_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD30_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD30_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD30_DOFF.Reg)
}

// DMA.TCD30_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD30_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD30_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD30_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD30_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD30_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD30_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD30_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD30_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD30_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD30_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD30_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD30_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD30_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD30_DLASTSGA.Reg)
}

// DMA.TCD30_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD30_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD30_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD30_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD30_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD30_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD30_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD30_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD30_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD30_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD30_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD30_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD30_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD30_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD30_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD30_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD30_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD30_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD30_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD30_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD30_CSR.Reg, volatile.LoadUint16(&o.TCD30_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD30_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD30_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD30_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD30_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD30_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD30_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD30_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD30_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD30_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD30_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD30_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD30_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD30_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD31_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD31_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD31_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD31_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD31_SADDR.Reg)
}

// DMA.TCD31_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD31_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD31_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD31_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD31_SOFF.Reg)
}

// DMA.TCD31_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD31_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD31_ATTR.Reg, volatile.LoadUint16(&o.TCD31_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD31_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD31_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD31_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD31_ATTR.Reg, volatile.LoadUint16(&o.TCD31_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD31_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD31_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD31_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD31_ATTR.Reg, volatile.LoadUint16(&o.TCD31_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD31_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD31_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD31_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD31_ATTR.Reg, volatile.LoadUint16(&o.TCD31_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD31_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD31_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD31_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD31_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD31_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD31_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD31_NBYTES_MLNO.Reg)
}

// DMA.TCD31_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD31_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD31_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD31_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD31_SLAST.Reg)
}

// DMA.TCD31_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD31_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD31_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD31_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD31_DADDR.Reg)
}

// DMA.TCD31_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD31_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD31_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD31_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD31_DOFF.Reg)
}

// DMA.TCD31_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD31_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD31_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD31_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD31_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD31_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD31_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD31_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD31_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD31_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD31_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD31_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD31_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD31_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD31_DLASTSGA.Reg)
}

// DMA.TCD31_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD31_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD31_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD31_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD31_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD31_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD31_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD31_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD31_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD31_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD31_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD31_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD31_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD31_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD31_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD31_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD31_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD31_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0x1f00)|value<<8)
}
func (o *DMA_Type) GetTCD31_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0x1f00) >> 8
}
func (o *DMA_Type) SetTCD31_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD31_CSR.Reg, volatile.LoadUint16(&o.TCD31_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD31_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD31_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD31_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD31_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD31_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD31_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD31_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD31_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD31_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD31_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD31_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD31_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD31_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// FlexBus external bus interface
type FB_Type struct {
	CSAR0  volatile.Register32 // 0x0
	CSMR0  volatile.Register32 // 0x4
	CSCR0  volatile.Register32 // 0x8
	CSAR1  volatile.Register32 // 0xC
	CSMR1  volatile.Register32 // 0x10
	CSCR1  volatile.Register32 // 0x14
	CSAR2  volatile.Register32 // 0x18
	CSMR2  volatile.Register32 // 0x1C
	CSCR2  volatile.Register32 // 0x20
	CSAR3  volatile.Register32 // 0x24
	CSMR3  volatile.Register32 // 0x28
	CSCR3  volatile.Register32 // 0x2C
	CSAR4  volatile.Register32 // 0x30
	CSMR4  volatile.Register32 // 0x34
	CSCR4  volatile.Register32 // 0x38
	CSAR5  volatile.Register32 // 0x3C
	CSMR5  volatile.Register32 // 0x40
	CSCR5  volatile.Register32 // 0x44
	_      [24]byte
	CSPMCR volatile.Register32 // 0x60
}

// FB.CSAR0: Chip Select Address Register
func (o *FB_Type) SetCSAR0_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR0.Reg, volatile.LoadUint32(&o.CSAR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR0_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR0.Reg) & 0xffff0000) >> 16
}

// FB.CSMR0: Chip Select Mask Register
func (o *FB_Type) SetCSMR0_V(value uint32) {
	volatile.StoreUint32(&o.CSMR0.Reg, volatile.LoadUint32(&o.CSMR0.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR0_V() uint32 {
	return volatile.LoadUint32(&o.CSMR0.Reg) & 0x1
}
func (o *FB_Type) SetCSMR0_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR0.Reg, volatile.LoadUint32(&o.CSMR0.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR0_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR0.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR0_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR0.Reg, volatile.LoadUint32(&o.CSMR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR0_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR0.Reg) & 0xffff0000) >> 16
}

// FB.CSCR0: Chip Select Control Register
func (o *FB_Type) SetCSCR0_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR0_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR0_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR0_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR0_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR0_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR0_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR0_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR0_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR0_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR0_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR0_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR0_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR0_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR0_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR0_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR0_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR0_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR0_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR0_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR0_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR0_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR0_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR0_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR0_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR0.Reg, volatile.LoadUint32(&o.CSCR0.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR0_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR0.Reg) & 0xfc000000) >> 26
}

// FB.CSAR1: Chip Select Address Register
func (o *FB_Type) SetCSAR1_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR1.Reg, volatile.LoadUint32(&o.CSAR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR1_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR1.Reg) & 0xffff0000) >> 16
}

// FB.CSMR1: Chip Select Mask Register
func (o *FB_Type) SetCSMR1_V(value uint32) {
	volatile.StoreUint32(&o.CSMR1.Reg, volatile.LoadUint32(&o.CSMR1.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR1_V() uint32 {
	return volatile.LoadUint32(&o.CSMR1.Reg) & 0x1
}
func (o *FB_Type) SetCSMR1_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR1.Reg, volatile.LoadUint32(&o.CSMR1.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR1_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR1.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR1_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR1.Reg, volatile.LoadUint32(&o.CSMR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR1_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR1.Reg) & 0xffff0000) >> 16
}

// FB.CSCR1: Chip Select Control Register
func (o *FB_Type) SetCSCR1_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR1_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR1_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR1_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR1_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR1_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR1_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR1_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR1_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR1_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR1_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR1_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR1_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR1_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR1_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR1_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR1_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR1_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR1_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR1_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR1_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR1_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR1_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR1_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR1_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR1.Reg, volatile.LoadUint32(&o.CSCR1.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR1_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR1.Reg) & 0xfc000000) >> 26
}

// FB.CSAR2: Chip Select Address Register
func (o *FB_Type) SetCSAR2_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR2.Reg, volatile.LoadUint32(&o.CSAR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR2_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR2.Reg) & 0xffff0000) >> 16
}

// FB.CSMR2: Chip Select Mask Register
func (o *FB_Type) SetCSMR2_V(value uint32) {
	volatile.StoreUint32(&o.CSMR2.Reg, volatile.LoadUint32(&o.CSMR2.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR2_V() uint32 {
	return volatile.LoadUint32(&o.CSMR2.Reg) & 0x1
}
func (o *FB_Type) SetCSMR2_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR2.Reg, volatile.LoadUint32(&o.CSMR2.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR2_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR2.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR2_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR2.Reg, volatile.LoadUint32(&o.CSMR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR2_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR2.Reg) & 0xffff0000) >> 16
}

// FB.CSCR2: Chip Select Control Register
func (o *FB_Type) SetCSCR2_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR2_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR2_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR2_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR2_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR2_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR2_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR2_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR2_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR2_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR2_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR2_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR2_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR2_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR2_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR2_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR2_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR2_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR2_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR2_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR2_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR2_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR2_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR2_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR2_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR2.Reg, volatile.LoadUint32(&o.CSCR2.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR2_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR2.Reg) & 0xfc000000) >> 26
}

// FB.CSAR3: Chip Select Address Register
func (o *FB_Type) SetCSAR3_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR3.Reg, volatile.LoadUint32(&o.CSAR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR3_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR3.Reg) & 0xffff0000) >> 16
}

// FB.CSMR3: Chip Select Mask Register
func (o *FB_Type) SetCSMR3_V(value uint32) {
	volatile.StoreUint32(&o.CSMR3.Reg, volatile.LoadUint32(&o.CSMR3.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR3_V() uint32 {
	return volatile.LoadUint32(&o.CSMR3.Reg) & 0x1
}
func (o *FB_Type) SetCSMR3_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR3.Reg, volatile.LoadUint32(&o.CSMR3.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR3_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR3.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR3_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR3.Reg, volatile.LoadUint32(&o.CSMR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR3_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR3.Reg) & 0xffff0000) >> 16
}

// FB.CSCR3: Chip Select Control Register
func (o *FB_Type) SetCSCR3_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR3_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR3_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR3_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR3_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR3_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR3_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR3_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR3_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR3_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR3_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR3_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR3_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR3_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR3_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR3_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR3_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR3_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR3_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR3_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR3_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR3_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR3_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR3_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR3_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR3.Reg, volatile.LoadUint32(&o.CSCR3.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR3_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR3.Reg) & 0xfc000000) >> 26
}

// FB.CSAR4: Chip Select Address Register
func (o *FB_Type) SetCSAR4_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR4.Reg, volatile.LoadUint32(&o.CSAR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR4_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR4.Reg) & 0xffff0000) >> 16
}

// FB.CSMR4: Chip Select Mask Register
func (o *FB_Type) SetCSMR4_V(value uint32) {
	volatile.StoreUint32(&o.CSMR4.Reg, volatile.LoadUint32(&o.CSMR4.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR4_V() uint32 {
	return volatile.LoadUint32(&o.CSMR4.Reg) & 0x1
}
func (o *FB_Type) SetCSMR4_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR4.Reg, volatile.LoadUint32(&o.CSMR4.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR4_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR4.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR4_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR4.Reg, volatile.LoadUint32(&o.CSMR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR4_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR4.Reg) & 0xffff0000) >> 16
}

// FB.CSCR4: Chip Select Control Register
func (o *FB_Type) SetCSCR4_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR4_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR4_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR4_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR4_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR4_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR4_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR4_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR4_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR4_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR4_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR4_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR4_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR4_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR4_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR4_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR4_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR4_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR4_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR4_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR4_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR4_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR4_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR4_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR4_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR4.Reg, volatile.LoadUint32(&o.CSCR4.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR4_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR4.Reg) & 0xfc000000) >> 26
}

// FB.CSAR5: Chip Select Address Register
func (o *FB_Type) SetCSAR5_BA(value uint32) {
	volatile.StoreUint32(&o.CSAR5.Reg, volatile.LoadUint32(&o.CSAR5.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSAR5_BA() uint32 {
	return (volatile.LoadUint32(&o.CSAR5.Reg) & 0xffff0000) >> 16
}

// FB.CSMR5: Chip Select Mask Register
func (o *FB_Type) SetCSMR5_V(value uint32) {
	volatile.StoreUint32(&o.CSMR5.Reg, volatile.LoadUint32(&o.CSMR5.Reg)&^(0x1)|value)
}
func (o *FB_Type) GetCSMR5_V() uint32 {
	return volatile.LoadUint32(&o.CSMR5.Reg) & 0x1
}
func (o *FB_Type) SetCSMR5_WP(value uint32) {
	volatile.StoreUint32(&o.CSMR5.Reg, volatile.LoadUint32(&o.CSMR5.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSMR5_WP() uint32 {
	return (volatile.LoadUint32(&o.CSMR5.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSMR5_BAM(value uint32) {
	volatile.StoreUint32(&o.CSMR5.Reg, volatile.LoadUint32(&o.CSMR5.Reg)&^(0xffff0000)|value<<16)
}
func (o *FB_Type) GetCSMR5_BAM() uint32 {
	return (volatile.LoadUint32(&o.CSMR5.Reg) & 0xffff0000) >> 16
}

// FB.CSCR5: Chip Select Control Register
func (o *FB_Type) SetCSCR5_BSTW(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x8)|value<<3)
}
func (o *FB_Type) GetCSCR5_BSTW() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x8) >> 3
}
func (o *FB_Type) SetCSCR5_BSTR(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x10)|value<<4)
}
func (o *FB_Type) GetCSCR5_BSTR() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x10) >> 4
}
func (o *FB_Type) SetCSCR5_BEM(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x20)|value<<5)
}
func (o *FB_Type) GetCSCR5_BEM() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x20) >> 5
}
func (o *FB_Type) SetCSCR5_PS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0xc0)|value<<6)
}
func (o *FB_Type) GetCSCR5_PS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0xc0) >> 6
}
func (o *FB_Type) SetCSCR5_AA(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x100)|value<<8)
}
func (o *FB_Type) GetCSCR5_AA() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x100) >> 8
}
func (o *FB_Type) SetCSCR5_BLS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x200)|value<<9)
}
func (o *FB_Type) GetCSCR5_BLS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x200) >> 9
}
func (o *FB_Type) SetCSCR5_WS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0xfc00)|value<<10)
}
func (o *FB_Type) GetCSCR5_WS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0xfc00) >> 10
}
func (o *FB_Type) SetCSCR5_WRAH(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x30000)|value<<16)
}
func (o *FB_Type) GetCSCR5_WRAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x30000) >> 16
}
func (o *FB_Type) SetCSCR5_RDAH(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0xc0000)|value<<18)
}
func (o *FB_Type) GetCSCR5_RDAH() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0xc0000) >> 18
}
func (o *FB_Type) SetCSCR5_ASET(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x300000)|value<<20)
}
func (o *FB_Type) GetCSCR5_ASET() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x300000) >> 20
}
func (o *FB_Type) SetCSCR5_EXTS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x400000)|value<<22)
}
func (o *FB_Type) GetCSCR5_EXTS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x400000) >> 22
}
func (o *FB_Type) SetCSCR5_SWSEN(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0x800000)|value<<23)
}
func (o *FB_Type) GetCSCR5_SWSEN() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0x800000) >> 23
}
func (o *FB_Type) SetCSCR5_SWS(value uint32) {
	volatile.StoreUint32(&o.CSCR5.Reg, volatile.LoadUint32(&o.CSCR5.Reg)&^(0xfc000000)|value<<26)
}
func (o *FB_Type) GetCSCR5_SWS() uint32 {
	return (volatile.LoadUint32(&o.CSCR5.Reg) & 0xfc000000) >> 26
}

// FB.CSPMCR: Chip Select port Multiplexing Control Register
func (o *FB_Type) SetCSPMCR_GROUP5(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf000)|value<<12)
}
func (o *FB_Type) GetCSPMCR_GROUP5() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf000) >> 12
}
func (o *FB_Type) SetCSPMCR_GROUP4(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf0000)|value<<16)
}
func (o *FB_Type) GetCSPMCR_GROUP4() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf0000) >> 16
}
func (o *FB_Type) SetCSPMCR_GROUP3(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf00000)|value<<20)
}
func (o *FB_Type) GetCSPMCR_GROUP3() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf00000) >> 20
}
func (o *FB_Type) SetCSPMCR_GROUP2(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf000000)|value<<24)
}
func (o *FB_Type) GetCSPMCR_GROUP2() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf000000) >> 24
}
func (o *FB_Type) SetCSPMCR_GROUP1(value uint32) {
	volatile.StoreUint32(&o.CSPMCR.Reg, volatile.LoadUint32(&o.CSPMCR.Reg)&^(0xf0000000)|value<<28)
}
func (o *FB_Type) GetCSPMCR_GROUP1() uint32 {
	return (volatile.LoadUint32(&o.CSPMCR.Reg) & 0xf0000000) >> 28
}

// Memory protection unit
type SYSMPU_Type struct {
	CESR        volatile.Register32 // 0x0
	_           [12]byte
	EAR0        volatile.Register32 // 0x10
	EDR0        volatile.Register32 // 0x14
	EAR1        volatile.Register32 // 0x18
	EDR1        volatile.Register32 // 0x1C
	EAR2        volatile.Register32 // 0x20
	EDR2        volatile.Register32 // 0x24
	EAR3        volatile.Register32 // 0x28
	EDR3        volatile.Register32 // 0x2C
	EAR4        volatile.Register32 // 0x30
	EDR4        volatile.Register32 // 0x34
	_           [968]byte
	RGD0_WORD0  volatile.Register32 // 0x400
	RGD0_WORD1  volatile.Register32 // 0x404
	RGD0_WORD2  volatile.Register32 // 0x408
	RGD0_WORD3  volatile.Register32 // 0x40C
	RGD1_WORD0  volatile.Register32 // 0x410
	RGD1_WORD1  volatile.Register32 // 0x414
	RGD1_WORD2  volatile.Register32 // 0x418
	RGD1_WORD3  volatile.Register32 // 0x41C
	RGD2_WORD0  volatile.Register32 // 0x420
	RGD2_WORD1  volatile.Register32 // 0x424
	RGD2_WORD2  volatile.Register32 // 0x428
	RGD2_WORD3  volatile.Register32 // 0x42C
	RGD3_WORD0  volatile.Register32 // 0x430
	RGD3_WORD1  volatile.Register32 // 0x434
	RGD3_WORD2  volatile.Register32 // 0x438
	RGD3_WORD3  volatile.Register32 // 0x43C
	RGD4_WORD0  volatile.Register32 // 0x440
	RGD4_WORD1  volatile.Register32 // 0x444
	RGD4_WORD2  volatile.Register32 // 0x448
	RGD4_WORD3  volatile.Register32 // 0x44C
	RGD5_WORD0  volatile.Register32 // 0x450
	RGD5_WORD1  volatile.Register32 // 0x454
	RGD5_WORD2  volatile.Register32 // 0x458
	RGD5_WORD3  volatile.Register32 // 0x45C
	RGD6_WORD0  volatile.Register32 // 0x460
	RGD6_WORD1  volatile.Register32 // 0x464
	RGD6_WORD2  volatile.Register32 // 0x468
	RGD6_WORD3  volatile.Register32 // 0x46C
	RGD7_WORD0  volatile.Register32 // 0x470
	RGD7_WORD1  volatile.Register32 // 0x474
	RGD7_WORD2  volatile.Register32 // 0x478
	RGD7_WORD3  volatile.Register32 // 0x47C
	RGD8_WORD0  volatile.Register32 // 0x480
	RGD8_WORD1  volatile.Register32 // 0x484
	RGD8_WORD2  volatile.Register32 // 0x488
	RGD8_WORD3  volatile.Register32 // 0x48C
	RGD9_WORD0  volatile.Register32 // 0x490
	RGD9_WORD1  volatile.Register32 // 0x494
	RGD9_WORD2  volatile.Register32 // 0x498
	RGD9_WORD3  volatile.Register32 // 0x49C
	RGD10_WORD0 volatile.Register32 // 0x4A0
	RGD10_WORD1 volatile.Register32 // 0x4A4
	RGD10_WORD2 volatile.Register32 // 0x4A8
	RGD10_WORD3 volatile.Register32 // 0x4AC
	RGD11_WORD0 volatile.Register32 // 0x4B0
	RGD11_WORD1 volatile.Register32 // 0x4B4
	RGD11_WORD2 volatile.Register32 // 0x4B8
	RGD11_WORD3 volatile.Register32 // 0x4BC
	_           [832]byte
	RGDAAC0     volatile.Register32 // 0x800
	RGDAAC1     volatile.Register32 // 0x804
	RGDAAC2     volatile.Register32 // 0x808
	RGDAAC3     volatile.Register32 // 0x80C
	RGDAAC4     volatile.Register32 // 0x810
	RGDAAC5     volatile.Register32 // 0x814
	RGDAAC6     volatile.Register32 // 0x818
	RGDAAC7     volatile.Register32 // 0x81C
	RGDAAC8     volatile.Register32 // 0x820
	RGDAAC9     volatile.Register32 // 0x824
	RGDAAC10    volatile.Register32 // 0x828
	RGDAAC11    volatile.Register32 // 0x82C
}

// SYSMPU.CESR: Control/Error Status Register
func (o *SYSMPU_Type) SetCESR_VLD(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetCESR_VLD() uint32 {
	return volatile.LoadUint32(&o.CESR.Reg) & 0x1
}
func (o *SYSMPU_Type) SetCESR_NRGD(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0xf00)|value<<8)
}
func (o *SYSMPU_Type) GetCESR_NRGD() uint32 {
	return (volatile.LoadUint32(&o.CESR.Reg) & 0xf00) >> 8
}
func (o *SYSMPU_Type) SetCESR_NSP(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0xf000)|value<<12)
}
func (o *SYSMPU_Type) GetCESR_NSP() uint32 {
	return (volatile.LoadUint32(&o.CESR.Reg) & 0xf000) >> 12
}
func (o *SYSMPU_Type) SetCESR_HRL(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0xf0000)|value<<16)
}
func (o *SYSMPU_Type) GetCESR_HRL() uint32 {
	return (volatile.LoadUint32(&o.CESR.Reg) & 0xf0000) >> 16
}
func (o *SYSMPU_Type) SetCESR_SPERR(value uint32) {
	volatile.StoreUint32(&o.CESR.Reg, volatile.LoadUint32(&o.CESR.Reg)&^(0xf8000000)|value<<27)
}
func (o *SYSMPU_Type) GetCESR_SPERR() uint32 {
	return (volatile.LoadUint32(&o.CESR.Reg) & 0xf8000000) >> 27
}

// SYSMPU.EAR0: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR0(value uint32) {
	volatile.StoreUint32(&o.EAR0.Reg, value)
}
func (o *SYSMPU_Type) GetEAR0() uint32 {
	return volatile.LoadUint32(&o.EAR0.Reg)
}

// SYSMPU.EDR0: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR0_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR0_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR0.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR0_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR0_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR0.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR0_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR0_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR0.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR0_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR0_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR0.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR0_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR0.Reg, volatile.LoadUint32(&o.EDR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR0_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR0.Reg) & 0xffff0000) >> 16
}

// SYSMPU.EAR1: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR1(value uint32) {
	volatile.StoreUint32(&o.EAR1.Reg, value)
}
func (o *SYSMPU_Type) GetEAR1() uint32 {
	return volatile.LoadUint32(&o.EAR1.Reg)
}

// SYSMPU.EDR1: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR1_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR1_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR1.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR1_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR1_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR1.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR1_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR1_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR1.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR1_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR1_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR1.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR1_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR1.Reg, volatile.LoadUint32(&o.EDR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR1_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR1.Reg) & 0xffff0000) >> 16
}

// SYSMPU.EAR2: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR2(value uint32) {
	volatile.StoreUint32(&o.EAR2.Reg, value)
}
func (o *SYSMPU_Type) GetEAR2() uint32 {
	return volatile.LoadUint32(&o.EAR2.Reg)
}

// SYSMPU.EDR2: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR2_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR2_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR2.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR2_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR2_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR2.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR2_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR2_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR2.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR2_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR2_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR2.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR2_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR2.Reg, volatile.LoadUint32(&o.EDR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR2_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR2.Reg) & 0xffff0000) >> 16
}

// SYSMPU.EAR3: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR3(value uint32) {
	volatile.StoreUint32(&o.EAR3.Reg, value)
}
func (o *SYSMPU_Type) GetEAR3() uint32 {
	return volatile.LoadUint32(&o.EAR3.Reg)
}

// SYSMPU.EDR3: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR3_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR3_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR3_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR3_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR3.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR3_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR3_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR3.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR3_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR3_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR3.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR3_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR3.Reg, volatile.LoadUint32(&o.EDR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR3_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR3.Reg) & 0xffff0000) >> 16
}

// SYSMPU.EAR4: Error Address Register, slave port n
func (o *SYSMPU_Type) SetEAR4(value uint32) {
	volatile.StoreUint32(&o.EAR4.Reg, value)
}
func (o *SYSMPU_Type) GetEAR4() uint32 {
	return volatile.LoadUint32(&o.EAR4.Reg)
}

// SYSMPU.EDR4: Error Detail Register, slave port n
func (o *SYSMPU_Type) SetEDR4_ERW(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetEDR4_ERW() uint32 {
	return volatile.LoadUint32(&o.EDR4.Reg) & 0x1
}
func (o *SYSMPU_Type) SetEDR4_EATTR(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0xe)|value<<1)
}
func (o *SYSMPU_Type) GetEDR4_EATTR() uint32 {
	return (volatile.LoadUint32(&o.EDR4.Reg) & 0xe) >> 1
}
func (o *SYSMPU_Type) SetEDR4_EMN(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0xf0)|value<<4)
}
func (o *SYSMPU_Type) GetEDR4_EMN() uint32 {
	return (volatile.LoadUint32(&o.EDR4.Reg) & 0xf0) >> 4
}
func (o *SYSMPU_Type) SetEDR4_EPID(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0xff00)|value<<8)
}
func (o *SYSMPU_Type) GetEDR4_EPID() uint32 {
	return (volatile.LoadUint32(&o.EDR4.Reg) & 0xff00) >> 8
}
func (o *SYSMPU_Type) SetEDR4_EACD(value uint32) {
	volatile.StoreUint32(&o.EDR4.Reg, volatile.LoadUint32(&o.EDR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSMPU_Type) GetEDR4_EACD() uint32 {
	return (volatile.LoadUint32(&o.EDR4.Reg) & 0xffff0000) >> 16
}

// SYSMPU.RGD0_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD0_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD0.Reg, volatile.LoadUint32(&o.RGD0_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD0_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD0_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD0_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD1.Reg, volatile.LoadUint32(&o.RGD0_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD0_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD0_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD0_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD0_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD2.Reg, volatile.LoadUint32(&o.RGD0_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD0_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD0_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD0_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD3.Reg, volatile.LoadUint32(&o.RGD0_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD0_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD0_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD0_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD3.Reg, volatile.LoadUint32(&o.RGD0_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD0_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD0_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD0_WORD3.Reg, volatile.LoadUint32(&o.RGD0_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD0_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD0_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD1_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD1_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD0.Reg, volatile.LoadUint32(&o.RGD1_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD1_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD1_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD1_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD1.Reg, volatile.LoadUint32(&o.RGD1_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD1_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD1_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD1_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD1_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD2.Reg, volatile.LoadUint32(&o.RGD1_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD1_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD1_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD1_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD3.Reg, volatile.LoadUint32(&o.RGD1_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD1_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD1_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD1_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD3.Reg, volatile.LoadUint32(&o.RGD1_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD1_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD1_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD1_WORD3.Reg, volatile.LoadUint32(&o.RGD1_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD1_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD1_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD2_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD2_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD0.Reg, volatile.LoadUint32(&o.RGD2_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD2_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD2_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD2_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD1.Reg, volatile.LoadUint32(&o.RGD2_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD2_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD2_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD2_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD2_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD2.Reg, volatile.LoadUint32(&o.RGD2_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD2_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD2_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD2_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD3.Reg, volatile.LoadUint32(&o.RGD2_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD2_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD2_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD2_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD3.Reg, volatile.LoadUint32(&o.RGD2_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD2_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD2_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD2_WORD3.Reg, volatile.LoadUint32(&o.RGD2_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD2_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD2_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD3_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD3_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD0.Reg, volatile.LoadUint32(&o.RGD3_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD3_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD3_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD3_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD1.Reg, volatile.LoadUint32(&o.RGD3_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD3_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD3_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD3_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD3_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD2.Reg, volatile.LoadUint32(&o.RGD3_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD3_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD3_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD3_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD3.Reg, volatile.LoadUint32(&o.RGD3_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD3_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD3_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD3_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD3.Reg, volatile.LoadUint32(&o.RGD3_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD3_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD3_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD3_WORD3.Reg, volatile.LoadUint32(&o.RGD3_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD3_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD3_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD4_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD4_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD0.Reg, volatile.LoadUint32(&o.RGD4_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD4_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD4_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD4_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD1.Reg, volatile.LoadUint32(&o.RGD4_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD4_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD4_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD4_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD4_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD2.Reg, volatile.LoadUint32(&o.RGD4_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD4_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD4_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD4_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD3.Reg, volatile.LoadUint32(&o.RGD4_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD4_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD4_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD4_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD3.Reg, volatile.LoadUint32(&o.RGD4_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD4_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD4_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD4_WORD3.Reg, volatile.LoadUint32(&o.RGD4_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD4_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD4_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD5_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD5_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD0.Reg, volatile.LoadUint32(&o.RGD5_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD5_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD5_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD5_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD1.Reg, volatile.LoadUint32(&o.RGD5_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD5_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD5_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD5_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD5_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD2.Reg, volatile.LoadUint32(&o.RGD5_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD5_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD5_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD5_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD3.Reg, volatile.LoadUint32(&o.RGD5_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD5_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD5_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD5_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD3.Reg, volatile.LoadUint32(&o.RGD5_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD5_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD5_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD5_WORD3.Reg, volatile.LoadUint32(&o.RGD5_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD5_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD5_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD6_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD6_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD0.Reg, volatile.LoadUint32(&o.RGD6_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD6_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD6_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD6_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD1.Reg, volatile.LoadUint32(&o.RGD6_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD6_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD6_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD6_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD6_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD2.Reg, volatile.LoadUint32(&o.RGD6_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD6_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD6_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD6_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD3.Reg, volatile.LoadUint32(&o.RGD6_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD6_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD6_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD6_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD3.Reg, volatile.LoadUint32(&o.RGD6_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD6_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD6_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD6_WORD3.Reg, volatile.LoadUint32(&o.RGD6_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD6_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD6_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD7_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD7_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD0.Reg, volatile.LoadUint32(&o.RGD7_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD7_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD7_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD7_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD1.Reg, volatile.LoadUint32(&o.RGD7_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD7_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD7_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD7_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD7_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD2.Reg, volatile.LoadUint32(&o.RGD7_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD7_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD7_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD7_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD3.Reg, volatile.LoadUint32(&o.RGD7_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD7_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD7_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD7_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD3.Reg, volatile.LoadUint32(&o.RGD7_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD7_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD7_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD7_WORD3.Reg, volatile.LoadUint32(&o.RGD7_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD7_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD7_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD8_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD8_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD0.Reg, volatile.LoadUint32(&o.RGD8_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD8_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD8_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD8_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD1.Reg, volatile.LoadUint32(&o.RGD8_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD8_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD8_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD8_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD8_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD2.Reg, volatile.LoadUint32(&o.RGD8_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD8_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD8_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD8_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD3.Reg, volatile.LoadUint32(&o.RGD8_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD8_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD8_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD8_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD3.Reg, volatile.LoadUint32(&o.RGD8_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD8_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD8_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD8_WORD3.Reg, volatile.LoadUint32(&o.RGD8_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD8_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD8_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD9_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD9_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD0.Reg, volatile.LoadUint32(&o.RGD9_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD9_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD9_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD9_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD1.Reg, volatile.LoadUint32(&o.RGD9_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD9_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD9_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD9_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD9_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD2.Reg, volatile.LoadUint32(&o.RGD9_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD9_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD9_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD9_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD3.Reg, volatile.LoadUint32(&o.RGD9_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD9_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD9_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD9_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD3.Reg, volatile.LoadUint32(&o.RGD9_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD9_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD9_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD9_WORD3.Reg, volatile.LoadUint32(&o.RGD9_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD9_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD9_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD10_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD10_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD0.Reg, volatile.LoadUint32(&o.RGD10_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD10_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD10_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD10_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD1.Reg, volatile.LoadUint32(&o.RGD10_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD10_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD10_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD10_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD10_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD2.Reg, volatile.LoadUint32(&o.RGD10_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD10_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD10_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD10_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD3.Reg, volatile.LoadUint32(&o.RGD10_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD10_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD10_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD10_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD3.Reg, volatile.LoadUint32(&o.RGD10_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD10_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD10_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD10_WORD3.Reg, volatile.LoadUint32(&o.RGD10_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD10_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD10_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGD11_WORD0: Region Descriptor n, Word 0
func (o *SYSMPU_Type) SetRGD11_WORD0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD0.Reg, volatile.LoadUint32(&o.RGD11_WORD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD11_WORD0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD0.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD11_WORD1: Region Descriptor n, Word 1
func (o *SYSMPU_Type) SetRGD11_WORD1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD1.Reg, volatile.LoadUint32(&o.RGD11_WORD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSMPU_Type) GetRGD11_WORD1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD1.Reg) & 0xffffffe0) >> 5
}

// SYSMPU.RGD11_WORD2: Region Descriptor n, Word 2
func (o *SYSMPU_Type) SetRGD11_WORD2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGD11_WORD2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD2.Reg, volatile.LoadUint32(&o.RGD11_WORD2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGD11_WORD2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGD11_WORD3: Region Descriptor n, Word 3
func (o *SYSMPU_Type) SetRGD11_WORD3_VLD(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD3.Reg, volatile.LoadUint32(&o.RGD11_WORD3.Reg)&^(0x1)|value)
}
func (o *SYSMPU_Type) GetRGD11_WORD3_VLD() uint32 {
	return volatile.LoadUint32(&o.RGD11_WORD3.Reg) & 0x1
}
func (o *SYSMPU_Type) SetRGD11_WORD3_PIDMASK(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD3.Reg, volatile.LoadUint32(&o.RGD11_WORD3.Reg)&^(0xff0000)|value<<16)
}
func (o *SYSMPU_Type) GetRGD11_WORD3_PIDMASK() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD3.Reg) & 0xff0000) >> 16
}
func (o *SYSMPU_Type) SetRGD11_WORD3_PID(value uint32) {
	volatile.StoreUint32(&o.RGD11_WORD3.Reg, volatile.LoadUint32(&o.RGD11_WORD3.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGD11_WORD3_PID() uint32 {
	return (volatile.LoadUint32(&o.RGD11_WORD3.Reg) & 0xff000000) >> 24
}

// SYSMPU.RGDAAC0: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC0_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC0_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC0_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC0_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC0_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC0_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC0_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC0_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC0_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC0_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC0_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC0_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC0_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC0_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC0_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC0_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC0_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC0_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC0_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC0_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC0_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC0_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC0_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC0_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC0_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC0_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC0_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC0_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC0_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC0_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC0_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC0_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC0_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC0_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC0_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC0_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC0_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC0_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC0_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC0.Reg, volatile.LoadUint32(&o.RGDAAC0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC0_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC0.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC1: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC1_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC1_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC1_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC1_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC1_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC1_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC1_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC1_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC1_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC1_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC1_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC1_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC1_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC1_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC1_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC1_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC1_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC1_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC1_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC1_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC1_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC1_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC1_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC1_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC1_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC1_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC1_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC1_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC1_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC1_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC1_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC1_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC1_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC1_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC1_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC1_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC1_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC1_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC1_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC1.Reg, volatile.LoadUint32(&o.RGDAAC1.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC1_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC1.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC2: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC2_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC2_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC2_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC2_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC2_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC2_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC2_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC2_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC2_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC2_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC2_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC2_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC2_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC2_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC2_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC2_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC2_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC2_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC2_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC2_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC2_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC2_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC2_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC2_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC2_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC2_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC2_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC2_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC2_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC2_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC2_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC2_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC2_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC2_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC2_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC2_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC2_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC2_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC2_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC2.Reg, volatile.LoadUint32(&o.RGDAAC2.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC2_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC2.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC3: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC3_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC3_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC3_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC3_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC3_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC3_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC3_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC3_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC3_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC3_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC3_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC3_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC3_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC3_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC3_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC3_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC3_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC3_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC3_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC3_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC3_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC3_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC3_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC3_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC3_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC3_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC3_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC3_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC3_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC3_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC3_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC3_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC3_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC3_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC3_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC3_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC3_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC3_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC3_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC3.Reg, volatile.LoadUint32(&o.RGDAAC3.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC3_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC3.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC4: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC4_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC4_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC4_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC4_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC4_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC4_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC4_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC4_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC4_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC4_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC4_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC4_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC4_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC4_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC4_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC4_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC4_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC4_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC4_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC4_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC4_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC4_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC4_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC4_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC4_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC4_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC4_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC4_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC4_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC4_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC4_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC4_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC4_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC4_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC4_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC4_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC4_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC4_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC4_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC4.Reg, volatile.LoadUint32(&o.RGDAAC4.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC4_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC4.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC5: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC5_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC5_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC5_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC5_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC5_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC5_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC5_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC5_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC5_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC5_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC5_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC5_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC5_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC5_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC5_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC5_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC5_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC5_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC5_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC5_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC5_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC5_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC5_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC5_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC5_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC5_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC5_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC5_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC5_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC5_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC5_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC5_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC5_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC5_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC5_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC5_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC5_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC5_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC5_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC5.Reg, volatile.LoadUint32(&o.RGDAAC5.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC5_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC5.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC6: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC6_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC6_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC6_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC6_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC6_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC6_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC6_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC6_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC6_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC6_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC6_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC6_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC6_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC6_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC6_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC6_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC6_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC6_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC6_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC6_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC6_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC6_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC6_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC6_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC6_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC6_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC6_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC6_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC6_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC6_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC6_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC6_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC6_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC6_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC6_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC6_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC6_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC6_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC6_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC6.Reg, volatile.LoadUint32(&o.RGDAAC6.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC6_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC6.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC7: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC7_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC7_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC7_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC7_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC7_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC7_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC7_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC7_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC7_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC7_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC7_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC7_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC7_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC7_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC7_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC7_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC7_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC7_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC7_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC7_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC7_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC7_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC7_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC7_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC7_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC7_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC7_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC7_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC7_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC7_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC7_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC7_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC7_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC7_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC7_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC7_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC7_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC7_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC7_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC7.Reg, volatile.LoadUint32(&o.RGDAAC7.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC7_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC7.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC8: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC8_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC8_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC8_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC8_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC8_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC8_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC8_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC8_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC8_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC8_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC8_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC8_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC8_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC8_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC8_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC8_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC8_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC8_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC8_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC8_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC8_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC8_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC8_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC8_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC8_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC8_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC8_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC8_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC8_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC8_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC8_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC8_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC8_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC8_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC8_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC8_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC8_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC8_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC8_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC8.Reg, volatile.LoadUint32(&o.RGDAAC8.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC8_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC8.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC9: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC9_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC9_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC9_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC9_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC9_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC9_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC9_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC9_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC9_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC9_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC9_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC9_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC9_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC9_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC9_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC9_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC9_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC9_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC9_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC9_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC9_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC9_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC9_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC9_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC9_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC9_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC9_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC9_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC9_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC9_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC9_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC9_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC9_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC9_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC9_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC9_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC9_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC9_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC9_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC9.Reg, volatile.LoadUint32(&o.RGDAAC9.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC9_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC9.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC10: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC10_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC10_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC10_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC10_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC10_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC10_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC10_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC10_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC10_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC10_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC10_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC10_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC10_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC10_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC10_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC10_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC10_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC10_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC10_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC10_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC10_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC10_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC10_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC10_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC10_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC10_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC10_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC10_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC10_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC10_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC10_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC10_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC10_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC10_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC10_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC10_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC10_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC10_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC10_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC10.Reg, volatile.LoadUint32(&o.RGDAAC10.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC10_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC10.Reg) & 0x80000000) >> 31
}

// SYSMPU.RGDAAC11: Region Descriptor Alternate Access Control n
func (o *SYSMPU_Type) SetRGDAAC11_M0UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x7)|value)
}
func (o *SYSMPU_Type) GetRGDAAC11_M0UM() uint32 {
	return volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x7
}
func (o *SYSMPU_Type) SetRGDAAC11_M0SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x18)|value<<3)
}
func (o *SYSMPU_Type) GetRGDAAC11_M0SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x18) >> 3
}
func (o *SYSMPU_Type) SetRGDAAC11_M0PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x20)|value<<5)
}
func (o *SYSMPU_Type) GetRGDAAC11_M0PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x20) >> 5
}
func (o *SYSMPU_Type) SetRGDAAC11_M1UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x1c0)|value<<6)
}
func (o *SYSMPU_Type) GetRGDAAC11_M1UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x1c0) >> 6
}
func (o *SYSMPU_Type) SetRGDAAC11_M1SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x600)|value<<9)
}
func (o *SYSMPU_Type) GetRGDAAC11_M1SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x600) >> 9
}
func (o *SYSMPU_Type) SetRGDAAC11_M1PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x800)|value<<11)
}
func (o *SYSMPU_Type) GetRGDAAC11_M1PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x800) >> 11
}
func (o *SYSMPU_Type) SetRGDAAC11_M2UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x7000)|value<<12)
}
func (o *SYSMPU_Type) GetRGDAAC11_M2UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x7000) >> 12
}
func (o *SYSMPU_Type) SetRGDAAC11_M2SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x18000)|value<<15)
}
func (o *SYSMPU_Type) GetRGDAAC11_M2SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x18000) >> 15
}
func (o *SYSMPU_Type) SetRGDAAC11_M2PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x20000)|value<<17)
}
func (o *SYSMPU_Type) GetRGDAAC11_M2PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x20000) >> 17
}
func (o *SYSMPU_Type) SetRGDAAC11_M3UM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x1c0000)|value<<18)
}
func (o *SYSMPU_Type) GetRGDAAC11_M3UM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x1c0000) >> 18
}
func (o *SYSMPU_Type) SetRGDAAC11_M3SM(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x600000)|value<<21)
}
func (o *SYSMPU_Type) GetRGDAAC11_M3SM() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x600000) >> 21
}
func (o *SYSMPU_Type) SetRGDAAC11_M3PE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x800000)|value<<23)
}
func (o *SYSMPU_Type) GetRGDAAC11_M3PE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x800000) >> 23
}
func (o *SYSMPU_Type) SetRGDAAC11_M4WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSMPU_Type) GetRGDAAC11_M4WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x1000000) >> 24
}
func (o *SYSMPU_Type) SetRGDAAC11_M4RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSMPU_Type) GetRGDAAC11_M4RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x2000000) >> 25
}
func (o *SYSMPU_Type) SetRGDAAC11_M5WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSMPU_Type) GetRGDAAC11_M5WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x4000000) >> 26
}
func (o *SYSMPU_Type) SetRGDAAC11_M5RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSMPU_Type) GetRGDAAC11_M5RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x8000000) >> 27
}
func (o *SYSMPU_Type) SetRGDAAC11_M6WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSMPU_Type) GetRGDAAC11_M6WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x10000000) >> 28
}
func (o *SYSMPU_Type) SetRGDAAC11_M6RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSMPU_Type) GetRGDAAC11_M6RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x20000000) >> 29
}
func (o *SYSMPU_Type) SetRGDAAC11_M7WE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSMPU_Type) GetRGDAAC11_M7WE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x40000000) >> 30
}
func (o *SYSMPU_Type) SetRGDAAC11_M7RE(value uint32) {
	volatile.StoreUint32(&o.RGDAAC11.Reg, volatile.LoadUint32(&o.RGDAAC11.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSMPU_Type) GetRGDAAC11_M7RE() uint32 {
	return (volatile.LoadUint32(&o.RGDAAC11.Reg) & 0x80000000) >> 31
}

// Synchronous DRAM Controller
type SDRAM_Type struct {
	_    [66]byte
	CTRL volatile.Register16 // 0x42
	_    [4]byte
	AC0  volatile.Register32 // 0x48
	CM0  volatile.Register32 // 0x4C
	AC1  volatile.Register32 // 0x50
	CM1  volatile.Register32 // 0x54
}

// SDRAM.CTRL: Control Register
func (o *SDRAM_Type) SetCTRL_RC(value uint16) {
	volatile.StoreUint16(&o.CTRL.Reg, volatile.LoadUint16(&o.CTRL.Reg)&^(0x1ff)|value)
}
func (o *SDRAM_Type) GetCTRL_RC() uint16 {
	return volatile.LoadUint16(&o.CTRL.Reg) & 0x1ff
}
func (o *SDRAM_Type) SetCTRL_RTIM(value uint16) {
	volatile.StoreUint16(&o.CTRL.Reg, volatile.LoadUint16(&o.CTRL.Reg)&^(0x600)|value<<9)
}
func (o *SDRAM_Type) GetCTRL_RTIM() uint16 {
	return (volatile.LoadUint16(&o.CTRL.Reg) & 0x600) >> 9
}
func (o *SDRAM_Type) SetCTRL_IS(value uint16) {
	volatile.StoreUint16(&o.CTRL.Reg, volatile.LoadUint16(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *SDRAM_Type) GetCTRL_IS() uint16 {
	return (volatile.LoadUint16(&o.CTRL.Reg) & 0x800) >> 11
}

// SDRAM.AC0: Address and Control Register
func (o *SDRAM_Type) SetAC0_IP(value uint32) {
	volatile.StoreUint32(&o.AC0.Reg, volatile.LoadUint32(&o.AC0.Reg)&^(0x8)|value<<3)
}
func (o *SDRAM_Type) GetAC0_IP() uint32 {
	return (volatile.LoadUint32(&o.AC0.Reg) & 0x8) >> 3
}
func (o *SDRAM_Type) SetAC0_PS(value uint32) {
	volatile.StoreUint32(&o.AC0.Reg, volatile.LoadUint32(&o.AC0.Reg)&^(0x30)|value<<4)
}
func (o *SDRAM_Type) GetAC0_PS() uint32 {
	return (volatile.LoadUint32(&o.AC0.Reg) & 0x30) >> 4
}
func (o *SDRAM_Type) SetAC0_IMRS(value uint32) {
	volatile.StoreUint32(&o.AC0.Reg, volatile.LoadUint32(&o.AC0.Reg)&^(0x40)|value<<6)
}
func (o *SDRAM_Type) GetAC0_IMRS() uint32 {
	return (volatile.LoadUint32(&o.AC0.Reg) & 0x40) >> 6
}
func (o *SDRAM_Type) SetAC0_CBM(value uint32) {
	volatile.StoreUint32(&o.AC0.Reg, volatile.LoadUint32(&o.AC0.Reg)&^(0x700)|value<<8)
}
func (o *SDRAM_Type) GetAC0_CBM() uint32 {
	return (volatile.LoadUint32(&o.AC0.Reg) & 0x700) >> 8
}
func (o *SDRAM_Type) SetAC0_CASL(value uint32) {
	volatile.StoreUint32(&o.AC0.Reg, volatile.LoadUint32(&o.AC0.Reg)&^(0x3000)|value<<12)
}
func (o *SDRAM_Type) GetAC0_CASL() uint32 {
	return (volatile.LoadUint32(&o.AC0.Reg) & 0x3000) >> 12
}
func (o *SDRAM_Type) SetAC0_RE(value uint32) {
	volatile.StoreUint32(&o.AC0.Reg, volatile.LoadUint32(&o.AC0.Reg)&^(0x8000)|value<<15)
}
func (o *SDRAM_Type) GetAC0_RE() uint32 {
	return (volatile.LoadUint32(&o.AC0.Reg) & 0x8000) >> 15
}
func (o *SDRAM_Type) SetAC0_BA(value uint32) {
	volatile.StoreUint32(&o.AC0.Reg, volatile.LoadUint32(&o.AC0.Reg)&^(0xfffc0000)|value<<18)
}
func (o *SDRAM_Type) GetAC0_BA() uint32 {
	return (volatile.LoadUint32(&o.AC0.Reg) & 0xfffc0000) >> 18
}

// SDRAM.CM0: Control Mask
func (o *SDRAM_Type) SetCM0_V(value uint32) {
	volatile.StoreUint32(&o.CM0.Reg, volatile.LoadUint32(&o.CM0.Reg)&^(0x1)|value)
}
func (o *SDRAM_Type) GetCM0_V() uint32 {
	return volatile.LoadUint32(&o.CM0.Reg) & 0x1
}
func (o *SDRAM_Type) SetCM0_WP(value uint32) {
	volatile.StoreUint32(&o.CM0.Reg, volatile.LoadUint32(&o.CM0.Reg)&^(0x100)|value<<8)
}
func (o *SDRAM_Type) GetCM0_WP() uint32 {
	return (volatile.LoadUint32(&o.CM0.Reg) & 0x100) >> 8
}
func (o *SDRAM_Type) SetCM0_BAM(value uint32) {
	volatile.StoreUint32(&o.CM0.Reg, volatile.LoadUint32(&o.CM0.Reg)&^(0xfffc0000)|value<<18)
}
func (o *SDRAM_Type) GetCM0_BAM() uint32 {
	return (volatile.LoadUint32(&o.CM0.Reg) & 0xfffc0000) >> 18
}

// SDRAM.AC1: Address and Control Register
func (o *SDRAM_Type) SetAC1_IP(value uint32) {
	volatile.StoreUint32(&o.AC1.Reg, volatile.LoadUint32(&o.AC1.Reg)&^(0x8)|value<<3)
}
func (o *SDRAM_Type) GetAC1_IP() uint32 {
	return (volatile.LoadUint32(&o.AC1.Reg) & 0x8) >> 3
}
func (o *SDRAM_Type) SetAC1_PS(value uint32) {
	volatile.StoreUint32(&o.AC1.Reg, volatile.LoadUint32(&o.AC1.Reg)&^(0x30)|value<<4)
}
func (o *SDRAM_Type) GetAC1_PS() uint32 {
	return (volatile.LoadUint32(&o.AC1.Reg) & 0x30) >> 4
}
func (o *SDRAM_Type) SetAC1_IMRS(value uint32) {
	volatile.StoreUint32(&o.AC1.Reg, volatile.LoadUint32(&o.AC1.Reg)&^(0x40)|value<<6)
}
func (o *SDRAM_Type) GetAC1_IMRS() uint32 {
	return (volatile.LoadUint32(&o.AC1.Reg) & 0x40) >> 6
}
func (o *SDRAM_Type) SetAC1_CBM(value uint32) {
	volatile.StoreUint32(&o.AC1.Reg, volatile.LoadUint32(&o.AC1.Reg)&^(0x700)|value<<8)
}
func (o *SDRAM_Type) GetAC1_CBM() uint32 {
	return (volatile.LoadUint32(&o.AC1.Reg) & 0x700) >> 8
}
func (o *SDRAM_Type) SetAC1_CASL(value uint32) {
	volatile.StoreUint32(&o.AC1.Reg, volatile.LoadUint32(&o.AC1.Reg)&^(0x3000)|value<<12)
}
func (o *SDRAM_Type) GetAC1_CASL() uint32 {
	return (volatile.LoadUint32(&o.AC1.Reg) & 0x3000) >> 12
}
func (o *SDRAM_Type) SetAC1_RE(value uint32) {
	volatile.StoreUint32(&o.AC1.Reg, volatile.LoadUint32(&o.AC1.Reg)&^(0x8000)|value<<15)
}
func (o *SDRAM_Type) GetAC1_RE() uint32 {
	return (volatile.LoadUint32(&o.AC1.Reg) & 0x8000) >> 15
}
func (o *SDRAM_Type) SetAC1_BA(value uint32) {
	volatile.StoreUint32(&o.AC1.Reg, volatile.LoadUint32(&o.AC1.Reg)&^(0xfffc0000)|value<<18)
}
func (o *SDRAM_Type) GetAC1_BA() uint32 {
	return (volatile.LoadUint32(&o.AC1.Reg) & 0xfffc0000) >> 18
}

// SDRAM.CM1: Control Mask
func (o *SDRAM_Type) SetCM1_V(value uint32) {
	volatile.StoreUint32(&o.CM1.Reg, volatile.LoadUint32(&o.CM1.Reg)&^(0x1)|value)
}
func (o *SDRAM_Type) GetCM1_V() uint32 {
	return volatile.LoadUint32(&o.CM1.Reg) & 0x1
}
func (o *SDRAM_Type) SetCM1_WP(value uint32) {
	volatile.StoreUint32(&o.CM1.Reg, volatile.LoadUint32(&o.CM1.Reg)&^(0x100)|value<<8)
}
func (o *SDRAM_Type) GetCM1_WP() uint32 {
	return (volatile.LoadUint32(&o.CM1.Reg) & 0x100) >> 8
}
func (o *SDRAM_Type) SetCM1_BAM(value uint32) {
	volatile.StoreUint32(&o.CM1.Reg, volatile.LoadUint32(&o.CM1.Reg)&^(0xfffc0000)|value<<18)
}
func (o *SDRAM_Type) GetCM1_BAM() uint32 {
	return (volatile.LoadUint32(&o.CM1.Reg) & 0xfffc0000) >> 18
}

// Flash Memory Controller-greg
type FMC_Type struct {
	PFAPR      volatile.Register32 // 0x0
	PFB01CR    volatile.Register32 // 0x4
	PFB23CR    volatile.Register32 // 0x8
	_          [244]byte
	TAGVDW0S0  volatile.Register32 // 0x100
	TAGVDW0S1  volatile.Register32 // 0x104
	TAGVDW0S2  volatile.Register32 // 0x108
	TAGVDW0S3  volatile.Register32 // 0x10C
	TAGVDW1S0  volatile.Register32 // 0x110
	TAGVDW1S1  volatile.Register32 // 0x114
	TAGVDW1S2  volatile.Register32 // 0x118
	TAGVDW1S3  volatile.Register32 // 0x11C
	TAGVDW2S0  volatile.Register32 // 0x120
	TAGVDW2S1  volatile.Register32 // 0x124
	TAGVDW2S2  volatile.Register32 // 0x128
	TAGVDW2S3  volatile.Register32 // 0x12C
	TAGVDW3S0  volatile.Register32 // 0x130
	TAGVDW3S1  volatile.Register32 // 0x134
	TAGVDW3S2  volatile.Register32 // 0x138
	TAGVDW3S3  volatile.Register32 // 0x13C
	_          [192]byte
	DATAW0S0UM volatile.Register32 // 0x200
	DATAW0S0MU volatile.Register32 // 0x204
	DATAW0S0ML volatile.Register32 // 0x208
	DATAW0S0LM volatile.Register32 // 0x20C
	DATAW0S1UM volatile.Register32 // 0x210
	DATAW0S1MU volatile.Register32 // 0x214
	DATAW0S1ML volatile.Register32 // 0x218
	DATAW0S1LM volatile.Register32 // 0x21C
	DATAW0S2UM volatile.Register32 // 0x220
	DATAW0S2MU volatile.Register32 // 0x224
	DATAW0S2ML volatile.Register32 // 0x228
	DATAW0S2LM volatile.Register32 // 0x22C
	DATAW0S3UM volatile.Register32 // 0x230
	DATAW0S3MU volatile.Register32 // 0x234
	DATAW0S3ML volatile.Register32 // 0x238
	DATAW0S3LM volatile.Register32 // 0x23C
	DATAW1S0UM volatile.Register32 // 0x240
	DATAW1S0MU volatile.Register32 // 0x244
	DATAW1S0ML volatile.Register32 // 0x248
	DATAW1S0LM volatile.Register32 // 0x24C
	DATAW1S1UM volatile.Register32 // 0x250
	DATAW1S1MU volatile.Register32 // 0x254
	DATAW1S1ML volatile.Register32 // 0x258
	DATAW1S1LM volatile.Register32 // 0x25C
	DATAW1S2UM volatile.Register32 // 0x260
	DATAW1S2MU volatile.Register32 // 0x264
	DATAW1S2ML volatile.Register32 // 0x268
	DATAW1S2LM volatile.Register32 // 0x26C
	DATAW1S3UM volatile.Register32 // 0x270
	DATAW1S3MU volatile.Register32 // 0x274
	DATAW1S3ML volatile.Register32 // 0x278
	DATAW1S3LM volatile.Register32 // 0x27C
	DATAW2S0UM volatile.Register32 // 0x280
	DATAW2S0MU volatile.Register32 // 0x284
	DATAW2S0ML volatile.Register32 // 0x288
	DATAW2S0LM volatile.Register32 // 0x28C
	DATAW2S1UM volatile.Register32 // 0x290
	DATAW2S1MU volatile.Register32 // 0x294
	DATAW2S1ML volatile.Register32 // 0x298
	DATAW2S1LM volatile.Register32 // 0x29C
	DATAW2S2UM volatile.Register32 // 0x2A0
	DATAW2S2MU volatile.Register32 // 0x2A4
	DATAW2S2ML volatile.Register32 // 0x2A8
	DATAW2S2LM volatile.Register32 // 0x2AC
	DATAW2S3UM volatile.Register32 // 0x2B0
	DATAW2S3MU volatile.Register32 // 0x2B4
	DATAW2S3ML volatile.Register32 // 0x2B8
	DATAW2S3LM volatile.Register32 // 0x2BC
	DATAW3S0UM volatile.Register32 // 0x2C0
	DATAW3S0MU volatile.Register32 // 0x2C4
	DATAW3S0ML volatile.Register32 // 0x2C8
	DATAW3S0LM volatile.Register32 // 0x2CC
	DATAW3S1UM volatile.Register32 // 0x2D0
	DATAW3S1MU volatile.Register32 // 0x2D4
	DATAW3S1ML volatile.Register32 // 0x2D8
	DATAW3S1LM volatile.Register32 // 0x2DC
	DATAW3S2UM volatile.Register32 // 0x2E0
	DATAW3S2MU volatile.Register32 // 0x2E4
	DATAW3S2ML volatile.Register32 // 0x2E8
	DATAW3S2LM volatile.Register32 // 0x2EC
	DATAW3S3UM volatile.Register32 // 0x2F0
	DATAW3S3MU volatile.Register32 // 0x2F4
	DATAW3S3ML volatile.Register32 // 0x2F8
	DATAW3S3LM volatile.Register32 // 0x2FC
}

// FMC.PFAPR: Flash Access Protection Register
func (o *FMC_Type) SetPFAPR_M0AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x3)|value)
}
func (o *FMC_Type) GetPFAPR_M0AP() uint32 {
	return volatile.LoadUint32(&o.PFAPR.Reg) & 0x3
}
func (o *FMC_Type) SetPFAPR_M1AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetPFAPR_M1AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetPFAPR_M2AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetPFAPR_M2AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetPFAPR_M3AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0xc0)|value<<6)
}
func (o *FMC_Type) GetPFAPR_M3AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0xc0) >> 6
}
func (o *FMC_Type) SetPFAPR_M4AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x300)|value<<8)
}
func (o *FMC_Type) GetPFAPR_M4AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x300) >> 8
}
func (o *FMC_Type) SetPFAPR_M5AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0xc00)|value<<10)
}
func (o *FMC_Type) GetPFAPR_M5AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0xc00) >> 10
}
func (o *FMC_Type) SetPFAPR_M6AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x3000)|value<<12)
}
func (o *FMC_Type) GetPFAPR_M6AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x3000) >> 12
}
func (o *FMC_Type) SetPFAPR_M7AP(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0xc000)|value<<14)
}
func (o *FMC_Type) GetPFAPR_M7AP() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0xc000) >> 14
}
func (o *FMC_Type) SetPFAPR_M0PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x10000)|value<<16)
}
func (o *FMC_Type) GetPFAPR_M0PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x10000) >> 16
}
func (o *FMC_Type) SetPFAPR_M1PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x20000)|value<<17)
}
func (o *FMC_Type) GetPFAPR_M1PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x20000) >> 17
}
func (o *FMC_Type) SetPFAPR_M2PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x40000)|value<<18)
}
func (o *FMC_Type) GetPFAPR_M2PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x40000) >> 18
}
func (o *FMC_Type) SetPFAPR_M3PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetPFAPR_M3PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetPFAPR_M4PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x100000)|value<<20)
}
func (o *FMC_Type) GetPFAPR_M4PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x100000) >> 20
}
func (o *FMC_Type) SetPFAPR_M5PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x200000)|value<<21)
}
func (o *FMC_Type) GetPFAPR_M5PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x200000) >> 21
}
func (o *FMC_Type) SetPFAPR_M6PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x400000)|value<<22)
}
func (o *FMC_Type) GetPFAPR_M6PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x400000) >> 22
}
func (o *FMC_Type) SetPFAPR_M7PFD(value uint32) {
	volatile.StoreUint32(&o.PFAPR.Reg, volatile.LoadUint32(&o.PFAPR.Reg)&^(0x800000)|value<<23)
}
func (o *FMC_Type) GetPFAPR_M7PFD() uint32 {
	return (volatile.LoadUint32(&o.PFAPR.Reg) & 0x800000) >> 23
}

// FMC.PFB01CR: Flash Bank 0-1 Control Register
func (o *FMC_Type) SetPFB01CR_RFU(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetPFB01CR_RFU() uint32 {
	return volatile.LoadUint32(&o.PFB01CR.Reg) & 0x1
}
func (o *FMC_Type) SetPFB01CR_B0IPE(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetPFB01CR_B0IPE() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetPFB01CR_B0DPE(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0x4)|value<<2)
}
func (o *FMC_Type) GetPFB01CR_B0DPE() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0x4) >> 2
}
func (o *FMC_Type) SetPFB01CR_B0ICE(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0x8)|value<<3)
}
func (o *FMC_Type) GetPFB01CR_B0ICE() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0x8) >> 3
}
func (o *FMC_Type) SetPFB01CR_B0DCE(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0x10)|value<<4)
}
func (o *FMC_Type) GetPFB01CR_B0DCE() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0x10) >> 4
}
func (o *FMC_Type) SetPFB01CR_CRC(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0xe0)|value<<5)
}
func (o *FMC_Type) GetPFB01CR_CRC() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0xe0) >> 5
}
func (o *FMC_Type) SetPFB01CR_B0MW(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0x60000)|value<<17)
}
func (o *FMC_Type) GetPFB01CR_B0MW() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0x60000) >> 17
}
func (o *FMC_Type) SetPFB01CR_S_B_INV(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetPFB01CR_S_B_INV() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetPFB01CR_CINV_WAY(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetPFB01CR_CINV_WAY() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetPFB01CR_CLCK_WAY(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetPFB01CR_CLCK_WAY() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetPFB01CR_B0RWSC(value uint32) {
	volatile.StoreUint32(&o.PFB01CR.Reg, volatile.LoadUint32(&o.PFB01CR.Reg)&^(0xf0000000)|value<<28)
}
func (o *FMC_Type) GetPFB01CR_B0RWSC() uint32 {
	return (volatile.LoadUint32(&o.PFB01CR.Reg) & 0xf0000000) >> 28
}

// FMC.PFB23CR: Flash Bank 2-3 Control Register
func (o *FMC_Type) SetPFB23CR_RFU(value uint32) {
	volatile.StoreUint32(&o.PFB23CR.Reg, volatile.LoadUint32(&o.PFB23CR.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetPFB23CR_RFU() uint32 {
	return volatile.LoadUint32(&o.PFB23CR.Reg) & 0x1
}
func (o *FMC_Type) SetPFB23CR_B1IPE(value uint32) {
	volatile.StoreUint32(&o.PFB23CR.Reg, volatile.LoadUint32(&o.PFB23CR.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetPFB23CR_B1IPE() uint32 {
	return (volatile.LoadUint32(&o.PFB23CR.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetPFB23CR_B1DPE(value uint32) {
	volatile.StoreUint32(&o.PFB23CR.Reg, volatile.LoadUint32(&o.PFB23CR.Reg)&^(0x4)|value<<2)
}
func (o *FMC_Type) GetPFB23CR_B1DPE() uint32 {
	return (volatile.LoadUint32(&o.PFB23CR.Reg) & 0x4) >> 2
}
func (o *FMC_Type) SetPFB23CR_B1ICE(value uint32) {
	volatile.StoreUint32(&o.PFB23CR.Reg, volatile.LoadUint32(&o.PFB23CR.Reg)&^(0x8)|value<<3)
}
func (o *FMC_Type) GetPFB23CR_B1ICE() uint32 {
	return (volatile.LoadUint32(&o.PFB23CR.Reg) & 0x8) >> 3
}
func (o *FMC_Type) SetPFB23CR_B1DCE(value uint32) {
	volatile.StoreUint32(&o.PFB23CR.Reg, volatile.LoadUint32(&o.PFB23CR.Reg)&^(0x10)|value<<4)
}
func (o *FMC_Type) GetPFB23CR_B1DCE() uint32 {
	return (volatile.LoadUint32(&o.PFB23CR.Reg) & 0x10) >> 4
}
func (o *FMC_Type) SetPFB23CR_B1MW(value uint32) {
	volatile.StoreUint32(&o.PFB23CR.Reg, volatile.LoadUint32(&o.PFB23CR.Reg)&^(0x60000)|value<<17)
}
func (o *FMC_Type) GetPFB23CR_B1MW() uint32 {
	return (volatile.LoadUint32(&o.PFB23CR.Reg) & 0x60000) >> 17
}
func (o *FMC_Type) SetPFB23CR_B1RWSC(value uint32) {
	volatile.StoreUint32(&o.PFB23CR.Reg, volatile.LoadUint32(&o.PFB23CR.Reg)&^(0xf0000000)|value<<28)
}
func (o *FMC_Type) GetPFB23CR_B1RWSC() uint32 {
	return (volatile.LoadUint32(&o.PFB23CR.Reg) & 0xf0000000) >> 28
}

// FMC.TAGVDW0S0: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW0S0_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S0.Reg, volatile.LoadUint32(&o.TAGVDW0S0.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW0S0_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW0S0.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW0S0_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S0.Reg, volatile.LoadUint32(&o.TAGVDW0S0.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW0S0_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW0S0.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW0S1: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW0S1_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S1.Reg, volatile.LoadUint32(&o.TAGVDW0S1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW0S1_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW0S1.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW0S1_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S1.Reg, volatile.LoadUint32(&o.TAGVDW0S1.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW0S1_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW0S1.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW0S2: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW0S2_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S2.Reg, volatile.LoadUint32(&o.TAGVDW0S2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW0S2_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW0S2.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW0S2_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S2.Reg, volatile.LoadUint32(&o.TAGVDW0S2.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW0S2_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW0S2.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW0S3: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW0S3_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S3.Reg, volatile.LoadUint32(&o.TAGVDW0S3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW0S3_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW0S3.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW0S3_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW0S3.Reg, volatile.LoadUint32(&o.TAGVDW0S3.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW0S3_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW0S3.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW1S0: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW1S0_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S0.Reg, volatile.LoadUint32(&o.TAGVDW1S0.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW1S0_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW1S0.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW1S0_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S0.Reg, volatile.LoadUint32(&o.TAGVDW1S0.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW1S0_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW1S0.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW1S1: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW1S1_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S1.Reg, volatile.LoadUint32(&o.TAGVDW1S1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW1S1_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW1S1.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW1S1_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S1.Reg, volatile.LoadUint32(&o.TAGVDW1S1.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW1S1_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW1S1.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW1S2: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW1S2_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S2.Reg, volatile.LoadUint32(&o.TAGVDW1S2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW1S2_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW1S2.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW1S2_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S2.Reg, volatile.LoadUint32(&o.TAGVDW1S2.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW1S2_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW1S2.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW1S3: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW1S3_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S3.Reg, volatile.LoadUint32(&o.TAGVDW1S3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW1S3_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW1S3.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW1S3_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW1S3.Reg, volatile.LoadUint32(&o.TAGVDW1S3.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW1S3_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW1S3.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW2S0: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW2S0_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S0.Reg, volatile.LoadUint32(&o.TAGVDW2S0.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW2S0_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW2S0.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW2S0_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S0.Reg, volatile.LoadUint32(&o.TAGVDW2S0.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW2S0_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW2S0.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW2S1: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW2S1_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S1.Reg, volatile.LoadUint32(&o.TAGVDW2S1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW2S1_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW2S1.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW2S1_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S1.Reg, volatile.LoadUint32(&o.TAGVDW2S1.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW2S1_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW2S1.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW2S2: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW2S2_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S2.Reg, volatile.LoadUint32(&o.TAGVDW2S2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW2S2_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW2S2.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW2S2_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S2.Reg, volatile.LoadUint32(&o.TAGVDW2S2.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW2S2_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW2S2.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW2S3: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW2S3_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S3.Reg, volatile.LoadUint32(&o.TAGVDW2S3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW2S3_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW2S3.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW2S3_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW2S3.Reg, volatile.LoadUint32(&o.TAGVDW2S3.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW2S3_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW2S3.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW3S0: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW3S0_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S0.Reg, volatile.LoadUint32(&o.TAGVDW3S0.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW3S0_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW3S0.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW3S0_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S0.Reg, volatile.LoadUint32(&o.TAGVDW3S0.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW3S0_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW3S0.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW3S1: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW3S1_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S1.Reg, volatile.LoadUint32(&o.TAGVDW3S1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW3S1_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW3S1.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW3S1_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S1.Reg, volatile.LoadUint32(&o.TAGVDW3S1.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW3S1_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW3S1.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW3S2: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW3S2_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S2.Reg, volatile.LoadUint32(&o.TAGVDW3S2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW3S2_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW3S2.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW3S2_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S2.Reg, volatile.LoadUint32(&o.TAGVDW3S2.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW3S2_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW3S2.Reg) & 0x3fffc0) >> 6
}

// FMC.TAGVDW3S3: Cache Tag Storage
func (o *FMC_Type) SetTAGVDW3S3_VALID(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S3.Reg, volatile.LoadUint32(&o.TAGVDW3S3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetTAGVDW3S3_VALID() uint32 {
	return volatile.LoadUint32(&o.TAGVDW3S3.Reg) & 0x1
}
func (o *FMC_Type) SetTAGVDW3S3_TAG(value uint32) {
	volatile.StoreUint32(&o.TAGVDW3S3.Reg, volatile.LoadUint32(&o.TAGVDW3S3.Reg)&^(0x3fffc0)|value<<6)
}
func (o *FMC_Type) GetTAGVDW3S3_TAG() uint32 {
	return (volatile.LoadUint32(&o.TAGVDW3S3.Reg) & 0x3fffc0) >> 6
}

// FMC.DATAW0S0UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW0S0UM(value uint32) {
	volatile.StoreUint32(&o.DATAW0S0UM.Reg, value)
}
func (o *FMC_Type) GetDATAW0S0UM() uint32 {
	return volatile.LoadUint32(&o.DATAW0S0UM.Reg)
}

// FMC.DATAW0S0MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW0S0MU(value uint32) {
	volatile.StoreUint32(&o.DATAW0S0MU.Reg, value)
}
func (o *FMC_Type) GetDATAW0S0MU() uint32 {
	return volatile.LoadUint32(&o.DATAW0S0MU.Reg)
}

// FMC.DATAW0S0ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW0S0ML(value uint32) {
	volatile.StoreUint32(&o.DATAW0S0ML.Reg, value)
}
func (o *FMC_Type) GetDATAW0S0ML() uint32 {
	return volatile.LoadUint32(&o.DATAW0S0ML.Reg)
}

// FMC.DATAW0S0LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW0S0LM(value uint32) {
	volatile.StoreUint32(&o.DATAW0S0LM.Reg, value)
}
func (o *FMC_Type) GetDATAW0S0LM() uint32 {
	return volatile.LoadUint32(&o.DATAW0S0LM.Reg)
}

// FMC.DATAW0S1UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW0S1UM(value uint32) {
	volatile.StoreUint32(&o.DATAW0S1UM.Reg, value)
}
func (o *FMC_Type) GetDATAW0S1UM() uint32 {
	return volatile.LoadUint32(&o.DATAW0S1UM.Reg)
}

// FMC.DATAW0S1MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW0S1MU(value uint32) {
	volatile.StoreUint32(&o.DATAW0S1MU.Reg, value)
}
func (o *FMC_Type) GetDATAW0S1MU() uint32 {
	return volatile.LoadUint32(&o.DATAW0S1MU.Reg)
}

// FMC.DATAW0S1ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW0S1ML(value uint32) {
	volatile.StoreUint32(&o.DATAW0S1ML.Reg, value)
}
func (o *FMC_Type) GetDATAW0S1ML() uint32 {
	return volatile.LoadUint32(&o.DATAW0S1ML.Reg)
}

// FMC.DATAW0S1LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW0S1LM(value uint32) {
	volatile.StoreUint32(&o.DATAW0S1LM.Reg, value)
}
func (o *FMC_Type) GetDATAW0S1LM() uint32 {
	return volatile.LoadUint32(&o.DATAW0S1LM.Reg)
}

// FMC.DATAW0S2UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW0S2UM(value uint32) {
	volatile.StoreUint32(&o.DATAW0S2UM.Reg, value)
}
func (o *FMC_Type) GetDATAW0S2UM() uint32 {
	return volatile.LoadUint32(&o.DATAW0S2UM.Reg)
}

// FMC.DATAW0S2MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW0S2MU(value uint32) {
	volatile.StoreUint32(&o.DATAW0S2MU.Reg, value)
}
func (o *FMC_Type) GetDATAW0S2MU() uint32 {
	return volatile.LoadUint32(&o.DATAW0S2MU.Reg)
}

// FMC.DATAW0S2ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW0S2ML(value uint32) {
	volatile.StoreUint32(&o.DATAW0S2ML.Reg, value)
}
func (o *FMC_Type) GetDATAW0S2ML() uint32 {
	return volatile.LoadUint32(&o.DATAW0S2ML.Reg)
}

// FMC.DATAW0S2LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW0S2LM(value uint32) {
	volatile.StoreUint32(&o.DATAW0S2LM.Reg, value)
}
func (o *FMC_Type) GetDATAW0S2LM() uint32 {
	return volatile.LoadUint32(&o.DATAW0S2LM.Reg)
}

// FMC.DATAW0S3UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW0S3UM(value uint32) {
	volatile.StoreUint32(&o.DATAW0S3UM.Reg, value)
}
func (o *FMC_Type) GetDATAW0S3UM() uint32 {
	return volatile.LoadUint32(&o.DATAW0S3UM.Reg)
}

// FMC.DATAW0S3MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW0S3MU(value uint32) {
	volatile.StoreUint32(&o.DATAW0S3MU.Reg, value)
}
func (o *FMC_Type) GetDATAW0S3MU() uint32 {
	return volatile.LoadUint32(&o.DATAW0S3MU.Reg)
}

// FMC.DATAW0S3ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW0S3ML(value uint32) {
	volatile.StoreUint32(&o.DATAW0S3ML.Reg, value)
}
func (o *FMC_Type) GetDATAW0S3ML() uint32 {
	return volatile.LoadUint32(&o.DATAW0S3ML.Reg)
}

// FMC.DATAW0S3LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW0S3LM(value uint32) {
	volatile.StoreUint32(&o.DATAW0S3LM.Reg, value)
}
func (o *FMC_Type) GetDATAW0S3LM() uint32 {
	return volatile.LoadUint32(&o.DATAW0S3LM.Reg)
}

// FMC.DATAW1S0UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW1S0UM(value uint32) {
	volatile.StoreUint32(&o.DATAW1S0UM.Reg, value)
}
func (o *FMC_Type) GetDATAW1S0UM() uint32 {
	return volatile.LoadUint32(&o.DATAW1S0UM.Reg)
}

// FMC.DATAW1S0MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW1S0MU(value uint32) {
	volatile.StoreUint32(&o.DATAW1S0MU.Reg, value)
}
func (o *FMC_Type) GetDATAW1S0MU() uint32 {
	return volatile.LoadUint32(&o.DATAW1S0MU.Reg)
}

// FMC.DATAW1S0ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW1S0ML(value uint32) {
	volatile.StoreUint32(&o.DATAW1S0ML.Reg, value)
}
func (o *FMC_Type) GetDATAW1S0ML() uint32 {
	return volatile.LoadUint32(&o.DATAW1S0ML.Reg)
}

// FMC.DATAW1S0LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW1S0LM(value uint32) {
	volatile.StoreUint32(&o.DATAW1S0LM.Reg, value)
}
func (o *FMC_Type) GetDATAW1S0LM() uint32 {
	return volatile.LoadUint32(&o.DATAW1S0LM.Reg)
}

// FMC.DATAW1S1UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW1S1UM(value uint32) {
	volatile.StoreUint32(&o.DATAW1S1UM.Reg, value)
}
func (o *FMC_Type) GetDATAW1S1UM() uint32 {
	return volatile.LoadUint32(&o.DATAW1S1UM.Reg)
}

// FMC.DATAW1S1MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW1S1MU(value uint32) {
	volatile.StoreUint32(&o.DATAW1S1MU.Reg, value)
}
func (o *FMC_Type) GetDATAW1S1MU() uint32 {
	return volatile.LoadUint32(&o.DATAW1S1MU.Reg)
}

// FMC.DATAW1S1ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW1S1ML(value uint32) {
	volatile.StoreUint32(&o.DATAW1S1ML.Reg, value)
}
func (o *FMC_Type) GetDATAW1S1ML() uint32 {
	return volatile.LoadUint32(&o.DATAW1S1ML.Reg)
}

// FMC.DATAW1S1LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW1S1LM(value uint32) {
	volatile.StoreUint32(&o.DATAW1S1LM.Reg, value)
}
func (o *FMC_Type) GetDATAW1S1LM() uint32 {
	return volatile.LoadUint32(&o.DATAW1S1LM.Reg)
}

// FMC.DATAW1S2UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW1S2UM(value uint32) {
	volatile.StoreUint32(&o.DATAW1S2UM.Reg, value)
}
func (o *FMC_Type) GetDATAW1S2UM() uint32 {
	return volatile.LoadUint32(&o.DATAW1S2UM.Reg)
}

// FMC.DATAW1S2MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW1S2MU(value uint32) {
	volatile.StoreUint32(&o.DATAW1S2MU.Reg, value)
}
func (o *FMC_Type) GetDATAW1S2MU() uint32 {
	return volatile.LoadUint32(&o.DATAW1S2MU.Reg)
}

// FMC.DATAW1S2ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW1S2ML(value uint32) {
	volatile.StoreUint32(&o.DATAW1S2ML.Reg, value)
}
func (o *FMC_Type) GetDATAW1S2ML() uint32 {
	return volatile.LoadUint32(&o.DATAW1S2ML.Reg)
}

// FMC.DATAW1S2LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW1S2LM(value uint32) {
	volatile.StoreUint32(&o.DATAW1S2LM.Reg, value)
}
func (o *FMC_Type) GetDATAW1S2LM() uint32 {
	return volatile.LoadUint32(&o.DATAW1S2LM.Reg)
}

// FMC.DATAW1S3UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW1S3UM(value uint32) {
	volatile.StoreUint32(&o.DATAW1S3UM.Reg, value)
}
func (o *FMC_Type) GetDATAW1S3UM() uint32 {
	return volatile.LoadUint32(&o.DATAW1S3UM.Reg)
}

// FMC.DATAW1S3MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW1S3MU(value uint32) {
	volatile.StoreUint32(&o.DATAW1S3MU.Reg, value)
}
func (o *FMC_Type) GetDATAW1S3MU() uint32 {
	return volatile.LoadUint32(&o.DATAW1S3MU.Reg)
}

// FMC.DATAW1S3ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW1S3ML(value uint32) {
	volatile.StoreUint32(&o.DATAW1S3ML.Reg, value)
}
func (o *FMC_Type) GetDATAW1S3ML() uint32 {
	return volatile.LoadUint32(&o.DATAW1S3ML.Reg)
}

// FMC.DATAW1S3LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW1S3LM(value uint32) {
	volatile.StoreUint32(&o.DATAW1S3LM.Reg, value)
}
func (o *FMC_Type) GetDATAW1S3LM() uint32 {
	return volatile.LoadUint32(&o.DATAW1S3LM.Reg)
}

// FMC.DATAW2S0UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW2S0UM(value uint32) {
	volatile.StoreUint32(&o.DATAW2S0UM.Reg, value)
}
func (o *FMC_Type) GetDATAW2S0UM() uint32 {
	return volatile.LoadUint32(&o.DATAW2S0UM.Reg)
}

// FMC.DATAW2S0MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW2S0MU(value uint32) {
	volatile.StoreUint32(&o.DATAW2S0MU.Reg, value)
}
func (o *FMC_Type) GetDATAW2S0MU() uint32 {
	return volatile.LoadUint32(&o.DATAW2S0MU.Reg)
}

// FMC.DATAW2S0ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW2S0ML(value uint32) {
	volatile.StoreUint32(&o.DATAW2S0ML.Reg, value)
}
func (o *FMC_Type) GetDATAW2S0ML() uint32 {
	return volatile.LoadUint32(&o.DATAW2S0ML.Reg)
}

// FMC.DATAW2S0LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW2S0LM(value uint32) {
	volatile.StoreUint32(&o.DATAW2S0LM.Reg, value)
}
func (o *FMC_Type) GetDATAW2S0LM() uint32 {
	return volatile.LoadUint32(&o.DATAW2S0LM.Reg)
}

// FMC.DATAW2S1UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW2S1UM(value uint32) {
	volatile.StoreUint32(&o.DATAW2S1UM.Reg, value)
}
func (o *FMC_Type) GetDATAW2S1UM() uint32 {
	return volatile.LoadUint32(&o.DATAW2S1UM.Reg)
}

// FMC.DATAW2S1MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW2S1MU(value uint32) {
	volatile.StoreUint32(&o.DATAW2S1MU.Reg, value)
}
func (o *FMC_Type) GetDATAW2S1MU() uint32 {
	return volatile.LoadUint32(&o.DATAW2S1MU.Reg)
}

// FMC.DATAW2S1ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW2S1ML(value uint32) {
	volatile.StoreUint32(&o.DATAW2S1ML.Reg, value)
}
func (o *FMC_Type) GetDATAW2S1ML() uint32 {
	return volatile.LoadUint32(&o.DATAW2S1ML.Reg)
}

// FMC.DATAW2S1LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW2S1LM(value uint32) {
	volatile.StoreUint32(&o.DATAW2S1LM.Reg, value)
}
func (o *FMC_Type) GetDATAW2S1LM() uint32 {
	return volatile.LoadUint32(&o.DATAW2S1LM.Reg)
}

// FMC.DATAW2S2UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW2S2UM(value uint32) {
	volatile.StoreUint32(&o.DATAW2S2UM.Reg, value)
}
func (o *FMC_Type) GetDATAW2S2UM() uint32 {
	return volatile.LoadUint32(&o.DATAW2S2UM.Reg)
}

// FMC.DATAW2S2MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW2S2MU(value uint32) {
	volatile.StoreUint32(&o.DATAW2S2MU.Reg, value)
}
func (o *FMC_Type) GetDATAW2S2MU() uint32 {
	return volatile.LoadUint32(&o.DATAW2S2MU.Reg)
}

// FMC.DATAW2S2ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW2S2ML(value uint32) {
	volatile.StoreUint32(&o.DATAW2S2ML.Reg, value)
}
func (o *FMC_Type) GetDATAW2S2ML() uint32 {
	return volatile.LoadUint32(&o.DATAW2S2ML.Reg)
}

// FMC.DATAW2S2LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW2S2LM(value uint32) {
	volatile.StoreUint32(&o.DATAW2S2LM.Reg, value)
}
func (o *FMC_Type) GetDATAW2S2LM() uint32 {
	return volatile.LoadUint32(&o.DATAW2S2LM.Reg)
}

// FMC.DATAW2S3UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW2S3UM(value uint32) {
	volatile.StoreUint32(&o.DATAW2S3UM.Reg, value)
}
func (o *FMC_Type) GetDATAW2S3UM() uint32 {
	return volatile.LoadUint32(&o.DATAW2S3UM.Reg)
}

// FMC.DATAW2S3MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW2S3MU(value uint32) {
	volatile.StoreUint32(&o.DATAW2S3MU.Reg, value)
}
func (o *FMC_Type) GetDATAW2S3MU() uint32 {
	return volatile.LoadUint32(&o.DATAW2S3MU.Reg)
}

// FMC.DATAW2S3ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW2S3ML(value uint32) {
	volatile.StoreUint32(&o.DATAW2S3ML.Reg, value)
}
func (o *FMC_Type) GetDATAW2S3ML() uint32 {
	return volatile.LoadUint32(&o.DATAW2S3ML.Reg)
}

// FMC.DATAW2S3LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW2S3LM(value uint32) {
	volatile.StoreUint32(&o.DATAW2S3LM.Reg, value)
}
func (o *FMC_Type) GetDATAW2S3LM() uint32 {
	return volatile.LoadUint32(&o.DATAW2S3LM.Reg)
}

// FMC.DATAW3S0UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW3S0UM(value uint32) {
	volatile.StoreUint32(&o.DATAW3S0UM.Reg, value)
}
func (o *FMC_Type) GetDATAW3S0UM() uint32 {
	return volatile.LoadUint32(&o.DATAW3S0UM.Reg)
}

// FMC.DATAW3S0MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW3S0MU(value uint32) {
	volatile.StoreUint32(&o.DATAW3S0MU.Reg, value)
}
func (o *FMC_Type) GetDATAW3S0MU() uint32 {
	return volatile.LoadUint32(&o.DATAW3S0MU.Reg)
}

// FMC.DATAW3S0ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW3S0ML(value uint32) {
	volatile.StoreUint32(&o.DATAW3S0ML.Reg, value)
}
func (o *FMC_Type) GetDATAW3S0ML() uint32 {
	return volatile.LoadUint32(&o.DATAW3S0ML.Reg)
}

// FMC.DATAW3S0LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW3S0LM(value uint32) {
	volatile.StoreUint32(&o.DATAW3S0LM.Reg, value)
}
func (o *FMC_Type) GetDATAW3S0LM() uint32 {
	return volatile.LoadUint32(&o.DATAW3S0LM.Reg)
}

// FMC.DATAW3S1UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW3S1UM(value uint32) {
	volatile.StoreUint32(&o.DATAW3S1UM.Reg, value)
}
func (o *FMC_Type) GetDATAW3S1UM() uint32 {
	return volatile.LoadUint32(&o.DATAW3S1UM.Reg)
}

// FMC.DATAW3S1MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW3S1MU(value uint32) {
	volatile.StoreUint32(&o.DATAW3S1MU.Reg, value)
}
func (o *FMC_Type) GetDATAW3S1MU() uint32 {
	return volatile.LoadUint32(&o.DATAW3S1MU.Reg)
}

// FMC.DATAW3S1ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW3S1ML(value uint32) {
	volatile.StoreUint32(&o.DATAW3S1ML.Reg, value)
}
func (o *FMC_Type) GetDATAW3S1ML() uint32 {
	return volatile.LoadUint32(&o.DATAW3S1ML.Reg)
}

// FMC.DATAW3S1LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW3S1LM(value uint32) {
	volatile.StoreUint32(&o.DATAW3S1LM.Reg, value)
}
func (o *FMC_Type) GetDATAW3S1LM() uint32 {
	return volatile.LoadUint32(&o.DATAW3S1LM.Reg)
}

// FMC.DATAW3S2UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW3S2UM(value uint32) {
	volatile.StoreUint32(&o.DATAW3S2UM.Reg, value)
}
func (o *FMC_Type) GetDATAW3S2UM() uint32 {
	return volatile.LoadUint32(&o.DATAW3S2UM.Reg)
}

// FMC.DATAW3S2MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW3S2MU(value uint32) {
	volatile.StoreUint32(&o.DATAW3S2MU.Reg, value)
}
func (o *FMC_Type) GetDATAW3S2MU() uint32 {
	return volatile.LoadUint32(&o.DATAW3S2MU.Reg)
}

// FMC.DATAW3S2ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW3S2ML(value uint32) {
	volatile.StoreUint32(&o.DATAW3S2ML.Reg, value)
}
func (o *FMC_Type) GetDATAW3S2ML() uint32 {
	return volatile.LoadUint32(&o.DATAW3S2ML.Reg)
}

// FMC.DATAW3S2LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW3S2LM(value uint32) {
	volatile.StoreUint32(&o.DATAW3S2LM.Reg, value)
}
func (o *FMC_Type) GetDATAW3S2LM() uint32 {
	return volatile.LoadUint32(&o.DATAW3S2LM.Reg)
}

// FMC.DATAW3S3UM: Cache Data Storage (uppermost word)
func (o *FMC_Type) SetDATAW3S3UM(value uint32) {
	volatile.StoreUint32(&o.DATAW3S3UM.Reg, value)
}
func (o *FMC_Type) GetDATAW3S3UM() uint32 {
	return volatile.LoadUint32(&o.DATAW3S3UM.Reg)
}

// FMC.DATAW3S3MU: Cache Data Storage (mid-upper word)
func (o *FMC_Type) SetDATAW3S3MU(value uint32) {
	volatile.StoreUint32(&o.DATAW3S3MU.Reg, value)
}
func (o *FMC_Type) GetDATAW3S3MU() uint32 {
	return volatile.LoadUint32(&o.DATAW3S3MU.Reg)
}

// FMC.DATAW3S3ML: Cache Data Storage (mid-lower word)
func (o *FMC_Type) SetDATAW3S3ML(value uint32) {
	volatile.StoreUint32(&o.DATAW3S3ML.Reg, value)
}
func (o *FMC_Type) GetDATAW3S3ML() uint32 {
	return volatile.LoadUint32(&o.DATAW3S3ML.Reg)
}

// FMC.DATAW3S3LM: Cache Data Storage (lowermost word)
func (o *FMC_Type) SetDATAW3S3LM(value uint32) {
	volatile.StoreUint32(&o.DATAW3S3LM.Reg, value)
}
func (o *FMC_Type) GetDATAW3S3LM() uint32 {
	return volatile.LoadUint32(&o.DATAW3S3LM.Reg)
}

// Flash Memory Interface
type FTFE_Type struct {
	FSTAT  volatile.Register8 // 0x0
	FCNFG  volatile.Register8 // 0x1
	FSEC   volatile.Register8 // 0x2
	FOPT   volatile.Register8 // 0x3
	FCCOB3 volatile.Register8 // 0x4
	FCCOB2 volatile.Register8 // 0x5
	FCCOB1 volatile.Register8 // 0x6
	FCCOB0 volatile.Register8 // 0x7
	FCCOB7 volatile.Register8 // 0x8
	FCCOB6 volatile.Register8 // 0x9
	FCCOB5 volatile.Register8 // 0xA
	FCCOB4 volatile.Register8 // 0xB
	FCCOBB volatile.Register8 // 0xC
	FCCOBA volatile.Register8 // 0xD
	FCCOB9 volatile.Register8 // 0xE
	FCCOB8 volatile.Register8 // 0xF
	FPROT3 volatile.Register8 // 0x10
	FPROT2 volatile.Register8 // 0x11
	FPROT1 volatile.Register8 // 0x12
	FPROT0 volatile.Register8 // 0x13
	_      [2]byte
	FEPROT volatile.Register8 // 0x16
	FDPROT volatile.Register8 // 0x17
	XACCH3 volatile.Register8 // 0x18
	XACCH2 volatile.Register8 // 0x19
	XACCH1 volatile.Register8 // 0x1A
	XACCH0 volatile.Register8 // 0x1B
	XACCL3 volatile.Register8 // 0x1C
	XACCL2 volatile.Register8 // 0x1D
	XACCL1 volatile.Register8 // 0x1E
	XACCL0 volatile.Register8 // 0x1F
	SACCH3 volatile.Register8 // 0x20
	SACCH2 volatile.Register8 // 0x21
	SACCH1 volatile.Register8 // 0x22
	SACCH0 volatile.Register8 // 0x23
	SACCL3 volatile.Register8 // 0x24
	SACCL2 volatile.Register8 // 0x25
	SACCL1 volatile.Register8 // 0x26
	SACCL0 volatile.Register8 // 0x27
	FACSS  volatile.Register8 // 0x28
	_      [2]byte
	FACSN  volatile.Register8 // 0x2B
}

// FTFE.FSTAT: Flash Status Register
func (o *FTFE_Type) SetFSTAT_MGSTAT0(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x1)|value)
}
func (o *FTFE_Type) GetFSTAT_MGSTAT0() uint8 {
	return volatile.LoadUint8(&o.FSTAT.Reg) & 0x1
}
func (o *FTFE_Type) SetFSTAT_FPVIOL(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x10)|value<<4)
}
func (o *FTFE_Type) GetFSTAT_FPVIOL() uint8 {
	return (volatile.LoadUint8(&o.FSTAT.Reg) & 0x10) >> 4
}
func (o *FTFE_Type) SetFSTAT_ACCERR(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x20)|value<<5)
}
func (o *FTFE_Type) GetFSTAT_ACCERR() uint8 {
	return (volatile.LoadUint8(&o.FSTAT.Reg) & 0x20) >> 5
}
func (o *FTFE_Type) SetFSTAT_RDCOLERR(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x40)|value<<6)
}
func (o *FTFE_Type) GetFSTAT_RDCOLERR() uint8 {
	return (volatile.LoadUint8(&o.FSTAT.Reg) & 0x40) >> 6
}
func (o *FTFE_Type) SetFSTAT_CCIF(value uint8) {
	volatile.StoreUint8(&o.FSTAT.Reg, volatile.LoadUint8(&o.FSTAT.Reg)&^(0x80)|value<<7)
}
func (o *FTFE_Type) GetFSTAT_CCIF() uint8 {
	return (volatile.LoadUint8(&o.FSTAT.Reg) & 0x80) >> 7
}

// FTFE.FCNFG: Flash Configuration Register
func (o *FTFE_Type) SetFCNFG_EEERDY(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x1)|value)
}
func (o *FTFE_Type) GetFCNFG_EEERDY() uint8 {
	return volatile.LoadUint8(&o.FCNFG.Reg) & 0x1
}
func (o *FTFE_Type) SetFCNFG_RAMRDY(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x2)|value<<1)
}
func (o *FTFE_Type) GetFCNFG_RAMRDY() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x2) >> 1
}
func (o *FTFE_Type) SetFCNFG_PFLSH(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x4)|value<<2)
}
func (o *FTFE_Type) GetFCNFG_PFLSH() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x4) >> 2
}
func (o *FTFE_Type) SetFCNFG_SWAP(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x8)|value<<3)
}
func (o *FTFE_Type) GetFCNFG_SWAP() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x8) >> 3
}
func (o *FTFE_Type) SetFCNFG_ERSSUSP(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x10)|value<<4)
}
func (o *FTFE_Type) GetFCNFG_ERSSUSP() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x10) >> 4
}
func (o *FTFE_Type) SetFCNFG_ERSAREQ(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x20)|value<<5)
}
func (o *FTFE_Type) GetFCNFG_ERSAREQ() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x20) >> 5
}
func (o *FTFE_Type) SetFCNFG_RDCOLLIE(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x40)|value<<6)
}
func (o *FTFE_Type) GetFCNFG_RDCOLLIE() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x40) >> 6
}
func (o *FTFE_Type) SetFCNFG_CCIE(value uint8) {
	volatile.StoreUint8(&o.FCNFG.Reg, volatile.LoadUint8(&o.FCNFG.Reg)&^(0x80)|value<<7)
}
func (o *FTFE_Type) GetFCNFG_CCIE() uint8 {
	return (volatile.LoadUint8(&o.FCNFG.Reg) & 0x80) >> 7
}

// FTFE.FSEC: Flash Security Register
func (o *FTFE_Type) SetFSEC_SEC(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0x3)|value)
}
func (o *FTFE_Type) GetFSEC_SEC() uint8 {
	return volatile.LoadUint8(&o.FSEC.Reg) & 0x3
}
func (o *FTFE_Type) SetFSEC_FSLACC(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0xc)|value<<2)
}
func (o *FTFE_Type) GetFSEC_FSLACC() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0xc) >> 2
}
func (o *FTFE_Type) SetFSEC_MEEN(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0x30)|value<<4)
}
func (o *FTFE_Type) GetFSEC_MEEN() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0x30) >> 4
}
func (o *FTFE_Type) SetFSEC_KEYEN(value uint8) {
	volatile.StoreUint8(&o.FSEC.Reg, volatile.LoadUint8(&o.FSEC.Reg)&^(0xc0)|value<<6)
}
func (o *FTFE_Type) GetFSEC_KEYEN() uint8 {
	return (volatile.LoadUint8(&o.FSEC.Reg) & 0xc0) >> 6
}

// FTFE.FOPT: Flash Option Register
func (o *FTFE_Type) SetFOPT(value uint8) {
	volatile.StoreUint8(&o.FOPT.Reg, value)
}
func (o *FTFE_Type) GetFOPT() uint8 {
	return volatile.LoadUint8(&o.FOPT.Reg)
}

// FTFE.FCCOB3: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB3(value uint8) {
	volatile.StoreUint8(&o.FCCOB3.Reg, value)
}
func (o *FTFE_Type) GetFCCOB3() uint8 {
	return volatile.LoadUint8(&o.FCCOB3.Reg)
}

// FTFE.FCCOB2: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB2(value uint8) {
	volatile.StoreUint8(&o.FCCOB2.Reg, value)
}
func (o *FTFE_Type) GetFCCOB2() uint8 {
	return volatile.LoadUint8(&o.FCCOB2.Reg)
}

// FTFE.FCCOB1: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB1(value uint8) {
	volatile.StoreUint8(&o.FCCOB1.Reg, value)
}
func (o *FTFE_Type) GetFCCOB1() uint8 {
	return volatile.LoadUint8(&o.FCCOB1.Reg)
}

// FTFE.FCCOB0: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB0(value uint8) {
	volatile.StoreUint8(&o.FCCOB0.Reg, value)
}
func (o *FTFE_Type) GetFCCOB0() uint8 {
	return volatile.LoadUint8(&o.FCCOB0.Reg)
}

// FTFE.FCCOB7: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB7(value uint8) {
	volatile.StoreUint8(&o.FCCOB7.Reg, value)
}
func (o *FTFE_Type) GetFCCOB7() uint8 {
	return volatile.LoadUint8(&o.FCCOB7.Reg)
}

// FTFE.FCCOB6: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB6(value uint8) {
	volatile.StoreUint8(&o.FCCOB6.Reg, value)
}
func (o *FTFE_Type) GetFCCOB6() uint8 {
	return volatile.LoadUint8(&o.FCCOB6.Reg)
}

// FTFE.FCCOB5: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB5(value uint8) {
	volatile.StoreUint8(&o.FCCOB5.Reg, value)
}
func (o *FTFE_Type) GetFCCOB5() uint8 {
	return volatile.LoadUint8(&o.FCCOB5.Reg)
}

// FTFE.FCCOB4: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB4(value uint8) {
	volatile.StoreUint8(&o.FCCOB4.Reg, value)
}
func (o *FTFE_Type) GetFCCOB4() uint8 {
	return volatile.LoadUint8(&o.FCCOB4.Reg)
}

// FTFE.FCCOBB: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOBB(value uint8) {
	volatile.StoreUint8(&o.FCCOBB.Reg, value)
}
func (o *FTFE_Type) GetFCCOBB() uint8 {
	return volatile.LoadUint8(&o.FCCOBB.Reg)
}

// FTFE.FCCOBA: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOBA(value uint8) {
	volatile.StoreUint8(&o.FCCOBA.Reg, value)
}
func (o *FTFE_Type) GetFCCOBA() uint8 {
	return volatile.LoadUint8(&o.FCCOBA.Reg)
}

// FTFE.FCCOB9: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB9(value uint8) {
	volatile.StoreUint8(&o.FCCOB9.Reg, value)
}
func (o *FTFE_Type) GetFCCOB9() uint8 {
	return volatile.LoadUint8(&o.FCCOB9.Reg)
}

// FTFE.FCCOB8: Flash Common Command Object Registers
func (o *FTFE_Type) SetFCCOB8(value uint8) {
	volatile.StoreUint8(&o.FCCOB8.Reg, value)
}
func (o *FTFE_Type) GetFCCOB8() uint8 {
	return volatile.LoadUint8(&o.FCCOB8.Reg)
}

// FTFE.FPROT3: Program Flash Protection Registers
func (o *FTFE_Type) SetFPROT3(value uint8) {
	volatile.StoreUint8(&o.FPROT3.Reg, value)
}
func (o *FTFE_Type) GetFPROT3() uint8 {
	return volatile.LoadUint8(&o.FPROT3.Reg)
}

// FTFE.FPROT2: Program Flash Protection Registers
func (o *FTFE_Type) SetFPROT2(value uint8) {
	volatile.StoreUint8(&o.FPROT2.Reg, value)
}
func (o *FTFE_Type) GetFPROT2() uint8 {
	return volatile.LoadUint8(&o.FPROT2.Reg)
}

// FTFE.FPROT1: Program Flash Protection Registers
func (o *FTFE_Type) SetFPROT1(value uint8) {
	volatile.StoreUint8(&o.FPROT1.Reg, value)
}
func (o *FTFE_Type) GetFPROT1() uint8 {
	return volatile.LoadUint8(&o.FPROT1.Reg)
}

// FTFE.FPROT0: Program Flash Protection Registers
func (o *FTFE_Type) SetFPROT0(value uint8) {
	volatile.StoreUint8(&o.FPROT0.Reg, value)
}
func (o *FTFE_Type) GetFPROT0() uint8 {
	return volatile.LoadUint8(&o.FPROT0.Reg)
}

// FTFE.FEPROT: EEPROM Protection Register
func (o *FTFE_Type) SetFEPROT(value uint8) {
	volatile.StoreUint8(&o.FEPROT.Reg, value)
}
func (o *FTFE_Type) GetFEPROT() uint8 {
	return volatile.LoadUint8(&o.FEPROT.Reg)
}

// FTFE.FDPROT: Data Flash Protection Register
func (o *FTFE_Type) SetFDPROT(value uint8) {
	volatile.StoreUint8(&o.FDPROT.Reg, value)
}
func (o *FTFE_Type) GetFDPROT() uint8 {
	return volatile.LoadUint8(&o.FDPROT.Reg)
}

// FTFE.XACCH3: Execute-only Access Registers
func (o *FTFE_Type) SetXACCH3(value uint8) {
	volatile.StoreUint8(&o.XACCH3.Reg, value)
}
func (o *FTFE_Type) GetXACCH3() uint8 {
	return volatile.LoadUint8(&o.XACCH3.Reg)
}

// FTFE.XACCH2: Execute-only Access Registers
func (o *FTFE_Type) SetXACCH2(value uint8) {
	volatile.StoreUint8(&o.XACCH2.Reg, value)
}
func (o *FTFE_Type) GetXACCH2() uint8 {
	return volatile.LoadUint8(&o.XACCH2.Reg)
}

// FTFE.XACCH1: Execute-only Access Registers
func (o *FTFE_Type) SetXACCH1(value uint8) {
	volatile.StoreUint8(&o.XACCH1.Reg, value)
}
func (o *FTFE_Type) GetXACCH1() uint8 {
	return volatile.LoadUint8(&o.XACCH1.Reg)
}

// FTFE.XACCH0: Execute-only Access Registers
func (o *FTFE_Type) SetXACCH0(value uint8) {
	volatile.StoreUint8(&o.XACCH0.Reg, value)
}
func (o *FTFE_Type) GetXACCH0() uint8 {
	return volatile.LoadUint8(&o.XACCH0.Reg)
}

// FTFE.XACCL3: Execute-only Access Registers
func (o *FTFE_Type) SetXACCL3(value uint8) {
	volatile.StoreUint8(&o.XACCL3.Reg, value)
}
func (o *FTFE_Type) GetXACCL3() uint8 {
	return volatile.LoadUint8(&o.XACCL3.Reg)
}

// FTFE.XACCL2: Execute-only Access Registers
func (o *FTFE_Type) SetXACCL2(value uint8) {
	volatile.StoreUint8(&o.XACCL2.Reg, value)
}
func (o *FTFE_Type) GetXACCL2() uint8 {
	return volatile.LoadUint8(&o.XACCL2.Reg)
}

// FTFE.XACCL1: Execute-only Access Registers
func (o *FTFE_Type) SetXACCL1(value uint8) {
	volatile.StoreUint8(&o.XACCL1.Reg, value)
}
func (o *FTFE_Type) GetXACCL1() uint8 {
	return volatile.LoadUint8(&o.XACCL1.Reg)
}

// FTFE.XACCL0: Execute-only Access Registers
func (o *FTFE_Type) SetXACCL0(value uint8) {
	volatile.StoreUint8(&o.XACCL0.Reg, value)
}
func (o *FTFE_Type) GetXACCL0() uint8 {
	return volatile.LoadUint8(&o.XACCL0.Reg)
}

// FTFE.SACCH3: Supervisor-only Access Registers
func (o *FTFE_Type) SetSACCH3(value uint8) {
	volatile.StoreUint8(&o.SACCH3.Reg, value)
}
func (o *FTFE_Type) GetSACCH3() uint8 {
	return volatile.LoadUint8(&o.SACCH3.Reg)
}

// FTFE.SACCH2: Supervisor-only Access Registers
func (o *FTFE_Type) SetSACCH2(value uint8) {
	volatile.StoreUint8(&o.SACCH2.Reg, value)
}
func (o *FTFE_Type) GetSACCH2() uint8 {
	return volatile.LoadUint8(&o.SACCH2.Reg)
}

// FTFE.SACCH1: Supervisor-only Access Registers
func (o *FTFE_Type) SetSACCH1(value uint8) {
	volatile.StoreUint8(&o.SACCH1.Reg, value)
}
func (o *FTFE_Type) GetSACCH1() uint8 {
	return volatile.LoadUint8(&o.SACCH1.Reg)
}

// FTFE.SACCH0: Supervisor-only Access Registers
func (o *FTFE_Type) SetSACCH0(value uint8) {
	volatile.StoreUint8(&o.SACCH0.Reg, value)
}
func (o *FTFE_Type) GetSACCH0() uint8 {
	return volatile.LoadUint8(&o.SACCH0.Reg)
}

// FTFE.SACCL3: Supervisor-only Access Registers
func (o *FTFE_Type) SetSACCL3(value uint8) {
	volatile.StoreUint8(&o.SACCL3.Reg, value)
}
func (o *FTFE_Type) GetSACCL3() uint8 {
	return volatile.LoadUint8(&o.SACCL3.Reg)
}

// FTFE.SACCL2: Supervisor-only Access Registers
func (o *FTFE_Type) SetSACCL2(value uint8) {
	volatile.StoreUint8(&o.SACCL2.Reg, value)
}
func (o *FTFE_Type) GetSACCL2() uint8 {
	return volatile.LoadUint8(&o.SACCL2.Reg)
}

// FTFE.SACCL1: Supervisor-only Access Registers
func (o *FTFE_Type) SetSACCL1(value uint8) {
	volatile.StoreUint8(&o.SACCL1.Reg, value)
}
func (o *FTFE_Type) GetSACCL1() uint8 {
	return volatile.LoadUint8(&o.SACCL1.Reg)
}

// FTFE.SACCL0: Supervisor-only Access Registers
func (o *FTFE_Type) SetSACCL0(value uint8) {
	volatile.StoreUint8(&o.SACCL0.Reg, value)
}
func (o *FTFE_Type) GetSACCL0() uint8 {
	return volatile.LoadUint8(&o.SACCL0.Reg)
}

// FTFE.FACSS: Flash Access Segment Size Register
func (o *FTFE_Type) SetFACSS(value uint8) {
	volatile.StoreUint8(&o.FACSS.Reg, value)
}
func (o *FTFE_Type) GetFACSS() uint8 {
	return volatile.LoadUint8(&o.FACSS.Reg)
}

// FTFE.FACSN: Flash Access Segment Number Register
func (o *FTFE_Type) SetFACSN(value uint8) {
	volatile.StoreUint8(&o.FACSN.Reg, value)
}
func (o *FTFE_Type) GetFACSN() uint8 {
	return volatile.LoadUint8(&o.FACSN.Reg)
}

// DMA channel multiplexor
type DMAMUX_Type struct {
	CHCFG0  volatile.Register8 // 0x0
	CHCFG1  volatile.Register8 // 0x1
	CHCFG2  volatile.Register8 // 0x2
	CHCFG3  volatile.Register8 // 0x3
	CHCFG4  volatile.Register8 // 0x4
	CHCFG5  volatile.Register8 // 0x5
	CHCFG6  volatile.Register8 // 0x6
	CHCFG7  volatile.Register8 // 0x7
	CHCFG8  volatile.Register8 // 0x8
	CHCFG9  volatile.Register8 // 0x9
	CHCFG10 volatile.Register8 // 0xA
	CHCFG11 volatile.Register8 // 0xB
	CHCFG12 volatile.Register8 // 0xC
	CHCFG13 volatile.Register8 // 0xD
	CHCFG14 volatile.Register8 // 0xE
	CHCFG15 volatile.Register8 // 0xF
	CHCFG16 volatile.Register8 // 0x10
	CHCFG17 volatile.Register8 // 0x11
	CHCFG18 volatile.Register8 // 0x12
	CHCFG19 volatile.Register8 // 0x13
	CHCFG20 volatile.Register8 // 0x14
	CHCFG21 volatile.Register8 // 0x15
	CHCFG22 volatile.Register8 // 0x16
	CHCFG23 volatile.Register8 // 0x17
	CHCFG24 volatile.Register8 // 0x18
	CHCFG25 volatile.Register8 // 0x19
	CHCFG26 volatile.Register8 // 0x1A
	CHCFG27 volatile.Register8 // 0x1B
	CHCFG28 volatile.Register8 // 0x1C
	CHCFG29 volatile.Register8 // 0x1D
	CHCFG30 volatile.Register8 // 0x1E
	CHCFG31 volatile.Register8 // 0x1F
}

// DMAMUX.CHCFG0: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG0_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG0.Reg, volatile.LoadUint8(&o.CHCFG0.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG0_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG0.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG0_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG0.Reg, volatile.LoadUint8(&o.CHCFG0.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG0_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG0.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG0_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG0.Reg, volatile.LoadUint8(&o.CHCFG0.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG0_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG0.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG1: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG1_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG1.Reg, volatile.LoadUint8(&o.CHCFG1.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG1_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG1.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG1_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG1.Reg, volatile.LoadUint8(&o.CHCFG1.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG1_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG1.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG1_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG1.Reg, volatile.LoadUint8(&o.CHCFG1.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG1_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG1.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG2: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG2_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG2.Reg, volatile.LoadUint8(&o.CHCFG2.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG2_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG2.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG2_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG2.Reg, volatile.LoadUint8(&o.CHCFG2.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG2_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG2.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG2_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG2.Reg, volatile.LoadUint8(&o.CHCFG2.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG2_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG2.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG3: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG3_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG3.Reg, volatile.LoadUint8(&o.CHCFG3.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG3_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG3.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG3_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG3.Reg, volatile.LoadUint8(&o.CHCFG3.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG3_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG3.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG3_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG3.Reg, volatile.LoadUint8(&o.CHCFG3.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG3_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG3.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG4: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG4_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG4.Reg, volatile.LoadUint8(&o.CHCFG4.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG4_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG4.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG4_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG4.Reg, volatile.LoadUint8(&o.CHCFG4.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG4_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG4.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG4_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG4.Reg, volatile.LoadUint8(&o.CHCFG4.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG4_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG4.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG5: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG5_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG5.Reg, volatile.LoadUint8(&o.CHCFG5.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG5_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG5.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG5_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG5.Reg, volatile.LoadUint8(&o.CHCFG5.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG5_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG5.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG5_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG5.Reg, volatile.LoadUint8(&o.CHCFG5.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG5_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG5.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG6: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG6_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG6.Reg, volatile.LoadUint8(&o.CHCFG6.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG6_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG6.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG6_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG6.Reg, volatile.LoadUint8(&o.CHCFG6.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG6_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG6.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG6_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG6.Reg, volatile.LoadUint8(&o.CHCFG6.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG6_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG6.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG7: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG7_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG7.Reg, volatile.LoadUint8(&o.CHCFG7.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG7_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG7.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG7_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG7.Reg, volatile.LoadUint8(&o.CHCFG7.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG7_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG7.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG7_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG7.Reg, volatile.LoadUint8(&o.CHCFG7.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG7_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG7.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG8: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG8_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG8.Reg, volatile.LoadUint8(&o.CHCFG8.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG8_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG8.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG8_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG8.Reg, volatile.LoadUint8(&o.CHCFG8.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG8_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG8.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG8_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG8.Reg, volatile.LoadUint8(&o.CHCFG8.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG8_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG8.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG9: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG9_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG9.Reg, volatile.LoadUint8(&o.CHCFG9.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG9_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG9.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG9_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG9.Reg, volatile.LoadUint8(&o.CHCFG9.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG9_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG9.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG9_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG9.Reg, volatile.LoadUint8(&o.CHCFG9.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG9_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG9.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG10: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG10_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG10.Reg, volatile.LoadUint8(&o.CHCFG10.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG10_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG10.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG10_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG10.Reg, volatile.LoadUint8(&o.CHCFG10.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG10_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG10.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG10_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG10.Reg, volatile.LoadUint8(&o.CHCFG10.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG10_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG10.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG11: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG11_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG11.Reg, volatile.LoadUint8(&o.CHCFG11.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG11_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG11.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG11_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG11.Reg, volatile.LoadUint8(&o.CHCFG11.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG11_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG11.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG11_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG11.Reg, volatile.LoadUint8(&o.CHCFG11.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG11_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG11.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG12: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG12_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG12.Reg, volatile.LoadUint8(&o.CHCFG12.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG12_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG12.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG12_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG12.Reg, volatile.LoadUint8(&o.CHCFG12.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG12_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG12.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG12_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG12.Reg, volatile.LoadUint8(&o.CHCFG12.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG12_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG12.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG13: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG13_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG13.Reg, volatile.LoadUint8(&o.CHCFG13.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG13_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG13.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG13_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG13.Reg, volatile.LoadUint8(&o.CHCFG13.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG13_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG13.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG13_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG13.Reg, volatile.LoadUint8(&o.CHCFG13.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG13_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG13.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG14: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG14_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG14.Reg, volatile.LoadUint8(&o.CHCFG14.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG14_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG14.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG14_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG14.Reg, volatile.LoadUint8(&o.CHCFG14.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG14_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG14.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG14_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG14.Reg, volatile.LoadUint8(&o.CHCFG14.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG14_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG14.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG15: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG15_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG15.Reg, volatile.LoadUint8(&o.CHCFG15.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG15_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG15.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG15_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG15.Reg, volatile.LoadUint8(&o.CHCFG15.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG15_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG15.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG15_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG15.Reg, volatile.LoadUint8(&o.CHCFG15.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG15_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG15.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG16: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG16_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG16.Reg, volatile.LoadUint8(&o.CHCFG16.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG16_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG16.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG16_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG16.Reg, volatile.LoadUint8(&o.CHCFG16.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG16_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG16.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG16_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG16.Reg, volatile.LoadUint8(&o.CHCFG16.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG16_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG16.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG17: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG17_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG17.Reg, volatile.LoadUint8(&o.CHCFG17.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG17_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG17.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG17_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG17.Reg, volatile.LoadUint8(&o.CHCFG17.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG17_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG17.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG17_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG17.Reg, volatile.LoadUint8(&o.CHCFG17.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG17_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG17.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG18: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG18_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG18.Reg, volatile.LoadUint8(&o.CHCFG18.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG18_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG18.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG18_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG18.Reg, volatile.LoadUint8(&o.CHCFG18.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG18_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG18.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG18_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG18.Reg, volatile.LoadUint8(&o.CHCFG18.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG18_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG18.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG19: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG19_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG19.Reg, volatile.LoadUint8(&o.CHCFG19.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG19_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG19.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG19_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG19.Reg, volatile.LoadUint8(&o.CHCFG19.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG19_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG19.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG19_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG19.Reg, volatile.LoadUint8(&o.CHCFG19.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG19_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG19.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG20: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG20_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG20.Reg, volatile.LoadUint8(&o.CHCFG20.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG20_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG20.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG20_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG20.Reg, volatile.LoadUint8(&o.CHCFG20.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG20_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG20.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG20_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG20.Reg, volatile.LoadUint8(&o.CHCFG20.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG20_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG20.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG21: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG21_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG21.Reg, volatile.LoadUint8(&o.CHCFG21.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG21_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG21.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG21_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG21.Reg, volatile.LoadUint8(&o.CHCFG21.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG21_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG21.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG21_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG21.Reg, volatile.LoadUint8(&o.CHCFG21.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG21_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG21.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG22: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG22_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG22.Reg, volatile.LoadUint8(&o.CHCFG22.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG22_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG22.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG22_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG22.Reg, volatile.LoadUint8(&o.CHCFG22.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG22_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG22.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG22_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG22.Reg, volatile.LoadUint8(&o.CHCFG22.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG22_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG22.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG23: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG23_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG23.Reg, volatile.LoadUint8(&o.CHCFG23.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG23_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG23.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG23_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG23.Reg, volatile.LoadUint8(&o.CHCFG23.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG23_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG23.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG23_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG23.Reg, volatile.LoadUint8(&o.CHCFG23.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG23_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG23.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG24: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG24_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG24.Reg, volatile.LoadUint8(&o.CHCFG24.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG24_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG24.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG24_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG24.Reg, volatile.LoadUint8(&o.CHCFG24.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG24_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG24.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG24_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG24.Reg, volatile.LoadUint8(&o.CHCFG24.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG24_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG24.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG25: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG25_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG25.Reg, volatile.LoadUint8(&o.CHCFG25.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG25_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG25.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG25_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG25.Reg, volatile.LoadUint8(&o.CHCFG25.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG25_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG25.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG25_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG25.Reg, volatile.LoadUint8(&o.CHCFG25.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG25_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG25.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG26: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG26_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG26.Reg, volatile.LoadUint8(&o.CHCFG26.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG26_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG26.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG26_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG26.Reg, volatile.LoadUint8(&o.CHCFG26.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG26_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG26.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG26_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG26.Reg, volatile.LoadUint8(&o.CHCFG26.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG26_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG26.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG27: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG27_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG27.Reg, volatile.LoadUint8(&o.CHCFG27.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG27_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG27.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG27_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG27.Reg, volatile.LoadUint8(&o.CHCFG27.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG27_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG27.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG27_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG27.Reg, volatile.LoadUint8(&o.CHCFG27.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG27_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG27.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG28: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG28_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG28.Reg, volatile.LoadUint8(&o.CHCFG28.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG28_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG28.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG28_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG28.Reg, volatile.LoadUint8(&o.CHCFG28.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG28_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG28.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG28_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG28.Reg, volatile.LoadUint8(&o.CHCFG28.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG28_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG28.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG29: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG29_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG29.Reg, volatile.LoadUint8(&o.CHCFG29.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG29_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG29.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG29_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG29.Reg, volatile.LoadUint8(&o.CHCFG29.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG29_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG29.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG29_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG29.Reg, volatile.LoadUint8(&o.CHCFG29.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG29_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG29.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG30: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG30_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG30.Reg, volatile.LoadUint8(&o.CHCFG30.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG30_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG30.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG30_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG30.Reg, volatile.LoadUint8(&o.CHCFG30.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG30_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG30.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG30_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG30.Reg, volatile.LoadUint8(&o.CHCFG30.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG30_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG30.Reg) & 0x80) >> 7
}

// DMAMUX.CHCFG31: Channel Configuration register
func (o *DMAMUX_Type) SetCHCFG31_SOURCE(value uint8) {
	volatile.StoreUint8(&o.CHCFG31.Reg, volatile.LoadUint8(&o.CHCFG31.Reg)&^(0x3f)|value)
}
func (o *DMAMUX_Type) GetCHCFG31_SOURCE() uint8 {
	return volatile.LoadUint8(&o.CHCFG31.Reg) & 0x3f
}
func (o *DMAMUX_Type) SetCHCFG31_TRIG(value uint8) {
	volatile.StoreUint8(&o.CHCFG31.Reg, volatile.LoadUint8(&o.CHCFG31.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCHCFG31_TRIG() uint8 {
	return (volatile.LoadUint8(&o.CHCFG31.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCHCFG31_ENBL(value uint8) {
	volatile.StoreUint8(&o.CHCFG31.Reg, volatile.LoadUint8(&o.CHCFG31.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCHCFG31_ENBL() uint8 {
	return (volatile.LoadUint8(&o.CHCFG31.Reg) & 0x80) >> 7
}

// Flex Controller Area Network module
type CAN_Type struct {
	MCR      volatile.Register32 // 0x0
	CTRL1    volatile.Register32 // 0x4
	TIMER    volatile.Register32 // 0x8
	_        [4]byte
	RXMGMASK volatile.Register32 // 0x10
	RX14MASK volatile.Register32 // 0x14
	RX15MASK volatile.Register32 // 0x18
	ECR      volatile.Register32 // 0x1C
	ESR1     volatile.Register32 // 0x20
	_        [4]byte
	IMASK1   volatile.Register32 // 0x28
	_        [4]byte
	IFLAG1   volatile.Register32 // 0x30
	CTRL2    volatile.Register32 // 0x34
	ESR2     volatile.Register32 // 0x38
	_        [8]byte
	CRCR     volatile.Register32 // 0x44
	RXFGMASK volatile.Register32 // 0x48
	RXFIR    volatile.Register32 // 0x4C
	_        [48]byte
	CS0      volatile.Register32 // 0x80
	ID0      volatile.Register32 // 0x84
	WORD00   volatile.Register32 // 0x88
	WORD10   volatile.Register32 // 0x8C
	CS1      volatile.Register32 // 0x90
	ID1      volatile.Register32 // 0x94
	WORD01   volatile.Register32 // 0x98
	WORD11   volatile.Register32 // 0x9C
	CS2      volatile.Register32 // 0xA0
	ID2      volatile.Register32 // 0xA4
	WORD02   volatile.Register32 // 0xA8
	WORD12   volatile.Register32 // 0xAC
	CS3      volatile.Register32 // 0xB0
	ID3      volatile.Register32 // 0xB4
	WORD03   volatile.Register32 // 0xB8
	WORD13   volatile.Register32 // 0xBC
	CS4      volatile.Register32 // 0xC0
	ID4      volatile.Register32 // 0xC4
	WORD04   volatile.Register32 // 0xC8
	WORD14   volatile.Register32 // 0xCC
	CS5      volatile.Register32 // 0xD0
	ID5      volatile.Register32 // 0xD4
	WORD05   volatile.Register32 // 0xD8
	WORD15   volatile.Register32 // 0xDC
	CS6      volatile.Register32 // 0xE0
	ID6      volatile.Register32 // 0xE4
	WORD06   volatile.Register32 // 0xE8
	WORD16   volatile.Register32 // 0xEC
	CS7      volatile.Register32 // 0xF0
	ID7      volatile.Register32 // 0xF4
	WORD07   volatile.Register32 // 0xF8
	WORD17   volatile.Register32 // 0xFC
	CS8      volatile.Register32 // 0x100
	ID8      volatile.Register32 // 0x104
	WORD08   volatile.Register32 // 0x108
	WORD18   volatile.Register32 // 0x10C
	CS9      volatile.Register32 // 0x110
	ID9      volatile.Register32 // 0x114
	WORD09   volatile.Register32 // 0x118
	WORD19   volatile.Register32 // 0x11C
	CS10     volatile.Register32 // 0x120
	ID10     volatile.Register32 // 0x124
	WORD010  volatile.Register32 // 0x128
	WORD110  volatile.Register32 // 0x12C
	CS11     volatile.Register32 // 0x130
	ID11     volatile.Register32 // 0x134
	WORD011  volatile.Register32 // 0x138
	WORD111  volatile.Register32 // 0x13C
	CS12     volatile.Register32 // 0x140
	ID12     volatile.Register32 // 0x144
	WORD012  volatile.Register32 // 0x148
	WORD112  volatile.Register32 // 0x14C
	CS13     volatile.Register32 // 0x150
	ID13     volatile.Register32 // 0x154
	WORD013  volatile.Register32 // 0x158
	WORD113  volatile.Register32 // 0x15C
	CS14     volatile.Register32 // 0x160
	ID14     volatile.Register32 // 0x164
	WORD014  volatile.Register32 // 0x168
	WORD114  volatile.Register32 // 0x16C
	CS15     volatile.Register32 // 0x170
	ID15     volatile.Register32 // 0x174
	WORD015  volatile.Register32 // 0x178
	WORD115  volatile.Register32 // 0x17C
	_        [1792]byte
	RXIMR0   volatile.Register32 // 0x880
	RXIMR1   volatile.Register32 // 0x884
	RXIMR2   volatile.Register32 // 0x888
	RXIMR3   volatile.Register32 // 0x88C
	RXIMR4   volatile.Register32 // 0x890
	RXIMR5   volatile.Register32 // 0x894
	RXIMR6   volatile.Register32 // 0x898
	RXIMR7   volatile.Register32 // 0x89C
	RXIMR8   volatile.Register32 // 0x8A0
	RXIMR9   volatile.Register32 // 0x8A4
	RXIMR10  volatile.Register32 // 0x8A8
	RXIMR11  volatile.Register32 // 0x8AC
	RXIMR12  volatile.Register32 // 0x8B0
	RXIMR13  volatile.Register32 // 0x8B4
	RXIMR14  volatile.Register32 // 0x8B8
	RXIMR15  volatile.Register32 // 0x8BC
}

// CAN.MCR: Module Configuration Register
func (o *CAN_Type) SetMCR_MAXMB(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x7f)|value)
}
func (o *CAN_Type) GetMCR_MAXMB() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x7f
}
func (o *CAN_Type) SetMCR_IDAM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x300)|value<<8)
}
func (o *CAN_Type) GetMCR_IDAM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x300) >> 8
}
func (o *CAN_Type) SetMCR_AEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetMCR_AEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetMCR_LPRIOEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetMCR_LPRIOEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetMCR_IRMQ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetMCR_IRMQ() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetMCR_SRXDIS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetMCR_SRXDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetMCR_WAKSRC(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetMCR_WAKSRC() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetMCR_LPMACK(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMCR_LPMACK() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMCR_WRNEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetMCR_WRNEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetMCR_SLFWAK(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMCR_SLFWAK() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMCR_SUPV(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMCR_SUPV() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetMCR_FRZACK(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetMCR_FRZACK() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetMCR_SOFTRST(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetMCR_SOFTRST() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetMCR_WAKMSK(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetMCR_WAKMSK() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetMCR_NOTRDY(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetMCR_NOTRDY() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetMCR_HALT(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetMCR_HALT() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetMCR_RFEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMCR_RFEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetMCR_FRZ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetMCR_FRZ() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetMCR_MDIS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetMCR_MDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000000) >> 31
}

// CAN.CTRL1: Control 1 register
func (o *CAN_Type) SetCTRL1_PROPSEG(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x7)|value)
}
func (o *CAN_Type) GetCTRL1_PROPSEG() uint32 {
	return volatile.LoadUint32(&o.CTRL1.Reg) & 0x7
}
func (o *CAN_Type) SetCTRL1_LOM(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetCTRL1_LOM() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetCTRL1_LBUF(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetCTRL1_LBUF() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetCTRL1_TSYN(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetCTRL1_TSYN() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetCTRL1_BOFFREC(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetCTRL1_BOFFREC() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetCTRL1_SMP(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetCTRL1_SMP() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetCTRL1_RWRNMSK(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetCTRL1_RWRNMSK() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetCTRL1_TWRNMSK(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetCTRL1_TWRNMSK() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetCTRL1_LPB(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetCTRL1_LPB() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetCTRL1_CLKSRC(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetCTRL1_CLKSRC() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetCTRL1_ERRMSK(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetCTRL1_ERRMSK() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetCTRL1_BOFFMSK(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetCTRL1_BOFFMSK() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetCTRL1_PSEG2(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x70000)|value<<16)
}
func (o *CAN_Type) GetCTRL1_PSEG2() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x70000) >> 16
}
func (o *CAN_Type) SetCTRL1_PSEG1(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x380000)|value<<19)
}
func (o *CAN_Type) GetCTRL1_PSEG1() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x380000) >> 19
}
func (o *CAN_Type) SetCTRL1_RJW(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0xc00000)|value<<22)
}
func (o *CAN_Type) GetCTRL1_RJW() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0xc00000) >> 22
}
func (o *CAN_Type) SetCTRL1_PRESDIV(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetCTRL1_PRESDIV() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0xff000000) >> 24
}

// CAN.TIMER: Free Running Timer
func (o *CAN_Type) SetTIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER.Reg, volatile.LoadUint32(&o.TIMER.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetTIMER() uint32 {
	return volatile.LoadUint32(&o.TIMER.Reg) & 0xffff
}

// CAN.RXMGMASK: Rx Mailboxes Global Mask Register
func (o *CAN_Type) SetRXMGMASK_MG0(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXMGMASK_MG0() uint32 {
	return volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x1
}
func (o *CAN_Type) SetRXMGMASK_MG1(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXMGMASK_MG1() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXMGMASK_MG2(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXMGMASK_MG2() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXMGMASK_MG3(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXMGMASK_MG3() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXMGMASK_MG4(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXMGMASK_MG4() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXMGMASK_MG5(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXMGMASK_MG5() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXMGMASK_MG6(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXMGMASK_MG6() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXMGMASK_MG7(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXMGMASK_MG7() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXMGMASK_MG8(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXMGMASK_MG8() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXMGMASK_MG9(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXMGMASK_MG9() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXMGMASK_MG10(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXMGMASK_MG10() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXMGMASK_MG11(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXMGMASK_MG11() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXMGMASK_MG12(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXMGMASK_MG12() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXMGMASK_MG13(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXMGMASK_MG13() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXMGMASK_MG14(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXMGMASK_MG14() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXMGMASK_MG15(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXMGMASK_MG15() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXMGMASK_MG16(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXMGMASK_MG16() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXMGMASK_MG17(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXMGMASK_MG17() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXMGMASK_MG18(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXMGMASK_MG18() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXMGMASK_MG19(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXMGMASK_MG19() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXMGMASK_MG20(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXMGMASK_MG20() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXMGMASK_MG21(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXMGMASK_MG21() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXMGMASK_MG22(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXMGMASK_MG22() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXMGMASK_MG23(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXMGMASK_MG23() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXMGMASK_MG24(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXMGMASK_MG24() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXMGMASK_MG25(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXMGMASK_MG25() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXMGMASK_MG26(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXMGMASK_MG26() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXMGMASK_MG27(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXMGMASK_MG27() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXMGMASK_MG28(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXMGMASK_MG28() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXMGMASK_MG29(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXMGMASK_MG29() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXMGMASK_MG30(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXMGMASK_MG30() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXMGMASK_MG31(value uint32) {
	volatile.StoreUint32(&o.RXMGMASK.Reg, volatile.LoadUint32(&o.RXMGMASK.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXMGMASK_MG31() uint32 {
	return (volatile.LoadUint32(&o.RXMGMASK.Reg) & 0x80000000) >> 31
}

// CAN.RX14MASK: Rx 14 Mask register
func (o *CAN_Type) SetRX14MASK_RX14M0(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRX14MASK_RX14M0() uint32 {
	return volatile.LoadUint32(&o.RX14MASK.Reg) & 0x1
}
func (o *CAN_Type) SetRX14MASK_RX14M1(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRX14MASK_RX14M1() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRX14MASK_RX14M2(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRX14MASK_RX14M2() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRX14MASK_RX14M3(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRX14MASK_RX14M3() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRX14MASK_RX14M4(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRX14MASK_RX14M4() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRX14MASK_RX14M5(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRX14MASK_RX14M5() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRX14MASK_RX14M6(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRX14MASK_RX14M6() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRX14MASK_RX14M7(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRX14MASK_RX14M7() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRX14MASK_RX14M8(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRX14MASK_RX14M8() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRX14MASK_RX14M9(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRX14MASK_RX14M9() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRX14MASK_RX14M10(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRX14MASK_RX14M10() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRX14MASK_RX14M11(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRX14MASK_RX14M11() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRX14MASK_RX14M12(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRX14MASK_RX14M12() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRX14MASK_RX14M13(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRX14MASK_RX14M13() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRX14MASK_RX14M14(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRX14MASK_RX14M14() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRX14MASK_RX14M15(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRX14MASK_RX14M15() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRX14MASK_RX14M16(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRX14MASK_RX14M16() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRX14MASK_RX14M17(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRX14MASK_RX14M17() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRX14MASK_RX14M18(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRX14MASK_RX14M18() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRX14MASK_RX14M19(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRX14MASK_RX14M19() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRX14MASK_RX14M20(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRX14MASK_RX14M20() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRX14MASK_RX14M21(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRX14MASK_RX14M21() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRX14MASK_RX14M22(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRX14MASK_RX14M22() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRX14MASK_RX14M23(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRX14MASK_RX14M23() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRX14MASK_RX14M24(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRX14MASK_RX14M24() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRX14MASK_RX14M25(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRX14MASK_RX14M25() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRX14MASK_RX14M26(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRX14MASK_RX14M26() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRX14MASK_RX14M27(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRX14MASK_RX14M27() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRX14MASK_RX14M28(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRX14MASK_RX14M28() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRX14MASK_RX14M29(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRX14MASK_RX14M29() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRX14MASK_RX14M30(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRX14MASK_RX14M30() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRX14MASK_RX14M31(value uint32) {
	volatile.StoreUint32(&o.RX14MASK.Reg, volatile.LoadUint32(&o.RX14MASK.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRX14MASK_RX14M31() uint32 {
	return (volatile.LoadUint32(&o.RX14MASK.Reg) & 0x80000000) >> 31
}

// CAN.RX15MASK: Rx 15 Mask register
func (o *CAN_Type) SetRX15MASK_RX15M0(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRX15MASK_RX15M0() uint32 {
	return volatile.LoadUint32(&o.RX15MASK.Reg) & 0x1
}
func (o *CAN_Type) SetRX15MASK_RX15M1(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRX15MASK_RX15M1() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRX15MASK_RX15M2(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRX15MASK_RX15M2() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRX15MASK_RX15M3(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRX15MASK_RX15M3() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRX15MASK_RX15M4(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRX15MASK_RX15M4() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRX15MASK_RX15M5(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRX15MASK_RX15M5() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRX15MASK_RX15M6(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRX15MASK_RX15M6() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRX15MASK_RX15M7(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRX15MASK_RX15M7() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRX15MASK_RX15M8(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRX15MASK_RX15M8() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRX15MASK_RX15M9(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRX15MASK_RX15M9() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRX15MASK_RX15M10(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRX15MASK_RX15M10() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRX15MASK_RX15M11(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRX15MASK_RX15M11() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRX15MASK_RX15M12(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRX15MASK_RX15M12() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRX15MASK_RX15M13(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRX15MASK_RX15M13() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRX15MASK_RX15M14(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRX15MASK_RX15M14() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRX15MASK_RX15M15(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRX15MASK_RX15M15() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRX15MASK_RX15M16(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRX15MASK_RX15M16() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRX15MASK_RX15M17(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRX15MASK_RX15M17() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRX15MASK_RX15M18(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRX15MASK_RX15M18() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRX15MASK_RX15M19(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRX15MASK_RX15M19() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRX15MASK_RX15M20(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRX15MASK_RX15M20() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRX15MASK_RX15M21(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRX15MASK_RX15M21() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRX15MASK_RX15M22(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRX15MASK_RX15M22() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRX15MASK_RX15M23(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRX15MASK_RX15M23() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRX15MASK_RX15M24(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRX15MASK_RX15M24() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRX15MASK_RX15M25(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRX15MASK_RX15M25() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRX15MASK_RX15M26(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRX15MASK_RX15M26() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRX15MASK_RX15M27(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRX15MASK_RX15M27() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRX15MASK_RX15M28(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRX15MASK_RX15M28() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRX15MASK_RX15M29(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRX15MASK_RX15M29() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRX15MASK_RX15M30(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRX15MASK_RX15M30() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRX15MASK_RX15M31(value uint32) {
	volatile.StoreUint32(&o.RX15MASK.Reg, volatile.LoadUint32(&o.RX15MASK.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRX15MASK_RX15M31() uint32 {
	return (volatile.LoadUint32(&o.RX15MASK.Reg) & 0x80000000) >> 31
}

// CAN.ECR: Error Counter
func (o *CAN_Type) SetECR_TXERRCNT(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetECR_TXERRCNT() uint32 {
	return volatile.LoadUint32(&o.ECR.Reg) & 0xff
}
func (o *CAN_Type) SetECR_RXERRCNT(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetECR_RXERRCNT() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0xff00) >> 8
}

// CAN.ESR1: Error and Status 1 register
func (o *CAN_Type) SetESR1_WAKINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetESR1_WAKINT() uint32 {
	return volatile.LoadUint32(&o.ESR1.Reg) & 0x1
}
func (o *CAN_Type) SetESR1_ERRINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetESR1_ERRINT() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetESR1_BOFFINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetESR1_BOFFINT() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetESR1_RX(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetESR1_RX() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetESR1_FLTCONF(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x30)|value<<4)
}
func (o *CAN_Type) GetESR1_FLTCONF() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x30) >> 4
}
func (o *CAN_Type) SetESR1_TX(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetESR1_TX() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetESR1_IDLE(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetESR1_IDLE() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetESR1_RXWRN(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetESR1_RXWRN() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetESR1_TXWRN(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetESR1_TXWRN() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetESR1_STFERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetESR1_STFERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetESR1_FRMERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetESR1_FRMERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetESR1_CRCERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetESR1_CRCERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetESR1_ACKERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetESR1_ACKERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetESR1_BIT0ERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetESR1_BIT0ERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetESR1_BIT1ERR(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetESR1_BIT1ERR() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetESR1_RWRNINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetESR1_RWRNINT() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetESR1_TWRNINT(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetESR1_TWRNINT() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetESR1_SYNCH(value uint32) {
	volatile.StoreUint32(&o.ESR1.Reg, volatile.LoadUint32(&o.ESR1.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetESR1_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.ESR1.Reg) & 0x40000) >> 18
}

// CAN.IMASK1: Interrupt Masks 1 register
func (o *CAN_Type) SetIMASK1_BUFLM0(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetIMASK1_BUFLM0() uint32 {
	return volatile.LoadUint32(&o.IMASK1.Reg) & 0x1
}
func (o *CAN_Type) SetIMASK1_BUFLM1(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetIMASK1_BUFLM1() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetIMASK1_BUFLM2(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetIMASK1_BUFLM2() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetIMASK1_BUFLM3(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetIMASK1_BUFLM3() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetIMASK1_BUFLM4(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetIMASK1_BUFLM4() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetIMASK1_BUFLM5(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetIMASK1_BUFLM5() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetIMASK1_BUFLM6(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetIMASK1_BUFLM6() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetIMASK1_BUFLM7(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetIMASK1_BUFLM7() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetIMASK1_BUFLM8(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetIMASK1_BUFLM8() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetIMASK1_BUFLM9(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetIMASK1_BUFLM9() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetIMASK1_BUFLM10(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetIMASK1_BUFLM10() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetIMASK1_BUFLM11(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetIMASK1_BUFLM11() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetIMASK1_BUFLM12(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetIMASK1_BUFLM12() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetIMASK1_BUFLM13(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetIMASK1_BUFLM13() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetIMASK1_BUFLM14(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetIMASK1_BUFLM14() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetIMASK1_BUFLM15(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetIMASK1_BUFLM15() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetIMASK1_BUFLM16(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetIMASK1_BUFLM16() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetIMASK1_BUFLM17(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetIMASK1_BUFLM17() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetIMASK1_BUFLM18(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetIMASK1_BUFLM18() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetIMASK1_BUFLM19(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetIMASK1_BUFLM19() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetIMASK1_BUFLM20(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetIMASK1_BUFLM20() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetIMASK1_BUFLM21(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetIMASK1_BUFLM21() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetIMASK1_BUFLM22(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetIMASK1_BUFLM22() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetIMASK1_BUFLM23(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetIMASK1_BUFLM23() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetIMASK1_BUFLM24(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetIMASK1_BUFLM24() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetIMASK1_BUFLM25(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetIMASK1_BUFLM25() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetIMASK1_BUFLM26(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetIMASK1_BUFLM26() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetIMASK1_BUFLM27(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetIMASK1_BUFLM27() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetIMASK1_BUFLM28(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetIMASK1_BUFLM28() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetIMASK1_BUFLM29(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetIMASK1_BUFLM29() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetIMASK1_BUFLM30(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetIMASK1_BUFLM30() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetIMASK1_BUFLM31(value uint32) {
	volatile.StoreUint32(&o.IMASK1.Reg, volatile.LoadUint32(&o.IMASK1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetIMASK1_BUFLM31() uint32 {
	return (volatile.LoadUint32(&o.IMASK1.Reg) & 0x80000000) >> 31
}

// CAN.IFLAG1: Interrupt Flags 1 register
func (o *CAN_Type) SetIFLAG1_BUF0I(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetIFLAG1_BUF0I() uint32 {
	return volatile.LoadUint32(&o.IFLAG1.Reg) & 0x1
}
func (o *CAN_Type) SetIFLAG1_BUF4TO1I0(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetIFLAG1_BUF4TO1I0() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetIFLAG1_BUF4TO1I1(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetIFLAG1_BUF4TO1I1() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetIFLAG1_BUF4TO1I2(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetIFLAG1_BUF4TO1I2() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetIFLAG1_BUF4TO1I3(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetIFLAG1_BUF4TO1I3() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetIFLAG1_BUF5I(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetIFLAG1_BUF5I() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetIFLAG1_BUF6I(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetIFLAG1_BUF6I() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetIFLAG1_BUF7I(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetIFLAG1_BUF7I() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I0(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I0() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I1(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I1() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I2(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I2() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I3(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I3() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I4(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I4() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I5(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I5() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I6(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I6() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I7(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I7() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I8(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I8() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I9(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I9() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I10(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I10() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I11(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I11() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I12(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I12() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I13(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I13() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I14(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I14() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I15(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I15() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I16(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I16() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I17(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I17() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I18(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I18() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I19(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I19() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I20(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I20() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I21(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I21() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I22(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I22() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetIFLAG1_BUF31TO8I23(value uint32) {
	volatile.StoreUint32(&o.IFLAG1.Reg, volatile.LoadUint32(&o.IFLAG1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetIFLAG1_BUF31TO8I23() uint32 {
	return (volatile.LoadUint32(&o.IFLAG1.Reg) & 0x80000000) >> 31
}

// CAN.CTRL2: Control 2 register
func (o *CAN_Type) SetCTRL2_EACEN(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetCTRL2_EACEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetCTRL2_RRS(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetCTRL2_RRS() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetCTRL2_MRP(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetCTRL2_MRP() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetCTRL2_TASD(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0xf80000)|value<<19)
}
func (o *CAN_Type) GetCTRL2_TASD() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0xf80000) >> 19
}
func (o *CAN_Type) SetCTRL2_RFFN(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCTRL2_RFFN() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0xf000000) >> 24
}
func (o *CAN_Type) SetCTRL2_WRMFRZ(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetCTRL2_WRMFRZ() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x10000000) >> 28
}

// CAN.ESR2: Error and Status 2 register
func (o *CAN_Type) SetESR2_IMB(value uint32) {
	volatile.StoreUint32(&o.ESR2.Reg, volatile.LoadUint32(&o.ESR2.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetESR2_IMB() uint32 {
	return (volatile.LoadUint32(&o.ESR2.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetESR2_VPS(value uint32) {
	volatile.StoreUint32(&o.ESR2.Reg, volatile.LoadUint32(&o.ESR2.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetESR2_VPS() uint32 {
	return (volatile.LoadUint32(&o.ESR2.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetESR2_LPTM(value uint32) {
	volatile.StoreUint32(&o.ESR2.Reg, volatile.LoadUint32(&o.ESR2.Reg)&^(0x7f0000)|value<<16)
}
func (o *CAN_Type) GetESR2_LPTM() uint32 {
	return (volatile.LoadUint32(&o.ESR2.Reg) & 0x7f0000) >> 16
}

// CAN.CRCR: CRC Register
func (o *CAN_Type) SetCRCR_TXCRC(value uint32) {
	volatile.StoreUint32(&o.CRCR.Reg, volatile.LoadUint32(&o.CRCR.Reg)&^(0x7fff)|value)
}
func (o *CAN_Type) GetCRCR_TXCRC() uint32 {
	return volatile.LoadUint32(&o.CRCR.Reg) & 0x7fff
}
func (o *CAN_Type) SetCRCR_MBCRC(value uint32) {
	volatile.StoreUint32(&o.CRCR.Reg, volatile.LoadUint32(&o.CRCR.Reg)&^(0x7f0000)|value<<16)
}
func (o *CAN_Type) GetCRCR_MBCRC() uint32 {
	return (volatile.LoadUint32(&o.CRCR.Reg) & 0x7f0000) >> 16
}

// CAN.RXFGMASK: Rx FIFO Global Mask register
func (o *CAN_Type) SetRXFGMASK_FGM0(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXFGMASK_FGM0() uint32 {
	return volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x1
}
func (o *CAN_Type) SetRXFGMASK_FGM1(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXFGMASK_FGM1() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXFGMASK_FGM2(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXFGMASK_FGM2() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXFGMASK_FGM3(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXFGMASK_FGM3() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXFGMASK_FGM4(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXFGMASK_FGM4() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXFGMASK_FGM5(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXFGMASK_FGM5() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXFGMASK_FGM6(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXFGMASK_FGM6() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXFGMASK_FGM7(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXFGMASK_FGM7() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXFGMASK_FGM8(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXFGMASK_FGM8() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXFGMASK_FGM9(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXFGMASK_FGM9() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXFGMASK_FGM10(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXFGMASK_FGM10() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXFGMASK_FGM11(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXFGMASK_FGM11() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXFGMASK_FGM12(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXFGMASK_FGM12() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXFGMASK_FGM13(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXFGMASK_FGM13() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXFGMASK_FGM14(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXFGMASK_FGM14() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXFGMASK_FGM15(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXFGMASK_FGM15() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXFGMASK_FGM16(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXFGMASK_FGM16() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXFGMASK_FGM17(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXFGMASK_FGM17() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXFGMASK_FGM18(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXFGMASK_FGM18() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXFGMASK_FGM19(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXFGMASK_FGM19() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXFGMASK_FGM20(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXFGMASK_FGM20() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXFGMASK_FGM21(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXFGMASK_FGM21() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXFGMASK_FGM22(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXFGMASK_FGM22() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXFGMASK_FGM23(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXFGMASK_FGM23() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXFGMASK_FGM24(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXFGMASK_FGM24() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXFGMASK_FGM25(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXFGMASK_FGM25() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXFGMASK_FGM26(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXFGMASK_FGM26() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXFGMASK_FGM27(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXFGMASK_FGM27() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXFGMASK_FGM28(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXFGMASK_FGM28() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXFGMASK_FGM29(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXFGMASK_FGM29() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXFGMASK_FGM30(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXFGMASK_FGM30() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXFGMASK_FGM31(value uint32) {
	volatile.StoreUint32(&o.RXFGMASK.Reg, volatile.LoadUint32(&o.RXFGMASK.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXFGMASK_FGM31() uint32 {
	return (volatile.LoadUint32(&o.RXFGMASK.Reg) & 0x80000000) >> 31
}

// CAN.RXFIR: Rx FIFO Information Register
func (o *CAN_Type) SetRXFIR_IDHIT(value uint32) {
	volatile.StoreUint32(&o.RXFIR.Reg, volatile.LoadUint32(&o.RXFIR.Reg)&^(0x1ff)|value)
}
func (o *CAN_Type) GetRXFIR_IDHIT() uint32 {
	return volatile.LoadUint32(&o.RXFIR.Reg) & 0x1ff
}

// CAN.CS0: Message Buffer 0 CS Register
func (o *CAN_Type) SetCS0_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS0_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS0.Reg) & 0xffff
}
func (o *CAN_Type) SetCS0_DLC(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS0_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS0_RTR(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS0_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS0_IDE(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS0_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS0_SRR(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS0_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS0_CODE(value uint32) {
	volatile.StoreUint32(&o.CS0.Reg, volatile.LoadUint32(&o.CS0.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS0_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS0.Reg) & 0xf000000) >> 24
}

// CAN.ID0: Message Buffer 0 ID Register
func (o *CAN_Type) SetID0_EXT(value uint32) {
	volatile.StoreUint32(&o.ID0.Reg, volatile.LoadUint32(&o.ID0.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID0_EXT() uint32 {
	return volatile.LoadUint32(&o.ID0.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID0_STD(value uint32) {
	volatile.StoreUint32(&o.ID0.Reg, volatile.LoadUint32(&o.ID0.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID0_STD() uint32 {
	return (volatile.LoadUint32(&o.ID0.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID0_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID0.Reg, volatile.LoadUint32(&o.ID0.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID0_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID0.Reg) & 0xe0000000) >> 29
}

// CAN.WORD00: Message Buffer 0 WORD0 Register
func (o *CAN_Type) SetWORD00_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD00.Reg, volatile.LoadUint32(&o.WORD00.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD00_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD00.Reg) & 0xff
}
func (o *CAN_Type) SetWORD00_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD00.Reg, volatile.LoadUint32(&o.WORD00.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD00_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD00.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD00_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD00.Reg, volatile.LoadUint32(&o.WORD00.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD00_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD00.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD00_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD00.Reg, volatile.LoadUint32(&o.WORD00.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD00_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD00.Reg) & 0xff000000) >> 24
}

// CAN.WORD10: Message Buffer 0 WORD1 Register
func (o *CAN_Type) SetWORD10_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD10.Reg, volatile.LoadUint32(&o.WORD10.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD10_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD10.Reg) & 0xff
}
func (o *CAN_Type) SetWORD10_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD10.Reg, volatile.LoadUint32(&o.WORD10.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD10_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD10.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD10_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD10.Reg, volatile.LoadUint32(&o.WORD10.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD10_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD10.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD10_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD10.Reg, volatile.LoadUint32(&o.WORD10.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD10_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD10.Reg) & 0xff000000) >> 24
}

// CAN.CS1: Message Buffer 1 CS Register
func (o *CAN_Type) SetCS1_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS1_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS1.Reg) & 0xffff
}
func (o *CAN_Type) SetCS1_DLC(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS1_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS1_RTR(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS1_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS1_IDE(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS1_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS1_SRR(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS1_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS1_CODE(value uint32) {
	volatile.StoreUint32(&o.CS1.Reg, volatile.LoadUint32(&o.CS1.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS1_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS1.Reg) & 0xf000000) >> 24
}

// CAN.ID1: Message Buffer 1 ID Register
func (o *CAN_Type) SetID1_EXT(value uint32) {
	volatile.StoreUint32(&o.ID1.Reg, volatile.LoadUint32(&o.ID1.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID1_EXT() uint32 {
	return volatile.LoadUint32(&o.ID1.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID1_STD(value uint32) {
	volatile.StoreUint32(&o.ID1.Reg, volatile.LoadUint32(&o.ID1.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID1_STD() uint32 {
	return (volatile.LoadUint32(&o.ID1.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID1_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID1.Reg, volatile.LoadUint32(&o.ID1.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID1_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID1.Reg) & 0xe0000000) >> 29
}

// CAN.WORD01: Message Buffer 1 WORD0 Register
func (o *CAN_Type) SetWORD01_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD01.Reg, volatile.LoadUint32(&o.WORD01.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD01_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD01.Reg) & 0xff
}
func (o *CAN_Type) SetWORD01_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD01.Reg, volatile.LoadUint32(&o.WORD01.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD01_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD01.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD01_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD01.Reg, volatile.LoadUint32(&o.WORD01.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD01_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD01.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD01_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD01.Reg, volatile.LoadUint32(&o.WORD01.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD01_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD01.Reg) & 0xff000000) >> 24
}

// CAN.WORD11: Message Buffer 1 WORD1 Register
func (o *CAN_Type) SetWORD11_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD11.Reg, volatile.LoadUint32(&o.WORD11.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD11_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD11.Reg) & 0xff
}
func (o *CAN_Type) SetWORD11_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD11.Reg, volatile.LoadUint32(&o.WORD11.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD11_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD11.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD11_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD11.Reg, volatile.LoadUint32(&o.WORD11.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD11_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD11.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD11_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD11.Reg, volatile.LoadUint32(&o.WORD11.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD11_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD11.Reg) & 0xff000000) >> 24
}

// CAN.CS2: Message Buffer 2 CS Register
func (o *CAN_Type) SetCS2_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS2_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS2.Reg) & 0xffff
}
func (o *CAN_Type) SetCS2_DLC(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS2_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS2_RTR(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS2_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS2_IDE(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS2_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS2_SRR(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS2_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS2_CODE(value uint32) {
	volatile.StoreUint32(&o.CS2.Reg, volatile.LoadUint32(&o.CS2.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS2_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS2.Reg) & 0xf000000) >> 24
}

// CAN.ID2: Message Buffer 2 ID Register
func (o *CAN_Type) SetID2_EXT(value uint32) {
	volatile.StoreUint32(&o.ID2.Reg, volatile.LoadUint32(&o.ID2.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID2_EXT() uint32 {
	return volatile.LoadUint32(&o.ID2.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID2_STD(value uint32) {
	volatile.StoreUint32(&o.ID2.Reg, volatile.LoadUint32(&o.ID2.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID2_STD() uint32 {
	return (volatile.LoadUint32(&o.ID2.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID2_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID2.Reg, volatile.LoadUint32(&o.ID2.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID2_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID2.Reg) & 0xe0000000) >> 29
}

// CAN.WORD02: Message Buffer 2 WORD0 Register
func (o *CAN_Type) SetWORD02_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD02.Reg, volatile.LoadUint32(&o.WORD02.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD02_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD02.Reg) & 0xff
}
func (o *CAN_Type) SetWORD02_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD02.Reg, volatile.LoadUint32(&o.WORD02.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD02_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD02.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD02_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD02.Reg, volatile.LoadUint32(&o.WORD02.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD02_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD02.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD02_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD02.Reg, volatile.LoadUint32(&o.WORD02.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD02_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD02.Reg) & 0xff000000) >> 24
}

// CAN.WORD12: Message Buffer 2 WORD1 Register
func (o *CAN_Type) SetWORD12_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD12.Reg, volatile.LoadUint32(&o.WORD12.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD12_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD12.Reg) & 0xff
}
func (o *CAN_Type) SetWORD12_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD12.Reg, volatile.LoadUint32(&o.WORD12.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD12_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD12.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD12_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD12.Reg, volatile.LoadUint32(&o.WORD12.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD12_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD12.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD12_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD12.Reg, volatile.LoadUint32(&o.WORD12.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD12_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD12.Reg) & 0xff000000) >> 24
}

// CAN.CS3: Message Buffer 3 CS Register
func (o *CAN_Type) SetCS3_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS3_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS3.Reg) & 0xffff
}
func (o *CAN_Type) SetCS3_DLC(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS3_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS3_RTR(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS3_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS3_IDE(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS3_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS3_SRR(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS3_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS3_CODE(value uint32) {
	volatile.StoreUint32(&o.CS3.Reg, volatile.LoadUint32(&o.CS3.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS3_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS3.Reg) & 0xf000000) >> 24
}

// CAN.ID3: Message Buffer 3 ID Register
func (o *CAN_Type) SetID3_EXT(value uint32) {
	volatile.StoreUint32(&o.ID3.Reg, volatile.LoadUint32(&o.ID3.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID3_EXT() uint32 {
	return volatile.LoadUint32(&o.ID3.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID3_STD(value uint32) {
	volatile.StoreUint32(&o.ID3.Reg, volatile.LoadUint32(&o.ID3.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID3_STD() uint32 {
	return (volatile.LoadUint32(&o.ID3.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID3_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID3.Reg, volatile.LoadUint32(&o.ID3.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID3_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID3.Reg) & 0xe0000000) >> 29
}

// CAN.WORD03: Message Buffer 3 WORD0 Register
func (o *CAN_Type) SetWORD03_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD03.Reg, volatile.LoadUint32(&o.WORD03.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD03_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD03.Reg) & 0xff
}
func (o *CAN_Type) SetWORD03_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD03.Reg, volatile.LoadUint32(&o.WORD03.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD03_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD03.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD03_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD03.Reg, volatile.LoadUint32(&o.WORD03.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD03_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD03.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD03_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD03.Reg, volatile.LoadUint32(&o.WORD03.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD03_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD03.Reg) & 0xff000000) >> 24
}

// CAN.WORD13: Message Buffer 3 WORD1 Register
func (o *CAN_Type) SetWORD13_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD13.Reg, volatile.LoadUint32(&o.WORD13.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD13_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD13.Reg) & 0xff
}
func (o *CAN_Type) SetWORD13_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD13.Reg, volatile.LoadUint32(&o.WORD13.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD13_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD13.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD13_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD13.Reg, volatile.LoadUint32(&o.WORD13.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD13_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD13.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD13_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD13.Reg, volatile.LoadUint32(&o.WORD13.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD13_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD13.Reg) & 0xff000000) >> 24
}

// CAN.CS4: Message Buffer 4 CS Register
func (o *CAN_Type) SetCS4_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS4_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS4.Reg) & 0xffff
}
func (o *CAN_Type) SetCS4_DLC(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS4_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS4_RTR(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS4_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS4_IDE(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS4_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS4_SRR(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS4_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS4_CODE(value uint32) {
	volatile.StoreUint32(&o.CS4.Reg, volatile.LoadUint32(&o.CS4.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS4_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS4.Reg) & 0xf000000) >> 24
}

// CAN.ID4: Message Buffer 4 ID Register
func (o *CAN_Type) SetID4_EXT(value uint32) {
	volatile.StoreUint32(&o.ID4.Reg, volatile.LoadUint32(&o.ID4.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID4_EXT() uint32 {
	return volatile.LoadUint32(&o.ID4.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID4_STD(value uint32) {
	volatile.StoreUint32(&o.ID4.Reg, volatile.LoadUint32(&o.ID4.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID4_STD() uint32 {
	return (volatile.LoadUint32(&o.ID4.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID4_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID4.Reg, volatile.LoadUint32(&o.ID4.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID4_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID4.Reg) & 0xe0000000) >> 29
}

// CAN.WORD04: Message Buffer 4 WORD0 Register
func (o *CAN_Type) SetWORD04_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD04.Reg, volatile.LoadUint32(&o.WORD04.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD04_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD04.Reg) & 0xff
}
func (o *CAN_Type) SetWORD04_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD04.Reg, volatile.LoadUint32(&o.WORD04.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD04_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD04.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD04_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD04.Reg, volatile.LoadUint32(&o.WORD04.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD04_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD04.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD04_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD04.Reg, volatile.LoadUint32(&o.WORD04.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD04_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD04.Reg) & 0xff000000) >> 24
}

// CAN.WORD14: Message Buffer 4 WORD1 Register
func (o *CAN_Type) SetWORD14_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD14.Reg, volatile.LoadUint32(&o.WORD14.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD14_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD14.Reg) & 0xff
}
func (o *CAN_Type) SetWORD14_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD14.Reg, volatile.LoadUint32(&o.WORD14.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD14_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD14.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD14_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD14.Reg, volatile.LoadUint32(&o.WORD14.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD14_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD14.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD14_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD14.Reg, volatile.LoadUint32(&o.WORD14.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD14_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD14.Reg) & 0xff000000) >> 24
}

// CAN.CS5: Message Buffer 5 CS Register
func (o *CAN_Type) SetCS5_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS5_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS5.Reg) & 0xffff
}
func (o *CAN_Type) SetCS5_DLC(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS5_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS5_RTR(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS5_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS5_IDE(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS5_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS5_SRR(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS5_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS5_CODE(value uint32) {
	volatile.StoreUint32(&o.CS5.Reg, volatile.LoadUint32(&o.CS5.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS5_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS5.Reg) & 0xf000000) >> 24
}

// CAN.ID5: Message Buffer 5 ID Register
func (o *CAN_Type) SetID5_EXT(value uint32) {
	volatile.StoreUint32(&o.ID5.Reg, volatile.LoadUint32(&o.ID5.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID5_EXT() uint32 {
	return volatile.LoadUint32(&o.ID5.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID5_STD(value uint32) {
	volatile.StoreUint32(&o.ID5.Reg, volatile.LoadUint32(&o.ID5.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID5_STD() uint32 {
	return (volatile.LoadUint32(&o.ID5.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID5_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID5.Reg, volatile.LoadUint32(&o.ID5.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID5_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID5.Reg) & 0xe0000000) >> 29
}

// CAN.WORD05: Message Buffer 5 WORD0 Register
func (o *CAN_Type) SetWORD05_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD05.Reg, volatile.LoadUint32(&o.WORD05.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD05_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD05.Reg) & 0xff
}
func (o *CAN_Type) SetWORD05_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD05.Reg, volatile.LoadUint32(&o.WORD05.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD05_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD05.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD05_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD05.Reg, volatile.LoadUint32(&o.WORD05.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD05_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD05.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD05_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD05.Reg, volatile.LoadUint32(&o.WORD05.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD05_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD05.Reg) & 0xff000000) >> 24
}

// CAN.WORD15: Message Buffer 5 WORD1 Register
func (o *CAN_Type) SetWORD15_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD15.Reg, volatile.LoadUint32(&o.WORD15.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD15_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD15.Reg) & 0xff
}
func (o *CAN_Type) SetWORD15_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD15.Reg, volatile.LoadUint32(&o.WORD15.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD15_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD15.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD15_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD15.Reg, volatile.LoadUint32(&o.WORD15.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD15_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD15.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD15_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD15.Reg, volatile.LoadUint32(&o.WORD15.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD15_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD15.Reg) & 0xff000000) >> 24
}

// CAN.CS6: Message Buffer 6 CS Register
func (o *CAN_Type) SetCS6_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS6_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS6.Reg) & 0xffff
}
func (o *CAN_Type) SetCS6_DLC(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS6_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS6_RTR(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS6_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS6_IDE(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS6_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS6_SRR(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS6_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS6_CODE(value uint32) {
	volatile.StoreUint32(&o.CS6.Reg, volatile.LoadUint32(&o.CS6.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS6_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS6.Reg) & 0xf000000) >> 24
}

// CAN.ID6: Message Buffer 6 ID Register
func (o *CAN_Type) SetID6_EXT(value uint32) {
	volatile.StoreUint32(&o.ID6.Reg, volatile.LoadUint32(&o.ID6.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID6_EXT() uint32 {
	return volatile.LoadUint32(&o.ID6.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID6_STD(value uint32) {
	volatile.StoreUint32(&o.ID6.Reg, volatile.LoadUint32(&o.ID6.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID6_STD() uint32 {
	return (volatile.LoadUint32(&o.ID6.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID6_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID6.Reg, volatile.LoadUint32(&o.ID6.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID6_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID6.Reg) & 0xe0000000) >> 29
}

// CAN.WORD06: Message Buffer 6 WORD0 Register
func (o *CAN_Type) SetWORD06_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD06.Reg, volatile.LoadUint32(&o.WORD06.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD06_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD06.Reg) & 0xff
}
func (o *CAN_Type) SetWORD06_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD06.Reg, volatile.LoadUint32(&o.WORD06.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD06_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD06.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD06_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD06.Reg, volatile.LoadUint32(&o.WORD06.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD06_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD06.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD06_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD06.Reg, volatile.LoadUint32(&o.WORD06.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD06_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD06.Reg) & 0xff000000) >> 24
}

// CAN.WORD16: Message Buffer 6 WORD1 Register
func (o *CAN_Type) SetWORD16_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD16.Reg, volatile.LoadUint32(&o.WORD16.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD16_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD16.Reg) & 0xff
}
func (o *CAN_Type) SetWORD16_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD16.Reg, volatile.LoadUint32(&o.WORD16.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD16_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD16.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD16_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD16.Reg, volatile.LoadUint32(&o.WORD16.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD16_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD16.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD16_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD16.Reg, volatile.LoadUint32(&o.WORD16.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD16_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD16.Reg) & 0xff000000) >> 24
}

// CAN.CS7: Message Buffer 7 CS Register
func (o *CAN_Type) SetCS7_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS7_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS7.Reg) & 0xffff
}
func (o *CAN_Type) SetCS7_DLC(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS7_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS7_RTR(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS7_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS7_IDE(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS7_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS7_SRR(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS7_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS7_CODE(value uint32) {
	volatile.StoreUint32(&o.CS7.Reg, volatile.LoadUint32(&o.CS7.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS7_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS7.Reg) & 0xf000000) >> 24
}

// CAN.ID7: Message Buffer 7 ID Register
func (o *CAN_Type) SetID7_EXT(value uint32) {
	volatile.StoreUint32(&o.ID7.Reg, volatile.LoadUint32(&o.ID7.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID7_EXT() uint32 {
	return volatile.LoadUint32(&o.ID7.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID7_STD(value uint32) {
	volatile.StoreUint32(&o.ID7.Reg, volatile.LoadUint32(&o.ID7.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID7_STD() uint32 {
	return (volatile.LoadUint32(&o.ID7.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID7_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID7.Reg, volatile.LoadUint32(&o.ID7.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID7_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID7.Reg) & 0xe0000000) >> 29
}

// CAN.WORD07: Message Buffer 7 WORD0 Register
func (o *CAN_Type) SetWORD07_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD07.Reg, volatile.LoadUint32(&o.WORD07.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD07_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD07.Reg) & 0xff
}
func (o *CAN_Type) SetWORD07_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD07.Reg, volatile.LoadUint32(&o.WORD07.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD07_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD07.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD07_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD07.Reg, volatile.LoadUint32(&o.WORD07.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD07_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD07.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD07_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD07.Reg, volatile.LoadUint32(&o.WORD07.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD07_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD07.Reg) & 0xff000000) >> 24
}

// CAN.WORD17: Message Buffer 7 WORD1 Register
func (o *CAN_Type) SetWORD17_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD17.Reg, volatile.LoadUint32(&o.WORD17.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD17_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD17.Reg) & 0xff
}
func (o *CAN_Type) SetWORD17_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD17.Reg, volatile.LoadUint32(&o.WORD17.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD17_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD17.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD17_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD17.Reg, volatile.LoadUint32(&o.WORD17.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD17_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD17.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD17_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD17.Reg, volatile.LoadUint32(&o.WORD17.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD17_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD17.Reg) & 0xff000000) >> 24
}

// CAN.CS8: Message Buffer 8 CS Register
func (o *CAN_Type) SetCS8_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS8_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS8.Reg) & 0xffff
}
func (o *CAN_Type) SetCS8_DLC(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS8_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS8_RTR(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS8_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS8_IDE(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS8_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS8_SRR(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS8_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS8_CODE(value uint32) {
	volatile.StoreUint32(&o.CS8.Reg, volatile.LoadUint32(&o.CS8.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS8_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS8.Reg) & 0xf000000) >> 24
}

// CAN.ID8: Message Buffer 8 ID Register
func (o *CAN_Type) SetID8_EXT(value uint32) {
	volatile.StoreUint32(&o.ID8.Reg, volatile.LoadUint32(&o.ID8.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID8_EXT() uint32 {
	return volatile.LoadUint32(&o.ID8.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID8_STD(value uint32) {
	volatile.StoreUint32(&o.ID8.Reg, volatile.LoadUint32(&o.ID8.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID8_STD() uint32 {
	return (volatile.LoadUint32(&o.ID8.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID8_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID8.Reg, volatile.LoadUint32(&o.ID8.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID8_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID8.Reg) & 0xe0000000) >> 29
}

// CAN.WORD08: Message Buffer 8 WORD0 Register
func (o *CAN_Type) SetWORD08_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD08.Reg, volatile.LoadUint32(&o.WORD08.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD08_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD08.Reg) & 0xff
}
func (o *CAN_Type) SetWORD08_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD08.Reg, volatile.LoadUint32(&o.WORD08.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD08_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD08.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD08_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD08.Reg, volatile.LoadUint32(&o.WORD08.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD08_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD08.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD08_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD08.Reg, volatile.LoadUint32(&o.WORD08.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD08_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD08.Reg) & 0xff000000) >> 24
}

// CAN.WORD18: Message Buffer 8 WORD1 Register
func (o *CAN_Type) SetWORD18_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD18.Reg, volatile.LoadUint32(&o.WORD18.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD18_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD18.Reg) & 0xff
}
func (o *CAN_Type) SetWORD18_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD18.Reg, volatile.LoadUint32(&o.WORD18.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD18_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD18.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD18_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD18.Reg, volatile.LoadUint32(&o.WORD18.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD18_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD18.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD18_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD18.Reg, volatile.LoadUint32(&o.WORD18.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD18_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD18.Reg) & 0xff000000) >> 24
}

// CAN.CS9: Message Buffer 9 CS Register
func (o *CAN_Type) SetCS9_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS9_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS9.Reg) & 0xffff
}
func (o *CAN_Type) SetCS9_DLC(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS9_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS9_RTR(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS9_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS9_IDE(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS9_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS9_SRR(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS9_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS9_CODE(value uint32) {
	volatile.StoreUint32(&o.CS9.Reg, volatile.LoadUint32(&o.CS9.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS9_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS9.Reg) & 0xf000000) >> 24
}

// CAN.ID9: Message Buffer 9 ID Register
func (o *CAN_Type) SetID9_EXT(value uint32) {
	volatile.StoreUint32(&o.ID9.Reg, volatile.LoadUint32(&o.ID9.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID9_EXT() uint32 {
	return volatile.LoadUint32(&o.ID9.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID9_STD(value uint32) {
	volatile.StoreUint32(&o.ID9.Reg, volatile.LoadUint32(&o.ID9.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID9_STD() uint32 {
	return (volatile.LoadUint32(&o.ID9.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID9_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID9.Reg, volatile.LoadUint32(&o.ID9.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID9_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID9.Reg) & 0xe0000000) >> 29
}

// CAN.WORD09: Message Buffer 9 WORD0 Register
func (o *CAN_Type) SetWORD09_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD09.Reg, volatile.LoadUint32(&o.WORD09.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD09_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD09.Reg) & 0xff
}
func (o *CAN_Type) SetWORD09_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD09.Reg, volatile.LoadUint32(&o.WORD09.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD09_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD09.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD09_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD09.Reg, volatile.LoadUint32(&o.WORD09.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD09_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD09.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD09_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD09.Reg, volatile.LoadUint32(&o.WORD09.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD09_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD09.Reg) & 0xff000000) >> 24
}

// CAN.WORD19: Message Buffer 9 WORD1 Register
func (o *CAN_Type) SetWORD19_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD19.Reg, volatile.LoadUint32(&o.WORD19.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD19_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD19.Reg) & 0xff
}
func (o *CAN_Type) SetWORD19_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD19.Reg, volatile.LoadUint32(&o.WORD19.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD19_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD19.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD19_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD19.Reg, volatile.LoadUint32(&o.WORD19.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD19_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD19.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD19_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD19.Reg, volatile.LoadUint32(&o.WORD19.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD19_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD19.Reg) & 0xff000000) >> 24
}

// CAN.CS10: Message Buffer 10 CS Register
func (o *CAN_Type) SetCS10_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS10_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS10.Reg) & 0xffff
}
func (o *CAN_Type) SetCS10_DLC(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS10_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS10_RTR(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS10_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS10_IDE(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS10_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS10_SRR(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS10_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS10_CODE(value uint32) {
	volatile.StoreUint32(&o.CS10.Reg, volatile.LoadUint32(&o.CS10.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS10_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS10.Reg) & 0xf000000) >> 24
}

// CAN.ID10: Message Buffer 10 ID Register
func (o *CAN_Type) SetID10_EXT(value uint32) {
	volatile.StoreUint32(&o.ID10.Reg, volatile.LoadUint32(&o.ID10.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID10_EXT() uint32 {
	return volatile.LoadUint32(&o.ID10.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID10_STD(value uint32) {
	volatile.StoreUint32(&o.ID10.Reg, volatile.LoadUint32(&o.ID10.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID10_STD() uint32 {
	return (volatile.LoadUint32(&o.ID10.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID10_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID10.Reg, volatile.LoadUint32(&o.ID10.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID10_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID10.Reg) & 0xe0000000) >> 29
}

// CAN.WORD010: Message Buffer 10 WORD0 Register
func (o *CAN_Type) SetWORD010_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD010.Reg, volatile.LoadUint32(&o.WORD010.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD010_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD010.Reg) & 0xff
}
func (o *CAN_Type) SetWORD010_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD010.Reg, volatile.LoadUint32(&o.WORD010.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD010_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD010.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD010_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD010.Reg, volatile.LoadUint32(&o.WORD010.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD010_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD010.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD010_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD010.Reg, volatile.LoadUint32(&o.WORD010.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD010_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD010.Reg) & 0xff000000) >> 24
}

// CAN.WORD110: Message Buffer 10 WORD1 Register
func (o *CAN_Type) SetWORD110_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD110.Reg, volatile.LoadUint32(&o.WORD110.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD110_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD110.Reg) & 0xff
}
func (o *CAN_Type) SetWORD110_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD110.Reg, volatile.LoadUint32(&o.WORD110.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD110_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD110.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD110_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD110.Reg, volatile.LoadUint32(&o.WORD110.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD110_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD110.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD110_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD110.Reg, volatile.LoadUint32(&o.WORD110.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD110_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD110.Reg) & 0xff000000) >> 24
}

// CAN.CS11: Message Buffer 11 CS Register
func (o *CAN_Type) SetCS11_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS11_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS11.Reg) & 0xffff
}
func (o *CAN_Type) SetCS11_DLC(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS11_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS11_RTR(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS11_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS11_IDE(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS11_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS11_SRR(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS11_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS11_CODE(value uint32) {
	volatile.StoreUint32(&o.CS11.Reg, volatile.LoadUint32(&o.CS11.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS11_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS11.Reg) & 0xf000000) >> 24
}

// CAN.ID11: Message Buffer 11 ID Register
func (o *CAN_Type) SetID11_EXT(value uint32) {
	volatile.StoreUint32(&o.ID11.Reg, volatile.LoadUint32(&o.ID11.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID11_EXT() uint32 {
	return volatile.LoadUint32(&o.ID11.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID11_STD(value uint32) {
	volatile.StoreUint32(&o.ID11.Reg, volatile.LoadUint32(&o.ID11.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID11_STD() uint32 {
	return (volatile.LoadUint32(&o.ID11.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID11_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID11.Reg, volatile.LoadUint32(&o.ID11.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID11_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID11.Reg) & 0xe0000000) >> 29
}

// CAN.WORD011: Message Buffer 11 WORD0 Register
func (o *CAN_Type) SetWORD011_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD011.Reg, volatile.LoadUint32(&o.WORD011.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD011_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD011.Reg) & 0xff
}
func (o *CAN_Type) SetWORD011_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD011.Reg, volatile.LoadUint32(&o.WORD011.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD011_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD011.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD011_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD011.Reg, volatile.LoadUint32(&o.WORD011.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD011_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD011.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD011_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD011.Reg, volatile.LoadUint32(&o.WORD011.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD011_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD011.Reg) & 0xff000000) >> 24
}

// CAN.WORD111: Message Buffer 11 WORD1 Register
func (o *CAN_Type) SetWORD111_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD111.Reg, volatile.LoadUint32(&o.WORD111.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD111_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD111.Reg) & 0xff
}
func (o *CAN_Type) SetWORD111_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD111.Reg, volatile.LoadUint32(&o.WORD111.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD111_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD111.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD111_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD111.Reg, volatile.LoadUint32(&o.WORD111.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD111_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD111.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD111_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD111.Reg, volatile.LoadUint32(&o.WORD111.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD111_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD111.Reg) & 0xff000000) >> 24
}

// CAN.CS12: Message Buffer 12 CS Register
func (o *CAN_Type) SetCS12_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS12_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS12.Reg) & 0xffff
}
func (o *CAN_Type) SetCS12_DLC(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS12_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS12_RTR(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS12_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS12_IDE(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS12_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS12_SRR(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS12_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS12_CODE(value uint32) {
	volatile.StoreUint32(&o.CS12.Reg, volatile.LoadUint32(&o.CS12.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS12_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS12.Reg) & 0xf000000) >> 24
}

// CAN.ID12: Message Buffer 12 ID Register
func (o *CAN_Type) SetID12_EXT(value uint32) {
	volatile.StoreUint32(&o.ID12.Reg, volatile.LoadUint32(&o.ID12.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID12_EXT() uint32 {
	return volatile.LoadUint32(&o.ID12.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID12_STD(value uint32) {
	volatile.StoreUint32(&o.ID12.Reg, volatile.LoadUint32(&o.ID12.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID12_STD() uint32 {
	return (volatile.LoadUint32(&o.ID12.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID12_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID12.Reg, volatile.LoadUint32(&o.ID12.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID12_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID12.Reg) & 0xe0000000) >> 29
}

// CAN.WORD012: Message Buffer 12 WORD0 Register
func (o *CAN_Type) SetWORD012_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD012.Reg, volatile.LoadUint32(&o.WORD012.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD012_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD012.Reg) & 0xff
}
func (o *CAN_Type) SetWORD012_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD012.Reg, volatile.LoadUint32(&o.WORD012.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD012_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD012.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD012_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD012.Reg, volatile.LoadUint32(&o.WORD012.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD012_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD012.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD012_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD012.Reg, volatile.LoadUint32(&o.WORD012.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD012_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD012.Reg) & 0xff000000) >> 24
}

// CAN.WORD112: Message Buffer 12 WORD1 Register
func (o *CAN_Type) SetWORD112_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD112.Reg, volatile.LoadUint32(&o.WORD112.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD112_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD112.Reg) & 0xff
}
func (o *CAN_Type) SetWORD112_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD112.Reg, volatile.LoadUint32(&o.WORD112.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD112_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD112.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD112_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD112.Reg, volatile.LoadUint32(&o.WORD112.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD112_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD112.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD112_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD112.Reg, volatile.LoadUint32(&o.WORD112.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD112_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD112.Reg) & 0xff000000) >> 24
}

// CAN.CS13: Message Buffer 13 CS Register
func (o *CAN_Type) SetCS13_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS13_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS13.Reg) & 0xffff
}
func (o *CAN_Type) SetCS13_DLC(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS13_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS13_RTR(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS13_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS13_IDE(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS13_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS13_SRR(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS13_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS13_CODE(value uint32) {
	volatile.StoreUint32(&o.CS13.Reg, volatile.LoadUint32(&o.CS13.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS13_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS13.Reg) & 0xf000000) >> 24
}

// CAN.ID13: Message Buffer 13 ID Register
func (o *CAN_Type) SetID13_EXT(value uint32) {
	volatile.StoreUint32(&o.ID13.Reg, volatile.LoadUint32(&o.ID13.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID13_EXT() uint32 {
	return volatile.LoadUint32(&o.ID13.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID13_STD(value uint32) {
	volatile.StoreUint32(&o.ID13.Reg, volatile.LoadUint32(&o.ID13.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID13_STD() uint32 {
	return (volatile.LoadUint32(&o.ID13.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID13_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID13.Reg, volatile.LoadUint32(&o.ID13.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID13_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID13.Reg) & 0xe0000000) >> 29
}

// CAN.WORD013: Message Buffer 13 WORD0 Register
func (o *CAN_Type) SetWORD013_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD013.Reg, volatile.LoadUint32(&o.WORD013.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD013_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD013.Reg) & 0xff
}
func (o *CAN_Type) SetWORD013_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD013.Reg, volatile.LoadUint32(&o.WORD013.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD013_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD013.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD013_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD013.Reg, volatile.LoadUint32(&o.WORD013.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD013_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD013.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD013_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD013.Reg, volatile.LoadUint32(&o.WORD013.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD013_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD013.Reg) & 0xff000000) >> 24
}

// CAN.WORD113: Message Buffer 13 WORD1 Register
func (o *CAN_Type) SetWORD113_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD113.Reg, volatile.LoadUint32(&o.WORD113.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD113_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD113.Reg) & 0xff
}
func (o *CAN_Type) SetWORD113_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD113.Reg, volatile.LoadUint32(&o.WORD113.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD113_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD113.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD113_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD113.Reg, volatile.LoadUint32(&o.WORD113.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD113_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD113.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD113_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD113.Reg, volatile.LoadUint32(&o.WORD113.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD113_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD113.Reg) & 0xff000000) >> 24
}

// CAN.CS14: Message Buffer 14 CS Register
func (o *CAN_Type) SetCS14_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS14_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS14.Reg) & 0xffff
}
func (o *CAN_Type) SetCS14_DLC(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS14_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS14_RTR(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS14_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS14_IDE(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS14_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS14_SRR(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS14_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS14_CODE(value uint32) {
	volatile.StoreUint32(&o.CS14.Reg, volatile.LoadUint32(&o.CS14.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS14_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS14.Reg) & 0xf000000) >> 24
}

// CAN.ID14: Message Buffer 14 ID Register
func (o *CAN_Type) SetID14_EXT(value uint32) {
	volatile.StoreUint32(&o.ID14.Reg, volatile.LoadUint32(&o.ID14.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID14_EXT() uint32 {
	return volatile.LoadUint32(&o.ID14.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID14_STD(value uint32) {
	volatile.StoreUint32(&o.ID14.Reg, volatile.LoadUint32(&o.ID14.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID14_STD() uint32 {
	return (volatile.LoadUint32(&o.ID14.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID14_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID14.Reg, volatile.LoadUint32(&o.ID14.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID14_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID14.Reg) & 0xe0000000) >> 29
}

// CAN.WORD014: Message Buffer 14 WORD0 Register
func (o *CAN_Type) SetWORD014_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD014.Reg, volatile.LoadUint32(&o.WORD014.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD014_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD014.Reg) & 0xff
}
func (o *CAN_Type) SetWORD014_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD014.Reg, volatile.LoadUint32(&o.WORD014.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD014_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD014.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD014_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD014.Reg, volatile.LoadUint32(&o.WORD014.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD014_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD014.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD014_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD014.Reg, volatile.LoadUint32(&o.WORD014.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD014_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD014.Reg) & 0xff000000) >> 24
}

// CAN.WORD114: Message Buffer 14 WORD1 Register
func (o *CAN_Type) SetWORD114_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD114.Reg, volatile.LoadUint32(&o.WORD114.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD114_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD114.Reg) & 0xff
}
func (o *CAN_Type) SetWORD114_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD114.Reg, volatile.LoadUint32(&o.WORD114.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD114_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD114.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD114_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD114.Reg, volatile.LoadUint32(&o.WORD114.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD114_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD114.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD114_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD114.Reg, volatile.LoadUint32(&o.WORD114.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD114_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD114.Reg) & 0xff000000) >> 24
}

// CAN.CS15: Message Buffer 15 CS Register
func (o *CAN_Type) SetCS15_TIME_STAMP(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetCS15_TIME_STAMP() uint32 {
	return volatile.LoadUint32(&o.CS15.Reg) & 0xffff
}
func (o *CAN_Type) SetCS15_DLC(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetCS15_DLC() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetCS15_RTR(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetCS15_RTR() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetCS15_IDE(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetCS15_IDE() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetCS15_SRR(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetCS15_SRR() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetCS15_CODE(value uint32) {
	volatile.StoreUint32(&o.CS15.Reg, volatile.LoadUint32(&o.CS15.Reg)&^(0xf000000)|value<<24)
}
func (o *CAN_Type) GetCS15_CODE() uint32 {
	return (volatile.LoadUint32(&o.CS15.Reg) & 0xf000000) >> 24
}

// CAN.ID15: Message Buffer 15 ID Register
func (o *CAN_Type) SetID15_EXT(value uint32) {
	volatile.StoreUint32(&o.ID15.Reg, volatile.LoadUint32(&o.ID15.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetID15_EXT() uint32 {
	return volatile.LoadUint32(&o.ID15.Reg) & 0x3ffff
}
func (o *CAN_Type) SetID15_STD(value uint32) {
	volatile.StoreUint32(&o.ID15.Reg, volatile.LoadUint32(&o.ID15.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetID15_STD() uint32 {
	return (volatile.LoadUint32(&o.ID15.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetID15_PRIO(value uint32) {
	volatile.StoreUint32(&o.ID15.Reg, volatile.LoadUint32(&o.ID15.Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN_Type) GetID15_PRIO() uint32 {
	return (volatile.LoadUint32(&o.ID15.Reg) & 0xe0000000) >> 29
}

// CAN.WORD015: Message Buffer 15 WORD0 Register
func (o *CAN_Type) SetWORD015_DATA_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.WORD015.Reg, volatile.LoadUint32(&o.WORD015.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD015_DATA_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.WORD015.Reg) & 0xff
}
func (o *CAN_Type) SetWORD015_DATA_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.WORD015.Reg, volatile.LoadUint32(&o.WORD015.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD015_DATA_BYTE_2() uint32 {
	return (volatile.LoadUint32(&o.WORD015.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD015_DATA_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.WORD015.Reg, volatile.LoadUint32(&o.WORD015.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD015_DATA_BYTE_1() uint32 {
	return (volatile.LoadUint32(&o.WORD015.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD015_DATA_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.WORD015.Reg, volatile.LoadUint32(&o.WORD015.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD015_DATA_BYTE_0() uint32 {
	return (volatile.LoadUint32(&o.WORD015.Reg) & 0xff000000) >> 24
}

// CAN.WORD115: Message Buffer 15 WORD1 Register
func (o *CAN_Type) SetWORD115_DATA_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.WORD115.Reg, volatile.LoadUint32(&o.WORD115.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetWORD115_DATA_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.WORD115.Reg) & 0xff
}
func (o *CAN_Type) SetWORD115_DATA_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.WORD115.Reg, volatile.LoadUint32(&o.WORD115.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWORD115_DATA_BYTE_6() uint32 {
	return (volatile.LoadUint32(&o.WORD115.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetWORD115_DATA_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.WORD115.Reg, volatile.LoadUint32(&o.WORD115.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetWORD115_DATA_BYTE_5() uint32 {
	return (volatile.LoadUint32(&o.WORD115.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetWORD115_DATA_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.WORD115.Reg, volatile.LoadUint32(&o.WORD115.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetWORD115_DATA_BYTE_4() uint32 {
	return (volatile.LoadUint32(&o.WORD115.Reg) & 0xff000000) >> 24
}

// CAN.RXIMR0: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR0_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR0_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR0.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR0_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR0_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR0_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR0_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR0_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR0_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR0_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR0_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR0_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR0_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR0_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR0_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR0_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR0_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR0_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR0_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR0_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR0_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR0_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR0_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR0_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR0_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR0_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR0_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR0_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR0_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR0_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR0_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR0_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR0_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR0_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR0_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR0_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR0_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR0_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR0_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR0_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR0_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR0_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR0_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR0_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR0_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR0_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR0_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR0_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR0_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR0_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR0_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR0_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR0_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR0_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR0_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR0_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR0_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR0_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR0_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR0_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR0_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR0_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR0_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR0_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR0.Reg, volatile.LoadUint32(&o.RXIMR0.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR0_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR0.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR1: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR1_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR1_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR1.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR1_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR1_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR1_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR1_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR1_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR1_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR1_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR1_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR1_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR1_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR1_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR1_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR1_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR1_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR1_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR1_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR1_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR1_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR1_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR1_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR1_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR1_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR1_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR1_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR1_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR1_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR1_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR1_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR1_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR1_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR1_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR1_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR1_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR1_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR1_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR1_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR1_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR1_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR1_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR1_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR1_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR1_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR1_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR1_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR1_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR1_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR1_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR1_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR1_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR1_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR1_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR1_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR1_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR1_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR1_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR1_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR1_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR1_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR1_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR1_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR1_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR1.Reg, volatile.LoadUint32(&o.RXIMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR1_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR1.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR2: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR2_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR2_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR2.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR2_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR2_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR2_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR2_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR2_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR2_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR2_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR2_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR2_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR2_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR2_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR2_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR2_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR2_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR2_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR2_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR2_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR2_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR2_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR2_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR2_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR2_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR2_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR2_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR2_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR2_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR2_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR2_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR2_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR2_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR2_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR2_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR2_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR2_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR2_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR2_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR2_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR2_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR2_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR2_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR2_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR2_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR2_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR2_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR2_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR2_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR2_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR2_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR2_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR2_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR2_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR2_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR2_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR2_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR2_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR2_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR2_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR2_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR2_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR2_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR2_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR2.Reg, volatile.LoadUint32(&o.RXIMR2.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR2_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR2.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR3: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR3_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR3_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR3.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR3_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR3_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR3_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR3_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR3_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR3_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR3_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR3_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR3_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR3_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR3_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR3_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR3_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR3_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR3_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR3_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR3_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR3_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR3_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR3_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR3_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR3_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR3_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR3_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR3_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR3_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR3_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR3_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR3_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR3_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR3_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR3_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR3_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR3_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR3_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR3_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR3_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR3_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR3_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR3_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR3_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR3_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR3_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR3_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR3_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR3_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR3_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR3_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR3_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR3_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR3_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR3_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR3_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR3_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR3_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR3_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR3_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR3_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR3_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR3_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR3_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR3.Reg, volatile.LoadUint32(&o.RXIMR3.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR3_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR3.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR4: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR4_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR4_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR4.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR4_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR4_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR4_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR4_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR4_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR4_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR4_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR4_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR4_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR4_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR4_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR4_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR4_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR4_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR4_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR4_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR4_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR4_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR4_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR4_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR4_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR4_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR4_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR4_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR4_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR4_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR4_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR4_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR4_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR4_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR4_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR4_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR4_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR4_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR4_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR4_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR4_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR4_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR4_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR4_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR4_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR4_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR4_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR4_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR4_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR4_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR4_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR4_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR4_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR4_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR4_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR4_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR4_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR4_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR4_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR4_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR4_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR4_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR4_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR4_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR4_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR4.Reg, volatile.LoadUint32(&o.RXIMR4.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR4_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR4.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR5: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR5_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR5_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR5.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR5_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR5_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR5_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR5_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR5_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR5_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR5_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR5_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR5_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR5_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR5_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR5_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR5_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR5_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR5_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR5_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR5_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR5_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR5_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR5_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR5_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR5_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR5_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR5_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR5_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR5_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR5_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR5_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR5_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR5_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR5_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR5_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR5_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR5_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR5_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR5_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR5_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR5_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR5_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR5_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR5_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR5_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR5_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR5_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR5_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR5_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR5_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR5_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR5_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR5_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR5_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR5_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR5_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR5_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR5_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR5_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR5_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR5_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR5_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR5_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR5_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR5.Reg, volatile.LoadUint32(&o.RXIMR5.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR5_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR5.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR6: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR6_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR6_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR6.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR6_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR6_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR6_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR6_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR6_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR6_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR6_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR6_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR6_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR6_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR6_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR6_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR6_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR6_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR6_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR6_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR6_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR6_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR6_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR6_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR6_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR6_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR6_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR6_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR6_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR6_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR6_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR6_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR6_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR6_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR6_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR6_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR6_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR6_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR6_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR6_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR6_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR6_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR6_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR6_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR6_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR6_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR6_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR6_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR6_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR6_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR6_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR6_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR6_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR6_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR6_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR6_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR6_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR6_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR6_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR6_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR6_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR6_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR6_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR6_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR6_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR6.Reg, volatile.LoadUint32(&o.RXIMR6.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR6_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR6.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR7: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR7_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR7_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR7.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR7_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR7_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR7_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR7_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR7_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR7_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR7_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR7_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR7_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR7_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR7_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR7_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR7_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR7_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR7_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR7_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR7_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR7_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR7_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR7_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR7_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR7_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR7_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR7_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR7_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR7_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR7_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR7_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR7_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR7_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR7_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR7_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR7_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR7_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR7_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR7_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR7_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR7_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR7_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR7_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR7_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR7_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR7_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR7_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR7_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR7_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR7_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR7_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR7_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR7_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR7_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR7_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR7_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR7_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR7_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR7_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR7_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR7_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR7_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR7_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR7_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR7.Reg, volatile.LoadUint32(&o.RXIMR7.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR7_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR7.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR8: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR8_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR8_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR8.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR8_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR8_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR8_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR8_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR8_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR8_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR8_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR8_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR8_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR8_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR8_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR8_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR8_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR8_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR8_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR8_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR8_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR8_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR8_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR8_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR8_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR8_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR8_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR8_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR8_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR8_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR8_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR8_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR8_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR8_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR8_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR8_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR8_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR8_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR8_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR8_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR8_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR8_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR8_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR8_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR8_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR8_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR8_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR8_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR8_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR8_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR8_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR8_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR8_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR8_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR8_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR8_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR8_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR8_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR8_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR8_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR8_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR8_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR8_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR8_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR8_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR8.Reg, volatile.LoadUint32(&o.RXIMR8.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR8_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR8.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR9: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR9_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR9_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR9.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR9_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR9_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR9_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR9_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR9_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR9_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR9_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR9_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR9_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR9_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR9_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR9_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR9_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR9_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR9_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR9_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR9_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR9_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR9_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR9_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR9_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR9_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR9_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR9_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR9_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR9_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR9_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR9_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR9_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR9_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR9_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR9_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR9_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR9_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR9_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR9_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR9_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR9_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR9_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR9_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR9_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR9_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR9_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR9_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR9_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR9_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR9_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR9_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR9_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR9_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR9_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR9_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR9_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR9_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR9_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR9_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR9_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR9_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR9_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR9_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR9_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR9.Reg, volatile.LoadUint32(&o.RXIMR9.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR9_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR9.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR10: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR10_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR10_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR10.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR10_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR10_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR10_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR10_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR10_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR10_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR10_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR10_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR10_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR10_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR10_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR10_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR10_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR10_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR10_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR10_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR10_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR10_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR10_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR10_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR10_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR10_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR10_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR10_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR10_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR10_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR10_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR10_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR10_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR10_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR10_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR10_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR10_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR10_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR10_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR10_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR10_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR10_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR10_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR10_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR10_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR10_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR10_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR10_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR10_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR10_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR10_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR10_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR10_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR10_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR10_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR10_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR10_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR10_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR10_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR10_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR10_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR10_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR10_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR10_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR10_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR10.Reg, volatile.LoadUint32(&o.RXIMR10.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR10_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR10.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR11: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR11_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR11_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR11.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR11_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR11_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR11_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR11_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR11_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR11_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR11_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR11_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR11_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR11_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR11_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR11_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR11_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR11_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR11_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR11_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR11_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR11_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR11_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR11_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR11_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR11_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR11_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR11_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR11_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR11_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR11_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR11_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR11_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR11_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR11_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR11_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR11_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR11_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR11_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR11_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR11_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR11_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR11_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR11_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR11_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR11_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR11_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR11_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR11_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR11_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR11_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR11_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR11_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR11_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR11_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR11_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR11_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR11_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR11_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR11_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR11_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR11_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR11_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR11_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR11_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR11.Reg, volatile.LoadUint32(&o.RXIMR11.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR11_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR11.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR12: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR12_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR12_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR12.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR12_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR12_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR12_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR12_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR12_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR12_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR12_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR12_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR12_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR12_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR12_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR12_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR12_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR12_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR12_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR12_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR12_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR12_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR12_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR12_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR12_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR12_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR12_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR12_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR12_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR12_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR12_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR12_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR12_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR12_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR12_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR12_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR12_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR12_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR12_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR12_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR12_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR12_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR12_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR12_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR12_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR12_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR12_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR12_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR12_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR12_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR12_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR12_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR12_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR12_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR12_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR12_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR12_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR12_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR12_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR12_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR12_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR12_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR12_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR12_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR12_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR12.Reg, volatile.LoadUint32(&o.RXIMR12.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR12_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR12.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR13: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR13_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR13_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR13.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR13_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR13_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR13_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR13_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR13_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR13_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR13_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR13_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR13_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR13_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR13_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR13_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR13_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR13_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR13_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR13_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR13_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR13_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR13_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR13_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR13_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR13_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR13_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR13_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR13_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR13_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR13_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR13_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR13_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR13_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR13_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR13_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR13_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR13_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR13_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR13_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR13_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR13_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR13_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR13_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR13_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR13_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR13_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR13_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR13_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR13_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR13_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR13_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR13_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR13_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR13_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR13_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR13_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR13_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR13_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR13_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR13_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR13_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR13_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR13_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR13_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR13.Reg, volatile.LoadUint32(&o.RXIMR13.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR13_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR13.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR14: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR14_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR14_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR14.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR14_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR14_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR14_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR14_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR14_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR14_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR14_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR14_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR14_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR14_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR14_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR14_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR14_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR14_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR14_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR14_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR14_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR14_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR14_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR14_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR14_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR14_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR14_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR14_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR14_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR14_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR14_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR14_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR14_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR14_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR14_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR14_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR14_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR14_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR14_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR14_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR14_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR14_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR14_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR14_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR14_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR14_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR14_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR14_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR14_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR14_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR14_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR14_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR14_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR14_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR14_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR14_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR14_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR14_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR14_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR14_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR14_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR14_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR14_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR14_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR14_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR14.Reg, volatile.LoadUint32(&o.RXIMR14.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR14_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR14.Reg) & 0x80000000) >> 31
}

// CAN.RXIMR15: Rx Individual Mask Registers
func (o *CAN_Type) SetRXIMR15_MI0(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetRXIMR15_MI0() uint32 {
	return volatile.LoadUint32(&o.RXIMR15.Reg) & 0x1
}
func (o *CAN_Type) SetRXIMR15_MI1(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetRXIMR15_MI1() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetRXIMR15_MI2(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetRXIMR15_MI2() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetRXIMR15_MI3(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRXIMR15_MI3() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRXIMR15_MI4(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRXIMR15_MI4() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRXIMR15_MI5(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRXIMR15_MI5() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRXIMR15_MI6(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetRXIMR15_MI6() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetRXIMR15_MI7(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetRXIMR15_MI7() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetRXIMR15_MI8(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetRXIMR15_MI8() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetRXIMR15_MI9(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetRXIMR15_MI9() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetRXIMR15_MI10(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRXIMR15_MI10() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRXIMR15_MI11(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetRXIMR15_MI11() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetRXIMR15_MI12(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetRXIMR15_MI12() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetRXIMR15_MI13(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetRXIMR15_MI13() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetRXIMR15_MI14(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetRXIMR15_MI14() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetRXIMR15_MI15(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetRXIMR15_MI15() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetRXIMR15_MI16(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetRXIMR15_MI16() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetRXIMR15_MI17(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetRXIMR15_MI17() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetRXIMR15_MI18(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetRXIMR15_MI18() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetRXIMR15_MI19(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetRXIMR15_MI19() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetRXIMR15_MI20(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetRXIMR15_MI20() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetRXIMR15_MI21(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetRXIMR15_MI21() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetRXIMR15_MI22(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetRXIMR15_MI22() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetRXIMR15_MI23(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetRXIMR15_MI23() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetRXIMR15_MI24(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetRXIMR15_MI24() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetRXIMR15_MI25(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetRXIMR15_MI25() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetRXIMR15_MI26(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetRXIMR15_MI26() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetRXIMR15_MI27(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetRXIMR15_MI27() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetRXIMR15_MI28(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetRXIMR15_MI28() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetRXIMR15_MI29(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetRXIMR15_MI29() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetRXIMR15_MI30(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRXIMR15_MI30() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRXIMR15_MI31(value uint32) {
	volatile.StoreUint32(&o.RXIMR15.Reg, volatile.LoadUint32(&o.RXIMR15.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRXIMR15_MI31() uint32 {
	return (volatile.LoadUint32(&o.RXIMR15.Reg) & 0x80000000) >> 31
}

// Serial Peripheral Interface
type SPI_Type struct {
	MCR   volatile.Register32 // 0x0
	_     [4]byte
	TCR   volatile.Register32 // 0x8
	CTAR0 volatile.Register32 // 0xC
	CTAR1 volatile.Register32 // 0x10
	_     [24]byte
	SR    volatile.Register32 // 0x2C
	RSER  volatile.Register32 // 0x30
	PUSHR volatile.Register32 // 0x34
	POPR  volatile.Register32 // 0x38
	TXFR0 volatile.Register32 // 0x3C
	TXFR1 volatile.Register32 // 0x40
	TXFR2 volatile.Register32 // 0x44
	TXFR3 volatile.Register32 // 0x48
	_     [48]byte
	RXFR0 volatile.Register32 // 0x7C
	RXFR1 volatile.Register32 // 0x80
	RXFR2 volatile.Register32 // 0x84
	RXFR3 volatile.Register32 // 0x88
}

// SPI.MCR: Module Configuration Register
func (o *SPI_Type) SetMCR_HALT(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetMCR_HALT() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *SPI_Type) SetMCR_SMPL_PT(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x300)|value<<8)
}
func (o *SPI_Type) GetMCR_SMPL_PT() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x300) >> 8
}
func (o *SPI_Type) SetMCR_CLR_RXF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetMCR_CLR_RXF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetMCR_CLR_TXF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetMCR_CLR_TXF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetMCR_DIS_RXF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetMCR_DIS_RXF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetMCR_DIS_TXF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetMCR_DIS_TXF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetMCR_MDIS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetMCR_MDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetMCR_DOZE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetMCR_DOZE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetMCR_PCSIS0(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetMCR_PCSIS0() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetMCR_PCSIS1(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetMCR_PCSIS1() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetMCR_PCSIS2(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetMCR_PCSIS2() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetMCR_PCSIS3(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetMCR_PCSIS3() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetMCR_PCSIS4(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetMCR_PCSIS4() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetMCR_PCSIS5(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetMCR_PCSIS5() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetMCR_ROOE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetMCR_ROOE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetMCR_PCSSE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetMCR_PCSSE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetMCR_MTFE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetMCR_MTFE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetMCR_FRZ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI_Type) GetMCR_FRZ() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8000000) >> 27
}
func (o *SPI_Type) SetMCR_DCONF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x30000000)|value<<28)
}
func (o *SPI_Type) GetMCR_DCONF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x30000000) >> 28
}
func (o *SPI_Type) SetMCR_CONT_SCKE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetMCR_CONT_SCKE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetMCR_MSTR(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetMCR_MSTR() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000000) >> 31
}

// SPI.TCR: Transfer Count Register
func (o *SPI_Type) SetTCR_SPI_TCNT(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTCR_SPI_TCNT() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xffff0000) >> 16
}

// SPI.CTAR0: Clock and Transfer Attributes Register (In Master Mode)
func (o *SPI_Type) SetCTAR0_BR(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetCTAR0_BR() uint32 {
	return volatile.LoadUint32(&o.CTAR0.Reg) & 0xf
}
func (o *SPI_Type) SetCTAR0_DT(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetCTAR0_DT() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetCTAR0_ASC(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetCTAR0_ASC() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetCTAR0_CSSCK(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xf000)|value<<12)
}
func (o *SPI_Type) GetCTAR0_CSSCK() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xf000) >> 12
}
func (o *SPI_Type) SetCTAR0_PBR(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x30000)|value<<16)
}
func (o *SPI_Type) GetCTAR0_PBR() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x30000) >> 16
}
func (o *SPI_Type) SetCTAR0_PDT(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xc0000)|value<<18)
}
func (o *SPI_Type) GetCTAR0_PDT() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xc0000) >> 18
}
func (o *SPI_Type) SetCTAR0_PASC(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x300000)|value<<20)
}
func (o *SPI_Type) GetCTAR0_PASC() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x300000) >> 20
}
func (o *SPI_Type) SetCTAR0_PCSSCK(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0xc00000)|value<<22)
}
func (o *SPI_Type) GetCTAR0_PCSSCK() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0xc00000) >> 22
}
func (o *SPI_Type) SetCTAR0_LSBFE(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetCTAR0_LSBFE() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetCTAR0_CPHA(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetCTAR0_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetCTAR0_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetCTAR0_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetCTAR0_FMSZ(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x78000000)|value<<27)
}
func (o *SPI_Type) GetCTAR0_FMSZ() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x78000000) >> 27
}
func (o *SPI_Type) SetCTAR0_DBR(value uint32) {
	volatile.StoreUint32(&o.CTAR0.Reg, volatile.LoadUint32(&o.CTAR0.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetCTAR0_DBR() uint32 {
	return (volatile.LoadUint32(&o.CTAR0.Reg) & 0x80000000) >> 31
}

// SPI.CTAR1: Clock and Transfer Attributes Register (In Master Mode)
func (o *SPI_Type) SetCTAR1_BR(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetCTAR1_BR() uint32 {
	return volatile.LoadUint32(&o.CTAR1.Reg) & 0xf
}
func (o *SPI_Type) SetCTAR1_DT(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetCTAR1_DT() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetCTAR1_ASC(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetCTAR1_ASC() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetCTAR1_CSSCK(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xf000)|value<<12)
}
func (o *SPI_Type) GetCTAR1_CSSCK() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xf000) >> 12
}
func (o *SPI_Type) SetCTAR1_PBR(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x30000)|value<<16)
}
func (o *SPI_Type) GetCTAR1_PBR() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x30000) >> 16
}
func (o *SPI_Type) SetCTAR1_PDT(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xc0000)|value<<18)
}
func (o *SPI_Type) GetCTAR1_PDT() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xc0000) >> 18
}
func (o *SPI_Type) SetCTAR1_PASC(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x300000)|value<<20)
}
func (o *SPI_Type) GetCTAR1_PASC() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x300000) >> 20
}
func (o *SPI_Type) SetCTAR1_PCSSCK(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0xc00000)|value<<22)
}
func (o *SPI_Type) GetCTAR1_PCSSCK() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0xc00000) >> 22
}
func (o *SPI_Type) SetCTAR1_LSBFE(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetCTAR1_LSBFE() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetCTAR1_CPHA(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetCTAR1_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetCTAR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetCTAR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetCTAR1_FMSZ(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x78000000)|value<<27)
}
func (o *SPI_Type) GetCTAR1_FMSZ() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x78000000) >> 27
}
func (o *SPI_Type) SetCTAR1_DBR(value uint32) {
	volatile.StoreUint32(&o.CTAR1.Reg, volatile.LoadUint32(&o.CTAR1.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetCTAR1_DBR() uint32 {
	return (volatile.LoadUint32(&o.CTAR1.Reg) & 0x80000000) >> 31
}

// SPI.SR: Status Register
func (o *SPI_Type) SetSR_POPNXTPTR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetSR_POPNXTPTR() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0xf
}
func (o *SPI_Type) SetSR_RXCTR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetSR_RXCTR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetSR_TXNXTPTR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetSR_TXNXTPTR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetSR_TXCTR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf000)|value<<12)
}
func (o *SPI_Type) GetSR_TXCTR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf000) >> 12
}
func (o *SPI_Type) SetSR_RFDF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetSR_RFDF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetSR_RFOF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetSR_RFOF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetSR_TFFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetSR_TFFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetSR_TFUF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI_Type) GetSR_TFUF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}
func (o *SPI_Type) SetSR_EOQF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI_Type) GetSR_EOQF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000000) >> 28
}
func (o *SPI_Type) SetSR_TXRXS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetSR_TXRXS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetSR_TCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetSR_TCF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// SPI.RSER: DMA/Interrupt Request Select and Enable Register
func (o *SPI_Type) SetRSER_RFDF_DIRS(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetRSER_RFDF_DIRS() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetRSER_RFDF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetRSER_RFDF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetRSER_RFOF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetRSER_RFOF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetRSER_TFFF_DIRS(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetRSER_TFFF_DIRS() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetRSER_TFFF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetRSER_TFFF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetRSER_TFUF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI_Type) GetRSER_TFUF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x8000000) >> 27
}
func (o *SPI_Type) SetRSER_EOQF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI_Type) GetRSER_EOQF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x10000000) >> 28
}
func (o *SPI_Type) SetRSER_TCF_RE(value uint32) {
	volatile.StoreUint32(&o.RSER.Reg, volatile.LoadUint32(&o.RSER.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetRSER_TCF_RE() uint32 {
	return (volatile.LoadUint32(&o.RSER.Reg) & 0x80000000) >> 31
}

// SPI.PUSHR: PUSH TX FIFO Register In Master Mode
func (o *SPI_Type) SetPUSHR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetPUSHR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.PUSHR.Reg) & 0xffff
}
func (o *SPI_Type) SetPUSHR_PCS0(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetPUSHR_PCS0() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetPUSHR_PCS1(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetPUSHR_PCS1() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetPUSHR_PCS2(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetPUSHR_PCS2() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetPUSHR_PCS3(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetPUSHR_PCS3() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetPUSHR_PCS4(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetPUSHR_PCS4() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetPUSHR_PCS5(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetPUSHR_PCS5() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetPUSHR_CTCNT(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetPUSHR_CTCNT() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetPUSHR_EOQ(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI_Type) GetPUSHR_EOQ() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x8000000) >> 27
}
func (o *SPI_Type) SetPUSHR_CTAS(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x70000000)|value<<28)
}
func (o *SPI_Type) GetPUSHR_CTAS() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x70000000) >> 28
}
func (o *SPI_Type) SetPUSHR_CONT(value uint32) {
	volatile.StoreUint32(&o.PUSHR.Reg, volatile.LoadUint32(&o.PUSHR.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetPUSHR_CONT() uint32 {
	return (volatile.LoadUint32(&o.PUSHR.Reg) & 0x80000000) >> 31
}

// SPI.POPR: POP RX FIFO Register
func (o *SPI_Type) SetPOPR(value uint32) {
	volatile.StoreUint32(&o.POPR.Reg, value)
}
func (o *SPI_Type) GetPOPR() uint32 {
	return volatile.LoadUint32(&o.POPR.Reg)
}

// SPI.TXFR0: Transmit FIFO Registers
func (o *SPI_Type) SetTXFR0_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR0.Reg, volatile.LoadUint32(&o.TXFR0.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXFR0_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXFR0.Reg) & 0xffff
}
func (o *SPI_Type) SetTXFR0_TXCMD_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR0.Reg, volatile.LoadUint32(&o.TXFR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTXFR0_TXCMD_TXDATA() uint32 {
	return (volatile.LoadUint32(&o.TXFR0.Reg) & 0xffff0000) >> 16
}

// SPI.TXFR1: Transmit FIFO Registers
func (o *SPI_Type) SetTXFR1_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR1.Reg, volatile.LoadUint32(&o.TXFR1.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXFR1_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXFR1.Reg) & 0xffff
}
func (o *SPI_Type) SetTXFR1_TXCMD_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR1.Reg, volatile.LoadUint32(&o.TXFR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTXFR1_TXCMD_TXDATA() uint32 {
	return (volatile.LoadUint32(&o.TXFR1.Reg) & 0xffff0000) >> 16
}

// SPI.TXFR2: Transmit FIFO Registers
func (o *SPI_Type) SetTXFR2_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR2.Reg, volatile.LoadUint32(&o.TXFR2.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXFR2_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXFR2.Reg) & 0xffff
}
func (o *SPI_Type) SetTXFR2_TXCMD_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR2.Reg, volatile.LoadUint32(&o.TXFR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTXFR2_TXCMD_TXDATA() uint32 {
	return (volatile.LoadUint32(&o.TXFR2.Reg) & 0xffff0000) >> 16
}

// SPI.TXFR3: Transmit FIFO Registers
func (o *SPI_Type) SetTXFR3_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR3.Reg, volatile.LoadUint32(&o.TXFR3.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXFR3_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXFR3.Reg) & 0xffff
}
func (o *SPI_Type) SetTXFR3_TXCMD_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXFR3.Reg, volatile.LoadUint32(&o.TXFR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetTXFR3_TXCMD_TXDATA() uint32 {
	return (volatile.LoadUint32(&o.TXFR3.Reg) & 0xffff0000) >> 16
}

// SPI.RXFR0: Receive FIFO Registers
func (o *SPI_Type) SetRXFR0(value uint32) {
	volatile.StoreUint32(&o.RXFR0.Reg, value)
}
func (o *SPI_Type) GetRXFR0() uint32 {
	return volatile.LoadUint32(&o.RXFR0.Reg)
}

// SPI.RXFR1: Receive FIFO Registers
func (o *SPI_Type) SetRXFR1(value uint32) {
	volatile.StoreUint32(&o.RXFR1.Reg, value)
}
func (o *SPI_Type) GetRXFR1() uint32 {
	return volatile.LoadUint32(&o.RXFR1.Reg)
}

// SPI.RXFR2: Receive FIFO Registers
func (o *SPI_Type) SetRXFR2(value uint32) {
	volatile.StoreUint32(&o.RXFR2.Reg, value)
}
func (o *SPI_Type) GetRXFR2() uint32 {
	return volatile.LoadUint32(&o.RXFR2.Reg)
}

// SPI.RXFR3: Receive FIFO Registers
func (o *SPI_Type) SetRXFR3(value uint32) {
	volatile.StoreUint32(&o.RXFR3.Reg, value)
}
func (o *SPI_Type) GetRXFR3() uint32 {
	return volatile.LoadUint32(&o.RXFR3.Reg)
}

// Inter-IC Sound / Synchronous Audio Interface
type I2S0_Type struct {
	TCSR volatile.Register32 // 0x0
	TCR1 volatile.Register32 // 0x4
	TCR2 volatile.Register32 // 0x8
	TCR3 volatile.Register32 // 0xC
	TCR4 volatile.Register32 // 0x10
	TCR5 volatile.Register32 // 0x14
	_    [8]byte
	TDR0 volatile.Register32 // 0x20
	TDR1 volatile.Register32 // 0x24
	_    [24]byte
	TFR0 volatile.Register32 // 0x40
	TFR1 volatile.Register32 // 0x44
	_    [24]byte
	TMR  volatile.Register32 // 0x60
	_    [28]byte
	RCSR volatile.Register32 // 0x80
	RCR1 volatile.Register32 // 0x84
	RCR2 volatile.Register32 // 0x88
	RCR3 volatile.Register32 // 0x8C
	RCR4 volatile.Register32 // 0x90
	RCR5 volatile.Register32 // 0x94
	_    [8]byte
	RDR0 volatile.Register32 // 0xA0
	RDR1 volatile.Register32 // 0xA4
	_    [24]byte
	RFR0 volatile.Register32 // 0xC0
	RFR1 volatile.Register32 // 0xC4
	_    [24]byte
	RMR  volatile.Register32 // 0xE0
	_    [28]byte
	MCR  volatile.Register32 // 0x100
	MDR  volatile.Register32 // 0x104
}

// I2S0.TCSR: SAI Transmit Control Register
func (o *I2S0_Type) SetTCSR_FRDE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetTCSR_FRDE() uint32 {
	return volatile.LoadUint32(&o.TCSR.Reg) & 0x1
}
func (o *I2S0_Type) SetTCSR_FWDE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetTCSR_FWDE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetTCSR_FRIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x100)|value<<8)
}
func (o *I2S0_Type) GetTCSR_FRIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x100) >> 8
}
func (o *I2S0_Type) SetTCSR_FWIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x200)|value<<9)
}
func (o *I2S0_Type) GetTCSR_FWIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x200) >> 9
}
func (o *I2S0_Type) SetTCSR_FEIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x400)|value<<10)
}
func (o *I2S0_Type) GetTCSR_FEIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x400) >> 10
}
func (o *I2S0_Type) SetTCSR_SEIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x800)|value<<11)
}
func (o *I2S0_Type) GetTCSR_SEIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x800) >> 11
}
func (o *I2S0_Type) SetTCSR_WSIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S0_Type) GetTCSR_WSIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x1000) >> 12
}
func (o *I2S0_Type) SetTCSR_FRF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetTCSR_FRF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetTCSR_FWF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetTCSR_FWF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetTCSR_FEF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S0_Type) GetTCSR_FEF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x40000) >> 18
}
func (o *I2S0_Type) SetTCSR_SEF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S0_Type) GetTCSR_SEF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x80000) >> 19
}
func (o *I2S0_Type) SetTCSR_WSF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S0_Type) GetTCSR_WSF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x100000) >> 20
}
func (o *I2S0_Type) SetTCSR_SR(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetTCSR_SR() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetTCSR_FR(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetTCSR_FR() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetTCSR_BCE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetTCSR_BCE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetTCSR_DBGE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetTCSR_DBGE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetTCSR_STOPE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetTCSR_STOPE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetTCSR_TE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetTCSR_TE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x80000000) >> 31
}

// I2S0.TCR1: SAI Transmit Configuration 1 Register
func (o *I2S0_Type) SetTCR1_TFW(value uint32) {
	volatile.StoreUint32(&o.TCR1.Reg, volatile.LoadUint32(&o.TCR1.Reg)&^(0x7)|value)
}
func (o *I2S0_Type) GetTCR1_TFW() uint32 {
	return volatile.LoadUint32(&o.TCR1.Reg) & 0x7
}

// I2S0.TCR2: SAI Transmit Configuration 2 Register
func (o *I2S0_Type) SetTCR2_DIV(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0xff)|value)
}
func (o *I2S0_Type) GetTCR2_DIV() uint32 {
	return volatile.LoadUint32(&o.TCR2.Reg) & 0xff
}
func (o *I2S0_Type) SetTCR2_BCD(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetTCR2_BCD() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetTCR2_BCP(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetTCR2_BCP() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetTCR2_MSEL(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S0_Type) GetTCR2_MSEL() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0xc000000) >> 26
}
func (o *I2S0_Type) SetTCR2_BCI(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetTCR2_BCI() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetTCR2_BCS(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetTCR2_BCS() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetTCR2_SYNC(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *I2S0_Type) GetTCR2_SYNC() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0xc0000000) >> 30
}

// I2S0.TCR3: SAI Transmit Configuration 3 Register
func (o *I2S0_Type) SetTCR3_WDFL(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x1f)|value)
}
func (o *I2S0_Type) GetTCR3_WDFL() uint32 {
	return volatile.LoadUint32(&o.TCR3.Reg) & 0x1f
}
func (o *I2S0_Type) SetTCR3_TCE0(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetTCR3_TCE0() uint32 {
	return (volatile.LoadUint32(&o.TCR3.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetTCR3_TCE1(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetTCR3_TCE1() uint32 {
	return (volatile.LoadUint32(&o.TCR3.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetTCR3_CFR0(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetTCR3_CFR0() uint32 {
	return (volatile.LoadUint32(&o.TCR3.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetTCR3_CFR1(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetTCR3_CFR1() uint32 {
	return (volatile.LoadUint32(&o.TCR3.Reg) & 0x2000000) >> 25
}

// I2S0.TCR4: SAI Transmit Configuration 4 Register
func (o *I2S0_Type) SetTCR4_FSD(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetTCR4_FSD() uint32 {
	return volatile.LoadUint32(&o.TCR4.Reg) & 0x1
}
func (o *I2S0_Type) SetTCR4_FSP(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetTCR4_FSP() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetTCR4_ONDEM(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x4)|value<<2)
}
func (o *I2S0_Type) GetTCR4_ONDEM() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x4) >> 2
}
func (o *I2S0_Type) SetTCR4_FSE(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x8)|value<<3)
}
func (o *I2S0_Type) GetTCR4_FSE() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x8) >> 3
}
func (o *I2S0_Type) SetTCR4_MF(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x10)|value<<4)
}
func (o *I2S0_Type) GetTCR4_MF() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x10) >> 4
}
func (o *I2S0_Type) SetTCR4_SYWD(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S0_Type) GetTCR4_SYWD() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x1f00) >> 8
}
func (o *I2S0_Type) SetTCR4_FRSZ(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S0_Type) GetTCR4_FRSZ() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x1f0000) >> 16
}
func (o *I2S0_Type) SetTCR4_FPACK(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S0_Type) GetTCR4_FPACK() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x3000000) >> 24
}
func (o *I2S0_Type) SetTCR4_FCOMB(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S0_Type) GetTCR4_FCOMB() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0xc000000) >> 26
}
func (o *I2S0_Type) SetTCR4_FCONT(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetTCR4_FCONT() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x10000000) >> 28
}

// I2S0.TCR5: SAI Transmit Configuration 5 Register
func (o *I2S0_Type) SetTCR5_FBT(value uint32) {
	volatile.StoreUint32(&o.TCR5.Reg, volatile.LoadUint32(&o.TCR5.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S0_Type) GetTCR5_FBT() uint32 {
	return (volatile.LoadUint32(&o.TCR5.Reg) & 0x1f00) >> 8
}
func (o *I2S0_Type) SetTCR5_W0W(value uint32) {
	volatile.StoreUint32(&o.TCR5.Reg, volatile.LoadUint32(&o.TCR5.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S0_Type) GetTCR5_W0W() uint32 {
	return (volatile.LoadUint32(&o.TCR5.Reg) & 0x1f0000) >> 16
}
func (o *I2S0_Type) SetTCR5_WNW(value uint32) {
	volatile.StoreUint32(&o.TCR5.Reg, volatile.LoadUint32(&o.TCR5.Reg)&^(0x1f000000)|value<<24)
}
func (o *I2S0_Type) GetTCR5_WNW() uint32 {
	return (volatile.LoadUint32(&o.TCR5.Reg) & 0x1f000000) >> 24
}

// I2S0.TDR0: SAI Transmit Data Register
func (o *I2S0_Type) SetTDR0(value uint32) {
	volatile.StoreUint32(&o.TDR0.Reg, value)
}
func (o *I2S0_Type) GetTDR0() uint32 {
	return volatile.LoadUint32(&o.TDR0.Reg)
}

// I2S0.TDR1: SAI Transmit Data Register
func (o *I2S0_Type) SetTDR1(value uint32) {
	volatile.StoreUint32(&o.TDR1.Reg, value)
}
func (o *I2S0_Type) GetTDR1() uint32 {
	return volatile.LoadUint32(&o.TDR1.Reg)
}

// I2S0.TFR0: SAI Transmit FIFO Register
func (o *I2S0_Type) SetTFR0_RFP(value uint32) {
	volatile.StoreUint32(&o.TFR0.Reg, volatile.LoadUint32(&o.TFR0.Reg)&^(0xf)|value)
}
func (o *I2S0_Type) GetTFR0_RFP() uint32 {
	return volatile.LoadUint32(&o.TFR0.Reg) & 0xf
}
func (o *I2S0_Type) SetTFR0_WFP(value uint32) {
	volatile.StoreUint32(&o.TFR0.Reg, volatile.LoadUint32(&o.TFR0.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S0_Type) GetTFR0_WFP() uint32 {
	return (volatile.LoadUint32(&o.TFR0.Reg) & 0xf0000) >> 16
}
func (o *I2S0_Type) SetTFR0_WCP(value uint32) {
	volatile.StoreUint32(&o.TFR0.Reg, volatile.LoadUint32(&o.TFR0.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetTFR0_WCP() uint32 {
	return (volatile.LoadUint32(&o.TFR0.Reg) & 0x80000000) >> 31
}

// I2S0.TFR1: SAI Transmit FIFO Register
func (o *I2S0_Type) SetTFR1_RFP(value uint32) {
	volatile.StoreUint32(&o.TFR1.Reg, volatile.LoadUint32(&o.TFR1.Reg)&^(0xf)|value)
}
func (o *I2S0_Type) GetTFR1_RFP() uint32 {
	return volatile.LoadUint32(&o.TFR1.Reg) & 0xf
}
func (o *I2S0_Type) SetTFR1_WFP(value uint32) {
	volatile.StoreUint32(&o.TFR1.Reg, volatile.LoadUint32(&o.TFR1.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S0_Type) GetTFR1_WFP() uint32 {
	return (volatile.LoadUint32(&o.TFR1.Reg) & 0xf0000) >> 16
}
func (o *I2S0_Type) SetTFR1_WCP(value uint32) {
	volatile.StoreUint32(&o.TFR1.Reg, volatile.LoadUint32(&o.TFR1.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetTFR1_WCP() uint32 {
	return (volatile.LoadUint32(&o.TFR1.Reg) & 0x80000000) >> 31
}

// I2S0.TMR: SAI Transmit Mask Register
func (o *I2S0_Type) SetTMR_TWM0(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetTMR_TWM0() uint32 {
	return volatile.LoadUint32(&o.TMR.Reg) & 0x1
}
func (o *I2S0_Type) SetTMR_TWM1(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetTMR_TWM1() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetTMR_TWM2(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x4)|value<<2)
}
func (o *I2S0_Type) GetTMR_TWM2() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x4) >> 2
}
func (o *I2S0_Type) SetTMR_TWM3(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x8)|value<<3)
}
func (o *I2S0_Type) GetTMR_TWM3() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x8) >> 3
}
func (o *I2S0_Type) SetTMR_TWM4(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x10)|value<<4)
}
func (o *I2S0_Type) GetTMR_TWM4() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x10) >> 4
}
func (o *I2S0_Type) SetTMR_TWM5(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x20)|value<<5)
}
func (o *I2S0_Type) GetTMR_TWM5() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x20) >> 5
}
func (o *I2S0_Type) SetTMR_TWM6(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x40)|value<<6)
}
func (o *I2S0_Type) GetTMR_TWM6() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x40) >> 6
}
func (o *I2S0_Type) SetTMR_TWM7(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x80)|value<<7)
}
func (o *I2S0_Type) GetTMR_TWM7() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x80) >> 7
}
func (o *I2S0_Type) SetTMR_TWM8(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x100)|value<<8)
}
func (o *I2S0_Type) GetTMR_TWM8() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x100) >> 8
}
func (o *I2S0_Type) SetTMR_TWM9(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x200)|value<<9)
}
func (o *I2S0_Type) GetTMR_TWM9() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x200) >> 9
}
func (o *I2S0_Type) SetTMR_TWM10(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x400)|value<<10)
}
func (o *I2S0_Type) GetTMR_TWM10() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x400) >> 10
}
func (o *I2S0_Type) SetTMR_TWM11(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x800)|value<<11)
}
func (o *I2S0_Type) GetTMR_TWM11() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x800) >> 11
}
func (o *I2S0_Type) SetTMR_TWM12(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S0_Type) GetTMR_TWM12() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x1000) >> 12
}
func (o *I2S0_Type) SetTMR_TWM13(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x2000)|value<<13)
}
func (o *I2S0_Type) GetTMR_TWM13() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x2000) >> 13
}
func (o *I2S0_Type) SetTMR_TWM14(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x4000)|value<<14)
}
func (o *I2S0_Type) GetTMR_TWM14() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x4000) >> 14
}
func (o *I2S0_Type) SetTMR_TWM15(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x8000)|value<<15)
}
func (o *I2S0_Type) GetTMR_TWM15() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x8000) >> 15
}
func (o *I2S0_Type) SetTMR_TWM16(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetTMR_TWM16() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetTMR_TWM17(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetTMR_TWM17() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetTMR_TWM18(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S0_Type) GetTMR_TWM18() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x40000) >> 18
}
func (o *I2S0_Type) SetTMR_TWM19(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S0_Type) GetTMR_TWM19() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x80000) >> 19
}
func (o *I2S0_Type) SetTMR_TWM20(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S0_Type) GetTMR_TWM20() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x100000) >> 20
}
func (o *I2S0_Type) SetTMR_TWM21(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x200000)|value<<21)
}
func (o *I2S0_Type) GetTMR_TWM21() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x200000) >> 21
}
func (o *I2S0_Type) SetTMR_TWM22(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x400000)|value<<22)
}
func (o *I2S0_Type) GetTMR_TWM22() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x400000) >> 22
}
func (o *I2S0_Type) SetTMR_TWM23(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x800000)|value<<23)
}
func (o *I2S0_Type) GetTMR_TWM23() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x800000) >> 23
}
func (o *I2S0_Type) SetTMR_TWM24(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetTMR_TWM24() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetTMR_TWM25(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetTMR_TWM25() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetTMR_TWM26(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x4000000)|value<<26)
}
func (o *I2S0_Type) GetTMR_TWM26() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x4000000) >> 26
}
func (o *I2S0_Type) SetTMR_TWM27(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x8000000)|value<<27)
}
func (o *I2S0_Type) GetTMR_TWM27() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x8000000) >> 27
}
func (o *I2S0_Type) SetTMR_TWM28(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetTMR_TWM28() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetTMR_TWM29(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetTMR_TWM29() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetTMR_TWM30(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetTMR_TWM30() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetTMR_TWM31(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetTMR_TWM31() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0x80000000) >> 31
}

// I2S0.RCSR: SAI Receive Control Register
func (o *I2S0_Type) SetRCSR_FRDE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetRCSR_FRDE() uint32 {
	return volatile.LoadUint32(&o.RCSR.Reg) & 0x1
}
func (o *I2S0_Type) SetRCSR_FWDE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetRCSR_FWDE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetRCSR_FRIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x100)|value<<8)
}
func (o *I2S0_Type) GetRCSR_FRIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x100) >> 8
}
func (o *I2S0_Type) SetRCSR_FWIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x200)|value<<9)
}
func (o *I2S0_Type) GetRCSR_FWIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x200) >> 9
}
func (o *I2S0_Type) SetRCSR_FEIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x400)|value<<10)
}
func (o *I2S0_Type) GetRCSR_FEIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x400) >> 10
}
func (o *I2S0_Type) SetRCSR_SEIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x800)|value<<11)
}
func (o *I2S0_Type) GetRCSR_SEIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x800) >> 11
}
func (o *I2S0_Type) SetRCSR_WSIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S0_Type) GetRCSR_WSIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x1000) >> 12
}
func (o *I2S0_Type) SetRCSR_FRF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetRCSR_FRF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetRCSR_FWF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetRCSR_FWF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetRCSR_FEF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S0_Type) GetRCSR_FEF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x40000) >> 18
}
func (o *I2S0_Type) SetRCSR_SEF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S0_Type) GetRCSR_SEF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x80000) >> 19
}
func (o *I2S0_Type) SetRCSR_WSF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S0_Type) GetRCSR_WSF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x100000) >> 20
}
func (o *I2S0_Type) SetRCSR_SR(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetRCSR_SR() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetRCSR_FR(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetRCSR_FR() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetRCSR_BCE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetRCSR_BCE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetRCSR_DBGE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetRCSR_DBGE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetRCSR_STOPE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetRCSR_STOPE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetRCSR_RE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetRCSR_RE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x80000000) >> 31
}

// I2S0.RCR1: SAI Receive Configuration 1 Register
func (o *I2S0_Type) SetRCR1_RFW(value uint32) {
	volatile.StoreUint32(&o.RCR1.Reg, volatile.LoadUint32(&o.RCR1.Reg)&^(0x7)|value)
}
func (o *I2S0_Type) GetRCR1_RFW() uint32 {
	return volatile.LoadUint32(&o.RCR1.Reg) & 0x7
}

// I2S0.RCR2: SAI Receive Configuration 2 Register
func (o *I2S0_Type) SetRCR2_DIV(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0xff)|value)
}
func (o *I2S0_Type) GetRCR2_DIV() uint32 {
	return volatile.LoadUint32(&o.RCR2.Reg) & 0xff
}
func (o *I2S0_Type) SetRCR2_BCD(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetRCR2_BCD() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetRCR2_BCP(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetRCR2_BCP() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetRCR2_MSEL(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S0_Type) GetRCR2_MSEL() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0xc000000) >> 26
}
func (o *I2S0_Type) SetRCR2_BCI(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetRCR2_BCI() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetRCR2_BCS(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetRCR2_BCS() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetRCR2_SYNC(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *I2S0_Type) GetRCR2_SYNC() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0xc0000000) >> 30
}

// I2S0.RCR3: SAI Receive Configuration 3 Register
func (o *I2S0_Type) SetRCR3_WDFL(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x1f)|value)
}
func (o *I2S0_Type) GetRCR3_WDFL() uint32 {
	return volatile.LoadUint32(&o.RCR3.Reg) & 0x1f
}
func (o *I2S0_Type) SetRCR3_RCE0(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetRCR3_RCE0() uint32 {
	return (volatile.LoadUint32(&o.RCR3.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetRCR3_RCE1(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetRCR3_RCE1() uint32 {
	return (volatile.LoadUint32(&o.RCR3.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetRCR3_CFR0(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetRCR3_CFR0() uint32 {
	return (volatile.LoadUint32(&o.RCR3.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetRCR3_CFR1(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetRCR3_CFR1() uint32 {
	return (volatile.LoadUint32(&o.RCR3.Reg) & 0x2000000) >> 25
}

// I2S0.RCR4: SAI Receive Configuration 4 Register
func (o *I2S0_Type) SetRCR4_FSD(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetRCR4_FSD() uint32 {
	return volatile.LoadUint32(&o.RCR4.Reg) & 0x1
}
func (o *I2S0_Type) SetRCR4_FSP(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetRCR4_FSP() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetRCR4_ONDEM(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x4)|value<<2)
}
func (o *I2S0_Type) GetRCR4_ONDEM() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x4) >> 2
}
func (o *I2S0_Type) SetRCR4_FSE(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x8)|value<<3)
}
func (o *I2S0_Type) GetRCR4_FSE() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x8) >> 3
}
func (o *I2S0_Type) SetRCR4_MF(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x10)|value<<4)
}
func (o *I2S0_Type) GetRCR4_MF() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x10) >> 4
}
func (o *I2S0_Type) SetRCR4_SYWD(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S0_Type) GetRCR4_SYWD() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x1f00) >> 8
}
func (o *I2S0_Type) SetRCR4_FRSZ(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S0_Type) GetRCR4_FRSZ() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x1f0000) >> 16
}
func (o *I2S0_Type) SetRCR4_FPACK(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S0_Type) GetRCR4_FPACK() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x3000000) >> 24
}
func (o *I2S0_Type) SetRCR4_FCOMB(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S0_Type) GetRCR4_FCOMB() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0xc000000) >> 26
}
func (o *I2S0_Type) SetRCR4_FCONT(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetRCR4_FCONT() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x10000000) >> 28
}

// I2S0.RCR5: SAI Receive Configuration 5 Register
func (o *I2S0_Type) SetRCR5_FBT(value uint32) {
	volatile.StoreUint32(&o.RCR5.Reg, volatile.LoadUint32(&o.RCR5.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S0_Type) GetRCR5_FBT() uint32 {
	return (volatile.LoadUint32(&o.RCR5.Reg) & 0x1f00) >> 8
}
func (o *I2S0_Type) SetRCR5_W0W(value uint32) {
	volatile.StoreUint32(&o.RCR5.Reg, volatile.LoadUint32(&o.RCR5.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S0_Type) GetRCR5_W0W() uint32 {
	return (volatile.LoadUint32(&o.RCR5.Reg) & 0x1f0000) >> 16
}
func (o *I2S0_Type) SetRCR5_WNW(value uint32) {
	volatile.StoreUint32(&o.RCR5.Reg, volatile.LoadUint32(&o.RCR5.Reg)&^(0x1f000000)|value<<24)
}
func (o *I2S0_Type) GetRCR5_WNW() uint32 {
	return (volatile.LoadUint32(&o.RCR5.Reg) & 0x1f000000) >> 24
}

// I2S0.RDR0: SAI Receive Data Register
func (o *I2S0_Type) SetRDR0(value uint32) {
	volatile.StoreUint32(&o.RDR0.Reg, value)
}
func (o *I2S0_Type) GetRDR0() uint32 {
	return volatile.LoadUint32(&o.RDR0.Reg)
}

// I2S0.RDR1: SAI Receive Data Register
func (o *I2S0_Type) SetRDR1(value uint32) {
	volatile.StoreUint32(&o.RDR1.Reg, value)
}
func (o *I2S0_Type) GetRDR1() uint32 {
	return volatile.LoadUint32(&o.RDR1.Reg)
}

// I2S0.RFR0: SAI Receive FIFO Register
func (o *I2S0_Type) SetRFR0_RFP(value uint32) {
	volatile.StoreUint32(&o.RFR0.Reg, volatile.LoadUint32(&o.RFR0.Reg)&^(0xf)|value)
}
func (o *I2S0_Type) GetRFR0_RFP() uint32 {
	return volatile.LoadUint32(&o.RFR0.Reg) & 0xf
}
func (o *I2S0_Type) SetRFR0_RCP(value uint32) {
	volatile.StoreUint32(&o.RFR0.Reg, volatile.LoadUint32(&o.RFR0.Reg)&^(0x8000)|value<<15)
}
func (o *I2S0_Type) GetRFR0_RCP() uint32 {
	return (volatile.LoadUint32(&o.RFR0.Reg) & 0x8000) >> 15
}
func (o *I2S0_Type) SetRFR0_WFP(value uint32) {
	volatile.StoreUint32(&o.RFR0.Reg, volatile.LoadUint32(&o.RFR0.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S0_Type) GetRFR0_WFP() uint32 {
	return (volatile.LoadUint32(&o.RFR0.Reg) & 0xf0000) >> 16
}

// I2S0.RFR1: SAI Receive FIFO Register
func (o *I2S0_Type) SetRFR1_RFP(value uint32) {
	volatile.StoreUint32(&o.RFR1.Reg, volatile.LoadUint32(&o.RFR1.Reg)&^(0xf)|value)
}
func (o *I2S0_Type) GetRFR1_RFP() uint32 {
	return volatile.LoadUint32(&o.RFR1.Reg) & 0xf
}
func (o *I2S0_Type) SetRFR1_RCP(value uint32) {
	volatile.StoreUint32(&o.RFR1.Reg, volatile.LoadUint32(&o.RFR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2S0_Type) GetRFR1_RCP() uint32 {
	return (volatile.LoadUint32(&o.RFR1.Reg) & 0x8000) >> 15
}
func (o *I2S0_Type) SetRFR1_WFP(value uint32) {
	volatile.StoreUint32(&o.RFR1.Reg, volatile.LoadUint32(&o.RFR1.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S0_Type) GetRFR1_WFP() uint32 {
	return (volatile.LoadUint32(&o.RFR1.Reg) & 0xf0000) >> 16
}

// I2S0.RMR: SAI Receive Mask Register
func (o *I2S0_Type) SetRMR_RWM0(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x1)|value)
}
func (o *I2S0_Type) GetRMR_RWM0() uint32 {
	return volatile.LoadUint32(&o.RMR.Reg) & 0x1
}
func (o *I2S0_Type) SetRMR_RWM1(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x2)|value<<1)
}
func (o *I2S0_Type) GetRMR_RWM1() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x2) >> 1
}
func (o *I2S0_Type) SetRMR_RWM2(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x4)|value<<2)
}
func (o *I2S0_Type) GetRMR_RWM2() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x4) >> 2
}
func (o *I2S0_Type) SetRMR_RWM3(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x8)|value<<3)
}
func (o *I2S0_Type) GetRMR_RWM3() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x8) >> 3
}
func (o *I2S0_Type) SetRMR_RWM4(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x10)|value<<4)
}
func (o *I2S0_Type) GetRMR_RWM4() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x10) >> 4
}
func (o *I2S0_Type) SetRMR_RWM5(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x20)|value<<5)
}
func (o *I2S0_Type) GetRMR_RWM5() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x20) >> 5
}
func (o *I2S0_Type) SetRMR_RWM6(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x40)|value<<6)
}
func (o *I2S0_Type) GetRMR_RWM6() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x40) >> 6
}
func (o *I2S0_Type) SetRMR_RWM7(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x80)|value<<7)
}
func (o *I2S0_Type) GetRMR_RWM7() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x80) >> 7
}
func (o *I2S0_Type) SetRMR_RWM8(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x100)|value<<8)
}
func (o *I2S0_Type) GetRMR_RWM8() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x100) >> 8
}
func (o *I2S0_Type) SetRMR_RWM9(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x200)|value<<9)
}
func (o *I2S0_Type) GetRMR_RWM9() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x200) >> 9
}
func (o *I2S0_Type) SetRMR_RWM10(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x400)|value<<10)
}
func (o *I2S0_Type) GetRMR_RWM10() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x400) >> 10
}
func (o *I2S0_Type) SetRMR_RWM11(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x800)|value<<11)
}
func (o *I2S0_Type) GetRMR_RWM11() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x800) >> 11
}
func (o *I2S0_Type) SetRMR_RWM12(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S0_Type) GetRMR_RWM12() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x1000) >> 12
}
func (o *I2S0_Type) SetRMR_RWM13(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x2000)|value<<13)
}
func (o *I2S0_Type) GetRMR_RWM13() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x2000) >> 13
}
func (o *I2S0_Type) SetRMR_RWM14(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x4000)|value<<14)
}
func (o *I2S0_Type) GetRMR_RWM14() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x4000) >> 14
}
func (o *I2S0_Type) SetRMR_RWM15(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x8000)|value<<15)
}
func (o *I2S0_Type) GetRMR_RWM15() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x8000) >> 15
}
func (o *I2S0_Type) SetRMR_RWM16(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S0_Type) GetRMR_RWM16() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x10000) >> 16
}
func (o *I2S0_Type) SetRMR_RWM17(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S0_Type) GetRMR_RWM17() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x20000) >> 17
}
func (o *I2S0_Type) SetRMR_RWM18(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S0_Type) GetRMR_RWM18() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x40000) >> 18
}
func (o *I2S0_Type) SetRMR_RWM19(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S0_Type) GetRMR_RWM19() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x80000) >> 19
}
func (o *I2S0_Type) SetRMR_RWM20(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S0_Type) GetRMR_RWM20() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x100000) >> 20
}
func (o *I2S0_Type) SetRMR_RWM21(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x200000)|value<<21)
}
func (o *I2S0_Type) GetRMR_RWM21() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x200000) >> 21
}
func (o *I2S0_Type) SetRMR_RWM22(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x400000)|value<<22)
}
func (o *I2S0_Type) GetRMR_RWM22() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x400000) >> 22
}
func (o *I2S0_Type) SetRMR_RWM23(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x800000)|value<<23)
}
func (o *I2S0_Type) GetRMR_RWM23() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x800000) >> 23
}
func (o *I2S0_Type) SetRMR_RWM24(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S0_Type) GetRMR_RWM24() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x1000000) >> 24
}
func (o *I2S0_Type) SetRMR_RWM25(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S0_Type) GetRMR_RWM25() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x2000000) >> 25
}
func (o *I2S0_Type) SetRMR_RWM26(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x4000000)|value<<26)
}
func (o *I2S0_Type) GetRMR_RWM26() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x4000000) >> 26
}
func (o *I2S0_Type) SetRMR_RWM27(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x8000000)|value<<27)
}
func (o *I2S0_Type) GetRMR_RWM27() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x8000000) >> 27
}
func (o *I2S0_Type) SetRMR_RWM28(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S0_Type) GetRMR_RWM28() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x10000000) >> 28
}
func (o *I2S0_Type) SetRMR_RWM29(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S0_Type) GetRMR_RWM29() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x20000000) >> 29
}
func (o *I2S0_Type) SetRMR_RWM30(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetRMR_RWM30() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetRMR_RWM31(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, volatile.LoadUint32(&o.RMR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetRMR_RWM31() uint32 {
	return (volatile.LoadUint32(&o.RMR.Reg) & 0x80000000) >> 31
}

// I2S0.MCR: SAI MCLK Control Register
func (o *I2S0_Type) SetMCR_MICS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S0_Type) GetMCR_MICS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x3000000) >> 24
}
func (o *I2S0_Type) SetMCR_MOE(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S0_Type) GetMCR_MOE() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40000000) >> 30
}
func (o *I2S0_Type) SetMCR_DUF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S0_Type) GetMCR_DUF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000000) >> 31
}

// I2S0.MDR: SAI MCLK Divide Register
func (o *I2S0_Type) SetMDR_DIVIDE(value uint32) {
	volatile.StoreUint32(&o.MDR.Reg, volatile.LoadUint32(&o.MDR.Reg)&^(0xfff)|value)
}
func (o *I2S0_Type) GetMDR_DIVIDE() uint32 {
	return volatile.LoadUint32(&o.MDR.Reg) & 0xfff
}
func (o *I2S0_Type) SetMDR_FRACT(value uint32) {
	volatile.StoreUint32(&o.MDR.Reg, volatile.LoadUint32(&o.MDR.Reg)&^(0xff000)|value<<12)
}
func (o *I2S0_Type) GetMDR_FRACT() uint32 {
	return (volatile.LoadUint32(&o.MDR.Reg) & 0xff000) >> 12
}

// Cyclic Redundancy Check
type CRC_Type struct {
	DATA  volatile.Register32 // 0x0
	GPOLY volatile.Register32 // 0x4
	CTRL  volatile.Register32 // 0x8
}

// CRC.DATA: CRC Data register
func (o *CRC_Type) SetDATA_LL(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff)|value)
}
func (o *CRC_Type) GetDATA_LL() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0xff
}
func (o *CRC_Type) SetDATA_LU(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff00)|value<<8)
}
func (o *CRC_Type) GetDATA_LU() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0xff00) >> 8
}
func (o *CRC_Type) SetDATA_HL(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff0000)|value<<16)
}
func (o *CRC_Type) GetDATA_HL() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0xff0000) >> 16
}
func (o *CRC_Type) SetDATA_HU(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff000000)|value<<24)
}
func (o *CRC_Type) GetDATA_HU() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0xff000000) >> 24
}

// CRC.GPOLY: CRC Polynomial register
func (o *CRC_Type) SetGPOLY_LOW(value uint32) {
	volatile.StoreUint32(&o.GPOLY.Reg, volatile.LoadUint32(&o.GPOLY.Reg)&^(0xffff)|value)
}
func (o *CRC_Type) GetGPOLY_LOW() uint32 {
	return volatile.LoadUint32(&o.GPOLY.Reg) & 0xffff
}
func (o *CRC_Type) SetGPOLY_HIGH(value uint32) {
	volatile.StoreUint32(&o.GPOLY.Reg, volatile.LoadUint32(&o.GPOLY.Reg)&^(0xffff0000)|value<<16)
}
func (o *CRC_Type) GetGPOLY_HIGH() uint32 {
	return (volatile.LoadUint32(&o.GPOLY.Reg) & 0xffff0000) >> 16
}

// CRC.CTRL: CRC Control register
func (o *CRC_Type) SetCTRL_TCRC(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *CRC_Type) GetCTRL_TCRC() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *CRC_Type) SetCTRL_WAS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *CRC_Type) GetCTRL_WAS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *CRC_Type) SetCTRL_FXOR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *CRC_Type) GetCTRL_FXOR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000000) >> 26
}
func (o *CRC_Type) SetCTRL_TOTR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *CRC_Type) GetCTRL_TOTR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x30000000) >> 28
}
func (o *CRC_Type) SetCTRL_TOT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc0000000)|value<<30)
}
func (o *CRC_Type) GetCTRL_TOT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc0000000) >> 30
}

// USB Device Charger Detection module
type USBDCD_Type struct {
	CONTROL         volatile.Register32 // 0x0
	CLOCK           volatile.Register32 // 0x4
	STATUS          volatile.Register32 // 0x8
	SIGNAL_OVERRIDE volatile.Register32 // 0xC
	TIMER0          volatile.Register32 // 0x10
	TIMER1          volatile.Register32 // 0x14
	TIMER2_BC11     volatile.Register32 // 0x18
}

// USBDCD.CONTROL: Control register
func (o *USBDCD_Type) SetCONTROL_IACK(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x1)|value)
}
func (o *USBDCD_Type) GetCONTROL_IACK() uint32 {
	return volatile.LoadUint32(&o.CONTROL.Reg) & 0x1
}
func (o *USBDCD_Type) SetCONTROL_IF(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x100)|value<<8)
}
func (o *USBDCD_Type) GetCONTROL_IF() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x100) >> 8
}
func (o *USBDCD_Type) SetCONTROL_IE(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x10000)|value<<16)
}
func (o *USBDCD_Type) GetCONTROL_IE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x10000) >> 16
}
func (o *USBDCD_Type) SetCONTROL_BC12(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x20000)|value<<17)
}
func (o *USBDCD_Type) GetCONTROL_BC12() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x20000) >> 17
}
func (o *USBDCD_Type) SetCONTROL_START(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *USBDCD_Type) GetCONTROL_START() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x1000000) >> 24
}
func (o *USBDCD_Type) SetCONTROL_SR(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *USBDCD_Type) GetCONTROL_SR() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x2000000) >> 25
}

// USBDCD.CLOCK: Clock register
func (o *USBDCD_Type) SetCLOCK_CLOCK_UNIT(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x1)|value)
}
func (o *USBDCD_Type) GetCLOCK_CLOCK_UNIT() uint32 {
	return volatile.LoadUint32(&o.CLOCK.Reg) & 0x1
}
func (o *USBDCD_Type) SetCLOCK_CLOCK_SPEED(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0xffc)|value<<2)
}
func (o *USBDCD_Type) GetCLOCK_CLOCK_SPEED() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0xffc) >> 2
}

// USBDCD.STATUS: Status register
func (o *USBDCD_Type) SetSTATUS_SEQ_RES(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x30000)|value<<16)
}
func (o *USBDCD_Type) GetSTATUS_SEQ_RES() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x30000) >> 16
}
func (o *USBDCD_Type) SetSTATUS_SEQ_STAT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xc0000)|value<<18)
}
func (o *USBDCD_Type) GetSTATUS_SEQ_STAT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xc0000) >> 18
}
func (o *USBDCD_Type) SetSTATUS_ERR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100000)|value<<20)
}
func (o *USBDCD_Type) GetSTATUS_ERR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100000) >> 20
}
func (o *USBDCD_Type) SetSTATUS_TO(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *USBDCD_Type) GetSTATUS_TO() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200000) >> 21
}
func (o *USBDCD_Type) SetSTATUS_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400000)|value<<22)
}
func (o *USBDCD_Type) GetSTATUS_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400000) >> 22
}

// USBDCD.SIGNAL_OVERRIDE: Signal Override Register
func (o *USBDCD_Type) SetSIGNAL_OVERRIDE_PS(value uint32) {
	volatile.StoreUint32(&o.SIGNAL_OVERRIDE.Reg, volatile.LoadUint32(&o.SIGNAL_OVERRIDE.Reg)&^(0x3)|value)
}
func (o *USBDCD_Type) GetSIGNAL_OVERRIDE_PS() uint32 {
	return volatile.LoadUint32(&o.SIGNAL_OVERRIDE.Reg) & 0x3
}

// USBDCD.TIMER0: TIMER0 register
func (o *USBDCD_Type) SetTIMER0_TUNITCON(value uint32) {
	volatile.StoreUint32(&o.TIMER0.Reg, volatile.LoadUint32(&o.TIMER0.Reg)&^(0xfff)|value)
}
func (o *USBDCD_Type) GetTIMER0_TUNITCON() uint32 {
	return volatile.LoadUint32(&o.TIMER0.Reg) & 0xfff
}
func (o *USBDCD_Type) SetTIMER0_TSEQ_INIT(value uint32) {
	volatile.StoreUint32(&o.TIMER0.Reg, volatile.LoadUint32(&o.TIMER0.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBDCD_Type) GetTIMER0_TSEQ_INIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER0.Reg) & 0x3ff0000) >> 16
}

// USBDCD.TIMER1: TIMER1 register
func (o *USBDCD_Type) SetTIMER1_TVDPSRC_ON(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3ff)|value)
}
func (o *USBDCD_Type) GetTIMER1_TVDPSRC_ON() uint32 {
	return volatile.LoadUint32(&o.TIMER1.Reg) & 0x3ff
}
func (o *USBDCD_Type) SetTIMER1_TDCD_DBNC(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBDCD_Type) GetTIMER1_TDCD_DBNC() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0x3ff0000) >> 16
}

// USBDCD.TIMER2_BC11: TIMER2_BC11 register
func (o *USBDCD_Type) SetTIMER2_BC11_CHECK_DM(value uint32) {
	volatile.StoreUint32(&o.TIMER2_BC11.Reg, volatile.LoadUint32(&o.TIMER2_BC11.Reg)&^(0xf)|value)
}
func (o *USBDCD_Type) GetTIMER2_BC11_CHECK_DM() uint32 {
	return volatile.LoadUint32(&o.TIMER2_BC11.Reg) & 0xf
}
func (o *USBDCD_Type) SetTIMER2_BC11_TVDPSRC_CON(value uint32) {
	volatile.StoreUint32(&o.TIMER2_BC11.Reg, volatile.LoadUint32(&o.TIMER2_BC11.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBDCD_Type) GetTIMER2_BC11_TVDPSRC_CON() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_BC11.Reg) & 0x3ff0000) >> 16
}

// Programmable Delay Block
type PDB0_Type struct {
	SC       volatile.Register32 // 0x0
	MOD      volatile.Register32 // 0x4
	CNT      volatile.Register32 // 0x8
	IDLY     volatile.Register32 // 0xC
	CH0C1    volatile.Register32 // 0x10
	CH0S     volatile.Register32 // 0x14
	CH0DLY0  volatile.Register32 // 0x18
	CH0DLY1  volatile.Register32 // 0x1C
	_        [24]byte
	CH1C1    volatile.Register32 // 0x38
	CH1S     volatile.Register32 // 0x3C
	CH1DLY0  volatile.Register32 // 0x40
	CH1DLY1  volatile.Register32 // 0x44
	_        [264]byte
	DACINTC0 volatile.Register32 // 0x150
	DACINT0  volatile.Register32 // 0x154
	DACINTC1 volatile.Register32 // 0x158
	DACINT1  volatile.Register32 // 0x15C
	_        [48]byte
	POEN     volatile.Register32 // 0x190
	PO0DLY   volatile.Register32 // 0x194
	PO1DLY   volatile.Register32 // 0x198
	PO2DLY   volatile.Register32 // 0x19C
	PO3DLY   volatile.Register32 // 0x1A0
}

// PDB0.SC: Status and Control register
func (o *PDB0_Type) SetSC_LDOK(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetSC_LDOK() uint32 {
	return volatile.LoadUint32(&o.SC.Reg) & 0x1
}
func (o *PDB0_Type) SetSC_CONT(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetSC_CONT() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetSC_MULT(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0xc)|value<<2)
}
func (o *PDB0_Type) GetSC_MULT() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0xc) >> 2
}
func (o *PDB0_Type) SetSC_PDBIE(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetSC_PDBIE() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetSC_PDBIF(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetSC_PDBIF() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetSC_PDBEN(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetSC_PDBEN() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetSC_TRGSEL(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0xf00)|value<<8)
}
func (o *PDB0_Type) GetSC_TRGSEL() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0xf00) >> 8
}
func (o *PDB0_Type) SetSC_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x7000)|value<<12)
}
func (o *PDB0_Type) GetSC_PRESCALER() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x7000) >> 12
}
func (o *PDB0_Type) SetSC_DMAEN(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x8000)|value<<15)
}
func (o *PDB0_Type) GetSC_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x8000) >> 15
}
func (o *PDB0_Type) SetSC_SWTRIG(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x10000)|value<<16)
}
func (o *PDB0_Type) GetSC_SWTRIG() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x10000) >> 16
}
func (o *PDB0_Type) SetSC_PDBEIE(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x20000)|value<<17)
}
func (o *PDB0_Type) GetSC_PDBEIE() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x20000) >> 17
}
func (o *PDB0_Type) SetSC_LDMOD(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0xc0000)|value<<18)
}
func (o *PDB0_Type) GetSC_LDMOD() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0xc0000) >> 18
}

// PDB0.MOD: Modulus register
func (o *PDB0_Type) SetMOD(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetMOD() uint32 {
	return volatile.LoadUint32(&o.MOD.Reg) & 0xffff
}

// PDB0.CNT: Counter register
func (o *PDB0_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// PDB0.IDLY: Interrupt Delay register
func (o *PDB0_Type) SetIDLY(value uint32) {
	volatile.StoreUint32(&o.IDLY.Reg, volatile.LoadUint32(&o.IDLY.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetIDLY() uint32 {
	return volatile.LoadUint32(&o.IDLY.Reg) & 0xffff
}

// PDB0.CH0C1: Channel n Control register 1
func (o *PDB0_Type) SetCH0C1_EN0(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetCH0C1_EN0() uint32 {
	return volatile.LoadUint32(&o.CH0C1.Reg) & 0x1
}
func (o *PDB0_Type) SetCH0C1_EN1(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetCH0C1_EN1() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetCH0C1_EN2(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetCH0C1_EN2() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetCH0C1_EN3(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetCH0C1_EN3() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetCH0C1_EN4(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetCH0C1_EN4() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetCH0C1_EN5(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetCH0C1_EN5() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetCH0C1_EN6(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetCH0C1_EN6() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetCH0C1_EN7(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetCH0C1_EN7() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetCH0C1_TOS0(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x100)|value<<8)
}
func (o *PDB0_Type) GetCH0C1_TOS0() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x100) >> 8
}
func (o *PDB0_Type) SetCH0C1_TOS1(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x200)|value<<9)
}
func (o *PDB0_Type) GetCH0C1_TOS1() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x200) >> 9
}
func (o *PDB0_Type) SetCH0C1_TOS2(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x400)|value<<10)
}
func (o *PDB0_Type) GetCH0C1_TOS2() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x400) >> 10
}
func (o *PDB0_Type) SetCH0C1_TOS3(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x800)|value<<11)
}
func (o *PDB0_Type) GetCH0C1_TOS3() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x800) >> 11
}
func (o *PDB0_Type) SetCH0C1_TOS4(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x1000)|value<<12)
}
func (o *PDB0_Type) GetCH0C1_TOS4() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x1000) >> 12
}
func (o *PDB0_Type) SetCH0C1_TOS5(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x2000)|value<<13)
}
func (o *PDB0_Type) GetCH0C1_TOS5() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x2000) >> 13
}
func (o *PDB0_Type) SetCH0C1_TOS6(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x4000)|value<<14)
}
func (o *PDB0_Type) GetCH0C1_TOS6() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x4000) >> 14
}
func (o *PDB0_Type) SetCH0C1_TOS7(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x8000)|value<<15)
}
func (o *PDB0_Type) GetCH0C1_TOS7() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x8000) >> 15
}
func (o *PDB0_Type) SetCH0C1_BB0(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x10000)|value<<16)
}
func (o *PDB0_Type) GetCH0C1_BB0() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x10000) >> 16
}
func (o *PDB0_Type) SetCH0C1_BB1(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x20000)|value<<17)
}
func (o *PDB0_Type) GetCH0C1_BB1() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x20000) >> 17
}
func (o *PDB0_Type) SetCH0C1_BB2(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x40000)|value<<18)
}
func (o *PDB0_Type) GetCH0C1_BB2() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x40000) >> 18
}
func (o *PDB0_Type) SetCH0C1_BB3(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x80000)|value<<19)
}
func (o *PDB0_Type) GetCH0C1_BB3() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x80000) >> 19
}
func (o *PDB0_Type) SetCH0C1_BB4(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x100000)|value<<20)
}
func (o *PDB0_Type) GetCH0C1_BB4() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x100000) >> 20
}
func (o *PDB0_Type) SetCH0C1_BB5(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x200000)|value<<21)
}
func (o *PDB0_Type) GetCH0C1_BB5() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x200000) >> 21
}
func (o *PDB0_Type) SetCH0C1_BB6(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x400000)|value<<22)
}
func (o *PDB0_Type) GetCH0C1_BB6() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x400000) >> 22
}
func (o *PDB0_Type) SetCH0C1_BB7(value uint32) {
	volatile.StoreUint32(&o.CH0C1.Reg, volatile.LoadUint32(&o.CH0C1.Reg)&^(0x800000)|value<<23)
}
func (o *PDB0_Type) GetCH0C1_BB7() uint32 {
	return (volatile.LoadUint32(&o.CH0C1.Reg) & 0x800000) >> 23
}

// PDB0.CH0S: Channel n Status register
func (o *PDB0_Type) SetCH0S_ERR0(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetCH0S_ERR0() uint32 {
	return volatile.LoadUint32(&o.CH0S.Reg) & 0x1
}
func (o *PDB0_Type) SetCH0S_ERR1(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetCH0S_ERR1() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetCH0S_ERR2(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetCH0S_ERR2() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetCH0S_ERR3(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetCH0S_ERR3() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetCH0S_ERR4(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetCH0S_ERR4() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetCH0S_ERR5(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetCH0S_ERR5() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetCH0S_ERR6(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetCH0S_ERR6() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetCH0S_ERR7(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetCH0S_ERR7() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetCH0S_CF(value uint32) {
	volatile.StoreUint32(&o.CH0S.Reg, volatile.LoadUint32(&o.CH0S.Reg)&^(0xff0000)|value<<16)
}
func (o *PDB0_Type) GetCH0S_CF() uint32 {
	return (volatile.LoadUint32(&o.CH0S.Reg) & 0xff0000) >> 16
}

// PDB0.CH0DLY0: Channel n Delay 0 register
func (o *PDB0_Type) SetCH0DLY0_DLY(value uint32) {
	volatile.StoreUint32(&o.CH0DLY0.Reg, volatile.LoadUint32(&o.CH0DLY0.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCH0DLY0_DLY() uint32 {
	return volatile.LoadUint32(&o.CH0DLY0.Reg) & 0xffff
}

// PDB0.CH0DLY1: Channel n Delay 1 register
func (o *PDB0_Type) SetCH0DLY1_DLY(value uint32) {
	volatile.StoreUint32(&o.CH0DLY1.Reg, volatile.LoadUint32(&o.CH0DLY1.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCH0DLY1_DLY() uint32 {
	return volatile.LoadUint32(&o.CH0DLY1.Reg) & 0xffff
}

// PDB0.CH1C1: Channel n Control register 1
func (o *PDB0_Type) SetCH1C1_EN0(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetCH1C1_EN0() uint32 {
	return volatile.LoadUint32(&o.CH1C1.Reg) & 0x1
}
func (o *PDB0_Type) SetCH1C1_EN1(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetCH1C1_EN1() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetCH1C1_EN2(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetCH1C1_EN2() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetCH1C1_EN3(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetCH1C1_EN3() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetCH1C1_EN4(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetCH1C1_EN4() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetCH1C1_EN5(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetCH1C1_EN5() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetCH1C1_EN6(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetCH1C1_EN6() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetCH1C1_EN7(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetCH1C1_EN7() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetCH1C1_TOS0(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x100)|value<<8)
}
func (o *PDB0_Type) GetCH1C1_TOS0() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x100) >> 8
}
func (o *PDB0_Type) SetCH1C1_TOS1(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x200)|value<<9)
}
func (o *PDB0_Type) GetCH1C1_TOS1() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x200) >> 9
}
func (o *PDB0_Type) SetCH1C1_TOS2(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x400)|value<<10)
}
func (o *PDB0_Type) GetCH1C1_TOS2() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x400) >> 10
}
func (o *PDB0_Type) SetCH1C1_TOS3(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x800)|value<<11)
}
func (o *PDB0_Type) GetCH1C1_TOS3() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x800) >> 11
}
func (o *PDB0_Type) SetCH1C1_TOS4(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x1000)|value<<12)
}
func (o *PDB0_Type) GetCH1C1_TOS4() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x1000) >> 12
}
func (o *PDB0_Type) SetCH1C1_TOS5(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x2000)|value<<13)
}
func (o *PDB0_Type) GetCH1C1_TOS5() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x2000) >> 13
}
func (o *PDB0_Type) SetCH1C1_TOS6(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x4000)|value<<14)
}
func (o *PDB0_Type) GetCH1C1_TOS6() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x4000) >> 14
}
func (o *PDB0_Type) SetCH1C1_TOS7(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x8000)|value<<15)
}
func (o *PDB0_Type) GetCH1C1_TOS7() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x8000) >> 15
}
func (o *PDB0_Type) SetCH1C1_BB0(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x10000)|value<<16)
}
func (o *PDB0_Type) GetCH1C1_BB0() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x10000) >> 16
}
func (o *PDB0_Type) SetCH1C1_BB1(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x20000)|value<<17)
}
func (o *PDB0_Type) GetCH1C1_BB1() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x20000) >> 17
}
func (o *PDB0_Type) SetCH1C1_BB2(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x40000)|value<<18)
}
func (o *PDB0_Type) GetCH1C1_BB2() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x40000) >> 18
}
func (o *PDB0_Type) SetCH1C1_BB3(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x80000)|value<<19)
}
func (o *PDB0_Type) GetCH1C1_BB3() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x80000) >> 19
}
func (o *PDB0_Type) SetCH1C1_BB4(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x100000)|value<<20)
}
func (o *PDB0_Type) GetCH1C1_BB4() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x100000) >> 20
}
func (o *PDB0_Type) SetCH1C1_BB5(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x200000)|value<<21)
}
func (o *PDB0_Type) GetCH1C1_BB5() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x200000) >> 21
}
func (o *PDB0_Type) SetCH1C1_BB6(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x400000)|value<<22)
}
func (o *PDB0_Type) GetCH1C1_BB6() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x400000) >> 22
}
func (o *PDB0_Type) SetCH1C1_BB7(value uint32) {
	volatile.StoreUint32(&o.CH1C1.Reg, volatile.LoadUint32(&o.CH1C1.Reg)&^(0x800000)|value<<23)
}
func (o *PDB0_Type) GetCH1C1_BB7() uint32 {
	return (volatile.LoadUint32(&o.CH1C1.Reg) & 0x800000) >> 23
}

// PDB0.CH1S: Channel n Status register
func (o *PDB0_Type) SetCH1S_ERR0(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetCH1S_ERR0() uint32 {
	return volatile.LoadUint32(&o.CH1S.Reg) & 0x1
}
func (o *PDB0_Type) SetCH1S_ERR1(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetCH1S_ERR1() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetCH1S_ERR2(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetCH1S_ERR2() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetCH1S_ERR3(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetCH1S_ERR3() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetCH1S_ERR4(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetCH1S_ERR4() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetCH1S_ERR5(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetCH1S_ERR5() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetCH1S_ERR6(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetCH1S_ERR6() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetCH1S_ERR7(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetCH1S_ERR7() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0x80) >> 7
}
func (o *PDB0_Type) SetCH1S_CF(value uint32) {
	volatile.StoreUint32(&o.CH1S.Reg, volatile.LoadUint32(&o.CH1S.Reg)&^(0xff0000)|value<<16)
}
func (o *PDB0_Type) GetCH1S_CF() uint32 {
	return (volatile.LoadUint32(&o.CH1S.Reg) & 0xff0000) >> 16
}

// PDB0.CH1DLY0: Channel n Delay 0 register
func (o *PDB0_Type) SetCH1DLY0_DLY(value uint32) {
	volatile.StoreUint32(&o.CH1DLY0.Reg, volatile.LoadUint32(&o.CH1DLY0.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCH1DLY0_DLY() uint32 {
	return volatile.LoadUint32(&o.CH1DLY0.Reg) & 0xffff
}

// PDB0.CH1DLY1: Channel n Delay 1 register
func (o *PDB0_Type) SetCH1DLY1_DLY(value uint32) {
	volatile.StoreUint32(&o.CH1DLY1.Reg, volatile.LoadUint32(&o.CH1DLY1.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetCH1DLY1_DLY() uint32 {
	return volatile.LoadUint32(&o.CH1DLY1.Reg) & 0xffff
}

// PDB0.DACINTC0: DAC Interval Trigger n Control register
func (o *PDB0_Type) SetDACINTC0_TOE(value uint32) {
	volatile.StoreUint32(&o.DACINTC0.Reg, volatile.LoadUint32(&o.DACINTC0.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetDACINTC0_TOE() uint32 {
	return volatile.LoadUint32(&o.DACINTC0.Reg) & 0x1
}
func (o *PDB0_Type) SetDACINTC0_EXT(value uint32) {
	volatile.StoreUint32(&o.DACINTC0.Reg, volatile.LoadUint32(&o.DACINTC0.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetDACINTC0_EXT() uint32 {
	return (volatile.LoadUint32(&o.DACINTC0.Reg) & 0x2) >> 1
}

// PDB0.DACINT0: DAC Interval n register
func (o *PDB0_Type) SetDACINT0_INT(value uint32) {
	volatile.StoreUint32(&o.DACINT0.Reg, volatile.LoadUint32(&o.DACINT0.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetDACINT0_INT() uint32 {
	return volatile.LoadUint32(&o.DACINT0.Reg) & 0xffff
}

// PDB0.DACINTC1: DAC Interval Trigger n Control register
func (o *PDB0_Type) SetDACINTC1_TOE(value uint32) {
	volatile.StoreUint32(&o.DACINTC1.Reg, volatile.LoadUint32(&o.DACINTC1.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetDACINTC1_TOE() uint32 {
	return volatile.LoadUint32(&o.DACINTC1.Reg) & 0x1
}
func (o *PDB0_Type) SetDACINTC1_EXT(value uint32) {
	volatile.StoreUint32(&o.DACINTC1.Reg, volatile.LoadUint32(&o.DACINTC1.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetDACINTC1_EXT() uint32 {
	return (volatile.LoadUint32(&o.DACINTC1.Reg) & 0x2) >> 1
}

// PDB0.DACINT1: DAC Interval n register
func (o *PDB0_Type) SetDACINT1_INT(value uint32) {
	volatile.StoreUint32(&o.DACINT1.Reg, volatile.LoadUint32(&o.DACINT1.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetDACINT1_INT() uint32 {
	return volatile.LoadUint32(&o.DACINT1.Reg) & 0xffff
}

// PDB0.POEN: Pulse-Out n Enable register
func (o *PDB0_Type) SetPOEN_POEN0(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x1)|value)
}
func (o *PDB0_Type) GetPOEN_POEN0() uint32 {
	return volatile.LoadUint32(&o.POEN.Reg) & 0x1
}
func (o *PDB0_Type) SetPOEN_POEN1(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x2)|value<<1)
}
func (o *PDB0_Type) GetPOEN_POEN1() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x2) >> 1
}
func (o *PDB0_Type) SetPOEN_POEN2(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x4)|value<<2)
}
func (o *PDB0_Type) GetPOEN_POEN2() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x4) >> 2
}
func (o *PDB0_Type) SetPOEN_POEN3(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x8)|value<<3)
}
func (o *PDB0_Type) GetPOEN_POEN3() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x8) >> 3
}
func (o *PDB0_Type) SetPOEN_POEN4(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x10)|value<<4)
}
func (o *PDB0_Type) GetPOEN_POEN4() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x10) >> 4
}
func (o *PDB0_Type) SetPOEN_POEN5(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x20)|value<<5)
}
func (o *PDB0_Type) GetPOEN_POEN5() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x20) >> 5
}
func (o *PDB0_Type) SetPOEN_POEN6(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x40)|value<<6)
}
func (o *PDB0_Type) GetPOEN_POEN6() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x40) >> 6
}
func (o *PDB0_Type) SetPOEN_POEN7(value uint32) {
	volatile.StoreUint32(&o.POEN.Reg, volatile.LoadUint32(&o.POEN.Reg)&^(0x80)|value<<7)
}
func (o *PDB0_Type) GetPOEN_POEN7() uint32 {
	return (volatile.LoadUint32(&o.POEN.Reg) & 0x80) >> 7
}

// PDB0.PO0DLY: Pulse-Out n Delay register
func (o *PDB0_Type) SetPO0DLY_DLY2(value uint32) {
	volatile.StoreUint32(&o.PO0DLY.Reg, volatile.LoadUint32(&o.PO0DLY.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetPO0DLY_DLY2() uint32 {
	return volatile.LoadUint32(&o.PO0DLY.Reg) & 0xffff
}
func (o *PDB0_Type) SetPO0DLY_DLY1(value uint32) {
	volatile.StoreUint32(&o.PO0DLY.Reg, volatile.LoadUint32(&o.PO0DLY.Reg)&^(0xffff0000)|value<<16)
}
func (o *PDB0_Type) GetPO0DLY_DLY1() uint32 {
	return (volatile.LoadUint32(&o.PO0DLY.Reg) & 0xffff0000) >> 16
}

// PDB0.PO1DLY: Pulse-Out n Delay register
func (o *PDB0_Type) SetPO1DLY_DLY2(value uint32) {
	volatile.StoreUint32(&o.PO1DLY.Reg, volatile.LoadUint32(&o.PO1DLY.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetPO1DLY_DLY2() uint32 {
	return volatile.LoadUint32(&o.PO1DLY.Reg) & 0xffff
}
func (o *PDB0_Type) SetPO1DLY_DLY1(value uint32) {
	volatile.StoreUint32(&o.PO1DLY.Reg, volatile.LoadUint32(&o.PO1DLY.Reg)&^(0xffff0000)|value<<16)
}
func (o *PDB0_Type) GetPO1DLY_DLY1() uint32 {
	return (volatile.LoadUint32(&o.PO1DLY.Reg) & 0xffff0000) >> 16
}

// PDB0.PO2DLY: Pulse-Out n Delay register
func (o *PDB0_Type) SetPO2DLY_DLY2(value uint32) {
	volatile.StoreUint32(&o.PO2DLY.Reg, volatile.LoadUint32(&o.PO2DLY.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetPO2DLY_DLY2() uint32 {
	return volatile.LoadUint32(&o.PO2DLY.Reg) & 0xffff
}
func (o *PDB0_Type) SetPO2DLY_DLY1(value uint32) {
	volatile.StoreUint32(&o.PO2DLY.Reg, volatile.LoadUint32(&o.PO2DLY.Reg)&^(0xffff0000)|value<<16)
}
func (o *PDB0_Type) GetPO2DLY_DLY1() uint32 {
	return (volatile.LoadUint32(&o.PO2DLY.Reg) & 0xffff0000) >> 16
}

// PDB0.PO3DLY: Pulse-Out n Delay register
func (o *PDB0_Type) SetPO3DLY_DLY2(value uint32) {
	volatile.StoreUint32(&o.PO3DLY.Reg, volatile.LoadUint32(&o.PO3DLY.Reg)&^(0xffff)|value)
}
func (o *PDB0_Type) GetPO3DLY_DLY2() uint32 {
	return volatile.LoadUint32(&o.PO3DLY.Reg) & 0xffff
}
func (o *PDB0_Type) SetPO3DLY_DLY1(value uint32) {
	volatile.StoreUint32(&o.PO3DLY.Reg, volatile.LoadUint32(&o.PO3DLY.Reg)&^(0xffff0000)|value<<16)
}
func (o *PDB0_Type) GetPO3DLY_DLY1() uint32 {
	return (volatile.LoadUint32(&o.PO3DLY.Reg) & 0xffff0000) >> 16
}

// Periodic Interrupt Timer
type PIT_Type struct {
	MCR     volatile.Register32 // 0x0
	_       [220]byte
	LTMR64H volatile.Register32 // 0xE0
	LTMR64L volatile.Register32 // 0xE4
	_       [24]byte
	LDVAL0  volatile.Register32 // 0x100
	CVAL0   volatile.Register32 // 0x104
	TCTRL0  volatile.Register32 // 0x108
	TFLG0   volatile.Register32 // 0x10C
	LDVAL1  volatile.Register32 // 0x110
	CVAL1   volatile.Register32 // 0x114
	TCTRL1  volatile.Register32 // 0x118
	TFLG1   volatile.Register32 // 0x11C
	LDVAL2  volatile.Register32 // 0x120
	CVAL2   volatile.Register32 // 0x124
	TCTRL2  volatile.Register32 // 0x128
	TFLG2   volatile.Register32 // 0x12C
	LDVAL3  volatile.Register32 // 0x130
	CVAL3   volatile.Register32 // 0x134
	TCTRL3  volatile.Register32 // 0x138
	TFLG3   volatile.Register32 // 0x13C
}

// PIT.MCR: PIT Module Control Register
func (o *PIT_Type) SetMCR_FRZ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetMCR_FRZ() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *PIT_Type) SetMCR_MDIS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetMCR_MDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}

// PIT.LTMR64H: PIT Upper Lifetime Timer Register
func (o *PIT_Type) SetLTMR64H(value uint32) {
	volatile.StoreUint32(&o.LTMR64H.Reg, value)
}
func (o *PIT_Type) GetLTMR64H() uint32 {
	return volatile.LoadUint32(&o.LTMR64H.Reg)
}

// PIT.LTMR64L: PIT Lower Lifetime Timer Register
func (o *PIT_Type) SetLTMR64L(value uint32) {
	volatile.StoreUint32(&o.LTMR64L.Reg, value)
}
func (o *PIT_Type) GetLTMR64L() uint32 {
	return volatile.LoadUint32(&o.LTMR64L.Reg)
}

// PIT.LDVAL0: Timer Load Value Register
func (o *PIT_Type) SetLDVAL0(value uint32) {
	volatile.StoreUint32(&o.LDVAL0.Reg, value)
}
func (o *PIT_Type) GetLDVAL0() uint32 {
	return volatile.LoadUint32(&o.LDVAL0.Reg)
}

// PIT.CVAL0: Current Timer Value Register
func (o *PIT_Type) SetCVAL0(value uint32) {
	volatile.StoreUint32(&o.CVAL0.Reg, value)
}
func (o *PIT_Type) GetCVAL0() uint32 {
	return volatile.LoadUint32(&o.CVAL0.Reg)
}

// PIT.TCTRL0: Timer Control Register
func (o *PIT_Type) SetTCTRL0_TEN(value uint32) {
	volatile.StoreUint32(&o.TCTRL0.Reg, volatile.LoadUint32(&o.TCTRL0.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTCTRL0_TEN() uint32 {
	return volatile.LoadUint32(&o.TCTRL0.Reg) & 0x1
}
func (o *PIT_Type) SetTCTRL0_TIE(value uint32) {
	volatile.StoreUint32(&o.TCTRL0.Reg, volatile.LoadUint32(&o.TCTRL0.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetTCTRL0_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCTRL0.Reg) & 0x2) >> 1
}
func (o *PIT_Type) SetTCTRL0_CHN(value uint32) {
	volatile.StoreUint32(&o.TCTRL0.Reg, volatile.LoadUint32(&o.TCTRL0.Reg)&^(0x4)|value<<2)
}
func (o *PIT_Type) GetTCTRL0_CHN() uint32 {
	return (volatile.LoadUint32(&o.TCTRL0.Reg) & 0x4) >> 2
}

// PIT.TFLG0: Timer Flag Register
func (o *PIT_Type) SetTFLG0_TIF(value uint32) {
	volatile.StoreUint32(&o.TFLG0.Reg, volatile.LoadUint32(&o.TFLG0.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTFLG0_TIF() uint32 {
	return volatile.LoadUint32(&o.TFLG0.Reg) & 0x1
}

// PIT.LDVAL1: Timer Load Value Register
func (o *PIT_Type) SetLDVAL1(value uint32) {
	volatile.StoreUint32(&o.LDVAL1.Reg, value)
}
func (o *PIT_Type) GetLDVAL1() uint32 {
	return volatile.LoadUint32(&o.LDVAL1.Reg)
}

// PIT.CVAL1: Current Timer Value Register
func (o *PIT_Type) SetCVAL1(value uint32) {
	volatile.StoreUint32(&o.CVAL1.Reg, value)
}
func (o *PIT_Type) GetCVAL1() uint32 {
	return volatile.LoadUint32(&o.CVAL1.Reg)
}

// PIT.TCTRL1: Timer Control Register
func (o *PIT_Type) SetTCTRL1_TEN(value uint32) {
	volatile.StoreUint32(&o.TCTRL1.Reg, volatile.LoadUint32(&o.TCTRL1.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTCTRL1_TEN() uint32 {
	return volatile.LoadUint32(&o.TCTRL1.Reg) & 0x1
}
func (o *PIT_Type) SetTCTRL1_TIE(value uint32) {
	volatile.StoreUint32(&o.TCTRL1.Reg, volatile.LoadUint32(&o.TCTRL1.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetTCTRL1_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCTRL1.Reg) & 0x2) >> 1
}
func (o *PIT_Type) SetTCTRL1_CHN(value uint32) {
	volatile.StoreUint32(&o.TCTRL1.Reg, volatile.LoadUint32(&o.TCTRL1.Reg)&^(0x4)|value<<2)
}
func (o *PIT_Type) GetTCTRL1_CHN() uint32 {
	return (volatile.LoadUint32(&o.TCTRL1.Reg) & 0x4) >> 2
}

// PIT.TFLG1: Timer Flag Register
func (o *PIT_Type) SetTFLG1_TIF(value uint32) {
	volatile.StoreUint32(&o.TFLG1.Reg, volatile.LoadUint32(&o.TFLG1.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTFLG1_TIF() uint32 {
	return volatile.LoadUint32(&o.TFLG1.Reg) & 0x1
}

// PIT.LDVAL2: Timer Load Value Register
func (o *PIT_Type) SetLDVAL2(value uint32) {
	volatile.StoreUint32(&o.LDVAL2.Reg, value)
}
func (o *PIT_Type) GetLDVAL2() uint32 {
	return volatile.LoadUint32(&o.LDVAL2.Reg)
}

// PIT.CVAL2: Current Timer Value Register
func (o *PIT_Type) SetCVAL2(value uint32) {
	volatile.StoreUint32(&o.CVAL2.Reg, value)
}
func (o *PIT_Type) GetCVAL2() uint32 {
	return volatile.LoadUint32(&o.CVAL2.Reg)
}

// PIT.TCTRL2: Timer Control Register
func (o *PIT_Type) SetTCTRL2_TEN(value uint32) {
	volatile.StoreUint32(&o.TCTRL2.Reg, volatile.LoadUint32(&o.TCTRL2.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTCTRL2_TEN() uint32 {
	return volatile.LoadUint32(&o.TCTRL2.Reg) & 0x1
}
func (o *PIT_Type) SetTCTRL2_TIE(value uint32) {
	volatile.StoreUint32(&o.TCTRL2.Reg, volatile.LoadUint32(&o.TCTRL2.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetTCTRL2_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCTRL2.Reg) & 0x2) >> 1
}
func (o *PIT_Type) SetTCTRL2_CHN(value uint32) {
	volatile.StoreUint32(&o.TCTRL2.Reg, volatile.LoadUint32(&o.TCTRL2.Reg)&^(0x4)|value<<2)
}
func (o *PIT_Type) GetTCTRL2_CHN() uint32 {
	return (volatile.LoadUint32(&o.TCTRL2.Reg) & 0x4) >> 2
}

// PIT.TFLG2: Timer Flag Register
func (o *PIT_Type) SetTFLG2_TIF(value uint32) {
	volatile.StoreUint32(&o.TFLG2.Reg, volatile.LoadUint32(&o.TFLG2.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTFLG2_TIF() uint32 {
	return volatile.LoadUint32(&o.TFLG2.Reg) & 0x1
}

// PIT.LDVAL3: Timer Load Value Register
func (o *PIT_Type) SetLDVAL3(value uint32) {
	volatile.StoreUint32(&o.LDVAL3.Reg, value)
}
func (o *PIT_Type) GetLDVAL3() uint32 {
	return volatile.LoadUint32(&o.LDVAL3.Reg)
}

// PIT.CVAL3: Current Timer Value Register
func (o *PIT_Type) SetCVAL3(value uint32) {
	volatile.StoreUint32(&o.CVAL3.Reg, value)
}
func (o *PIT_Type) GetCVAL3() uint32 {
	return volatile.LoadUint32(&o.CVAL3.Reg)
}

// PIT.TCTRL3: Timer Control Register
func (o *PIT_Type) SetTCTRL3_TEN(value uint32) {
	volatile.StoreUint32(&o.TCTRL3.Reg, volatile.LoadUint32(&o.TCTRL3.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTCTRL3_TEN() uint32 {
	return volatile.LoadUint32(&o.TCTRL3.Reg) & 0x1
}
func (o *PIT_Type) SetTCTRL3_TIE(value uint32) {
	volatile.StoreUint32(&o.TCTRL3.Reg, volatile.LoadUint32(&o.TCTRL3.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetTCTRL3_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCTRL3.Reg) & 0x2) >> 1
}
func (o *PIT_Type) SetTCTRL3_CHN(value uint32) {
	volatile.StoreUint32(&o.TCTRL3.Reg, volatile.LoadUint32(&o.TCTRL3.Reg)&^(0x4)|value<<2)
}
func (o *PIT_Type) GetTCTRL3_CHN() uint32 {
	return (volatile.LoadUint32(&o.TCTRL3.Reg) & 0x4) >> 2
}

// PIT.TFLG3: Timer Flag Register
func (o *PIT_Type) SetTFLG3_TIF(value uint32) {
	volatile.StoreUint32(&o.TFLG3.Reg, volatile.LoadUint32(&o.TFLG3.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetTFLG3_TIF() uint32 {
	return volatile.LoadUint32(&o.TFLG3.Reg) & 0x1
}

// FlexTimer Module
type FTM_Type struct {
	SC       volatile.Register32 // 0x0
	CNT      volatile.Register32 // 0x4
	MOD      volatile.Register32 // 0x8
	C0SC     volatile.Register32 // 0xC
	C0V      volatile.Register32 // 0x10
	C1SC     volatile.Register32 // 0x14
	C1V      volatile.Register32 // 0x18
	C2SC     volatile.Register32 // 0x1C
	C2V      volatile.Register32 // 0x20
	C3SC     volatile.Register32 // 0x24
	C3V      volatile.Register32 // 0x28
	C4SC     volatile.Register32 // 0x2C
	C4V      volatile.Register32 // 0x30
	C5SC     volatile.Register32 // 0x34
	C5V      volatile.Register32 // 0x38
	C6SC     volatile.Register32 // 0x3C
	C6V      volatile.Register32 // 0x40
	C7SC     volatile.Register32 // 0x44
	C7V      volatile.Register32 // 0x48
	CNTIN    volatile.Register32 // 0x4C
	STATUS   volatile.Register32 // 0x50
	MODE     volatile.Register32 // 0x54
	SYNC     volatile.Register32 // 0x58
	OUTINIT  volatile.Register32 // 0x5C
	OUTMASK  volatile.Register32 // 0x60
	COMBINE  volatile.Register32 // 0x64
	DEADTIME volatile.Register32 // 0x68
	EXTTRIG  volatile.Register32 // 0x6C
	POL      volatile.Register32 // 0x70
	FMS      volatile.Register32 // 0x74
	FILTER   volatile.Register32 // 0x78
	FLTCTRL  volatile.Register32 // 0x7C
	QDCTRL   volatile.Register32 // 0x80
	CONF     volatile.Register32 // 0x84
	FLTPOL   volatile.Register32 // 0x88
	SYNCONF  volatile.Register32 // 0x8C
	INVCTRL  volatile.Register32 // 0x90
	SWOCTRL  volatile.Register32 // 0x94
	PWMLOAD  volatile.Register32 // 0x98
}

// FTM.SC: Status And Control
func (o *FTM_Type) SetSC_PS(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x7)|value)
}
func (o *FTM_Type) GetSC_PS() uint32 {
	return volatile.LoadUint32(&o.SC.Reg) & 0x7
}
func (o *FTM_Type) SetSC_CLKS(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x18)|value<<3)
}
func (o *FTM_Type) GetSC_CLKS() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x18) >> 3
}
func (o *FTM_Type) SetSC_CPWMS(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSC_CPWMS() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSC_TOIE(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetSC_TOIE() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetSC_TOF(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSC_TOF() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x80) >> 7
}

// FTM.CNT: Counter
func (o *FTM_Type) SetCNT_COUNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetCNT_COUNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// FTM.MOD: Modulo
func (o *FTM_Type) SetMOD(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetMOD() uint32 {
	return volatile.LoadUint32(&o.MOD.Reg) & 0xffff
}

// FTM.C0SC: Channel (n) Status And Control
func (o *FTM_Type) SetC0SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC0SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C0SC.Reg) & 0x1
}
func (o *FTM_Type) SetC0SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC0SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC0SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC0SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC0SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC0SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC0SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC0SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC0SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC0SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC0SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC0SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x80) >> 7
}

// FTM.C0V: Channel (n) Value
func (o *FTM_Type) SetC0V_VAL(value uint32) {
	volatile.StoreUint32(&o.C0V.Reg, volatile.LoadUint32(&o.C0V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC0V_VAL() uint32 {
	return volatile.LoadUint32(&o.C0V.Reg) & 0xffff
}

// FTM.C1SC: Channel (n) Status And Control
func (o *FTM_Type) SetC1SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC1SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C1SC.Reg) & 0x1
}
func (o *FTM_Type) SetC1SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC1SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC1SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC1SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC1SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC1SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC1SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC1SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC1SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC1SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC1SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC1SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x80) >> 7
}

// FTM.C1V: Channel (n) Value
func (o *FTM_Type) SetC1V_VAL(value uint32) {
	volatile.StoreUint32(&o.C1V.Reg, volatile.LoadUint32(&o.C1V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC1V_VAL() uint32 {
	return volatile.LoadUint32(&o.C1V.Reg) & 0xffff
}

// FTM.C2SC: Channel (n) Status And Control
func (o *FTM_Type) SetC2SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC2SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C2SC.Reg) & 0x1
}
func (o *FTM_Type) SetC2SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC2SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC2SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC2SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC2SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC2SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC2SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC2SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC2SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC2SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC2SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C2SC.Reg, volatile.LoadUint32(&o.C2SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC2SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C2SC.Reg) & 0x80) >> 7
}

// FTM.C2V: Channel (n) Value
func (o *FTM_Type) SetC2V_VAL(value uint32) {
	volatile.StoreUint32(&o.C2V.Reg, volatile.LoadUint32(&o.C2V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC2V_VAL() uint32 {
	return volatile.LoadUint32(&o.C2V.Reg) & 0xffff
}

// FTM.C3SC: Channel (n) Status And Control
func (o *FTM_Type) SetC3SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC3SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C3SC.Reg) & 0x1
}
func (o *FTM_Type) SetC3SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC3SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC3SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC3SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC3SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC3SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC3SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC3SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC3SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC3SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC3SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C3SC.Reg, volatile.LoadUint32(&o.C3SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC3SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C3SC.Reg) & 0x80) >> 7
}

// FTM.C3V: Channel (n) Value
func (o *FTM_Type) SetC3V_VAL(value uint32) {
	volatile.StoreUint32(&o.C3V.Reg, volatile.LoadUint32(&o.C3V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC3V_VAL() uint32 {
	return volatile.LoadUint32(&o.C3V.Reg) & 0xffff
}

// FTM.C4SC: Channel (n) Status And Control
func (o *FTM_Type) SetC4SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC4SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C4SC.Reg) & 0x1
}
func (o *FTM_Type) SetC4SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC4SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC4SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC4SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC4SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC4SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC4SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC4SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC4SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC4SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC4SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C4SC.Reg, volatile.LoadUint32(&o.C4SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC4SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C4SC.Reg) & 0x80) >> 7
}

// FTM.C4V: Channel (n) Value
func (o *FTM_Type) SetC4V_VAL(value uint32) {
	volatile.StoreUint32(&o.C4V.Reg, volatile.LoadUint32(&o.C4V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC4V_VAL() uint32 {
	return volatile.LoadUint32(&o.C4V.Reg) & 0xffff
}

// FTM.C5SC: Channel (n) Status And Control
func (o *FTM_Type) SetC5SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC5SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C5SC.Reg) & 0x1
}
func (o *FTM_Type) SetC5SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC5SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC5SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC5SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC5SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC5SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC5SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC5SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC5SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC5SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC5SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C5SC.Reg, volatile.LoadUint32(&o.C5SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC5SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C5SC.Reg) & 0x80) >> 7
}

// FTM.C5V: Channel (n) Value
func (o *FTM_Type) SetC5V_VAL(value uint32) {
	volatile.StoreUint32(&o.C5V.Reg, volatile.LoadUint32(&o.C5V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC5V_VAL() uint32 {
	return volatile.LoadUint32(&o.C5V.Reg) & 0xffff
}

// FTM.C6SC: Channel (n) Status And Control
func (o *FTM_Type) SetC6SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC6SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C6SC.Reg) & 0x1
}
func (o *FTM_Type) SetC6SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC6SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC6SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC6SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC6SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC6SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC6SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC6SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC6SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC6SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC6SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C6SC.Reg, volatile.LoadUint32(&o.C6SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC6SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C6SC.Reg) & 0x80) >> 7
}

// FTM.C6V: Channel (n) Value
func (o *FTM_Type) SetC6V_VAL(value uint32) {
	volatile.StoreUint32(&o.C6V.Reg, volatile.LoadUint32(&o.C6V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC6V_VAL() uint32 {
	return volatile.LoadUint32(&o.C6V.Reg) & 0xffff
}

// FTM.C7SC: Channel (n) Status And Control
func (o *FTM_Type) SetC7SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetC7SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C7SC.Reg) & 0x1
}
func (o *FTM_Type) SetC7SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetC7SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetC7SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetC7SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetC7SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetC7SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetC7SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetC7SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetC7SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetC7SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetC7SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C7SC.Reg, volatile.LoadUint32(&o.C7SC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetC7SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C7SC.Reg) & 0x80) >> 7
}

// FTM.C7V: Channel (n) Value
func (o *FTM_Type) SetC7V_VAL(value uint32) {
	volatile.StoreUint32(&o.C7V.Reg, volatile.LoadUint32(&o.C7V.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetC7V_VAL() uint32 {
	return volatile.LoadUint32(&o.C7V.Reg) & 0xffff
}

// FTM.CNTIN: Counter Initial Value
func (o *FTM_Type) SetCNTIN_INIT(value uint32) {
	volatile.StoreUint32(&o.CNTIN.Reg, volatile.LoadUint32(&o.CNTIN.Reg)&^(0xffff)|value)
}
func (o *FTM_Type) GetCNTIN_INIT() uint32 {
	return volatile.LoadUint32(&o.CNTIN.Reg) & 0xffff
}

// FTM.STATUS: Capture And Compare Status
func (o *FTM_Type) SetSTATUS_CH0F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetSTATUS_CH0F() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *FTM_Type) SetSTATUS_CH1F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetSTATUS_CH1F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetSTATUS_CH2F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetSTATUS_CH2F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetSTATUS_CH3F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetSTATUS_CH3F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetSTATUS_CH4F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetSTATUS_CH4F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetSTATUS_CH5F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSTATUS_CH5F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSTATUS_CH6F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetSTATUS_CH6F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetSTATUS_CH7F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSTATUS_CH7F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}

// FTM.MODE: Features Mode Selection
func (o *FTM_Type) SetMODE_FTMEN(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetMODE_FTMEN() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}
func (o *FTM_Type) SetMODE_INIT(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetMODE_INIT() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetMODE_WPDIS(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetMODE_WPDIS() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetMODE_PWMSYNC(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetMODE_PWMSYNC() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetMODE_CAPTEST(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetMODE_CAPTEST() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetMODE_FAULTM(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x60)|value<<5)
}
func (o *FTM_Type) GetMODE_FAULTM() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x60) >> 5
}
func (o *FTM_Type) SetMODE_FAULTIE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetMODE_FAULTIE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x80) >> 7
}

// FTM.SYNC: Synchronization
func (o *FTM_Type) SetSYNC_CNTMIN(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetSYNC_CNTMIN() uint32 {
	return volatile.LoadUint32(&o.SYNC.Reg) & 0x1
}
func (o *FTM_Type) SetSYNC_CNTMAX(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetSYNC_CNTMAX() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetSYNC_REINIT(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetSYNC_REINIT() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetSYNC_SYNCHOM(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetSYNC_SYNCHOM() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetSYNC_TRIG0(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetSYNC_TRIG0() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetSYNC_TRIG1(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSYNC_TRIG1() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSYNC_TRIG2(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetSYNC_TRIG2() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetSYNC_SWSYNC(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSYNC_SWSYNC() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x80) >> 7
}

// FTM.OUTINIT: Initial State For Channels Output
func (o *FTM_Type) SetOUTINIT_CH0OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetOUTINIT_CH0OI() uint32 {
	return volatile.LoadUint32(&o.OUTINIT.Reg) & 0x1
}
func (o *FTM_Type) SetOUTINIT_CH1OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetOUTINIT_CH1OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetOUTINIT_CH2OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetOUTINIT_CH2OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetOUTINIT_CH3OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetOUTINIT_CH3OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetOUTINIT_CH4OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetOUTINIT_CH4OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetOUTINIT_CH5OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetOUTINIT_CH5OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetOUTINIT_CH6OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetOUTINIT_CH6OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetOUTINIT_CH7OI(value uint32) {
	volatile.StoreUint32(&o.OUTINIT.Reg, volatile.LoadUint32(&o.OUTINIT.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetOUTINIT_CH7OI() uint32 {
	return (volatile.LoadUint32(&o.OUTINIT.Reg) & 0x80) >> 7
}

// FTM.OUTMASK: Output Mask
func (o *FTM_Type) SetOUTMASK_CH0OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetOUTMASK_CH0OM() uint32 {
	return volatile.LoadUint32(&o.OUTMASK.Reg) & 0x1
}
func (o *FTM_Type) SetOUTMASK_CH1OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetOUTMASK_CH1OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetOUTMASK_CH2OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetOUTMASK_CH2OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetOUTMASK_CH3OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetOUTMASK_CH3OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetOUTMASK_CH4OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetOUTMASK_CH4OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetOUTMASK_CH5OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetOUTMASK_CH5OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetOUTMASK_CH6OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetOUTMASK_CH6OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetOUTMASK_CH7OM(value uint32) {
	volatile.StoreUint32(&o.OUTMASK.Reg, volatile.LoadUint32(&o.OUTMASK.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetOUTMASK_CH7OM() uint32 {
	return (volatile.LoadUint32(&o.OUTMASK.Reg) & 0x80) >> 7
}

// FTM.COMBINE: Function For Linked Channels
func (o *FTM_Type) SetCOMBINE_COMBINE0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetCOMBINE_COMBINE0() uint32 {
	return volatile.LoadUint32(&o.COMBINE.Reg) & 0x1
}
func (o *FTM_Type) SetCOMBINE_COMP0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetCOMBINE_COMP0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetCOMBINE_DECAPEN0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetCOMBINE_DECAPEN0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetCOMBINE_DECAP0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetCOMBINE_DECAP0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetCOMBINE_DTEN0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetCOMBINE_DTEN0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetCOMBINE_SYNCEN0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetCOMBINE_SYNCEN0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetCOMBINE_FAULTEN0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetCOMBINE_FAULTEN0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetCOMBINE_COMBINE1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x100)|value<<8)
}
func (o *FTM_Type) GetCOMBINE_COMBINE1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x100) >> 8
}
func (o *FTM_Type) SetCOMBINE_COMP1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetCOMBINE_COMP1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x200) >> 9
}
func (o *FTM_Type) SetCOMBINE_DECAPEN1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x400)|value<<10)
}
func (o *FTM_Type) GetCOMBINE_DECAPEN1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x400) >> 10
}
func (o *FTM_Type) SetCOMBINE_DECAP1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x800)|value<<11)
}
func (o *FTM_Type) GetCOMBINE_DECAP1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x800) >> 11
}
func (o *FTM_Type) SetCOMBINE_DTEN1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x1000)|value<<12)
}
func (o *FTM_Type) GetCOMBINE_DTEN1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x1000) >> 12
}
func (o *FTM_Type) SetCOMBINE_SYNCEN1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x2000)|value<<13)
}
func (o *FTM_Type) GetCOMBINE_SYNCEN1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x2000) >> 13
}
func (o *FTM_Type) SetCOMBINE_FAULTEN1(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x4000)|value<<14)
}
func (o *FTM_Type) GetCOMBINE_FAULTEN1() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x4000) >> 14
}
func (o *FTM_Type) SetCOMBINE_COMBINE2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x10000)|value<<16)
}
func (o *FTM_Type) GetCOMBINE_COMBINE2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x10000) >> 16
}
func (o *FTM_Type) SetCOMBINE_COMP2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x20000)|value<<17)
}
func (o *FTM_Type) GetCOMBINE_COMP2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x20000) >> 17
}
func (o *FTM_Type) SetCOMBINE_DECAPEN2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x40000)|value<<18)
}
func (o *FTM_Type) GetCOMBINE_DECAPEN2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x40000) >> 18
}
func (o *FTM_Type) SetCOMBINE_DECAP2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x80000)|value<<19)
}
func (o *FTM_Type) GetCOMBINE_DECAP2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x80000) >> 19
}
func (o *FTM_Type) SetCOMBINE_DTEN2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x100000)|value<<20)
}
func (o *FTM_Type) GetCOMBINE_DTEN2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x100000) >> 20
}
func (o *FTM_Type) SetCOMBINE_SYNCEN2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x200000)|value<<21)
}
func (o *FTM_Type) GetCOMBINE_SYNCEN2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x200000) >> 21
}
func (o *FTM_Type) SetCOMBINE_FAULTEN2(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x400000)|value<<22)
}
func (o *FTM_Type) GetCOMBINE_FAULTEN2() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x400000) >> 22
}
func (o *FTM_Type) SetCOMBINE_COMBINE3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x1000000)|value<<24)
}
func (o *FTM_Type) GetCOMBINE_COMBINE3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x1000000) >> 24
}
func (o *FTM_Type) SetCOMBINE_COMP3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x2000000)|value<<25)
}
func (o *FTM_Type) GetCOMBINE_COMP3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x2000000) >> 25
}
func (o *FTM_Type) SetCOMBINE_DECAPEN3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x4000000)|value<<26)
}
func (o *FTM_Type) GetCOMBINE_DECAPEN3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x4000000) >> 26
}
func (o *FTM_Type) SetCOMBINE_DECAP3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x8000000)|value<<27)
}
func (o *FTM_Type) GetCOMBINE_DECAP3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x8000000) >> 27
}
func (o *FTM_Type) SetCOMBINE_DTEN3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x10000000)|value<<28)
}
func (o *FTM_Type) GetCOMBINE_DTEN3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x10000000) >> 28
}
func (o *FTM_Type) SetCOMBINE_SYNCEN3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x20000000)|value<<29)
}
func (o *FTM_Type) GetCOMBINE_SYNCEN3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x20000000) >> 29
}
func (o *FTM_Type) SetCOMBINE_FAULTEN3(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x40000000)|value<<30)
}
func (o *FTM_Type) GetCOMBINE_FAULTEN3() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x40000000) >> 30
}

// FTM.DEADTIME: Deadtime Insertion Control
func (o *FTM_Type) SetDEADTIME_DTVAL(value uint32) {
	volatile.StoreUint32(&o.DEADTIME.Reg, volatile.LoadUint32(&o.DEADTIME.Reg)&^(0x3f)|value)
}
func (o *FTM_Type) GetDEADTIME_DTVAL() uint32 {
	return volatile.LoadUint32(&o.DEADTIME.Reg) & 0x3f
}
func (o *FTM_Type) SetDEADTIME_DTPS(value uint32) {
	volatile.StoreUint32(&o.DEADTIME.Reg, volatile.LoadUint32(&o.DEADTIME.Reg)&^(0xc0)|value<<6)
}
func (o *FTM_Type) GetDEADTIME_DTPS() uint32 {
	return (volatile.LoadUint32(&o.DEADTIME.Reg) & 0xc0) >> 6
}

// FTM.EXTTRIG: FTM External Trigger
func (o *FTM_Type) SetEXTTRIG_CH2TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetEXTTRIG_CH2TRIG() uint32 {
	return volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x1
}
func (o *FTM_Type) SetEXTTRIG_CH3TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetEXTTRIG_CH3TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetEXTTRIG_CH4TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetEXTTRIG_CH4TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetEXTTRIG_CH5TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetEXTTRIG_CH5TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetEXTTRIG_CH0TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetEXTTRIG_CH0TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetEXTTRIG_CH1TRIG(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetEXTTRIG_CH1TRIG() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetEXTTRIG_INITTRIGEN(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetEXTTRIG_INITTRIGEN() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetEXTTRIG_TRIGF(value uint32) {
	volatile.StoreUint32(&o.EXTTRIG.Reg, volatile.LoadUint32(&o.EXTTRIG.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetEXTTRIG_TRIGF() uint32 {
	return (volatile.LoadUint32(&o.EXTTRIG.Reg) & 0x80) >> 7
}

// FTM.POL: Channels Polarity
func (o *FTM_Type) SetPOL_POL0(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetPOL_POL0() uint32 {
	return volatile.LoadUint32(&o.POL.Reg) & 0x1
}
func (o *FTM_Type) SetPOL_POL1(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetPOL_POL1() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetPOL_POL2(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetPOL_POL2() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetPOL_POL3(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetPOL_POL3() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetPOL_POL4(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetPOL_POL4() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetPOL_POL5(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetPOL_POL5() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetPOL_POL6(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetPOL_POL6() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetPOL_POL7(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetPOL_POL7() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x80) >> 7
}

// FTM.FMS: Fault Mode Status
func (o *FTM_Type) SetFMS_FAULTF0(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetFMS_FAULTF0() uint32 {
	return volatile.LoadUint32(&o.FMS.Reg) & 0x1
}
func (o *FTM_Type) SetFMS_FAULTF1(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetFMS_FAULTF1() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetFMS_FAULTF2(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetFMS_FAULTF2() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetFMS_FAULTF3(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetFMS_FAULTF3() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetFMS_FAULTIN(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetFMS_FAULTIN() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetFMS_WPEN(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetFMS_WPEN() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetFMS_FAULTF(value uint32) {
	volatile.StoreUint32(&o.FMS.Reg, volatile.LoadUint32(&o.FMS.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetFMS_FAULTF() uint32 {
	return (volatile.LoadUint32(&o.FMS.Reg) & 0x80) >> 7
}

// FTM.FILTER: Input Capture Filter Control
func (o *FTM_Type) SetFILTER_CH0FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf)|value)
}
func (o *FTM_Type) GetFILTER_CH0FVAL() uint32 {
	return volatile.LoadUint32(&o.FILTER.Reg) & 0xf
}
func (o *FTM_Type) SetFILTER_CH1FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf0)|value<<4)
}
func (o *FTM_Type) GetFILTER_CH1FVAL() uint32 {
	return (volatile.LoadUint32(&o.FILTER.Reg) & 0xf0) >> 4
}
func (o *FTM_Type) SetFILTER_CH2FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf00)|value<<8)
}
func (o *FTM_Type) GetFILTER_CH2FVAL() uint32 {
	return (volatile.LoadUint32(&o.FILTER.Reg) & 0xf00) >> 8
}
func (o *FTM_Type) SetFILTER_CH3FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf000)|value<<12)
}
func (o *FTM_Type) GetFILTER_CH3FVAL() uint32 {
	return (volatile.LoadUint32(&o.FILTER.Reg) & 0xf000) >> 12
}

// FTM.FLTCTRL: Fault Control
func (o *FTM_Type) SetFLTCTRL_FAULT0EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetFLTCTRL_FAULT0EN() uint32 {
	return volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x1
}
func (o *FTM_Type) SetFLTCTRL_FAULT1EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetFLTCTRL_FAULT1EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetFLTCTRL_FAULT2EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetFLTCTRL_FAULT2EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetFLTCTRL_FAULT3EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetFLTCTRL_FAULT3EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetFLTCTRL_FFLTR0EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetFLTCTRL_FFLTR0EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetFLTCTRL_FFLTR1EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetFLTCTRL_FFLTR1EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetFLTCTRL_FFLTR2EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetFLTCTRL_FFLTR2EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetFLTCTRL_FFLTR3EN(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetFLTCTRL_FFLTR3EN() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0x80) >> 7
}
func (o *FTM_Type) SetFLTCTRL_FFVAL(value uint32) {
	volatile.StoreUint32(&o.FLTCTRL.Reg, volatile.LoadUint32(&o.FLTCTRL.Reg)&^(0xf00)|value<<8)
}
func (o *FTM_Type) GetFLTCTRL_FFVAL() uint32 {
	return (volatile.LoadUint32(&o.FLTCTRL.Reg) & 0xf00) >> 8
}

// FTM.QDCTRL: Quadrature Decoder Control And Status
func (o *FTM_Type) SetQDCTRL_QUADEN(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetQDCTRL_QUADEN() uint32 {
	return volatile.LoadUint32(&o.QDCTRL.Reg) & 0x1
}
func (o *FTM_Type) SetQDCTRL_TOFDIR(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetQDCTRL_TOFDIR() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetQDCTRL_QUADIR(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetQDCTRL_QUADIR() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetQDCTRL_QUADMODE(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetQDCTRL_QUADMODE() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetQDCTRL_PHBPOL(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetQDCTRL_PHBPOL() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetQDCTRL_PHAPOL(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetQDCTRL_PHAPOL() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetQDCTRL_PHBFLTREN(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetQDCTRL_PHBFLTREN() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetQDCTRL_PHAFLTREN(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetQDCTRL_PHAFLTREN() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x80) >> 7
}

// FTM.CONF: Configuration
func (o *FTM_Type) SetCONF_NUMTOF(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1f)|value)
}
func (o *FTM_Type) GetCONF_NUMTOF() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x1f
}
func (o *FTM_Type) SetCONF_BDMMODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xc0)|value<<6)
}
func (o *FTM_Type) GetCONF_BDMMODE() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xc0) >> 6
}
func (o *FTM_Type) SetCONF_GTBEEN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetCONF_GTBEEN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x200) >> 9
}
func (o *FTM_Type) SetCONF_GTBEOUT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x400)|value<<10)
}
func (o *FTM_Type) GetCONF_GTBEOUT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x400) >> 10
}

// FTM.FLTPOL: FTM Fault Input Polarity
func (o *FTM_Type) SetFLTPOL_FLT0POL(value uint32) {
	volatile.StoreUint32(&o.FLTPOL.Reg, volatile.LoadUint32(&o.FLTPOL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetFLTPOL_FLT0POL() uint32 {
	return volatile.LoadUint32(&o.FLTPOL.Reg) & 0x1
}
func (o *FTM_Type) SetFLTPOL_FLT1POL(value uint32) {
	volatile.StoreUint32(&o.FLTPOL.Reg, volatile.LoadUint32(&o.FLTPOL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetFLTPOL_FLT1POL() uint32 {
	return (volatile.LoadUint32(&o.FLTPOL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetFLTPOL_FLT2POL(value uint32) {
	volatile.StoreUint32(&o.FLTPOL.Reg, volatile.LoadUint32(&o.FLTPOL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetFLTPOL_FLT2POL() uint32 {
	return (volatile.LoadUint32(&o.FLTPOL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetFLTPOL_FLT3POL(value uint32) {
	volatile.StoreUint32(&o.FLTPOL.Reg, volatile.LoadUint32(&o.FLTPOL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetFLTPOL_FLT3POL() uint32 {
	return (volatile.LoadUint32(&o.FLTPOL.Reg) & 0x8) >> 3
}

// FTM.SYNCONF: Synchronization Configuration
func (o *FTM_Type) SetSYNCONF_HWTRIGMODE(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetSYNCONF_HWTRIGMODE() uint32 {
	return volatile.LoadUint32(&o.SYNCONF.Reg) & 0x1
}
func (o *FTM_Type) SetSYNCONF_CNTINC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetSYNCONF_CNTINC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetSYNCONF_INVC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetSYNCONF_INVC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetSYNCONF_SWOC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSYNCONF_SWOC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSYNCONF_SYNCMODE(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSYNCONF_SYNCMODE() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x80) >> 7
}
func (o *FTM_Type) SetSYNCONF_SWRSTCNT(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x100)|value<<8)
}
func (o *FTM_Type) GetSYNCONF_SWRSTCNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x100) >> 8
}
func (o *FTM_Type) SetSYNCONF_SWWRBUF(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetSYNCONF_SWWRBUF() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x200) >> 9
}
func (o *FTM_Type) SetSYNCONF_SWOM(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x400)|value<<10)
}
func (o *FTM_Type) GetSYNCONF_SWOM() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x400) >> 10
}
func (o *FTM_Type) SetSYNCONF_SWINVC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x800)|value<<11)
}
func (o *FTM_Type) GetSYNCONF_SWINVC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x800) >> 11
}
func (o *FTM_Type) SetSYNCONF_SWSOC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x1000)|value<<12)
}
func (o *FTM_Type) GetSYNCONF_SWSOC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x1000) >> 12
}
func (o *FTM_Type) SetSYNCONF_HWRSTCNT(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x10000)|value<<16)
}
func (o *FTM_Type) GetSYNCONF_HWRSTCNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x10000) >> 16
}
func (o *FTM_Type) SetSYNCONF_HWWRBUF(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x20000)|value<<17)
}
func (o *FTM_Type) GetSYNCONF_HWWRBUF() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x20000) >> 17
}
func (o *FTM_Type) SetSYNCONF_HWOM(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x40000)|value<<18)
}
func (o *FTM_Type) GetSYNCONF_HWOM() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x40000) >> 18
}
func (o *FTM_Type) SetSYNCONF_HWINVC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x80000)|value<<19)
}
func (o *FTM_Type) GetSYNCONF_HWINVC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x80000) >> 19
}
func (o *FTM_Type) SetSYNCONF_HWSOC(value uint32) {
	volatile.StoreUint32(&o.SYNCONF.Reg, volatile.LoadUint32(&o.SYNCONF.Reg)&^(0x100000)|value<<20)
}
func (o *FTM_Type) GetSYNCONF_HWSOC() uint32 {
	return (volatile.LoadUint32(&o.SYNCONF.Reg) & 0x100000) >> 20
}

// FTM.INVCTRL: FTM Inverting Control
func (o *FTM_Type) SetINVCTRL_INV0EN(value uint32) {
	volatile.StoreUint32(&o.INVCTRL.Reg, volatile.LoadUint32(&o.INVCTRL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetINVCTRL_INV0EN() uint32 {
	return volatile.LoadUint32(&o.INVCTRL.Reg) & 0x1
}
func (o *FTM_Type) SetINVCTRL_INV1EN(value uint32) {
	volatile.StoreUint32(&o.INVCTRL.Reg, volatile.LoadUint32(&o.INVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetINVCTRL_INV1EN() uint32 {
	return (volatile.LoadUint32(&o.INVCTRL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetINVCTRL_INV2EN(value uint32) {
	volatile.StoreUint32(&o.INVCTRL.Reg, volatile.LoadUint32(&o.INVCTRL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetINVCTRL_INV2EN() uint32 {
	return (volatile.LoadUint32(&o.INVCTRL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetINVCTRL_INV3EN(value uint32) {
	volatile.StoreUint32(&o.INVCTRL.Reg, volatile.LoadUint32(&o.INVCTRL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetINVCTRL_INV3EN() uint32 {
	return (volatile.LoadUint32(&o.INVCTRL.Reg) & 0x8) >> 3
}

// FTM.SWOCTRL: FTM Software Output Control
func (o *FTM_Type) SetSWOCTRL_CH0OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetSWOCTRL_CH0OC() uint32 {
	return volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x1
}
func (o *FTM_Type) SetSWOCTRL_CH1OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetSWOCTRL_CH1OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetSWOCTRL_CH2OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetSWOCTRL_CH2OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetSWOCTRL_CH3OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetSWOCTRL_CH3OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetSWOCTRL_CH4OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetSWOCTRL_CH4OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetSWOCTRL_CH5OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetSWOCTRL_CH5OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetSWOCTRL_CH6OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetSWOCTRL_CH6OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetSWOCTRL_CH7OC(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetSWOCTRL_CH7OC() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x80) >> 7
}
func (o *FTM_Type) SetSWOCTRL_CH0OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x100)|value<<8)
}
func (o *FTM_Type) GetSWOCTRL_CH0OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x100) >> 8
}
func (o *FTM_Type) SetSWOCTRL_CH1OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetSWOCTRL_CH1OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x200) >> 9
}
func (o *FTM_Type) SetSWOCTRL_CH2OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x400)|value<<10)
}
func (o *FTM_Type) GetSWOCTRL_CH2OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x400) >> 10
}
func (o *FTM_Type) SetSWOCTRL_CH3OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x800)|value<<11)
}
func (o *FTM_Type) GetSWOCTRL_CH3OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x800) >> 11
}
func (o *FTM_Type) SetSWOCTRL_CH4OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *FTM_Type) GetSWOCTRL_CH4OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x1000) >> 12
}
func (o *FTM_Type) SetSWOCTRL_CH5OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *FTM_Type) GetSWOCTRL_CH5OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x2000) >> 13
}
func (o *FTM_Type) SetSWOCTRL_CH6OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *FTM_Type) GetSWOCTRL_CH6OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x4000) >> 14
}
func (o *FTM_Type) SetSWOCTRL_CH7OCV(value uint32) {
	volatile.StoreUint32(&o.SWOCTRL.Reg, volatile.LoadUint32(&o.SWOCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *FTM_Type) GetSWOCTRL_CH7OCV() uint32 {
	return (volatile.LoadUint32(&o.SWOCTRL.Reg) & 0x8000) >> 15
}

// FTM.PWMLOAD: FTM PWM Load
func (o *FTM_Type) SetPWMLOAD_CH0SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x1)|value)
}
func (o *FTM_Type) GetPWMLOAD_CH0SEL() uint32 {
	return volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x1
}
func (o *FTM_Type) SetPWMLOAD_CH1SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x2)|value<<1)
}
func (o *FTM_Type) GetPWMLOAD_CH1SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x2) >> 1
}
func (o *FTM_Type) SetPWMLOAD_CH2SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x4)|value<<2)
}
func (o *FTM_Type) GetPWMLOAD_CH2SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x4) >> 2
}
func (o *FTM_Type) SetPWMLOAD_CH3SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x8)|value<<3)
}
func (o *FTM_Type) GetPWMLOAD_CH3SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x8) >> 3
}
func (o *FTM_Type) SetPWMLOAD_CH4SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x10)|value<<4)
}
func (o *FTM_Type) GetPWMLOAD_CH4SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x10) >> 4
}
func (o *FTM_Type) SetPWMLOAD_CH5SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x20)|value<<5)
}
func (o *FTM_Type) GetPWMLOAD_CH5SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x20) >> 5
}
func (o *FTM_Type) SetPWMLOAD_CH6SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x40)|value<<6)
}
func (o *FTM_Type) GetPWMLOAD_CH6SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x40) >> 6
}
func (o *FTM_Type) SetPWMLOAD_CH7SEL(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x80)|value<<7)
}
func (o *FTM_Type) GetPWMLOAD_CH7SEL() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x80) >> 7
}
func (o *FTM_Type) SetPWMLOAD_LDOK(value uint32) {
	volatile.StoreUint32(&o.PWMLOAD.Reg, volatile.LoadUint32(&o.PWMLOAD.Reg)&^(0x200)|value<<9)
}
func (o *FTM_Type) GetPWMLOAD_LDOK() uint32 {
	return (volatile.LoadUint32(&o.PWMLOAD.Reg) & 0x200) >> 9
}

// Analog-to-Digital Converter
type ADC_Type struct {
	SC1A volatile.Register32 // 0x0
	SC1B volatile.Register32 // 0x4
	CFG1 volatile.Register32 // 0x8
	CFG2 volatile.Register32 // 0xC
	RA   volatile.Register32 // 0x10
	RB   volatile.Register32 // 0x14
	CV1  volatile.Register32 // 0x18
	CV2  volatile.Register32 // 0x1C
	SC2  volatile.Register32 // 0x20
	SC3  volatile.Register32 // 0x24
	OFS  volatile.Register32 // 0x28
	PG   volatile.Register32 // 0x2C
	MG   volatile.Register32 // 0x30
	CLPD volatile.Register32 // 0x34
	CLPS volatile.Register32 // 0x38
	CLP4 volatile.Register32 // 0x3C
	CLP3 volatile.Register32 // 0x40
	CLP2 volatile.Register32 // 0x44
	CLP1 volatile.Register32 // 0x48
	CLP0 volatile.Register32 // 0x4C
	_    [4]byte
	CLMD volatile.Register32 // 0x54
	CLMS volatile.Register32 // 0x58
	CLM4 volatile.Register32 // 0x5C
	CLM3 volatile.Register32 // 0x60
	CLM2 volatile.Register32 // 0x64
	CLM1 volatile.Register32 // 0x68
	CLM0 volatile.Register32 // 0x6C
}

// ADC.SC1A: ADC Status and Control Registers 1
func (o *ADC_Type) SetSC1A_ADCH(value uint32) {
	volatile.StoreUint32(&o.SC1A.Reg, volatile.LoadUint32(&o.SC1A.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSC1A_ADCH() uint32 {
	return volatile.LoadUint32(&o.SC1A.Reg) & 0x1f
}
func (o *ADC_Type) SetSC1A_DIFF(value uint32) {
	volatile.StoreUint32(&o.SC1A.Reg, volatile.LoadUint32(&o.SC1A.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetSC1A_DIFF() uint32 {
	return (volatile.LoadUint32(&o.SC1A.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetSC1A_AIEN(value uint32) {
	volatile.StoreUint32(&o.SC1A.Reg, volatile.LoadUint32(&o.SC1A.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSC1A_AIEN() uint32 {
	return (volatile.LoadUint32(&o.SC1A.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSC1A_COCO(value uint32) {
	volatile.StoreUint32(&o.SC1A.Reg, volatile.LoadUint32(&o.SC1A.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSC1A_COCO() uint32 {
	return (volatile.LoadUint32(&o.SC1A.Reg) & 0x80) >> 7
}

// ADC.SC1B: ADC Status and Control Registers 1
func (o *ADC_Type) SetSC1B_ADCH(value uint32) {
	volatile.StoreUint32(&o.SC1B.Reg, volatile.LoadUint32(&o.SC1B.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSC1B_ADCH() uint32 {
	return volatile.LoadUint32(&o.SC1B.Reg) & 0x1f
}
func (o *ADC_Type) SetSC1B_DIFF(value uint32) {
	volatile.StoreUint32(&o.SC1B.Reg, volatile.LoadUint32(&o.SC1B.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetSC1B_DIFF() uint32 {
	return (volatile.LoadUint32(&o.SC1B.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetSC1B_AIEN(value uint32) {
	volatile.StoreUint32(&o.SC1B.Reg, volatile.LoadUint32(&o.SC1B.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSC1B_AIEN() uint32 {
	return (volatile.LoadUint32(&o.SC1B.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSC1B_COCO(value uint32) {
	volatile.StoreUint32(&o.SC1B.Reg, volatile.LoadUint32(&o.SC1B.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSC1B_COCO() uint32 {
	return (volatile.LoadUint32(&o.SC1B.Reg) & 0x80) >> 7
}

// ADC.CFG1: ADC Configuration Register 1
func (o *ADC_Type) SetCFG1_ADICLK(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetCFG1_ADICLK() uint32 {
	return volatile.LoadUint32(&o.CFG1.Reg) & 0x3
}
func (o *ADC_Type) SetCFG1_MODE(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xc)|value<<2)
}
func (o *ADC_Type) GetCFG1_MODE() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xc) >> 2
}
func (o *ADC_Type) SetCFG1_ADLSMP(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCFG1_ADLSMP() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCFG1_ADIV(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x60)|value<<5)
}
func (o *ADC_Type) GetCFG1_ADIV() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x60) >> 5
}
func (o *ADC_Type) SetCFG1_ADLPC(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCFG1_ADLPC() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x80) >> 7
}

// ADC.CFG2: ADC Configuration Register 2
func (o *ADC_Type) SetCFG2_ADLSTS(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetCFG2_ADLSTS() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0x3
}
func (o *ADC_Type) SetCFG2_ADHSC(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCFG2_ADHSC() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCFG2_ADACKEN(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCFG2_ADACKEN() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCFG2_MUXSEL(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCFG2_MUXSEL() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x10) >> 4
}

// ADC.RA: ADC Data Result Register
func (o *ADC_Type) SetRA_D(value uint32) {
	volatile.StoreUint32(&o.RA.Reg, volatile.LoadUint32(&o.RA.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetRA_D() uint32 {
	return volatile.LoadUint32(&o.RA.Reg) & 0xffff
}

// ADC.RB: ADC Data Result Register
func (o *ADC_Type) SetRB_D(value uint32) {
	volatile.StoreUint32(&o.RB.Reg, volatile.LoadUint32(&o.RB.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetRB_D() uint32 {
	return volatile.LoadUint32(&o.RB.Reg) & 0xffff
}

// ADC.CV1: Compare Value Registers
func (o *ADC_Type) SetCV1_CV(value uint32) {
	volatile.StoreUint32(&o.CV1.Reg, volatile.LoadUint32(&o.CV1.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetCV1_CV() uint32 {
	return volatile.LoadUint32(&o.CV1.Reg) & 0xffff
}

// ADC.CV2: Compare Value Registers
func (o *ADC_Type) SetCV2_CV(value uint32) {
	volatile.StoreUint32(&o.CV2.Reg, volatile.LoadUint32(&o.CV2.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetCV2_CV() uint32 {
	return volatile.LoadUint32(&o.CV2.Reg) & 0xffff
}

// ADC.SC2: Status and Control Register 2
func (o *ADC_Type) SetSC2_REFSEL(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetSC2_REFSEL() uint32 {
	return volatile.LoadUint32(&o.SC2.Reg) & 0x3
}
func (o *ADC_Type) SetSC2_DMAEN(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetSC2_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetSC2_ACREN(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetSC2_ACREN() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetSC2_ACFGT(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetSC2_ACFGT() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetSC2_ACFE(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetSC2_ACFE() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetSC2_ADTRG(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSC2_ADTRG() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSC2_ADACT(value uint32) {
	volatile.StoreUint32(&o.SC2.Reg, volatile.LoadUint32(&o.SC2.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSC2_ADACT() uint32 {
	return (volatile.LoadUint32(&o.SC2.Reg) & 0x80) >> 7
}

// ADC.SC3: Status and Control Register 3
func (o *ADC_Type) SetSC3_AVGS(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetSC3_AVGS() uint32 {
	return volatile.LoadUint32(&o.SC3.Reg) & 0x3
}
func (o *ADC_Type) SetSC3_AVGE(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetSC3_AVGE() uint32 {
	return (volatile.LoadUint32(&o.SC3.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetSC3_ADCO(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetSC3_ADCO() uint32 {
	return (volatile.LoadUint32(&o.SC3.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetSC3_CALF(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSC3_CALF() uint32 {
	return (volatile.LoadUint32(&o.SC3.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSC3_CAL(value uint32) {
	volatile.StoreUint32(&o.SC3.Reg, volatile.LoadUint32(&o.SC3.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSC3_CAL() uint32 {
	return (volatile.LoadUint32(&o.SC3.Reg) & 0x80) >> 7
}

// ADC.OFS: ADC Offset Correction Register
func (o *ADC_Type) SetOFS(value uint32) {
	volatile.StoreUint32(&o.OFS.Reg, volatile.LoadUint32(&o.OFS.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetOFS() uint32 {
	return volatile.LoadUint32(&o.OFS.Reg) & 0xffff
}

// ADC.PG: ADC Plus-Side Gain Register
func (o *ADC_Type) SetPG(value uint32) {
	volatile.StoreUint32(&o.PG.Reg, volatile.LoadUint32(&o.PG.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetPG() uint32 {
	return volatile.LoadUint32(&o.PG.Reg) & 0xffff
}

// ADC.MG: ADC Minus-Side Gain Register
func (o *ADC_Type) SetMG(value uint32) {
	volatile.StoreUint32(&o.MG.Reg, volatile.LoadUint32(&o.MG.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetMG() uint32 {
	return volatile.LoadUint32(&o.MG.Reg) & 0xffff
}

// ADC.CLPD: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLPD(value uint32) {
	volatile.StoreUint32(&o.CLPD.Reg, volatile.LoadUint32(&o.CLPD.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLPD() uint32 {
	return volatile.LoadUint32(&o.CLPD.Reg) & 0x3f
}

// ADC.CLPS: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLPS(value uint32) {
	volatile.StoreUint32(&o.CLPS.Reg, volatile.LoadUint32(&o.CLPS.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLPS() uint32 {
	return volatile.LoadUint32(&o.CLPS.Reg) & 0x3f
}

// ADC.CLP4: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP4(value uint32) {
	volatile.StoreUint32(&o.CLP4.Reg, volatile.LoadUint32(&o.CLP4.Reg)&^(0x3ff)|value)
}
func (o *ADC_Type) GetCLP4() uint32 {
	return volatile.LoadUint32(&o.CLP4.Reg) & 0x3ff
}

// ADC.CLP3: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP3(value uint32) {
	volatile.StoreUint32(&o.CLP3.Reg, volatile.LoadUint32(&o.CLP3.Reg)&^(0x1ff)|value)
}
func (o *ADC_Type) GetCLP3() uint32 {
	return volatile.LoadUint32(&o.CLP3.Reg) & 0x1ff
}

// ADC.CLP2: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP2(value uint32) {
	volatile.StoreUint32(&o.CLP2.Reg, volatile.LoadUint32(&o.CLP2.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetCLP2() uint32 {
	return volatile.LoadUint32(&o.CLP2.Reg) & 0xff
}

// ADC.CLP1: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP1(value uint32) {
	volatile.StoreUint32(&o.CLP1.Reg, volatile.LoadUint32(&o.CLP1.Reg)&^(0x7f)|value)
}
func (o *ADC_Type) GetCLP1() uint32 {
	return volatile.LoadUint32(&o.CLP1.Reg) & 0x7f
}

// ADC.CLP0: ADC Plus-Side General Calibration Value Register
func (o *ADC_Type) SetCLP0(value uint32) {
	volatile.StoreUint32(&o.CLP0.Reg, volatile.LoadUint32(&o.CLP0.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLP0() uint32 {
	return volatile.LoadUint32(&o.CLP0.Reg) & 0x3f
}

// ADC.CLMD: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLMD(value uint32) {
	volatile.StoreUint32(&o.CLMD.Reg, volatile.LoadUint32(&o.CLMD.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLMD() uint32 {
	return volatile.LoadUint32(&o.CLMD.Reg) & 0x3f
}

// ADC.CLMS: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLMS(value uint32) {
	volatile.StoreUint32(&o.CLMS.Reg, volatile.LoadUint32(&o.CLMS.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLMS() uint32 {
	return volatile.LoadUint32(&o.CLMS.Reg) & 0x3f
}

// ADC.CLM4: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM4(value uint32) {
	volatile.StoreUint32(&o.CLM4.Reg, volatile.LoadUint32(&o.CLM4.Reg)&^(0x3ff)|value)
}
func (o *ADC_Type) GetCLM4() uint32 {
	return volatile.LoadUint32(&o.CLM4.Reg) & 0x3ff
}

// ADC.CLM3: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM3(value uint32) {
	volatile.StoreUint32(&o.CLM3.Reg, volatile.LoadUint32(&o.CLM3.Reg)&^(0x1ff)|value)
}
func (o *ADC_Type) GetCLM3() uint32 {
	return volatile.LoadUint32(&o.CLM3.Reg) & 0x1ff
}

// ADC.CLM2: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM2(value uint32) {
	volatile.StoreUint32(&o.CLM2.Reg, volatile.LoadUint32(&o.CLM2.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetCLM2() uint32 {
	return volatile.LoadUint32(&o.CLM2.Reg) & 0xff
}

// ADC.CLM1: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM1(value uint32) {
	volatile.StoreUint32(&o.CLM1.Reg, volatile.LoadUint32(&o.CLM1.Reg)&^(0x7f)|value)
}
func (o *ADC_Type) GetCLM1() uint32 {
	return volatile.LoadUint32(&o.CLM1.Reg) & 0x7f
}

// ADC.CLM0: ADC Minus-Side General Calibration Value Register
func (o *ADC_Type) SetCLM0(value uint32) {
	volatile.StoreUint32(&o.CLM0.Reg, volatile.LoadUint32(&o.CLM0.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetCLM0() uint32 {
	return volatile.LoadUint32(&o.CLM0.Reg) & 0x3f
}

// Secure Real Time Clock
type RTC_Type struct {
	TSR  volatile.Register32 // 0x0
	TPR  volatile.Register32 // 0x4
	TAR  volatile.Register32 // 0x8
	TCR  volatile.Register32 // 0xC
	CR   volatile.Register32 // 0x10
	SR   volatile.Register32 // 0x14
	LR   volatile.Register32 // 0x18
	IER  volatile.Register32 // 0x1C
	TTSR volatile.Register32 // 0x20
	MER  volatile.Register32 // 0x24
	MCLR volatile.Register32 // 0x28
	MCHR volatile.Register32 // 0x2C
	_    [2000]byte
	WAR  volatile.Register32 // 0x800
	RAR  volatile.Register32 // 0x804
}

// RTC.TSR: RTC Time Seconds Register
func (o *RTC_Type) SetTSR(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, value)
}
func (o *RTC_Type) GetTSR() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg)
}

// RTC.TPR: RTC Time Prescaler Register
func (o *RTC_Type) SetTPR(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, volatile.LoadUint32(&o.TPR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetTPR() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg) & 0xffff
}

// RTC.TAR: RTC Time Alarm Register
func (o *RTC_Type) SetTAR(value uint32) {
	volatile.StoreUint32(&o.TAR.Reg, value)
}
func (o *RTC_Type) GetTAR() uint32 {
	return volatile.LoadUint32(&o.TAR.Reg)
}

// RTC.TCR: RTC Time Compensation Register
func (o *RTC_Type) SetTCR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetTCR() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xff
}
func (o *RTC_Type) SetTCR_CIR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_Type) GetTCR_CIR() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xff00) >> 8
}
func (o *RTC_Type) SetTCR_TCV(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xff0000)|value<<16)
}
func (o *RTC_Type) GetTCR_TCV() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xff0000) >> 16
}
func (o *RTC_Type) SetTCR_CIC(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_Type) GetTCR_CIC() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xff000000) >> 24
}

// RTC.CR: RTC Control Register
func (o *RTC_Type) SetCR_SWR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCR_SWR() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RTC_Type) SetCR_WPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCR_WPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCR_SUP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetCR_SUP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetCR_UM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCR_UM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetCR_WPS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCR_WPS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCR_OSCE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetCR_OSCE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetCR_CLKO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetCR_CLKO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetCR_SC16P(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetCR_SC16P() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetCR_SC8P(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetCR_SC8P() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetCR_SC4P(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetCR_SC4P() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetCR_SC2P(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCR_SC2P() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}

// RTC.SR: RTC Status Register
func (o *RTC_Type) SetSR_TIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSR_TIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RTC_Type) SetSR_TOF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSR_TOF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSR_TAF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSR_TAF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSR_MOF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSR_MOF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetSR_TCE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSR_TCE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}

// RTC.LR: RTC Lock Register
func (o *RTC_Type) SetLR_TCL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetLR_TCL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetLR_CRL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetLR_CRL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetLR_SRL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetLR_SRL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetLR_LRL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetLR_LRL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetLR_TTSL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetLR_TTSL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetLR_MEL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetLR_MEL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetLR_MCLL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetLR_MCLL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetLR_MCHL(value uint32) {
	volatile.StoreUint32(&o.LR.Reg, volatile.LoadUint32(&o.LR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetLR_MCHL() uint32 {
	return (volatile.LoadUint32(&o.LR.Reg) & 0x800) >> 11
}

// RTC.IER: RTC Interrupt Enable Register
func (o *RTC_Type) SetIER_TIIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetIER_TIIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *RTC_Type) SetIER_TOIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetIER_TOIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetIER_TAIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetIER_TAIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetIER_MOIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetIER_MOIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetIER_TSIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetIER_TSIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetIER_WPON(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetIER_WPON() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}

// RTC.TTSR: RTC Tamper Time Seconds Register
func (o *RTC_Type) SetTTSR(value uint32) {
	volatile.StoreUint32(&o.TTSR.Reg, value)
}
func (o *RTC_Type) GetTTSR() uint32 {
	return volatile.LoadUint32(&o.TTSR.Reg)
}

// RTC.MER: RTC Monotonic Enable Register
func (o *RTC_Type) SetMER_MCE(value uint32) {
	volatile.StoreUint32(&o.MER.Reg, volatile.LoadUint32(&o.MER.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetMER_MCE() uint32 {
	return (volatile.LoadUint32(&o.MER.Reg) & 0x10) >> 4
}

// RTC.MCLR: RTC Monotonic Counter Low Register
func (o *RTC_Type) SetMCLR(value uint32) {
	volatile.StoreUint32(&o.MCLR.Reg, value)
}
func (o *RTC_Type) GetMCLR() uint32 {
	return volatile.LoadUint32(&o.MCLR.Reg)
}

// RTC.MCHR: RTC Monotonic Counter High Register
func (o *RTC_Type) SetMCHR(value uint32) {
	volatile.StoreUint32(&o.MCHR.Reg, value)
}
func (o *RTC_Type) GetMCHR() uint32 {
	return volatile.LoadUint32(&o.MCHR.Reg)
}

// RTC.WAR: RTC Write Access Register
func (o *RTC_Type) SetWAR_TSRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetWAR_TSRW() uint32 {
	return volatile.LoadUint32(&o.WAR.Reg) & 0x1
}
func (o *RTC_Type) SetWAR_TPRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetWAR_TPRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetWAR_TARW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetWAR_TARW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetWAR_TCRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetWAR_TCRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetWAR_CRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetWAR_CRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetWAR_SRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetWAR_SRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetWAR_LRW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetWAR_LRW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetWAR_IERW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetWAR_IERW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetWAR_TTSW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetWAR_TTSW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetWAR_MERW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetWAR_MERW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetWAR_MCLW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetWAR_MCLW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetWAR_MCHW(value uint32) {
	volatile.StoreUint32(&o.WAR.Reg, volatile.LoadUint32(&o.WAR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetWAR_MCHW() uint32 {
	return (volatile.LoadUint32(&o.WAR.Reg) & 0x800) >> 11
}

// RTC.RAR: RTC Read Access Register
func (o *RTC_Type) SetRAR_TSRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRAR_TSRR() uint32 {
	return volatile.LoadUint32(&o.RAR.Reg) & 0x1
}
func (o *RTC_Type) SetRAR_TPRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRAR_TPRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRAR_TARR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRAR_TARR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRAR_TCRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRAR_TCRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRAR_CRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRAR_CRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRAR_SRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetRAR_SRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetRAR_LRR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRAR_LRR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRAR_IERR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRAR_IERR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRAR_TTSR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetRAR_TTSR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetRAR_MERR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetRAR_MERR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetRAR_MCLR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetRAR_MCLR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetRAR_MCHR(value uint32) {
	volatile.StoreUint32(&o.RAR.Reg, volatile.LoadUint32(&o.RAR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetRAR_MCHR() uint32 {
	return (volatile.LoadUint32(&o.RAR.Reg) & 0x800) >> 11
}

// VBAT register file
type RFVBAT_Type struct {
	REG0 volatile.Register32 // 0x0
	REG1 volatile.Register32 // 0x4
	REG2 volatile.Register32 // 0x8
	REG3 volatile.Register32 // 0xC
	REG4 volatile.Register32 // 0x10
	REG5 volatile.Register32 // 0x14
	REG6 volatile.Register32 // 0x18
	REG7 volatile.Register32 // 0x1C
}

// RFVBAT.REG0: VBAT register file register
func (o *RFVBAT_Type) SetREG0_LL(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG0_LL() uint32 {
	return volatile.LoadUint32(&o.REG0.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG0_LH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG0_LH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG0_HL(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG0_HL() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG0_HH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG0_HH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG1: VBAT register file register
func (o *RFVBAT_Type) SetREG1_LL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG1_LL() uint32 {
	return volatile.LoadUint32(&o.REG1.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG1_LH(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG1_LH() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG1_HL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG1_HL() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG1_HH(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG1_HH() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG2: VBAT register file register
func (o *RFVBAT_Type) SetREG2_LL(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG2_LL() uint32 {
	return volatile.LoadUint32(&o.REG2.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG2_LH(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG2_LH() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG2_HL(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG2_HL() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG2_HH(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG2_HH() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG3: VBAT register file register
func (o *RFVBAT_Type) SetREG3_LL(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG3_LL() uint32 {
	return volatile.LoadUint32(&o.REG3.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG3_LH(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG3_LH() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG3_HL(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG3_HL() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG3_HH(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG3_HH() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG4: VBAT register file register
func (o *RFVBAT_Type) SetREG4_LL(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG4_LL() uint32 {
	return volatile.LoadUint32(&o.REG4.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG4_LH(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG4_LH() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG4_HL(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG4_HL() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG4_HH(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG4_HH() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG5: VBAT register file register
func (o *RFVBAT_Type) SetREG5_LL(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG5_LL() uint32 {
	return volatile.LoadUint32(&o.REG5.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG5_LH(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG5_LH() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG5_HL(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG5_HL() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG5_HH(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG5_HH() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG6: VBAT register file register
func (o *RFVBAT_Type) SetREG6_LL(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG6_LL() uint32 {
	return volatile.LoadUint32(&o.REG6.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG6_LH(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG6_LH() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG6_HL(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG6_HL() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG6_HH(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG6_HH() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff000000) >> 24
}

// RFVBAT.REG7: VBAT register file register
func (o *RFVBAT_Type) SetREG7_LL(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff)|value)
}
func (o *RFVBAT_Type) GetREG7_LL() uint32 {
	return volatile.LoadUint32(&o.REG7.Reg) & 0xff
}
func (o *RFVBAT_Type) SetREG7_LH(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff00)|value<<8)
}
func (o *RFVBAT_Type) GetREG7_LH() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff00) >> 8
}
func (o *RFVBAT_Type) SetREG7_HL(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff0000)|value<<16)
}
func (o *RFVBAT_Type) GetREG7_HL() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff0000) >> 16
}
func (o *RFVBAT_Type) SetREG7_HH(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff000000)|value<<24)
}
func (o *RFVBAT_Type) GetREG7_HH() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff000000) >> 24
}

// Low Power Timer
type LPTMR0_Type struct {
	CSR volatile.Register32 // 0x0
	PSR volatile.Register32 // 0x4
	CMR volatile.Register32 // 0x8
	CNR volatile.Register32 // 0xC
}

// LPTMR0.CSR: Low Power Timer Control Status Register
func (o *LPTMR0_Type) SetCSR_TEN(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *LPTMR0_Type) GetCSR_TEN() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *LPTMR0_Type) SetCSR_TMS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *LPTMR0_Type) GetCSR_TMS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *LPTMR0_Type) SetCSR_TFC(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *LPTMR0_Type) GetCSR_TFC() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *LPTMR0_Type) SetCSR_TPP(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *LPTMR0_Type) GetCSR_TPP() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}
func (o *LPTMR0_Type) SetCSR_TPS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x30)|value<<4)
}
func (o *LPTMR0_Type) GetCSR_TPS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x30) >> 4
}
func (o *LPTMR0_Type) SetCSR_TIE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40)|value<<6)
}
func (o *LPTMR0_Type) GetCSR_TIE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40) >> 6
}
func (o *LPTMR0_Type) SetCSR_TCF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80)|value<<7)
}
func (o *LPTMR0_Type) GetCSR_TCF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80) >> 7
}

// LPTMR0.PSR: Low Power Timer Prescale Register
func (o *LPTMR0_Type) SetPSR_PCS(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x3)|value)
}
func (o *LPTMR0_Type) GetPSR_PCS() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x3
}
func (o *LPTMR0_Type) SetPSR_PBYP(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4)|value<<2)
}
func (o *LPTMR0_Type) GetPSR_PBYP() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4) >> 2
}
func (o *LPTMR0_Type) SetPSR_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x78)|value<<3)
}
func (o *LPTMR0_Type) GetPSR_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x78) >> 3
}

// LPTMR0.CMR: Low Power Timer Compare Register
func (o *LPTMR0_Type) SetCMR_COMPARE(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0xffff)|value)
}
func (o *LPTMR0_Type) GetCMR_COMPARE() uint32 {
	return volatile.LoadUint32(&o.CMR.Reg) & 0xffff
}

// LPTMR0.CNR: Low Power Timer Counter Register
func (o *LPTMR0_Type) SetCNR_COUNTER(value uint32) {
	volatile.StoreUint32(&o.CNR.Reg, volatile.LoadUint32(&o.CNR.Reg)&^(0xffff)|value)
}
func (o *LPTMR0_Type) GetCNR_COUNTER() uint32 {
	return volatile.LoadUint32(&o.CNR.Reg) & 0xffff
}

// System register file
type RFSYS_Type struct {
	REG0 volatile.Register32 // 0x0
	REG1 volatile.Register32 // 0x4
	REG2 volatile.Register32 // 0x8
	REG3 volatile.Register32 // 0xC
	REG4 volatile.Register32 // 0x10
	REG5 volatile.Register32 // 0x14
	REG6 volatile.Register32 // 0x18
	REG7 volatile.Register32 // 0x1C
}

// RFSYS.REG0: Register file register
func (o *RFSYS_Type) SetREG0_LL(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG0_LL() uint32 {
	return volatile.LoadUint32(&o.REG0.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG0_LH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG0_LH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG0_HL(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG0_HL() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG0_HH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG0_HH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xff000000) >> 24
}

// RFSYS.REG1: Register file register
func (o *RFSYS_Type) SetREG1_LL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG1_LL() uint32 {
	return volatile.LoadUint32(&o.REG1.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG1_LH(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG1_LH() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG1_HL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG1_HL() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG1_HH(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG1_HH() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0xff000000) >> 24
}

// RFSYS.REG2: Register file register
func (o *RFSYS_Type) SetREG2_LL(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG2_LL() uint32 {
	return volatile.LoadUint32(&o.REG2.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG2_LH(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG2_LH() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG2_HL(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG2_HL() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG2_HH(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG2_HH() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xff000000) >> 24
}

// RFSYS.REG3: Register file register
func (o *RFSYS_Type) SetREG3_LL(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG3_LL() uint32 {
	return volatile.LoadUint32(&o.REG3.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG3_LH(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG3_LH() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG3_HL(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG3_HL() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG3_HH(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG3_HH() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0xff000000) >> 24
}

// RFSYS.REG4: Register file register
func (o *RFSYS_Type) SetREG4_LL(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG4_LL() uint32 {
	return volatile.LoadUint32(&o.REG4.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG4_LH(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG4_LH() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG4_HL(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG4_HL() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG4_HH(value uint32) {
	volatile.StoreUint32(&o.REG4.Reg, volatile.LoadUint32(&o.REG4.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG4_HH() uint32 {
	return (volatile.LoadUint32(&o.REG4.Reg) & 0xff000000) >> 24
}

// RFSYS.REG5: Register file register
func (o *RFSYS_Type) SetREG5_LL(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG5_LL() uint32 {
	return volatile.LoadUint32(&o.REG5.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG5_LH(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG5_LH() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG5_HL(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG5_HL() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG5_HH(value uint32) {
	volatile.StoreUint32(&o.REG5.Reg, volatile.LoadUint32(&o.REG5.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG5_HH() uint32 {
	return (volatile.LoadUint32(&o.REG5.Reg) & 0xff000000) >> 24
}

// RFSYS.REG6: Register file register
func (o *RFSYS_Type) SetREG6_LL(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG6_LL() uint32 {
	return volatile.LoadUint32(&o.REG6.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG6_LH(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG6_LH() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG6_HL(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG6_HL() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG6_HH(value uint32) {
	volatile.StoreUint32(&o.REG6.Reg, volatile.LoadUint32(&o.REG6.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG6_HH() uint32 {
	return (volatile.LoadUint32(&o.REG6.Reg) & 0xff000000) >> 24
}

// RFSYS.REG7: Register file register
func (o *RFSYS_Type) SetREG7_LL(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff)|value)
}
func (o *RFSYS_Type) GetREG7_LL() uint32 {
	return volatile.LoadUint32(&o.REG7.Reg) & 0xff
}
func (o *RFSYS_Type) SetREG7_LH(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff00)|value<<8)
}
func (o *RFSYS_Type) GetREG7_LH() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff00) >> 8
}
func (o *RFSYS_Type) SetREG7_HL(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff0000)|value<<16)
}
func (o *RFSYS_Type) GetREG7_HL() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff0000) >> 16
}
func (o *RFSYS_Type) SetREG7_HH(value uint32) {
	volatile.StoreUint32(&o.REG7.Reg, volatile.LoadUint32(&o.REG7.Reg)&^(0xff000000)|value<<24)
}
func (o *RFSYS_Type) GetREG7_HH() uint32 {
	return (volatile.LoadUint32(&o.REG7.Reg) & 0xff000000) >> 24
}

// Touch sense input
type TSI0_Type struct {
	GENCS volatile.Register32 // 0x0
	DATA  volatile.Register32 // 0x4
	TSHD  volatile.Register32 // 0x8
}

// TSI0.GENCS: TSI General Control and Status Register
func (o *TSI0_Type) SetGENCS_EOSDMEO(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x1)|value)
}
func (o *TSI0_Type) GetGENCS_EOSDMEO() uint32 {
	return volatile.LoadUint32(&o.GENCS.Reg) & 0x1
}
func (o *TSI0_Type) SetGENCS_CURSW(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x2)|value<<1)
}
func (o *TSI0_Type) GetGENCS_CURSW() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x2) >> 1
}
func (o *TSI0_Type) SetGENCS_EOSF(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x4)|value<<2)
}
func (o *TSI0_Type) GetGENCS_EOSF() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x4) >> 2
}
func (o *TSI0_Type) SetGENCS_SCNIP(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x8)|value<<3)
}
func (o *TSI0_Type) GetGENCS_SCNIP() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x8) >> 3
}
func (o *TSI0_Type) SetGENCS_STM(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x10)|value<<4)
}
func (o *TSI0_Type) GetGENCS_STM() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x10) >> 4
}
func (o *TSI0_Type) SetGENCS_STPE(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x20)|value<<5)
}
func (o *TSI0_Type) GetGENCS_STPE() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x20) >> 5
}
func (o *TSI0_Type) SetGENCS_TSIIEN(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x40)|value<<6)
}
func (o *TSI0_Type) GetGENCS_TSIIEN() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x40) >> 6
}
func (o *TSI0_Type) SetGENCS_TSIEN(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x80)|value<<7)
}
func (o *TSI0_Type) GetGENCS_TSIEN() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x80) >> 7
}
func (o *TSI0_Type) SetGENCS_NSCN(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x1f00)|value<<8)
}
func (o *TSI0_Type) GetGENCS_NSCN() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x1f00) >> 8
}
func (o *TSI0_Type) SetGENCS_PS(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0xe000)|value<<13)
}
func (o *TSI0_Type) GetGENCS_PS() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0xe000) >> 13
}
func (o *TSI0_Type) SetGENCS_EXTCHRG(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x70000)|value<<16)
}
func (o *TSI0_Type) GetGENCS_EXTCHRG() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x70000) >> 16
}
func (o *TSI0_Type) SetGENCS_DVOLT(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x180000)|value<<19)
}
func (o *TSI0_Type) GetGENCS_DVOLT() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x180000) >> 19
}
func (o *TSI0_Type) SetGENCS_REFCHRG(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0xe00000)|value<<21)
}
func (o *TSI0_Type) GetGENCS_REFCHRG() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0xe00000) >> 21
}
func (o *TSI0_Type) SetGENCS_MODE(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0xf000000)|value<<24)
}
func (o *TSI0_Type) GetGENCS_MODE() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0xf000000) >> 24
}
func (o *TSI0_Type) SetGENCS_ESOR(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x10000000)|value<<28)
}
func (o *TSI0_Type) GetGENCS_ESOR() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x10000000) >> 28
}
func (o *TSI0_Type) SetGENCS_OUTRGF(value uint32) {
	volatile.StoreUint32(&o.GENCS.Reg, volatile.LoadUint32(&o.GENCS.Reg)&^(0x80000000)|value<<31)
}
func (o *TSI0_Type) GetGENCS_OUTRGF() uint32 {
	return (volatile.LoadUint32(&o.GENCS.Reg) & 0x80000000) >> 31
}

// TSI0.DATA: TSI DATA Register
func (o *TSI0_Type) SetDATA_TSICNT(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xffff)|value)
}
func (o *TSI0_Type) GetDATA_TSICNT() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0xffff
}
func (o *TSI0_Type) SetDATA_SWTS(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x400000)|value<<22)
}
func (o *TSI0_Type) GetDATA_SWTS() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x400000) >> 22
}
func (o *TSI0_Type) SetDATA_DMAEN(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x800000)|value<<23)
}
func (o *TSI0_Type) GetDATA_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x800000) >> 23
}
func (o *TSI0_Type) SetDATA_TSICH(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xf0000000)|value<<28)
}
func (o *TSI0_Type) GetDATA_TSICH() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0xf0000000) >> 28
}

// TSI0.TSHD: TSI Threshold Register
func (o *TSI0_Type) SetTSHD_THRESL(value uint32) {
	volatile.StoreUint32(&o.TSHD.Reg, volatile.LoadUint32(&o.TSHD.Reg)&^(0xffff)|value)
}
func (o *TSI0_Type) GetTSHD_THRESL() uint32 {
	return volatile.LoadUint32(&o.TSHD.Reg) & 0xffff
}
func (o *TSI0_Type) SetTSHD_THRESH(value uint32) {
	volatile.StoreUint32(&o.TSHD.Reg, volatile.LoadUint32(&o.TSHD.Reg)&^(0xffff0000)|value<<16)
}
func (o *TSI0_Type) GetTSHD_THRESH() uint32 {
	return (volatile.LoadUint32(&o.TSHD.Reg) & 0xffff0000) >> 16
}

// System Integration Module
type SIM_Type struct {
	SOPT1     volatile.Register32 // 0x0
	SOPT1CFG  volatile.Register32 // 0x4
	USBPHYCTL volatile.Register32 // 0x8
	_         [4088]byte
	SOPT2     volatile.Register32 // 0x1004
	_         [4]byte
	SOPT4     volatile.Register32 // 0x100C
	SOPT5     volatile.Register32 // 0x1010
	_         [4]byte
	SOPT7     volatile.Register32 // 0x1018
	SOPT8     volatile.Register32 // 0x101C
	SOPT9     volatile.Register32 // 0x1020
	SDID      volatile.Register32 // 0x1024
	SCGC1     volatile.Register32 // 0x1028
	SCGC2     volatile.Register32 // 0x102C
	SCGC3     volatile.Register32 // 0x1030
	SCGC4     volatile.Register32 // 0x1034
	SCGC5     volatile.Register32 // 0x1038
	SCGC6     volatile.Register32 // 0x103C
	SCGC7     volatile.Register32 // 0x1040
	CLKDIV1   volatile.Register32 // 0x1044
	CLKDIV2   volatile.Register32 // 0x1048
	FCFG1     volatile.Register32 // 0x104C
	FCFG2     volatile.Register32 // 0x1050
	UIDH      volatile.Register32 // 0x1054
	UIDMH     volatile.Register32 // 0x1058
	UIDML     volatile.Register32 // 0x105C
	UIDL      volatile.Register32 // 0x1060
	CLKDIV3   volatile.Register32 // 0x1064
	CLKDIV4   volatile.Register32 // 0x1068
}

// SIM.SOPT1: System Options Register 1
func (o *SIM_Type) SetSOPT1_RAMSIZE(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0xf000)|value<<12)
}
func (o *SIM_Type) GetSOPT1_RAMSIZE() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0xf000) >> 12
}
func (o *SIM_Type) SetSOPT1_OSC32KSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0xc0000)|value<<18)
}
func (o *SIM_Type) GetSOPT1_OSC32KSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0xc0000) >> 18
}
func (o *SIM_Type) SetSOPT1_USBVSTBY(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0x20000000)|value<<29)
}
func (o *SIM_Type) GetSOPT1_USBVSTBY() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0x20000000) >> 29
}
func (o *SIM_Type) SetSOPT1_USBSSTBY(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0x40000000)|value<<30)
}
func (o *SIM_Type) GetSOPT1_USBSSTBY() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0x40000000) >> 30
}
func (o *SIM_Type) SetSOPT1_USBREGEN(value uint32) {
	volatile.StoreUint32(&o.SOPT1.Reg, volatile.LoadUint32(&o.SOPT1.Reg)&^(0x80000000)|value<<31)
}
func (o *SIM_Type) GetSOPT1_USBREGEN() uint32 {
	return (volatile.LoadUint32(&o.SOPT1.Reg) & 0x80000000) >> 31
}

// SIM.SOPT1CFG: SOPT1 Configuration Register
func (o *SIM_Type) SetSOPT1CFG_URWE(value uint32) {
	volatile.StoreUint32(&o.SOPT1CFG.Reg, volatile.LoadUint32(&o.SOPT1CFG.Reg)&^(0x1000000)|value<<24)
}
func (o *SIM_Type) GetSOPT1CFG_URWE() uint32 {
	return (volatile.LoadUint32(&o.SOPT1CFG.Reg) & 0x1000000) >> 24
}
func (o *SIM_Type) SetSOPT1CFG_UVSWE(value uint32) {
	volatile.StoreUint32(&o.SOPT1CFG.Reg, volatile.LoadUint32(&o.SOPT1CFG.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSOPT1CFG_UVSWE() uint32 {
	return (volatile.LoadUint32(&o.SOPT1CFG.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSOPT1CFG_USSWE(value uint32) {
	volatile.StoreUint32(&o.SOPT1CFG.Reg, volatile.LoadUint32(&o.SOPT1CFG.Reg)&^(0x4000000)|value<<26)
}
func (o *SIM_Type) GetSOPT1CFG_USSWE() uint32 {
	return (volatile.LoadUint32(&o.SOPT1CFG.Reg) & 0x4000000) >> 26
}

// SIM.USBPHYCTL: USB PHY Control Register
func (o *SIM_Type) SetUSBPHYCTL_USBVREGSEL(value uint32) {
	volatile.StoreUint32(&o.USBPHYCTL.Reg, volatile.LoadUint32(&o.USBPHYCTL.Reg)&^(0x100)|value<<8)
}
func (o *SIM_Type) GetUSBPHYCTL_USBVREGSEL() uint32 {
	return (volatile.LoadUint32(&o.USBPHYCTL.Reg) & 0x100) >> 8
}
func (o *SIM_Type) SetUSBPHYCTL_USBVREGPD(value uint32) {
	volatile.StoreUint32(&o.USBPHYCTL.Reg, volatile.LoadUint32(&o.USBPHYCTL.Reg)&^(0x200)|value<<9)
}
func (o *SIM_Type) GetUSBPHYCTL_USBVREGPD() uint32 {
	return (volatile.LoadUint32(&o.USBPHYCTL.Reg) & 0x200) >> 9
}
func (o *SIM_Type) SetUSBPHYCTL_USB3VOUTTRG(value uint32) {
	volatile.StoreUint32(&o.USBPHYCTL.Reg, volatile.LoadUint32(&o.USBPHYCTL.Reg)&^(0x700000)|value<<20)
}
func (o *SIM_Type) GetUSBPHYCTL_USB3VOUTTRG() uint32 {
	return (volatile.LoadUint32(&o.USBPHYCTL.Reg) & 0x700000) >> 20
}
func (o *SIM_Type) SetUSBPHYCTL_USBDISILIM(value uint32) {
	volatile.StoreUint32(&o.USBPHYCTL.Reg, volatile.LoadUint32(&o.USBPHYCTL.Reg)&^(0x800000)|value<<23)
}
func (o *SIM_Type) GetUSBPHYCTL_USBDISILIM() uint32 {
	return (volatile.LoadUint32(&o.USBPHYCTL.Reg) & 0x800000) >> 23
}

// SIM.SOPT2: System Options Register 2
func (o *SIM_Type) SetSOPT2_USBSLSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSOPT2_USBSLSRC() uint32 {
	return volatile.LoadUint32(&o.SOPT2.Reg) & 0x1
}
func (o *SIM_Type) SetSOPT2_USBREGEN(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSOPT2_USBREGEN() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSOPT2_RTCCLKOUTSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSOPT2_RTCCLKOUTSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSOPT2_CLKOUTSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0xe0)|value<<5)
}
func (o *SIM_Type) GetSOPT2_CLKOUTSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0xe0) >> 5
}
func (o *SIM_Type) SetSOPT2_FBSL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x300)|value<<8)
}
func (o *SIM_Type) GetSOPT2_FBSL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x300) >> 8
}
func (o *SIM_Type) SetSOPT2_TRACECLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSOPT2_TRACECLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSOPT2_PLLFLLSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x30000)|value<<16)
}
func (o *SIM_Type) GetSOPT2_PLLFLLSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x30000) >> 16
}
func (o *SIM_Type) SetSOPT2_USBSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x40000)|value<<18)
}
func (o *SIM_Type) GetSOPT2_USBSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x40000) >> 18
}
func (o *SIM_Type) SetSOPT2_RMIISRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x80000)|value<<19)
}
func (o *SIM_Type) GetSOPT2_RMIISRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x80000) >> 19
}
func (o *SIM_Type) SetSOPT2_TIMESRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x300000)|value<<20)
}
func (o *SIM_Type) GetSOPT2_TIMESRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x300000) >> 20
}
func (o *SIM_Type) SetSOPT2_TPMSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x3000000)|value<<24)
}
func (o *SIM_Type) GetSOPT2_TPMSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x3000000) >> 24
}
func (o *SIM_Type) SetSOPT2_LPUARTSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0xc000000)|value<<26)
}
func (o *SIM_Type) GetSOPT2_LPUARTSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0xc000000) >> 26
}
func (o *SIM_Type) SetSOPT2_SDHCSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT2.Reg, volatile.LoadUint32(&o.SOPT2.Reg)&^(0x30000000)|value<<28)
}
func (o *SIM_Type) GetSOPT2_SDHCSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT2.Reg) & 0x30000000) >> 28
}

// SIM.SOPT4: System Options Register 4
func (o *SIM_Type) SetSOPT4_FTM0FLT0(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSOPT4_FTM0FLT0() uint32 {
	return volatile.LoadUint32(&o.SOPT4.Reg) & 0x1
}
func (o *SIM_Type) SetSOPT4_FTM0FLT1(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSOPT4_FTM0FLT1() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSOPT4_FTM0FLT2(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x4)|value<<2)
}
func (o *SIM_Type) GetSOPT4_FTM0FLT2() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x4) >> 2
}
func (o *SIM_Type) SetSOPT4_FTM0FLT3(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x8)|value<<3)
}
func (o *SIM_Type) GetSOPT4_FTM0FLT3() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x8) >> 3
}
func (o *SIM_Type) SetSOPT4_FTM1FLT0(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSOPT4_FTM1FLT0() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSOPT4_FTM2FLT0(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x100)|value<<8)
}
func (o *SIM_Type) GetSOPT4_FTM2FLT0() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x100) >> 8
}
func (o *SIM_Type) SetSOPT4_FTM3FLT0(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSOPT4_FTM3FLT0() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSOPT4_FTM1CH0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0xc0000)|value<<18)
}
func (o *SIM_Type) GetSOPT4_FTM1CH0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0xc0000) >> 18
}
func (o *SIM_Type) SetSOPT4_FTM2CH0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x300000)|value<<20)
}
func (o *SIM_Type) GetSOPT4_FTM2CH0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x300000) >> 20
}
func (o *SIM_Type) SetSOPT4_FTM2CH1SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x400000)|value<<22)
}
func (o *SIM_Type) GetSOPT4_FTM2CH1SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x400000) >> 22
}
func (o *SIM_Type) SetSOPT4_FTM0CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x1000000)|value<<24)
}
func (o *SIM_Type) GetSOPT4_FTM0CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x1000000) >> 24
}
func (o *SIM_Type) SetSOPT4_FTM1CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSOPT4_FTM1CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSOPT4_FTM2CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x4000000)|value<<26)
}
func (o *SIM_Type) GetSOPT4_FTM2CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x4000000) >> 26
}
func (o *SIM_Type) SetSOPT4_FTM3CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x8000000)|value<<27)
}
func (o *SIM_Type) GetSOPT4_FTM3CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x8000000) >> 27
}
func (o *SIM_Type) SetSOPT4_FTM0TRG0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x10000000)|value<<28)
}
func (o *SIM_Type) GetSOPT4_FTM0TRG0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x10000000) >> 28
}
func (o *SIM_Type) SetSOPT4_FTM0TRG1SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x20000000)|value<<29)
}
func (o *SIM_Type) GetSOPT4_FTM0TRG1SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x20000000) >> 29
}
func (o *SIM_Type) SetSOPT4_FTM3TRG0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x40000000)|value<<30)
}
func (o *SIM_Type) GetSOPT4_FTM3TRG0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x40000000) >> 30
}
func (o *SIM_Type) SetSOPT4_FTM3TRG1SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT4.Reg, volatile.LoadUint32(&o.SOPT4.Reg)&^(0x80000000)|value<<31)
}
func (o *SIM_Type) GetSOPT4_FTM3TRG1SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT4.Reg) & 0x80000000) >> 31
}

// SIM.SOPT5: System Options Register 5
func (o *SIM_Type) SetSOPT5_UART0TXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0x3)|value)
}
func (o *SIM_Type) GetSOPT5_UART0TXSRC() uint32 {
	return volatile.LoadUint32(&o.SOPT5.Reg) & 0x3
}
func (o *SIM_Type) SetSOPT5_UART0RXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0xc)|value<<2)
}
func (o *SIM_Type) GetSOPT5_UART0RXSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT5.Reg) & 0xc) >> 2
}
func (o *SIM_Type) SetSOPT5_UART1TXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0x30)|value<<4)
}
func (o *SIM_Type) GetSOPT5_UART1TXSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT5.Reg) & 0x30) >> 4
}
func (o *SIM_Type) SetSOPT5_UART1RXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0xc0)|value<<6)
}
func (o *SIM_Type) GetSOPT5_UART1RXSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT5.Reg) & 0xc0) >> 6
}
func (o *SIM_Type) SetSOPT5_LPUART0TXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0x30000)|value<<16)
}
func (o *SIM_Type) GetSOPT5_LPUART0TXSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT5.Reg) & 0x30000) >> 16
}
func (o *SIM_Type) SetSOPT5_LPUART0RXSRC(value uint32) {
	volatile.StoreUint32(&o.SOPT5.Reg, volatile.LoadUint32(&o.SOPT5.Reg)&^(0xc0000)|value<<18)
}
func (o *SIM_Type) GetSOPT5_LPUART0RXSRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT5.Reg) & 0xc0000) >> 18
}

// SIM.SOPT7: System Options Register 7
func (o *SIM_Type) SetSOPT7_ADC0TRGSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0xf)|value)
}
func (o *SIM_Type) GetSOPT7_ADC0TRGSEL() uint32 {
	return volatile.LoadUint32(&o.SOPT7.Reg) & 0xf
}
func (o *SIM_Type) SetSOPT7_ADC0PRETRGSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSOPT7_ADC0PRETRGSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSOPT7_ADC0ALTTRGEN(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0x80)|value<<7)
}
func (o *SIM_Type) GetSOPT7_ADC0ALTTRGEN() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0x80) >> 7
}
func (o *SIM_Type) SetSOPT7_ADC1TRGSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0xf00)|value<<8)
}
func (o *SIM_Type) GetSOPT7_ADC1TRGSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0xf00) >> 8
}
func (o *SIM_Type) SetSOPT7_ADC1PRETRGSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSOPT7_ADC1PRETRGSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSOPT7_ADC1ALTTRGEN(value uint32) {
	volatile.StoreUint32(&o.SOPT7.Reg, volatile.LoadUint32(&o.SOPT7.Reg)&^(0x8000)|value<<15)
}
func (o *SIM_Type) GetSOPT7_ADC1ALTTRGEN() uint32 {
	return (volatile.LoadUint32(&o.SOPT7.Reg) & 0x8000) >> 15
}

// SIM.SOPT8: System Options Register 8
func (o *SIM_Type) SetSOPT8_FTM0SYNCBIT(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSOPT8_FTM0SYNCBIT() uint32 {
	return volatile.LoadUint32(&o.SOPT8.Reg) & 0x1
}
func (o *SIM_Type) SetSOPT8_FTM1SYNCBIT(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSOPT8_FTM1SYNCBIT() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSOPT8_FTM2SYNCBIT(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x4)|value<<2)
}
func (o *SIM_Type) GetSOPT8_FTM2SYNCBIT() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x4) >> 2
}
func (o *SIM_Type) SetSOPT8_FTM3SYNCBIT(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x8)|value<<3)
}
func (o *SIM_Type) GetSOPT8_FTM3SYNCBIT() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x8) >> 3
}
func (o *SIM_Type) SetSOPT8_FTM0OCH0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x10000)|value<<16)
}
func (o *SIM_Type) GetSOPT8_FTM0OCH0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x10000) >> 16
}
func (o *SIM_Type) SetSOPT8_FTM0OCH1SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x20000)|value<<17)
}
func (o *SIM_Type) GetSOPT8_FTM0OCH1SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x20000) >> 17
}
func (o *SIM_Type) SetSOPT8_FTM0OCH2SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x40000)|value<<18)
}
func (o *SIM_Type) GetSOPT8_FTM0OCH2SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x40000) >> 18
}
func (o *SIM_Type) SetSOPT8_FTM0OCH3SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x80000)|value<<19)
}
func (o *SIM_Type) GetSOPT8_FTM0OCH3SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x80000) >> 19
}
func (o *SIM_Type) SetSOPT8_FTM0OCH4SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x100000)|value<<20)
}
func (o *SIM_Type) GetSOPT8_FTM0OCH4SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x100000) >> 20
}
func (o *SIM_Type) SetSOPT8_FTM0OCH5SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x200000)|value<<21)
}
func (o *SIM_Type) GetSOPT8_FTM0OCH5SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x200000) >> 21
}
func (o *SIM_Type) SetSOPT8_FTM0OCH6SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x400000)|value<<22)
}
func (o *SIM_Type) GetSOPT8_FTM0OCH6SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x400000) >> 22
}
func (o *SIM_Type) SetSOPT8_FTM0OCH7SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x800000)|value<<23)
}
func (o *SIM_Type) GetSOPT8_FTM0OCH7SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x800000) >> 23
}
func (o *SIM_Type) SetSOPT8_FTM3OCH0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x1000000)|value<<24)
}
func (o *SIM_Type) GetSOPT8_FTM3OCH0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x1000000) >> 24
}
func (o *SIM_Type) SetSOPT8_FTM3OCH1SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSOPT8_FTM3OCH1SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSOPT8_FTM3OCH2SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x4000000)|value<<26)
}
func (o *SIM_Type) GetSOPT8_FTM3OCH2SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x4000000) >> 26
}
func (o *SIM_Type) SetSOPT8_FTM3OCH3SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x8000000)|value<<27)
}
func (o *SIM_Type) GetSOPT8_FTM3OCH3SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x8000000) >> 27
}
func (o *SIM_Type) SetSOPT8_FTM3OCH4SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x10000000)|value<<28)
}
func (o *SIM_Type) GetSOPT8_FTM3OCH4SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x10000000) >> 28
}
func (o *SIM_Type) SetSOPT8_FTM3OCH5SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x20000000)|value<<29)
}
func (o *SIM_Type) GetSOPT8_FTM3OCH5SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x20000000) >> 29
}
func (o *SIM_Type) SetSOPT8_FTM3OCH6SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x40000000)|value<<30)
}
func (o *SIM_Type) GetSOPT8_FTM3OCH6SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x40000000) >> 30
}
func (o *SIM_Type) SetSOPT8_FTM3OCH7SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT8.Reg, volatile.LoadUint32(&o.SOPT8.Reg)&^(0x80000000)|value<<31)
}
func (o *SIM_Type) GetSOPT8_FTM3OCH7SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT8.Reg) & 0x80000000) >> 31
}

// SIM.SOPT9: System Options Register 9
func (o *SIM_Type) SetSOPT9_TPM1CH0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT9.Reg, volatile.LoadUint32(&o.SOPT9.Reg)&^(0xc0000)|value<<18)
}
func (o *SIM_Type) GetSOPT9_TPM1CH0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT9.Reg) & 0xc0000) >> 18
}
func (o *SIM_Type) SetSOPT9_TPM2CH0SRC(value uint32) {
	volatile.StoreUint32(&o.SOPT9.Reg, volatile.LoadUint32(&o.SOPT9.Reg)&^(0x300000)|value<<20)
}
func (o *SIM_Type) GetSOPT9_TPM2CH0SRC() uint32 {
	return (volatile.LoadUint32(&o.SOPT9.Reg) & 0x300000) >> 20
}
func (o *SIM_Type) SetSOPT9_TPM1CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT9.Reg, volatile.LoadUint32(&o.SOPT9.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSOPT9_TPM1CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT9.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSOPT9_TPM2CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SOPT9.Reg, volatile.LoadUint32(&o.SOPT9.Reg)&^(0x4000000)|value<<26)
}
func (o *SIM_Type) GetSOPT9_TPM2CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.SOPT9.Reg) & 0x4000000) >> 26
}

// SIM.SDID: System Device Identification Register
func (o *SIM_Type) SetSDID_PINID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf)|value)
}
func (o *SIM_Type) GetSDID_PINID() uint32 {
	return volatile.LoadUint32(&o.SDID.Reg) & 0xf
}
func (o *SIM_Type) SetSDID_FAMID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0x70)|value<<4)
}
func (o *SIM_Type) GetSDID_FAMID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0x70) >> 4
}
func (o *SIM_Type) SetSDID_DIEID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf80)|value<<7)
}
func (o *SIM_Type) GetSDID_DIEID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf80) >> 7
}
func (o *SIM_Type) SetSDID_REVID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf000)|value<<12)
}
func (o *SIM_Type) GetSDID_REVID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf000) >> 12
}
func (o *SIM_Type) SetSDID_SERIESID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf00000)|value<<20)
}
func (o *SIM_Type) GetSDID_SERIESID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf00000) >> 20
}
func (o *SIM_Type) SetSDID_SUBFAMID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf000000)|value<<24)
}
func (o *SIM_Type) GetSDID_SUBFAMID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf000000) >> 24
}
func (o *SIM_Type) SetSDID_FAMILYID(value uint32) {
	volatile.StoreUint32(&o.SDID.Reg, volatile.LoadUint32(&o.SDID.Reg)&^(0xf0000000)|value<<28)
}
func (o *SIM_Type) GetSDID_FAMILYID() uint32 {
	return (volatile.LoadUint32(&o.SDID.Reg) & 0xf0000000) >> 28
}

// SIM.SCGC1: System Clock Gating Control Register 1
func (o *SIM_Type) SetSCGC1_I2C2(value uint32) {
	volatile.StoreUint32(&o.SCGC1.Reg, volatile.LoadUint32(&o.SCGC1.Reg)&^(0x40)|value<<6)
}
func (o *SIM_Type) GetSCGC1_I2C2() uint32 {
	return (volatile.LoadUint32(&o.SCGC1.Reg) & 0x40) >> 6
}
func (o *SIM_Type) SetSCGC1_I2C3(value uint32) {
	volatile.StoreUint32(&o.SCGC1.Reg, volatile.LoadUint32(&o.SCGC1.Reg)&^(0x80)|value<<7)
}
func (o *SIM_Type) GetSCGC1_I2C3() uint32 {
	return (volatile.LoadUint32(&o.SCGC1.Reg) & 0x80) >> 7
}
func (o *SIM_Type) SetSCGC1_UART4(value uint32) {
	volatile.StoreUint32(&o.SCGC1.Reg, volatile.LoadUint32(&o.SCGC1.Reg)&^(0x400)|value<<10)
}
func (o *SIM_Type) GetSCGC1_UART4() uint32 {
	return (volatile.LoadUint32(&o.SCGC1.Reg) & 0x400) >> 10
}

// SIM.SCGC2: System Clock Gating Control Register 2
func (o *SIM_Type) SetSCGC2_ENET(value uint32) {
	volatile.StoreUint32(&o.SCGC2.Reg, volatile.LoadUint32(&o.SCGC2.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC2_ENET() uint32 {
	return volatile.LoadUint32(&o.SCGC2.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC2_LPUART0(value uint32) {
	volatile.StoreUint32(&o.SCGC2.Reg, volatile.LoadUint32(&o.SCGC2.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSCGC2_LPUART0() uint32 {
	return (volatile.LoadUint32(&o.SCGC2.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSCGC2_TPM1(value uint32) {
	volatile.StoreUint32(&o.SCGC2.Reg, volatile.LoadUint32(&o.SCGC2.Reg)&^(0x200)|value<<9)
}
func (o *SIM_Type) GetSCGC2_TPM1() uint32 {
	return (volatile.LoadUint32(&o.SCGC2.Reg) & 0x200) >> 9
}
func (o *SIM_Type) SetSCGC2_TPM2(value uint32) {
	volatile.StoreUint32(&o.SCGC2.Reg, volatile.LoadUint32(&o.SCGC2.Reg)&^(0x400)|value<<10)
}
func (o *SIM_Type) GetSCGC2_TPM2() uint32 {
	return (volatile.LoadUint32(&o.SCGC2.Reg) & 0x400) >> 10
}
func (o *SIM_Type) SetSCGC2_DAC0(value uint32) {
	volatile.StoreUint32(&o.SCGC2.Reg, volatile.LoadUint32(&o.SCGC2.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC2_DAC0() uint32 {
	return (volatile.LoadUint32(&o.SCGC2.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC2_DAC1(value uint32) {
	volatile.StoreUint32(&o.SCGC2.Reg, volatile.LoadUint32(&o.SCGC2.Reg)&^(0x2000)|value<<13)
}
func (o *SIM_Type) GetSCGC2_DAC1() uint32 {
	return (volatile.LoadUint32(&o.SCGC2.Reg) & 0x2000) >> 13
}

// SIM.SCGC3: System Clock Gating Control Register 3
func (o *SIM_Type) SetSCGC3_RNGA(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC3_RNGA() uint32 {
	return volatile.LoadUint32(&o.SCGC3.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC3_USBHS(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSCGC3_USBHS() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSCGC3_USBHSPHY(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x4)|value<<2)
}
func (o *SIM_Type) GetSCGC3_USBHSPHY() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x4) >> 2
}
func (o *SIM_Type) SetSCGC3_USBHSDCD(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x8)|value<<3)
}
func (o *SIM_Type) GetSCGC3_USBHSDCD() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x8) >> 3
}
func (o *SIM_Type) SetSCGC3_FLEXCAN1(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSCGC3_FLEXCAN1() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSCGC3_SPI2(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC3_SPI2() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC3_SDHC(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x20000)|value<<17)
}
func (o *SIM_Type) GetSCGC3_SDHC() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x20000) >> 17
}
func (o *SIM_Type) SetSCGC3_FTM2(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x1000000)|value<<24)
}
func (o *SIM_Type) GetSCGC3_FTM2() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x1000000) >> 24
}
func (o *SIM_Type) SetSCGC3_FTM3(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSCGC3_FTM3() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSCGC3_ADC1(value uint32) {
	volatile.StoreUint32(&o.SCGC3.Reg, volatile.LoadUint32(&o.SCGC3.Reg)&^(0x8000000)|value<<27)
}
func (o *SIM_Type) GetSCGC3_ADC1() uint32 {
	return (volatile.LoadUint32(&o.SCGC3.Reg) & 0x8000000) >> 27
}

// SIM.SCGC4: System Clock Gating Control Register 4
func (o *SIM_Type) SetSCGC4_EWM(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSCGC4_EWM() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSCGC4_CMT(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x4)|value<<2)
}
func (o *SIM_Type) GetSCGC4_CMT() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x4) >> 2
}
func (o *SIM_Type) SetSCGC4_I2C0(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x40)|value<<6)
}
func (o *SIM_Type) GetSCGC4_I2C0() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x40) >> 6
}
func (o *SIM_Type) SetSCGC4_I2C1(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x80)|value<<7)
}
func (o *SIM_Type) GetSCGC4_I2C1() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x80) >> 7
}
func (o *SIM_Type) SetSCGC4_UART0(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x400)|value<<10)
}
func (o *SIM_Type) GetSCGC4_UART0() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x400) >> 10
}
func (o *SIM_Type) SetSCGC4_UART1(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x800)|value<<11)
}
func (o *SIM_Type) GetSCGC4_UART1() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x800) >> 11
}
func (o *SIM_Type) SetSCGC4_UART2(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC4_UART2() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC4_UART3(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x2000)|value<<13)
}
func (o *SIM_Type) GetSCGC4_UART3() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x2000) >> 13
}
func (o *SIM_Type) SetSCGC4_USBOTG(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x40000)|value<<18)
}
func (o *SIM_Type) GetSCGC4_USBOTG() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x40000) >> 18
}
func (o *SIM_Type) SetSCGC4_CMP(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x80000)|value<<19)
}
func (o *SIM_Type) GetSCGC4_CMP() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x80000) >> 19
}
func (o *SIM_Type) SetSCGC4_VREF(value uint32) {
	volatile.StoreUint32(&o.SCGC4.Reg, volatile.LoadUint32(&o.SCGC4.Reg)&^(0x100000)|value<<20)
}
func (o *SIM_Type) GetSCGC4_VREF() uint32 {
	return (volatile.LoadUint32(&o.SCGC4.Reg) & 0x100000) >> 20
}

// SIM.SCGC5: System Clock Gating Control Register 5
func (o *SIM_Type) SetSCGC5_LPTMR(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC5_LPTMR() uint32 {
	return volatile.LoadUint32(&o.SCGC5.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC5_TSI(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x20)|value<<5)
}
func (o *SIM_Type) GetSCGC5_TSI() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x20) >> 5
}
func (o *SIM_Type) SetSCGC5_PORTA(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x200)|value<<9)
}
func (o *SIM_Type) GetSCGC5_PORTA() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x200) >> 9
}
func (o *SIM_Type) SetSCGC5_PORTB(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x400)|value<<10)
}
func (o *SIM_Type) GetSCGC5_PORTB() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x400) >> 10
}
func (o *SIM_Type) SetSCGC5_PORTC(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x800)|value<<11)
}
func (o *SIM_Type) GetSCGC5_PORTC() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x800) >> 11
}
func (o *SIM_Type) SetSCGC5_PORTD(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC5_PORTD() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC5_PORTE(value uint32) {
	volatile.StoreUint32(&o.SCGC5.Reg, volatile.LoadUint32(&o.SCGC5.Reg)&^(0x2000)|value<<13)
}
func (o *SIM_Type) GetSCGC5_PORTE() uint32 {
	return (volatile.LoadUint32(&o.SCGC5.Reg) & 0x2000) >> 13
}

// SIM.SCGC6: System Clock Gating Control Register 6
func (o *SIM_Type) SetSCGC6_FTF(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC6_FTF() uint32 {
	return volatile.LoadUint32(&o.SCGC6.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC6_DMAMUX(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSCGC6_DMAMUX() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSCGC6_FLEXCAN0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x10)|value<<4)
}
func (o *SIM_Type) GetSCGC6_FLEXCAN0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x10) >> 4
}
func (o *SIM_Type) SetSCGC6_RNGA(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x200)|value<<9)
}
func (o *SIM_Type) GetSCGC6_RNGA() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x200) >> 9
}
func (o *SIM_Type) SetSCGC6_SPI0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x1000)|value<<12)
}
func (o *SIM_Type) GetSCGC6_SPI0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x1000) >> 12
}
func (o *SIM_Type) SetSCGC6_SPI1(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x2000)|value<<13)
}
func (o *SIM_Type) GetSCGC6_SPI1() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x2000) >> 13
}
func (o *SIM_Type) SetSCGC6_I2S(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x8000)|value<<15)
}
func (o *SIM_Type) GetSCGC6_I2S() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x8000) >> 15
}
func (o *SIM_Type) SetSCGC6_CRC(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x40000)|value<<18)
}
func (o *SIM_Type) GetSCGC6_CRC() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x40000) >> 18
}
func (o *SIM_Type) SetSCGC6_USBDCD(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x200000)|value<<21)
}
func (o *SIM_Type) GetSCGC6_USBDCD() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x200000) >> 21
}
func (o *SIM_Type) SetSCGC6_PDB(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x400000)|value<<22)
}
func (o *SIM_Type) GetSCGC6_PDB() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x400000) >> 22
}
func (o *SIM_Type) SetSCGC6_PIT(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x800000)|value<<23)
}
func (o *SIM_Type) GetSCGC6_PIT() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x800000) >> 23
}
func (o *SIM_Type) SetSCGC6_FTM0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x1000000)|value<<24)
}
func (o *SIM_Type) GetSCGC6_FTM0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x1000000) >> 24
}
func (o *SIM_Type) SetSCGC6_FTM1(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x2000000)|value<<25)
}
func (o *SIM_Type) GetSCGC6_FTM1() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x2000000) >> 25
}
func (o *SIM_Type) SetSCGC6_FTM2(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x4000000)|value<<26)
}
func (o *SIM_Type) GetSCGC6_FTM2() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x4000000) >> 26
}
func (o *SIM_Type) SetSCGC6_ADC0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x8000000)|value<<27)
}
func (o *SIM_Type) GetSCGC6_ADC0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x8000000) >> 27
}
func (o *SIM_Type) SetSCGC6_RTC(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x20000000)|value<<29)
}
func (o *SIM_Type) GetSCGC6_RTC() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x20000000) >> 29
}
func (o *SIM_Type) SetSCGC6_DAC0(value uint32) {
	volatile.StoreUint32(&o.SCGC6.Reg, volatile.LoadUint32(&o.SCGC6.Reg)&^(0x80000000)|value<<31)
}
func (o *SIM_Type) GetSCGC6_DAC0() uint32 {
	return (volatile.LoadUint32(&o.SCGC6.Reg) & 0x80000000) >> 31
}

// SIM.SCGC7: System Clock Gating Control Register 7
func (o *SIM_Type) SetSCGC7_FLEXBUS(value uint32) {
	volatile.StoreUint32(&o.SCGC7.Reg, volatile.LoadUint32(&o.SCGC7.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetSCGC7_FLEXBUS() uint32 {
	return volatile.LoadUint32(&o.SCGC7.Reg) & 0x1
}
func (o *SIM_Type) SetSCGC7_DMA(value uint32) {
	volatile.StoreUint32(&o.SCGC7.Reg, volatile.LoadUint32(&o.SCGC7.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetSCGC7_DMA() uint32 {
	return (volatile.LoadUint32(&o.SCGC7.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetSCGC7_MPU(value uint32) {
	volatile.StoreUint32(&o.SCGC7.Reg, volatile.LoadUint32(&o.SCGC7.Reg)&^(0x4)|value<<2)
}
func (o *SIM_Type) GetSCGC7_MPU() uint32 {
	return (volatile.LoadUint32(&o.SCGC7.Reg) & 0x4) >> 2
}
func (o *SIM_Type) SetSCGC7_SDRAMC(value uint32) {
	volatile.StoreUint32(&o.SCGC7.Reg, volatile.LoadUint32(&o.SCGC7.Reg)&^(0x8)|value<<3)
}
func (o *SIM_Type) GetSCGC7_SDRAMC() uint32 {
	return (volatile.LoadUint32(&o.SCGC7.Reg) & 0x8) >> 3
}

// SIM.CLKDIV1: System Clock Divider Register 1
func (o *SIM_Type) SetCLKDIV1_OUTDIV4(value uint32) {
	volatile.StoreUint32(&o.CLKDIV1.Reg, volatile.LoadUint32(&o.CLKDIV1.Reg)&^(0xf0000)|value<<16)
}
func (o *SIM_Type) GetCLKDIV1_OUTDIV4() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV1.Reg) & 0xf0000) >> 16
}
func (o *SIM_Type) SetCLKDIV1_OUTDIV3(value uint32) {
	volatile.StoreUint32(&o.CLKDIV1.Reg, volatile.LoadUint32(&o.CLKDIV1.Reg)&^(0xf00000)|value<<20)
}
func (o *SIM_Type) GetCLKDIV1_OUTDIV3() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV1.Reg) & 0xf00000) >> 20
}
func (o *SIM_Type) SetCLKDIV1_OUTDIV2(value uint32) {
	volatile.StoreUint32(&o.CLKDIV1.Reg, volatile.LoadUint32(&o.CLKDIV1.Reg)&^(0xf000000)|value<<24)
}
func (o *SIM_Type) GetCLKDIV1_OUTDIV2() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV1.Reg) & 0xf000000) >> 24
}
func (o *SIM_Type) SetCLKDIV1_OUTDIV1(value uint32) {
	volatile.StoreUint32(&o.CLKDIV1.Reg, volatile.LoadUint32(&o.CLKDIV1.Reg)&^(0xf0000000)|value<<28)
}
func (o *SIM_Type) GetCLKDIV1_OUTDIV1() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV1.Reg) & 0xf0000000) >> 28
}

// SIM.CLKDIV2: System Clock Divider Register 2
func (o *SIM_Type) SetCLKDIV2_USBFRAC(value uint32) {
	volatile.StoreUint32(&o.CLKDIV2.Reg, volatile.LoadUint32(&o.CLKDIV2.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetCLKDIV2_USBFRAC() uint32 {
	return volatile.LoadUint32(&o.CLKDIV2.Reg) & 0x1
}
func (o *SIM_Type) SetCLKDIV2_USBDIV(value uint32) {
	volatile.StoreUint32(&o.CLKDIV2.Reg, volatile.LoadUint32(&o.CLKDIV2.Reg)&^(0xe)|value<<1)
}
func (o *SIM_Type) GetCLKDIV2_USBDIV() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV2.Reg) & 0xe) >> 1
}

// SIM.FCFG1: Flash Configuration Register 1
func (o *SIM_Type) SetFCFG1_FLASHDIS(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetFCFG1_FLASHDIS() uint32 {
	return volatile.LoadUint32(&o.FCFG1.Reg) & 0x1
}
func (o *SIM_Type) SetFCFG1_FLASHDOZE(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0x2)|value<<1)
}
func (o *SIM_Type) GetFCFG1_FLASHDOZE() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0x2) >> 1
}
func (o *SIM_Type) SetFCFG1_DEPART(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0xf00)|value<<8)
}
func (o *SIM_Type) GetFCFG1_DEPART() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0xf00) >> 8
}
func (o *SIM_Type) SetFCFG1_EESIZE(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0xf0000)|value<<16)
}
func (o *SIM_Type) GetFCFG1_EESIZE() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0xf0000) >> 16
}
func (o *SIM_Type) SetFCFG1_PFSIZE(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0xf000000)|value<<24)
}
func (o *SIM_Type) GetFCFG1_PFSIZE() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0xf000000) >> 24
}
func (o *SIM_Type) SetFCFG1_NVMSIZE(value uint32) {
	volatile.StoreUint32(&o.FCFG1.Reg, volatile.LoadUint32(&o.FCFG1.Reg)&^(0xf0000000)|value<<28)
}
func (o *SIM_Type) GetFCFG1_NVMSIZE() uint32 {
	return (volatile.LoadUint32(&o.FCFG1.Reg) & 0xf0000000) >> 28
}

// SIM.FCFG2: Flash Configuration Register 2
func (o *SIM_Type) SetFCFG2_MAXADDR1(value uint32) {
	volatile.StoreUint32(&o.FCFG2.Reg, volatile.LoadUint32(&o.FCFG2.Reg)&^(0x7f0000)|value<<16)
}
func (o *SIM_Type) GetFCFG2_MAXADDR1() uint32 {
	return (volatile.LoadUint32(&o.FCFG2.Reg) & 0x7f0000) >> 16
}
func (o *SIM_Type) SetFCFG2_PFLSH(value uint32) {
	volatile.StoreUint32(&o.FCFG2.Reg, volatile.LoadUint32(&o.FCFG2.Reg)&^(0x800000)|value<<23)
}
func (o *SIM_Type) GetFCFG2_PFLSH() uint32 {
	return (volatile.LoadUint32(&o.FCFG2.Reg) & 0x800000) >> 23
}
func (o *SIM_Type) SetFCFG2_MAXADDR0(value uint32) {
	volatile.StoreUint32(&o.FCFG2.Reg, volatile.LoadUint32(&o.FCFG2.Reg)&^(0x7f000000)|value<<24)
}
func (o *SIM_Type) GetFCFG2_MAXADDR0() uint32 {
	return (volatile.LoadUint32(&o.FCFG2.Reg) & 0x7f000000) >> 24
}
func (o *SIM_Type) SetFCFG2_SWAPPFLSH(value uint32) {
	volatile.StoreUint32(&o.FCFG2.Reg, volatile.LoadUint32(&o.FCFG2.Reg)&^(0x80000000)|value<<31)
}
func (o *SIM_Type) GetFCFG2_SWAPPFLSH() uint32 {
	return (volatile.LoadUint32(&o.FCFG2.Reg) & 0x80000000) >> 31
}

// SIM.UIDH: Unique Identification Register High
func (o *SIM_Type) SetUIDH(value uint32) {
	volatile.StoreUint32(&o.UIDH.Reg, value)
}
func (o *SIM_Type) GetUIDH() uint32 {
	return volatile.LoadUint32(&o.UIDH.Reg)
}

// SIM.UIDMH: Unique Identification Register Mid-High
func (o *SIM_Type) SetUIDMH(value uint32) {
	volatile.StoreUint32(&o.UIDMH.Reg, value)
}
func (o *SIM_Type) GetUIDMH() uint32 {
	return volatile.LoadUint32(&o.UIDMH.Reg)
}

// SIM.UIDML: Unique Identification Register Mid Low
func (o *SIM_Type) SetUIDML(value uint32) {
	volatile.StoreUint32(&o.UIDML.Reg, value)
}
func (o *SIM_Type) GetUIDML() uint32 {
	return volatile.LoadUint32(&o.UIDML.Reg)
}

// SIM.UIDL: Unique Identification Register Low
func (o *SIM_Type) SetUIDL(value uint32) {
	volatile.StoreUint32(&o.UIDL.Reg, value)
}
func (o *SIM_Type) GetUIDL() uint32 {
	return volatile.LoadUint32(&o.UIDL.Reg)
}

// SIM.CLKDIV3: System Clock Divider Register 3
func (o *SIM_Type) SetCLKDIV3_PLLFLLFRAC(value uint32) {
	volatile.StoreUint32(&o.CLKDIV3.Reg, volatile.LoadUint32(&o.CLKDIV3.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetCLKDIV3_PLLFLLFRAC() uint32 {
	return volatile.LoadUint32(&o.CLKDIV3.Reg) & 0x1
}
func (o *SIM_Type) SetCLKDIV3_PLLFLLDIV(value uint32) {
	volatile.StoreUint32(&o.CLKDIV3.Reg, volatile.LoadUint32(&o.CLKDIV3.Reg)&^(0xe)|value<<1)
}
func (o *SIM_Type) GetCLKDIV3_PLLFLLDIV() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV3.Reg) & 0xe) >> 1
}

// SIM.CLKDIV4: System Clock Divider Register 4
func (o *SIM_Type) SetCLKDIV4_TRACEFRAC(value uint32) {
	volatile.StoreUint32(&o.CLKDIV4.Reg, volatile.LoadUint32(&o.CLKDIV4.Reg)&^(0x1)|value)
}
func (o *SIM_Type) GetCLKDIV4_TRACEFRAC() uint32 {
	return volatile.LoadUint32(&o.CLKDIV4.Reg) & 0x1
}
func (o *SIM_Type) SetCLKDIV4_TRACEDIV(value uint32) {
	volatile.StoreUint32(&o.CLKDIV4.Reg, volatile.LoadUint32(&o.CLKDIV4.Reg)&^(0xe)|value<<1)
}
func (o *SIM_Type) GetCLKDIV4_TRACEDIV() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV4.Reg) & 0xe) >> 1
}

// Pin Control and Interrupts
type PORT_Type struct {
	PCR0  volatile.Register32 // 0x0
	PCR1  volatile.Register32 // 0x4
	PCR2  volatile.Register32 // 0x8
	PCR3  volatile.Register32 // 0xC
	PCR4  volatile.Register32 // 0x10
	PCR5  volatile.Register32 // 0x14
	PCR6  volatile.Register32 // 0x18
	PCR7  volatile.Register32 // 0x1C
	PCR8  volatile.Register32 // 0x20
	PCR9  volatile.Register32 // 0x24
	PCR10 volatile.Register32 // 0x28
	PCR11 volatile.Register32 // 0x2C
	PCR12 volatile.Register32 // 0x30
	PCR13 volatile.Register32 // 0x34
	PCR14 volatile.Register32 // 0x38
	PCR15 volatile.Register32 // 0x3C
	PCR16 volatile.Register32 // 0x40
	PCR17 volatile.Register32 // 0x44
	PCR18 volatile.Register32 // 0x48
	PCR19 volatile.Register32 // 0x4C
	PCR20 volatile.Register32 // 0x50
	PCR21 volatile.Register32 // 0x54
	PCR22 volatile.Register32 // 0x58
	PCR23 volatile.Register32 // 0x5C
	PCR24 volatile.Register32 // 0x60
	PCR25 volatile.Register32 // 0x64
	PCR26 volatile.Register32 // 0x68
	PCR27 volatile.Register32 // 0x6C
	PCR28 volatile.Register32 // 0x70
	PCR29 volatile.Register32 // 0x74
	PCR30 volatile.Register32 // 0x78
	PCR31 volatile.Register32 // 0x7C
	GPCLR volatile.Register32 // 0x80
	GPCHR volatile.Register32 // 0x84
	_     [24]byte
	ISFR  volatile.Register32 // 0xA0
}

// PORT.PCR0: Pin Control Register n
func (o *PORT_Type) SetPCR0_PS(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR0_PS() uint32 {
	return volatile.LoadUint32(&o.PCR0.Reg) & 0x1
}
func (o *PORT_Type) SetPCR0_PE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR0_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR0_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR0_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR0_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR0_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR0_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR0_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR0_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR0_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR0_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR0_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR0_LK(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR0_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR0_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR0_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR0_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR0.Reg, volatile.LoadUint32(&o.PCR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR0_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR0.Reg) & 0x1000000) >> 24
}

// PORT.PCR1: Pin Control Register n
func (o *PORT_Type) SetPCR1_PS(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR1_PS() uint32 {
	return volatile.LoadUint32(&o.PCR1.Reg) & 0x1
}
func (o *PORT_Type) SetPCR1_PE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR1_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR1_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR1_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR1_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR1_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR1_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR1_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR1_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR1_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR1_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR1_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR1_LK(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR1_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR1_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR1_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR1_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR1.Reg, volatile.LoadUint32(&o.PCR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR1_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR1.Reg) & 0x1000000) >> 24
}

// PORT.PCR2: Pin Control Register n
func (o *PORT_Type) SetPCR2_PS(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR2_PS() uint32 {
	return volatile.LoadUint32(&o.PCR2.Reg) & 0x1
}
func (o *PORT_Type) SetPCR2_PE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR2_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR2_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR2_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR2_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR2_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR2_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR2_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR2_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR2_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR2_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR2_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR2_LK(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR2_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR2_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR2_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR2_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR2.Reg, volatile.LoadUint32(&o.PCR2.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR2_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR2.Reg) & 0x1000000) >> 24
}

// PORT.PCR3: Pin Control Register n
func (o *PORT_Type) SetPCR3_PS(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR3_PS() uint32 {
	return volatile.LoadUint32(&o.PCR3.Reg) & 0x1
}
func (o *PORT_Type) SetPCR3_PE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR3_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR3_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR3_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR3_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR3_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR3_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR3_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR3_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR3_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR3_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR3_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR3_LK(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR3_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR3_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR3_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR3_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR3.Reg, volatile.LoadUint32(&o.PCR3.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR3_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR3.Reg) & 0x1000000) >> 24
}

// PORT.PCR4: Pin Control Register n
func (o *PORT_Type) SetPCR4_PS(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR4_PS() uint32 {
	return volatile.LoadUint32(&o.PCR4.Reg) & 0x1
}
func (o *PORT_Type) SetPCR4_PE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR4_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR4_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR4_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR4_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR4_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR4_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR4_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR4_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR4_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR4_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR4_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR4_LK(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR4_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR4_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR4_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR4_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR4.Reg, volatile.LoadUint32(&o.PCR4.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR4_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR4.Reg) & 0x1000000) >> 24
}

// PORT.PCR5: Pin Control Register n
func (o *PORT_Type) SetPCR5_PS(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR5_PS() uint32 {
	return volatile.LoadUint32(&o.PCR5.Reg) & 0x1
}
func (o *PORT_Type) SetPCR5_PE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR5_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR5_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR5_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR5_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR5_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR5_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR5_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR5_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR5_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR5_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR5_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR5_LK(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR5_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR5_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR5_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR5_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR5.Reg, volatile.LoadUint32(&o.PCR5.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR5_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR5.Reg) & 0x1000000) >> 24
}

// PORT.PCR6: Pin Control Register n
func (o *PORT_Type) SetPCR6_PS(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR6_PS() uint32 {
	return volatile.LoadUint32(&o.PCR6.Reg) & 0x1
}
func (o *PORT_Type) SetPCR6_PE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR6_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR6_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR6_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR6_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR6_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR6_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR6_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR6_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR6_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR6_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR6_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR6_LK(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR6_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR6_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR6_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR6_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR6.Reg, volatile.LoadUint32(&o.PCR6.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR6_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR6.Reg) & 0x1000000) >> 24
}

// PORT.PCR7: Pin Control Register n
func (o *PORT_Type) SetPCR7_PS(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR7_PS() uint32 {
	return volatile.LoadUint32(&o.PCR7.Reg) & 0x1
}
func (o *PORT_Type) SetPCR7_PE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR7_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR7_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR7_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR7_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR7_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR7_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR7_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR7_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR7_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR7_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR7_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR7_LK(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR7_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR7_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR7_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR7_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR7.Reg, volatile.LoadUint32(&o.PCR7.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR7_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR7.Reg) & 0x1000000) >> 24
}

// PORT.PCR8: Pin Control Register n
func (o *PORT_Type) SetPCR8_PS(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR8_PS() uint32 {
	return volatile.LoadUint32(&o.PCR8.Reg) & 0x1
}
func (o *PORT_Type) SetPCR8_PE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR8_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR8_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR8_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR8_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR8_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR8_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR8_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR8_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR8_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR8_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR8_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR8_LK(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR8_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR8_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR8_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR8_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR8.Reg, volatile.LoadUint32(&o.PCR8.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR8_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR8.Reg) & 0x1000000) >> 24
}

// PORT.PCR9: Pin Control Register n
func (o *PORT_Type) SetPCR9_PS(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR9_PS() uint32 {
	return volatile.LoadUint32(&o.PCR9.Reg) & 0x1
}
func (o *PORT_Type) SetPCR9_PE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR9_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR9_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR9_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR9_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR9_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR9_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR9_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR9_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR9_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR9_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR9_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR9_LK(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR9_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR9_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR9_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR9_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR9.Reg, volatile.LoadUint32(&o.PCR9.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR9_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR9.Reg) & 0x1000000) >> 24
}

// PORT.PCR10: Pin Control Register n
func (o *PORT_Type) SetPCR10_PS(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR10_PS() uint32 {
	return volatile.LoadUint32(&o.PCR10.Reg) & 0x1
}
func (o *PORT_Type) SetPCR10_PE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR10_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR10_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR10_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR10_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR10_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR10_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR10_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR10_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR10_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR10_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR10_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR10_LK(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR10_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR10_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR10_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR10_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR10.Reg, volatile.LoadUint32(&o.PCR10.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR10_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR10.Reg) & 0x1000000) >> 24
}

// PORT.PCR11: Pin Control Register n
func (o *PORT_Type) SetPCR11_PS(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR11_PS() uint32 {
	return volatile.LoadUint32(&o.PCR11.Reg) & 0x1
}
func (o *PORT_Type) SetPCR11_PE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR11_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR11_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR11_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR11_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR11_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR11_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR11_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR11_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR11_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR11_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR11_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR11_LK(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR11_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR11_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR11_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR11_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR11.Reg, volatile.LoadUint32(&o.PCR11.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR11_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR11.Reg) & 0x1000000) >> 24
}

// PORT.PCR12: Pin Control Register n
func (o *PORT_Type) SetPCR12_PS(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR12_PS() uint32 {
	return volatile.LoadUint32(&o.PCR12.Reg) & 0x1
}
func (o *PORT_Type) SetPCR12_PE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR12_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR12_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR12_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR12_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR12_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR12_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR12_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR12_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR12_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR12_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR12_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR12_LK(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR12_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR12_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR12_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR12_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR12.Reg, volatile.LoadUint32(&o.PCR12.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR12_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR12.Reg) & 0x1000000) >> 24
}

// PORT.PCR13: Pin Control Register n
func (o *PORT_Type) SetPCR13_PS(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR13_PS() uint32 {
	return volatile.LoadUint32(&o.PCR13.Reg) & 0x1
}
func (o *PORT_Type) SetPCR13_PE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR13_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR13_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR13_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR13_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR13_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR13_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR13_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR13_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR13_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR13_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR13_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR13_LK(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR13_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR13_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR13_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR13_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR13.Reg, volatile.LoadUint32(&o.PCR13.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR13_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR13.Reg) & 0x1000000) >> 24
}

// PORT.PCR14: Pin Control Register n
func (o *PORT_Type) SetPCR14_PS(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR14_PS() uint32 {
	return volatile.LoadUint32(&o.PCR14.Reg) & 0x1
}
func (o *PORT_Type) SetPCR14_PE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR14_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR14_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR14_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR14_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR14_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR14_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR14_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR14_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR14_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR14_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR14_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR14_LK(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR14_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR14_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR14_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR14_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR14.Reg, volatile.LoadUint32(&o.PCR14.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR14_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR14.Reg) & 0x1000000) >> 24
}

// PORT.PCR15: Pin Control Register n
func (o *PORT_Type) SetPCR15_PS(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR15_PS() uint32 {
	return volatile.LoadUint32(&o.PCR15.Reg) & 0x1
}
func (o *PORT_Type) SetPCR15_PE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR15_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR15_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR15_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR15_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR15_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR15_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR15_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR15_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR15_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR15_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR15_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR15_LK(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR15_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR15_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR15_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR15_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR15.Reg, volatile.LoadUint32(&o.PCR15.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR15_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR15.Reg) & 0x1000000) >> 24
}

// PORT.PCR16: Pin Control Register n
func (o *PORT_Type) SetPCR16_PS(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR16_PS() uint32 {
	return volatile.LoadUint32(&o.PCR16.Reg) & 0x1
}
func (o *PORT_Type) SetPCR16_PE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR16_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR16_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR16_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR16_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR16_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR16_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR16_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR16_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR16_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR16_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR16_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR16_LK(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR16_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR16_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR16_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR16_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR16.Reg, volatile.LoadUint32(&o.PCR16.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR16_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR16.Reg) & 0x1000000) >> 24
}

// PORT.PCR17: Pin Control Register n
func (o *PORT_Type) SetPCR17_PS(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR17_PS() uint32 {
	return volatile.LoadUint32(&o.PCR17.Reg) & 0x1
}
func (o *PORT_Type) SetPCR17_PE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR17_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR17_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR17_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR17_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR17_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR17_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR17_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR17_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR17_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR17_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR17_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR17_LK(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR17_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR17_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR17_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR17_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR17.Reg, volatile.LoadUint32(&o.PCR17.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR17_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR17.Reg) & 0x1000000) >> 24
}

// PORT.PCR18: Pin Control Register n
func (o *PORT_Type) SetPCR18_PS(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR18_PS() uint32 {
	return volatile.LoadUint32(&o.PCR18.Reg) & 0x1
}
func (o *PORT_Type) SetPCR18_PE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR18_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR18_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR18_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR18_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR18_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR18_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR18_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR18_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR18_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR18_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR18_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR18_LK(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR18_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR18_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR18_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR18_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR18.Reg, volatile.LoadUint32(&o.PCR18.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR18_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR18.Reg) & 0x1000000) >> 24
}

// PORT.PCR19: Pin Control Register n
func (o *PORT_Type) SetPCR19_PS(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR19_PS() uint32 {
	return volatile.LoadUint32(&o.PCR19.Reg) & 0x1
}
func (o *PORT_Type) SetPCR19_PE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR19_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR19_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR19_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR19_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR19_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR19_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR19_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR19_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR19_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR19_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR19_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR19_LK(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR19_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR19_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR19_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR19_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR19.Reg, volatile.LoadUint32(&o.PCR19.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR19_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR19.Reg) & 0x1000000) >> 24
}

// PORT.PCR20: Pin Control Register n
func (o *PORT_Type) SetPCR20_PS(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR20_PS() uint32 {
	return volatile.LoadUint32(&o.PCR20.Reg) & 0x1
}
func (o *PORT_Type) SetPCR20_PE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR20_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR20_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR20_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR20_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR20_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR20_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR20_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR20_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR20_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR20_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR20_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR20_LK(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR20_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR20_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR20_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR20_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR20.Reg, volatile.LoadUint32(&o.PCR20.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR20_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR20.Reg) & 0x1000000) >> 24
}

// PORT.PCR21: Pin Control Register n
func (o *PORT_Type) SetPCR21_PS(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR21_PS() uint32 {
	return volatile.LoadUint32(&o.PCR21.Reg) & 0x1
}
func (o *PORT_Type) SetPCR21_PE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR21_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR21_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR21_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR21_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR21_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR21_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR21_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR21_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR21_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR21_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR21_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR21_LK(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR21_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR21_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR21_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR21_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR21.Reg, volatile.LoadUint32(&o.PCR21.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR21_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR21.Reg) & 0x1000000) >> 24
}

// PORT.PCR22: Pin Control Register n
func (o *PORT_Type) SetPCR22_PS(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR22_PS() uint32 {
	return volatile.LoadUint32(&o.PCR22.Reg) & 0x1
}
func (o *PORT_Type) SetPCR22_PE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR22_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR22_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR22_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR22_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR22_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR22_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR22_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR22_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR22_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR22_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR22_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR22_LK(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR22_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR22_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR22_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR22_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR22.Reg, volatile.LoadUint32(&o.PCR22.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR22_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR22.Reg) & 0x1000000) >> 24
}

// PORT.PCR23: Pin Control Register n
func (o *PORT_Type) SetPCR23_PS(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR23_PS() uint32 {
	return volatile.LoadUint32(&o.PCR23.Reg) & 0x1
}
func (o *PORT_Type) SetPCR23_PE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR23_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR23_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR23_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR23_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR23_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR23_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR23_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR23_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR23_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR23_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR23_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR23_LK(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR23_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR23_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR23_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR23_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR23.Reg, volatile.LoadUint32(&o.PCR23.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR23_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR23.Reg) & 0x1000000) >> 24
}

// PORT.PCR24: Pin Control Register n
func (o *PORT_Type) SetPCR24_PS(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR24_PS() uint32 {
	return volatile.LoadUint32(&o.PCR24.Reg) & 0x1
}
func (o *PORT_Type) SetPCR24_PE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR24_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR24_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR24_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR24_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR24_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR24_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR24_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR24_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR24_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR24_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR24_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR24_LK(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR24_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR24_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR24_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR24_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR24.Reg, volatile.LoadUint32(&o.PCR24.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR24_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR24.Reg) & 0x1000000) >> 24
}

// PORT.PCR25: Pin Control Register n
func (o *PORT_Type) SetPCR25_PS(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR25_PS() uint32 {
	return volatile.LoadUint32(&o.PCR25.Reg) & 0x1
}
func (o *PORT_Type) SetPCR25_PE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR25_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR25_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR25_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR25_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR25_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR25_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR25_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR25_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR25_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR25_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR25_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR25_LK(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR25_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR25_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR25_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR25_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR25.Reg, volatile.LoadUint32(&o.PCR25.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR25_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR25.Reg) & 0x1000000) >> 24
}

// PORT.PCR26: Pin Control Register n
func (o *PORT_Type) SetPCR26_PS(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR26_PS() uint32 {
	return volatile.LoadUint32(&o.PCR26.Reg) & 0x1
}
func (o *PORT_Type) SetPCR26_PE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR26_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR26_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR26_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR26_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR26_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR26_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR26_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR26_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR26_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR26_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR26_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR26_LK(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR26_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR26_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR26_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR26_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR26.Reg, volatile.LoadUint32(&o.PCR26.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR26_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR26.Reg) & 0x1000000) >> 24
}

// PORT.PCR27: Pin Control Register n
func (o *PORT_Type) SetPCR27_PS(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR27_PS() uint32 {
	return volatile.LoadUint32(&o.PCR27.Reg) & 0x1
}
func (o *PORT_Type) SetPCR27_PE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR27_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR27_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR27_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR27_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR27_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR27_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR27_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR27_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR27_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR27_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR27_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR27_LK(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR27_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR27_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR27_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR27_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR27.Reg, volatile.LoadUint32(&o.PCR27.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR27_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR27.Reg) & 0x1000000) >> 24
}

// PORT.PCR28: Pin Control Register n
func (o *PORT_Type) SetPCR28_PS(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR28_PS() uint32 {
	return volatile.LoadUint32(&o.PCR28.Reg) & 0x1
}
func (o *PORT_Type) SetPCR28_PE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR28_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR28_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR28_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR28_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR28_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR28_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR28_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR28_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR28_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR28_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR28_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR28_LK(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR28_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR28_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR28_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR28_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR28.Reg, volatile.LoadUint32(&o.PCR28.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR28_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR28.Reg) & 0x1000000) >> 24
}

// PORT.PCR29: Pin Control Register n
func (o *PORT_Type) SetPCR29_PS(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR29_PS() uint32 {
	return volatile.LoadUint32(&o.PCR29.Reg) & 0x1
}
func (o *PORT_Type) SetPCR29_PE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR29_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR29_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR29_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR29_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR29_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR29_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR29_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR29_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR29_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR29_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR29_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR29_LK(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR29_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR29_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR29_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR29_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR29.Reg, volatile.LoadUint32(&o.PCR29.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR29_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR29.Reg) & 0x1000000) >> 24
}

// PORT.PCR30: Pin Control Register n
func (o *PORT_Type) SetPCR30_PS(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR30_PS() uint32 {
	return volatile.LoadUint32(&o.PCR30.Reg) & 0x1
}
func (o *PORT_Type) SetPCR30_PE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR30_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR30_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR30_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR30_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR30_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR30_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR30_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR30_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR30_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR30_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR30_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR30_LK(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR30_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR30_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR30_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR30_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR30.Reg, volatile.LoadUint32(&o.PCR30.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR30_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR30.Reg) & 0x1000000) >> 24
}

// PORT.PCR31: Pin Control Register n
func (o *PORT_Type) SetPCR31_PS(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetPCR31_PS() uint32 {
	return volatile.LoadUint32(&o.PCR31.Reg) & 0x1
}
func (o *PORT_Type) SetPCR31_PE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetPCR31_PE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetPCR31_SRE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetPCR31_SRE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetPCR31_PFE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetPCR31_PFE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetPCR31_ODE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetPCR31_ODE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetPCR31_DSE(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetPCR31_DSE() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetPCR31_MUX(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x700)|value<<8)
}
func (o *PORT_Type) GetPCR31_MUX() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x700) >> 8
}
func (o *PORT_Type) SetPCR31_LK(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetPCR31_LK() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetPCR31_IRQC(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0xf0000)|value<<16)
}
func (o *PORT_Type) GetPCR31_IRQC() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0xf0000) >> 16
}
func (o *PORT_Type) SetPCR31_ISF(value uint32) {
	volatile.StoreUint32(&o.PCR31.Reg, volatile.LoadUint32(&o.PCR31.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetPCR31_ISF() uint32 {
	return (volatile.LoadUint32(&o.PCR31.Reg) & 0x1000000) >> 24
}

// PORT.GPCLR: Global Pin Control Low Register
func (o *PORT_Type) SetGPCLR_GPWD(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0xffff)|value)
}
func (o *PORT_Type) GetGPCLR_GPWD() uint32 {
	return volatile.LoadUint32(&o.GPCLR.Reg) & 0xffff
}
func (o *PORT_Type) SetGPCLR_GPWE0(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x10000)|value<<16)
}
func (o *PORT_Type) GetGPCLR_GPWE0() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x10000) >> 16
}
func (o *PORT_Type) SetGPCLR_GPWE1(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x20000)|value<<17)
}
func (o *PORT_Type) GetGPCLR_GPWE1() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x20000) >> 17
}
func (o *PORT_Type) SetGPCLR_GPWE2(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x40000)|value<<18)
}
func (o *PORT_Type) GetGPCLR_GPWE2() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x40000) >> 18
}
func (o *PORT_Type) SetGPCLR_GPWE3(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x80000)|value<<19)
}
func (o *PORT_Type) GetGPCLR_GPWE3() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x80000) >> 19
}
func (o *PORT_Type) SetGPCLR_GPWE4(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x100000)|value<<20)
}
func (o *PORT_Type) GetGPCLR_GPWE4() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x100000) >> 20
}
func (o *PORT_Type) SetGPCLR_GPWE5(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x200000)|value<<21)
}
func (o *PORT_Type) GetGPCLR_GPWE5() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x200000) >> 21
}
func (o *PORT_Type) SetGPCLR_GPWE6(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x400000)|value<<22)
}
func (o *PORT_Type) GetGPCLR_GPWE6() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x400000) >> 22
}
func (o *PORT_Type) SetGPCLR_GPWE7(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x800000)|value<<23)
}
func (o *PORT_Type) GetGPCLR_GPWE7() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x800000) >> 23
}
func (o *PORT_Type) SetGPCLR_GPWE8(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetGPCLR_GPWE8() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x1000000) >> 24
}
func (o *PORT_Type) SetGPCLR_GPWE9(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT_Type) GetGPCLR_GPWE9() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x2000000) >> 25
}
func (o *PORT_Type) SetGPCLR_GPWE10(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT_Type) GetGPCLR_GPWE10() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x4000000) >> 26
}
func (o *PORT_Type) SetGPCLR_GPWE11(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT_Type) GetGPCLR_GPWE11() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x8000000) >> 27
}
func (o *PORT_Type) SetGPCLR_GPWE12(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT_Type) GetGPCLR_GPWE12() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x10000000) >> 28
}
func (o *PORT_Type) SetGPCLR_GPWE13(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT_Type) GetGPCLR_GPWE13() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x20000000) >> 29
}
func (o *PORT_Type) SetGPCLR_GPWE14(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT_Type) GetGPCLR_GPWE14() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x40000000) >> 30
}
func (o *PORT_Type) SetGPCLR_GPWE15(value uint32) {
	volatile.StoreUint32(&o.GPCLR.Reg, volatile.LoadUint32(&o.GPCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT_Type) GetGPCLR_GPWE15() uint32 {
	return (volatile.LoadUint32(&o.GPCLR.Reg) & 0x80000000) >> 31
}

// PORT.GPCHR: Global Pin Control High Register
func (o *PORT_Type) SetGPCHR_GPWD(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0xffff)|value)
}
func (o *PORT_Type) GetGPCHR_GPWD() uint32 {
	return volatile.LoadUint32(&o.GPCHR.Reg) & 0xffff
}
func (o *PORT_Type) SetGPCHR_GPWE0(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x10000)|value<<16)
}
func (o *PORT_Type) GetGPCHR_GPWE0() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x10000) >> 16
}
func (o *PORT_Type) SetGPCHR_GPWE1(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x20000)|value<<17)
}
func (o *PORT_Type) GetGPCHR_GPWE1() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x20000) >> 17
}
func (o *PORT_Type) SetGPCHR_GPWE2(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x40000)|value<<18)
}
func (o *PORT_Type) GetGPCHR_GPWE2() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x40000) >> 18
}
func (o *PORT_Type) SetGPCHR_GPWE3(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x80000)|value<<19)
}
func (o *PORT_Type) GetGPCHR_GPWE3() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x80000) >> 19
}
func (o *PORT_Type) SetGPCHR_GPWE4(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x100000)|value<<20)
}
func (o *PORT_Type) GetGPCHR_GPWE4() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x100000) >> 20
}
func (o *PORT_Type) SetGPCHR_GPWE5(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x200000)|value<<21)
}
func (o *PORT_Type) GetGPCHR_GPWE5() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x200000) >> 21
}
func (o *PORT_Type) SetGPCHR_GPWE6(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x400000)|value<<22)
}
func (o *PORT_Type) GetGPCHR_GPWE6() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x400000) >> 22
}
func (o *PORT_Type) SetGPCHR_GPWE7(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x800000)|value<<23)
}
func (o *PORT_Type) GetGPCHR_GPWE7() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x800000) >> 23
}
func (o *PORT_Type) SetGPCHR_GPWE8(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetGPCHR_GPWE8() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x1000000) >> 24
}
func (o *PORT_Type) SetGPCHR_GPWE9(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT_Type) GetGPCHR_GPWE9() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x2000000) >> 25
}
func (o *PORT_Type) SetGPCHR_GPWE10(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT_Type) GetGPCHR_GPWE10() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x4000000) >> 26
}
func (o *PORT_Type) SetGPCHR_GPWE11(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT_Type) GetGPCHR_GPWE11() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x8000000) >> 27
}
func (o *PORT_Type) SetGPCHR_GPWE12(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT_Type) GetGPCHR_GPWE12() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x10000000) >> 28
}
func (o *PORT_Type) SetGPCHR_GPWE13(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT_Type) GetGPCHR_GPWE13() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x20000000) >> 29
}
func (o *PORT_Type) SetGPCHR_GPWE14(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT_Type) GetGPCHR_GPWE14() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x40000000) >> 30
}
func (o *PORT_Type) SetGPCHR_GPWE15(value uint32) {
	volatile.StoreUint32(&o.GPCHR.Reg, volatile.LoadUint32(&o.GPCHR.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT_Type) GetGPCHR_GPWE15() uint32 {
	return (volatile.LoadUint32(&o.GPCHR.Reg) & 0x80000000) >> 31
}

// PORT.ISFR: Interrupt Status Flag Register
func (o *PORT_Type) SetISFR_ISF0(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x1)|value)
}
func (o *PORT_Type) GetISFR_ISF0() uint32 {
	return volatile.LoadUint32(&o.ISFR.Reg) & 0x1
}
func (o *PORT_Type) SetISFR_ISF1(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x2)|value<<1)
}
func (o *PORT_Type) GetISFR_ISF1() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x2) >> 1
}
func (o *PORT_Type) SetISFR_ISF2(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x4)|value<<2)
}
func (o *PORT_Type) GetISFR_ISF2() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x4) >> 2
}
func (o *PORT_Type) SetISFR_ISF3(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x8)|value<<3)
}
func (o *PORT_Type) GetISFR_ISF3() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x8) >> 3
}
func (o *PORT_Type) SetISFR_ISF4(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x10)|value<<4)
}
func (o *PORT_Type) GetISFR_ISF4() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x10) >> 4
}
func (o *PORT_Type) SetISFR_ISF5(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x20)|value<<5)
}
func (o *PORT_Type) GetISFR_ISF5() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x20) >> 5
}
func (o *PORT_Type) SetISFR_ISF6(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x40)|value<<6)
}
func (o *PORT_Type) GetISFR_ISF6() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x40) >> 6
}
func (o *PORT_Type) SetISFR_ISF7(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x80)|value<<7)
}
func (o *PORT_Type) GetISFR_ISF7() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x80) >> 7
}
func (o *PORT_Type) SetISFR_ISF8(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x100)|value<<8)
}
func (o *PORT_Type) GetISFR_ISF8() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x100) >> 8
}
func (o *PORT_Type) SetISFR_ISF9(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x200)|value<<9)
}
func (o *PORT_Type) GetISFR_ISF9() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x200) >> 9
}
func (o *PORT_Type) SetISFR_ISF10(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x400)|value<<10)
}
func (o *PORT_Type) GetISFR_ISF10() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x400) >> 10
}
func (o *PORT_Type) SetISFR_ISF11(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x800)|value<<11)
}
func (o *PORT_Type) GetISFR_ISF11() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x800) >> 11
}
func (o *PORT_Type) SetISFR_ISF12(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x1000)|value<<12)
}
func (o *PORT_Type) GetISFR_ISF12() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x1000) >> 12
}
func (o *PORT_Type) SetISFR_ISF13(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x2000)|value<<13)
}
func (o *PORT_Type) GetISFR_ISF13() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x2000) >> 13
}
func (o *PORT_Type) SetISFR_ISF14(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x4000)|value<<14)
}
func (o *PORT_Type) GetISFR_ISF14() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x4000) >> 14
}
func (o *PORT_Type) SetISFR_ISF15(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_Type) GetISFR_ISF15() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x8000) >> 15
}
func (o *PORT_Type) SetISFR_ISF16(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x10000)|value<<16)
}
func (o *PORT_Type) GetISFR_ISF16() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x10000) >> 16
}
func (o *PORT_Type) SetISFR_ISF17(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x20000)|value<<17)
}
func (o *PORT_Type) GetISFR_ISF17() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x20000) >> 17
}
func (o *PORT_Type) SetISFR_ISF18(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x40000)|value<<18)
}
func (o *PORT_Type) GetISFR_ISF18() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x40000) >> 18
}
func (o *PORT_Type) SetISFR_ISF19(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x80000)|value<<19)
}
func (o *PORT_Type) GetISFR_ISF19() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x80000) >> 19
}
func (o *PORT_Type) SetISFR_ISF20(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x100000)|value<<20)
}
func (o *PORT_Type) GetISFR_ISF20() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x100000) >> 20
}
func (o *PORT_Type) SetISFR_ISF21(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x200000)|value<<21)
}
func (o *PORT_Type) GetISFR_ISF21() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x200000) >> 21
}
func (o *PORT_Type) SetISFR_ISF22(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x400000)|value<<22)
}
func (o *PORT_Type) GetISFR_ISF22() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x400000) >> 22
}
func (o *PORT_Type) SetISFR_ISF23(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x800000)|value<<23)
}
func (o *PORT_Type) GetISFR_ISF23() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x800000) >> 23
}
func (o *PORT_Type) SetISFR_ISF24(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x1000000)|value<<24)
}
func (o *PORT_Type) GetISFR_ISF24() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x1000000) >> 24
}
func (o *PORT_Type) SetISFR_ISF25(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x2000000)|value<<25)
}
func (o *PORT_Type) GetISFR_ISF25() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x2000000) >> 25
}
func (o *PORT_Type) SetISFR_ISF26(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x4000000)|value<<26)
}
func (o *PORT_Type) GetISFR_ISF26() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x4000000) >> 26
}
func (o *PORT_Type) SetISFR_ISF27(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x8000000)|value<<27)
}
func (o *PORT_Type) GetISFR_ISF27() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x8000000) >> 27
}
func (o *PORT_Type) SetISFR_ISF28(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT_Type) GetISFR_ISF28() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x10000000) >> 28
}
func (o *PORT_Type) SetISFR_ISF29(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x20000000)|value<<29)
}
func (o *PORT_Type) GetISFR_ISF29() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x20000000) >> 29
}
func (o *PORT_Type) SetISFR_ISF30(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT_Type) GetISFR_ISF30() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x40000000) >> 30
}
func (o *PORT_Type) SetISFR_ISF31(value uint32) {
	volatile.StoreUint32(&o.ISFR.Reg, volatile.LoadUint32(&o.ISFR.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT_Type) GetISFR_ISF31() uint32 {
	return (volatile.LoadUint32(&o.ISFR.Reg) & 0x80000000) >> 31
}

// Generation 2008 Watchdog Timer
type WDOG_Type struct {
	STCTRLH volatile.Register16 // 0x0
	STCTRLL volatile.Register16 // 0x2
	TOVALH  volatile.Register16 // 0x4
	TOVALL  volatile.Register16 // 0x6
	WINH    volatile.Register16 // 0x8
	WINL    volatile.Register16 // 0xA
	REFRESH volatile.Register16 // 0xC
	UNLOCK  volatile.Register16 // 0xE
	TMROUTH volatile.Register16 // 0x10
	TMROUTL volatile.Register16 // 0x12
	RSTCNT  volatile.Register16 // 0x14
	PRESC   volatile.Register16 // 0x16
}

// WDOG.STCTRLH: Watchdog Status and Control Register High
func (o *WDOG_Type) SetSTCTRLH_WDOGEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x1)|value)
}
func (o *WDOG_Type) GetSTCTRLH_WDOGEN() uint16 {
	return volatile.LoadUint16(&o.STCTRLH.Reg) & 0x1
}
func (o *WDOG_Type) SetSTCTRLH_CLKSRC(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x2)|value<<1)
}
func (o *WDOG_Type) GetSTCTRLH_CLKSRC() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x2) >> 1
}
func (o *WDOG_Type) SetSTCTRLH_IRQRSTEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x4)|value<<2)
}
func (o *WDOG_Type) GetSTCTRLH_IRQRSTEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x4) >> 2
}
func (o *WDOG_Type) SetSTCTRLH_WINEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x8)|value<<3)
}
func (o *WDOG_Type) GetSTCTRLH_WINEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x8) >> 3
}
func (o *WDOG_Type) SetSTCTRLH_ALLOWUPDATE(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x10)|value<<4)
}
func (o *WDOG_Type) GetSTCTRLH_ALLOWUPDATE() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x10) >> 4
}
func (o *WDOG_Type) SetSTCTRLH_DBGEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x20)|value<<5)
}
func (o *WDOG_Type) GetSTCTRLH_DBGEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x20) >> 5
}
func (o *WDOG_Type) SetSTCTRLH_STOPEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x40)|value<<6)
}
func (o *WDOG_Type) GetSTCTRLH_STOPEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x40) >> 6
}
func (o *WDOG_Type) SetSTCTRLH_WAITEN(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x80)|value<<7)
}
func (o *WDOG_Type) GetSTCTRLH_WAITEN() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x80) >> 7
}
func (o *WDOG_Type) SetSTCTRLH_TESTWDOG(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x400)|value<<10)
}
func (o *WDOG_Type) GetSTCTRLH_TESTWDOG() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x400) >> 10
}
func (o *WDOG_Type) SetSTCTRLH_TESTSEL(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x800)|value<<11)
}
func (o *WDOG_Type) GetSTCTRLH_TESTSEL() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x800) >> 11
}
func (o *WDOG_Type) SetSTCTRLH_BYTESEL(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x3000)|value<<12)
}
func (o *WDOG_Type) GetSTCTRLH_BYTESEL() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x3000) >> 12
}
func (o *WDOG_Type) SetSTCTRLH_DISTESTWDOG(value uint16) {
	volatile.StoreUint16(&o.STCTRLH.Reg, volatile.LoadUint16(&o.STCTRLH.Reg)&^(0x4000)|value<<14)
}
func (o *WDOG_Type) GetSTCTRLH_DISTESTWDOG() uint16 {
	return (volatile.LoadUint16(&o.STCTRLH.Reg) & 0x4000) >> 14
}

// WDOG.STCTRLL: Watchdog Status and Control Register Low
func (o *WDOG_Type) SetSTCTRLL_INTFLG(value uint16) {
	volatile.StoreUint16(&o.STCTRLL.Reg, volatile.LoadUint16(&o.STCTRLL.Reg)&^(0x8000)|value<<15)
}
func (o *WDOG_Type) GetSTCTRLL_INTFLG() uint16 {
	return (volatile.LoadUint16(&o.STCTRLL.Reg) & 0x8000) >> 15
}

// WDOG.TOVALH: Watchdog Time-out Value Register High
func (o *WDOG_Type) SetTOVALH(value uint16) {
	volatile.StoreUint16(&o.TOVALH.Reg, value)
}
func (o *WDOG_Type) GetTOVALH() uint16 {
	return volatile.LoadUint16(&o.TOVALH.Reg)
}

// WDOG.TOVALL: Watchdog Time-out Value Register Low
func (o *WDOG_Type) SetTOVALL(value uint16) {
	volatile.StoreUint16(&o.TOVALL.Reg, value)
}
func (o *WDOG_Type) GetTOVALL() uint16 {
	return volatile.LoadUint16(&o.TOVALL.Reg)
}

// WDOG.WINH: Watchdog Window Register High
func (o *WDOG_Type) SetWINH(value uint16) {
	volatile.StoreUint16(&o.WINH.Reg, value)
}
func (o *WDOG_Type) GetWINH() uint16 {
	return volatile.LoadUint16(&o.WINH.Reg)
}

// WDOG.WINL: Watchdog Window Register Low
func (o *WDOG_Type) SetWINL(value uint16) {
	volatile.StoreUint16(&o.WINL.Reg, value)
}
func (o *WDOG_Type) GetWINL() uint16 {
	return volatile.LoadUint16(&o.WINL.Reg)
}

// WDOG.REFRESH: Watchdog Refresh register
func (o *WDOG_Type) SetREFRESH(value uint16) {
	volatile.StoreUint16(&o.REFRESH.Reg, value)
}
func (o *WDOG_Type) GetREFRESH() uint16 {
	return volatile.LoadUint16(&o.REFRESH.Reg)
}

// WDOG.UNLOCK: Watchdog Unlock register
func (o *WDOG_Type) SetUNLOCK(value uint16) {
	volatile.StoreUint16(&o.UNLOCK.Reg, value)
}
func (o *WDOG_Type) GetUNLOCK() uint16 {
	return volatile.LoadUint16(&o.UNLOCK.Reg)
}

// WDOG.TMROUTH: Watchdog Timer Output Register High
func (o *WDOG_Type) SetTMROUTH(value uint16) {
	volatile.StoreUint16(&o.TMROUTH.Reg, value)
}
func (o *WDOG_Type) GetTMROUTH() uint16 {
	return volatile.LoadUint16(&o.TMROUTH.Reg)
}

// WDOG.TMROUTL: Watchdog Timer Output Register Low
func (o *WDOG_Type) SetTMROUTL(value uint16) {
	volatile.StoreUint16(&o.TMROUTL.Reg, value)
}
func (o *WDOG_Type) GetTMROUTL() uint16 {
	return volatile.LoadUint16(&o.TMROUTL.Reg)
}

// WDOG.RSTCNT: Watchdog Reset Count register
func (o *WDOG_Type) SetRSTCNT(value uint16) {
	volatile.StoreUint16(&o.RSTCNT.Reg, value)
}
func (o *WDOG_Type) GetRSTCNT() uint16 {
	return volatile.LoadUint16(&o.RSTCNT.Reg)
}

// WDOG.PRESC: Watchdog Prescaler register
func (o *WDOG_Type) SetPRESC_PRESCVAL(value uint16) {
	volatile.StoreUint16(&o.PRESC.Reg, volatile.LoadUint16(&o.PRESC.Reg)&^(0x700)|value<<8)
}
func (o *WDOG_Type) GetPRESC_PRESCVAL() uint16 {
	return (volatile.LoadUint16(&o.PRESC.Reg) & 0x700) >> 8
}

// External Watchdog Monitor
type EWM_Type struct {
	CTRL volatile.Register8 // 0x0
	SERV volatile.Register8 // 0x1
	CMPL volatile.Register8 // 0x2
	CMPH volatile.Register8 // 0x3
}

// EWM.CTRL: Control Register
func (o *EWM_Type) SetCTRL_EWMEN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *EWM_Type) GetCTRL_EWMEN() uint8 {
	return volatile.LoadUint8(&o.CTRL.Reg) & 0x1
}
func (o *EWM_Type) SetCTRL_ASSIN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *EWM_Type) GetCTRL_ASSIN() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *EWM_Type) SetCTRL_INEN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EWM_Type) GetCTRL_INEN() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *EWM_Type) SetCTRL_INTEN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *EWM_Type) GetCTRL_INTEN() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x8) >> 3
}

// EWM.SERV: Service Register
func (o *EWM_Type) SetSERV(value uint8) {
	volatile.StoreUint8(&o.SERV.Reg, value)
}
func (o *EWM_Type) GetSERV() uint8 {
	return volatile.LoadUint8(&o.SERV.Reg)
}

// EWM.CMPL: Compare Low Register
func (o *EWM_Type) SetCMPL(value uint8) {
	volatile.StoreUint8(&o.CMPL.Reg, value)
}
func (o *EWM_Type) GetCMPL() uint8 {
	return volatile.LoadUint8(&o.CMPL.Reg)
}

// EWM.CMPH: Compare High Register
func (o *EWM_Type) SetCMPH(value uint8) {
	volatile.StoreUint8(&o.CMPH.Reg, value)
}
func (o *EWM_Type) GetCMPH() uint8 {
	return volatile.LoadUint8(&o.CMPH.Reg)
}

// Carrier Modulator Transmitter
type CMT_Type struct {
	CGH1 volatile.Register8 // 0x0
	CGL1 volatile.Register8 // 0x1
	CGH2 volatile.Register8 // 0x2
	CGL2 volatile.Register8 // 0x3
	OC   volatile.Register8 // 0x4
	MSC  volatile.Register8 // 0x5
	CMD1 volatile.Register8 // 0x6
	CMD2 volatile.Register8 // 0x7
	CMD3 volatile.Register8 // 0x8
	CMD4 volatile.Register8 // 0x9
	PPS  volatile.Register8 // 0xA
	DMA  volatile.Register8 // 0xB
}

// CMT.CGH1: CMT Carrier Generator High Data Register 1
func (o *CMT_Type) SetCGH1(value uint8) {
	volatile.StoreUint8(&o.CGH1.Reg, value)
}
func (o *CMT_Type) GetCGH1() uint8 {
	return volatile.LoadUint8(&o.CGH1.Reg)
}

// CMT.CGL1: CMT Carrier Generator Low Data Register 1
func (o *CMT_Type) SetCGL1(value uint8) {
	volatile.StoreUint8(&o.CGL1.Reg, value)
}
func (o *CMT_Type) GetCGL1() uint8 {
	return volatile.LoadUint8(&o.CGL1.Reg)
}

// CMT.CGH2: CMT Carrier Generator High Data Register 2
func (o *CMT_Type) SetCGH2(value uint8) {
	volatile.StoreUint8(&o.CGH2.Reg, value)
}
func (o *CMT_Type) GetCGH2() uint8 {
	return volatile.LoadUint8(&o.CGH2.Reg)
}

// CMT.CGL2: CMT Carrier Generator Low Data Register 2
func (o *CMT_Type) SetCGL2(value uint8) {
	volatile.StoreUint8(&o.CGL2.Reg, value)
}
func (o *CMT_Type) GetCGL2() uint8 {
	return volatile.LoadUint8(&o.CGL2.Reg)
}

// CMT.OC: CMT Output Control Register
func (o *CMT_Type) SetOC_IROPEN(value uint8) {
	volatile.StoreUint8(&o.OC.Reg, volatile.LoadUint8(&o.OC.Reg)&^(0x20)|value<<5)
}
func (o *CMT_Type) GetOC_IROPEN() uint8 {
	return (volatile.LoadUint8(&o.OC.Reg) & 0x20) >> 5
}
func (o *CMT_Type) SetOC_CMTPOL(value uint8) {
	volatile.StoreUint8(&o.OC.Reg, volatile.LoadUint8(&o.OC.Reg)&^(0x40)|value<<6)
}
func (o *CMT_Type) GetOC_CMTPOL() uint8 {
	return (volatile.LoadUint8(&o.OC.Reg) & 0x40) >> 6
}
func (o *CMT_Type) SetOC_IROL(value uint8) {
	volatile.StoreUint8(&o.OC.Reg, volatile.LoadUint8(&o.OC.Reg)&^(0x80)|value<<7)
}
func (o *CMT_Type) GetOC_IROL() uint8 {
	return (volatile.LoadUint8(&o.OC.Reg) & 0x80) >> 7
}

// CMT.MSC: CMT Modulator Status and Control Register
func (o *CMT_Type) SetMSC_MCGEN(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x1)|value)
}
func (o *CMT_Type) GetMSC_MCGEN() uint8 {
	return volatile.LoadUint8(&o.MSC.Reg) & 0x1
}
func (o *CMT_Type) SetMSC_EOCIE(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x2)|value<<1)
}
func (o *CMT_Type) GetMSC_EOCIE() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x2) >> 1
}
func (o *CMT_Type) SetMSC_FSK(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x4)|value<<2)
}
func (o *CMT_Type) GetMSC_FSK() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x4) >> 2
}
func (o *CMT_Type) SetMSC_BASE(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x8)|value<<3)
}
func (o *CMT_Type) GetMSC_BASE() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x8) >> 3
}
func (o *CMT_Type) SetMSC_EXSPC(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x10)|value<<4)
}
func (o *CMT_Type) GetMSC_EXSPC() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x10) >> 4
}
func (o *CMT_Type) SetMSC_CMTDIV(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x60)|value<<5)
}
func (o *CMT_Type) GetMSC_CMTDIV() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x60) >> 5
}
func (o *CMT_Type) SetMSC_EOCF(value uint8) {
	volatile.StoreUint8(&o.MSC.Reg, volatile.LoadUint8(&o.MSC.Reg)&^(0x80)|value<<7)
}
func (o *CMT_Type) GetMSC_EOCF() uint8 {
	return (volatile.LoadUint8(&o.MSC.Reg) & 0x80) >> 7
}

// CMT.CMD1: CMT Modulator Data Register Mark High
func (o *CMT_Type) SetCMD1(value uint8) {
	volatile.StoreUint8(&o.CMD1.Reg, value)
}
func (o *CMT_Type) GetCMD1() uint8 {
	return volatile.LoadUint8(&o.CMD1.Reg)
}

// CMT.CMD2: CMT Modulator Data Register Mark Low
func (o *CMT_Type) SetCMD2(value uint8) {
	volatile.StoreUint8(&o.CMD2.Reg, value)
}
func (o *CMT_Type) GetCMD2() uint8 {
	return volatile.LoadUint8(&o.CMD2.Reg)
}

// CMT.CMD3: CMT Modulator Data Register Space High
func (o *CMT_Type) SetCMD3(value uint8) {
	volatile.StoreUint8(&o.CMD3.Reg, value)
}
func (o *CMT_Type) GetCMD3() uint8 {
	return volatile.LoadUint8(&o.CMD3.Reg)
}

// CMT.CMD4: CMT Modulator Data Register Space Low
func (o *CMT_Type) SetCMD4(value uint8) {
	volatile.StoreUint8(&o.CMD4.Reg, value)
}
func (o *CMT_Type) GetCMD4() uint8 {
	return volatile.LoadUint8(&o.CMD4.Reg)
}

// CMT.PPS: CMT Primary Prescaler Register
func (o *CMT_Type) SetPPS_PPSDIV(value uint8) {
	volatile.StoreUint8(&o.PPS.Reg, volatile.LoadUint8(&o.PPS.Reg)&^(0xf)|value)
}
func (o *CMT_Type) GetPPS_PPSDIV() uint8 {
	return volatile.LoadUint8(&o.PPS.Reg) & 0xf
}

// CMT.DMA: CMT Direct Memory Access Register
func (o *CMT_Type) SetDMA(value uint8) {
	volatile.StoreUint8(&o.DMA.Reg, volatile.LoadUint8(&o.DMA.Reg)&^(0x1)|value)
}
func (o *CMT_Type) GetDMA() uint8 {
	return volatile.LoadUint8(&o.DMA.Reg) & 0x1
}

// Multipurpose Clock Generator module
type MCG_Type struct {
	C1    volatile.Register8 // 0x0
	C2    volatile.Register8 // 0x1
	C3    volatile.Register8 // 0x2
	C4    volatile.Register8 // 0x3
	C5    volatile.Register8 // 0x4
	C6    volatile.Register8 // 0x5
	S     volatile.Register8 // 0x6
	_     byte
	SC    volatile.Register8 // 0x8
	_     byte
	ATCVH volatile.Register8 // 0xA
	ATCVL volatile.Register8 // 0xB
	C7    volatile.Register8 // 0xC
	C8    volatile.Register8 // 0xD
	C9    volatile.Register8 // 0xE
	_     byte
	C11   volatile.Register8 // 0x10
	_     byte
	S2    volatile.Register8 // 0x12
}

// MCG.C1: MCG Control 1 Register
func (o *MCG_Type) SetC1_IREFSTEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetC1_IREFSTEN() uint8 {
	return volatile.LoadUint8(&o.C1.Reg) & 0x1
}
func (o *MCG_Type) SetC1_IRCLKEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x2)|value<<1)
}
func (o *MCG_Type) GetC1_IRCLKEN() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x2) >> 1
}
func (o *MCG_Type) SetC1_IREFS(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x4)|value<<2)
}
func (o *MCG_Type) GetC1_IREFS() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x4) >> 2
}
func (o *MCG_Type) SetC1_FRDIV(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x38)|value<<3)
}
func (o *MCG_Type) GetC1_FRDIV() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x38) >> 3
}
func (o *MCG_Type) SetC1_CLKS(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0xc0)|value<<6)
}
func (o *MCG_Type) GetC1_CLKS() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0xc0) >> 6
}

// MCG.C2: MCG Control 2 Register
func (o *MCG_Type) SetC2_IRCS(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetC2_IRCS() uint8 {
	return volatile.LoadUint8(&o.C2.Reg) & 0x1
}
func (o *MCG_Type) SetC2_LP(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x2)|value<<1)
}
func (o *MCG_Type) GetC2_LP() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x2) >> 1
}
func (o *MCG_Type) SetC2_EREFS(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x4)|value<<2)
}
func (o *MCG_Type) GetC2_EREFS() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x4) >> 2
}
func (o *MCG_Type) SetC2_HGO(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x8)|value<<3)
}
func (o *MCG_Type) GetC2_HGO() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x8) >> 3
}
func (o *MCG_Type) SetC2_RANGE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x30)|value<<4)
}
func (o *MCG_Type) GetC2_RANGE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x30) >> 4
}
func (o *MCG_Type) SetC2_FCFTRIM(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetC2_FCFTRIM() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetC2_LOCRE0(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetC2_LOCRE0() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x80) >> 7
}

// MCG.C3: MCG Control 3 Register
func (o *MCG_Type) SetC3(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, value)
}
func (o *MCG_Type) GetC3() uint8 {
	return volatile.LoadUint8(&o.C3.Reg)
}

// MCG.C4: MCG Control 4 Register
func (o *MCG_Type) SetC4_SCFTRIM(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetC4_SCFTRIM() uint8 {
	return volatile.LoadUint8(&o.C4.Reg) & 0x1
}
func (o *MCG_Type) SetC4_FCTRIM(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x1e)|value<<1)
}
func (o *MCG_Type) GetC4_FCTRIM() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x1e) >> 1
}
func (o *MCG_Type) SetC4_DRST_DRS(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x60)|value<<5)
}
func (o *MCG_Type) GetC4_DRST_DRS() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x60) >> 5
}
func (o *MCG_Type) SetC4_DMX32(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetC4_DMX32() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x80) >> 7
}

// MCG.C5: MCG Control 5 Register
func (o *MCG_Type) SetC5_PRDIV(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x7)|value)
}
func (o *MCG_Type) GetC5_PRDIV() uint8 {
	return volatile.LoadUint8(&o.C5.Reg) & 0x7
}
func (o *MCG_Type) SetC5_PLLSTEN(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetC5_PLLSTEN() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetC5_PLLCLKEN(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetC5_PLLCLKEN() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x40) >> 6
}

// MCG.C6: MCG Control 6 Register
func (o *MCG_Type) SetC6_VDIV(value uint8) {
	volatile.StoreUint8(&o.C6.Reg, volatile.LoadUint8(&o.C6.Reg)&^(0x1f)|value)
}
func (o *MCG_Type) GetC6_VDIV() uint8 {
	return volatile.LoadUint8(&o.C6.Reg) & 0x1f
}
func (o *MCG_Type) SetC6_CME0(value uint8) {
	volatile.StoreUint8(&o.C6.Reg, volatile.LoadUint8(&o.C6.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetC6_CME0() uint8 {
	return (volatile.LoadUint8(&o.C6.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetC6_PLLS(value uint8) {
	volatile.StoreUint8(&o.C6.Reg, volatile.LoadUint8(&o.C6.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetC6_PLLS() uint8 {
	return (volatile.LoadUint8(&o.C6.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetC6_LOLIE0(value uint8) {
	volatile.StoreUint8(&o.C6.Reg, volatile.LoadUint8(&o.C6.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetC6_LOLIE0() uint8 {
	return (volatile.LoadUint8(&o.C6.Reg) & 0x80) >> 7
}

// MCG.S: MCG Status Register
func (o *MCG_Type) SetS_IRCST(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetS_IRCST() uint8 {
	return volatile.LoadUint8(&o.S.Reg) & 0x1
}
func (o *MCG_Type) SetS_OSCINIT0(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x2)|value<<1)
}
func (o *MCG_Type) GetS_OSCINIT0() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x2) >> 1
}
func (o *MCG_Type) SetS_CLKST(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0xc)|value<<2)
}
func (o *MCG_Type) GetS_CLKST() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0xc) >> 2
}
func (o *MCG_Type) SetS_IREFST(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x10)|value<<4)
}
func (o *MCG_Type) GetS_IREFST() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x10) >> 4
}
func (o *MCG_Type) SetS_PLLST(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetS_PLLST() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetS_LOCK0(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetS_LOCK0() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetS_LOLS0(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetS_LOLS0() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x80) >> 7
}

// MCG.SC: MCG Status and Control Register
func (o *MCG_Type) SetSC_LOCS0(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetSC_LOCS0() uint8 {
	return volatile.LoadUint8(&o.SC.Reg) & 0x1
}
func (o *MCG_Type) SetSC_FCRDIV(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0xe)|value<<1)
}
func (o *MCG_Type) GetSC_FCRDIV() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0xe) >> 1
}
func (o *MCG_Type) SetSC_FLTPRSRV(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x10)|value<<4)
}
func (o *MCG_Type) GetSC_FLTPRSRV() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x10) >> 4
}
func (o *MCG_Type) SetSC_ATMF(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetSC_ATMF() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetSC_ATMS(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetSC_ATMS() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetSC_ATME(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetSC_ATME() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x80) >> 7
}

// MCG.ATCVH: MCG Auto Trim Compare Value High Register
func (o *MCG_Type) SetATCVH(value uint8) {
	volatile.StoreUint8(&o.ATCVH.Reg, value)
}
func (o *MCG_Type) GetATCVH() uint8 {
	return volatile.LoadUint8(&o.ATCVH.Reg)
}

// MCG.ATCVL: MCG Auto Trim Compare Value Low Register
func (o *MCG_Type) SetATCVL(value uint8) {
	volatile.StoreUint8(&o.ATCVL.Reg, value)
}
func (o *MCG_Type) GetATCVL() uint8 {
	return volatile.LoadUint8(&o.ATCVL.Reg)
}

// MCG.C7: MCG Control 7 Register
func (o *MCG_Type) SetC7_OSCSEL(value uint8) {
	volatile.StoreUint8(&o.C7.Reg, volatile.LoadUint8(&o.C7.Reg)&^(0x3)|value)
}
func (o *MCG_Type) GetC7_OSCSEL() uint8 {
	return volatile.LoadUint8(&o.C7.Reg) & 0x3
}

// MCG.C8: MCG Control 8 Register
func (o *MCG_Type) SetC8_LOCS1(value uint8) {
	volatile.StoreUint8(&o.C8.Reg, volatile.LoadUint8(&o.C8.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetC8_LOCS1() uint8 {
	return volatile.LoadUint8(&o.C8.Reg) & 0x1
}
func (o *MCG_Type) SetC8_CME1(value uint8) {
	volatile.StoreUint8(&o.C8.Reg, volatile.LoadUint8(&o.C8.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetC8_CME1() uint8 {
	return (volatile.LoadUint8(&o.C8.Reg) & 0x20) >> 5
}
func (o *MCG_Type) SetC8_LOLRE(value uint8) {
	volatile.StoreUint8(&o.C8.Reg, volatile.LoadUint8(&o.C8.Reg)&^(0x40)|value<<6)
}
func (o *MCG_Type) GetC8_LOLRE() uint8 {
	return (volatile.LoadUint8(&o.C8.Reg) & 0x40) >> 6
}
func (o *MCG_Type) SetC8_LOCRE1(value uint8) {
	volatile.StoreUint8(&o.C8.Reg, volatile.LoadUint8(&o.C8.Reg)&^(0x80)|value<<7)
}
func (o *MCG_Type) GetC8_LOCRE1() uint8 {
	return (volatile.LoadUint8(&o.C8.Reg) & 0x80) >> 7
}

// MCG.C9: MCG Control 9 Register
func (o *MCG_Type) SetC9_EXT_PLL_LOCS(value uint8) {
	volatile.StoreUint8(&o.C9.Reg, volatile.LoadUint8(&o.C9.Reg)&^(0x1)|value)
}
func (o *MCG_Type) GetC9_EXT_PLL_LOCS() uint8 {
	return volatile.LoadUint8(&o.C9.Reg) & 0x1
}
func (o *MCG_Type) SetC9_PLL_LOCRE(value uint8) {
	volatile.StoreUint8(&o.C9.Reg, volatile.LoadUint8(&o.C9.Reg)&^(0x10)|value<<4)
}
func (o *MCG_Type) GetC9_PLL_LOCRE() uint8 {
	return (volatile.LoadUint8(&o.C9.Reg) & 0x10) >> 4
}
func (o *MCG_Type) SetC9_PLL_CME(value uint8) {
	volatile.StoreUint8(&o.C9.Reg, volatile.LoadUint8(&o.C9.Reg)&^(0x20)|value<<5)
}
func (o *MCG_Type) GetC9_PLL_CME() uint8 {
	return (volatile.LoadUint8(&o.C9.Reg) & 0x20) >> 5
}

// MCG.C11: MCG Control 11 Register
func (o *MCG_Type) SetC11_PLLCS(value uint8) {
	volatile.StoreUint8(&o.C11.Reg, volatile.LoadUint8(&o.C11.Reg)&^(0x10)|value<<4)
}
func (o *MCG_Type) GetC11_PLLCS() uint8 {
	return (volatile.LoadUint8(&o.C11.Reg) & 0x10) >> 4
}

// MCG.S2: MCG Status 2 Register
func (o *MCG_Type) SetS2_PLLCST(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x10)|value<<4)
}
func (o *MCG_Type) GetS2_PLLCST() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x10) >> 4
}

// Oscillator
type OSC_Type struct {
	CR  volatile.Register8 // 0x0
	_   byte
	DIV volatile.Register8 // 0x2
}

// OSC.CR: OSC Control Register
func (o *OSC_Type) SetCR_SC16P(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x1)|value)
}
func (o *OSC_Type) GetCR_SC16P() uint8 {
	return volatile.LoadUint8(&o.CR.Reg) & 0x1
}
func (o *OSC_Type) SetCR_SC8P(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *OSC_Type) GetCR_SC8P() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x2) >> 1
}
func (o *OSC_Type) SetCR_SC4P(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *OSC_Type) GetCR_SC4P() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x4) >> 2
}
func (o *OSC_Type) SetCR_SC2P(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *OSC_Type) GetCR_SC2P() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x8) >> 3
}
func (o *OSC_Type) SetCR_EREFSTEN(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *OSC_Type) GetCR_EREFSTEN() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x20) >> 5
}
func (o *OSC_Type) SetCR_ERCLKEN(value uint8) {
	volatile.StoreUint8(&o.CR.Reg, volatile.LoadUint8(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *OSC_Type) GetCR_ERCLKEN() uint8 {
	return (volatile.LoadUint8(&o.CR.Reg) & 0x80) >> 7
}

// OSC.DIV: OSC_DIV
func (o *OSC_Type) SetDIV_ERPS(value uint8) {
	volatile.StoreUint8(&o.DIV.Reg, volatile.LoadUint8(&o.DIV.Reg)&^(0xc0)|value<<6)
}
func (o *OSC_Type) GetDIV_ERPS() uint8 {
	return (volatile.LoadUint8(&o.DIV.Reg) & 0xc0) >> 6
}

// Inter-Integrated Circuit
type I2C_Type struct {
	A1   volatile.Register8 // 0x0
	F    volatile.Register8 // 0x1
	C1   volatile.Register8 // 0x2
	S    volatile.Register8 // 0x3
	D    volatile.Register8 // 0x4
	C2   volatile.Register8 // 0x5
	FLT  volatile.Register8 // 0x6
	RA   volatile.Register8 // 0x7
	SMB  volatile.Register8 // 0x8
	A2   volatile.Register8 // 0x9
	SLTH volatile.Register8 // 0xA
	SLTL volatile.Register8 // 0xB
}

// I2C.A1: I2C Address Register 1
func (o *I2C_Type) SetA1_AD(value uint8) {
	volatile.StoreUint8(&o.A1.Reg, volatile.LoadUint8(&o.A1.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetA1_AD() uint8 {
	return (volatile.LoadUint8(&o.A1.Reg) & 0xfe) >> 1
}

// I2C.F: I2C Frequency Divider register
func (o *I2C_Type) SetF_ICR(value uint8) {
	volatile.StoreUint8(&o.F.Reg, volatile.LoadUint8(&o.F.Reg)&^(0x3f)|value)
}
func (o *I2C_Type) GetF_ICR() uint8 {
	return volatile.LoadUint8(&o.F.Reg) & 0x3f
}
func (o *I2C_Type) SetF_MULT(value uint8) {
	volatile.StoreUint8(&o.F.Reg, volatile.LoadUint8(&o.F.Reg)&^(0xc0)|value<<6)
}
func (o *I2C_Type) GetF_MULT() uint8 {
	return (volatile.LoadUint8(&o.F.Reg) & 0xc0) >> 6
}

// I2C.C1: I2C Control Register 1
func (o *I2C_Type) SetC1_DMAEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetC1_DMAEN() uint8 {
	return volatile.LoadUint8(&o.C1.Reg) & 0x1
}
func (o *I2C_Type) SetC1_WUEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetC1_WUEN() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetC1_RSTA(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetC1_RSTA() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetC1_TXAK(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetC1_TXAK() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetC1_TX(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetC1_TX() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetC1_MST(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetC1_MST() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetC1_IICIE(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetC1_IICIE() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetC1_IICEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetC1_IICEN() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x80) >> 7
}

// I2C.S: I2C Status register
func (o *I2C_Type) SetS_RXAK(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetS_RXAK() uint8 {
	return volatile.LoadUint8(&o.S.Reg) & 0x1
}
func (o *I2C_Type) SetS_IICIF(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetS_IICIF() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetS_SRW(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetS_SRW() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetS_RAM(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetS_RAM() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetS_ARBL(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetS_ARBL() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetS_BUSY(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetS_BUSY() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetS_IAAS(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetS_IAAS() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetS_TCF(value uint8) {
	volatile.StoreUint8(&o.S.Reg, volatile.LoadUint8(&o.S.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetS_TCF() uint8 {
	return (volatile.LoadUint8(&o.S.Reg) & 0x80) >> 7
}

// I2C.D: I2C Data I/O register
func (o *I2C_Type) SetD(value uint8) {
	volatile.StoreUint8(&o.D.Reg, value)
}
func (o *I2C_Type) GetD() uint8 {
	return volatile.LoadUint8(&o.D.Reg)
}

// I2C.C2: I2C Control Register 2
func (o *I2C_Type) SetC2_AD(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x7)|value)
}
func (o *I2C_Type) GetC2_AD() uint8 {
	return volatile.LoadUint8(&o.C2.Reg) & 0x7
}
func (o *I2C_Type) SetC2_RMEN(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetC2_RMEN() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetC2_SBRC(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetC2_SBRC() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetC2_HDRS(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetC2_HDRS() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetC2_ADEXT(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetC2_ADEXT() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetC2_GCAEN(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetC2_GCAEN() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x80) >> 7
}

// I2C.FLT: I2C Programmable Input Glitch Filter Register
func (o *I2C_Type) SetFLT(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0xf)|value)
}
func (o *I2C_Type) GetFLT() uint8 {
	return volatile.LoadUint8(&o.FLT.Reg) & 0xf
}
func (o *I2C_Type) SetFLT_STARTF(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetFLT_STARTF() uint8 {
	return (volatile.LoadUint8(&o.FLT.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetFLT_SSIE(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetFLT_SSIE() uint8 {
	return (volatile.LoadUint8(&o.FLT.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetFLT_STOPF(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetFLT_STOPF() uint8 {
	return (volatile.LoadUint8(&o.FLT.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetFLT_SHEN(value uint8) {
	volatile.StoreUint8(&o.FLT.Reg, volatile.LoadUint8(&o.FLT.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetFLT_SHEN() uint8 {
	return (volatile.LoadUint8(&o.FLT.Reg) & 0x80) >> 7
}

// I2C.RA: I2C Range Address register
func (o *I2C_Type) SetRA_RAD(value uint8) {
	volatile.StoreUint8(&o.RA.Reg, volatile.LoadUint8(&o.RA.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetRA_RAD() uint8 {
	return (volatile.LoadUint8(&o.RA.Reg) & 0xfe) >> 1
}

// I2C.SMB: I2C SMBus Control and Status register
func (o *I2C_Type) SetSMB_SHTF2IE(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSMB_SHTF2IE() uint8 {
	return volatile.LoadUint8(&o.SMB.Reg) & 0x1
}
func (o *I2C_Type) SetSMB_SHTF2(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetSMB_SHTF2() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetSMB_SHTF1(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetSMB_SHTF1() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetSMB_SLTF(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetSMB_SLTF() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetSMB_TCKSEL(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetSMB_TCKSEL() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetSMB_SIICAEN(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetSMB_SIICAEN() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetSMB_ALERTEN(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetSMB_ALERTEN() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetSMB_FACK(value uint8) {
	volatile.StoreUint8(&o.SMB.Reg, volatile.LoadUint8(&o.SMB.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetSMB_FACK() uint8 {
	return (volatile.LoadUint8(&o.SMB.Reg) & 0x80) >> 7
}

// I2C.A2: I2C Address Register 2
func (o *I2C_Type) SetA2_SAD(value uint8) {
	volatile.StoreUint8(&o.A2.Reg, volatile.LoadUint8(&o.A2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetA2_SAD() uint8 {
	return (volatile.LoadUint8(&o.A2.Reg) & 0xfe) >> 1
}

// I2C.SLTH: I2C SCL Low Timeout Register High
func (o *I2C_Type) SetSLTH(value uint8) {
	volatile.StoreUint8(&o.SLTH.Reg, value)
}
func (o *I2C_Type) GetSLTH() uint8 {
	return volatile.LoadUint8(&o.SLTH.Reg)
}

// I2C.SLTL: I2C SCL Low Timeout Register Low
func (o *I2C_Type) SetSLTL(value uint8) {
	volatile.StoreUint8(&o.SLTL.Reg, value)
}
func (o *I2C_Type) GetSLTL() uint8 {
	return volatile.LoadUint8(&o.SLTL.Reg)
}

// Serial Communication Interface
type UART_Type struct {
	BDH        volatile.Register8 // 0x0
	BDL        volatile.Register8 // 0x1
	C1         volatile.Register8 // 0x2
	C2         volatile.Register8 // 0x3
	S1         volatile.Register8 // 0x4
	S2         volatile.Register8 // 0x5
	C3         volatile.Register8 // 0x6
	D          volatile.Register8 // 0x7
	MA1        volatile.Register8 // 0x8
	MA2        volatile.Register8 // 0x9
	C4         volatile.Register8 // 0xA
	C5         volatile.Register8 // 0xB
	ED         volatile.Register8 // 0xC
	MODEM      volatile.Register8 // 0xD
	IR         volatile.Register8 // 0xE
	_          byte
	PFIFO      volatile.Register8 // 0x10
	CFIFO      volatile.Register8 // 0x11
	SFIFO      volatile.Register8 // 0x12
	TWFIFO     volatile.Register8 // 0x13
	TCFIFO     volatile.Register8 // 0x14
	RWFIFO     volatile.Register8 // 0x15
	RCFIFO     volatile.Register8 // 0x16
	_          byte
	C7816      volatile.Register8 // 0x18
	IE7816     volatile.Register8 // 0x19
	IS7816     volatile.Register8 // 0x1A
	WP7816     volatile.Register8 // 0x1B
	WN7816     volatile.Register8 // 0x1C
	WF7816     volatile.Register8 // 0x1D
	ET7816     volatile.Register8 // 0x1E
	TL7816     volatile.Register8 // 0x1F
	_          [26]byte
	AP7816A_T0 volatile.Register8 // 0x3A
	AP7816B_T0 volatile.Register8 // 0x3B
	WP7816A_T0 volatile.Register8 // 0x3C
	WP7816B_T0 volatile.Register8 // 0x3D
	WGP7816_T1 volatile.Register8 // 0x3E
	WP7816C_T1 volatile.Register8 // 0x3F
}

// UART.BDH: UART Baud Rate Registers: High
func (o *UART_Type) SetBDH_SBR(value uint8) {
	volatile.StoreUint8(&o.BDH.Reg, volatile.LoadUint8(&o.BDH.Reg)&^(0x1f)|value)
}
func (o *UART_Type) GetBDH_SBR() uint8 {
	return volatile.LoadUint8(&o.BDH.Reg) & 0x1f
}
func (o *UART_Type) SetBDH_SBNS(value uint8) {
	volatile.StoreUint8(&o.BDH.Reg, volatile.LoadUint8(&o.BDH.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetBDH_SBNS() uint8 {
	return (volatile.LoadUint8(&o.BDH.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetBDH_RXEDGIE(value uint8) {
	volatile.StoreUint8(&o.BDH.Reg, volatile.LoadUint8(&o.BDH.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetBDH_RXEDGIE() uint8 {
	return (volatile.LoadUint8(&o.BDH.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetBDH_LBKDIE(value uint8) {
	volatile.StoreUint8(&o.BDH.Reg, volatile.LoadUint8(&o.BDH.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetBDH_LBKDIE() uint8 {
	return (volatile.LoadUint8(&o.BDH.Reg) & 0x80) >> 7
}

// UART.BDL: UART Baud Rate Registers: Low
func (o *UART_Type) SetBDL(value uint8) {
	volatile.StoreUint8(&o.BDL.Reg, value)
}
func (o *UART_Type) GetBDL() uint8 {
	return volatile.LoadUint8(&o.BDL.Reg)
}

// UART.C1: UART Control Register 1
func (o *UART_Type) SetC1_PT(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetC1_PT() uint8 {
	return volatile.LoadUint8(&o.C1.Reg) & 0x1
}
func (o *UART_Type) SetC1_PE(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetC1_PE() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetC1_ILT(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetC1_ILT() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetC1_WAKE(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetC1_WAKE() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetC1_M(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetC1_M() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetC1_RSRC(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC1_RSRC() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC1_UARTSWAI(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetC1_UARTSWAI() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetC1_LOOPS(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC1_LOOPS() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x80) >> 7
}

// UART.C2: UART Control Register 2
func (o *UART_Type) SetC2_SBK(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetC2_SBK() uint8 {
	return volatile.LoadUint8(&o.C2.Reg) & 0x1
}
func (o *UART_Type) SetC2_RWU(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetC2_RWU() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetC2_RE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetC2_RE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetC2_TE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetC2_TE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetC2_ILIE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetC2_ILIE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetC2_RIE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC2_RIE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC2_TCIE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetC2_TCIE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetC2_TIE(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC2_TIE() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0x80) >> 7
}

// UART.S1: UART Status Register 1
func (o *UART_Type) SetS1_PF(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetS1_PF() uint8 {
	return volatile.LoadUint8(&o.S1.Reg) & 0x1
}
func (o *UART_Type) SetS1_FE(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetS1_FE() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetS1_NF(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetS1_NF() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetS1_OR(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetS1_OR() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetS1_IDLE(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetS1_IDLE() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetS1_RDRF(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetS1_RDRF() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetS1_TC(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetS1_TC() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetS1_TDRE(value uint8) {
	volatile.StoreUint8(&o.S1.Reg, volatile.LoadUint8(&o.S1.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetS1_TDRE() uint8 {
	return (volatile.LoadUint8(&o.S1.Reg) & 0x80) >> 7
}

// UART.S2: UART Status Register 2
func (o *UART_Type) SetS2_RAF(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetS2_RAF() uint8 {
	return volatile.LoadUint8(&o.S2.Reg) & 0x1
}
func (o *UART_Type) SetS2_LBKDE(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetS2_LBKDE() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetS2_BRK13(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetS2_BRK13() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetS2_RWUID(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetS2_RWUID() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetS2_RXINV(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetS2_RXINV() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetS2_MSBF(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetS2_MSBF() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetS2_RXEDGIF(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetS2_RXEDGIF() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetS2_LBKDIF(value uint8) {
	volatile.StoreUint8(&o.S2.Reg, volatile.LoadUint8(&o.S2.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetS2_LBKDIF() uint8 {
	return (volatile.LoadUint8(&o.S2.Reg) & 0x80) >> 7
}

// UART.C3: UART Control Register 3
func (o *UART_Type) SetC3_PEIE(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetC3_PEIE() uint8 {
	return volatile.LoadUint8(&o.C3.Reg) & 0x1
}
func (o *UART_Type) SetC3_FEIE(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetC3_FEIE() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetC3_NEIE(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetC3_NEIE() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetC3_ORIE(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetC3_ORIE() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetC3_TXINV(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetC3_TXINV() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetC3_TXDIR(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC3_TXDIR() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC3_T8(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetC3_T8() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetC3_R8(value uint8) {
	volatile.StoreUint8(&o.C3.Reg, volatile.LoadUint8(&o.C3.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC3_R8() uint8 {
	return (volatile.LoadUint8(&o.C3.Reg) & 0x80) >> 7
}

// UART.D: UART Data Register
func (o *UART_Type) SetD(value uint8) {
	volatile.StoreUint8(&o.D.Reg, value)
}
func (o *UART_Type) GetD() uint8 {
	return volatile.LoadUint8(&o.D.Reg)
}

// UART.MA1: UART Match Address Registers 1
func (o *UART_Type) SetMA1(value uint8) {
	volatile.StoreUint8(&o.MA1.Reg, value)
}
func (o *UART_Type) GetMA1() uint8 {
	return volatile.LoadUint8(&o.MA1.Reg)
}

// UART.MA2: UART Match Address Registers 2
func (o *UART_Type) SetMA2(value uint8) {
	volatile.StoreUint8(&o.MA2.Reg, value)
}
func (o *UART_Type) GetMA2() uint8 {
	return volatile.LoadUint8(&o.MA2.Reg)
}

// UART.C4: UART Control Register 4
func (o *UART_Type) SetC4_BRFA(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x1f)|value)
}
func (o *UART_Type) GetC4_BRFA() uint8 {
	return volatile.LoadUint8(&o.C4.Reg) & 0x1f
}
func (o *UART_Type) SetC4_M10(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC4_M10() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC4_MAEN2(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetC4_MAEN2() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetC4_MAEN1(value uint8) {
	volatile.StoreUint8(&o.C4.Reg, volatile.LoadUint8(&o.C4.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC4_MAEN1() uint8 {
	return (volatile.LoadUint8(&o.C4.Reg) & 0x80) >> 7
}

// UART.C5: UART Control Register 5
func (o *UART_Type) SetC5_RDMAS(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetC5_RDMAS() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetC5_TDMAS(value uint8) {
	volatile.StoreUint8(&o.C5.Reg, volatile.LoadUint8(&o.C5.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetC5_TDMAS() uint8 {
	return (volatile.LoadUint8(&o.C5.Reg) & 0x80) >> 7
}

// UART.ED: UART Extended Data Register
func (o *UART_Type) SetED_PARITYE(value uint8) {
	volatile.StoreUint8(&o.ED.Reg, volatile.LoadUint8(&o.ED.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetED_PARITYE() uint8 {
	return (volatile.LoadUint8(&o.ED.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetED_NOISY(value uint8) {
	volatile.StoreUint8(&o.ED.Reg, volatile.LoadUint8(&o.ED.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetED_NOISY() uint8 {
	return (volatile.LoadUint8(&o.ED.Reg) & 0x80) >> 7
}

// UART.MODEM: UART Modem Register
func (o *UART_Type) SetMODEM_TXCTSE(value uint8) {
	volatile.StoreUint8(&o.MODEM.Reg, volatile.LoadUint8(&o.MODEM.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetMODEM_TXCTSE() uint8 {
	return volatile.LoadUint8(&o.MODEM.Reg) & 0x1
}
func (o *UART_Type) SetMODEM_TXRTSE(value uint8) {
	volatile.StoreUint8(&o.MODEM.Reg, volatile.LoadUint8(&o.MODEM.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetMODEM_TXRTSE() uint8 {
	return (volatile.LoadUint8(&o.MODEM.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetMODEM_TXRTSPOL(value uint8) {
	volatile.StoreUint8(&o.MODEM.Reg, volatile.LoadUint8(&o.MODEM.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetMODEM_TXRTSPOL() uint8 {
	return (volatile.LoadUint8(&o.MODEM.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetMODEM_RXRTSE(value uint8) {
	volatile.StoreUint8(&o.MODEM.Reg, volatile.LoadUint8(&o.MODEM.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetMODEM_RXRTSE() uint8 {
	return (volatile.LoadUint8(&o.MODEM.Reg) & 0x8) >> 3
}

// UART.IR: UART Infrared Register
func (o *UART_Type) SetIR_TNP(value uint8) {
	volatile.StoreUint8(&o.IR.Reg, volatile.LoadUint8(&o.IR.Reg)&^(0x3)|value)
}
func (o *UART_Type) GetIR_TNP() uint8 {
	return volatile.LoadUint8(&o.IR.Reg) & 0x3
}
func (o *UART_Type) SetIR_IREN(value uint8) {
	volatile.StoreUint8(&o.IR.Reg, volatile.LoadUint8(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetIR_IREN() uint8 {
	return (volatile.LoadUint8(&o.IR.Reg) & 0x4) >> 2
}

// UART.PFIFO: UART FIFO Parameters
func (o *UART_Type) SetPFIFO_RXFIFOSIZE(value uint8) {
	volatile.StoreUint8(&o.PFIFO.Reg, volatile.LoadUint8(&o.PFIFO.Reg)&^(0x7)|value)
}
func (o *UART_Type) GetPFIFO_RXFIFOSIZE() uint8 {
	return volatile.LoadUint8(&o.PFIFO.Reg) & 0x7
}
func (o *UART_Type) SetPFIFO_RXFE(value uint8) {
	volatile.StoreUint8(&o.PFIFO.Reg, volatile.LoadUint8(&o.PFIFO.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetPFIFO_RXFE() uint8 {
	return (volatile.LoadUint8(&o.PFIFO.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetPFIFO_TXFIFOSIZE(value uint8) {
	volatile.StoreUint8(&o.PFIFO.Reg, volatile.LoadUint8(&o.PFIFO.Reg)&^(0x70)|value<<4)
}
func (o *UART_Type) GetPFIFO_TXFIFOSIZE() uint8 {
	return (volatile.LoadUint8(&o.PFIFO.Reg) & 0x70) >> 4
}
func (o *UART_Type) SetPFIFO_TXFE(value uint8) {
	volatile.StoreUint8(&o.PFIFO.Reg, volatile.LoadUint8(&o.PFIFO.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetPFIFO_TXFE() uint8 {
	return (volatile.LoadUint8(&o.PFIFO.Reg) & 0x80) >> 7
}

// UART.CFIFO: UART FIFO Control Register
func (o *UART_Type) SetCFIFO_RXUFE(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetCFIFO_RXUFE() uint8 {
	return volatile.LoadUint8(&o.CFIFO.Reg) & 0x1
}
func (o *UART_Type) SetCFIFO_TXOFE(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetCFIFO_TXOFE() uint8 {
	return (volatile.LoadUint8(&o.CFIFO.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetCFIFO_RXOFE(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetCFIFO_RXOFE() uint8 {
	return (volatile.LoadUint8(&o.CFIFO.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetCFIFO_RXFLUSH(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetCFIFO_RXFLUSH() uint8 {
	return (volatile.LoadUint8(&o.CFIFO.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetCFIFO_TXFLUSH(value uint8) {
	volatile.StoreUint8(&o.CFIFO.Reg, volatile.LoadUint8(&o.CFIFO.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetCFIFO_TXFLUSH() uint8 {
	return (volatile.LoadUint8(&o.CFIFO.Reg) & 0x80) >> 7
}

// UART.SFIFO: UART FIFO Status Register
func (o *UART_Type) SetSFIFO_RXUF(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetSFIFO_RXUF() uint8 {
	return volatile.LoadUint8(&o.SFIFO.Reg) & 0x1
}
func (o *UART_Type) SetSFIFO_TXOF(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetSFIFO_TXOF() uint8 {
	return (volatile.LoadUint8(&o.SFIFO.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetSFIFO_RXOF(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetSFIFO_RXOF() uint8 {
	return (volatile.LoadUint8(&o.SFIFO.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetSFIFO_RXEMPT(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetSFIFO_RXEMPT() uint8 {
	return (volatile.LoadUint8(&o.SFIFO.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetSFIFO_TXEMPT(value uint8) {
	volatile.StoreUint8(&o.SFIFO.Reg, volatile.LoadUint8(&o.SFIFO.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetSFIFO_TXEMPT() uint8 {
	return (volatile.LoadUint8(&o.SFIFO.Reg) & 0x80) >> 7
}

// UART.TWFIFO: UART FIFO Transmit Watermark
func (o *UART_Type) SetTWFIFO(value uint8) {
	volatile.StoreUint8(&o.TWFIFO.Reg, value)
}
func (o *UART_Type) GetTWFIFO() uint8 {
	return volatile.LoadUint8(&o.TWFIFO.Reg)
}

// UART.TCFIFO: UART FIFO Transmit Count
func (o *UART_Type) SetTCFIFO(value uint8) {
	volatile.StoreUint8(&o.TCFIFO.Reg, value)
}
func (o *UART_Type) GetTCFIFO() uint8 {
	return volatile.LoadUint8(&o.TCFIFO.Reg)
}

// UART.RWFIFO: UART FIFO Receive Watermark
func (o *UART_Type) SetRWFIFO(value uint8) {
	volatile.StoreUint8(&o.RWFIFO.Reg, value)
}
func (o *UART_Type) GetRWFIFO() uint8 {
	return volatile.LoadUint8(&o.RWFIFO.Reg)
}

// UART.RCFIFO: UART FIFO Receive Count
func (o *UART_Type) SetRCFIFO(value uint8) {
	volatile.StoreUint8(&o.RCFIFO.Reg, value)
}
func (o *UART_Type) GetRCFIFO() uint8 {
	return volatile.LoadUint8(&o.RCFIFO.Reg)
}

// UART.C7816: UART 7816 Control Register
func (o *UART_Type) SetC7816_ISO_7816E(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetC7816_ISO_7816E() uint8 {
	return volatile.LoadUint8(&o.C7816.Reg) & 0x1
}
func (o *UART_Type) SetC7816_TTYPE(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetC7816_TTYPE() uint8 {
	return (volatile.LoadUint8(&o.C7816.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetC7816_INIT(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetC7816_INIT() uint8 {
	return (volatile.LoadUint8(&o.C7816.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetC7816_ANACK(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetC7816_ANACK() uint8 {
	return (volatile.LoadUint8(&o.C7816.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetC7816_ONACK(value uint8) {
	volatile.StoreUint8(&o.C7816.Reg, volatile.LoadUint8(&o.C7816.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetC7816_ONACK() uint8 {
	return (volatile.LoadUint8(&o.C7816.Reg) & 0x10) >> 4
}

// UART.IE7816: UART 7816 Interrupt Enable Register
func (o *UART_Type) SetIE7816_RXTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIE7816_RXTE() uint8 {
	return volatile.LoadUint8(&o.IE7816.Reg) & 0x1
}
func (o *UART_Type) SetIE7816_TXTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIE7816_TXTE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIE7816_GTVE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetIE7816_GTVE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetIE7816_ADTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetIE7816_ADTE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetIE7816_INITDE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetIE7816_INITDE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetIE7816_BWTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIE7816_BWTE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIE7816_CWTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIE7816_CWTE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIE7816_WTE(value uint8) {
	volatile.StoreUint8(&o.IE7816.Reg, volatile.LoadUint8(&o.IE7816.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIE7816_WTE() uint8 {
	return (volatile.LoadUint8(&o.IE7816.Reg) & 0x80) >> 7
}

// UART.IS7816: UART 7816 Interrupt Status Register
func (o *UART_Type) SetIS7816_RXT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIS7816_RXT() uint8 {
	return volatile.LoadUint8(&o.IS7816.Reg) & 0x1
}
func (o *UART_Type) SetIS7816_TXT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIS7816_TXT() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIS7816_GTV(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetIS7816_GTV() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetIS7816_ADT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetIS7816_ADT() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetIS7816_INITD(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetIS7816_INITD() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetIS7816_BWT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIS7816_BWT() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIS7816_CWT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIS7816_CWT() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIS7816_WT(value uint8) {
	volatile.StoreUint8(&o.IS7816.Reg, volatile.LoadUint8(&o.IS7816.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIS7816_WT() uint8 {
	return (volatile.LoadUint8(&o.IS7816.Reg) & 0x80) >> 7
}

// UART.WP7816: UART 7816 Wait Parameter Register
func (o *UART_Type) SetWP7816(value uint8) {
	volatile.StoreUint8(&o.WP7816.Reg, value)
}
func (o *UART_Type) GetWP7816() uint8 {
	return volatile.LoadUint8(&o.WP7816.Reg)
}

// UART.WN7816: UART 7816 Wait N Register
func (o *UART_Type) SetWN7816(value uint8) {
	volatile.StoreUint8(&o.WN7816.Reg, value)
}
func (o *UART_Type) GetWN7816() uint8 {
	return volatile.LoadUint8(&o.WN7816.Reg)
}

// UART.WF7816: UART 7816 Wait FD Register
func (o *UART_Type) SetWF7816(value uint8) {
	volatile.StoreUint8(&o.WF7816.Reg, value)
}
func (o *UART_Type) GetWF7816() uint8 {
	return volatile.LoadUint8(&o.WF7816.Reg)
}

// UART.ET7816: UART 7816 Error Threshold Register
func (o *UART_Type) SetET7816_RXTHRESHOLD(value uint8) {
	volatile.StoreUint8(&o.ET7816.Reg, volatile.LoadUint8(&o.ET7816.Reg)&^(0xf)|value)
}
func (o *UART_Type) GetET7816_RXTHRESHOLD() uint8 {
	return volatile.LoadUint8(&o.ET7816.Reg) & 0xf
}
func (o *UART_Type) SetET7816_TXTHRESHOLD(value uint8) {
	volatile.StoreUint8(&o.ET7816.Reg, volatile.LoadUint8(&o.ET7816.Reg)&^(0xf0)|value<<4)
}
func (o *UART_Type) GetET7816_TXTHRESHOLD() uint8 {
	return (volatile.LoadUint8(&o.ET7816.Reg) & 0xf0) >> 4
}

// UART.TL7816: UART 7816 Transmit Length Register
func (o *UART_Type) SetTL7816(value uint8) {
	volatile.StoreUint8(&o.TL7816.Reg, value)
}
func (o *UART_Type) GetTL7816() uint8 {
	return volatile.LoadUint8(&o.TL7816.Reg)
}

// UART.AP7816A_T0: UART 7816 ATR Duration Timer Register A
func (o *UART_Type) SetAP7816A_T0(value uint8) {
	volatile.StoreUint8(&o.AP7816A_T0.Reg, value)
}
func (o *UART_Type) GetAP7816A_T0() uint8 {
	return volatile.LoadUint8(&o.AP7816A_T0.Reg)
}

// UART.AP7816B_T0: UART 7816 ATR Duration Timer Register B
func (o *UART_Type) SetAP7816B_T0(value uint8) {
	volatile.StoreUint8(&o.AP7816B_T0.Reg, value)
}
func (o *UART_Type) GetAP7816B_T0() uint8 {
	return volatile.LoadUint8(&o.AP7816B_T0.Reg)
}

// UART.WP7816A_T0: UART 7816 Wait Parameter Register A
func (o *UART_Type) SetWP7816A_T0(value uint8) {
	volatile.StoreUint8(&o.WP7816A_T0.Reg, value)
}
func (o *UART_Type) GetWP7816A_T0() uint8 {
	return volatile.LoadUint8(&o.WP7816A_T0.Reg)
}

// UART.WP7816B_T0: UART 7816 Wait Parameter Register B
func (o *UART_Type) SetWP7816B_T0(value uint8) {
	volatile.StoreUint8(&o.WP7816B_T0.Reg, value)
}
func (o *UART_Type) GetWP7816B_T0() uint8 {
	return volatile.LoadUint8(&o.WP7816B_T0.Reg)
}

// UART.WGP7816_T1: UART 7816 Wait and Guard Parameter Register
func (o *UART_Type) SetWGP7816_T1_BGI(value uint8) {
	volatile.StoreUint8(&o.WGP7816_T1.Reg, volatile.LoadUint8(&o.WGP7816_T1.Reg)&^(0xf)|value)
}
func (o *UART_Type) GetWGP7816_T1_BGI() uint8 {
	return volatile.LoadUint8(&o.WGP7816_T1.Reg) & 0xf
}
func (o *UART_Type) SetWGP7816_T1_CWI1(value uint8) {
	volatile.StoreUint8(&o.WGP7816_T1.Reg, volatile.LoadUint8(&o.WGP7816_T1.Reg)&^(0xf0)|value<<4)
}
func (o *UART_Type) GetWGP7816_T1_CWI1() uint8 {
	return (volatile.LoadUint8(&o.WGP7816_T1.Reg) & 0xf0) >> 4
}

// UART.WP7816C_T1: UART 7816 Wait Parameter Register C
func (o *UART_Type) SetWP7816C_T1_CWI2(value uint8) {
	volatile.StoreUint8(&o.WP7816C_T1.Reg, volatile.LoadUint8(&o.WP7816C_T1.Reg)&^(0x1f)|value)
}
func (o *UART_Type) GetWP7816C_T1_CWI2() uint8 {
	return volatile.LoadUint8(&o.WP7816C_T1.Reg) & 0x1f
}

// Universal Serial Bus, OTG Capable Controller
type USB0_Type struct {
	PERID                  volatile.Register8 // 0x0
	_                      [3]byte
	IDCOMP                 volatile.Register8 // 0x4
	_                      [3]byte
	REV                    volatile.Register8 // 0x8
	_                      [3]byte
	ADDINFO                volatile.Register8 // 0xC
	_                      [3]byte
	OTGISTAT               volatile.Register8 // 0x10
	_                      [3]byte
	OTGICR                 volatile.Register8 // 0x14
	_                      [3]byte
	OTGSTAT                volatile.Register8 // 0x18
	_                      [3]byte
	OTGCTL                 volatile.Register8 // 0x1C
	_                      [99]byte
	ISTAT                  volatile.Register8 // 0x80
	_                      [3]byte
	INTEN                  volatile.Register8 // 0x84
	_                      [3]byte
	ERRSTAT                volatile.Register8 // 0x88
	_                      [3]byte
	ERREN                  volatile.Register8 // 0x8C
	_                      [3]byte
	STAT                   volatile.Register8 // 0x90
	_                      [3]byte
	CTL                    volatile.Register8 // 0x94
	_                      [3]byte
	ADDR                   volatile.Register8 // 0x98
	_                      [3]byte
	BDTPAGE1               volatile.Register8 // 0x9C
	_                      [3]byte
	FRMNUML                volatile.Register8 // 0xA0
	_                      [3]byte
	FRMNUMH                volatile.Register8 // 0xA4
	_                      [3]byte
	TOKEN                  volatile.Register8 // 0xA8
	_                      [3]byte
	SOFTHLD                volatile.Register8 // 0xAC
	_                      [3]byte
	BDTPAGE2               volatile.Register8 // 0xB0
	_                      [3]byte
	BDTPAGE3               volatile.Register8 // 0xB4
	_                      [11]byte
	ENDPT0                 volatile.Register8 // 0xC0
	_                      [3]byte
	ENDPT1                 volatile.Register8 // 0xC4
	_                      [3]byte
	ENDPT2                 volatile.Register8 // 0xC8
	_                      [3]byte
	ENDPT3                 volatile.Register8 // 0xCC
	_                      [3]byte
	ENDPT4                 volatile.Register8 // 0xD0
	_                      [3]byte
	ENDPT5                 volatile.Register8 // 0xD4
	_                      [3]byte
	ENDPT6                 volatile.Register8 // 0xD8
	_                      [3]byte
	ENDPT7                 volatile.Register8 // 0xDC
	_                      [3]byte
	ENDPT8                 volatile.Register8 // 0xE0
	_                      [3]byte
	ENDPT9                 volatile.Register8 // 0xE4
	_                      [3]byte
	ENDPT10                volatile.Register8 // 0xE8
	_                      [3]byte
	ENDPT11                volatile.Register8 // 0xEC
	_                      [3]byte
	ENDPT12                volatile.Register8 // 0xF0
	_                      [3]byte
	ENDPT13                volatile.Register8 // 0xF4
	_                      [3]byte
	ENDPT14                volatile.Register8 // 0xF8
	_                      [3]byte
	ENDPT15                volatile.Register8 // 0xFC
	_                      [3]byte
	USBCTRL                volatile.Register8 // 0x100
	_                      [3]byte
	OBSERVE                volatile.Register8 // 0x104
	_                      [3]byte
	CONTROL                volatile.Register8 // 0x108
	_                      [3]byte
	USBTRC0                volatile.Register8 // 0x10C
	_                      [7]byte
	USBFRMADJUST           volatile.Register8 // 0x114
	_                      [43]byte
	CLK_RECOVER_CTRL       volatile.Register8 // 0x140
	_                      [3]byte
	CLK_RECOVER_IRC_EN     volatile.Register8 // 0x144
	_                      [15]byte
	CLK_RECOVER_INT_EN     volatile.Register8 // 0x154
	_                      [7]byte
	CLK_RECOVER_INT_STATUS volatile.Register8 // 0x15C
}

// USB0.PERID: Peripheral ID register
func (o *USB0_Type) SetPERID_ID(value uint8) {
	volatile.StoreUint8(&o.PERID.Reg, volatile.LoadUint8(&o.PERID.Reg)&^(0x3f)|value)
}
func (o *USB0_Type) GetPERID_ID() uint8 {
	return volatile.LoadUint8(&o.PERID.Reg) & 0x3f
}

// USB0.IDCOMP: Peripheral ID Complement register
func (o *USB0_Type) SetIDCOMP_NID(value uint8) {
	volatile.StoreUint8(&o.IDCOMP.Reg, volatile.LoadUint8(&o.IDCOMP.Reg)&^(0x3f)|value)
}
func (o *USB0_Type) GetIDCOMP_NID() uint8 {
	return volatile.LoadUint8(&o.IDCOMP.Reg) & 0x3f
}

// USB0.REV: Peripheral Revision register
func (o *USB0_Type) SetREV(value uint8) {
	volatile.StoreUint8(&o.REV.Reg, value)
}
func (o *USB0_Type) GetREV() uint8 {
	return volatile.LoadUint8(&o.REV.Reg)
}

// USB0.ADDINFO: Peripheral Additional Info register
func (o *USB0_Type) SetADDINFO_IEHOST(value uint8) {
	volatile.StoreUint8(&o.ADDINFO.Reg, volatile.LoadUint8(&o.ADDINFO.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetADDINFO_IEHOST() uint8 {
	return volatile.LoadUint8(&o.ADDINFO.Reg) & 0x1
}

// USB0.OTGISTAT: OTG Interrupt Status register
func (o *USB0_Type) SetOTGISTAT_AVBUSCHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetOTGISTAT_AVBUSCHG() uint8 {
	return volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x1
}
func (o *USB0_Type) SetOTGISTAT_B_SESS_CHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetOTGISTAT_B_SESS_CHG() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetOTGISTAT_SESSVLDCHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetOTGISTAT_SESSVLDCHG() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetOTGISTAT_LINE_STATE_CHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetOTGISTAT_LINE_STATE_CHG() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetOTGISTAT_ONEMSEC(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetOTGISTAT_ONEMSEC() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetOTGISTAT_IDCHG(value uint8) {
	volatile.StoreUint8(&o.OTGISTAT.Reg, volatile.LoadUint8(&o.OTGISTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOTGISTAT_IDCHG() uint8 {
	return (volatile.LoadUint8(&o.OTGISTAT.Reg) & 0x80) >> 7
}

// USB0.OTGICR: OTG Interrupt Control register
func (o *USB0_Type) SetOTGICR_AVBUSEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetOTGICR_AVBUSEN() uint8 {
	return volatile.LoadUint8(&o.OTGICR.Reg) & 0x1
}
func (o *USB0_Type) SetOTGICR_BSESSEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetOTGICR_BSESSEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetOTGICR_SESSVLDEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetOTGICR_SESSVLDEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetOTGICR_LINESTATEEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetOTGICR_LINESTATEEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetOTGICR_ONEMSECEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetOTGICR_ONEMSECEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetOTGICR_IDEN(value uint8) {
	volatile.StoreUint8(&o.OTGICR.Reg, volatile.LoadUint8(&o.OTGICR.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOTGICR_IDEN() uint8 {
	return (volatile.LoadUint8(&o.OTGICR.Reg) & 0x80) >> 7
}

// USB0.OTGSTAT: OTG Status register
func (o *USB0_Type) SetOTGSTAT_AVBUSVLD(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetOTGSTAT_AVBUSVLD() uint8 {
	return volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x1
}
func (o *USB0_Type) SetOTGSTAT_BSESSEND(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetOTGSTAT_BSESSEND() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetOTGSTAT_SESS_VLD(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetOTGSTAT_SESS_VLD() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetOTGSTAT_LINESTATESTABLE(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetOTGSTAT_LINESTATESTABLE() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetOTGSTAT_ONEMSECEN(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetOTGSTAT_ONEMSECEN() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetOTGSTAT_ID(value uint8) {
	volatile.StoreUint8(&o.OTGSTAT.Reg, volatile.LoadUint8(&o.OTGSTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOTGSTAT_ID() uint8 {
	return (volatile.LoadUint8(&o.OTGSTAT.Reg) & 0x80) >> 7
}

// USB0.OTGCTL: OTG Control register
func (o *USB0_Type) SetOTGCTL_OTGEN(value uint8) {
	volatile.StoreUint8(&o.OTGCTL.Reg, volatile.LoadUint8(&o.OTGCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetOTGCTL_OTGEN() uint8 {
	return (volatile.LoadUint8(&o.OTGCTL.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetOTGCTL_DMLOW(value uint8) {
	volatile.StoreUint8(&o.OTGCTL.Reg, volatile.LoadUint8(&o.OTGCTL.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetOTGCTL_DMLOW() uint8 {
	return (volatile.LoadUint8(&o.OTGCTL.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetOTGCTL_DPLOW(value uint8) {
	volatile.StoreUint8(&o.OTGCTL.Reg, volatile.LoadUint8(&o.OTGCTL.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetOTGCTL_DPLOW() uint8 {
	return (volatile.LoadUint8(&o.OTGCTL.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetOTGCTL_DPHIGH(value uint8) {
	volatile.StoreUint8(&o.OTGCTL.Reg, volatile.LoadUint8(&o.OTGCTL.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOTGCTL_DPHIGH() uint8 {
	return (volatile.LoadUint8(&o.OTGCTL.Reg) & 0x80) >> 7
}

// USB0.ISTAT: Interrupt Status register
func (o *USB0_Type) SetISTAT_USBRST(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetISTAT_USBRST() uint8 {
	return volatile.LoadUint8(&o.ISTAT.Reg) & 0x1
}
func (o *USB0_Type) SetISTAT_ERROR(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetISTAT_ERROR() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetISTAT_SOFTOK(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetISTAT_SOFTOK() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetISTAT_TOKDNE(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetISTAT_TOKDNE() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetISTAT_SLEEP(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetISTAT_SLEEP() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetISTAT_RESUME(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetISTAT_RESUME() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetISTAT_ATTACH(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetISTAT_ATTACH() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetISTAT_STALL(value uint8) {
	volatile.StoreUint8(&o.ISTAT.Reg, volatile.LoadUint8(&o.ISTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetISTAT_STALL() uint8 {
	return (volatile.LoadUint8(&o.ISTAT.Reg) & 0x80) >> 7
}

// USB0.INTEN: Interrupt Enable register
func (o *USB0_Type) SetINTEN_USBRSTEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetINTEN_USBRSTEN() uint8 {
	return volatile.LoadUint8(&o.INTEN.Reg) & 0x1
}
func (o *USB0_Type) SetINTEN_ERROREN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetINTEN_ERROREN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetINTEN_SOFTOKEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetINTEN_SOFTOKEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetINTEN_TOKDNEEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetINTEN_TOKDNEEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetINTEN_SLEEPEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetINTEN_SLEEPEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetINTEN_RESUMEEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetINTEN_RESUMEEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetINTEN_ATTACHEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetINTEN_ATTACHEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetINTEN_STALLEN(value uint8) {
	volatile.StoreUint8(&o.INTEN.Reg, volatile.LoadUint8(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetINTEN_STALLEN() uint8 {
	return (volatile.LoadUint8(&o.INTEN.Reg) & 0x80) >> 7
}

// USB0.ERRSTAT: Error Interrupt Status register
func (o *USB0_Type) SetERRSTAT_PIDERR(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetERRSTAT_PIDERR() uint8 {
	return volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x1
}
func (o *USB0_Type) SetERRSTAT_CRC5EOF(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetERRSTAT_CRC5EOF() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetERRSTAT_CRC16(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetERRSTAT_CRC16() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetERRSTAT_DFN8(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetERRSTAT_DFN8() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetERRSTAT_BTOERR(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetERRSTAT_BTOERR() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetERRSTAT_DMAERR(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetERRSTAT_DMAERR() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetERRSTAT_BTSERR(value uint8) {
	volatile.StoreUint8(&o.ERRSTAT.Reg, volatile.LoadUint8(&o.ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetERRSTAT_BTSERR() uint8 {
	return (volatile.LoadUint8(&o.ERRSTAT.Reg) & 0x80) >> 7
}

// USB0.ERREN: Error Interrupt Enable register
func (o *USB0_Type) SetERREN_PIDERREN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetERREN_PIDERREN() uint8 {
	return volatile.LoadUint8(&o.ERREN.Reg) & 0x1
}
func (o *USB0_Type) SetERREN_CRC5EOFEN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetERREN_CRC5EOFEN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetERREN_CRC16EN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetERREN_CRC16EN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetERREN_DFN8EN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetERREN_DFN8EN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetERREN_BTOERREN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetERREN_BTOERREN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetERREN_DMAERREN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetERREN_DMAERREN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetERREN_BTSERREN(value uint8) {
	volatile.StoreUint8(&o.ERREN.Reg, volatile.LoadUint8(&o.ERREN.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetERREN_BTSERREN() uint8 {
	return (volatile.LoadUint8(&o.ERREN.Reg) & 0x80) >> 7
}

// USB0.STAT: Status register
func (o *USB0_Type) SetSTAT_ODD(value uint8) {
	volatile.StoreUint8(&o.STAT.Reg, volatile.LoadUint8(&o.STAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetSTAT_ODD() uint8 {
	return (volatile.LoadUint8(&o.STAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetSTAT_TX(value uint8) {
	volatile.StoreUint8(&o.STAT.Reg, volatile.LoadUint8(&o.STAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetSTAT_TX() uint8 {
	return (volatile.LoadUint8(&o.STAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetSTAT_ENDP(value uint8) {
	volatile.StoreUint8(&o.STAT.Reg, volatile.LoadUint8(&o.STAT.Reg)&^(0xf0)|value<<4)
}
func (o *USB0_Type) GetSTAT_ENDP() uint8 {
	return (volatile.LoadUint8(&o.STAT.Reg) & 0xf0) >> 4
}

// USB0.CTL: Control register
func (o *USB0_Type) SetCTL_USBENSOFEN(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetCTL_USBENSOFEN() uint8 {
	return volatile.LoadUint8(&o.CTL.Reg) & 0x1
}
func (o *USB0_Type) SetCTL_ODDRST(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetCTL_ODDRST() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetCTL_RESUME(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetCTL_RESUME() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetCTL_HOSTMODEEN(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetCTL_HOSTMODEEN() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetCTL_RESET(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetCTL_RESET() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetCTL_TXSUSPENDTOKENBUSY(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetCTL_TXSUSPENDTOKENBUSY() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetCTL_SE0(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetCTL_SE0() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetCTL_JSTATE(value uint8) {
	volatile.StoreUint8(&o.CTL.Reg, volatile.LoadUint8(&o.CTL.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetCTL_JSTATE() uint8 {
	return (volatile.LoadUint8(&o.CTL.Reg) & 0x80) >> 7
}

// USB0.ADDR: Address register
func (o *USB0_Type) SetADDR(value uint8) {
	volatile.StoreUint8(&o.ADDR.Reg, volatile.LoadUint8(&o.ADDR.Reg)&^(0x7f)|value)
}
func (o *USB0_Type) GetADDR() uint8 {
	return volatile.LoadUint8(&o.ADDR.Reg) & 0x7f
}
func (o *USB0_Type) SetADDR_LSEN(value uint8) {
	volatile.StoreUint8(&o.ADDR.Reg, volatile.LoadUint8(&o.ADDR.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetADDR_LSEN() uint8 {
	return (volatile.LoadUint8(&o.ADDR.Reg) & 0x80) >> 7
}

// USB0.BDTPAGE1: BDT Page register 1
func (o *USB0_Type) SetBDTPAGE1_BDTBA(value uint8) {
	volatile.StoreUint8(&o.BDTPAGE1.Reg, volatile.LoadUint8(&o.BDTPAGE1.Reg)&^(0xfe)|value<<1)
}
func (o *USB0_Type) GetBDTPAGE1_BDTBA() uint8 {
	return (volatile.LoadUint8(&o.BDTPAGE1.Reg) & 0xfe) >> 1
}

// USB0.FRMNUML: Frame Number register Low
func (o *USB0_Type) SetFRMNUML(value uint8) {
	volatile.StoreUint8(&o.FRMNUML.Reg, value)
}
func (o *USB0_Type) GetFRMNUML() uint8 {
	return volatile.LoadUint8(&o.FRMNUML.Reg)
}

// USB0.FRMNUMH: Frame Number register High
func (o *USB0_Type) SetFRMNUMH_FRM(value uint8) {
	volatile.StoreUint8(&o.FRMNUMH.Reg, volatile.LoadUint8(&o.FRMNUMH.Reg)&^(0x7)|value)
}
func (o *USB0_Type) GetFRMNUMH_FRM() uint8 {
	return volatile.LoadUint8(&o.FRMNUMH.Reg) & 0x7
}

// USB0.TOKEN: Token register
func (o *USB0_Type) SetTOKEN_TOKENENDPT(value uint8) {
	volatile.StoreUint8(&o.TOKEN.Reg, volatile.LoadUint8(&o.TOKEN.Reg)&^(0xf)|value)
}
func (o *USB0_Type) GetTOKEN_TOKENENDPT() uint8 {
	return volatile.LoadUint8(&o.TOKEN.Reg) & 0xf
}
func (o *USB0_Type) SetTOKEN_TOKENPID(value uint8) {
	volatile.StoreUint8(&o.TOKEN.Reg, volatile.LoadUint8(&o.TOKEN.Reg)&^(0xf0)|value<<4)
}
func (o *USB0_Type) GetTOKEN_TOKENPID() uint8 {
	return (volatile.LoadUint8(&o.TOKEN.Reg) & 0xf0) >> 4
}

// USB0.SOFTHLD: SOF Threshold register
func (o *USB0_Type) SetSOFTHLD(value uint8) {
	volatile.StoreUint8(&o.SOFTHLD.Reg, value)
}
func (o *USB0_Type) GetSOFTHLD() uint8 {
	return volatile.LoadUint8(&o.SOFTHLD.Reg)
}

// USB0.BDTPAGE2: BDT Page Register 2
func (o *USB0_Type) SetBDTPAGE2(value uint8) {
	volatile.StoreUint8(&o.BDTPAGE2.Reg, value)
}
func (o *USB0_Type) GetBDTPAGE2() uint8 {
	return volatile.LoadUint8(&o.BDTPAGE2.Reg)
}

// USB0.BDTPAGE3: BDT Page Register 3
func (o *USB0_Type) SetBDTPAGE3(value uint8) {
	volatile.StoreUint8(&o.BDTPAGE3.Reg, value)
}
func (o *USB0_Type) GetBDTPAGE3() uint8 {
	return volatile.LoadUint8(&o.BDTPAGE3.Reg)
}

// USB0.ENDPT0: Endpoint Control register
func (o *USB0_Type) SetENDPT0_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT0_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT0.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT0_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT0_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT0_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT0_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT0_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT0_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT0_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT0_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT0_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT0_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT0_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT0.Reg, volatile.LoadUint8(&o.ENDPT0.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT0_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT0.Reg) & 0x80) >> 7
}

// USB0.ENDPT1: Endpoint Control register
func (o *USB0_Type) SetENDPT1_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT1_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT1.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT1_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT1_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT1_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT1_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT1_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT1_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT1_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT1_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT1_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT1_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT1_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT1.Reg, volatile.LoadUint8(&o.ENDPT1.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT1_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT1.Reg) & 0x80) >> 7
}

// USB0.ENDPT2: Endpoint Control register
func (o *USB0_Type) SetENDPT2_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT2_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT2.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT2_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT2_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT2_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT2_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT2_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT2_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT2_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT2_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT2_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT2_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT2_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT2.Reg, volatile.LoadUint8(&o.ENDPT2.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT2_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT2.Reg) & 0x80) >> 7
}

// USB0.ENDPT3: Endpoint Control register
func (o *USB0_Type) SetENDPT3_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT3_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT3.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT3_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT3_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT3_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT3_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT3_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT3_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT3_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT3_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT3_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT3_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT3_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT3.Reg, volatile.LoadUint8(&o.ENDPT3.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT3_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT3.Reg) & 0x80) >> 7
}

// USB0.ENDPT4: Endpoint Control register
func (o *USB0_Type) SetENDPT4_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT4_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT4.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT4_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT4_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT4_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT4_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT4_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT4_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT4_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT4_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT4_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT4_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT4_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT4.Reg, volatile.LoadUint8(&o.ENDPT4.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT4_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT4.Reg) & 0x80) >> 7
}

// USB0.ENDPT5: Endpoint Control register
func (o *USB0_Type) SetENDPT5_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT5_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT5.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT5_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT5_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT5_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT5_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT5_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT5_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT5_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT5_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT5_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT5_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT5_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT5.Reg, volatile.LoadUint8(&o.ENDPT5.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT5_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT5.Reg) & 0x80) >> 7
}

// USB0.ENDPT6: Endpoint Control register
func (o *USB0_Type) SetENDPT6_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT6_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT6.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT6_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT6_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT6_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT6_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT6_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT6_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT6_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT6_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT6_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT6_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT6_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT6.Reg, volatile.LoadUint8(&o.ENDPT6.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT6_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT6.Reg) & 0x80) >> 7
}

// USB0.ENDPT7: Endpoint Control register
func (o *USB0_Type) SetENDPT7_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT7_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT7.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT7_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT7_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT7_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT7_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT7_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT7_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT7_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT7_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT7_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT7_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT7_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT7.Reg, volatile.LoadUint8(&o.ENDPT7.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT7_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT7.Reg) & 0x80) >> 7
}

// USB0.ENDPT8: Endpoint Control register
func (o *USB0_Type) SetENDPT8_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT8_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT8.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT8_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT8_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT8_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT8_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT8_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT8_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT8_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT8_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT8_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT8_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT8_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT8.Reg, volatile.LoadUint8(&o.ENDPT8.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT8_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT8.Reg) & 0x80) >> 7
}

// USB0.ENDPT9: Endpoint Control register
func (o *USB0_Type) SetENDPT9_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT9_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT9.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT9_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT9_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT9_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT9_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT9_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT9_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT9_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT9_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT9_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT9_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT9_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT9.Reg, volatile.LoadUint8(&o.ENDPT9.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT9_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT9.Reg) & 0x80) >> 7
}

// USB0.ENDPT10: Endpoint Control register
func (o *USB0_Type) SetENDPT10_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT10_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT10.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT10_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT10_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT10_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT10_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT10_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT10_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT10_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT10_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT10_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT10_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT10_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT10.Reg, volatile.LoadUint8(&o.ENDPT10.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT10_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT10.Reg) & 0x80) >> 7
}

// USB0.ENDPT11: Endpoint Control register
func (o *USB0_Type) SetENDPT11_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT11_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT11.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT11_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT11_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT11_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT11_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT11_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT11_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT11_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT11_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT11_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT11_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT11_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT11.Reg, volatile.LoadUint8(&o.ENDPT11.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT11_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT11.Reg) & 0x80) >> 7
}

// USB0.ENDPT12: Endpoint Control register
func (o *USB0_Type) SetENDPT12_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT12_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT12.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT12_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT12_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT12_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT12_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT12_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT12_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT12_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT12_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT12_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT12_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT12_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT12.Reg, volatile.LoadUint8(&o.ENDPT12.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT12_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT12.Reg) & 0x80) >> 7
}

// USB0.ENDPT13: Endpoint Control register
func (o *USB0_Type) SetENDPT13_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT13_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT13.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT13_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT13_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT13_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT13_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT13_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT13_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT13_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT13_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT13_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT13_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT13_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT13.Reg, volatile.LoadUint8(&o.ENDPT13.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT13_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT13.Reg) & 0x80) >> 7
}

// USB0.ENDPT14: Endpoint Control register
func (o *USB0_Type) SetENDPT14_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT14_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT14.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT14_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT14_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT14_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT14_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT14_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT14_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT14_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT14_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT14_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT14_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT14_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT14.Reg, volatile.LoadUint8(&o.ENDPT14.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT14_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT14.Reg) & 0x80) >> 7
}

// USB0.ENDPT15: Endpoint Control register
func (o *USB0_Type) SetENDPT15_EPHSHK(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPT15_EPHSHK() uint8 {
	return volatile.LoadUint8(&o.ENDPT15.Reg) & 0x1
}
func (o *USB0_Type) SetENDPT15_EPSTALL(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPT15_EPSTALL() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPT15_EPTXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPT15_EPTXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPT15_EPRXEN(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPT15_EPRXEN() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPT15_EPCTLDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPT15_EPCTLDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPT15_RETRYDIS(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPT15_RETRYDIS() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPT15_HOSTWOHUB(value uint8) {
	volatile.StoreUint8(&o.ENDPT15.Reg, volatile.LoadUint8(&o.ENDPT15.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPT15_HOSTWOHUB() uint8 {
	return (volatile.LoadUint8(&o.ENDPT15.Reg) & 0x80) >> 7
}

// USB0.USBCTRL: USB Control register
func (o *USB0_Type) SetUSBCTRL_PDE(value uint8) {
	volatile.StoreUint8(&o.USBCTRL.Reg, volatile.LoadUint8(&o.USBCTRL.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetUSBCTRL_PDE() uint8 {
	return (volatile.LoadUint8(&o.USBCTRL.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetUSBCTRL_SUSP(value uint8) {
	volatile.StoreUint8(&o.USBCTRL.Reg, volatile.LoadUint8(&o.USBCTRL.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetUSBCTRL_SUSP() uint8 {
	return (volatile.LoadUint8(&o.USBCTRL.Reg) & 0x80) >> 7
}

// USB0.OBSERVE: USB OTG Observe register
func (o *USB0_Type) SetOBSERVE_DMPD(value uint8) {
	volatile.StoreUint8(&o.OBSERVE.Reg, volatile.LoadUint8(&o.OBSERVE.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetOBSERVE_DMPD() uint8 {
	return (volatile.LoadUint8(&o.OBSERVE.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetOBSERVE_DPPD(value uint8) {
	volatile.StoreUint8(&o.OBSERVE.Reg, volatile.LoadUint8(&o.OBSERVE.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetOBSERVE_DPPD() uint8 {
	return (volatile.LoadUint8(&o.OBSERVE.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetOBSERVE_DPPU(value uint8) {
	volatile.StoreUint8(&o.OBSERVE.Reg, volatile.LoadUint8(&o.OBSERVE.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOBSERVE_DPPU() uint8 {
	return (volatile.LoadUint8(&o.OBSERVE.Reg) & 0x80) >> 7
}

// USB0.CONTROL: USB OTG Control register
func (o *USB0_Type) SetCONTROL_DPPULLUPNONOTG(value uint8) {
	volatile.StoreUint8(&o.CONTROL.Reg, volatile.LoadUint8(&o.CONTROL.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetCONTROL_DPPULLUPNONOTG() uint8 {
	return (volatile.LoadUint8(&o.CONTROL.Reg) & 0x10) >> 4
}

// USB0.USBTRC0: USB Transceiver Control register 0
func (o *USB0_Type) SetUSBTRC0_USB_RESUME_INT(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetUSBTRC0_USB_RESUME_INT() uint8 {
	return volatile.LoadUint8(&o.USBTRC0.Reg) & 0x1
}
func (o *USB0_Type) SetUSBTRC0_SYNC_DET(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetUSBTRC0_SYNC_DET() uint8 {
	return (volatile.LoadUint8(&o.USBTRC0.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetUSBTRC0_USB_CLK_RECOVERY_INT(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetUSBTRC0_USB_CLK_RECOVERY_INT() uint8 {
	return (volatile.LoadUint8(&o.USBTRC0.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetUSBTRC0_USBRESMEN(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetUSBTRC0_USBRESMEN() uint8 {
	return (volatile.LoadUint8(&o.USBTRC0.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetUSBTRC0_USBRESET(value uint8) {
	volatile.StoreUint8(&o.USBTRC0.Reg, volatile.LoadUint8(&o.USBTRC0.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetUSBTRC0_USBRESET() uint8 {
	return (volatile.LoadUint8(&o.USBTRC0.Reg) & 0x80) >> 7
}

// USB0.USBFRMADJUST: Frame Adjust Register
func (o *USB0_Type) SetUSBFRMADJUST(value uint8) {
	volatile.StoreUint8(&o.USBFRMADJUST.Reg, value)
}
func (o *USB0_Type) GetUSBFRMADJUST() uint8 {
	return volatile.LoadUint8(&o.USBFRMADJUST.Reg)
}

// USB0.CLK_RECOVER_CTRL: USB Clock recovery control
func (o *USB0_Type) SetCLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_CTRL.Reg, volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetCLK_RECOVER_CTRL_RESTART_IFRTRIM_EN() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetCLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_CTRL.Reg, volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetCLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetCLK_RECOVER_CTRL_CLOCK_RECOVER_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_CTRL.Reg, volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetCLK_RECOVER_CTRL_CLOCK_RECOVER_EN() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_CTRL.Reg) & 0x80) >> 7
}

// USB0.CLK_RECOVER_IRC_EN: IRC48M oscillator enable register
func (o *USB0_Type) SetCLK_RECOVER_IRC_EN_REG_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_IRC_EN.Reg, volatile.LoadUint8(&o.CLK_RECOVER_IRC_EN.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetCLK_RECOVER_IRC_EN_REG_EN() uint8 {
	return volatile.LoadUint8(&o.CLK_RECOVER_IRC_EN.Reg) & 0x1
}
func (o *USB0_Type) SetCLK_RECOVER_IRC_EN_IRC_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_IRC_EN.Reg, volatile.LoadUint8(&o.CLK_RECOVER_IRC_EN.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetCLK_RECOVER_IRC_EN_IRC_EN() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_IRC_EN.Reg) & 0x2) >> 1
}

// USB0.CLK_RECOVER_INT_EN: Clock recovery combined interrupt enable
func (o *USB0_Type) SetCLK_RECOVER_INT_EN_OVF_ERROR_EN(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_INT_EN.Reg, volatile.LoadUint8(&o.CLK_RECOVER_INT_EN.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetCLK_RECOVER_INT_EN_OVF_ERROR_EN() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_INT_EN.Reg) & 0x10) >> 4
}

// USB0.CLK_RECOVER_INT_STATUS: Clock recovery separated interrupt status
func (o *USB0_Type) SetCLK_RECOVER_INT_STATUS_OVF_ERROR(value uint8) {
	volatile.StoreUint8(&o.CLK_RECOVER_INT_STATUS.Reg, volatile.LoadUint8(&o.CLK_RECOVER_INT_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetCLK_RECOVER_INT_STATUS_OVF_ERROR() uint8 {
	return (volatile.LoadUint8(&o.CLK_RECOVER_INT_STATUS.Reg) & 0x10) >> 4
}

// High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
type CMP_Type struct {
	CR0   volatile.Register8 // 0x0
	CR1   volatile.Register8 // 0x1
	FPR   volatile.Register8 // 0x2
	SCR   volatile.Register8 // 0x3
	DACCR volatile.Register8 // 0x4
	MUXCR volatile.Register8 // 0x5
}

// CMP.CR0: CMP Control Register 0
func (o *CMP_Type) SetCR0_HYSTCTR(value uint8) {
	volatile.StoreUint8(&o.CR0.Reg, volatile.LoadUint8(&o.CR0.Reg)&^(0x3)|value)
}
func (o *CMP_Type) GetCR0_HYSTCTR() uint8 {
	return volatile.LoadUint8(&o.CR0.Reg) & 0x3
}
func (o *CMP_Type) SetCR0_FILTER_CNT(value uint8) {
	volatile.StoreUint8(&o.CR0.Reg, volatile.LoadUint8(&o.CR0.Reg)&^(0x70)|value<<4)
}
func (o *CMP_Type) GetCR0_FILTER_CNT() uint8 {
	return (volatile.LoadUint8(&o.CR0.Reg) & 0x70) >> 4
}

// CMP.CR1: CMP Control Register 1
func (o *CMP_Type) SetCR1_EN(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x1)|value)
}
func (o *CMP_Type) GetCR1_EN() uint8 {
	return volatile.LoadUint8(&o.CR1.Reg) & 0x1
}
func (o *CMP_Type) SetCR1_OPE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *CMP_Type) GetCR1_OPE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x2) >> 1
}
func (o *CMP_Type) SetCR1_COS(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *CMP_Type) GetCR1_COS() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x4) >> 2
}
func (o *CMP_Type) SetCR1_INV(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *CMP_Type) GetCR1_INV() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x8) >> 3
}
func (o *CMP_Type) SetCR1_PMODE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *CMP_Type) GetCR1_PMODE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x10) >> 4
}
func (o *CMP_Type) SetCR1_TRIGM(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *CMP_Type) GetCR1_TRIGM() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x20) >> 5
}
func (o *CMP_Type) SetCR1_WE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *CMP_Type) GetCR1_WE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x40) >> 6
}
func (o *CMP_Type) SetCR1_SE(value uint8) {
	volatile.StoreUint8(&o.CR1.Reg, volatile.LoadUint8(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *CMP_Type) GetCR1_SE() uint8 {
	return (volatile.LoadUint8(&o.CR1.Reg) & 0x80) >> 7
}

// CMP.FPR: CMP Filter Period Register
func (o *CMP_Type) SetFPR(value uint8) {
	volatile.StoreUint8(&o.FPR.Reg, value)
}
func (o *CMP_Type) GetFPR() uint8 {
	return volatile.LoadUint8(&o.FPR.Reg)
}

// CMP.SCR: CMP Status and Control Register
func (o *CMP_Type) SetSCR_COUT(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x1)|value)
}
func (o *CMP_Type) GetSCR_COUT() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x1
}
func (o *CMP_Type) SetSCR_CFF(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *CMP_Type) GetSCR_CFF() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x2) >> 1
}
func (o *CMP_Type) SetSCR_CFR(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *CMP_Type) GetSCR_CFR() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *CMP_Type) SetSCR_IEF(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *CMP_Type) GetSCR_IEF() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *CMP_Type) SetSCR_IER(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *CMP_Type) GetSCR_IER() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *CMP_Type) SetSCR_DMAEN(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *CMP_Type) GetSCR_DMAEN() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}

// CMP.DACCR: DAC Control Register
func (o *CMP_Type) SetDACCR_VOSEL(value uint8) {
	volatile.StoreUint8(&o.DACCR.Reg, volatile.LoadUint8(&o.DACCR.Reg)&^(0x3f)|value)
}
func (o *CMP_Type) GetDACCR_VOSEL() uint8 {
	return volatile.LoadUint8(&o.DACCR.Reg) & 0x3f
}
func (o *CMP_Type) SetDACCR_VRSEL(value uint8) {
	volatile.StoreUint8(&o.DACCR.Reg, volatile.LoadUint8(&o.DACCR.Reg)&^(0x40)|value<<6)
}
func (o *CMP_Type) GetDACCR_VRSEL() uint8 {
	return (volatile.LoadUint8(&o.DACCR.Reg) & 0x40) >> 6
}
func (o *CMP_Type) SetDACCR_DACEN(value uint8) {
	volatile.StoreUint8(&o.DACCR.Reg, volatile.LoadUint8(&o.DACCR.Reg)&^(0x80)|value<<7)
}
func (o *CMP_Type) GetDACCR_DACEN() uint8 {
	return (volatile.LoadUint8(&o.DACCR.Reg) & 0x80) >> 7
}

// CMP.MUXCR: MUX Control Register
func (o *CMP_Type) SetMUXCR_MSEL(value uint8) {
	volatile.StoreUint8(&o.MUXCR.Reg, volatile.LoadUint8(&o.MUXCR.Reg)&^(0x7)|value)
}
func (o *CMP_Type) GetMUXCR_MSEL() uint8 {
	return volatile.LoadUint8(&o.MUXCR.Reg) & 0x7
}
func (o *CMP_Type) SetMUXCR_PSEL(value uint8) {
	volatile.StoreUint8(&o.MUXCR.Reg, volatile.LoadUint8(&o.MUXCR.Reg)&^(0x38)|value<<3)
}
func (o *CMP_Type) GetMUXCR_PSEL() uint8 {
	return (volatile.LoadUint8(&o.MUXCR.Reg) & 0x38) >> 3
}
func (o *CMP_Type) SetMUXCR_PSTM(value uint8) {
	volatile.StoreUint8(&o.MUXCR.Reg, volatile.LoadUint8(&o.MUXCR.Reg)&^(0x80)|value<<7)
}
func (o *CMP_Type) GetMUXCR_PSTM() uint8 {
	return (volatile.LoadUint8(&o.MUXCR.Reg) & 0x80) >> 7
}

// Voltage Reference
type VREF_Type struct {
	TRM volatile.Register8 // 0x0
	SC  volatile.Register8 // 0x1
}

// VREF.TRM: VREF Trim Register
func (o *VREF_Type) SetTRM_TRIM(value uint8) {
	volatile.StoreUint8(&o.TRM.Reg, volatile.LoadUint8(&o.TRM.Reg)&^(0x3f)|value)
}
func (o *VREF_Type) GetTRM_TRIM() uint8 {
	return volatile.LoadUint8(&o.TRM.Reg) & 0x3f
}
func (o *VREF_Type) SetTRM_CHOPEN(value uint8) {
	volatile.StoreUint8(&o.TRM.Reg, volatile.LoadUint8(&o.TRM.Reg)&^(0x40)|value<<6)
}
func (o *VREF_Type) GetTRM_CHOPEN() uint8 {
	return (volatile.LoadUint8(&o.TRM.Reg) & 0x40) >> 6
}

// VREF.SC: VREF Status and Control Register
func (o *VREF_Type) SetSC_MODE_LV(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x3)|value)
}
func (o *VREF_Type) GetSC_MODE_LV() uint8 {
	return volatile.LoadUint8(&o.SC.Reg) & 0x3
}
func (o *VREF_Type) SetSC_VREFST(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x4)|value<<2)
}
func (o *VREF_Type) GetSC_VREFST() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x4) >> 2
}
func (o *VREF_Type) SetSC_ICOMPEN(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x20)|value<<5)
}
func (o *VREF_Type) GetSC_ICOMPEN() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x20) >> 5
}
func (o *VREF_Type) SetSC_REGEN(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x40)|value<<6)
}
func (o *VREF_Type) GetSC_REGEN() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x40) >> 6
}
func (o *VREF_Type) SetSC_VREFEN(value uint8) {
	volatile.StoreUint8(&o.SC.Reg, volatile.LoadUint8(&o.SC.Reg)&^(0x80)|value<<7)
}
func (o *VREF_Type) GetSC_VREFEN() uint8 {
	return (volatile.LoadUint8(&o.SC.Reg) & 0x80) >> 7
}

// Low leakage wakeup unit
type LLWU_Type struct {
	PE1   volatile.Register8 // 0x0
	PE2   volatile.Register8 // 0x1
	PE3   volatile.Register8 // 0x2
	PE4   volatile.Register8 // 0x3
	PE5   volatile.Register8 // 0x4
	PE6   volatile.Register8 // 0x5
	PE7   volatile.Register8 // 0x6
	PE8   volatile.Register8 // 0x7
	ME    volatile.Register8 // 0x8
	PF1   volatile.Register8 // 0x9
	PF2   volatile.Register8 // 0xA
	PF3   volatile.Register8 // 0xB
	PF4   volatile.Register8 // 0xC
	MF5   volatile.Register8 // 0xD
	FILT1 volatile.Register8 // 0xE
	FILT2 volatile.Register8 // 0xF
	FILT3 volatile.Register8 // 0x10
	FILT4 volatile.Register8 // 0x11
}

// LLWU.PE1: LLWU Pin Enable 1 register
func (o *LLWU_Type) SetPE1_WUPE0(value uint8) {
	volatile.StoreUint8(&o.PE1.Reg, volatile.LoadUint8(&o.PE1.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE1_WUPE0() uint8 {
	return volatile.LoadUint8(&o.PE1.Reg) & 0x3
}
func (o *LLWU_Type) SetPE1_WUPE1(value uint8) {
	volatile.StoreUint8(&o.PE1.Reg, volatile.LoadUint8(&o.PE1.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE1_WUPE1() uint8 {
	return (volatile.LoadUint8(&o.PE1.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE1_WUPE2(value uint8) {
	volatile.StoreUint8(&o.PE1.Reg, volatile.LoadUint8(&o.PE1.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE1_WUPE2() uint8 {
	return (volatile.LoadUint8(&o.PE1.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE1_WUPE3(value uint8) {
	volatile.StoreUint8(&o.PE1.Reg, volatile.LoadUint8(&o.PE1.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE1_WUPE3() uint8 {
	return (volatile.LoadUint8(&o.PE1.Reg) & 0xc0) >> 6
}

// LLWU.PE2: LLWU Pin Enable 2 register
func (o *LLWU_Type) SetPE2_WUPE4(value uint8) {
	volatile.StoreUint8(&o.PE2.Reg, volatile.LoadUint8(&o.PE2.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE2_WUPE4() uint8 {
	return volatile.LoadUint8(&o.PE2.Reg) & 0x3
}
func (o *LLWU_Type) SetPE2_WUPE5(value uint8) {
	volatile.StoreUint8(&o.PE2.Reg, volatile.LoadUint8(&o.PE2.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE2_WUPE5() uint8 {
	return (volatile.LoadUint8(&o.PE2.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE2_WUPE6(value uint8) {
	volatile.StoreUint8(&o.PE2.Reg, volatile.LoadUint8(&o.PE2.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE2_WUPE6() uint8 {
	return (volatile.LoadUint8(&o.PE2.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE2_WUPE7(value uint8) {
	volatile.StoreUint8(&o.PE2.Reg, volatile.LoadUint8(&o.PE2.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE2_WUPE7() uint8 {
	return (volatile.LoadUint8(&o.PE2.Reg) & 0xc0) >> 6
}

// LLWU.PE3: LLWU Pin Enable 3 register
func (o *LLWU_Type) SetPE3_WUPE8(value uint8) {
	volatile.StoreUint8(&o.PE3.Reg, volatile.LoadUint8(&o.PE3.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE3_WUPE8() uint8 {
	return volatile.LoadUint8(&o.PE3.Reg) & 0x3
}
func (o *LLWU_Type) SetPE3_WUPE9(value uint8) {
	volatile.StoreUint8(&o.PE3.Reg, volatile.LoadUint8(&o.PE3.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE3_WUPE9() uint8 {
	return (volatile.LoadUint8(&o.PE3.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE3_WUPE10(value uint8) {
	volatile.StoreUint8(&o.PE3.Reg, volatile.LoadUint8(&o.PE3.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE3_WUPE10() uint8 {
	return (volatile.LoadUint8(&o.PE3.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE3_WUPE11(value uint8) {
	volatile.StoreUint8(&o.PE3.Reg, volatile.LoadUint8(&o.PE3.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE3_WUPE11() uint8 {
	return (volatile.LoadUint8(&o.PE3.Reg) & 0xc0) >> 6
}

// LLWU.PE4: LLWU Pin Enable 4 register
func (o *LLWU_Type) SetPE4_WUPE12(value uint8) {
	volatile.StoreUint8(&o.PE4.Reg, volatile.LoadUint8(&o.PE4.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE4_WUPE12() uint8 {
	return volatile.LoadUint8(&o.PE4.Reg) & 0x3
}
func (o *LLWU_Type) SetPE4_WUPE13(value uint8) {
	volatile.StoreUint8(&o.PE4.Reg, volatile.LoadUint8(&o.PE4.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE4_WUPE13() uint8 {
	return (volatile.LoadUint8(&o.PE4.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE4_WUPE14(value uint8) {
	volatile.StoreUint8(&o.PE4.Reg, volatile.LoadUint8(&o.PE4.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE4_WUPE14() uint8 {
	return (volatile.LoadUint8(&o.PE4.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE4_WUPE15(value uint8) {
	volatile.StoreUint8(&o.PE4.Reg, volatile.LoadUint8(&o.PE4.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE4_WUPE15() uint8 {
	return (volatile.LoadUint8(&o.PE4.Reg) & 0xc0) >> 6
}

// LLWU.PE5: LLWU Pin Enable 5 register
func (o *LLWU_Type) SetPE5_WUPE16(value uint8) {
	volatile.StoreUint8(&o.PE5.Reg, volatile.LoadUint8(&o.PE5.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE5_WUPE16() uint8 {
	return volatile.LoadUint8(&o.PE5.Reg) & 0x3
}
func (o *LLWU_Type) SetPE5_WUPE17(value uint8) {
	volatile.StoreUint8(&o.PE5.Reg, volatile.LoadUint8(&o.PE5.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE5_WUPE17() uint8 {
	return (volatile.LoadUint8(&o.PE5.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE5_WUPE18(value uint8) {
	volatile.StoreUint8(&o.PE5.Reg, volatile.LoadUint8(&o.PE5.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE5_WUPE18() uint8 {
	return (volatile.LoadUint8(&o.PE5.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE5_WUPE19(value uint8) {
	volatile.StoreUint8(&o.PE5.Reg, volatile.LoadUint8(&o.PE5.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE5_WUPE19() uint8 {
	return (volatile.LoadUint8(&o.PE5.Reg) & 0xc0) >> 6
}

// LLWU.PE6: LLWU Pin Enable 6 register
func (o *LLWU_Type) SetPE6_WUPE20(value uint8) {
	volatile.StoreUint8(&o.PE6.Reg, volatile.LoadUint8(&o.PE6.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE6_WUPE20() uint8 {
	return volatile.LoadUint8(&o.PE6.Reg) & 0x3
}
func (o *LLWU_Type) SetPE6_WUPE21(value uint8) {
	volatile.StoreUint8(&o.PE6.Reg, volatile.LoadUint8(&o.PE6.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE6_WUPE21() uint8 {
	return (volatile.LoadUint8(&o.PE6.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE6_WUPE22(value uint8) {
	volatile.StoreUint8(&o.PE6.Reg, volatile.LoadUint8(&o.PE6.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE6_WUPE22() uint8 {
	return (volatile.LoadUint8(&o.PE6.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE6_WUPE23(value uint8) {
	volatile.StoreUint8(&o.PE6.Reg, volatile.LoadUint8(&o.PE6.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE6_WUPE23() uint8 {
	return (volatile.LoadUint8(&o.PE6.Reg) & 0xc0) >> 6
}

// LLWU.PE7: LLWU Pin Enable 7 register
func (o *LLWU_Type) SetPE7_WUPE24(value uint8) {
	volatile.StoreUint8(&o.PE7.Reg, volatile.LoadUint8(&o.PE7.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE7_WUPE24() uint8 {
	return volatile.LoadUint8(&o.PE7.Reg) & 0x3
}
func (o *LLWU_Type) SetPE7_WUPE25(value uint8) {
	volatile.StoreUint8(&o.PE7.Reg, volatile.LoadUint8(&o.PE7.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE7_WUPE25() uint8 {
	return (volatile.LoadUint8(&o.PE7.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE7_WUPE26(value uint8) {
	volatile.StoreUint8(&o.PE7.Reg, volatile.LoadUint8(&o.PE7.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE7_WUPE26() uint8 {
	return (volatile.LoadUint8(&o.PE7.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE7_WUPE27(value uint8) {
	volatile.StoreUint8(&o.PE7.Reg, volatile.LoadUint8(&o.PE7.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE7_WUPE27() uint8 {
	return (volatile.LoadUint8(&o.PE7.Reg) & 0xc0) >> 6
}

// LLWU.PE8: LLWU Pin Enable 8 register
func (o *LLWU_Type) SetPE8_WUPE28(value uint8) {
	volatile.StoreUint8(&o.PE8.Reg, volatile.LoadUint8(&o.PE8.Reg)&^(0x3)|value)
}
func (o *LLWU_Type) GetPE8_WUPE28() uint8 {
	return volatile.LoadUint8(&o.PE8.Reg) & 0x3
}
func (o *LLWU_Type) SetPE8_WUPE29(value uint8) {
	volatile.StoreUint8(&o.PE8.Reg, volatile.LoadUint8(&o.PE8.Reg)&^(0xc)|value<<2)
}
func (o *LLWU_Type) GetPE8_WUPE29() uint8 {
	return (volatile.LoadUint8(&o.PE8.Reg) & 0xc) >> 2
}
func (o *LLWU_Type) SetPE8_WUPE30(value uint8) {
	volatile.StoreUint8(&o.PE8.Reg, volatile.LoadUint8(&o.PE8.Reg)&^(0x30)|value<<4)
}
func (o *LLWU_Type) GetPE8_WUPE30() uint8 {
	return (volatile.LoadUint8(&o.PE8.Reg) & 0x30) >> 4
}
func (o *LLWU_Type) SetPE8_WUPE31(value uint8) {
	volatile.StoreUint8(&o.PE8.Reg, volatile.LoadUint8(&o.PE8.Reg)&^(0xc0)|value<<6)
}
func (o *LLWU_Type) GetPE8_WUPE31() uint8 {
	return (volatile.LoadUint8(&o.PE8.Reg) & 0xc0) >> 6
}

// LLWU.ME: LLWU Module Enable register
func (o *LLWU_Type) SetME_WUME0(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetME_WUME0() uint8 {
	return volatile.LoadUint8(&o.ME.Reg) & 0x1
}
func (o *LLWU_Type) SetME_WUME1(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetME_WUME1() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetME_WUME2(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetME_WUME2() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetME_WUME3(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetME_WUME3() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetME_WUME4(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetME_WUME4() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetME_WUME5(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetME_WUME5() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetME_WUME6(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetME_WUME6() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetME_WUME7(value uint8) {
	volatile.StoreUint8(&o.ME.Reg, volatile.LoadUint8(&o.ME.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetME_WUME7() uint8 {
	return (volatile.LoadUint8(&o.ME.Reg) & 0x80) >> 7
}

// LLWU.PF1: LLWU Pin Flag 1 register
func (o *LLWU_Type) SetPF1_WUF0(value uint8) {
	volatile.StoreUint8(&o.PF1.Reg, volatile.LoadUint8(&o.PF1.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetPF1_WUF0() uint8 {
	return volatile.LoadUint8(&o.PF1.Reg) & 0x1
}
func (o *LLWU_Type) SetPF1_WUF1(value uint8) {
	volatile.StoreUint8(&o.PF1.Reg, volatile.LoadUint8(&o.PF1.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetPF1_WUF1() uint8 {
	return (volatile.LoadUint8(&o.PF1.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetPF1_WUF2(value uint8) {
	volatile.StoreUint8(&o.PF1.Reg, volatile.LoadUint8(&o.PF1.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetPF1_WUF2() uint8 {
	return (volatile.LoadUint8(&o.PF1.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetPF1_WUF3(value uint8) {
	volatile.StoreUint8(&o.PF1.Reg, volatile.LoadUint8(&o.PF1.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetPF1_WUF3() uint8 {
	return (volatile.LoadUint8(&o.PF1.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetPF1_WUF4(value uint8) {
	volatile.StoreUint8(&o.PF1.Reg, volatile.LoadUint8(&o.PF1.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetPF1_WUF4() uint8 {
	return (volatile.LoadUint8(&o.PF1.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetPF1_WUF5(value uint8) {
	volatile.StoreUint8(&o.PF1.Reg, volatile.LoadUint8(&o.PF1.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetPF1_WUF5() uint8 {
	return (volatile.LoadUint8(&o.PF1.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetPF1_WUF6(value uint8) {
	volatile.StoreUint8(&o.PF1.Reg, volatile.LoadUint8(&o.PF1.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetPF1_WUF6() uint8 {
	return (volatile.LoadUint8(&o.PF1.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetPF1_WUF7(value uint8) {
	volatile.StoreUint8(&o.PF1.Reg, volatile.LoadUint8(&o.PF1.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetPF1_WUF7() uint8 {
	return (volatile.LoadUint8(&o.PF1.Reg) & 0x80) >> 7
}

// LLWU.PF2: LLWU Pin Flag 2 register
func (o *LLWU_Type) SetPF2_WUF8(value uint8) {
	volatile.StoreUint8(&o.PF2.Reg, volatile.LoadUint8(&o.PF2.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetPF2_WUF8() uint8 {
	return volatile.LoadUint8(&o.PF2.Reg) & 0x1
}
func (o *LLWU_Type) SetPF2_WUF9(value uint8) {
	volatile.StoreUint8(&o.PF2.Reg, volatile.LoadUint8(&o.PF2.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetPF2_WUF9() uint8 {
	return (volatile.LoadUint8(&o.PF2.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetPF2_WUF10(value uint8) {
	volatile.StoreUint8(&o.PF2.Reg, volatile.LoadUint8(&o.PF2.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetPF2_WUF10() uint8 {
	return (volatile.LoadUint8(&o.PF2.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetPF2_WUF11(value uint8) {
	volatile.StoreUint8(&o.PF2.Reg, volatile.LoadUint8(&o.PF2.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetPF2_WUF11() uint8 {
	return (volatile.LoadUint8(&o.PF2.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetPF2_WUF12(value uint8) {
	volatile.StoreUint8(&o.PF2.Reg, volatile.LoadUint8(&o.PF2.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetPF2_WUF12() uint8 {
	return (volatile.LoadUint8(&o.PF2.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetPF2_WUF13(value uint8) {
	volatile.StoreUint8(&o.PF2.Reg, volatile.LoadUint8(&o.PF2.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetPF2_WUF13() uint8 {
	return (volatile.LoadUint8(&o.PF2.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetPF2_WUF14(value uint8) {
	volatile.StoreUint8(&o.PF2.Reg, volatile.LoadUint8(&o.PF2.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetPF2_WUF14() uint8 {
	return (volatile.LoadUint8(&o.PF2.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetPF2_WUF15(value uint8) {
	volatile.StoreUint8(&o.PF2.Reg, volatile.LoadUint8(&o.PF2.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetPF2_WUF15() uint8 {
	return (volatile.LoadUint8(&o.PF2.Reg) & 0x80) >> 7
}

// LLWU.PF3: LLWU Pin Flag 3 register
func (o *LLWU_Type) SetPF3_WUF16(value uint8) {
	volatile.StoreUint8(&o.PF3.Reg, volatile.LoadUint8(&o.PF3.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetPF3_WUF16() uint8 {
	return volatile.LoadUint8(&o.PF3.Reg) & 0x1
}
func (o *LLWU_Type) SetPF3_WUF17(value uint8) {
	volatile.StoreUint8(&o.PF3.Reg, volatile.LoadUint8(&o.PF3.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetPF3_WUF17() uint8 {
	return (volatile.LoadUint8(&o.PF3.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetPF3_WUF18(value uint8) {
	volatile.StoreUint8(&o.PF3.Reg, volatile.LoadUint8(&o.PF3.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetPF3_WUF18() uint8 {
	return (volatile.LoadUint8(&o.PF3.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetPF3_WUF19(value uint8) {
	volatile.StoreUint8(&o.PF3.Reg, volatile.LoadUint8(&o.PF3.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetPF3_WUF19() uint8 {
	return (volatile.LoadUint8(&o.PF3.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetPF3_WUF20(value uint8) {
	volatile.StoreUint8(&o.PF3.Reg, volatile.LoadUint8(&o.PF3.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetPF3_WUF20() uint8 {
	return (volatile.LoadUint8(&o.PF3.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetPF3_WUF21(value uint8) {
	volatile.StoreUint8(&o.PF3.Reg, volatile.LoadUint8(&o.PF3.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetPF3_WUF21() uint8 {
	return (volatile.LoadUint8(&o.PF3.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetPF3_WUF22(value uint8) {
	volatile.StoreUint8(&o.PF3.Reg, volatile.LoadUint8(&o.PF3.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetPF3_WUF22() uint8 {
	return (volatile.LoadUint8(&o.PF3.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetPF3_WUF23(value uint8) {
	volatile.StoreUint8(&o.PF3.Reg, volatile.LoadUint8(&o.PF3.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetPF3_WUF23() uint8 {
	return (volatile.LoadUint8(&o.PF3.Reg) & 0x80) >> 7
}

// LLWU.PF4: LLWU Pin Flag 4 register
func (o *LLWU_Type) SetPF4_WUF24(value uint8) {
	volatile.StoreUint8(&o.PF4.Reg, volatile.LoadUint8(&o.PF4.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetPF4_WUF24() uint8 {
	return volatile.LoadUint8(&o.PF4.Reg) & 0x1
}
func (o *LLWU_Type) SetPF4_WUF25(value uint8) {
	volatile.StoreUint8(&o.PF4.Reg, volatile.LoadUint8(&o.PF4.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetPF4_WUF25() uint8 {
	return (volatile.LoadUint8(&o.PF4.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetPF4_WUF26(value uint8) {
	volatile.StoreUint8(&o.PF4.Reg, volatile.LoadUint8(&o.PF4.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetPF4_WUF26() uint8 {
	return (volatile.LoadUint8(&o.PF4.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetPF4_WUF27(value uint8) {
	volatile.StoreUint8(&o.PF4.Reg, volatile.LoadUint8(&o.PF4.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetPF4_WUF27() uint8 {
	return (volatile.LoadUint8(&o.PF4.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetPF4_WUF28(value uint8) {
	volatile.StoreUint8(&o.PF4.Reg, volatile.LoadUint8(&o.PF4.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetPF4_WUF28() uint8 {
	return (volatile.LoadUint8(&o.PF4.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetPF4_WUF29(value uint8) {
	volatile.StoreUint8(&o.PF4.Reg, volatile.LoadUint8(&o.PF4.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetPF4_WUF29() uint8 {
	return (volatile.LoadUint8(&o.PF4.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetPF4_WUF30(value uint8) {
	volatile.StoreUint8(&o.PF4.Reg, volatile.LoadUint8(&o.PF4.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetPF4_WUF30() uint8 {
	return (volatile.LoadUint8(&o.PF4.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetPF4_WUF31(value uint8) {
	volatile.StoreUint8(&o.PF4.Reg, volatile.LoadUint8(&o.PF4.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetPF4_WUF31() uint8 {
	return (volatile.LoadUint8(&o.PF4.Reg) & 0x80) >> 7
}

// LLWU.MF5: LLWU Module Flag 5 register
func (o *LLWU_Type) SetMF5_MWUF0(value uint8) {
	volatile.StoreUint8(&o.MF5.Reg, volatile.LoadUint8(&o.MF5.Reg)&^(0x1)|value)
}
func (o *LLWU_Type) GetMF5_MWUF0() uint8 {
	return volatile.LoadUint8(&o.MF5.Reg) & 0x1
}
func (o *LLWU_Type) SetMF5_MWUF1(value uint8) {
	volatile.StoreUint8(&o.MF5.Reg, volatile.LoadUint8(&o.MF5.Reg)&^(0x2)|value<<1)
}
func (o *LLWU_Type) GetMF5_MWUF1() uint8 {
	return (volatile.LoadUint8(&o.MF5.Reg) & 0x2) >> 1
}
func (o *LLWU_Type) SetMF5_MWUF2(value uint8) {
	volatile.StoreUint8(&o.MF5.Reg, volatile.LoadUint8(&o.MF5.Reg)&^(0x4)|value<<2)
}
func (o *LLWU_Type) GetMF5_MWUF2() uint8 {
	return (volatile.LoadUint8(&o.MF5.Reg) & 0x4) >> 2
}
func (o *LLWU_Type) SetMF5_MWUF3(value uint8) {
	volatile.StoreUint8(&o.MF5.Reg, volatile.LoadUint8(&o.MF5.Reg)&^(0x8)|value<<3)
}
func (o *LLWU_Type) GetMF5_MWUF3() uint8 {
	return (volatile.LoadUint8(&o.MF5.Reg) & 0x8) >> 3
}
func (o *LLWU_Type) SetMF5_MWUF4(value uint8) {
	volatile.StoreUint8(&o.MF5.Reg, volatile.LoadUint8(&o.MF5.Reg)&^(0x10)|value<<4)
}
func (o *LLWU_Type) GetMF5_MWUF4() uint8 {
	return (volatile.LoadUint8(&o.MF5.Reg) & 0x10) >> 4
}
func (o *LLWU_Type) SetMF5_MWUF5(value uint8) {
	volatile.StoreUint8(&o.MF5.Reg, volatile.LoadUint8(&o.MF5.Reg)&^(0x20)|value<<5)
}
func (o *LLWU_Type) GetMF5_MWUF5() uint8 {
	return (volatile.LoadUint8(&o.MF5.Reg) & 0x20) >> 5
}
func (o *LLWU_Type) SetMF5_MWUF6(value uint8) {
	volatile.StoreUint8(&o.MF5.Reg, volatile.LoadUint8(&o.MF5.Reg)&^(0x40)|value<<6)
}
func (o *LLWU_Type) GetMF5_MWUF6() uint8 {
	return (volatile.LoadUint8(&o.MF5.Reg) & 0x40) >> 6
}
func (o *LLWU_Type) SetMF5_MWUF7(value uint8) {
	volatile.StoreUint8(&o.MF5.Reg, volatile.LoadUint8(&o.MF5.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetMF5_MWUF7() uint8 {
	return (volatile.LoadUint8(&o.MF5.Reg) & 0x80) >> 7
}

// LLWU.FILT1: LLWU Pin Filter 1 register
func (o *LLWU_Type) SetFILT1_FILTSEL(value uint8) {
	volatile.StoreUint8(&o.FILT1.Reg, volatile.LoadUint8(&o.FILT1.Reg)&^(0x1f)|value)
}
func (o *LLWU_Type) GetFILT1_FILTSEL() uint8 {
	return volatile.LoadUint8(&o.FILT1.Reg) & 0x1f
}
func (o *LLWU_Type) SetFILT1_FILTE(value uint8) {
	volatile.StoreUint8(&o.FILT1.Reg, volatile.LoadUint8(&o.FILT1.Reg)&^(0x60)|value<<5)
}
func (o *LLWU_Type) GetFILT1_FILTE() uint8 {
	return (volatile.LoadUint8(&o.FILT1.Reg) & 0x60) >> 5
}
func (o *LLWU_Type) SetFILT1_FILTF(value uint8) {
	volatile.StoreUint8(&o.FILT1.Reg, volatile.LoadUint8(&o.FILT1.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetFILT1_FILTF() uint8 {
	return (volatile.LoadUint8(&o.FILT1.Reg) & 0x80) >> 7
}

// LLWU.FILT2: LLWU Pin Filter 2 register
func (o *LLWU_Type) SetFILT2_FILTSEL(value uint8) {
	volatile.StoreUint8(&o.FILT2.Reg, volatile.LoadUint8(&o.FILT2.Reg)&^(0x1f)|value)
}
func (o *LLWU_Type) GetFILT2_FILTSEL() uint8 {
	return volatile.LoadUint8(&o.FILT2.Reg) & 0x1f
}
func (o *LLWU_Type) SetFILT2_FILTE(value uint8) {
	volatile.StoreUint8(&o.FILT2.Reg, volatile.LoadUint8(&o.FILT2.Reg)&^(0x60)|value<<5)
}
func (o *LLWU_Type) GetFILT2_FILTE() uint8 {
	return (volatile.LoadUint8(&o.FILT2.Reg) & 0x60) >> 5
}
func (o *LLWU_Type) SetFILT2_FILTF(value uint8) {
	volatile.StoreUint8(&o.FILT2.Reg, volatile.LoadUint8(&o.FILT2.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetFILT2_FILTF() uint8 {
	return (volatile.LoadUint8(&o.FILT2.Reg) & 0x80) >> 7
}

// LLWU.FILT3: LLWU Pin Filter 3 register
func (o *LLWU_Type) SetFILT3_FILTSEL(value uint8) {
	volatile.StoreUint8(&o.FILT3.Reg, volatile.LoadUint8(&o.FILT3.Reg)&^(0x1f)|value)
}
func (o *LLWU_Type) GetFILT3_FILTSEL() uint8 {
	return volatile.LoadUint8(&o.FILT3.Reg) & 0x1f
}
func (o *LLWU_Type) SetFILT3_FILTE(value uint8) {
	volatile.StoreUint8(&o.FILT3.Reg, volatile.LoadUint8(&o.FILT3.Reg)&^(0x60)|value<<5)
}
func (o *LLWU_Type) GetFILT3_FILTE() uint8 {
	return (volatile.LoadUint8(&o.FILT3.Reg) & 0x60) >> 5
}
func (o *LLWU_Type) SetFILT3_FILTF(value uint8) {
	volatile.StoreUint8(&o.FILT3.Reg, volatile.LoadUint8(&o.FILT3.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetFILT3_FILTF() uint8 {
	return (volatile.LoadUint8(&o.FILT3.Reg) & 0x80) >> 7
}

// LLWU.FILT4: LLWU Pin Filter 4 register
func (o *LLWU_Type) SetFILT4_FILTSEL(value uint8) {
	volatile.StoreUint8(&o.FILT4.Reg, volatile.LoadUint8(&o.FILT4.Reg)&^(0x1f)|value)
}
func (o *LLWU_Type) GetFILT4_FILTSEL() uint8 {
	return volatile.LoadUint8(&o.FILT4.Reg) & 0x1f
}
func (o *LLWU_Type) SetFILT4_FILTE(value uint8) {
	volatile.StoreUint8(&o.FILT4.Reg, volatile.LoadUint8(&o.FILT4.Reg)&^(0x60)|value<<5)
}
func (o *LLWU_Type) GetFILT4_FILTE() uint8 {
	return (volatile.LoadUint8(&o.FILT4.Reg) & 0x60) >> 5
}
func (o *LLWU_Type) SetFILT4_FILTF(value uint8) {
	volatile.StoreUint8(&o.FILT4.Reg, volatile.LoadUint8(&o.FILT4.Reg)&^(0x80)|value<<7)
}
func (o *LLWU_Type) GetFILT4_FILTF() uint8 {
	return (volatile.LoadUint8(&o.FILT4.Reg) & 0x80) >> 7
}

// Power Management Controller
type PMC_Type struct {
	LVDSC1 volatile.Register8 // 0x0
	LVDSC2 volatile.Register8 // 0x1
	REGSC  volatile.Register8 // 0x2
}

// PMC.LVDSC1: Low Voltage Detect Status And Control 1 register
func (o *PMC_Type) SetLVDSC1_LVDV(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x3)|value)
}
func (o *PMC_Type) GetLVDSC1_LVDV() uint8 {
	return volatile.LoadUint8(&o.LVDSC1.Reg) & 0x3
}
func (o *PMC_Type) SetLVDSC1_LVDRE(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetLVDSC1_LVDRE() uint8 {
	return (volatile.LoadUint8(&o.LVDSC1.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetLVDSC1_LVDIE(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetLVDSC1_LVDIE() uint8 {
	return (volatile.LoadUint8(&o.LVDSC1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetLVDSC1_LVDACK(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetLVDSC1_LVDACK() uint8 {
	return (volatile.LoadUint8(&o.LVDSC1.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetLVDSC1_LVDF(value uint8) {
	volatile.StoreUint8(&o.LVDSC1.Reg, volatile.LoadUint8(&o.LVDSC1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetLVDSC1_LVDF() uint8 {
	return (volatile.LoadUint8(&o.LVDSC1.Reg) & 0x80) >> 7
}

// PMC.LVDSC2: Low Voltage Detect Status And Control 2 register
func (o *PMC_Type) SetLVDSC2_LVWV(value uint8) {
	volatile.StoreUint8(&o.LVDSC2.Reg, volatile.LoadUint8(&o.LVDSC2.Reg)&^(0x3)|value)
}
func (o *PMC_Type) GetLVDSC2_LVWV() uint8 {
	return volatile.LoadUint8(&o.LVDSC2.Reg) & 0x3
}
func (o *PMC_Type) SetLVDSC2_LVWIE(value uint8) {
	volatile.StoreUint8(&o.LVDSC2.Reg, volatile.LoadUint8(&o.LVDSC2.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetLVDSC2_LVWIE() uint8 {
	return (volatile.LoadUint8(&o.LVDSC2.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetLVDSC2_LVWACK(value uint8) {
	volatile.StoreUint8(&o.LVDSC2.Reg, volatile.LoadUint8(&o.LVDSC2.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetLVDSC2_LVWACK() uint8 {
	return (volatile.LoadUint8(&o.LVDSC2.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetLVDSC2_LVWF(value uint8) {
	volatile.StoreUint8(&o.LVDSC2.Reg, volatile.LoadUint8(&o.LVDSC2.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetLVDSC2_LVWF() uint8 {
	return (volatile.LoadUint8(&o.LVDSC2.Reg) & 0x80) >> 7
}

// PMC.REGSC: Regulator Status And Control register
func (o *PMC_Type) SetREGSC_BGBE(value uint8) {
	volatile.StoreUint8(&o.REGSC.Reg, volatile.LoadUint8(&o.REGSC.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetREGSC_BGBE() uint8 {
	return volatile.LoadUint8(&o.REGSC.Reg) & 0x1
}
func (o *PMC_Type) SetREGSC_REGONS(value uint8) {
	volatile.StoreUint8(&o.REGSC.Reg, volatile.LoadUint8(&o.REGSC.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetREGSC_REGONS() uint8 {
	return (volatile.LoadUint8(&o.REGSC.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetREGSC_ACKISO(value uint8) {
	volatile.StoreUint8(&o.REGSC.Reg, volatile.LoadUint8(&o.REGSC.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetREGSC_ACKISO() uint8 {
	return (volatile.LoadUint8(&o.REGSC.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetREGSC_BGEN(value uint8) {
	volatile.StoreUint8(&o.REGSC.Reg, volatile.LoadUint8(&o.REGSC.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetREGSC_BGEN() uint8 {
	return (volatile.LoadUint8(&o.REGSC.Reg) & 0x10) >> 4
}

// System Mode Controller
type SMC_Type struct {
	PMPROT   volatile.Register8 // 0x0
	PMCTRL   volatile.Register8 // 0x1
	STOPCTRL volatile.Register8 // 0x2
	PMSTAT   volatile.Register8 // 0x3
}

// SMC.PMPROT: Power Mode Protection register
func (o *SMC_Type) SetPMPROT_AVLLS(value uint8) {
	volatile.StoreUint8(&o.PMPROT.Reg, volatile.LoadUint8(&o.PMPROT.Reg)&^(0x2)|value<<1)
}
func (o *SMC_Type) GetPMPROT_AVLLS() uint8 {
	return (volatile.LoadUint8(&o.PMPROT.Reg) & 0x2) >> 1
}
func (o *SMC_Type) SetPMPROT_ALLS(value uint8) {
	volatile.StoreUint8(&o.PMPROT.Reg, volatile.LoadUint8(&o.PMPROT.Reg)&^(0x8)|value<<3)
}
func (o *SMC_Type) GetPMPROT_ALLS() uint8 {
	return (volatile.LoadUint8(&o.PMPROT.Reg) & 0x8) >> 3
}
func (o *SMC_Type) SetPMPROT_AVLP(value uint8) {
	volatile.StoreUint8(&o.PMPROT.Reg, volatile.LoadUint8(&o.PMPROT.Reg)&^(0x20)|value<<5)
}
func (o *SMC_Type) GetPMPROT_AVLP() uint8 {
	return (volatile.LoadUint8(&o.PMPROT.Reg) & 0x20) >> 5
}
func (o *SMC_Type) SetPMPROT_AHSRUN(value uint8) {
	volatile.StoreUint8(&o.PMPROT.Reg, volatile.LoadUint8(&o.PMPROT.Reg)&^(0x80)|value<<7)
}
func (o *SMC_Type) GetPMPROT_AHSRUN() uint8 {
	return (volatile.LoadUint8(&o.PMPROT.Reg) & 0x80) >> 7
}

// SMC.PMCTRL: Power Mode Control register
func (o *SMC_Type) SetPMCTRL_STOPM(value uint8) {
	volatile.StoreUint8(&o.PMCTRL.Reg, volatile.LoadUint8(&o.PMCTRL.Reg)&^(0x7)|value)
}
func (o *SMC_Type) GetPMCTRL_STOPM() uint8 {
	return volatile.LoadUint8(&o.PMCTRL.Reg) & 0x7
}
func (o *SMC_Type) SetPMCTRL_STOPA(value uint8) {
	volatile.StoreUint8(&o.PMCTRL.Reg, volatile.LoadUint8(&o.PMCTRL.Reg)&^(0x8)|value<<3)
}
func (o *SMC_Type) GetPMCTRL_STOPA() uint8 {
	return (volatile.LoadUint8(&o.PMCTRL.Reg) & 0x8) >> 3
}
func (o *SMC_Type) SetPMCTRL_RUNM(value uint8) {
	volatile.StoreUint8(&o.PMCTRL.Reg, volatile.LoadUint8(&o.PMCTRL.Reg)&^(0x60)|value<<5)
}
func (o *SMC_Type) GetPMCTRL_RUNM() uint8 {
	return (volatile.LoadUint8(&o.PMCTRL.Reg) & 0x60) >> 5
}

// SMC.STOPCTRL: Stop Control Register
func (o *SMC_Type) SetSTOPCTRL_LLSM(value uint8) {
	volatile.StoreUint8(&o.STOPCTRL.Reg, volatile.LoadUint8(&o.STOPCTRL.Reg)&^(0x7)|value)
}
func (o *SMC_Type) GetSTOPCTRL_LLSM() uint8 {
	return volatile.LoadUint8(&o.STOPCTRL.Reg) & 0x7
}
func (o *SMC_Type) SetSTOPCTRL_RAM2PO(value uint8) {
	volatile.StoreUint8(&o.STOPCTRL.Reg, volatile.LoadUint8(&o.STOPCTRL.Reg)&^(0x10)|value<<4)
}
func (o *SMC_Type) GetSTOPCTRL_RAM2PO() uint8 {
	return (volatile.LoadUint8(&o.STOPCTRL.Reg) & 0x10) >> 4
}
func (o *SMC_Type) SetSTOPCTRL_PORPO(value uint8) {
	volatile.StoreUint8(&o.STOPCTRL.Reg, volatile.LoadUint8(&o.STOPCTRL.Reg)&^(0x20)|value<<5)
}
func (o *SMC_Type) GetSTOPCTRL_PORPO() uint8 {
	return (volatile.LoadUint8(&o.STOPCTRL.Reg) & 0x20) >> 5
}
func (o *SMC_Type) SetSTOPCTRL_PSTOPO(value uint8) {
	volatile.StoreUint8(&o.STOPCTRL.Reg, volatile.LoadUint8(&o.STOPCTRL.Reg)&^(0xc0)|value<<6)
}
func (o *SMC_Type) GetSTOPCTRL_PSTOPO() uint8 {
	return (volatile.LoadUint8(&o.STOPCTRL.Reg) & 0xc0) >> 6
}

// SMC.PMSTAT: Power Mode Status register
func (o *SMC_Type) SetPMSTAT(value uint8) {
	volatile.StoreUint8(&o.PMSTAT.Reg, value)
}
func (o *SMC_Type) GetPMSTAT() uint8 {
	return volatile.LoadUint8(&o.PMSTAT.Reg)
}

// Reset Control Module
type RCM_Type struct {
	SRS0  volatile.Register8 // 0x0
	SRS1  volatile.Register8 // 0x1
	_     [2]byte
	RPFC  volatile.Register8 // 0x4
	RPFW  volatile.Register8 // 0x5
	_     byte
	MR    volatile.Register8 // 0x7
	SSRS0 volatile.Register8 // 0x8
	SSRS1 volatile.Register8 // 0x9
}

// RCM.SRS0: System Reset Status Register 0
func (o *RCM_Type) SetSRS0_WAKEUP(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x1)|value)
}
func (o *RCM_Type) GetSRS0_WAKEUP() uint8 {
	return volatile.LoadUint8(&o.SRS0.Reg) & 0x1
}
func (o *RCM_Type) SetSRS0_LVD(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x2)|value<<1)
}
func (o *RCM_Type) GetSRS0_LVD() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x2) >> 1
}
func (o *RCM_Type) SetSRS0_LOC(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x4)|value<<2)
}
func (o *RCM_Type) GetSRS0_LOC() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x4) >> 2
}
func (o *RCM_Type) SetSRS0_LOL(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x8)|value<<3)
}
func (o *RCM_Type) GetSRS0_LOL() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x8) >> 3
}
func (o *RCM_Type) SetSRS0_WDOG(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x20)|value<<5)
}
func (o *RCM_Type) GetSRS0_WDOG() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x20) >> 5
}
func (o *RCM_Type) SetSRS0_PIN(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x40)|value<<6)
}
func (o *RCM_Type) GetSRS0_PIN() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x40) >> 6
}
func (o *RCM_Type) SetSRS0_POR(value uint8) {
	volatile.StoreUint8(&o.SRS0.Reg, volatile.LoadUint8(&o.SRS0.Reg)&^(0x80)|value<<7)
}
func (o *RCM_Type) GetSRS0_POR() uint8 {
	return (volatile.LoadUint8(&o.SRS0.Reg) & 0x80) >> 7
}

// RCM.SRS1: System Reset Status Register 1
func (o *RCM_Type) SetSRS1_JTAG(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x1)|value)
}
func (o *RCM_Type) GetSRS1_JTAG() uint8 {
	return volatile.LoadUint8(&o.SRS1.Reg) & 0x1
}
func (o *RCM_Type) SetSRS1_LOCKUP(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x2)|value<<1)
}
func (o *RCM_Type) GetSRS1_LOCKUP() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x2) >> 1
}
func (o *RCM_Type) SetSRS1_SW(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x4)|value<<2)
}
func (o *RCM_Type) GetSRS1_SW() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x4) >> 2
}
func (o *RCM_Type) SetSRS1_MDM_AP(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x8)|value<<3)
}
func (o *RCM_Type) GetSRS1_MDM_AP() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x8) >> 3
}
func (o *RCM_Type) SetSRS1_EZPT(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x10)|value<<4)
}
func (o *RCM_Type) GetSRS1_EZPT() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x10) >> 4
}
func (o *RCM_Type) SetSRS1_SACKERR(value uint8) {
	volatile.StoreUint8(&o.SRS1.Reg, volatile.LoadUint8(&o.SRS1.Reg)&^(0x20)|value<<5)
}
func (o *RCM_Type) GetSRS1_SACKERR() uint8 {
	return (volatile.LoadUint8(&o.SRS1.Reg) & 0x20) >> 5
}

// RCM.RPFC: Reset Pin Filter Control register
func (o *RCM_Type) SetRPFC_RSTFLTSRW(value uint8) {
	volatile.StoreUint8(&o.RPFC.Reg, volatile.LoadUint8(&o.RPFC.Reg)&^(0x3)|value)
}
func (o *RCM_Type) GetRPFC_RSTFLTSRW() uint8 {
	return volatile.LoadUint8(&o.RPFC.Reg) & 0x3
}
func (o *RCM_Type) SetRPFC_RSTFLTSS(value uint8) {
	volatile.StoreUint8(&o.RPFC.Reg, volatile.LoadUint8(&o.RPFC.Reg)&^(0x4)|value<<2)
}
func (o *RCM_Type) GetRPFC_RSTFLTSS() uint8 {
	return (volatile.LoadUint8(&o.RPFC.Reg) & 0x4) >> 2
}

// RCM.RPFW: Reset Pin Filter Width register
func (o *RCM_Type) SetRPFW_RSTFLTSEL(value uint8) {
	volatile.StoreUint8(&o.RPFW.Reg, volatile.LoadUint8(&o.RPFW.Reg)&^(0x1f)|value)
}
func (o *RCM_Type) GetRPFW_RSTFLTSEL() uint8 {
	return volatile.LoadUint8(&o.RPFW.Reg) & 0x1f
}

// RCM.MR: Mode Register
func (o *RCM_Type) SetMR_EZP_MS(value uint8) {
	volatile.StoreUint8(&o.MR.Reg, volatile.LoadUint8(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *RCM_Type) GetMR_EZP_MS() uint8 {
	return (volatile.LoadUint8(&o.MR.Reg) & 0x2) >> 1
}

// RCM.SSRS0: Sticky System Reset Status Register 0
func (o *RCM_Type) SetSSRS0_SWAKEUP(value uint8) {
	volatile.StoreUint8(&o.SSRS0.Reg, volatile.LoadUint8(&o.SSRS0.Reg)&^(0x1)|value)
}
func (o *RCM_Type) GetSSRS0_SWAKEUP() uint8 {
	return volatile.LoadUint8(&o.SSRS0.Reg) & 0x1
}
func (o *RCM_Type) SetSSRS0_SLVD(value uint8) {
	volatile.StoreUint8(&o.SSRS0.Reg, volatile.LoadUint8(&o.SSRS0.Reg)&^(0x2)|value<<1)
}
func (o *RCM_Type) GetSSRS0_SLVD() uint8 {
	return (volatile.LoadUint8(&o.SSRS0.Reg) & 0x2) >> 1
}
func (o *RCM_Type) SetSSRS0_SLOC(value uint8) {
	volatile.StoreUint8(&o.SSRS0.Reg, volatile.LoadUint8(&o.SSRS0.Reg)&^(0x4)|value<<2)
}
func (o *RCM_Type) GetSSRS0_SLOC() uint8 {
	return (volatile.LoadUint8(&o.SSRS0.Reg) & 0x4) >> 2
}
func (o *RCM_Type) SetSSRS0_SLOL(value uint8) {
	volatile.StoreUint8(&o.SSRS0.Reg, volatile.LoadUint8(&o.SSRS0.Reg)&^(0x8)|value<<3)
}
func (o *RCM_Type) GetSSRS0_SLOL() uint8 {
	return (volatile.LoadUint8(&o.SSRS0.Reg) & 0x8) >> 3
}
func (o *RCM_Type) SetSSRS0_SWDOG(value uint8) {
	volatile.StoreUint8(&o.SSRS0.Reg, volatile.LoadUint8(&o.SSRS0.Reg)&^(0x20)|value<<5)
}
func (o *RCM_Type) GetSSRS0_SWDOG() uint8 {
	return (volatile.LoadUint8(&o.SSRS0.Reg) & 0x20) >> 5
}
func (o *RCM_Type) SetSSRS0_SPIN(value uint8) {
	volatile.StoreUint8(&o.SSRS0.Reg, volatile.LoadUint8(&o.SSRS0.Reg)&^(0x40)|value<<6)
}
func (o *RCM_Type) GetSSRS0_SPIN() uint8 {
	return (volatile.LoadUint8(&o.SSRS0.Reg) & 0x40) >> 6
}
func (o *RCM_Type) SetSSRS0_SPOR(value uint8) {
	volatile.StoreUint8(&o.SSRS0.Reg, volatile.LoadUint8(&o.SSRS0.Reg)&^(0x80)|value<<7)
}
func (o *RCM_Type) GetSSRS0_SPOR() uint8 {
	return (volatile.LoadUint8(&o.SSRS0.Reg) & 0x80) >> 7
}

// RCM.SSRS1: Sticky System Reset Status Register 1
func (o *RCM_Type) SetSSRS1_SJTAG(value uint8) {
	volatile.StoreUint8(&o.SSRS1.Reg, volatile.LoadUint8(&o.SSRS1.Reg)&^(0x1)|value)
}
func (o *RCM_Type) GetSSRS1_SJTAG() uint8 {
	return volatile.LoadUint8(&o.SSRS1.Reg) & 0x1
}
func (o *RCM_Type) SetSSRS1_SLOCKUP(value uint8) {
	volatile.StoreUint8(&o.SSRS1.Reg, volatile.LoadUint8(&o.SSRS1.Reg)&^(0x2)|value<<1)
}
func (o *RCM_Type) GetSSRS1_SLOCKUP() uint8 {
	return (volatile.LoadUint8(&o.SSRS1.Reg) & 0x2) >> 1
}
func (o *RCM_Type) SetSSRS1_SSW(value uint8) {
	volatile.StoreUint8(&o.SSRS1.Reg, volatile.LoadUint8(&o.SSRS1.Reg)&^(0x4)|value<<2)
}
func (o *RCM_Type) GetSSRS1_SSW() uint8 {
	return (volatile.LoadUint8(&o.SSRS1.Reg) & 0x4) >> 2
}
func (o *RCM_Type) SetSSRS1_SMDM_AP(value uint8) {
	volatile.StoreUint8(&o.SSRS1.Reg, volatile.LoadUint8(&o.SSRS1.Reg)&^(0x8)|value<<3)
}
func (o *RCM_Type) GetSSRS1_SMDM_AP() uint8 {
	return (volatile.LoadUint8(&o.SSRS1.Reg) & 0x8) >> 3
}
func (o *RCM_Type) SetSSRS1_SEZPT(value uint8) {
	volatile.StoreUint8(&o.SSRS1.Reg, volatile.LoadUint8(&o.SSRS1.Reg)&^(0x10)|value<<4)
}
func (o *RCM_Type) GetSSRS1_SEZPT() uint8 {
	return (volatile.LoadUint8(&o.SSRS1.Reg) & 0x10) >> 4
}
func (o *RCM_Type) SetSSRS1_SSACKERR(value uint8) {
	volatile.StoreUint8(&o.SSRS1.Reg, volatile.LoadUint8(&o.SSRS1.Reg)&^(0x20)|value<<5)
}
func (o *RCM_Type) GetSSRS1_SSACKERR() uint8 {
	return (volatile.LoadUint8(&o.SSRS1.Reg) & 0x20) >> 5
}

// Random Number Generator Accelerator
type RNG_Type struct {
	CR volatile.Register32 // 0x0
	SR volatile.Register32 // 0x4
	ER volatile.Register32 // 0x8
	OR volatile.Register32 // 0xC
}

// RNG.CR: RNGA Control Register
func (o *RNG_Type) SetCR_GO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetCR_GO() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RNG_Type) SetCR_HA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RNG_Type) GetCR_HA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RNG_Type) SetCR_INTM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetCR_INTM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetCR_CLRI(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RNG_Type) GetCR_CLRI() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RNG_Type) SetCR_SLP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *RNG_Type) GetCR_SLP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}

// RNG.SR: RNGA Status Register
func (o *RNG_Type) SetSR_SECV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetSR_SECV() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RNG_Type) SetSR_LRS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RNG_Type) GetSR_LRS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RNG_Type) SetSR_ORU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetSR_ORU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetSR_ERRI(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *RNG_Type) GetSR_ERRI() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *RNG_Type) SetSR_SLP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *RNG_Type) GetSR_SLP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *RNG_Type) SetSR_OREG_LVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xff00)|value<<8)
}
func (o *RNG_Type) GetSR_OREG_LVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xff00) >> 8
}
func (o *RNG_Type) SetSR_OREG_SIZE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xff0000)|value<<16)
}
func (o *RNG_Type) GetSR_OREG_SIZE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xff0000) >> 16
}

// RNG.ER: RNGA Entropy Register
func (o *RNG_Type) SetER(value uint32) {
	volatile.StoreUint32(&o.ER.Reg, value)
}
func (o *RNG_Type) GetER() uint32 {
	return volatile.LoadUint32(&o.ER.Reg)
}

// RNG.OR: RNGA Output Register
func (o *RNG_Type) SetOR(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, value)
}
func (o *RNG_Type) GetOR() uint32 {
	return volatile.LoadUint32(&o.OR.Reg)
}

// USB HS/FS/LS OTG Controller
type USBHS_Type struct {
	ID            volatile.Register32 // 0x0
	HWGENERAL     volatile.Register32 // 0x4
	HWHOST        volatile.Register32 // 0x8
	HWDEVICE      volatile.Register32 // 0xC
	HWTXBUF       volatile.Register32 // 0x10
	HWRXBUF       volatile.Register32 // 0x14
	_             [104]byte
	GPTIMER0LD    volatile.Register32 // 0x80
	GPTIMER0CTL   volatile.Register32 // 0x84
	GPTIMER1LD    volatile.Register32 // 0x88
	GPTIMER1CTL   volatile.Register32 // 0x8C
	USB_SBUSCFG   volatile.Register32 // 0x90
	_             [108]byte
	HCIVERSION    volatile.Register32 // 0x100
	HCSPARAMS     volatile.Register32 // 0x104
	HCCPARAMS     volatile.Register32 // 0x108
	_             [22]byte
	DCIVERSION    volatile.Register16 // 0x122
	DCCPARAMS     volatile.Register32 // 0x124
	_             [24]byte
	USBCMD        volatile.Register32 // 0x140
	USBSTS        volatile.Register32 // 0x144
	USBINTR       volatile.Register32 // 0x148
	FRINDEX       volatile.Register32 // 0x14C
	_             [4]byte
	DEVICEADDR    volatile.Register32 // 0x154
	ASYNCLISTADDR volatile.Register32 // 0x158
	TTCTRL        volatile.Register32 // 0x15C
	BURSTSIZE     volatile.Register32 // 0x160
	TXFILLTUNING  volatile.Register32 // 0x164
	_             [16]byte
	ENDPTNAK      volatile.Register32 // 0x178
	ENDPTNAKEN    volatile.Register32 // 0x17C
	CONFIGFLAG    volatile.Register32 // 0x180
	PORTSC1       volatile.Register32 // 0x184
	_             [28]byte
	OTGSC         volatile.Register32 // 0x1A4
	USBMODE       volatile.Register32 // 0x1A8
	EPSETUPSR     volatile.Register32 // 0x1AC
	EPPRIME       volatile.Register32 // 0x1B0
	EPFLUSH       volatile.Register32 // 0x1B4
	EPSR          volatile.Register32 // 0x1B8
	EPCOMPLETE    volatile.Register32 // 0x1BC
	EPCR0         volatile.Register32 // 0x1C0
	EPCR1         volatile.Register32 // 0x1C4
	EPCR2         volatile.Register32 // 0x1C8
	EPCR3         volatile.Register32 // 0x1CC
	EPCR4         volatile.Register32 // 0x1D0
	EPCR5         volatile.Register32 // 0x1D4
	EPCR6         volatile.Register32 // 0x1D8
	EPCR7         volatile.Register32 // 0x1DC
	_             [32]byte
	USBGENCTRL    volatile.Register32 // 0x200
}

// USBHS.ID: Identification Register
func (o *USBHS_Type) SetID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0x3f)|value)
}
func (o *USBHS_Type) GetID() uint32 {
	return volatile.LoadUint32(&o.ID.Reg) & 0x3f
}
func (o *USBHS_Type) SetID_NID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0x3f00)|value<<8)
}
func (o *USBHS_Type) GetID_NID() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0x3f00) >> 8
}
func (o *USBHS_Type) SetID_TAG(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0x1f0000)|value<<16)
}
func (o *USBHS_Type) GetID_TAG() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0x1f0000) >> 16
}
func (o *USBHS_Type) SetID_REVISION(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0x1e00000)|value<<21)
}
func (o *USBHS_Type) GetID_REVISION() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0x1e00000) >> 21
}
func (o *USBHS_Type) SetID_VERSION(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0x1e000000)|value<<25)
}
func (o *USBHS_Type) GetID_VERSION() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0x1e000000) >> 25
}
func (o *USBHS_Type) SetID_VERSIONID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xe0000000)|value<<29)
}
func (o *USBHS_Type) GetID_VERSIONID() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xe0000000) >> 29
}

// USBHS.HWGENERAL: General Hardware Parameters Register
func (o *USBHS_Type) SetHWGENERAL_PHYW(value uint32) {
	volatile.StoreUint32(&o.HWGENERAL.Reg, volatile.LoadUint32(&o.HWGENERAL.Reg)&^(0x30)|value<<4)
}
func (o *USBHS_Type) GetHWGENERAL_PHYW() uint32 {
	return (volatile.LoadUint32(&o.HWGENERAL.Reg) & 0x30) >> 4
}
func (o *USBHS_Type) SetHWGENERAL_PHYM(value uint32) {
	volatile.StoreUint32(&o.HWGENERAL.Reg, volatile.LoadUint32(&o.HWGENERAL.Reg)&^(0x1c0)|value<<6)
}
func (o *USBHS_Type) GetHWGENERAL_PHYM() uint32 {
	return (volatile.LoadUint32(&o.HWGENERAL.Reg) & 0x1c0) >> 6
}
func (o *USBHS_Type) SetHWGENERAL_SM(value uint32) {
	volatile.StoreUint32(&o.HWGENERAL.Reg, volatile.LoadUint32(&o.HWGENERAL.Reg)&^(0x600)|value<<9)
}
func (o *USBHS_Type) GetHWGENERAL_SM() uint32 {
	return (volatile.LoadUint32(&o.HWGENERAL.Reg) & 0x600) >> 9
}

// USBHS.HWHOST: Host Hardware Parameters Register
func (o *USBHS_Type) SetHWHOST_HC(value uint32) {
	volatile.StoreUint32(&o.HWHOST.Reg, volatile.LoadUint32(&o.HWHOST.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHWHOST_HC() uint32 {
	return volatile.LoadUint32(&o.HWHOST.Reg) & 0x1
}
func (o *USBHS_Type) SetHWHOST_NPORT(value uint32) {
	volatile.StoreUint32(&o.HWHOST.Reg, volatile.LoadUint32(&o.HWHOST.Reg)&^(0xe)|value<<1)
}
func (o *USBHS_Type) GetHWHOST_NPORT() uint32 {
	return (volatile.LoadUint32(&o.HWHOST.Reg) & 0xe) >> 1
}
func (o *USBHS_Type) SetHWHOST_TTASY(value uint32) {
	volatile.StoreUint32(&o.HWHOST.Reg, volatile.LoadUint32(&o.HWHOST.Reg)&^(0xff0000)|value<<16)
}
func (o *USBHS_Type) GetHWHOST_TTASY() uint32 {
	return (volatile.LoadUint32(&o.HWHOST.Reg) & 0xff0000) >> 16
}
func (o *USBHS_Type) SetHWHOST_TTPER(value uint32) {
	volatile.StoreUint32(&o.HWHOST.Reg, volatile.LoadUint32(&o.HWHOST.Reg)&^(0xff000000)|value<<24)
}
func (o *USBHS_Type) GetHWHOST_TTPER() uint32 {
	return (volatile.LoadUint32(&o.HWHOST.Reg) & 0xff000000) >> 24
}

// USBHS.HWDEVICE: Device Hardware Parameters Register
func (o *USBHS_Type) SetHWDEVICE_DC(value uint32) {
	volatile.StoreUint32(&o.HWDEVICE.Reg, volatile.LoadUint32(&o.HWDEVICE.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHWDEVICE_DC() uint32 {
	return volatile.LoadUint32(&o.HWDEVICE.Reg) & 0x1
}
func (o *USBHS_Type) SetHWDEVICE_DEVEP(value uint32) {
	volatile.StoreUint32(&o.HWDEVICE.Reg, volatile.LoadUint32(&o.HWDEVICE.Reg)&^(0x3e)|value<<1)
}
func (o *USBHS_Type) GetHWDEVICE_DEVEP() uint32 {
	return (volatile.LoadUint32(&o.HWDEVICE.Reg) & 0x3e) >> 1
}

// USBHS.HWTXBUF: Transmit Buffer Hardware Parameters Register
func (o *USBHS_Type) SetHWTXBUF_TXBURST(value uint32) {
	volatile.StoreUint32(&o.HWTXBUF.Reg, volatile.LoadUint32(&o.HWTXBUF.Reg)&^(0xff)|value)
}
func (o *USBHS_Type) GetHWTXBUF_TXBURST() uint32 {
	return volatile.LoadUint32(&o.HWTXBUF.Reg) & 0xff
}
func (o *USBHS_Type) SetHWTXBUF_TXADD(value uint32) {
	volatile.StoreUint32(&o.HWTXBUF.Reg, volatile.LoadUint32(&o.HWTXBUF.Reg)&^(0xff00)|value<<8)
}
func (o *USBHS_Type) GetHWTXBUF_TXADD() uint32 {
	return (volatile.LoadUint32(&o.HWTXBUF.Reg) & 0xff00) >> 8
}
func (o *USBHS_Type) SetHWTXBUF_TXCHANADD(value uint32) {
	volatile.StoreUint32(&o.HWTXBUF.Reg, volatile.LoadUint32(&o.HWTXBUF.Reg)&^(0xff0000)|value<<16)
}
func (o *USBHS_Type) GetHWTXBUF_TXCHANADD() uint32 {
	return (volatile.LoadUint32(&o.HWTXBUF.Reg) & 0xff0000) >> 16
}
func (o *USBHS_Type) SetHWTXBUF_TXLC(value uint32) {
	volatile.StoreUint32(&o.HWTXBUF.Reg, volatile.LoadUint32(&o.HWTXBUF.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetHWTXBUF_TXLC() uint32 {
	return (volatile.LoadUint32(&o.HWTXBUF.Reg) & 0x80000000) >> 31
}

// USBHS.HWRXBUF: Receive Buffer Hardware Parameters Register
func (o *USBHS_Type) SetHWRXBUF_RXBURST(value uint32) {
	volatile.StoreUint32(&o.HWRXBUF.Reg, volatile.LoadUint32(&o.HWRXBUF.Reg)&^(0xff)|value)
}
func (o *USBHS_Type) GetHWRXBUF_RXBURST() uint32 {
	return volatile.LoadUint32(&o.HWRXBUF.Reg) & 0xff
}
func (o *USBHS_Type) SetHWRXBUF_RXADD(value uint32) {
	volatile.StoreUint32(&o.HWRXBUF.Reg, volatile.LoadUint32(&o.HWRXBUF.Reg)&^(0xff00)|value<<8)
}
func (o *USBHS_Type) GetHWRXBUF_RXADD() uint32 {
	return (volatile.LoadUint32(&o.HWRXBUF.Reg) & 0xff00) >> 8
}

// USBHS.GPTIMER0LD: General Purpose Timer n Load Register
func (o *USBHS_Type) SetGPTIMER0LD_GPTLD(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0LD.Reg, volatile.LoadUint32(&o.GPTIMER0LD.Reg)&^(0xffffff)|value)
}
func (o *USBHS_Type) GetGPTIMER0LD_GPTLD() uint32 {
	return volatile.LoadUint32(&o.GPTIMER0LD.Reg) & 0xffffff
}

// USBHS.GPTIMER0CTL: General Purpose Timer n Control Register
func (o *USBHS_Type) SetGPTIMER0CTL_GPTCNT(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0CTL.Reg, volatile.LoadUint32(&o.GPTIMER0CTL.Reg)&^(0xffffff)|value)
}
func (o *USBHS_Type) GetGPTIMER0CTL_GPTCNT() uint32 {
	return volatile.LoadUint32(&o.GPTIMER0CTL.Reg) & 0xffffff
}
func (o *USBHS_Type) SetGPTIMER0CTL_MODE(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0CTL.Reg, volatile.LoadUint32(&o.GPTIMER0CTL.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHS_Type) GetGPTIMER0CTL_MODE() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER0CTL.Reg) & 0x1000000) >> 24
}
func (o *USBHS_Type) SetGPTIMER0CTL_RST(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0CTL.Reg, volatile.LoadUint32(&o.GPTIMER0CTL.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetGPTIMER0CTL_RST() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER0CTL.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetGPTIMER0CTL_RUN(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0CTL.Reg, volatile.LoadUint32(&o.GPTIMER0CTL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetGPTIMER0CTL_RUN() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER0CTL.Reg) & 0x80000000) >> 31
}

// USBHS.GPTIMER1LD: General Purpose Timer n Load Register
func (o *USBHS_Type) SetGPTIMER1LD_GPTLD(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1LD.Reg, volatile.LoadUint32(&o.GPTIMER1LD.Reg)&^(0xffffff)|value)
}
func (o *USBHS_Type) GetGPTIMER1LD_GPTLD() uint32 {
	return volatile.LoadUint32(&o.GPTIMER1LD.Reg) & 0xffffff
}

// USBHS.GPTIMER1CTL: General Purpose Timer n Control Register
func (o *USBHS_Type) SetGPTIMER1CTL_GPTCNT(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1CTL.Reg, volatile.LoadUint32(&o.GPTIMER1CTL.Reg)&^(0xffffff)|value)
}
func (o *USBHS_Type) GetGPTIMER1CTL_GPTCNT() uint32 {
	return volatile.LoadUint32(&o.GPTIMER1CTL.Reg) & 0xffffff
}
func (o *USBHS_Type) SetGPTIMER1CTL_MODE(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1CTL.Reg, volatile.LoadUint32(&o.GPTIMER1CTL.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHS_Type) GetGPTIMER1CTL_MODE() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER1CTL.Reg) & 0x1000000) >> 24
}
func (o *USBHS_Type) SetGPTIMER1CTL_RST(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1CTL.Reg, volatile.LoadUint32(&o.GPTIMER1CTL.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetGPTIMER1CTL_RST() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER1CTL.Reg) & 0x40000000) >> 30
}
func (o *USBHS_Type) SetGPTIMER1CTL_RUN(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1CTL.Reg, volatile.LoadUint32(&o.GPTIMER1CTL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetGPTIMER1CTL_RUN() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER1CTL.Reg) & 0x80000000) >> 31
}

// USBHS.USB_SBUSCFG: System Bus Interface Configuration Register
func (o *USBHS_Type) SetUSB_SBUSCFG_BURSTMODE(value uint32) {
	volatile.StoreUint32(&o.USB_SBUSCFG.Reg, volatile.LoadUint32(&o.USB_SBUSCFG.Reg)&^(0x7)|value)
}
func (o *USBHS_Type) GetUSB_SBUSCFG_BURSTMODE() uint32 {
	return volatile.LoadUint32(&o.USB_SBUSCFG.Reg) & 0x7
}

// USBHS.HCIVERSION: Host Controller Interface Version and Capability Registers Length Register
func (o *USBHS_Type) SetHCIVERSION_CAPLENGTH(value uint32) {
	volatile.StoreUint32(&o.HCIVERSION.Reg, volatile.LoadUint32(&o.HCIVERSION.Reg)&^(0xff)|value)
}
func (o *USBHS_Type) GetHCIVERSION_CAPLENGTH() uint32 {
	return volatile.LoadUint32(&o.HCIVERSION.Reg) & 0xff
}
func (o *USBHS_Type) SetHCIVERSION(value uint32) {
	volatile.StoreUint32(&o.HCIVERSION.Reg, volatile.LoadUint32(&o.HCIVERSION.Reg)&^(0xffff0000)|value<<16)
}
func (o *USBHS_Type) GetHCIVERSION() uint32 {
	return (volatile.LoadUint32(&o.HCIVERSION.Reg) & 0xffff0000) >> 16
}

// USBHS.HCSPARAMS: Host Controller Structural Parameters Register
func (o *USBHS_Type) SetHCSPARAMS_N_PORTS(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetHCSPARAMS_N_PORTS() uint32 {
	return volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf
}
func (o *USBHS_Type) SetHCSPARAMS_PPC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetHCSPARAMS_PPC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetHCSPARAMS_N_PCC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf00)|value<<8)
}
func (o *USBHS_Type) GetHCSPARAMS_N_PCC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf00) >> 8
}
func (o *USBHS_Type) SetHCSPARAMS_N_CC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf000)|value<<12)
}
func (o *USBHS_Type) GetHCSPARAMS_N_CC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf000) >> 12
}
func (o *USBHS_Type) SetHCSPARAMS_PI(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetHCSPARAMS_PI() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetHCSPARAMS_N_PTT(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf00000)|value<<20)
}
func (o *USBHS_Type) GetHCSPARAMS_N_PTT() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf00000) >> 20
}
func (o *USBHS_Type) SetHCSPARAMS_N_TT(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf000000)|value<<24)
}
func (o *USBHS_Type) GetHCSPARAMS_N_TT() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf000000) >> 24
}

// USBHS.HCCPARAMS: Host Controller Capability Parameters Register
func (o *USBHS_Type) SetHCCPARAMS_ADC(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHCCPARAMS_ADC() uint32 {
	return volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x1
}
func (o *USBHS_Type) SetHCCPARAMS_PFL(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetHCCPARAMS_PFL() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetHCCPARAMS_ASP(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetHCCPARAMS_ASP() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetHCCPARAMS_IST(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xf0)|value<<4)
}
func (o *USBHS_Type) GetHCCPARAMS_IST() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xf0) >> 4
}
func (o *USBHS_Type) SetHCCPARAMS_EECP(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xff00)|value<<8)
}
func (o *USBHS_Type) GetHCCPARAMS_EECP() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xff00) >> 8
}

// USBHS.DCIVERSION: Device Controller Interface Version
func (o *USBHS_Type) SetDCIVERSION(value uint16) {
	volatile.StoreUint16(&o.DCIVERSION.Reg, value)
}
func (o *USBHS_Type) GetDCIVERSION() uint16 {
	return volatile.LoadUint16(&o.DCIVERSION.Reg)
}

// USBHS.DCCPARAMS: Device Controller Capability Parameters
func (o *USBHS_Type) SetDCCPARAMS_DEN(value uint32) {
	volatile.StoreUint32(&o.DCCPARAMS.Reg, volatile.LoadUint32(&o.DCCPARAMS.Reg)&^(0x1f)|value)
}
func (o *USBHS_Type) GetDCCPARAMS_DEN() uint32 {
	return volatile.LoadUint32(&o.DCCPARAMS.Reg) & 0x1f
}
func (o *USBHS_Type) SetDCCPARAMS_DC(value uint32) {
	volatile.StoreUint32(&o.DCCPARAMS.Reg, volatile.LoadUint32(&o.DCCPARAMS.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDCCPARAMS_DC() uint32 {
	return (volatile.LoadUint32(&o.DCCPARAMS.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDCCPARAMS_HC(value uint32) {
	volatile.StoreUint32(&o.DCCPARAMS.Reg, volatile.LoadUint32(&o.DCCPARAMS.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetDCCPARAMS_HC() uint32 {
	return (volatile.LoadUint32(&o.DCCPARAMS.Reg) & 0x100) >> 8
}

// USBHS.USBCMD: USB Command Register
func (o *USBHS_Type) SetUSBCMD_RS(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetUSBCMD_RS() uint32 {
	return volatile.LoadUint32(&o.USBCMD.Reg) & 0x1
}
func (o *USBHS_Type) SetUSBCMD_RST(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetUSBCMD_RST() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetUSBCMD_FS(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetUSBCMD_FS() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetUSBCMD_PSE(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetUSBCMD_PSE() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetUSBCMD_ASE(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetUSBCMD_ASE() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetUSBCMD_IAA(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetUSBCMD_IAA() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetUSBCMD_ASP(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x300)|value<<8)
}
func (o *USBHS_Type) GetUSBCMD_ASP() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x300) >> 8
}
func (o *USBHS_Type) SetUSBCMD_ASPE(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetUSBCMD_ASPE() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetUSBCMD_SUTW(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetUSBCMD_SUTW() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetUSBCMD_ATDTW(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetUSBCMD_ATDTW() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetUSBCMD_FS2(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetUSBCMD_FS2() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetUSBCMD_ITC(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0xff0000)|value<<16)
}
func (o *USBHS_Type) GetUSBCMD_ITC() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0xff0000) >> 16
}

// USBHS.USBSTS: USB Status Register
func (o *USBHS_Type) SetUSBSTS_UI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetUSBSTS_UI() uint32 {
	return volatile.LoadUint32(&o.USBSTS.Reg) & 0x1
}
func (o *USBHS_Type) SetUSBSTS_UEI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetUSBSTS_UEI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetUSBSTS_PCI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetUSBSTS_PCI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetUSBSTS_FRI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetUSBSTS_FRI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetUSBSTS_SEI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetUSBSTS_SEI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetUSBSTS_AAI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetUSBSTS_AAI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetUSBSTS_URI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetUSBSTS_URI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetUSBSTS_SRI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetUSBSTS_SRI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetUSBSTS_SLI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetUSBSTS_SLI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetUSBSTS_HCH(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetUSBSTS_HCH() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetUSBSTS_RCL(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetUSBSTS_RCL() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetUSBSTS_PS(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetUSBSTS_PS() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetUSBSTS_AS(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetUSBSTS_AS() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetUSBSTS_NAKI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetUSBSTS_NAKI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetUSBSTS_UAI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetUSBSTS_UAI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetUSBSTS_UPI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetUSBSTS_UPI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetUSBSTS_TI0(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHS_Type) GetUSBSTS_TI0() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x1000000) >> 24
}
func (o *USBHS_Type) SetUSBSTS_TI1(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetUSBSTS_TI1() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x2000000) >> 25
}

// USBHS.USBINTR: USB Interrupt Enable Register
func (o *USBHS_Type) SetUSBINTR_UE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetUSBINTR_UE() uint32 {
	return volatile.LoadUint32(&o.USBINTR.Reg) & 0x1
}
func (o *USBHS_Type) SetUSBINTR_UEE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetUSBINTR_UEE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetUSBINTR_PCE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetUSBINTR_PCE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetUSBINTR_FRE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetUSBINTR_FRE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetUSBINTR_SEE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetUSBINTR_SEE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetUSBINTR_AAE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetUSBINTR_AAE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetUSBINTR_URE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetUSBINTR_URE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetUSBINTR_SRE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetUSBINTR_SRE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetUSBINTR_SLE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetUSBINTR_SLE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetUSBINTR_NAKE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetUSBINTR_NAKE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetUSBINTR_UAIE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetUSBINTR_UAIE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetUSBINTR_UPIE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetUSBINTR_UPIE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetUSBINTR_TIE0(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHS_Type) GetUSBINTR_TIE0() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x1000000) >> 24
}
func (o *USBHS_Type) SetUSBINTR_TIE1(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetUSBINTR_TIE1() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x2000000) >> 25
}

// USBHS.FRINDEX: Frame Index Register
func (o *USBHS_Type) SetFRINDEX(value uint32) {
	volatile.StoreUint32(&o.FRINDEX.Reg, volatile.LoadUint32(&o.FRINDEX.Reg)&^(0x3fff)|value)
}
func (o *USBHS_Type) GetFRINDEX() uint32 {
	return volatile.LoadUint32(&o.FRINDEX.Reg) & 0x3fff
}
func (o *USBHS_Type) SetFRINDEX_Reerved(value uint32) {
	volatile.StoreUint32(&o.FRINDEX.Reg, volatile.LoadUint32(&o.FRINDEX.Reg)&^(0xffffc000)|value<<14)
}
func (o *USBHS_Type) GetFRINDEX_Reerved() uint32 {
	return (volatile.LoadUint32(&o.FRINDEX.Reg) & 0xffffc000) >> 14
}

// USBHS.DEVICEADDR: Device Address Register
func (o *USBHS_Type) SetDEVICEADDR_USBADRA(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHS_Type) GetDEVICEADDR_USBADRA() uint32 {
	return (volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0x1000000) >> 24
}
func (o *USBHS_Type) SetDEVICEADDR_USBADR(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0xfe000000)|value<<25)
}
func (o *USBHS_Type) GetDEVICEADDR_USBADR() uint32 {
	return (volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0xfe000000) >> 25
}

// USBHS.ASYNCLISTADDR: Current Asynchronous List Address Register
func (o *USBHS_Type) SetASYNCLISTADDR_ASYBASE(value uint32) {
	volatile.StoreUint32(&o.ASYNCLISTADDR.Reg, volatile.LoadUint32(&o.ASYNCLISTADDR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *USBHS_Type) GetASYNCLISTADDR_ASYBASE() uint32 {
	return (volatile.LoadUint32(&o.ASYNCLISTADDR.Reg) & 0xffffffe0) >> 5
}

// USBHS.TTCTRL: Host TT Asynchronous Buffer Control
func (o *USBHS_Type) SetTTCTRL_TTHA(value uint32) {
	volatile.StoreUint32(&o.TTCTRL.Reg, volatile.LoadUint32(&o.TTCTRL.Reg)&^(0x7f000000)|value<<24)
}
func (o *USBHS_Type) GetTTCTRL_TTHA() uint32 {
	return (volatile.LoadUint32(&o.TTCTRL.Reg) & 0x7f000000) >> 24
}
func (o *USBHS_Type) SetTTCTRL_Reerved(value uint32) {
	volatile.StoreUint32(&o.TTCTRL.Reg, volatile.LoadUint32(&o.TTCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBHS_Type) GetTTCTRL_Reerved() uint32 {
	return (volatile.LoadUint32(&o.TTCTRL.Reg) & 0x80000000) >> 31
}

// USBHS.BURSTSIZE: Master Interface Data Burst Size Register
func (o *USBHS_Type) SetBURSTSIZE_RXPBURST(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0xff)|value)
}
func (o *USBHS_Type) GetBURSTSIZE_RXPBURST() uint32 {
	return volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0xff
}
func (o *USBHS_Type) SetBURSTSIZE_TXPBURST(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0xff00)|value<<8)
}
func (o *USBHS_Type) GetBURSTSIZE_TXPBURST() uint32 {
	return (volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0xff00) >> 8
}

// USBHS.TXFILLTUNING: Transmit FIFO Tuning Control Register
func (o *USBHS_Type) SetTXFILLTUNING_TXSCHOH(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0x7f)|value)
}
func (o *USBHS_Type) GetTXFILLTUNING_TXSCHOH() uint32 {
	return volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0x7f
}
func (o *USBHS_Type) SetTXFILLTUNING_TXSCHHEALTH(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0x1f00)|value<<8)
}
func (o *USBHS_Type) GetTXFILLTUNING_TXSCHHEALTH() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0x1f00) >> 8
}
func (o *USBHS_Type) SetTXFILLTUNING_TXFIFOTHRES(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0x3f0000)|value<<16)
}
func (o *USBHS_Type) GetTXFILLTUNING_TXFIFOTHRES() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0x3f0000) >> 16
}

// USBHS.ENDPTNAK: Endpoint NAK Register
func (o *USBHS_Type) SetENDPTNAK_EPRN(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetENDPTNAK_EPRN() uint32 {
	return volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0xf
}
func (o *USBHS_Type) SetENDPTNAK_EPTN(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0xf0000)|value<<16)
}
func (o *USBHS_Type) GetENDPTNAK_EPTN() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0xf0000) >> 16
}

// USBHS.ENDPTNAKEN: Endpoint NAK Enable Register
func (o *USBHS_Type) SetENDPTNAKEN_EPRNE(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetENDPTNAKEN_EPRNE() uint32 {
	return volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0xf
}
func (o *USBHS_Type) SetENDPTNAKEN_EPTNE(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0xf0000)|value<<16)
}
func (o *USBHS_Type) GetENDPTNAKEN_EPTNE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0xf0000) >> 16
}

// USBHS.PORTSC1: Port Status and Control Registers
func (o *USBHS_Type) SetPORTSC1_CCS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetPORTSC1_CCS() uint32 {
	return volatile.LoadUint32(&o.PORTSC1.Reg) & 0x1
}
func (o *USBHS_Type) SetPORTSC1_CSC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetPORTSC1_CSC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetPORTSC1_PE(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetPORTSC1_PE() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetPORTSC1_PEC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetPORTSC1_PEC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetPORTSC1_OCA(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetPORTSC1_OCA() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetPORTSC1_OCC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPORTSC1_OCC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPORTSC1_FPR(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPORTSC1_FPR() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPORTSC1_SUSP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPORTSC1_SUSP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPORTSC1_PR(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPORTSC1_PR() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPORTSC1_HSP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPORTSC1_HSP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPORTSC1_LS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xc00)|value<<10)
}
func (o *USBHS_Type) GetPORTSC1_LS() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xc00) >> 10
}
func (o *USBHS_Type) SetPORTSC1_PP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPORTSC1_PP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPORTSC1_PO(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPORTSC1_PO() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPORTSC1_PIC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xc000)|value<<14)
}
func (o *USBHS_Type) GetPORTSC1_PIC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xc000) >> 14
}
func (o *USBHS_Type) SetPORTSC1_PTC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xf0000)|value<<16)
}
func (o *USBHS_Type) GetPORTSC1_PTC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xf0000) >> 16
}
func (o *USBHS_Type) SetPORTSC1_WKCN(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetPORTSC1_WKCN() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x100000) >> 20
}
func (o *USBHS_Type) SetPORTSC1_WKDS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetPORTSC1_WKDS() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetPORTSC1_WKOC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetPORTSC1_WKOC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetPORTSC1_PHCD(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetPORTSC1_PHCD() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x800000) >> 23
}
func (o *USBHS_Type) SetPORTSC1_PFSC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHS_Type) GetPORTSC1_PFSC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x1000000) >> 24
}
func (o *USBHS_Type) SetPORTSC1_PTS2(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetPORTSC1_PTS2() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetPORTSC1_PSPD(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xc000000)|value<<26)
}
func (o *USBHS_Type) GetPORTSC1_PSPD() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xc000000) >> 26
}
func (o *USBHS_Type) SetPORTSC1_PTS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xc0000000)|value<<30)
}
func (o *USBHS_Type) GetPORTSC1_PTS() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xc0000000) >> 30
}

// USBHS.OTGSC: On-the-Go Status and Control Register
func (o *USBHS_Type) SetOTGSC_VD(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetOTGSC_VD() uint32 {
	return volatile.LoadUint32(&o.OTGSC.Reg) & 0x1
}
func (o *USBHS_Type) SetOTGSC_VC(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetOTGSC_VC() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetOTGSC_HAAR(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetOTGSC_HAAR() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetOTGSC_OT(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetOTGSC_OT() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetOTGSC_DP(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetOTGSC_DP() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetOTGSC_IDPU(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetOTGSC_IDPU() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetOTGSC_HABA(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetOTGSC_HABA() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetOTGSC_ID(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetOTGSC_ID() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetOTGSC_AVV(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetOTGSC_AVV() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetOTGSC_ASV(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetOTGSC_ASV() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetOTGSC_BSV(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetOTGSC_BSV() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetOTGSC_BSE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetOTGSC_BSE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetOTGSC_MST(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetOTGSC_MST() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetOTGSC_DPS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetOTGSC_DPS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetOTGSC_IDIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetOTGSC_IDIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetOTGSC_AVVIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetOTGSC_AVVIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetOTGSC_ASVIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x40000)|value<<18)
}
func (o *USBHS_Type) GetOTGSC_ASVIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x40000) >> 18
}
func (o *USBHS_Type) SetOTGSC_BSVIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x80000)|value<<19)
}
func (o *USBHS_Type) GetOTGSC_BSVIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x80000) >> 19
}
func (o *USBHS_Type) SetOTGSC_BSEIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetOTGSC_BSEIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x100000) >> 20
}
func (o *USBHS_Type) SetOTGSC_MSS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetOTGSC_MSS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetOTGSC_DPIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetOTGSC_DPIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetOTGSC_IDIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHS_Type) GetOTGSC_IDIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x1000000) >> 24
}
func (o *USBHS_Type) SetOTGSC_AVVIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHS_Type) GetOTGSC_AVVIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x2000000) >> 25
}
func (o *USBHS_Type) SetOTGSC_ASVIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x4000000)|value<<26)
}
func (o *USBHS_Type) GetOTGSC_ASVIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x4000000) >> 26
}
func (o *USBHS_Type) SetOTGSC_BSVIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x8000000)|value<<27)
}
func (o *USBHS_Type) GetOTGSC_BSVIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x8000000) >> 27
}
func (o *USBHS_Type) SetOTGSC_BSEIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x10000000)|value<<28)
}
func (o *USBHS_Type) GetOTGSC_BSEIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x10000000) >> 28
}
func (o *USBHS_Type) SetOTGSC_MSE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x20000000)|value<<29)
}
func (o *USBHS_Type) GetOTGSC_MSE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x20000000) >> 29
}
func (o *USBHS_Type) SetOTGSC_DPIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x40000000)|value<<30)
}
func (o *USBHS_Type) GetOTGSC_DPIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x40000000) >> 30
}

// USBHS.USBMODE: USB Mode Register
func (o *USBHS_Type) SetUSBMODE_CM(value uint32) {
	volatile.StoreUint32(&o.USBMODE.Reg, volatile.LoadUint32(&o.USBMODE.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetUSBMODE_CM() uint32 {
	return volatile.LoadUint32(&o.USBMODE.Reg) & 0x3
}
func (o *USBHS_Type) SetUSBMODE_ES(value uint32) {
	volatile.StoreUint32(&o.USBMODE.Reg, volatile.LoadUint32(&o.USBMODE.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetUSBMODE_ES() uint32 {
	return (volatile.LoadUint32(&o.USBMODE.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetUSBMODE_SLOM(value uint32) {
	volatile.StoreUint32(&o.USBMODE.Reg, volatile.LoadUint32(&o.USBMODE.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetUSBMODE_SLOM() uint32 {
	return (volatile.LoadUint32(&o.USBMODE.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetUSBMODE_SDIS(value uint32) {
	volatile.StoreUint32(&o.USBMODE.Reg, volatile.LoadUint32(&o.USBMODE.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetUSBMODE_SDIS() uint32 {
	return (volatile.LoadUint32(&o.USBMODE.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetUSBMODE_TXHSD(value uint32) {
	volatile.StoreUint32(&o.USBMODE.Reg, volatile.LoadUint32(&o.USBMODE.Reg)&^(0x7000)|value<<12)
}
func (o *USBHS_Type) GetUSBMODE_TXHSD() uint32 {
	return (volatile.LoadUint32(&o.USBMODE.Reg) & 0x7000) >> 12
}

// USBHS.EPSETUPSR: Endpoint Setup Status Register
func (o *USBHS_Type) SetEPSETUPSR_EPSETUPSTAT(value uint32) {
	volatile.StoreUint32(&o.EPSETUPSR.Reg, volatile.LoadUint32(&o.EPSETUPSR.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetEPSETUPSR_EPSETUPSTAT() uint32 {
	return volatile.LoadUint32(&o.EPSETUPSR.Reg) & 0xf
}

// USBHS.EPPRIME: Endpoint Initialization Register
func (o *USBHS_Type) SetEPPRIME_PERB(value uint32) {
	volatile.StoreUint32(&o.EPPRIME.Reg, volatile.LoadUint32(&o.EPPRIME.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetEPPRIME_PERB() uint32 {
	return volatile.LoadUint32(&o.EPPRIME.Reg) & 0xf
}
func (o *USBHS_Type) SetEPPRIME_PETB(value uint32) {
	volatile.StoreUint32(&o.EPPRIME.Reg, volatile.LoadUint32(&o.EPPRIME.Reg)&^(0xf0000)|value<<16)
}
func (o *USBHS_Type) GetEPPRIME_PETB() uint32 {
	return (volatile.LoadUint32(&o.EPPRIME.Reg) & 0xf0000) >> 16
}

// USBHS.EPFLUSH: Endpoint Flush Register
func (o *USBHS_Type) SetEPFLUSH_FERB(value uint32) {
	volatile.StoreUint32(&o.EPFLUSH.Reg, volatile.LoadUint32(&o.EPFLUSH.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetEPFLUSH_FERB() uint32 {
	return volatile.LoadUint32(&o.EPFLUSH.Reg) & 0xf
}
func (o *USBHS_Type) SetEPFLUSH_FETB(value uint32) {
	volatile.StoreUint32(&o.EPFLUSH.Reg, volatile.LoadUint32(&o.EPFLUSH.Reg)&^(0xf0000)|value<<16)
}
func (o *USBHS_Type) GetEPFLUSH_FETB() uint32 {
	return (volatile.LoadUint32(&o.EPFLUSH.Reg) & 0xf0000) >> 16
}

// USBHS.EPSR: Endpoint Status Register
func (o *USBHS_Type) SetEPSR_ERBR(value uint32) {
	volatile.StoreUint32(&o.EPSR.Reg, volatile.LoadUint32(&o.EPSR.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetEPSR_ERBR() uint32 {
	return volatile.LoadUint32(&o.EPSR.Reg) & 0xf
}
func (o *USBHS_Type) SetEPSR_ETBR(value uint32) {
	volatile.StoreUint32(&o.EPSR.Reg, volatile.LoadUint32(&o.EPSR.Reg)&^(0xf0000)|value<<16)
}
func (o *USBHS_Type) GetEPSR_ETBR() uint32 {
	return (volatile.LoadUint32(&o.EPSR.Reg) & 0xf0000) >> 16
}

// USBHS.EPCOMPLETE: Endpoint Complete Register
func (o *USBHS_Type) SetEPCOMPLETE_ERCE(value uint32) {
	volatile.StoreUint32(&o.EPCOMPLETE.Reg, volatile.LoadUint32(&o.EPCOMPLETE.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetEPCOMPLETE_ERCE() uint32 {
	return volatile.LoadUint32(&o.EPCOMPLETE.Reg) & 0xf
}
func (o *USBHS_Type) SetEPCOMPLETE_ETCE(value uint32) {
	volatile.StoreUint32(&o.EPCOMPLETE.Reg, volatile.LoadUint32(&o.EPCOMPLETE.Reg)&^(0xf0000)|value<<16)
}
func (o *USBHS_Type) GetEPCOMPLETE_ETCE() uint32 {
	return (volatile.LoadUint32(&o.EPCOMPLETE.Reg) & 0xf0000) >> 16
}

// USBHS.EPCR0: Endpoint Control Register 0
func (o *USBHS_Type) SetEPCR0_RXS(value uint32) {
	volatile.StoreUint32(&o.EPCR0.Reg, volatile.LoadUint32(&o.EPCR0.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetEPCR0_RXS() uint32 {
	return volatile.LoadUint32(&o.EPCR0.Reg) & 0x1
}
func (o *USBHS_Type) SetEPCR0_RXT(value uint32) {
	volatile.StoreUint32(&o.EPCR0.Reg, volatile.LoadUint32(&o.EPCR0.Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetEPCR0_RXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR0.Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetEPCR0_RXE(value uint32) {
	volatile.StoreUint32(&o.EPCR0.Reg, volatile.LoadUint32(&o.EPCR0.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetEPCR0_RXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR0.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetEPCR0_TXS(value uint32) {
	volatile.StoreUint32(&o.EPCR0.Reg, volatile.LoadUint32(&o.EPCR0.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetEPCR0_TXS() uint32 {
	return (volatile.LoadUint32(&o.EPCR0.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetEPCR0_TXT(value uint32) {
	volatile.StoreUint32(&o.EPCR0.Reg, volatile.LoadUint32(&o.EPCR0.Reg)&^(0xc0000)|value<<18)
}
func (o *USBHS_Type) GetEPCR0_TXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR0.Reg) & 0xc0000) >> 18
}
func (o *USBHS_Type) SetEPCR0_TXE(value uint32) {
	volatile.StoreUint32(&o.EPCR0.Reg, volatile.LoadUint32(&o.EPCR0.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetEPCR0_TXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR0.Reg) & 0x800000) >> 23
}

// USBHS.EPCR1: Endpoint Control Register n
func (o *USBHS_Type) SetEPCR1_RXS(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetEPCR1_RXS() uint32 {
	return volatile.LoadUint32(&o.EPCR1.Reg) & 0x1
}
func (o *USBHS_Type) SetEPCR1_RXD(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetEPCR1_RXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetEPCR1_RXT(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetEPCR1_RXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetEPCR1_RXI(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetEPCR1_RXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetEPCR1_RXR(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetEPCR1_RXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetEPCR1_RXE(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetEPCR1_RXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetEPCR1_TXS(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetEPCR1_TXS() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetEPCR1_TXD(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetEPCR1_TXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetEPCR1_TXT(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0xc0000)|value<<18)
}
func (o *USBHS_Type) GetEPCR1_TXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0xc0000) >> 18
}
func (o *USBHS_Type) SetEPCR1_TXI(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetEPCR1_TXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetEPCR1_TXR(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetEPCR1_TXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetEPCR1_TXE(value uint32) {
	volatile.StoreUint32(&o.EPCR1.Reg, volatile.LoadUint32(&o.EPCR1.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetEPCR1_TXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR1.Reg) & 0x800000) >> 23
}

// USBHS.EPCR2: Endpoint Control Register n
func (o *USBHS_Type) SetEPCR2_RXS(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetEPCR2_RXS() uint32 {
	return volatile.LoadUint32(&o.EPCR2.Reg) & 0x1
}
func (o *USBHS_Type) SetEPCR2_RXD(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetEPCR2_RXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetEPCR2_RXT(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetEPCR2_RXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetEPCR2_RXI(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetEPCR2_RXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetEPCR2_RXR(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetEPCR2_RXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetEPCR2_RXE(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetEPCR2_RXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetEPCR2_TXS(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetEPCR2_TXS() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetEPCR2_TXD(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetEPCR2_TXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetEPCR2_TXT(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0xc0000)|value<<18)
}
func (o *USBHS_Type) GetEPCR2_TXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0xc0000) >> 18
}
func (o *USBHS_Type) SetEPCR2_TXI(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetEPCR2_TXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetEPCR2_TXR(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetEPCR2_TXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetEPCR2_TXE(value uint32) {
	volatile.StoreUint32(&o.EPCR2.Reg, volatile.LoadUint32(&o.EPCR2.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetEPCR2_TXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR2.Reg) & 0x800000) >> 23
}

// USBHS.EPCR3: Endpoint Control Register n
func (o *USBHS_Type) SetEPCR3_RXS(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetEPCR3_RXS() uint32 {
	return volatile.LoadUint32(&o.EPCR3.Reg) & 0x1
}
func (o *USBHS_Type) SetEPCR3_RXD(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetEPCR3_RXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetEPCR3_RXT(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetEPCR3_RXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetEPCR3_RXI(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetEPCR3_RXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetEPCR3_RXR(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetEPCR3_RXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetEPCR3_RXE(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetEPCR3_RXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetEPCR3_TXS(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetEPCR3_TXS() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetEPCR3_TXD(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetEPCR3_TXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetEPCR3_TXT(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0xc0000)|value<<18)
}
func (o *USBHS_Type) GetEPCR3_TXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0xc0000) >> 18
}
func (o *USBHS_Type) SetEPCR3_TXI(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetEPCR3_TXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetEPCR3_TXR(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetEPCR3_TXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetEPCR3_TXE(value uint32) {
	volatile.StoreUint32(&o.EPCR3.Reg, volatile.LoadUint32(&o.EPCR3.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetEPCR3_TXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR3.Reg) & 0x800000) >> 23
}

// USBHS.EPCR4: Endpoint Control Register n
func (o *USBHS_Type) SetEPCR4_RXS(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetEPCR4_RXS() uint32 {
	return volatile.LoadUint32(&o.EPCR4.Reg) & 0x1
}
func (o *USBHS_Type) SetEPCR4_RXD(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetEPCR4_RXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetEPCR4_RXT(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetEPCR4_RXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetEPCR4_RXI(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetEPCR4_RXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetEPCR4_RXR(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetEPCR4_RXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetEPCR4_RXE(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetEPCR4_RXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetEPCR4_TXS(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetEPCR4_TXS() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetEPCR4_TXD(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetEPCR4_TXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetEPCR4_TXT(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0xc0000)|value<<18)
}
func (o *USBHS_Type) GetEPCR4_TXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0xc0000) >> 18
}
func (o *USBHS_Type) SetEPCR4_TXI(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetEPCR4_TXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetEPCR4_TXR(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetEPCR4_TXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetEPCR4_TXE(value uint32) {
	volatile.StoreUint32(&o.EPCR4.Reg, volatile.LoadUint32(&o.EPCR4.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetEPCR4_TXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR4.Reg) & 0x800000) >> 23
}

// USBHS.EPCR5: Endpoint Control Register n
func (o *USBHS_Type) SetEPCR5_RXS(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetEPCR5_RXS() uint32 {
	return volatile.LoadUint32(&o.EPCR5.Reg) & 0x1
}
func (o *USBHS_Type) SetEPCR5_RXD(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetEPCR5_RXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetEPCR5_RXT(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetEPCR5_RXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetEPCR5_RXI(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetEPCR5_RXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetEPCR5_RXR(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetEPCR5_RXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetEPCR5_RXE(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetEPCR5_RXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetEPCR5_TXS(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetEPCR5_TXS() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetEPCR5_TXD(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetEPCR5_TXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetEPCR5_TXT(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0xc0000)|value<<18)
}
func (o *USBHS_Type) GetEPCR5_TXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0xc0000) >> 18
}
func (o *USBHS_Type) SetEPCR5_TXI(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetEPCR5_TXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetEPCR5_TXR(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetEPCR5_TXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetEPCR5_TXE(value uint32) {
	volatile.StoreUint32(&o.EPCR5.Reg, volatile.LoadUint32(&o.EPCR5.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetEPCR5_TXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR5.Reg) & 0x800000) >> 23
}

// USBHS.EPCR6: Endpoint Control Register n
func (o *USBHS_Type) SetEPCR6_RXS(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetEPCR6_RXS() uint32 {
	return volatile.LoadUint32(&o.EPCR6.Reg) & 0x1
}
func (o *USBHS_Type) SetEPCR6_RXD(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetEPCR6_RXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetEPCR6_RXT(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetEPCR6_RXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetEPCR6_RXI(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetEPCR6_RXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetEPCR6_RXR(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetEPCR6_RXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetEPCR6_RXE(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetEPCR6_RXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetEPCR6_TXS(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetEPCR6_TXS() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetEPCR6_TXD(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetEPCR6_TXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetEPCR6_TXT(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0xc0000)|value<<18)
}
func (o *USBHS_Type) GetEPCR6_TXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0xc0000) >> 18
}
func (o *USBHS_Type) SetEPCR6_TXI(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetEPCR6_TXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetEPCR6_TXR(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetEPCR6_TXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetEPCR6_TXE(value uint32) {
	volatile.StoreUint32(&o.EPCR6.Reg, volatile.LoadUint32(&o.EPCR6.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetEPCR6_TXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR6.Reg) & 0x800000) >> 23
}

// USBHS.EPCR7: Endpoint Control Register n
func (o *USBHS_Type) SetEPCR7_RXS(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetEPCR7_RXS() uint32 {
	return volatile.LoadUint32(&o.EPCR7.Reg) & 0x1
}
func (o *USBHS_Type) SetEPCR7_RXD(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetEPCR7_RXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetEPCR7_RXT(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0xc)|value<<2)
}
func (o *USBHS_Type) GetEPCR7_RXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0xc) >> 2
}
func (o *USBHS_Type) SetEPCR7_RXI(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetEPCR7_RXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetEPCR7_RXR(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetEPCR7_RXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetEPCR7_RXE(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetEPCR7_RXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetEPCR7_TXS(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x10000)|value<<16)
}
func (o *USBHS_Type) GetEPCR7_TXS() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0x10000) >> 16
}
func (o *USBHS_Type) SetEPCR7_TXD(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x20000)|value<<17)
}
func (o *USBHS_Type) GetEPCR7_TXD() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0x20000) >> 17
}
func (o *USBHS_Type) SetEPCR7_TXT(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0xc0000)|value<<18)
}
func (o *USBHS_Type) GetEPCR7_TXT() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0xc0000) >> 18
}
func (o *USBHS_Type) SetEPCR7_TXI(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetEPCR7_TXI() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetEPCR7_TXR(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x400000)|value<<22)
}
func (o *USBHS_Type) GetEPCR7_TXR() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0x400000) >> 22
}
func (o *USBHS_Type) SetEPCR7_TXE(value uint32) {
	volatile.StoreUint32(&o.EPCR7.Reg, volatile.LoadUint32(&o.EPCR7.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetEPCR7_TXE() uint32 {
	return (volatile.LoadUint32(&o.EPCR7.Reg) & 0x800000) >> 23
}

// USBHS.USBGENCTRL: USB General Control Register
func (o *USBHS_Type) SetUSBGENCTRL_WU_IE(value uint32) {
	volatile.StoreUint32(&o.USBGENCTRL.Reg, volatile.LoadUint32(&o.USBGENCTRL.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetUSBGENCTRL_WU_IE() uint32 {
	return volatile.LoadUint32(&o.USBGENCTRL.Reg) & 0x1
}
func (o *USBHS_Type) SetUSBGENCTRL_WU_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.USBGENCTRL.Reg, volatile.LoadUint32(&o.USBGENCTRL.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetUSBGENCTRL_WU_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.USBGENCTRL.Reg) & 0x20) >> 5
}

// USBPHY Register Reference Index
type USBPHY_Type struct {
	PWD                       volatile.Register32 // 0x0
	PWD_SET                   volatile.Register32 // 0x4
	PWD_CLR                   volatile.Register32 // 0x8
	PWD_TOG                   volatile.Register32 // 0xC
	TX                        volatile.Register32 // 0x10
	TX_SET                    volatile.Register32 // 0x14
	TX_CLR                    volatile.Register32 // 0x18
	TX_TOG                    volatile.Register32 // 0x1C
	RX                        volatile.Register32 // 0x20
	RX_SET                    volatile.Register32 // 0x24
	RX_CLR                    volatile.Register32 // 0x28
	RX_TOG                    volatile.Register32 // 0x2C
	CTRL                      volatile.Register32 // 0x30
	CTRL_SET                  volatile.Register32 // 0x34
	CTRL_CLR                  volatile.Register32 // 0x38
	CTRL_TOG                  volatile.Register32 // 0x3C
	STATUS                    volatile.Register32 // 0x40
	_                         [12]byte
	DEBUG                     volatile.Register32 // 0x50
	DEBUG_SET                 volatile.Register32 // 0x54
	DEBUG_CLR                 volatile.Register32 // 0x58
	DEBUG_TOG                 volatile.Register32 // 0x5C
	DEBUG0_STATUS             volatile.Register32 // 0x60
	_                         [12]byte
	DEBUG1                    volatile.Register32 // 0x70
	DEBUG1_SET                volatile.Register32 // 0x74
	DEBUG1_CLR                volatile.Register32 // 0x78
	DEBUG1_TOG                volatile.Register32 // 0x7C
	VERSION                   volatile.Register32 // 0x80
	_                         [28]byte
	PLL_SIC                   volatile.Register32 // 0xA0
	PLL_SIC_SET               volatile.Register32 // 0xA4
	PLL_SIC_CLR               volatile.Register32 // 0xA8
	PLL_SIC_TOG               volatile.Register32 // 0xAC
	_                         [16]byte
	USB1_VBUS_DETECT          volatile.Register32 // 0xC0
	USB1_VBUS_DETECT_SET      volatile.Register32 // 0xC4
	USB1_VBUS_DETECT_CLR      volatile.Register32 // 0xC8
	USB1_VBUS_DETECT_TOG      volatile.Register32 // 0xCC
	USB1_VBUS_DET_STAT        volatile.Register32 // 0xD0
	_                         [28]byte
	USB1_CHRG_DET_STAT        volatile.Register32 // 0xF0
	_                         [12]byte
	ANACTRL                   volatile.Register32 // 0x100
	ANACTRL_SET               volatile.Register32 // 0x104
	ANACTRL_CLR               volatile.Register32 // 0x108
	ANACTRL_TOG               volatile.Register32 // 0x10C
	USB1_LOOPBACK             volatile.Register32 // 0x110
	USB1_LOOPBACK_SET         volatile.Register32 // 0x114
	USB1_LOOPBACK_CLR         volatile.Register32 // 0x118
	USB1_LOOPBACK_TOG         volatile.Register32 // 0x11C
	USB1_LOOPBACK_HSFSCNT     volatile.Register32 // 0x120
	USB1_LOOPBACK_HSFSCNT_SET volatile.Register32 // 0x124
	USB1_LOOPBACK_HSFSCNT_CLR volatile.Register32 // 0x128
	USB1_LOOPBACK_HSFSCNT_TOG volatile.Register32 // 0x12C
	TRIM_OVERRIDE_EN          volatile.Register32 // 0x130
	TRIM_OVERRIDE_EN_SET      volatile.Register32 // 0x134
	TRIM_OVERRIDE_EN_CLR      volatile.Register32 // 0x138
	TRIM_OVERRIDE_EN_TOG      volatile.Register32 // 0x13C
}

// USBPHY.PWD: USB PHY Power-Down Register
func (o *USBPHY_Type) SetPWD_TXPWDFS(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetPWD_TXPWDFS() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetPWD_TXPWDIBIAS(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPWD_TXPWDIBIAS() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPWD_TXPWDV2I(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPWD_TXPWDV2I() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPWD_RXPWDENV(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetPWD_RXPWDENV() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetPWD_RXPWD1PT1(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetPWD_RXPWD1PT1() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetPWD_RXPWDDIFF(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetPWD_RXPWDDIFF() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetPWD_RXPWDRX(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetPWD_RXPWDRX() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x100000) >> 20
}

// USBPHY.PWD_SET: USB PHY Power-Down Register
func (o *USBPHY_Type) SetPWD_SET_TXPWDFS(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetPWD_SET_TXPWDFS() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetPWD_SET_TXPWDIBIAS(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPWD_SET_TXPWDIBIAS() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPWD_SET_TXPWDV2I(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPWD_SET_TXPWDV2I() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPWD_SET_RXPWDENV(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetPWD_SET_RXPWDENV() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetPWD_SET_RXPWD1PT1(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetPWD_SET_RXPWD1PT1() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetPWD_SET_RXPWDDIFF(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetPWD_SET_RXPWDDIFF() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetPWD_SET_RXPWDRX(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetPWD_SET_RXPWDRX() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x100000) >> 20
}

// USBPHY.PWD_CLR: USB PHY Power-Down Register
func (o *USBPHY_Type) SetPWD_CLR_TXPWDFS(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetPWD_CLR_TXPWDFS() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetPWD_CLR_TXPWDIBIAS(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPWD_CLR_TXPWDIBIAS() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPWD_CLR_TXPWDV2I(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPWD_CLR_TXPWDV2I() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPWD_CLR_RXPWDENV(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetPWD_CLR_RXPWDENV() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetPWD_CLR_RXPWD1PT1(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetPWD_CLR_RXPWD1PT1() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetPWD_CLR_RXPWDDIFF(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetPWD_CLR_RXPWDDIFF() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetPWD_CLR_RXPWDRX(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetPWD_CLR_RXPWDRX() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x100000) >> 20
}

// USBPHY.PWD_TOG: USB PHY Power-Down Register
func (o *USBPHY_Type) SetPWD_TOG_TXPWDFS(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetPWD_TOG_TXPWDFS() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetPWD_TOG_TXPWDIBIAS(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPWD_TOG_TXPWDIBIAS() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPWD_TOG_TXPWDV2I(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPWD_TOG_TXPWDV2I() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPWD_TOG_RXPWDENV(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetPWD_TOG_RXPWDENV() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetPWD_TOG_RXPWD1PT1(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetPWD_TOG_RXPWD1PT1() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetPWD_TOG_RXPWDDIFF(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetPWD_TOG_RXPWDDIFF() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetPWD_TOG_RXPWDRX(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetPWD_TOG_RXPWDRX() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x100000) >> 20
}

// USBPHY.TX: USB PHY Transmitter Control Register
func (o *USBPHY_Type) SetTX_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0xf)|value)
}
func (o *USBPHY_Type) GetTX_D_CAL() uint32 {
	return volatile.LoadUint32(&o.TX.Reg) & 0xf
}
func (o *USBPHY_Type) SetTX_TXCAL45DM(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetTX_TXCAL45DM() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetTX_TXCAL45DP(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0xf0000)|value<<16)
}
func (o *USBPHY_Type) GetTX_TXCAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0xf0000) >> 16
}
func (o *USBPHY_Type) SetTX_USBPHY_TX_EDGECTRL(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0x1c000000)|value<<26)
}
func (o *USBPHY_Type) GetTX_USBPHY_TX_EDGECTRL() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0x1c000000) >> 26
}

// USBPHY.TX_SET: USB PHY Transmitter Control Register
func (o *USBPHY_Type) SetTX_SET_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0xf)|value)
}
func (o *USBPHY_Type) GetTX_SET_D_CAL() uint32 {
	return volatile.LoadUint32(&o.TX_SET.Reg) & 0xf
}
func (o *USBPHY_Type) SetTX_SET_TXCAL45DM(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetTX_SET_TXCAL45DM() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetTX_SET_TXCAL45DP(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0xf0000)|value<<16)
}
func (o *USBPHY_Type) GetTX_SET_TXCAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0xf0000) >> 16
}
func (o *USBPHY_Type) SetTX_SET_USBPHY_TX_EDGECTRL(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0x1c000000)|value<<26)
}
func (o *USBPHY_Type) GetTX_SET_USBPHY_TX_EDGECTRL() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0x1c000000) >> 26
}

// USBPHY.TX_CLR: USB PHY Transmitter Control Register
func (o *USBPHY_Type) SetTX_CLR_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0xf)|value)
}
func (o *USBPHY_Type) GetTX_CLR_D_CAL() uint32 {
	return volatile.LoadUint32(&o.TX_CLR.Reg) & 0xf
}
func (o *USBPHY_Type) SetTX_CLR_TXCAL45DM(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetTX_CLR_TXCAL45DM() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetTX_CLR_TXCAL45DP(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0xf0000)|value<<16)
}
func (o *USBPHY_Type) GetTX_CLR_TXCAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0xf0000) >> 16
}
func (o *USBPHY_Type) SetTX_CLR_USBPHY_TX_EDGECTRL(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0x1c000000)|value<<26)
}
func (o *USBPHY_Type) GetTX_CLR_USBPHY_TX_EDGECTRL() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0x1c000000) >> 26
}

// USBPHY.TX_TOG: USB PHY Transmitter Control Register
func (o *USBPHY_Type) SetTX_TOG_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0xf)|value)
}
func (o *USBPHY_Type) GetTX_TOG_D_CAL() uint32 {
	return volatile.LoadUint32(&o.TX_TOG.Reg) & 0xf
}
func (o *USBPHY_Type) SetTX_TOG_TXCAL45DM(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetTX_TOG_TXCAL45DM() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetTX_TOG_TXCAL45DP(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0xf0000)|value<<16)
}
func (o *USBPHY_Type) GetTX_TOG_TXCAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0xf0000) >> 16
}
func (o *USBPHY_Type) SetTX_TOG_USBPHY_TX_EDGECTRL(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0x1c000000)|value<<26)
}
func (o *USBPHY_Type) GetTX_TOG_USBPHY_TX_EDGECTRL() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0x1c000000) >> 26
}

// USBPHY.RX: USB PHY Receiver Control Register
func (o *USBPHY_Type) SetRX_ENVADJ(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetRX_ENVADJ() uint32 {
	return volatile.LoadUint32(&o.RX.Reg) & 0x7
}
func (o *USBPHY_Type) SetRX_DISCONADJ(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x70)|value<<4)
}
func (o *USBPHY_Type) GetRX_DISCONADJ() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x70) >> 4
}
func (o *USBPHY_Type) SetRX_RXDBYPASS(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetRX_RXDBYPASS() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x400000) >> 22
}

// USBPHY.RX_SET: USB PHY Receiver Control Register
func (o *USBPHY_Type) SetRX_SET_ENVADJ(value uint32) {
	volatile.StoreUint32(&o.RX_SET.Reg, volatile.LoadUint32(&o.RX_SET.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetRX_SET_ENVADJ() uint32 {
	return volatile.LoadUint32(&o.RX_SET.Reg) & 0x7
}
func (o *USBPHY_Type) SetRX_SET_DISCONADJ(value uint32) {
	volatile.StoreUint32(&o.RX_SET.Reg, volatile.LoadUint32(&o.RX_SET.Reg)&^(0x70)|value<<4)
}
func (o *USBPHY_Type) GetRX_SET_DISCONADJ() uint32 {
	return (volatile.LoadUint32(&o.RX_SET.Reg) & 0x70) >> 4
}
func (o *USBPHY_Type) SetRX_SET_RXDBYPASS(value uint32) {
	volatile.StoreUint32(&o.RX_SET.Reg, volatile.LoadUint32(&o.RX_SET.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetRX_SET_RXDBYPASS() uint32 {
	return (volatile.LoadUint32(&o.RX_SET.Reg) & 0x400000) >> 22
}

// USBPHY.RX_CLR: USB PHY Receiver Control Register
func (o *USBPHY_Type) SetRX_CLR_ENVADJ(value uint32) {
	volatile.StoreUint32(&o.RX_CLR.Reg, volatile.LoadUint32(&o.RX_CLR.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetRX_CLR_ENVADJ() uint32 {
	return volatile.LoadUint32(&o.RX_CLR.Reg) & 0x7
}
func (o *USBPHY_Type) SetRX_CLR_DISCONADJ(value uint32) {
	volatile.StoreUint32(&o.RX_CLR.Reg, volatile.LoadUint32(&o.RX_CLR.Reg)&^(0x70)|value<<4)
}
func (o *USBPHY_Type) GetRX_CLR_DISCONADJ() uint32 {
	return (volatile.LoadUint32(&o.RX_CLR.Reg) & 0x70) >> 4
}
func (o *USBPHY_Type) SetRX_CLR_RXDBYPASS(value uint32) {
	volatile.StoreUint32(&o.RX_CLR.Reg, volatile.LoadUint32(&o.RX_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetRX_CLR_RXDBYPASS() uint32 {
	return (volatile.LoadUint32(&o.RX_CLR.Reg) & 0x400000) >> 22
}

// USBPHY.RX_TOG: USB PHY Receiver Control Register
func (o *USBPHY_Type) SetRX_TOG_ENVADJ(value uint32) {
	volatile.StoreUint32(&o.RX_TOG.Reg, volatile.LoadUint32(&o.RX_TOG.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetRX_TOG_ENVADJ() uint32 {
	return volatile.LoadUint32(&o.RX_TOG.Reg) & 0x7
}
func (o *USBPHY_Type) SetRX_TOG_DISCONADJ(value uint32) {
	volatile.StoreUint32(&o.RX_TOG.Reg, volatile.LoadUint32(&o.RX_TOG.Reg)&^(0x70)|value<<4)
}
func (o *USBPHY_Type) GetRX_TOG_DISCONADJ() uint32 {
	return (volatile.LoadUint32(&o.RX_TOG.Reg) & 0x70) >> 4
}
func (o *USBPHY_Type) SetRX_TOG_RXDBYPASS(value uint32) {
	volatile.StoreUint32(&o.RX_TOG.Reg, volatile.LoadUint32(&o.RX_TOG.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetRX_TOG_RXDBYPASS() uint32 {
	return (volatile.LoadUint32(&o.RX_TOG.Reg) & 0x400000) >> 22
}

// USBPHY.CTRL: USB PHY General Control Register
func (o *USBPHY_Type) SetCTRL_ENHOSTDISCONDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetCTRL_ENHOSTDISCONDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetCTRL_HOSTDISCONDETECT_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetCTRL_HOSTDISCONDETECT_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetCTRL_ENDEVPLUGINDET(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetCTRL_ENDEVPLUGINDET() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetCTRL_DEVPLUGIN_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetCTRL_DEVPLUGIN_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetCTRL_ENUTMILEVEL2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *USBPHY_Type) GetCTRL_ENUTMILEVEL2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000) >> 14
}
func (o *USBPHY_Type) SetCTRL_ENUTMILEVEL3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetCTRL_ENUTMILEVEL3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetCTRL_AUTORESUME_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetCTRL_AUTORESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetCTRL_ENAUTOCLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetCTRL_ENAUTOCLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetCTRL_ENAUTOCLR_PHY_PWD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetCTRL_ENAUTOCLR_PHY_PWD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetCTRL_FSDLL_RST_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetCTRL_FSDLL_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetCTRL_OTG_ID_VALUE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *USBPHY_Type) GetCTRL_OTG_ID_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000000) >> 27
}
func (o *USBPHY_Type) SetCTRL_HOST_FORCE_LS_SE0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *USBPHY_Type) GetCTRL_HOST_FORCE_LS_SE0() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000000) >> 28
}
func (o *USBPHY_Type) SetCTRL_UTMI_SUSPENDM(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetCTRL_UTMI_SUSPENDM() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetCTRL_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetCTRL_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetCTRL_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetCTRL_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// USBPHY.CTRL_SET: USB PHY General Control Register
func (o *USBPHY_Type) SetCTRL_SET_ENHOSTDISCONDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetCTRL_SET_ENHOSTDISCONDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetCTRL_SET_HOSTDISCONDETECT_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetCTRL_SET_HOSTDISCONDETECT_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetCTRL_SET_ENDEVPLUGINDET(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetCTRL_SET_ENDEVPLUGINDET() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetCTRL_SET_DEVPLUGIN_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetCTRL_SET_DEVPLUGIN_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetCTRL_SET_ENUTMILEVEL2(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x4000)|value<<14)
}
func (o *USBPHY_Type) GetCTRL_SET_ENUTMILEVEL2() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x4000) >> 14
}
func (o *USBPHY_Type) SetCTRL_SET_ENUTMILEVEL3(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetCTRL_SET_ENUTMILEVEL3() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetCTRL_SET_AUTORESUME_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetCTRL_SET_AUTORESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetCTRL_SET_ENAUTOCLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetCTRL_SET_ENAUTOCLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetCTRL_SET_ENAUTOCLR_PHY_PWD(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetCTRL_SET_ENAUTOCLR_PHY_PWD() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetCTRL_SET_FSDLL_RST_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetCTRL_SET_FSDLL_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetCTRL_SET_OTG_ID_VALUE(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x8000000)|value<<27)
}
func (o *USBPHY_Type) GetCTRL_SET_OTG_ID_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x8000000) >> 27
}
func (o *USBPHY_Type) SetCTRL_SET_HOST_FORCE_LS_SE0(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x10000000)|value<<28)
}
func (o *USBPHY_Type) GetCTRL_SET_HOST_FORCE_LS_SE0() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x10000000) >> 28
}
func (o *USBPHY_Type) SetCTRL_SET_UTMI_SUSPENDM(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetCTRL_SET_UTMI_SUSPENDM() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetCTRL_SET_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetCTRL_SET_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetCTRL_SET_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetCTRL_SET_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x80000000) >> 31
}

// USBPHY.CTRL_CLR: USB PHY General Control Register
func (o *USBPHY_Type) SetCTRL_CLR_ENHOSTDISCONDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENHOSTDISCONDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetCTRL_CLR_HOSTDISCONDETECT_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetCTRL_CLR_HOSTDISCONDETECT_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetCTRL_CLR_ENDEVPLUGINDET(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENDEVPLUGINDET() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetCTRL_CLR_DEVPLUGIN_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetCTRL_CLR_DEVPLUGIN_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetCTRL_CLR_ENUTMILEVEL2(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENUTMILEVEL2() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x4000) >> 14
}
func (o *USBPHY_Type) SetCTRL_CLR_ENUTMILEVEL3(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENUTMILEVEL3() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetCTRL_CLR_AUTORESUME_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetCTRL_CLR_AUTORESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetCTRL_CLR_ENAUTOCLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENAUTOCLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetCTRL_CLR_ENAUTOCLR_PHY_PWD(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENAUTOCLR_PHY_PWD() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetCTRL_CLR_FSDLL_RST_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetCTRL_CLR_FSDLL_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetCTRL_CLR_OTG_ID_VALUE(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBPHY_Type) GetCTRL_CLR_OTG_ID_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x8000000) >> 27
}
func (o *USBPHY_Type) SetCTRL_CLR_HOST_FORCE_LS_SE0(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBPHY_Type) GetCTRL_CLR_HOST_FORCE_LS_SE0() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x10000000) >> 28
}
func (o *USBPHY_Type) SetCTRL_CLR_UTMI_SUSPENDM(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetCTRL_CLR_UTMI_SUSPENDM() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetCTRL_CLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetCTRL_CLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetCTRL_CLR_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetCTRL_CLR_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x80000000) >> 31
}

// USBPHY.CTRL_TOG: USB PHY General Control Register
func (o *USBPHY_Type) SetCTRL_TOG_ENHOSTDISCONDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENHOSTDISCONDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetCTRL_TOG_HOSTDISCONDETECT_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetCTRL_TOG_HOSTDISCONDETECT_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetCTRL_TOG_ENDEVPLUGINDET(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENDEVPLUGINDET() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetCTRL_TOG_DEVPLUGIN_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetCTRL_TOG_DEVPLUGIN_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetCTRL_TOG_ENUTMILEVEL2(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x4000)|value<<14)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENUTMILEVEL2() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x4000) >> 14
}
func (o *USBPHY_Type) SetCTRL_TOG_ENUTMILEVEL3(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENUTMILEVEL3() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetCTRL_TOG_AUTORESUME_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetCTRL_TOG_AUTORESUME_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetCTRL_TOG_ENAUTOCLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENAUTOCLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetCTRL_TOG_ENAUTOCLR_PHY_PWD(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENAUTOCLR_PHY_PWD() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetCTRL_TOG_FSDLL_RST_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetCTRL_TOG_FSDLL_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetCTRL_TOG_OTG_ID_VALUE(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x8000000)|value<<27)
}
func (o *USBPHY_Type) GetCTRL_TOG_OTG_ID_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x8000000) >> 27
}
func (o *USBPHY_Type) SetCTRL_TOG_HOST_FORCE_LS_SE0(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x10000000)|value<<28)
}
func (o *USBPHY_Type) GetCTRL_TOG_HOST_FORCE_LS_SE0() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x10000000) >> 28
}
func (o *USBPHY_Type) SetCTRL_TOG_UTMI_SUSPENDM(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetCTRL_TOG_UTMI_SUSPENDM() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetCTRL_TOG_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetCTRL_TOG_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetCTRL_TOG_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetCTRL_TOG_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x80000000) >> 31
}

// USBPHY.STATUS: USB PHY Status Register
func (o *USBPHY_Type) SetSTATUS_HOSTDISCONDETECT_STATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetSTATUS_HOSTDISCONDETECT_STATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetSTATUS_DEVPLUGIN_STATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetSTATUS_DEVPLUGIN_STATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetSTATUS_OTGID_STATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetSTATUS_OTGID_STATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetSTATUS_RESUME_STATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetSTATUS_RESUME_STATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}

// USBPHY.DEBUG: USB PHY Debug Register
func (o *USBPHY_Type) SetDEBUG_OTGIDPIOLOCK(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetDEBUG_OTGIDPIOLOCK() uint32 {
	return volatile.LoadUint32(&o.DEBUG.Reg) & 0x1
}
func (o *USBPHY_Type) SetDEBUG_DEBUG_INTERFACE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetDEBUG_DEBUG_INTERFACE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetDEBUG_HSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetDEBUG_HSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetDEBUG_ENHSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x30)|value<<4)
}
func (o *USBPHY_Type) GetDEBUG_ENHSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x30) >> 4
}
func (o *USBPHY_Type) SetDEBUG_TX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetDEBUG_TX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetDEBUG_ENTX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetDEBUG_ENTX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetDEBUG_SQUELCHRESETCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1f0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG_SQUELCHRESETCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x1f0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG_ENSQUELCHRESET(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetDEBUG_ENSQUELCHRESET() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetDEBUG_SQUELCHRESETLENGTH(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1e000000)|value<<25)
}
func (o *USBPHY_Type) GetDEBUG_SQUELCHRESETLENGTH() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x1e000000) >> 25
}
func (o *USBPHY_Type) SetDEBUG_HOST_RESUME_DEBUG(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetDEBUG_HOST_RESUME_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetDEBUG_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetDEBUG_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x40000000) >> 30
}

// USBPHY.DEBUG_SET: USB PHY Debug Register
func (o *USBPHY_Type) SetDEBUG_SET_OTGIDPIOLOCK(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetDEBUG_SET_OTGIDPIOLOCK() uint32 {
	return volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1
}
func (o *USBPHY_Type) SetDEBUG_SET_DEBUG_INTERFACE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetDEBUG_SET_DEBUG_INTERFACE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetDEBUG_SET_HSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetDEBUG_SET_HSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetDEBUG_SET_ENHSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x30)|value<<4)
}
func (o *USBPHY_Type) GetDEBUG_SET_ENHSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x30) >> 4
}
func (o *USBPHY_Type) SetDEBUG_SET_TX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetDEBUG_SET_TX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetDEBUG_SET_ENTX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetDEBUG_SET_ENTX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetDEBUG_SET_SQUELCHRESETCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1f0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG_SET_SQUELCHRESETCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1f0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG_SET_ENSQUELCHRESET(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetDEBUG_SET_ENSQUELCHRESET() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetDEBUG_SET_SQUELCHRESETLENGTH(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1e000000)|value<<25)
}
func (o *USBPHY_Type) GetDEBUG_SET_SQUELCHRESETLENGTH() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1e000000) >> 25
}
func (o *USBPHY_Type) SetDEBUG_SET_HOST_RESUME_DEBUG(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetDEBUG_SET_HOST_RESUME_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetDEBUG_SET_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetDEBUG_SET_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x40000000) >> 30
}

// USBPHY.DEBUG_CLR: USB PHY Debug Register
func (o *USBPHY_Type) SetDEBUG_CLR_OTGIDPIOLOCK(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetDEBUG_CLR_OTGIDPIOLOCK() uint32 {
	return volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1
}
func (o *USBPHY_Type) SetDEBUG_CLR_DEBUG_INTERFACE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetDEBUG_CLR_DEBUG_INTERFACE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetDEBUG_CLR_HSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetDEBUG_CLR_HSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetDEBUG_CLR_ENHSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x30)|value<<4)
}
func (o *USBPHY_Type) GetDEBUG_CLR_ENHSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x30) >> 4
}
func (o *USBPHY_Type) SetDEBUG_CLR_TX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetDEBUG_CLR_TX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetDEBUG_CLR_ENTX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetDEBUG_CLR_ENTX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetDEBUG_CLR_SQUELCHRESETCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1f0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG_CLR_SQUELCHRESETCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1f0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG_CLR_ENSQUELCHRESET(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetDEBUG_CLR_ENSQUELCHRESET() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetDEBUG_CLR_SQUELCHRESETLENGTH(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1e000000)|value<<25)
}
func (o *USBPHY_Type) GetDEBUG_CLR_SQUELCHRESETLENGTH() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1e000000) >> 25
}
func (o *USBPHY_Type) SetDEBUG_CLR_HOST_RESUME_DEBUG(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetDEBUG_CLR_HOST_RESUME_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetDEBUG_CLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetDEBUG_CLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x40000000) >> 30
}

// USBPHY.DEBUG_TOG: USB PHY Debug Register
func (o *USBPHY_Type) SetDEBUG_TOG_OTGIDPIOLOCK(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetDEBUG_TOG_OTGIDPIOLOCK() uint32 {
	return volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1
}
func (o *USBPHY_Type) SetDEBUG_TOG_DEBUG_INTERFACE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetDEBUG_TOG_DEBUG_INTERFACE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetDEBUG_TOG_HSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetDEBUG_TOG_HSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetDEBUG_TOG_ENHSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x30)|value<<4)
}
func (o *USBPHY_Type) GetDEBUG_TOG_ENHSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x30) >> 4
}
func (o *USBPHY_Type) SetDEBUG_TOG_TX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetDEBUG_TOG_TX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetDEBUG_TOG_ENTX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetDEBUG_TOG_ENTX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetDEBUG_TOG_SQUELCHRESETCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1f0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG_TOG_SQUELCHRESETCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1f0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG_TOG_ENSQUELCHRESET(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetDEBUG_TOG_ENSQUELCHRESET() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetDEBUG_TOG_SQUELCHRESETLENGTH(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1e000000)|value<<25)
}
func (o *USBPHY_Type) GetDEBUG_TOG_SQUELCHRESETLENGTH() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1e000000) >> 25
}
func (o *USBPHY_Type) SetDEBUG_TOG_HOST_RESUME_DEBUG(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetDEBUG_TOG_HOST_RESUME_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetDEBUG_TOG_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetDEBUG_TOG_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x40000000) >> 30
}

// USBPHY.DEBUG0_STATUS: UTMI Debug Status Register 0
func (o *USBPHY_Type) SetDEBUG0_STATUS_LOOP_BACK_FAIL_COUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG0_STATUS.Reg, volatile.LoadUint32(&o.DEBUG0_STATUS.Reg)&^(0xffff)|value)
}
func (o *USBPHY_Type) GetDEBUG0_STATUS_LOOP_BACK_FAIL_COUNT() uint32 {
	return volatile.LoadUint32(&o.DEBUG0_STATUS.Reg) & 0xffff
}
func (o *USBPHY_Type) SetDEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG0_STATUS.Reg, volatile.LoadUint32(&o.DEBUG0_STATUS.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG0_STATUS.Reg) & 0x3ff0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG0_STATUS_SQUELCH_COUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG0_STATUS.Reg, volatile.LoadUint32(&o.DEBUG0_STATUS.Reg)&^(0xfc000000)|value<<26)
}
func (o *USBPHY_Type) GetDEBUG0_STATUS_SQUELCH_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG0_STATUS.Reg) & 0xfc000000) >> 26
}

// USBPHY.DEBUG1: UTMI Debug Status Register 1
func (o *USBPHY_Type) SetDEBUG1_ENTAILADJVD(value uint32) {
	volatile.StoreUint32(&o.DEBUG1.Reg, volatile.LoadUint32(&o.DEBUG1.Reg)&^(0x6000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG1_ENTAILADJVD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1.Reg) & 0x6000) >> 13
}

// USBPHY.DEBUG1_SET: UTMI Debug Status Register 1
func (o *USBPHY_Type) SetDEBUG1_SET_ENTAILADJVD(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_SET.Reg, volatile.LoadUint32(&o.DEBUG1_SET.Reg)&^(0x6000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG1_SET_ENTAILADJVD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1_SET.Reg) & 0x6000) >> 13
}

// USBPHY.DEBUG1_CLR: UTMI Debug Status Register 1
func (o *USBPHY_Type) SetDEBUG1_CLR_ENTAILADJVD(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_CLR.Reg, volatile.LoadUint32(&o.DEBUG1_CLR.Reg)&^(0x6000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG1_CLR_ENTAILADJVD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1_CLR.Reg) & 0x6000) >> 13
}

// USBPHY.DEBUG1_TOG: UTMI Debug Status Register 1
func (o *USBPHY_Type) SetDEBUG1_TOG_ENTAILADJVD(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_TOG.Reg, volatile.LoadUint32(&o.DEBUG1_TOG.Reg)&^(0x6000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG1_TOG_ENTAILADJVD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1_TOG.Reg) & 0x6000) >> 13
}

// USBPHY.VERSION: UTMI RTL Version
func (o *USBPHY_Type) SetVERSION_STEP(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xffff)|value)
}
func (o *USBPHY_Type) GetVERSION_STEP() uint32 {
	return volatile.LoadUint32(&o.VERSION.Reg) & 0xffff
}
func (o *USBPHY_Type) SetVERSION_MINOR(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xff0000)|value<<16)
}
func (o *USBPHY_Type) GetVERSION_MINOR() uint32 {
	return (volatile.LoadUint32(&o.VERSION.Reg) & 0xff0000) >> 16
}
func (o *USBPHY_Type) SetVERSION_MAJOR(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xff000000)|value<<24)
}
func (o *USBPHY_Type) GetVERSION_MAJOR() uint32 {
	return (volatile.LoadUint32(&o.VERSION.Reg) & 0xff000000) >> 24
}

// USBPHY.PLL_SIC: USB PHY PLL Control/Status Register
func (o *USBPHY_Type) SetPLL_SIC_PLL_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC.Reg, volatile.LoadUint32(&o.PLL_SIC.Reg)&^(0x3)|value)
}
func (o *USBPHY_Type) GetPLL_SIC_PLL_DIV_SEL() uint32 {
	return volatile.LoadUint32(&o.PLL_SIC.Reg) & 0x3
}
func (o *USBPHY_Type) SetPLL_SIC_PLL_EN_USB_CLKS(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC.Reg, volatile.LoadUint32(&o.PLL_SIC.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetPLL_SIC_PLL_EN_USB_CLKS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetPLL_SIC_PLL_HOLD_RING_OFF(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC.Reg, volatile.LoadUint32(&o.PLL_SIC.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPLL_SIC_PLL_HOLD_RING_OFF() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPLL_SIC_PLL_POWER(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC.Reg, volatile.LoadUint32(&o.PLL_SIC.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPLL_SIC_PLL_POWER() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPLL_SIC_PLL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC.Reg, volatile.LoadUint32(&o.PLL_SIC.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetPLL_SIC_PLL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetPLL_SIC_PLL_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC.Reg, volatile.LoadUint32(&o.PLL_SIC.Reg)&^(0x10000)|value<<16)
}
func (o *USBPHY_Type) GetPLL_SIC_PLL_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC.Reg) & 0x10000) >> 16
}
func (o *USBPHY_Type) SetPLL_SIC_PLL_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC.Reg, volatile.LoadUint32(&o.PLL_SIC.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetPLL_SIC_PLL_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC.Reg) & 0x80000000) >> 31
}

// USBPHY.PLL_SIC_SET: USB PHY PLL Control/Status Register
func (o *USBPHY_Type) SetPLL_SIC_SET_PLL_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_SET.Reg, volatile.LoadUint32(&o.PLL_SIC_SET.Reg)&^(0x3)|value)
}
func (o *USBPHY_Type) GetPLL_SIC_SET_PLL_DIV_SEL() uint32 {
	return volatile.LoadUint32(&o.PLL_SIC_SET.Reg) & 0x3
}
func (o *USBPHY_Type) SetPLL_SIC_SET_PLL_EN_USB_CLKS(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_SET.Reg, volatile.LoadUint32(&o.PLL_SIC_SET.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetPLL_SIC_SET_PLL_EN_USB_CLKS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_SET.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetPLL_SIC_SET_PLL_HOLD_RING_OFF(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_SET.Reg, volatile.LoadUint32(&o.PLL_SIC_SET.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPLL_SIC_SET_PLL_HOLD_RING_OFF() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_SET.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPLL_SIC_SET_PLL_POWER(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_SET.Reg, volatile.LoadUint32(&o.PLL_SIC_SET.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPLL_SIC_SET_PLL_POWER() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_SET.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPLL_SIC_SET_PLL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_SET.Reg, volatile.LoadUint32(&o.PLL_SIC_SET.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetPLL_SIC_SET_PLL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_SET.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetPLL_SIC_SET_PLL_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_SET.Reg, volatile.LoadUint32(&o.PLL_SIC_SET.Reg)&^(0x10000)|value<<16)
}
func (o *USBPHY_Type) GetPLL_SIC_SET_PLL_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_SET.Reg) & 0x10000) >> 16
}
func (o *USBPHY_Type) SetPLL_SIC_SET_PLL_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_SET.Reg, volatile.LoadUint32(&o.PLL_SIC_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetPLL_SIC_SET_PLL_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_SET.Reg) & 0x80000000) >> 31
}

// USBPHY.PLL_SIC_CLR: USB PHY PLL Control/Status Register
func (o *USBPHY_Type) SetPLL_SIC_CLR_PLL_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_CLR.Reg, volatile.LoadUint32(&o.PLL_SIC_CLR.Reg)&^(0x3)|value)
}
func (o *USBPHY_Type) GetPLL_SIC_CLR_PLL_DIV_SEL() uint32 {
	return volatile.LoadUint32(&o.PLL_SIC_CLR.Reg) & 0x3
}
func (o *USBPHY_Type) SetPLL_SIC_CLR_PLL_EN_USB_CLKS(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_CLR.Reg, volatile.LoadUint32(&o.PLL_SIC_CLR.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetPLL_SIC_CLR_PLL_EN_USB_CLKS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_CLR.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetPLL_SIC_CLR_PLL_HOLD_RING_OFF(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_CLR.Reg, volatile.LoadUint32(&o.PLL_SIC_CLR.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPLL_SIC_CLR_PLL_HOLD_RING_OFF() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_CLR.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPLL_SIC_CLR_PLL_POWER(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_CLR.Reg, volatile.LoadUint32(&o.PLL_SIC_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPLL_SIC_CLR_PLL_POWER() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_CLR.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPLL_SIC_CLR_PLL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_CLR.Reg, volatile.LoadUint32(&o.PLL_SIC_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetPLL_SIC_CLR_PLL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_CLR.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetPLL_SIC_CLR_PLL_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_CLR.Reg, volatile.LoadUint32(&o.PLL_SIC_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *USBPHY_Type) GetPLL_SIC_CLR_PLL_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_CLR.Reg) & 0x10000) >> 16
}
func (o *USBPHY_Type) SetPLL_SIC_CLR_PLL_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_CLR.Reg, volatile.LoadUint32(&o.PLL_SIC_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetPLL_SIC_CLR_PLL_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_CLR.Reg) & 0x80000000) >> 31
}

// USBPHY.PLL_SIC_TOG: USB PHY PLL Control/Status Register
func (o *USBPHY_Type) SetPLL_SIC_TOG_PLL_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_TOG.Reg, volatile.LoadUint32(&o.PLL_SIC_TOG.Reg)&^(0x3)|value)
}
func (o *USBPHY_Type) GetPLL_SIC_TOG_PLL_DIV_SEL() uint32 {
	return volatile.LoadUint32(&o.PLL_SIC_TOG.Reg) & 0x3
}
func (o *USBPHY_Type) SetPLL_SIC_TOG_PLL_EN_USB_CLKS(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_TOG.Reg, volatile.LoadUint32(&o.PLL_SIC_TOG.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetPLL_SIC_TOG_PLL_EN_USB_CLKS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_TOG.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetPLL_SIC_TOG_PLL_HOLD_RING_OFF(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_TOG.Reg, volatile.LoadUint32(&o.PLL_SIC_TOG.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPLL_SIC_TOG_PLL_HOLD_RING_OFF() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_TOG.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPLL_SIC_TOG_PLL_POWER(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_TOG.Reg, volatile.LoadUint32(&o.PLL_SIC_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPLL_SIC_TOG_PLL_POWER() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_TOG.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPLL_SIC_TOG_PLL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_TOG.Reg, volatile.LoadUint32(&o.PLL_SIC_TOG.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetPLL_SIC_TOG_PLL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_TOG.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetPLL_SIC_TOG_PLL_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_TOG.Reg, volatile.LoadUint32(&o.PLL_SIC_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *USBPHY_Type) GetPLL_SIC_TOG_PLL_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_TOG.Reg) & 0x10000) >> 16
}
func (o *USBPHY_Type) SetPLL_SIC_TOG_PLL_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_SIC_TOG.Reg, volatile.LoadUint32(&o.PLL_SIC_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetPLL_SIC_TOG_PLL_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_SIC_TOG.Reg) & 0x80000000) >> 31
}

// USBPHY.USB1_VBUS_DETECT: USB PHY VBUS Detect Control Register
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_VBUSVALID_THRESH(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_VBUSVALID_THRESH() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x7
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_VBUS_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_VBUS_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SESSEND_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SESSEND_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_BVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_BVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_AVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_AVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_VBUSVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_VBUSVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_VBUSVALID_SEL(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_VBUSVALID_SEL() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_VBUS_SOURCE_SEL(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x600)|value<<9)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_VBUS_SOURCE_SEL() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x600) >> 9
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_PWRUP_CMPS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_PWRUP_CMPS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_DISCHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x4000000)|value<<26)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_DISCHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x4000000) >> 26
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_EN_CHARGER_RESISTOR(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_EN_CHARGER_RESISTOR() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x80000000) >> 31
}

// USBPHY.USB1_VBUS_DETECT_SET: USB PHY VBUS Detect Control Register
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_VBUSVALID_THRESH(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_VBUSVALID_THRESH() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x7
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_SESSEND_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_SESSEND_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_BVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_BVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_AVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_AVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_VBUSVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_VBUSVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_VBUSVALID_SEL(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_VBUSVALID_SEL() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x600)|value<<9)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x600) >> 9
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_PWRUP_CMPS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_PWRUP_CMPS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_DISCHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x4000000)|value<<26)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_DISCHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x4000000) >> 26
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x80000000) >> 31
}

// USBPHY.USB1_VBUS_DETECT_CLR: USB PHY VBUS Detect Control Register
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_VBUSVALID_THRESH(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_VBUSVALID_THRESH() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x7
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_SESSEND_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_SESSEND_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_BVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_BVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_AVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_AVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_VBUSVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_VBUSVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_VBUSVALID_SEL(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_VBUSVALID_SEL() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x600)|value<<9)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x600) >> 9
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_PWRUP_CMPS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_PWRUP_CMPS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_DISCHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x4000000)|value<<26)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_DISCHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x4000000) >> 26
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x80000000) >> 31
}

// USBPHY.USB1_VBUS_DETECT_TOG: USB PHY VBUS Detect Control Register
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_VBUSVALID_THRESH(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_VBUSVALID_THRESH() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x7
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_SESSEND_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_SESSEND_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_BVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_BVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_AVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_AVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_VBUSVALID_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_VBUSVALID_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_VBUSVALID_SEL(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_VBUSVALID_SEL() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x600)|value<<9)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x600) >> 9
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_PWRUP_CMPS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_PWRUP_CMPS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_DISCHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x4000000)|value<<26)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_DISCHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x4000000) >> 26
}
func (o *USBPHY_Type) SetUSB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x80000000) >> 31
}

// USBPHY.USB1_VBUS_DET_STAT: USB PHY VBUS Detector Status Register
func (o *USBPHY_Type) SetUSB1_VBUS_DET_STAT_SESSEND(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DET_STAT_SESSEND() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg) & 0x1
}
func (o *USBPHY_Type) SetUSB1_VBUS_DET_STAT_BVALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DET_STAT_BVALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetUSB1_VBUS_DET_STAT_AVALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DET_STAT_AVALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetUSB1_VBUS_DET_STAT_VBUS_VALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DET_STAT_VBUS_VALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_VBUS_DET_STAT_VBUS_VALID_3V(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_VBUS_DET_STAT_VBUS_VALID_3V() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DET_STAT.Reg) & 0x10) >> 4
}

// USBPHY.USB1_CHRG_DET_STAT: USB PHY Charger Detect Status Register
func (o *USBPHY_Type) SetUSB1_CHRG_DET_STAT_PLUG_CONTACT(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetUSB1_CHRG_DET_STAT_PLUG_CONTACT() uint32 {
	return volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg) & 0x1
}
func (o *USBPHY_Type) SetUSB1_CHRG_DET_STAT_CHRG_DETECTED(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetUSB1_CHRG_DET_STAT_CHRG_DETECTED() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetUSB1_CHRG_DET_STAT_DM_STATE(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetUSB1_CHRG_DET_STAT_DM_STATE() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetUSB1_CHRG_DET_STAT_DP_STATE(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_CHRG_DET_STAT_DP_STATE() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_CHRG_DET_STAT_SECDET_DCP(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DET_STAT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_CHRG_DET_STAT_SECDET_DCP() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DET_STAT.Reg) & 0x10) >> 4
}

// USBPHY.ANACTRL: USB PHY Analog Control Register
func (o *USBPHY_Type) SetANACTRL_TESTCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL.Reg, volatile.LoadUint32(&o.ANACTRL.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetANACTRL_TESTCLK_SEL() uint32 {
	return volatile.LoadUint32(&o.ANACTRL.Reg) & 0x1
}
func (o *USBPHY_Type) SetANACTRL_PFD_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.ANACTRL.Reg, volatile.LoadUint32(&o.ANACTRL.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetANACTRL_PFD_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetANACTRL_PFD_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL.Reg, volatile.LoadUint32(&o.ANACTRL.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetANACTRL_PFD_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetANACTRL_PFD_FRAC(value uint32) {
	volatile.StoreUint32(&o.ANACTRL.Reg, volatile.LoadUint32(&o.ANACTRL.Reg)&^(0x3f0)|value<<4)
}
func (o *USBPHY_Type) GetANACTRL_PFD_FRAC() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL.Reg) & 0x3f0) >> 4
}
func (o *USBPHY_Type) SetANACTRL_DEV_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.ANACTRL.Reg, volatile.LoadUint32(&o.ANACTRL.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetANACTRL_DEV_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetANACTRL_EMPH_PULSE_CTRL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL.Reg, volatile.LoadUint32(&o.ANACTRL.Reg)&^(0x1800)|value<<11)
}
func (o *USBPHY_Type) GetANACTRL_EMPH_PULSE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL.Reg) & 0x1800) >> 11
}
func (o *USBPHY_Type) SetANACTRL_EMPH_EN(value uint32) {
	volatile.StoreUint32(&o.ANACTRL.Reg, volatile.LoadUint32(&o.ANACTRL.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetANACTRL_EMPH_EN() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetANACTRL_EMPH_CUR_CTRL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL.Reg, volatile.LoadUint32(&o.ANACTRL.Reg)&^(0xc000)|value<<14)
}
func (o *USBPHY_Type) GetANACTRL_EMPH_CUR_CTRL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL.Reg) & 0xc000) >> 14
}
func (o *USBPHY_Type) SetANACTRL_PFD_STABLE(value uint32) {
	volatile.StoreUint32(&o.ANACTRL.Reg, volatile.LoadUint32(&o.ANACTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetANACTRL_PFD_STABLE() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL.Reg) & 0x80000000) >> 31
}

// USBPHY.ANACTRL_SET: USB PHY Analog Control Register
func (o *USBPHY_Type) SetANACTRL_SET_TESTCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_SET.Reg, volatile.LoadUint32(&o.ANACTRL_SET.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetANACTRL_SET_TESTCLK_SEL() uint32 {
	return volatile.LoadUint32(&o.ANACTRL_SET.Reg) & 0x1
}
func (o *USBPHY_Type) SetANACTRL_SET_PFD_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_SET.Reg, volatile.LoadUint32(&o.ANACTRL_SET.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetANACTRL_SET_PFD_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_SET.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetANACTRL_SET_PFD_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_SET.Reg, volatile.LoadUint32(&o.ANACTRL_SET.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetANACTRL_SET_PFD_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_SET.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetANACTRL_SET_PFD_FRAC(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_SET.Reg, volatile.LoadUint32(&o.ANACTRL_SET.Reg)&^(0x3f0)|value<<4)
}
func (o *USBPHY_Type) GetANACTRL_SET_PFD_FRAC() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_SET.Reg) & 0x3f0) >> 4
}
func (o *USBPHY_Type) SetANACTRL_SET_DEV_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_SET.Reg, volatile.LoadUint32(&o.ANACTRL_SET.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetANACTRL_SET_DEV_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_SET.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetANACTRL_SET_EMPH_PULSE_CTRL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_SET.Reg, volatile.LoadUint32(&o.ANACTRL_SET.Reg)&^(0x1800)|value<<11)
}
func (o *USBPHY_Type) GetANACTRL_SET_EMPH_PULSE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_SET.Reg) & 0x1800) >> 11
}
func (o *USBPHY_Type) SetANACTRL_SET_EMPH_EN(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_SET.Reg, volatile.LoadUint32(&o.ANACTRL_SET.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetANACTRL_SET_EMPH_EN() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_SET.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetANACTRL_SET_EMPH_CUR_CTRL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_SET.Reg, volatile.LoadUint32(&o.ANACTRL_SET.Reg)&^(0xc000)|value<<14)
}
func (o *USBPHY_Type) GetANACTRL_SET_EMPH_CUR_CTRL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_SET.Reg) & 0xc000) >> 14
}
func (o *USBPHY_Type) SetANACTRL_SET_PFD_STABLE(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_SET.Reg, volatile.LoadUint32(&o.ANACTRL_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetANACTRL_SET_PFD_STABLE() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_SET.Reg) & 0x80000000) >> 31
}

// USBPHY.ANACTRL_CLR: USB PHY Analog Control Register
func (o *USBPHY_Type) SetANACTRL_CLR_TESTCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_CLR.Reg, volatile.LoadUint32(&o.ANACTRL_CLR.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetANACTRL_CLR_TESTCLK_SEL() uint32 {
	return volatile.LoadUint32(&o.ANACTRL_CLR.Reg) & 0x1
}
func (o *USBPHY_Type) SetANACTRL_CLR_PFD_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_CLR.Reg, volatile.LoadUint32(&o.ANACTRL_CLR.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetANACTRL_CLR_PFD_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_CLR.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetANACTRL_CLR_PFD_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_CLR.Reg, volatile.LoadUint32(&o.ANACTRL_CLR.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetANACTRL_CLR_PFD_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_CLR.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetANACTRL_CLR_PFD_FRAC(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_CLR.Reg, volatile.LoadUint32(&o.ANACTRL_CLR.Reg)&^(0x3f0)|value<<4)
}
func (o *USBPHY_Type) GetANACTRL_CLR_PFD_FRAC() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_CLR.Reg) & 0x3f0) >> 4
}
func (o *USBPHY_Type) SetANACTRL_CLR_DEV_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_CLR.Reg, volatile.LoadUint32(&o.ANACTRL_CLR.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetANACTRL_CLR_DEV_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_CLR.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetANACTRL_CLR_EMPH_PULSE_CTRL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_CLR.Reg, volatile.LoadUint32(&o.ANACTRL_CLR.Reg)&^(0x1800)|value<<11)
}
func (o *USBPHY_Type) GetANACTRL_CLR_EMPH_PULSE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_CLR.Reg) & 0x1800) >> 11
}
func (o *USBPHY_Type) SetANACTRL_CLR_EMPH_EN(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_CLR.Reg, volatile.LoadUint32(&o.ANACTRL_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetANACTRL_CLR_EMPH_EN() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_CLR.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetANACTRL_CLR_EMPH_CUR_CTRL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_CLR.Reg, volatile.LoadUint32(&o.ANACTRL_CLR.Reg)&^(0xc000)|value<<14)
}
func (o *USBPHY_Type) GetANACTRL_CLR_EMPH_CUR_CTRL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_CLR.Reg) & 0xc000) >> 14
}
func (o *USBPHY_Type) SetANACTRL_CLR_PFD_STABLE(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_CLR.Reg, volatile.LoadUint32(&o.ANACTRL_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetANACTRL_CLR_PFD_STABLE() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_CLR.Reg) & 0x80000000) >> 31
}

// USBPHY.ANACTRL_TOG: USB PHY Analog Control Register
func (o *USBPHY_Type) SetANACTRL_TOG_TESTCLK_SEL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_TOG.Reg, volatile.LoadUint32(&o.ANACTRL_TOG.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetANACTRL_TOG_TESTCLK_SEL() uint32 {
	return volatile.LoadUint32(&o.ANACTRL_TOG.Reg) & 0x1
}
func (o *USBPHY_Type) SetANACTRL_TOG_PFD_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_TOG.Reg, volatile.LoadUint32(&o.ANACTRL_TOG.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetANACTRL_TOG_PFD_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_TOG.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetANACTRL_TOG_PFD_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_TOG.Reg, volatile.LoadUint32(&o.ANACTRL_TOG.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetANACTRL_TOG_PFD_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_TOG.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetANACTRL_TOG_PFD_FRAC(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_TOG.Reg, volatile.LoadUint32(&o.ANACTRL_TOG.Reg)&^(0x3f0)|value<<4)
}
func (o *USBPHY_Type) GetANACTRL_TOG_PFD_FRAC() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_TOG.Reg) & 0x3f0) >> 4
}
func (o *USBPHY_Type) SetANACTRL_TOG_DEV_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_TOG.Reg, volatile.LoadUint32(&o.ANACTRL_TOG.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetANACTRL_TOG_DEV_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_TOG.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetANACTRL_TOG_EMPH_PULSE_CTRL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_TOG.Reg, volatile.LoadUint32(&o.ANACTRL_TOG.Reg)&^(0x1800)|value<<11)
}
func (o *USBPHY_Type) GetANACTRL_TOG_EMPH_PULSE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_TOG.Reg) & 0x1800) >> 11
}
func (o *USBPHY_Type) SetANACTRL_TOG_EMPH_EN(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_TOG.Reg, volatile.LoadUint32(&o.ANACTRL_TOG.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetANACTRL_TOG_EMPH_EN() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_TOG.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetANACTRL_TOG_EMPH_CUR_CTRL(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_TOG.Reg, volatile.LoadUint32(&o.ANACTRL_TOG.Reg)&^(0xc000)|value<<14)
}
func (o *USBPHY_Type) GetANACTRL_TOG_EMPH_CUR_CTRL() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_TOG.Reg) & 0xc000) >> 14
}
func (o *USBPHY_Type) SetANACTRL_TOG_PFD_STABLE(value uint32) {
	volatile.StoreUint32(&o.ANACTRL_TOG.Reg, volatile.LoadUint32(&o.ANACTRL_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetANACTRL_TOG_PFD_STABLE() uint32 {
	return (volatile.LoadUint32(&o.ANACTRL_TOG.Reg) & 0x80000000) >> 31
}

// USBPHY.USB1_LOOPBACK: USB PHY Loopback Control/Status Register
func (o *USBPHY_Type) SetUSB1_LOOPBACK_UTMI_TESTSTART(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_UTMI_TESTSTART() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x1
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_UTMI_DIG_TST0(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_UTMI_DIG_TST0() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_UTMI_DIG_TST1(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_UTMI_DIG_TST1() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TSTI_TX_HS_MODE(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TSTI_TX_HS_MODE() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TSTI_TX_LS_MODE(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TSTI_TX_LS_MODE() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TSTI_TX_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TSTI_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TSTI_TX_HIZ(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TSTI_TX_HIZ() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_UTMO_DIG_TST0(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_UTMO_DIG_TST0() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_UTMO_DIG_TST1(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_UTMO_DIG_TST1() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TSTI_HSFS_MODE_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TSTI_HSFS_MODE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TSTPKT(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0xff0000)|value<<16)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TSTPKT() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0xff0000) >> 16
}

// USBPHY.USB1_LOOPBACK_SET: USB PHY Loopback Control/Status Register
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_UTMI_TESTSTART(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_UTMI_TESTSTART() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x1
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_UTMI_DIG_TST0(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_UTMI_DIG_TST0() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_UTMI_DIG_TST1(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_UTMI_DIG_TST1() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_TSTI_TX_HS_MODE(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_TSTI_TX_HS_MODE() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_TSTI_TX_LS_MODE(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_TSTI_TX_LS_MODE() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_TSTI_TX_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_TSTI_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_TSTI_TX_HIZ(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_TSTI_TX_HIZ() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_UTMO_DIG_TST0(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_UTMO_DIG_TST0() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_UTMO_DIG_TST1(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_UTMO_DIG_TST1() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_TSTI_HSFS_MODE_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_TSTI_HSFS_MODE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_SET_TSTPKT(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0xff0000)|value<<16)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_SET_TSTPKT() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0xff0000) >> 16
}

// USBPHY.USB1_LOOPBACK_CLR: USB PHY Loopback Control/Status Register
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_UTMI_TESTSTART(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_UTMI_TESTSTART() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x1
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_UTMI_DIG_TST0(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_UTMI_DIG_TST0() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_UTMI_DIG_TST1(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_UTMI_DIG_TST1() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_TSTI_TX_HS_MODE(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_TSTI_TX_HS_MODE() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_TSTI_TX_LS_MODE(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_TSTI_TX_LS_MODE() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_TSTI_TX_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_TSTI_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_TSTI_TX_HIZ(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_TSTI_TX_HIZ() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_UTMO_DIG_TST0(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_UTMO_DIG_TST0() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_UTMO_DIG_TST1(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_UTMO_DIG_TST1() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_TSTI_HSFS_MODE_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_TSTI_HSFS_MODE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_CLR_TSTPKT(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0xff0000)|value<<16)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_CLR_TSTPKT() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0xff0000) >> 16
}

// USBPHY.USB1_LOOPBACK_TOG: USB PHY Loopback Control/Status Register
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_UTMI_TESTSTART(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_UTMI_TESTSTART() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x1
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_UTMI_DIG_TST0(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_UTMI_DIG_TST0() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_UTMI_DIG_TST1(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_UTMI_DIG_TST1() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_TSTI_TX_HS_MODE(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_TSTI_TX_HS_MODE() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_TSTI_TX_LS_MODE(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_TSTI_TX_LS_MODE() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_TSTI_TX_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_TSTI_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_TSTI_TX_HIZ(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_TSTI_TX_HIZ() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_UTMO_DIG_TST0(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_UTMO_DIG_TST0() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_UTMO_DIG_TST1(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_UTMO_DIG_TST1() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_TSTI_HSFS_MODE_EN(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_TSTI_HSFS_MODE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_TOG_TSTPKT(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0xff0000)|value<<16)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_TOG_TSTPKT() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0xff0000) >> 16
}

// USBPHY.USB1_LOOPBACK_HSFSCNT: USB PHY Loopback Packet Number Select Register
func (o *USBPHY_Type) SetUSB1_LOOPBACK_HSFSCNT_TSTI_HS_NUMBER(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_HSFSCNT.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT.Reg)&^(0xffff)|value)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_HSFSCNT_TSTI_HS_NUMBER() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT.Reg) & 0xffff
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_HSFSCNT_TSTI_FS_NUMBER(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_HSFSCNT.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT.Reg)&^(0xffff0000)|value<<16)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_HSFSCNT_TSTI_FS_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT.Reg) & 0xffff0000) >> 16
}

// USBPHY.USB1_LOOPBACK_HSFSCNT_SET: USB PHY Loopback Packet Number Select Register
func (o *USBPHY_Type) SetUSB1_LOOPBACK_HSFSCNT_SET_TSTI_HS_NUMBER(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_HSFSCNT_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_SET.Reg)&^(0xffff)|value)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_HSFSCNT_SET_TSTI_HS_NUMBER() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_SET.Reg) & 0xffff
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_HSFSCNT_SET_TSTI_FS_NUMBER(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_HSFSCNT_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_HSFSCNT_SET_TSTI_FS_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_SET.Reg) & 0xffff0000) >> 16
}

// USBPHY.USB1_LOOPBACK_HSFSCNT_CLR: USB PHY Loopback Packet Number Select Register
func (o *USBPHY_Type) SetUSB1_LOOPBACK_HSFSCNT_CLR_TSTI_HS_NUMBER(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_HSFSCNT_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_CLR.Reg)&^(0xffff)|value)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_HSFSCNT_CLR_TSTI_HS_NUMBER() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_CLR.Reg) & 0xffff
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_HSFSCNT_CLR_TSTI_FS_NUMBER(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_HSFSCNT_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_HSFSCNT_CLR_TSTI_FS_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_CLR.Reg) & 0xffff0000) >> 16
}

// USBPHY.USB1_LOOPBACK_HSFSCNT_TOG: USB PHY Loopback Packet Number Select Register
func (o *USBPHY_Type) SetUSB1_LOOPBACK_HSFSCNT_TOG_TSTI_HS_NUMBER(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_HSFSCNT_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_TOG.Reg)&^(0xffff)|value)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_HSFSCNT_TOG_TSTI_HS_NUMBER() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_TOG.Reg) & 0xffff
}
func (o *USBPHY_Type) SetUSB1_LOOPBACK_HSFSCNT_TOG_TSTI_FS_NUMBER(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_HSFSCNT_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_TOG.Reg)&^(0xffff0000)|value<<16)
}
func (o *USBPHY_Type) GetUSB1_LOOPBACK_HSFSCNT_TOG_TSTI_FS_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.USB1_LOOPBACK_HSFSCNT_TOG.Reg) & 0xffff0000) >> 16
}

// USBPHY.TRIM_OVERRIDE_EN: USB PHY Trim Override Enable Register
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_DIV_SEL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_DIV_SEL_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0x1
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_TX_D_CAL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_TX_D_CAL_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_TX_CAL45DP_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_TX_CAL45DP_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_TX_CAL45DM_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_TX_CAL45DM_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_PLL_CTRL0_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0x30000)|value<<16)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_PLL_CTRL0_DIV_SEL() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0x30000) >> 16
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_USB_REG_ENV_TAIL_ADJ_VD(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0xc0000)|value<<18)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_USB_REG_ENV_TAIL_ADJ_VD() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0xc0000) >> 18
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_USBPHY_TX_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0xf00000)|value<<20)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_USBPHY_TX_D_CAL() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0xf00000) >> 20
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DP(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0xf000000)|value<<24)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0xf000000) >> 24
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DM(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg)&^(0xf0000000)|value<<28)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DM() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN.Reg) & 0xf0000000) >> 28
}

// USBPHY.TRIM_OVERRIDE_EN_SET: USB PHY Trim Override Enable Register
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_DIV_SEL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_DIV_SEL_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0x1
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_TX_D_CAL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_TX_D_CAL_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DP_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DP_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DM_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DM_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_PLL_CTRL0_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0x30000)|value<<16)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_PLL_CTRL0_DIV_SEL() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0x30000) >> 16
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_USB_REG_ENV_TAIL_ADJ_VD(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0xc0000)|value<<18)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_USB_REG_ENV_TAIL_ADJ_VD() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0xc0000) >> 18
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0xf00000)|value<<20)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_D_CAL() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0xf00000) >> 20
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DP(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0xf000000)|value<<24)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0xf000000) >> 24
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DM(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_SET.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg)&^(0xf0000000)|value<<28)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DM() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_SET.Reg) & 0xf0000000) >> 28
}

// USBPHY.TRIM_OVERRIDE_EN_CLR: USB PHY Trim Override Enable Register
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_DIV_SEL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_DIV_SEL_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0x1
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_TX_D_CAL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_TX_D_CAL_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DP_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DP_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DM_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DM_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_PLL_CTRL0_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0x30000)|value<<16)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_PLL_CTRL0_DIV_SEL() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0x30000) >> 16
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_USB_REG_ENV_TAIL_ADJ_VD(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0xc0000)|value<<18)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_USB_REG_ENV_TAIL_ADJ_VD() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0xc0000) >> 18
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0xf00000)|value<<20)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_D_CAL() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0xf00000) >> 20
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DP(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0xf000000)|value<<24)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0xf000000) >> 24
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DM(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg)&^(0xf0000000)|value<<28)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DM() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_CLR.Reg) & 0xf0000000) >> 28
}

// USBPHY.TRIM_OVERRIDE_EN_TOG: USB PHY Trim Override Enable Register
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_DIV_SEL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_DIV_SEL_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0x1
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_TX_D_CAL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_TX_D_CAL_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DP_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DP_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DM_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DM_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_PLL_CTRL0_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0x30000)|value<<16)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_PLL_CTRL0_DIV_SEL() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0x30000) >> 16
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_USB_REG_ENV_TAIL_ADJ_VD(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0xc0000)|value<<18)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_USB_REG_ENV_TAIL_ADJ_VD() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0xc0000) >> 18
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0xf00000)|value<<20)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_D_CAL() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0xf00000) >> 20
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DP(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0xf000000)|value<<24)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0xf000000) >> 24
}
func (o *USBPHY_Type) SetTRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DM(value uint32) {
	volatile.StoreUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg, volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg)&^(0xf0000000)|value<<28)
}
func (o *USBPHY_Type) GetTRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DM() uint32 {
	return (volatile.LoadUint32(&o.TRIM_OVERRIDE_EN_TOG.Reg) & 0xf0000000) >> 28
}

// USB Device Charger Detection module
type USBHSDCD_Type struct {
	CONTROL         volatile.Register32 // 0x0
	CLOCK           volatile.Register32 // 0x4
	STATUS          volatile.Register32 // 0x8
	SIGNAL_OVERRIDE volatile.Register32 // 0xC
	TIMER0          volatile.Register32 // 0x10
	TIMER1          volatile.Register32 // 0x14
	TIMER2_BC11     volatile.Register32 // 0x18
}

// USBHSDCD.CONTROL: Control register
func (o *USBHSDCD_Type) SetCONTROL_IACK(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x1)|value)
}
func (o *USBHSDCD_Type) GetCONTROL_IACK() uint32 {
	return volatile.LoadUint32(&o.CONTROL.Reg) & 0x1
}
func (o *USBHSDCD_Type) SetCONTROL_IF(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x100)|value<<8)
}
func (o *USBHSDCD_Type) GetCONTROL_IF() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x100) >> 8
}
func (o *USBHSDCD_Type) SetCONTROL_IE(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x10000)|value<<16)
}
func (o *USBHSDCD_Type) GetCONTROL_IE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x10000) >> 16
}
func (o *USBHSDCD_Type) SetCONTROL_BC12(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x20000)|value<<17)
}
func (o *USBHSDCD_Type) GetCONTROL_BC12() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x20000) >> 17
}
func (o *USBHSDCD_Type) SetCONTROL_START(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *USBHSDCD_Type) GetCONTROL_START() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x1000000) >> 24
}
func (o *USBHSDCD_Type) SetCONTROL_SR(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *USBHSDCD_Type) GetCONTROL_SR() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x2000000) >> 25
}

// USBHSDCD.CLOCK: Clock register
func (o *USBHSDCD_Type) SetCLOCK_CLOCK_UNIT(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x1)|value)
}
func (o *USBHSDCD_Type) GetCLOCK_CLOCK_UNIT() uint32 {
	return volatile.LoadUint32(&o.CLOCK.Reg) & 0x1
}
func (o *USBHSDCD_Type) SetCLOCK_CLOCK_SPEED(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0xffc)|value<<2)
}
func (o *USBHSDCD_Type) GetCLOCK_CLOCK_SPEED() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0xffc) >> 2
}

// USBHSDCD.STATUS: Status register
func (o *USBHSDCD_Type) SetSTATUS_SEQ_RES(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x30000)|value<<16)
}
func (o *USBHSDCD_Type) GetSTATUS_SEQ_RES() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x30000) >> 16
}
func (o *USBHSDCD_Type) SetSTATUS_SEQ_STAT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xc0000)|value<<18)
}
func (o *USBHSDCD_Type) GetSTATUS_SEQ_STAT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xc0000) >> 18
}
func (o *USBHSDCD_Type) SetSTATUS_ERR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100000)|value<<20)
}
func (o *USBHSDCD_Type) GetSTATUS_ERR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100000) >> 20
}
func (o *USBHSDCD_Type) SetSTATUS_TO(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *USBHSDCD_Type) GetSTATUS_TO() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200000) >> 21
}
func (o *USBHSDCD_Type) SetSTATUS_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400000)|value<<22)
}
func (o *USBHSDCD_Type) GetSTATUS_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400000) >> 22
}

// USBHSDCD.SIGNAL_OVERRIDE: Signal Override Register
func (o *USBHSDCD_Type) SetSIGNAL_OVERRIDE_PS(value uint32) {
	volatile.StoreUint32(&o.SIGNAL_OVERRIDE.Reg, volatile.LoadUint32(&o.SIGNAL_OVERRIDE.Reg)&^(0x3)|value)
}
func (o *USBHSDCD_Type) GetSIGNAL_OVERRIDE_PS() uint32 {
	return volatile.LoadUint32(&o.SIGNAL_OVERRIDE.Reg) & 0x3
}

// USBHSDCD.TIMER0: TIMER0 register
func (o *USBHSDCD_Type) SetTIMER0_TUNITCON(value uint32) {
	volatile.StoreUint32(&o.TIMER0.Reg, volatile.LoadUint32(&o.TIMER0.Reg)&^(0xfff)|value)
}
func (o *USBHSDCD_Type) GetTIMER0_TUNITCON() uint32 {
	return volatile.LoadUint32(&o.TIMER0.Reg) & 0xfff
}
func (o *USBHSDCD_Type) SetTIMER0_TSEQ_INIT(value uint32) {
	volatile.StoreUint32(&o.TIMER0.Reg, volatile.LoadUint32(&o.TIMER0.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBHSDCD_Type) GetTIMER0_TSEQ_INIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER0.Reg) & 0x3ff0000) >> 16
}

// USBHSDCD.TIMER1: TIMER1 register
func (o *USBHSDCD_Type) SetTIMER1_TVDPSRC_ON(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3ff)|value)
}
func (o *USBHSDCD_Type) GetTIMER1_TVDPSRC_ON() uint32 {
	return volatile.LoadUint32(&o.TIMER1.Reg) & 0x3ff
}
func (o *USBHSDCD_Type) SetTIMER1_TDCD_DBNC(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBHSDCD_Type) GetTIMER1_TDCD_DBNC() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0x3ff0000) >> 16
}

// USBHSDCD.TIMER2_BC11: TIMER2_BC11 register
func (o *USBHSDCD_Type) SetTIMER2_BC11_CHECK_DM(value uint32) {
	volatile.StoreUint32(&o.TIMER2_BC11.Reg, volatile.LoadUint32(&o.TIMER2_BC11.Reg)&^(0xf)|value)
}
func (o *USBHSDCD_Type) GetTIMER2_BC11_CHECK_DM() uint32 {
	return volatile.LoadUint32(&o.TIMER2_BC11.Reg) & 0xf
}
func (o *USBHSDCD_Type) SetTIMER2_BC11_TVDPSRC_CON(value uint32) {
	volatile.StoreUint32(&o.TIMER2_BC11.Reg, volatile.LoadUint32(&o.TIMER2_BC11.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBHSDCD_Type) GetTIMER2_BC11_TVDPSRC_CON() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_BC11.Reg) & 0x3ff0000) >> 16
}

// Secured Digital Host Controller
type SDHC_Type struct {
	DSADDR    volatile.Register32 // 0x0
	BLKATTR   volatile.Register32 // 0x4
	CMDARG    volatile.Register32 // 0x8
	XFERTYP   volatile.Register32 // 0xC
	CMDRSP0   volatile.Register32 // 0x10
	CMDRSP1   volatile.Register32 // 0x14
	CMDRSP2   volatile.Register32 // 0x18
	CMDRSP3   volatile.Register32 // 0x1C
	DATPORT   volatile.Register32 // 0x20
	PRSSTAT   volatile.Register32 // 0x24
	PROCTL    volatile.Register32 // 0x28
	SYSCTL    volatile.Register32 // 0x2C
	IRQSTAT   volatile.Register32 // 0x30
	IRQSTATEN volatile.Register32 // 0x34
	IRQSIGEN  volatile.Register32 // 0x38
	AC12ERR   volatile.Register32 // 0x3C
	HTCAPBLT  volatile.Register32 // 0x40
	WML       volatile.Register32 // 0x44
	_         [8]byte
	FEVT      volatile.Register32 // 0x50
	ADMAES    volatile.Register32 // 0x54
	ADSADDR   volatile.Register32 // 0x58
	_         [100]byte
	VENDOR    volatile.Register32 // 0xC0
	MMCBOOT   volatile.Register32 // 0xC4
	_         [52]byte
	HOSTVER   volatile.Register32 // 0xFC
}

// SDHC.DSADDR: DMA System Address register
func (o *SDHC_Type) SetDSADDR(value uint32) {
	volatile.StoreUint32(&o.DSADDR.Reg, volatile.LoadUint32(&o.DSADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SDHC_Type) GetDSADDR() uint32 {
	return (volatile.LoadUint32(&o.DSADDR.Reg) & 0xfffffffc) >> 2
}

// SDHC.BLKATTR: Block Attributes register
func (o *SDHC_Type) SetBLKATTR_BLKSIZE(value uint32) {
	volatile.StoreUint32(&o.BLKATTR.Reg, volatile.LoadUint32(&o.BLKATTR.Reg)&^(0x1fff)|value)
}
func (o *SDHC_Type) GetBLKATTR_BLKSIZE() uint32 {
	return volatile.LoadUint32(&o.BLKATTR.Reg) & 0x1fff
}
func (o *SDHC_Type) SetBLKATTR_BLKCNT(value uint32) {
	volatile.StoreUint32(&o.BLKATTR.Reg, volatile.LoadUint32(&o.BLKATTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SDHC_Type) GetBLKATTR_BLKCNT() uint32 {
	return (volatile.LoadUint32(&o.BLKATTR.Reg) & 0xffff0000) >> 16
}

// SDHC.CMDARG: Command Argument register
func (o *SDHC_Type) SetCMDARG(value uint32) {
	volatile.StoreUint32(&o.CMDARG.Reg, value)
}
func (o *SDHC_Type) GetCMDARG() uint32 {
	return volatile.LoadUint32(&o.CMDARG.Reg)
}

// SDHC.XFERTYP: Transfer Type register
func (o *SDHC_Type) SetXFERTYP_DMAEN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetXFERTYP_DMAEN() uint32 {
	return volatile.LoadUint32(&o.XFERTYP.Reg) & 0x1
}
func (o *SDHC_Type) SetXFERTYP_BCEN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetXFERTYP_BCEN() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetXFERTYP_AC12EN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetXFERTYP_AC12EN() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetXFERTYP_DTDSEL(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetXFERTYP_DTDSEL() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetXFERTYP_MSBSEL(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetXFERTYP_MSBSEL() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetXFERTYP_RSPTYP(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x30000)|value<<16)
}
func (o *SDHC_Type) GetXFERTYP_RSPTYP() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x30000) >> 16
}
func (o *SDHC_Type) SetXFERTYP_CCCEN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetXFERTYP_CCCEN() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetXFERTYP_CICEN(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetXFERTYP_CICEN() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetXFERTYP_DPSEL(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetXFERTYP_DPSEL() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetXFERTYP_CMDTYP(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0xc00000)|value<<22)
}
func (o *SDHC_Type) GetXFERTYP_CMDTYP() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0xc00000) >> 22
}
func (o *SDHC_Type) SetXFERTYP_CMDINX(value uint32) {
	volatile.StoreUint32(&o.XFERTYP.Reg, volatile.LoadUint32(&o.XFERTYP.Reg)&^(0x3f000000)|value<<24)
}
func (o *SDHC_Type) GetXFERTYP_CMDINX() uint32 {
	return (volatile.LoadUint32(&o.XFERTYP.Reg) & 0x3f000000) >> 24
}

// SDHC.CMDRSP0: Command Response 0
func (o *SDHC_Type) SetCMDRSP0(value uint32) {
	volatile.StoreUint32(&o.CMDRSP0.Reg, value)
}
func (o *SDHC_Type) GetCMDRSP0() uint32 {
	return volatile.LoadUint32(&o.CMDRSP0.Reg)
}

// SDHC.CMDRSP1: Command Response 1
func (o *SDHC_Type) SetCMDRSP1(value uint32) {
	volatile.StoreUint32(&o.CMDRSP1.Reg, value)
}
func (o *SDHC_Type) GetCMDRSP1() uint32 {
	return volatile.LoadUint32(&o.CMDRSP1.Reg)
}

// SDHC.CMDRSP2: Command Response 2
func (o *SDHC_Type) SetCMDRSP2(value uint32) {
	volatile.StoreUint32(&o.CMDRSP2.Reg, value)
}
func (o *SDHC_Type) GetCMDRSP2() uint32 {
	return volatile.LoadUint32(&o.CMDRSP2.Reg)
}

// SDHC.CMDRSP3: Command Response 3
func (o *SDHC_Type) SetCMDRSP3(value uint32) {
	volatile.StoreUint32(&o.CMDRSP3.Reg, value)
}
func (o *SDHC_Type) GetCMDRSP3() uint32 {
	return volatile.LoadUint32(&o.CMDRSP3.Reg)
}

// SDHC.DATPORT: Buffer Data Port register
func (o *SDHC_Type) SetDATPORT(value uint32) {
	volatile.StoreUint32(&o.DATPORT.Reg, value)
}
func (o *SDHC_Type) GetDATPORT() uint32 {
	return volatile.LoadUint32(&o.DATPORT.Reg)
}

// SDHC.PRSSTAT: Present State register
func (o *SDHC_Type) SetPRSSTAT_CIHB(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetPRSSTAT_CIHB() uint32 {
	return volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x1
}
func (o *SDHC_Type) SetPRSSTAT_CDIHB(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetPRSSTAT_CDIHB() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetPRSSTAT_DLA(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetPRSSTAT_DLA() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetPRSSTAT_SDSTB(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetPRSSTAT_SDSTB() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetPRSSTAT_IPGOFF(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetPRSSTAT_IPGOFF() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetPRSSTAT_HCKOFF(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetPRSSTAT_HCKOFF() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetPRSSTAT_PEROFF(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetPRSSTAT_PEROFF() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetPRSSTAT_SDOFF(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetPRSSTAT_SDOFF() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetPRSSTAT_WTA(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetPRSSTAT_WTA() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetPRSSTAT_RTA(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x200)|value<<9)
}
func (o *SDHC_Type) GetPRSSTAT_RTA() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x200) >> 9
}
func (o *SDHC_Type) SetPRSSTAT_BWEN(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x400)|value<<10)
}
func (o *SDHC_Type) GetPRSSTAT_BWEN() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x400) >> 10
}
func (o *SDHC_Type) SetPRSSTAT_BREN(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x800)|value<<11)
}
func (o *SDHC_Type) GetPRSSTAT_BREN() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x800) >> 11
}
func (o *SDHC_Type) SetPRSSTAT_CINS(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetPRSSTAT_CINS() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetPRSSTAT_CLSL(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0x800000)|value<<23)
}
func (o *SDHC_Type) GetPRSSTAT_CLSL() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0x800000) >> 23
}
func (o *SDHC_Type) SetPRSSTAT_DLSL(value uint32) {
	volatile.StoreUint32(&o.PRSSTAT.Reg, volatile.LoadUint32(&o.PRSSTAT.Reg)&^(0xff000000)|value<<24)
}
func (o *SDHC_Type) GetPRSSTAT_DLSL() uint32 {
	return (volatile.LoadUint32(&o.PRSSTAT.Reg) & 0xff000000) >> 24
}

// SDHC.PROCTL: Protocol Control register
func (o *SDHC_Type) SetPROCTL_LCTL(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetPROCTL_LCTL() uint32 {
	return volatile.LoadUint32(&o.PROCTL.Reg) & 0x1
}
func (o *SDHC_Type) SetPROCTL_DTW(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x6)|value<<1)
}
func (o *SDHC_Type) GetPROCTL_DTW() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x6) >> 1
}
func (o *SDHC_Type) SetPROCTL_D3CD(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetPROCTL_D3CD() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetPROCTL_EMODE(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x30)|value<<4)
}
func (o *SDHC_Type) GetPROCTL_EMODE() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x30) >> 4
}
func (o *SDHC_Type) SetPROCTL_CDTL(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetPROCTL_CDTL() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetPROCTL_CDSS(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetPROCTL_CDSS() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetPROCTL_DMAS(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x300)|value<<8)
}
func (o *SDHC_Type) GetPROCTL_DMAS() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x300) >> 8
}
func (o *SDHC_Type) SetPROCTL_SABGREQ(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetPROCTL_SABGREQ() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetPROCTL_CREQ(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetPROCTL_CREQ() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetPROCTL_RWCTL(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetPROCTL_RWCTL() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetPROCTL_IABG(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetPROCTL_IABG() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetPROCTL_WECINT(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetPROCTL_WECINT() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetPROCTL_WECINS(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x2000000)|value<<25)
}
func (o *SDHC_Type) GetPROCTL_WECINS() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x2000000) >> 25
}
func (o *SDHC_Type) SetPROCTL_WECRM(value uint32) {
	volatile.StoreUint32(&o.PROCTL.Reg, volatile.LoadUint32(&o.PROCTL.Reg)&^(0x4000000)|value<<26)
}
func (o *SDHC_Type) GetPROCTL_WECRM() uint32 {
	return (volatile.LoadUint32(&o.PROCTL.Reg) & 0x4000000) >> 26
}

// SDHC.SYSCTL: System Control register
func (o *SDHC_Type) SetSYSCTL_IPGEN(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetSYSCTL_IPGEN() uint32 {
	return volatile.LoadUint32(&o.SYSCTL.Reg) & 0x1
}
func (o *SDHC_Type) SetSYSCTL_HCKEN(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetSYSCTL_HCKEN() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetSYSCTL_PEREN(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetSYSCTL_PEREN() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetSYSCTL_SDCLKEN(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetSYSCTL_SDCLKEN() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetSYSCTL_DVS(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0xf0)|value<<4)
}
func (o *SDHC_Type) GetSYSCTL_DVS() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0xf0) >> 4
}
func (o *SDHC_Type) SetSYSCTL_SDCLKFS(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0xff00)|value<<8)
}
func (o *SDHC_Type) GetSYSCTL_SDCLKFS() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0xff00) >> 8
}
func (o *SDHC_Type) SetSYSCTL_DTOCV(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0xf0000)|value<<16)
}
func (o *SDHC_Type) GetSYSCTL_DTOCV() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0xf0000) >> 16
}
func (o *SDHC_Type) SetSYSCTL_RSTA(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetSYSCTL_RSTA() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetSYSCTL_RSTC(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x2000000)|value<<25)
}
func (o *SDHC_Type) GetSYSCTL_RSTC() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x2000000) >> 25
}
func (o *SDHC_Type) SetSYSCTL_RSTD(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x4000000)|value<<26)
}
func (o *SDHC_Type) GetSYSCTL_RSTD() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x4000000) >> 26
}
func (o *SDHC_Type) SetSYSCTL_INITA(value uint32) {
	volatile.StoreUint32(&o.SYSCTL.Reg, volatile.LoadUint32(&o.SYSCTL.Reg)&^(0x8000000)|value<<27)
}
func (o *SDHC_Type) GetSYSCTL_INITA() uint32 {
	return (volatile.LoadUint32(&o.SYSCTL.Reg) & 0x8000000) >> 27
}

// SDHC.IRQSTAT: Interrupt Status register
func (o *SDHC_Type) SetIRQSTAT_CC(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetIRQSTAT_CC() uint32 {
	return volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x1
}
func (o *SDHC_Type) SetIRQSTAT_TC(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetIRQSTAT_TC() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetIRQSTAT_BGE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetIRQSTAT_BGE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetIRQSTAT_DINT(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetIRQSTAT_DINT() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetIRQSTAT_BWR(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetIRQSTAT_BWR() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetIRQSTAT_BRR(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetIRQSTAT_BRR() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetIRQSTAT_CINS(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetIRQSTAT_CINS() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetIRQSTAT_CRM(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetIRQSTAT_CRM() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetIRQSTAT_CINT(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetIRQSTAT_CINT() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetIRQSTAT_CTOE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetIRQSTAT_CTOE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetIRQSTAT_CCE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetIRQSTAT_CCE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetIRQSTAT_CEBE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetIRQSTAT_CEBE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetIRQSTAT_CIE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetIRQSTAT_CIE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetIRQSTAT_DTOE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetIRQSTAT_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetIRQSTAT_DCE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetIRQSTAT_DCE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetIRQSTAT_DEBE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetIRQSTAT_DEBE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetIRQSTAT_AC12E(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetIRQSTAT_AC12E() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetIRQSTAT_DMAE(value uint32) {
	volatile.StoreUint32(&o.IRQSTAT.Reg, volatile.LoadUint32(&o.IRQSTAT.Reg)&^(0x10000000)|value<<28)
}
func (o *SDHC_Type) GetIRQSTAT_DMAE() uint32 {
	return (volatile.LoadUint32(&o.IRQSTAT.Reg) & 0x10000000) >> 28
}

// SDHC.IRQSTATEN: Interrupt Status Enable register
func (o *SDHC_Type) SetIRQSTATEN_CCSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetIRQSTATEN_CCSEN() uint32 {
	return volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x1
}
func (o *SDHC_Type) SetIRQSTATEN_TCSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetIRQSTATEN_TCSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetIRQSTATEN_BGESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetIRQSTATEN_BGESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetIRQSTATEN_DINTSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetIRQSTATEN_DINTSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetIRQSTATEN_BWRSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetIRQSTATEN_BWRSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetIRQSTATEN_BRRSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetIRQSTATEN_BRRSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetIRQSTATEN_CINSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetIRQSTATEN_CINSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetIRQSTATEN_CRMSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetIRQSTATEN_CRMSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetIRQSTATEN_CINTSEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetIRQSTATEN_CINTSEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetIRQSTATEN_CTOESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetIRQSTATEN_CTOESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetIRQSTATEN_CCESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetIRQSTATEN_CCESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetIRQSTATEN_CEBESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetIRQSTATEN_CEBESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetIRQSTATEN_CIESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetIRQSTATEN_CIESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetIRQSTATEN_DTOESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetIRQSTATEN_DTOESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetIRQSTATEN_DCESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetIRQSTATEN_DCESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetIRQSTATEN_DEBESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetIRQSTATEN_DEBESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetIRQSTATEN_AC12ESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetIRQSTATEN_AC12ESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetIRQSTATEN_DMAESEN(value uint32) {
	volatile.StoreUint32(&o.IRQSTATEN.Reg, volatile.LoadUint32(&o.IRQSTATEN.Reg)&^(0x10000000)|value<<28)
}
func (o *SDHC_Type) GetIRQSTATEN_DMAESEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSTATEN.Reg) & 0x10000000) >> 28
}

// SDHC.IRQSIGEN: Interrupt Signal Enable register
func (o *SDHC_Type) SetIRQSIGEN_CCIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetIRQSIGEN_CCIEN() uint32 {
	return volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x1
}
func (o *SDHC_Type) SetIRQSIGEN_TCIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetIRQSIGEN_TCIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetIRQSIGEN_BGEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetIRQSIGEN_BGEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetIRQSIGEN_DINTIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetIRQSIGEN_DINTIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetIRQSIGEN_BWRIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetIRQSIGEN_BWRIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetIRQSIGEN_BRRIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetIRQSIGEN_BRRIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetIRQSIGEN_CINSIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetIRQSIGEN_CINSIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetIRQSIGEN_CRMIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetIRQSIGEN_CRMIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetIRQSIGEN_CINTIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetIRQSIGEN_CINTIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetIRQSIGEN_CTOEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetIRQSIGEN_CTOEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetIRQSIGEN_CCEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetIRQSIGEN_CCEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetIRQSIGEN_CEBEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetIRQSIGEN_CEBEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetIRQSIGEN_CIEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetIRQSIGEN_CIEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetIRQSIGEN_DTOEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetIRQSIGEN_DTOEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetIRQSIGEN_DCEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetIRQSIGEN_DCEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetIRQSIGEN_DEBEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetIRQSIGEN_DEBEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetIRQSIGEN_AC12EIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetIRQSIGEN_AC12EIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetIRQSIGEN_DMAEIEN(value uint32) {
	volatile.StoreUint32(&o.IRQSIGEN.Reg, volatile.LoadUint32(&o.IRQSIGEN.Reg)&^(0x10000000)|value<<28)
}
func (o *SDHC_Type) GetIRQSIGEN_DMAEIEN() uint32 {
	return (volatile.LoadUint32(&o.IRQSIGEN.Reg) & 0x10000000) >> 28
}

// SDHC.AC12ERR: Auto CMD12 Error Status Register
func (o *SDHC_Type) SetAC12ERR_AC12NE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetAC12ERR_AC12NE() uint32 {
	return volatile.LoadUint32(&o.AC12ERR.Reg) & 0x1
}
func (o *SDHC_Type) SetAC12ERR_AC12TOE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetAC12ERR_AC12TOE() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetAC12ERR_AC12EBE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetAC12ERR_AC12EBE() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetAC12ERR_AC12CE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetAC12ERR_AC12CE() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetAC12ERR_AC12IE(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetAC12ERR_AC12IE() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetAC12ERR_CNIBAC12E(value uint32) {
	volatile.StoreUint32(&o.AC12ERR.Reg, volatile.LoadUint32(&o.AC12ERR.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetAC12ERR_CNIBAC12E() uint32 {
	return (volatile.LoadUint32(&o.AC12ERR.Reg) & 0x80) >> 7
}

// SDHC.HTCAPBLT: Host Controller Capabilities
func (o *SDHC_Type) SetHTCAPBLT_MBL(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x70000)|value<<16)
}
func (o *SDHC_Type) GetHTCAPBLT_MBL() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x70000) >> 16
}
func (o *SDHC_Type) SetHTCAPBLT_ADMAS(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetHTCAPBLT_ADMAS() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetHTCAPBLT_HSS(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetHTCAPBLT_HSS() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetHTCAPBLT_DMAS(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetHTCAPBLT_DMAS() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetHTCAPBLT_SRS(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x800000)|value<<23)
}
func (o *SDHC_Type) GetHTCAPBLT_SRS() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x800000) >> 23
}
func (o *SDHC_Type) SetHTCAPBLT_VS33(value uint32) {
	volatile.StoreUint32(&o.HTCAPBLT.Reg, volatile.LoadUint32(&o.HTCAPBLT.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetHTCAPBLT_VS33() uint32 {
	return (volatile.LoadUint32(&o.HTCAPBLT.Reg) & 0x1000000) >> 24
}

// SDHC.WML: Watermark Level Register
func (o *SDHC_Type) SetWML_RDWML(value uint32) {
	volatile.StoreUint32(&o.WML.Reg, volatile.LoadUint32(&o.WML.Reg)&^(0xff)|value)
}
func (o *SDHC_Type) GetWML_RDWML() uint32 {
	return volatile.LoadUint32(&o.WML.Reg) & 0xff
}
func (o *SDHC_Type) SetWML_WRWML(value uint32) {
	volatile.StoreUint32(&o.WML.Reg, volatile.LoadUint32(&o.WML.Reg)&^(0xff0000)|value<<16)
}
func (o *SDHC_Type) GetWML_WRWML() uint32 {
	return (volatile.LoadUint32(&o.WML.Reg) & 0xff0000) >> 16
}

// SDHC.FEVT: Force Event register
func (o *SDHC_Type) SetFEVT_AC12NE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetFEVT_AC12NE() uint32 {
	return volatile.LoadUint32(&o.FEVT.Reg) & 0x1
}
func (o *SDHC_Type) SetFEVT_AC12TOE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetFEVT_AC12TOE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetFEVT_AC12CE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetFEVT_AC12CE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetFEVT_AC12EBE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetFEVT_AC12EBE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetFEVT_AC12IE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetFEVT_AC12IE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetFEVT_CNIBAC12E(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetFEVT_CNIBAC12E() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetFEVT_CTOE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetFEVT_CTOE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetFEVT_CCE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetFEVT_CCE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetFEVT_CEBE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetFEVT_CEBE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetFEVT_CIE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetFEVT_CIE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetFEVT_DTOE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x100000)|value<<20)
}
func (o *SDHC_Type) GetFEVT_DTOE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x100000) >> 20
}
func (o *SDHC_Type) SetFEVT_DCE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetFEVT_DCE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetFEVT_DEBE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetFEVT_DEBE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetFEVT_AC12E(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetFEVT_AC12E() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetFEVT_DMAE(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x10000000)|value<<28)
}
func (o *SDHC_Type) GetFEVT_DMAE() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x10000000) >> 28
}
func (o *SDHC_Type) SetFEVT_CINT(value uint32) {
	volatile.StoreUint32(&o.FEVT.Reg, volatile.LoadUint32(&o.FEVT.Reg)&^(0x80000000)|value<<31)
}
func (o *SDHC_Type) GetFEVT_CINT() uint32 {
	return (volatile.LoadUint32(&o.FEVT.Reg) & 0x80000000) >> 31
}

// SDHC.ADMAES: ADMA Error Status register
func (o *SDHC_Type) SetADMAES(value uint32) {
	volatile.StoreUint32(&o.ADMAES.Reg, volatile.LoadUint32(&o.ADMAES.Reg)&^(0x3)|value)
}
func (o *SDHC_Type) GetADMAES() uint32 {
	return volatile.LoadUint32(&o.ADMAES.Reg) & 0x3
}
func (o *SDHC_Type) SetADMAES_ADMALME(value uint32) {
	volatile.StoreUint32(&o.ADMAES.Reg, volatile.LoadUint32(&o.ADMAES.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetADMAES_ADMALME() uint32 {
	return (volatile.LoadUint32(&o.ADMAES.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetADMAES_ADMADCE(value uint32) {
	volatile.StoreUint32(&o.ADMAES.Reg, volatile.LoadUint32(&o.ADMAES.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetADMAES_ADMADCE() uint32 {
	return (volatile.LoadUint32(&o.ADMAES.Reg) & 0x8) >> 3
}

// SDHC.ADSADDR: ADMA System Addressregister
func (o *SDHC_Type) SetADSADDR(value uint32) {
	volatile.StoreUint32(&o.ADSADDR.Reg, volatile.LoadUint32(&o.ADSADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SDHC_Type) GetADSADDR() uint32 {
	return (volatile.LoadUint32(&o.ADSADDR.Reg) & 0xfffffffc) >> 2
}

// SDHC.VENDOR: Vendor Specific register
func (o *SDHC_Type) SetVENDOR_EXBLKNU(value uint32) {
	volatile.StoreUint32(&o.VENDOR.Reg, volatile.LoadUint32(&o.VENDOR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetVENDOR_EXBLKNU() uint32 {
	return (volatile.LoadUint32(&o.VENDOR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetVENDOR_INTSTVAL(value uint32) {
	volatile.StoreUint32(&o.VENDOR.Reg, volatile.LoadUint32(&o.VENDOR.Reg)&^(0xff0000)|value<<16)
}
func (o *SDHC_Type) GetVENDOR_INTSTVAL() uint32 {
	return (volatile.LoadUint32(&o.VENDOR.Reg) & 0xff0000) >> 16
}

// SDHC.MMCBOOT: MMC Boot register
func (o *SDHC_Type) SetMMCBOOT_DTOCVACK(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0xf)|value)
}
func (o *SDHC_Type) GetMMCBOOT_DTOCVACK() uint32 {
	return volatile.LoadUint32(&o.MMCBOOT.Reg) & 0xf
}
func (o *SDHC_Type) SetMMCBOOT_BOOTACK(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetMMCBOOT_BOOTACK() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetMMCBOOT_BOOTMODE(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetMMCBOOT_BOOTMODE() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetMMCBOOT_BOOTEN(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetMMCBOOT_BOOTEN() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetMMCBOOT_AUTOSABGEN(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetMMCBOOT_AUTOSABGEN() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetMMCBOOT_BOOTBLKCNT(value uint32) {
	volatile.StoreUint32(&o.MMCBOOT.Reg, volatile.LoadUint32(&o.MMCBOOT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SDHC_Type) GetMMCBOOT_BOOTBLKCNT() uint32 {
	return (volatile.LoadUint32(&o.MMCBOOT.Reg) & 0xffff0000) >> 16
}

// SDHC.HOSTVER: Host Controller Version
func (o *SDHC_Type) SetHOSTVER_SVN(value uint32) {
	volatile.StoreUint32(&o.HOSTVER.Reg, volatile.LoadUint32(&o.HOSTVER.Reg)&^(0xff)|value)
}
func (o *SDHC_Type) GetHOSTVER_SVN() uint32 {
	return volatile.LoadUint32(&o.HOSTVER.Reg) & 0xff
}
func (o *SDHC_Type) SetHOSTVER_VVN(value uint32) {
	volatile.StoreUint32(&o.HOSTVER.Reg, volatile.LoadUint32(&o.HOSTVER.Reg)&^(0xff00)|value<<8)
}
func (o *SDHC_Type) GetHOSTVER_VVN() uint32 {
	return (volatile.LoadUint32(&o.HOSTVER.Reg) & 0xff00) >> 8
}

// Ethernet MAC-NET Core
type ENET_Type struct {
	_                  [4]byte
	EIR                volatile.Register32 // 0x4
	EIMR               volatile.Register32 // 0x8
	_                  [4]byte
	RDAR               volatile.Register32 // 0x10
	TDAR               volatile.Register32 // 0x14
	_                  [12]byte
	ECR                volatile.Register32 // 0x24
	_                  [24]byte
	MMFR               volatile.Register32 // 0x40
	MSCR               volatile.Register32 // 0x44
	_                  [28]byte
	MIBC               volatile.Register32 // 0x64
	_                  [28]byte
	RCR                volatile.Register32 // 0x84
	_                  [60]byte
	TCR                volatile.Register32 // 0xC4
	_                  [28]byte
	PALR               volatile.Register32 // 0xE4
	PAUR               volatile.Register32 // 0xE8
	OPD                volatile.Register32 // 0xEC
	_                  [40]byte
	IAUR               volatile.Register32 // 0x118
	IALR               volatile.Register32 // 0x11C
	GAUR               volatile.Register32 // 0x120
	GALR               volatile.Register32 // 0x124
	_                  [28]byte
	TFWR               volatile.Register32 // 0x144
	_                  [56]byte
	RDSR               volatile.Register32 // 0x180
	TDSR               volatile.Register32 // 0x184
	MRBR               volatile.Register32 // 0x188
	_                  [4]byte
	RSFL               volatile.Register32 // 0x190
	RSEM               volatile.Register32 // 0x194
	RAEM               volatile.Register32 // 0x198
	RAFL               volatile.Register32 // 0x19C
	TSEM               volatile.Register32 // 0x1A0
	TAEM               volatile.Register32 // 0x1A4
	TAFL               volatile.Register32 // 0x1A8
	TIPG               volatile.Register32 // 0x1AC
	FTRL               volatile.Register32 // 0x1B0
	_                  [12]byte
	TACC               volatile.Register32 // 0x1C0
	RACC               volatile.Register32 // 0x1C4
	_                  [56]byte
	RMON_T_DROP        volatile.Register32 // 0x200
	RMON_T_PACKETS     volatile.Register32 // 0x204
	RMON_T_BC_PKT      volatile.Register32 // 0x208
	RMON_T_MC_PKT      volatile.Register32 // 0x20C
	RMON_T_CRC_ALIGN   volatile.Register32 // 0x210
	RMON_T_UNDERSIZE   volatile.Register32 // 0x214
	RMON_T_OVERSIZE    volatile.Register32 // 0x218
	RMON_T_FRAG        volatile.Register32 // 0x21C
	RMON_T_JAB         volatile.Register32 // 0x220
	RMON_T_COL         volatile.Register32 // 0x224
	RMON_T_P64         volatile.Register32 // 0x228
	RMON_T_P65TO127    volatile.Register32 // 0x22C
	RMON_T_P128TO255   volatile.Register32 // 0x230
	RMON_T_P256TO511   volatile.Register32 // 0x234
	RMON_T_P512TO1023  volatile.Register32 // 0x238
	RMON_T_P1024TO2047 volatile.Register32 // 0x23C
	RMON_T_P_GTE2048   volatile.Register32 // 0x240
	RMON_T_OCTETS      volatile.Register32 // 0x244
	IEEE_T_DROP        volatile.Register32 // 0x248
	IEEE_T_FRAME_OK    volatile.Register32 // 0x24C
	IEEE_T_1COL        volatile.Register32 // 0x250
	IEEE_T_MCOL        volatile.Register32 // 0x254
	IEEE_T_DEF         volatile.Register32 // 0x258
	IEEE_T_LCOL        volatile.Register32 // 0x25C
	IEEE_T_EXCOL       volatile.Register32 // 0x260
	IEEE_T_MACERR      volatile.Register32 // 0x264
	IEEE_T_CSERR       volatile.Register32 // 0x268
	IEEE_T_SQE         volatile.Register32 // 0x26C
	IEEE_T_FDXFC       volatile.Register32 // 0x270
	IEEE_T_OCTETS_OK   volatile.Register32 // 0x274
	_                  [12]byte
	RMON_R_PACKETS     volatile.Register32 // 0x284
	RMON_R_BC_PKT      volatile.Register32 // 0x288
	RMON_R_MC_PKT      volatile.Register32 // 0x28C
	RMON_R_CRC_ALIGN   volatile.Register32 // 0x290
	RMON_R_UNDERSIZE   volatile.Register32 // 0x294
	RMON_R_OVERSIZE    volatile.Register32 // 0x298
	RMON_R_FRAG        volatile.Register32 // 0x29C
	RMON_R_JAB         volatile.Register32 // 0x2A0
	RMON_R_RESVD_0     volatile.Register32 // 0x2A4
	RMON_R_P64         volatile.Register32 // 0x2A8
	RMON_R_P65TO127    volatile.Register32 // 0x2AC
	RMON_R_P128TO255   volatile.Register32 // 0x2B0
	RMON_R_P256TO511   volatile.Register32 // 0x2B4
	RMON_R_P512TO1023  volatile.Register32 // 0x2B8
	RMON_R_P1024TO2047 volatile.Register32 // 0x2BC
	RMON_R_P_GTE2048   volatile.Register32 // 0x2C0
	RMON_R_OCTETS      volatile.Register32 // 0x2C4
	IEEE_R_DROP        volatile.Register32 // 0x2C8
	IEEE_R_FRAME_OK    volatile.Register32 // 0x2CC
	IEEE_R_CRC         volatile.Register32 // 0x2D0
	IEEE_R_ALIGN       volatile.Register32 // 0x2D4
	IEEE_R_MACERR      volatile.Register32 // 0x2D8
	IEEE_R_FDXFC       volatile.Register32 // 0x2DC
	IEEE_R_OCTETS_OK   volatile.Register32 // 0x2E0
	_                  [284]byte
	ATCR               volatile.Register32 // 0x400
	ATVR               volatile.Register32 // 0x404
	ATOFF              volatile.Register32 // 0x408
	ATPER              volatile.Register32 // 0x40C
	ATCOR              volatile.Register32 // 0x410
	ATINC              volatile.Register32 // 0x414
	ATSTMP             volatile.Register32 // 0x418
	_                  [488]byte
	TGSR               volatile.Register32 // 0x604
	TCSR0              volatile.Register32 // 0x608
	TCCR0              volatile.Register32 // 0x60C
	TCSR1              volatile.Register32 // 0x610
	TCCR1              volatile.Register32 // 0x614
	TCSR2              volatile.Register32 // 0x618
	TCCR2              volatile.Register32 // 0x61C
	TCSR3              volatile.Register32 // 0x620
	TCCR3              volatile.Register32 // 0x624
}

// ENET.EIR: Interrupt Event Register
func (o *ENET_Type) SetEIR_TS_TIMER(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x8000)|value<<15)
}
func (o *ENET_Type) GetEIR_TS_TIMER() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x8000) >> 15
}
func (o *ENET_Type) SetEIR_TS_AVAIL(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x10000)|value<<16)
}
func (o *ENET_Type) GetEIR_TS_AVAIL() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x10000) >> 16
}
func (o *ENET_Type) SetEIR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x20000)|value<<17)
}
func (o *ENET_Type) GetEIR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x20000) >> 17
}
func (o *ENET_Type) SetEIR_PLR(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x40000)|value<<18)
}
func (o *ENET_Type) GetEIR_PLR() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x40000) >> 18
}
func (o *ENET_Type) SetEIR_UN(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x80000)|value<<19)
}
func (o *ENET_Type) GetEIR_UN() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x80000) >> 19
}
func (o *ENET_Type) SetEIR_RL(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x100000)|value<<20)
}
func (o *ENET_Type) GetEIR_RL() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x100000) >> 20
}
func (o *ENET_Type) SetEIR_LC(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x200000)|value<<21)
}
func (o *ENET_Type) GetEIR_LC() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x200000) >> 21
}
func (o *ENET_Type) SetEIR_EBERR(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x400000)|value<<22)
}
func (o *ENET_Type) GetEIR_EBERR() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x400000) >> 22
}
func (o *ENET_Type) SetEIR_MII(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x800000)|value<<23)
}
func (o *ENET_Type) GetEIR_MII() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x800000) >> 23
}
func (o *ENET_Type) SetEIR_RXB(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x1000000)|value<<24)
}
func (o *ENET_Type) GetEIR_RXB() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x1000000) >> 24
}
func (o *ENET_Type) SetEIR_RXF(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x2000000)|value<<25)
}
func (o *ENET_Type) GetEIR_RXF() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x2000000) >> 25
}
func (o *ENET_Type) SetEIR_TXB(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x4000000)|value<<26)
}
func (o *ENET_Type) GetEIR_TXB() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x4000000) >> 26
}
func (o *ENET_Type) SetEIR_TXF(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x8000000)|value<<27)
}
func (o *ENET_Type) GetEIR_TXF() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x8000000) >> 27
}
func (o *ENET_Type) SetEIR_GRA(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x10000000)|value<<28)
}
func (o *ENET_Type) GetEIR_GRA() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x10000000) >> 28
}
func (o *ENET_Type) SetEIR_BABT(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x20000000)|value<<29)
}
func (o *ENET_Type) GetEIR_BABT() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x20000000) >> 29
}
func (o *ENET_Type) SetEIR_BABR(value uint32) {
	volatile.StoreUint32(&o.EIR.Reg, volatile.LoadUint32(&o.EIR.Reg)&^(0x40000000)|value<<30)
}
func (o *ENET_Type) GetEIR_BABR() uint32 {
	return (volatile.LoadUint32(&o.EIR.Reg) & 0x40000000) >> 30
}

// ENET.EIMR: Interrupt Mask Register
func (o *ENET_Type) SetEIMR_TS_TIMER(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x8000)|value<<15)
}
func (o *ENET_Type) GetEIMR_TS_TIMER() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x8000) >> 15
}
func (o *ENET_Type) SetEIMR_TS_AVAIL(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x10000)|value<<16)
}
func (o *ENET_Type) GetEIMR_TS_AVAIL() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x10000) >> 16
}
func (o *ENET_Type) SetEIMR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x20000)|value<<17)
}
func (o *ENET_Type) GetEIMR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x20000) >> 17
}
func (o *ENET_Type) SetEIMR_PLR(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x40000)|value<<18)
}
func (o *ENET_Type) GetEIMR_PLR() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x40000) >> 18
}
func (o *ENET_Type) SetEIMR_UN(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x80000)|value<<19)
}
func (o *ENET_Type) GetEIMR_UN() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x80000) >> 19
}
func (o *ENET_Type) SetEIMR_RL(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x100000)|value<<20)
}
func (o *ENET_Type) GetEIMR_RL() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x100000) >> 20
}
func (o *ENET_Type) SetEIMR_LC(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x200000)|value<<21)
}
func (o *ENET_Type) GetEIMR_LC() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x200000) >> 21
}
func (o *ENET_Type) SetEIMR_EBERR(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x400000)|value<<22)
}
func (o *ENET_Type) GetEIMR_EBERR() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x400000) >> 22
}
func (o *ENET_Type) SetEIMR_MII(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x800000)|value<<23)
}
func (o *ENET_Type) GetEIMR_MII() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x800000) >> 23
}
func (o *ENET_Type) SetEIMR_RXB(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ENET_Type) GetEIMR_RXB() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x1000000) >> 24
}
func (o *ENET_Type) SetEIMR_RXF(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x2000000)|value<<25)
}
func (o *ENET_Type) GetEIMR_RXF() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x2000000) >> 25
}
func (o *ENET_Type) SetEIMR_TXB(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x4000000)|value<<26)
}
func (o *ENET_Type) GetEIMR_TXB() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x4000000) >> 26
}
func (o *ENET_Type) SetEIMR_TXF(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x8000000)|value<<27)
}
func (o *ENET_Type) GetEIMR_TXF() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x8000000) >> 27
}
func (o *ENET_Type) SetEIMR_GRA(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x10000000)|value<<28)
}
func (o *ENET_Type) GetEIMR_GRA() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x10000000) >> 28
}
func (o *ENET_Type) SetEIMR_BABT(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x20000000)|value<<29)
}
func (o *ENET_Type) GetEIMR_BABT() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x20000000) >> 29
}
func (o *ENET_Type) SetEIMR_BABR(value uint32) {
	volatile.StoreUint32(&o.EIMR.Reg, volatile.LoadUint32(&o.EIMR.Reg)&^(0x40000000)|value<<30)
}
func (o *ENET_Type) GetEIMR_BABR() uint32 {
	return (volatile.LoadUint32(&o.EIMR.Reg) & 0x40000000) >> 30
}

// ENET.RDAR: Receive Descriptor Active Register
func (o *ENET_Type) SetRDAR(value uint32) {
	volatile.StoreUint32(&o.RDAR.Reg, volatile.LoadUint32(&o.RDAR.Reg)&^(0x1000000)|value<<24)
}
func (o *ENET_Type) GetRDAR() uint32 {
	return (volatile.LoadUint32(&o.RDAR.Reg) & 0x1000000) >> 24
}

// ENET.TDAR: Transmit Descriptor Active Register
func (o *ENET_Type) SetTDAR(value uint32) {
	volatile.StoreUint32(&o.TDAR.Reg, volatile.LoadUint32(&o.TDAR.Reg)&^(0x1000000)|value<<24)
}
func (o *ENET_Type) GetTDAR() uint32 {
	return (volatile.LoadUint32(&o.TDAR.Reg) & 0x1000000) >> 24
}

// ENET.ECR: Ethernet Control Register
func (o *ENET_Type) SetECR_RESET(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetECR_RESET() uint32 {
	return volatile.LoadUint32(&o.ECR.Reg) & 0x1
}
func (o *ENET_Type) SetECR_ETHEREN(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x2)|value<<1)
}
func (o *ENET_Type) GetECR_ETHEREN() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x2) >> 1
}
func (o *ENET_Type) SetECR_MAGICEN(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetECR_MAGICEN() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetECR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetECR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetECR_EN1588(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetECR_EN1588() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x10) >> 4
}
func (o *ENET_Type) SetECR_DBGEN(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetECR_DBGEN() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetECR_STOPEN(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetECR_STOPEN() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x80) >> 7
}
func (o *ENET_Type) SetECR_DBSWP(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x100)|value<<8)
}
func (o *ENET_Type) GetECR_DBSWP() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x100) >> 8
}

// ENET.MMFR: MII Management Frame Register
func (o *ENET_Type) SetMMFR_DATA(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetMMFR_DATA() uint32 {
	return volatile.LoadUint32(&o.MMFR.Reg) & 0xffff
}
func (o *ENET_Type) SetMMFR_TA(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0x30000)|value<<16)
}
func (o *ENET_Type) GetMMFR_TA() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0x30000) >> 16
}
func (o *ENET_Type) SetMMFR_RA(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0x7c0000)|value<<18)
}
func (o *ENET_Type) GetMMFR_RA() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0x7c0000) >> 18
}
func (o *ENET_Type) SetMMFR_PA(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0xf800000)|value<<23)
}
func (o *ENET_Type) GetMMFR_PA() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0xf800000) >> 23
}
func (o *ENET_Type) SetMMFR_OP(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0x30000000)|value<<28)
}
func (o *ENET_Type) GetMMFR_OP() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0x30000000) >> 28
}
func (o *ENET_Type) SetMMFR_ST(value uint32) {
	volatile.StoreUint32(&o.MMFR.Reg, volatile.LoadUint32(&o.MMFR.Reg)&^(0xc0000000)|value<<30)
}
func (o *ENET_Type) GetMMFR_ST() uint32 {
	return (volatile.LoadUint32(&o.MMFR.Reg) & 0xc0000000) >> 30
}

// ENET.MSCR: MII Speed Control Register
func (o *ENET_Type) SetMSCR_MII_SPEED(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x7e)|value<<1)
}
func (o *ENET_Type) GetMSCR_MII_SPEED() uint32 {
	return (volatile.LoadUint32(&o.MSCR.Reg) & 0x7e) >> 1
}
func (o *ENET_Type) SetMSCR_DIS_PRE(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetMSCR_DIS_PRE() uint32 {
	return (volatile.LoadUint32(&o.MSCR.Reg) & 0x80) >> 7
}
func (o *ENET_Type) SetMSCR_HOLDTIME(value uint32) {
	volatile.StoreUint32(&o.MSCR.Reg, volatile.LoadUint32(&o.MSCR.Reg)&^(0x700)|value<<8)
}
func (o *ENET_Type) GetMSCR_HOLDTIME() uint32 {
	return (volatile.LoadUint32(&o.MSCR.Reg) & 0x700) >> 8
}

// ENET.MIBC: MIB Control Register
func (o *ENET_Type) SetMIBC_MIB_CLEAR(value uint32) {
	volatile.StoreUint32(&o.MIBC.Reg, volatile.LoadUint32(&o.MIBC.Reg)&^(0x20000000)|value<<29)
}
func (o *ENET_Type) GetMIBC_MIB_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.MIBC.Reg) & 0x20000000) >> 29
}
func (o *ENET_Type) SetMIBC_MIB_IDLE(value uint32) {
	volatile.StoreUint32(&o.MIBC.Reg, volatile.LoadUint32(&o.MIBC.Reg)&^(0x40000000)|value<<30)
}
func (o *ENET_Type) GetMIBC_MIB_IDLE() uint32 {
	return (volatile.LoadUint32(&o.MIBC.Reg) & 0x40000000) >> 30
}
func (o *ENET_Type) SetMIBC_MIB_DIS(value uint32) {
	volatile.StoreUint32(&o.MIBC.Reg, volatile.LoadUint32(&o.MIBC.Reg)&^(0x80000000)|value<<31)
}
func (o *ENET_Type) GetMIBC_MIB_DIS() uint32 {
	return (volatile.LoadUint32(&o.MIBC.Reg) & 0x80000000) >> 31
}

// ENET.RCR: Receive Control Register
func (o *ENET_Type) SetRCR_LOOP(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetRCR_LOOP() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0x1
}
func (o *ENET_Type) SetRCR_DRT(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x2)|value<<1)
}
func (o *ENET_Type) GetRCR_DRT() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x2) >> 1
}
func (o *ENET_Type) SetRCR_MII_MODE(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetRCR_MII_MODE() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetRCR_PROM(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetRCR_PROM() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetRCR_BC_REJ(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetRCR_BC_REJ() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x10) >> 4
}
func (o *ENET_Type) SetRCR_FCE(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x20)|value<<5)
}
func (o *ENET_Type) GetRCR_FCE() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x20) >> 5
}
func (o *ENET_Type) SetRCR_RMII_MODE(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x100)|value<<8)
}
func (o *ENET_Type) GetRCR_RMII_MODE() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x100) >> 8
}
func (o *ENET_Type) SetRCR_RMII_10T(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x200)|value<<9)
}
func (o *ENET_Type) GetRCR_RMII_10T() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x200) >> 9
}
func (o *ENET_Type) SetRCR_PADEN(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x1000)|value<<12)
}
func (o *ENET_Type) GetRCR_PADEN() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x1000) >> 12
}
func (o *ENET_Type) SetRCR_PAUFWD(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x2000)|value<<13)
}
func (o *ENET_Type) GetRCR_PAUFWD() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x2000) >> 13
}
func (o *ENET_Type) SetRCR_CRCFWD(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x4000)|value<<14)
}
func (o *ENET_Type) GetRCR_CRCFWD() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x4000) >> 14
}
func (o *ENET_Type) SetRCR_CFEN(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x8000)|value<<15)
}
func (o *ENET_Type) GetRCR_CFEN() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x8000) >> 15
}
func (o *ENET_Type) SetRCR_MAX_FL(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ENET_Type) GetRCR_MAX_FL() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x3fff0000) >> 16
}
func (o *ENET_Type) SetRCR_NLC(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x40000000)|value<<30)
}
func (o *ENET_Type) GetRCR_NLC() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x40000000) >> 30
}
func (o *ENET_Type) SetRCR_GRS(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0x80000000)|value<<31)
}
func (o *ENET_Type) GetRCR_GRS() uint32 {
	return (volatile.LoadUint32(&o.RCR.Reg) & 0x80000000) >> 31
}

// ENET.TCR: Transmit Control Register
func (o *ENET_Type) SetTCR_GTS(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCR_GTS() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *ENET_Type) SetTCR_FDEN(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetTCR_FDEN() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetTCR_TFC_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetTCR_TFC_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetTCR_RFC_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetTCR_RFC_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x10) >> 4
}
func (o *ENET_Type) SetTCR_ADDSEL(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xe0)|value<<5)
}
func (o *ENET_Type) GetTCR_ADDSEL() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xe0) >> 5
}
func (o *ENET_Type) SetTCR_ADDINS(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x100)|value<<8)
}
func (o *ENET_Type) GetTCR_ADDINS() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x100) >> 8
}
func (o *ENET_Type) SetTCR_CRCFWD(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x200)|value<<9)
}
func (o *ENET_Type) GetTCR_CRCFWD() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x200) >> 9
}

// ENET.PALR: Physical Address Lower Register
func (o *ENET_Type) SetPALR(value uint32) {
	volatile.StoreUint32(&o.PALR.Reg, value)
}
func (o *ENET_Type) GetPALR() uint32 {
	return volatile.LoadUint32(&o.PALR.Reg)
}

// ENET.PAUR: Physical Address Upper Register
func (o *ENET_Type) SetPAUR_TYPE(value uint32) {
	volatile.StoreUint32(&o.PAUR.Reg, volatile.LoadUint32(&o.PAUR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetPAUR_TYPE() uint32 {
	return volatile.LoadUint32(&o.PAUR.Reg) & 0xffff
}
func (o *ENET_Type) SetPAUR_PADDR2(value uint32) {
	volatile.StoreUint32(&o.PAUR.Reg, volatile.LoadUint32(&o.PAUR.Reg)&^(0xffff0000)|value<<16)
}
func (o *ENET_Type) GetPAUR_PADDR2() uint32 {
	return (volatile.LoadUint32(&o.PAUR.Reg) & 0xffff0000) >> 16
}

// ENET.OPD: Opcode/Pause Duration Register
func (o *ENET_Type) SetOPD_PAUSE_DUR(value uint32) {
	volatile.StoreUint32(&o.OPD.Reg, volatile.LoadUint32(&o.OPD.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetOPD_PAUSE_DUR() uint32 {
	return volatile.LoadUint32(&o.OPD.Reg) & 0xffff
}
func (o *ENET_Type) SetOPD_OPCODE(value uint32) {
	volatile.StoreUint32(&o.OPD.Reg, volatile.LoadUint32(&o.OPD.Reg)&^(0xffff0000)|value<<16)
}
func (o *ENET_Type) GetOPD_OPCODE() uint32 {
	return (volatile.LoadUint32(&o.OPD.Reg) & 0xffff0000) >> 16
}

// ENET.IAUR: Descriptor Individual Upper Address Register
func (o *ENET_Type) SetIAUR(value uint32) {
	volatile.StoreUint32(&o.IAUR.Reg, value)
}
func (o *ENET_Type) GetIAUR() uint32 {
	return volatile.LoadUint32(&o.IAUR.Reg)
}

// ENET.IALR: Descriptor Individual Lower Address Register
func (o *ENET_Type) SetIALR(value uint32) {
	volatile.StoreUint32(&o.IALR.Reg, value)
}
func (o *ENET_Type) GetIALR() uint32 {
	return volatile.LoadUint32(&o.IALR.Reg)
}

// ENET.GAUR: Descriptor Group Upper Address Register
func (o *ENET_Type) SetGAUR(value uint32) {
	volatile.StoreUint32(&o.GAUR.Reg, value)
}
func (o *ENET_Type) GetGAUR() uint32 {
	return volatile.LoadUint32(&o.GAUR.Reg)
}

// ENET.GALR: Descriptor Group Lower Address Register
func (o *ENET_Type) SetGALR(value uint32) {
	volatile.StoreUint32(&o.GALR.Reg, value)
}
func (o *ENET_Type) GetGALR() uint32 {
	return volatile.LoadUint32(&o.GALR.Reg)
}

// ENET.TFWR: Transmit FIFO Watermark Register
func (o *ENET_Type) SetTFWR(value uint32) {
	volatile.StoreUint32(&o.TFWR.Reg, volatile.LoadUint32(&o.TFWR.Reg)&^(0x3f)|value)
}
func (o *ENET_Type) GetTFWR() uint32 {
	return volatile.LoadUint32(&o.TFWR.Reg) & 0x3f
}
func (o *ENET_Type) SetTFWR_STRFWD(value uint32) {
	volatile.StoreUint32(&o.TFWR.Reg, volatile.LoadUint32(&o.TFWR.Reg)&^(0x100)|value<<8)
}
func (o *ENET_Type) GetTFWR_STRFWD() uint32 {
	return (volatile.LoadUint32(&o.TFWR.Reg) & 0x100) >> 8
}

// ENET.RDSR: Receive Descriptor Ring Start Register
func (o *ENET_Type) SetRDSR_R_DES_START(value uint32) {
	volatile.StoreUint32(&o.RDSR.Reg, volatile.LoadUint32(&o.RDSR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *ENET_Type) GetRDSR_R_DES_START() uint32 {
	return (volatile.LoadUint32(&o.RDSR.Reg) & 0xfffffff8) >> 3
}

// ENET.TDSR: Transmit Buffer Descriptor Ring Start Register
func (o *ENET_Type) SetTDSR_X_DES_START(value uint32) {
	volatile.StoreUint32(&o.TDSR.Reg, volatile.LoadUint32(&o.TDSR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *ENET_Type) GetTDSR_X_DES_START() uint32 {
	return (volatile.LoadUint32(&o.TDSR.Reg) & 0xfffffff8) >> 3
}

// ENET.MRBR: Maximum Receive Buffer Size Register
func (o *ENET_Type) SetMRBR_R_BUF_SIZE(value uint32) {
	volatile.StoreUint32(&o.MRBR.Reg, volatile.LoadUint32(&o.MRBR.Reg)&^(0x7f0)|value<<4)
}
func (o *ENET_Type) GetMRBR_R_BUF_SIZE() uint32 {
	return (volatile.LoadUint32(&o.MRBR.Reg) & 0x7f0) >> 4
}

// ENET.RSFL: Receive FIFO Section Full Threshold
func (o *ENET_Type) SetRSFL_RX_SECTION_FULL(value uint32) {
	volatile.StoreUint32(&o.RSFL.Reg, volatile.LoadUint32(&o.RSFL.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetRSFL_RX_SECTION_FULL() uint32 {
	return volatile.LoadUint32(&o.RSFL.Reg) & 0xff
}

// ENET.RSEM: Receive FIFO Section Empty Threshold
func (o *ENET_Type) SetRSEM_RX_SECTION_EMPTY(value uint32) {
	volatile.StoreUint32(&o.RSEM.Reg, volatile.LoadUint32(&o.RSEM.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetRSEM_RX_SECTION_EMPTY() uint32 {
	return volatile.LoadUint32(&o.RSEM.Reg) & 0xff
}
func (o *ENET_Type) SetRSEM_STAT_SECTION_EMPTY(value uint32) {
	volatile.StoreUint32(&o.RSEM.Reg, volatile.LoadUint32(&o.RSEM.Reg)&^(0x1f0000)|value<<16)
}
func (o *ENET_Type) GetRSEM_STAT_SECTION_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.RSEM.Reg) & 0x1f0000) >> 16
}

// ENET.RAEM: Receive FIFO Almost Empty Threshold
func (o *ENET_Type) SetRAEM_RX_ALMOST_EMPTY(value uint32) {
	volatile.StoreUint32(&o.RAEM.Reg, volatile.LoadUint32(&o.RAEM.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetRAEM_RX_ALMOST_EMPTY() uint32 {
	return volatile.LoadUint32(&o.RAEM.Reg) & 0xff
}

// ENET.RAFL: Receive FIFO Almost Full Threshold
func (o *ENET_Type) SetRAFL_RX_ALMOST_FULL(value uint32) {
	volatile.StoreUint32(&o.RAFL.Reg, volatile.LoadUint32(&o.RAFL.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetRAFL_RX_ALMOST_FULL() uint32 {
	return volatile.LoadUint32(&o.RAFL.Reg) & 0xff
}

// ENET.TSEM: Transmit FIFO Section Empty Threshold
func (o *ENET_Type) SetTSEM_TX_SECTION_EMPTY(value uint32) {
	volatile.StoreUint32(&o.TSEM.Reg, volatile.LoadUint32(&o.TSEM.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetTSEM_TX_SECTION_EMPTY() uint32 {
	return volatile.LoadUint32(&o.TSEM.Reg) & 0xff
}

// ENET.TAEM: Transmit FIFO Almost Empty Threshold
func (o *ENET_Type) SetTAEM_TX_ALMOST_EMPTY(value uint32) {
	volatile.StoreUint32(&o.TAEM.Reg, volatile.LoadUint32(&o.TAEM.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetTAEM_TX_ALMOST_EMPTY() uint32 {
	return volatile.LoadUint32(&o.TAEM.Reg) & 0xff
}

// ENET.TAFL: Transmit FIFO Almost Full Threshold
func (o *ENET_Type) SetTAFL_TX_ALMOST_FULL(value uint32) {
	volatile.StoreUint32(&o.TAFL.Reg, volatile.LoadUint32(&o.TAFL.Reg)&^(0xff)|value)
}
func (o *ENET_Type) GetTAFL_TX_ALMOST_FULL() uint32 {
	return volatile.LoadUint32(&o.TAFL.Reg) & 0xff
}

// ENET.TIPG: Transmit Inter-Packet Gap
func (o *ENET_Type) SetTIPG_IPG(value uint32) {
	volatile.StoreUint32(&o.TIPG.Reg, volatile.LoadUint32(&o.TIPG.Reg)&^(0x1f)|value)
}
func (o *ENET_Type) GetTIPG_IPG() uint32 {
	return volatile.LoadUint32(&o.TIPG.Reg) & 0x1f
}

// ENET.FTRL: Frame Truncation Length
func (o *ENET_Type) SetFTRL_TRUNC_FL(value uint32) {
	volatile.StoreUint32(&o.FTRL.Reg, volatile.LoadUint32(&o.FTRL.Reg)&^(0x3fff)|value)
}
func (o *ENET_Type) GetFTRL_TRUNC_FL() uint32 {
	return volatile.LoadUint32(&o.FTRL.Reg) & 0x3fff
}

// ENET.TACC: Transmit Accelerator Function Configuration
func (o *ENET_Type) SetTACC_SHIFT16(value uint32) {
	volatile.StoreUint32(&o.TACC.Reg, volatile.LoadUint32(&o.TACC.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTACC_SHIFT16() uint32 {
	return volatile.LoadUint32(&o.TACC.Reg) & 0x1
}
func (o *ENET_Type) SetTACC_IPCHK(value uint32) {
	volatile.StoreUint32(&o.TACC.Reg, volatile.LoadUint32(&o.TACC.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetTACC_IPCHK() uint32 {
	return (volatile.LoadUint32(&o.TACC.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetTACC_PROCHK(value uint32) {
	volatile.StoreUint32(&o.TACC.Reg, volatile.LoadUint32(&o.TACC.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetTACC_PROCHK() uint32 {
	return (volatile.LoadUint32(&o.TACC.Reg) & 0x10) >> 4
}

// ENET.RACC: Receive Accelerator Function Configuration
func (o *ENET_Type) SetRACC_PADREM(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetRACC_PADREM() uint32 {
	return volatile.LoadUint32(&o.RACC.Reg) & 0x1
}
func (o *ENET_Type) SetRACC_IPDIS(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x2)|value<<1)
}
func (o *ENET_Type) GetRACC_IPDIS() uint32 {
	return (volatile.LoadUint32(&o.RACC.Reg) & 0x2) >> 1
}
func (o *ENET_Type) SetRACC_PRODIS(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetRACC_PRODIS() uint32 {
	return (volatile.LoadUint32(&o.RACC.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetRACC_LINEDIS(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetRACC_LINEDIS() uint32 {
	return (volatile.LoadUint32(&o.RACC.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetRACC_SHIFT16(value uint32) {
	volatile.StoreUint32(&o.RACC.Reg, volatile.LoadUint32(&o.RACC.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetRACC_SHIFT16() uint32 {
	return (volatile.LoadUint32(&o.RACC.Reg) & 0x80) >> 7
}

// ENET.RMON_T_PACKETS: Tx Packet Count Statistic Register
func (o *ENET_Type) SetRMON_T_PACKETS_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_PACKETS.Reg, volatile.LoadUint32(&o.RMON_T_PACKETS.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_PACKETS_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_PACKETS.Reg) & 0xffff
}

// ENET.RMON_T_BC_PKT: Tx Broadcast Packets Statistic Register
func (o *ENET_Type) SetRMON_T_BC_PKT_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_BC_PKT.Reg, volatile.LoadUint32(&o.RMON_T_BC_PKT.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_BC_PKT_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_BC_PKT.Reg) & 0xffff
}

// ENET.RMON_T_MC_PKT: Tx Multicast Packets Statistic Register
func (o *ENET_Type) SetRMON_T_MC_PKT_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_MC_PKT.Reg, volatile.LoadUint32(&o.RMON_T_MC_PKT.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_MC_PKT_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_MC_PKT.Reg) & 0xffff
}

// ENET.RMON_T_CRC_ALIGN: Tx Packets with CRC/Align Error Statistic Register
func (o *ENET_Type) SetRMON_T_CRC_ALIGN_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_CRC_ALIGN.Reg, volatile.LoadUint32(&o.RMON_T_CRC_ALIGN.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_CRC_ALIGN_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_CRC_ALIGN.Reg) & 0xffff
}

// ENET.RMON_T_UNDERSIZE: Tx Packets Less Than Bytes and Good CRC Statistic Register
func (o *ENET_Type) SetRMON_T_UNDERSIZE_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_UNDERSIZE.Reg, volatile.LoadUint32(&o.RMON_T_UNDERSIZE.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_UNDERSIZE_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_UNDERSIZE.Reg) & 0xffff
}

// ENET.RMON_T_OVERSIZE: Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
func (o *ENET_Type) SetRMON_T_OVERSIZE_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_OVERSIZE.Reg, volatile.LoadUint32(&o.RMON_T_OVERSIZE.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_OVERSIZE_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_OVERSIZE.Reg) & 0xffff
}

// ENET.RMON_T_FRAG: Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
func (o *ENET_Type) SetRMON_T_FRAG_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_FRAG.Reg, volatile.LoadUint32(&o.RMON_T_FRAG.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_FRAG_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_FRAG.Reg) & 0xffff
}

// ENET.RMON_T_JAB: Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
func (o *ENET_Type) SetRMON_T_JAB_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_JAB.Reg, volatile.LoadUint32(&o.RMON_T_JAB.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_JAB_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_JAB.Reg) & 0xffff
}

// ENET.RMON_T_COL: Tx Collision Count Statistic Register
func (o *ENET_Type) SetRMON_T_COL_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_COL.Reg, volatile.LoadUint32(&o.RMON_T_COL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_COL_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_COL.Reg) & 0xffff
}

// ENET.RMON_T_P64: Tx 64-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P64_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P64.Reg, volatile.LoadUint32(&o.RMON_T_P64.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P64_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P64.Reg) & 0xffff
}

// ENET.RMON_T_P65TO127: Tx 65- to 127-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P65TO127_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P65TO127.Reg, volatile.LoadUint32(&o.RMON_T_P65TO127.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P65TO127_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P65TO127.Reg) & 0xffff
}

// ENET.RMON_T_P128TO255: Tx 128- to 255-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P128TO255_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P128TO255.Reg, volatile.LoadUint32(&o.RMON_T_P128TO255.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P128TO255_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P128TO255.Reg) & 0xffff
}

// ENET.RMON_T_P256TO511: Tx 256- to 511-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P256TO511_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P256TO511.Reg, volatile.LoadUint32(&o.RMON_T_P256TO511.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P256TO511_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P256TO511.Reg) & 0xffff
}

// ENET.RMON_T_P512TO1023: Tx 512- to 1023-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P512TO1023_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P512TO1023.Reg, volatile.LoadUint32(&o.RMON_T_P512TO1023.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P512TO1023_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P512TO1023.Reg) & 0xffff
}

// ENET.RMON_T_P1024TO2047: Tx 1024- to 2047-byte Packets Statistic Register
func (o *ENET_Type) SetRMON_T_P1024TO2047_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P1024TO2047.Reg, volatile.LoadUint32(&o.RMON_T_P1024TO2047.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P1024TO2047_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P1024TO2047.Reg) & 0xffff
}

// ENET.RMON_T_P_GTE2048: Tx Packets Greater Than 2048 Bytes Statistic Register
func (o *ENET_Type) SetRMON_T_P_GTE2048_TXPKTS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_P_GTE2048.Reg, volatile.LoadUint32(&o.RMON_T_P_GTE2048.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_T_P_GTE2048_TXPKTS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_P_GTE2048.Reg) & 0xffff
}

// ENET.RMON_T_OCTETS: Tx Octets Statistic Register
func (o *ENET_Type) SetRMON_T_OCTETS(value uint32) {
	volatile.StoreUint32(&o.RMON_T_OCTETS.Reg, value)
}
func (o *ENET_Type) GetRMON_T_OCTETS() uint32 {
	return volatile.LoadUint32(&o.RMON_T_OCTETS.Reg)
}

// ENET.IEEE_T_FRAME_OK: Frames Transmitted OK Statistic Register
func (o *ENET_Type) SetIEEE_T_FRAME_OK_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_FRAME_OK.Reg, volatile.LoadUint32(&o.IEEE_T_FRAME_OK.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_FRAME_OK_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_FRAME_OK.Reg) & 0xffff
}

// ENET.IEEE_T_1COL: Frames Transmitted with Single Collision Statistic Register
func (o *ENET_Type) SetIEEE_T_1COL_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_1COL.Reg, volatile.LoadUint32(&o.IEEE_T_1COL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_1COL_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_1COL.Reg) & 0xffff
}

// ENET.IEEE_T_MCOL: Frames Transmitted with Multiple Collisions Statistic Register
func (o *ENET_Type) SetIEEE_T_MCOL_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_MCOL.Reg, volatile.LoadUint32(&o.IEEE_T_MCOL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_MCOL_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_MCOL.Reg) & 0xffff
}

// ENET.IEEE_T_DEF: Frames Transmitted after Deferral Delay Statistic Register
func (o *ENET_Type) SetIEEE_T_DEF_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_DEF.Reg, volatile.LoadUint32(&o.IEEE_T_DEF.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_DEF_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_DEF.Reg) & 0xffff
}

// ENET.IEEE_T_LCOL: Frames Transmitted with Late Collision Statistic Register
func (o *ENET_Type) SetIEEE_T_LCOL_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_LCOL.Reg, volatile.LoadUint32(&o.IEEE_T_LCOL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_LCOL_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_LCOL.Reg) & 0xffff
}

// ENET.IEEE_T_EXCOL: Frames Transmitted with Excessive Collisions Statistic Register
func (o *ENET_Type) SetIEEE_T_EXCOL_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_EXCOL.Reg, volatile.LoadUint32(&o.IEEE_T_EXCOL.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_EXCOL_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_EXCOL.Reg) & 0xffff
}

// ENET.IEEE_T_MACERR: Frames Transmitted with Tx FIFO Underrun Statistic Register
func (o *ENET_Type) SetIEEE_T_MACERR_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_MACERR.Reg, volatile.LoadUint32(&o.IEEE_T_MACERR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_MACERR_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_MACERR.Reg) & 0xffff
}

// ENET.IEEE_T_CSERR: Frames Transmitted with Carrier Sense Error Statistic Register
func (o *ENET_Type) SetIEEE_T_CSERR_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_CSERR.Reg, volatile.LoadUint32(&o.IEEE_T_CSERR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_CSERR_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_CSERR.Reg) & 0xffff
}

// ENET.IEEE_T_SQE: no description available
func (o *ENET_Type) SetIEEE_T_SQE_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_SQE.Reg, volatile.LoadUint32(&o.IEEE_T_SQE.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_SQE_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_SQE.Reg) & 0xffff
}

// ENET.IEEE_T_FDXFC: Flow Control Pause Frames Transmitted Statistic Register
func (o *ENET_Type) SetIEEE_T_FDXFC_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_FDXFC.Reg, volatile.LoadUint32(&o.IEEE_T_FDXFC.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_T_FDXFC_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_FDXFC.Reg) & 0xffff
}

// ENET.IEEE_T_OCTETS_OK: Octet Count for Frames Transmitted w/o Error Statistic Register
func (o *ENET_Type) SetIEEE_T_OCTETS_OK(value uint32) {
	volatile.StoreUint32(&o.IEEE_T_OCTETS_OK.Reg, value)
}
func (o *ENET_Type) GetIEEE_T_OCTETS_OK() uint32 {
	return volatile.LoadUint32(&o.IEEE_T_OCTETS_OK.Reg)
}

// ENET.RMON_R_PACKETS: Rx Packet Count Statistic Register
func (o *ENET_Type) SetRMON_R_PACKETS_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_PACKETS.Reg, volatile.LoadUint32(&o.RMON_R_PACKETS.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_PACKETS_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_PACKETS.Reg) & 0xffff
}

// ENET.RMON_R_BC_PKT: Rx Broadcast Packets Statistic Register
func (o *ENET_Type) SetRMON_R_BC_PKT_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_BC_PKT.Reg, volatile.LoadUint32(&o.RMON_R_BC_PKT.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_BC_PKT_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_BC_PKT.Reg) & 0xffff
}

// ENET.RMON_R_MC_PKT: Rx Multicast Packets Statistic Register
func (o *ENET_Type) SetRMON_R_MC_PKT_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_MC_PKT.Reg, volatile.LoadUint32(&o.RMON_R_MC_PKT.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_MC_PKT_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_MC_PKT.Reg) & 0xffff
}

// ENET.RMON_R_CRC_ALIGN: Rx Packets with CRC/Align Error Statistic Register
func (o *ENET_Type) SetRMON_R_CRC_ALIGN_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_CRC_ALIGN.Reg, volatile.LoadUint32(&o.RMON_R_CRC_ALIGN.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_CRC_ALIGN_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_CRC_ALIGN.Reg) & 0xffff
}

// ENET.RMON_R_UNDERSIZE: Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
func (o *ENET_Type) SetRMON_R_UNDERSIZE_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_UNDERSIZE.Reg, volatile.LoadUint32(&o.RMON_R_UNDERSIZE.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_UNDERSIZE_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_UNDERSIZE.Reg) & 0xffff
}

// ENET.RMON_R_OVERSIZE: Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
func (o *ENET_Type) SetRMON_R_OVERSIZE_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_OVERSIZE.Reg, volatile.LoadUint32(&o.RMON_R_OVERSIZE.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_OVERSIZE_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_OVERSIZE.Reg) & 0xffff
}

// ENET.RMON_R_FRAG: Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
func (o *ENET_Type) SetRMON_R_FRAG_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_FRAG.Reg, volatile.LoadUint32(&o.RMON_R_FRAG.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_FRAG_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_FRAG.Reg) & 0xffff
}

// ENET.RMON_R_JAB: Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
func (o *ENET_Type) SetRMON_R_JAB_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_JAB.Reg, volatile.LoadUint32(&o.RMON_R_JAB.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_JAB_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_JAB.Reg) & 0xffff
}

// ENET.RMON_R_P64: Rx 64-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P64_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P64.Reg, volatile.LoadUint32(&o.RMON_R_P64.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P64_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P64.Reg) & 0xffff
}

// ENET.RMON_R_P65TO127: Rx 65- to 127-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P65TO127_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P65TO127.Reg, volatile.LoadUint32(&o.RMON_R_P65TO127.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P65TO127_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P65TO127.Reg) & 0xffff
}

// ENET.RMON_R_P128TO255: Rx 128- to 255-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P128TO255_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P128TO255.Reg, volatile.LoadUint32(&o.RMON_R_P128TO255.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P128TO255_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P128TO255.Reg) & 0xffff
}

// ENET.RMON_R_P256TO511: Rx 256- to 511-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P256TO511_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P256TO511.Reg, volatile.LoadUint32(&o.RMON_R_P256TO511.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P256TO511_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P256TO511.Reg) & 0xffff
}

// ENET.RMON_R_P512TO1023: Rx 512- to 1023-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P512TO1023_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P512TO1023.Reg, volatile.LoadUint32(&o.RMON_R_P512TO1023.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P512TO1023_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P512TO1023.Reg) & 0xffff
}

// ENET.RMON_R_P1024TO2047: Rx 1024- to 2047-Byte Packets Statistic Register
func (o *ENET_Type) SetRMON_R_P1024TO2047_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P1024TO2047.Reg, volatile.LoadUint32(&o.RMON_R_P1024TO2047.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P1024TO2047_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P1024TO2047.Reg) & 0xffff
}

// ENET.RMON_R_P_GTE2048: Rx Packets Greater than 2048 Bytes Statistic Register
func (o *ENET_Type) SetRMON_R_P_GTE2048_COUNT(value uint32) {
	volatile.StoreUint32(&o.RMON_R_P_GTE2048.Reg, volatile.LoadUint32(&o.RMON_R_P_GTE2048.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetRMON_R_P_GTE2048_COUNT() uint32 {
	return volatile.LoadUint32(&o.RMON_R_P_GTE2048.Reg) & 0xffff
}

// ENET.RMON_R_OCTETS: Rx Octets Statistic Register
func (o *ENET_Type) SetRMON_R_OCTETS(value uint32) {
	volatile.StoreUint32(&o.RMON_R_OCTETS.Reg, value)
}
func (o *ENET_Type) GetRMON_R_OCTETS() uint32 {
	return volatile.LoadUint32(&o.RMON_R_OCTETS.Reg)
}

// ENET.IEEE_R_DROP: Frames not Counted Correctly Statistic Register
func (o *ENET_Type) SetIEEE_R_DROP_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_DROP.Reg, volatile.LoadUint32(&o.IEEE_R_DROP.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_DROP_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_DROP.Reg) & 0xffff
}

// ENET.IEEE_R_FRAME_OK: Frames Received OK Statistic Register
func (o *ENET_Type) SetIEEE_R_FRAME_OK_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_FRAME_OK.Reg, volatile.LoadUint32(&o.IEEE_R_FRAME_OK.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_FRAME_OK_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_FRAME_OK.Reg) & 0xffff
}

// ENET.IEEE_R_CRC: Frames Received with CRC Error Statistic Register
func (o *ENET_Type) SetIEEE_R_CRC_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_CRC.Reg, volatile.LoadUint32(&o.IEEE_R_CRC.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_CRC_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_CRC.Reg) & 0xffff
}

// ENET.IEEE_R_ALIGN: Frames Received with Alignment Error Statistic Register
func (o *ENET_Type) SetIEEE_R_ALIGN_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_ALIGN.Reg, volatile.LoadUint32(&o.IEEE_R_ALIGN.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_ALIGN_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_ALIGN.Reg) & 0xffff
}

// ENET.IEEE_R_MACERR: Receive FIFO Overflow Count Statistic Register
func (o *ENET_Type) SetIEEE_R_MACERR_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_MACERR.Reg, volatile.LoadUint32(&o.IEEE_R_MACERR.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_MACERR_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_MACERR.Reg) & 0xffff
}

// ENET.IEEE_R_FDXFC: Flow Control Pause Frames Received Statistic Register
func (o *ENET_Type) SetIEEE_R_FDXFC_COUNT(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_FDXFC.Reg, volatile.LoadUint32(&o.IEEE_R_FDXFC.Reg)&^(0xffff)|value)
}
func (o *ENET_Type) GetIEEE_R_FDXFC_COUNT() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_FDXFC.Reg) & 0xffff
}

// ENET.IEEE_R_OCTETS_OK: Octet Count for Frames Received without Error Statistic Register
func (o *ENET_Type) SetIEEE_R_OCTETS_OK(value uint32) {
	volatile.StoreUint32(&o.IEEE_R_OCTETS_OK.Reg, value)
}
func (o *ENET_Type) GetIEEE_R_OCTETS_OK() uint32 {
	return volatile.LoadUint32(&o.IEEE_R_OCTETS_OK.Reg)
}

// ENET.ATCR: Adjustable Timer Control Register
func (o *ENET_Type) SetATCR_EN(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetATCR_EN() uint32 {
	return volatile.LoadUint32(&o.ATCR.Reg) & 0x1
}
func (o *ENET_Type) SetATCR_OFFEN(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetATCR_OFFEN() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetATCR_OFFRST(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetATCR_OFFRST() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x8) >> 3
}
func (o *ENET_Type) SetATCR_PEREN(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x10)|value<<4)
}
func (o *ENET_Type) GetATCR_PEREN() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x10) >> 4
}
func (o *ENET_Type) SetATCR_PINPER(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetATCR_PINPER() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x80) >> 7
}
func (o *ENET_Type) SetATCR_RESTART(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x200)|value<<9)
}
func (o *ENET_Type) GetATCR_RESTART() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x200) >> 9
}
func (o *ENET_Type) SetATCR_CAPTURE(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x800)|value<<11)
}
func (o *ENET_Type) GetATCR_CAPTURE() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x800) >> 11
}
func (o *ENET_Type) SetATCR_SLAVE(value uint32) {
	volatile.StoreUint32(&o.ATCR.Reg, volatile.LoadUint32(&o.ATCR.Reg)&^(0x2000)|value<<13)
}
func (o *ENET_Type) GetATCR_SLAVE() uint32 {
	return (volatile.LoadUint32(&o.ATCR.Reg) & 0x2000) >> 13
}

// ENET.ATVR: Timer Value Register
func (o *ENET_Type) SetATVR(value uint32) {
	volatile.StoreUint32(&o.ATVR.Reg, value)
}
func (o *ENET_Type) GetATVR() uint32 {
	return volatile.LoadUint32(&o.ATVR.Reg)
}

// ENET.ATOFF: Timer Offset Register
func (o *ENET_Type) SetATOFF(value uint32) {
	volatile.StoreUint32(&o.ATOFF.Reg, value)
}
func (o *ENET_Type) GetATOFF() uint32 {
	return volatile.LoadUint32(&o.ATOFF.Reg)
}

// ENET.ATPER: Timer Period Register
func (o *ENET_Type) SetATPER(value uint32) {
	volatile.StoreUint32(&o.ATPER.Reg, value)
}
func (o *ENET_Type) GetATPER() uint32 {
	return volatile.LoadUint32(&o.ATPER.Reg)
}

// ENET.ATCOR: Timer Correction Register
func (o *ENET_Type) SetATCOR_COR(value uint32) {
	volatile.StoreUint32(&o.ATCOR.Reg, volatile.LoadUint32(&o.ATCOR.Reg)&^(0x7fffffff)|value)
}
func (o *ENET_Type) GetATCOR_COR() uint32 {
	return volatile.LoadUint32(&o.ATCOR.Reg) & 0x7fffffff
}

// ENET.ATINC: Time-Stamping Clock Period Register
func (o *ENET_Type) SetATINC_INC(value uint32) {
	volatile.StoreUint32(&o.ATINC.Reg, volatile.LoadUint32(&o.ATINC.Reg)&^(0x7f)|value)
}
func (o *ENET_Type) GetATINC_INC() uint32 {
	return volatile.LoadUint32(&o.ATINC.Reg) & 0x7f
}
func (o *ENET_Type) SetATINC_INC_CORR(value uint32) {
	volatile.StoreUint32(&o.ATINC.Reg, volatile.LoadUint32(&o.ATINC.Reg)&^(0x7f00)|value<<8)
}
func (o *ENET_Type) GetATINC_INC_CORR() uint32 {
	return (volatile.LoadUint32(&o.ATINC.Reg) & 0x7f00) >> 8
}

// ENET.ATSTMP: Timestamp of Last Transmitted Frame
func (o *ENET_Type) SetATSTMP(value uint32) {
	volatile.StoreUint32(&o.ATSTMP.Reg, value)
}
func (o *ENET_Type) GetATSTMP() uint32 {
	return volatile.LoadUint32(&o.ATSTMP.Reg)
}

// ENET.TGSR: Timer Global Status Register
func (o *ENET_Type) SetTGSR_TF0(value uint32) {
	volatile.StoreUint32(&o.TGSR.Reg, volatile.LoadUint32(&o.TGSR.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTGSR_TF0() uint32 {
	return volatile.LoadUint32(&o.TGSR.Reg) & 0x1
}
func (o *ENET_Type) SetTGSR_TF1(value uint32) {
	volatile.StoreUint32(&o.TGSR.Reg, volatile.LoadUint32(&o.TGSR.Reg)&^(0x2)|value<<1)
}
func (o *ENET_Type) GetTGSR_TF1() uint32 {
	return (volatile.LoadUint32(&o.TGSR.Reg) & 0x2) >> 1
}
func (o *ENET_Type) SetTGSR_TF2(value uint32) {
	volatile.StoreUint32(&o.TGSR.Reg, volatile.LoadUint32(&o.TGSR.Reg)&^(0x4)|value<<2)
}
func (o *ENET_Type) GetTGSR_TF2() uint32 {
	return (volatile.LoadUint32(&o.TGSR.Reg) & 0x4) >> 2
}
func (o *ENET_Type) SetTGSR_TF3(value uint32) {
	volatile.StoreUint32(&o.TGSR.Reg, volatile.LoadUint32(&o.TGSR.Reg)&^(0x8)|value<<3)
}
func (o *ENET_Type) GetTGSR_TF3() uint32 {
	return (volatile.LoadUint32(&o.TGSR.Reg) & 0x8) >> 3
}

// ENET.TCSR0: Timer Control Status Register
func (o *ENET_Type) SetTCSR0_TDRE(value uint32) {
	volatile.StoreUint32(&o.TCSR0.Reg, volatile.LoadUint32(&o.TCSR0.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCSR0_TDRE() uint32 {
	return volatile.LoadUint32(&o.TCSR0.Reg) & 0x1
}
func (o *ENET_Type) SetTCSR0_TMODE(value uint32) {
	volatile.StoreUint32(&o.TCSR0.Reg, volatile.LoadUint32(&o.TCSR0.Reg)&^(0x3c)|value<<2)
}
func (o *ENET_Type) GetTCSR0_TMODE() uint32 {
	return (volatile.LoadUint32(&o.TCSR0.Reg) & 0x3c) >> 2
}
func (o *ENET_Type) SetTCSR0_TIE(value uint32) {
	volatile.StoreUint32(&o.TCSR0.Reg, volatile.LoadUint32(&o.TCSR0.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetTCSR0_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR0.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetTCSR0_TF(value uint32) {
	volatile.StoreUint32(&o.TCSR0.Reg, volatile.LoadUint32(&o.TCSR0.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetTCSR0_TF() uint32 {
	return (volatile.LoadUint32(&o.TCSR0.Reg) & 0x80) >> 7
}

// ENET.TCCR0: Timer Compare Capture Register
func (o *ENET_Type) SetTCCR0(value uint32) {
	volatile.StoreUint32(&o.TCCR0.Reg, value)
}
func (o *ENET_Type) GetTCCR0() uint32 {
	return volatile.LoadUint32(&o.TCCR0.Reg)
}

// ENET.TCSR1: Timer Control Status Register
func (o *ENET_Type) SetTCSR1_TDRE(value uint32) {
	volatile.StoreUint32(&o.TCSR1.Reg, volatile.LoadUint32(&o.TCSR1.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCSR1_TDRE() uint32 {
	return volatile.LoadUint32(&o.TCSR1.Reg) & 0x1
}
func (o *ENET_Type) SetTCSR1_TMODE(value uint32) {
	volatile.StoreUint32(&o.TCSR1.Reg, volatile.LoadUint32(&o.TCSR1.Reg)&^(0x3c)|value<<2)
}
func (o *ENET_Type) GetTCSR1_TMODE() uint32 {
	return (volatile.LoadUint32(&o.TCSR1.Reg) & 0x3c) >> 2
}
func (o *ENET_Type) SetTCSR1_TIE(value uint32) {
	volatile.StoreUint32(&o.TCSR1.Reg, volatile.LoadUint32(&o.TCSR1.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetTCSR1_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR1.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetTCSR1_TF(value uint32) {
	volatile.StoreUint32(&o.TCSR1.Reg, volatile.LoadUint32(&o.TCSR1.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetTCSR1_TF() uint32 {
	return (volatile.LoadUint32(&o.TCSR1.Reg) & 0x80) >> 7
}

// ENET.TCCR1: Timer Compare Capture Register
func (o *ENET_Type) SetTCCR1(value uint32) {
	volatile.StoreUint32(&o.TCCR1.Reg, value)
}
func (o *ENET_Type) GetTCCR1() uint32 {
	return volatile.LoadUint32(&o.TCCR1.Reg)
}

// ENET.TCSR2: Timer Control Status Register
func (o *ENET_Type) SetTCSR2_TDRE(value uint32) {
	volatile.StoreUint32(&o.TCSR2.Reg, volatile.LoadUint32(&o.TCSR2.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCSR2_TDRE() uint32 {
	return volatile.LoadUint32(&o.TCSR2.Reg) & 0x1
}
func (o *ENET_Type) SetTCSR2_TMODE(value uint32) {
	volatile.StoreUint32(&o.TCSR2.Reg, volatile.LoadUint32(&o.TCSR2.Reg)&^(0x3c)|value<<2)
}
func (o *ENET_Type) GetTCSR2_TMODE() uint32 {
	return (volatile.LoadUint32(&o.TCSR2.Reg) & 0x3c) >> 2
}
func (o *ENET_Type) SetTCSR2_TIE(value uint32) {
	volatile.StoreUint32(&o.TCSR2.Reg, volatile.LoadUint32(&o.TCSR2.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetTCSR2_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR2.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetTCSR2_TF(value uint32) {
	volatile.StoreUint32(&o.TCSR2.Reg, volatile.LoadUint32(&o.TCSR2.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetTCSR2_TF() uint32 {
	return (volatile.LoadUint32(&o.TCSR2.Reg) & 0x80) >> 7
}

// ENET.TCCR2: Timer Compare Capture Register
func (o *ENET_Type) SetTCCR2(value uint32) {
	volatile.StoreUint32(&o.TCCR2.Reg, value)
}
func (o *ENET_Type) GetTCCR2() uint32 {
	return volatile.LoadUint32(&o.TCCR2.Reg)
}

// ENET.TCSR3: Timer Control Status Register
func (o *ENET_Type) SetTCSR3_TDRE(value uint32) {
	volatile.StoreUint32(&o.TCSR3.Reg, volatile.LoadUint32(&o.TCSR3.Reg)&^(0x1)|value)
}
func (o *ENET_Type) GetTCSR3_TDRE() uint32 {
	return volatile.LoadUint32(&o.TCSR3.Reg) & 0x1
}
func (o *ENET_Type) SetTCSR3_TMODE(value uint32) {
	volatile.StoreUint32(&o.TCSR3.Reg, volatile.LoadUint32(&o.TCSR3.Reg)&^(0x3c)|value<<2)
}
func (o *ENET_Type) GetTCSR3_TMODE() uint32 {
	return (volatile.LoadUint32(&o.TCSR3.Reg) & 0x3c) >> 2
}
func (o *ENET_Type) SetTCSR3_TIE(value uint32) {
	volatile.StoreUint32(&o.TCSR3.Reg, volatile.LoadUint32(&o.TCSR3.Reg)&^(0x40)|value<<6)
}
func (o *ENET_Type) GetTCSR3_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR3.Reg) & 0x40) >> 6
}
func (o *ENET_Type) SetTCSR3_TF(value uint32) {
	volatile.StoreUint32(&o.TCSR3.Reg, volatile.LoadUint32(&o.TCSR3.Reg)&^(0x80)|value<<7)
}
func (o *ENET_Type) GetTCSR3_TF() uint32 {
	return (volatile.LoadUint32(&o.TCSR3.Reg) & 0x80) >> 7
}

// ENET.TCCR3: Timer Compare Capture Register
func (o *ENET_Type) SetTCCR3(value uint32) {
	volatile.StoreUint32(&o.TCCR3.Reg, value)
}
func (o *ENET_Type) GetTCCR3() uint32 {
	return volatile.LoadUint32(&o.TCCR3.Reg)
}

// Universal Asynchronous Receiver/Transmitter
type LPUART0_Type struct {
	BAUD  volatile.Register32 // 0x0
	STAT  volatile.Register32 // 0x4
	CTRL  volatile.Register32 // 0x8
	DATA  volatile.Register32 // 0xC
	MATCH volatile.Register32 // 0x10
	MODIR volatile.Register32 // 0x14
}

// LPUART0.BAUD: LPUART Baud Rate Register
func (o *LPUART0_Type) SetBAUD_SBR(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x1fff)|value)
}
func (o *LPUART0_Type) GetBAUD_SBR() uint32 {
	return volatile.LoadUint32(&o.BAUD.Reg) & 0x1fff
}
func (o *LPUART0_Type) SetBAUD_SBNS(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x2000)|value<<13)
}
func (o *LPUART0_Type) GetBAUD_SBNS() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x2000) >> 13
}
func (o *LPUART0_Type) SetBAUD_RXEDGIE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART0_Type) GetBAUD_RXEDGIE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x4000) >> 14
}
func (o *LPUART0_Type) SetBAUD_LBKDIE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART0_Type) GetBAUD_LBKDIE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x8000) >> 15
}
func (o *LPUART0_Type) SetBAUD_RESYNCDIS(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x10000)|value<<16)
}
func (o *LPUART0_Type) GetBAUD_RESYNCDIS() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x10000) >> 16
}
func (o *LPUART0_Type) SetBAUD_BOTHEDGE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART0_Type) GetBAUD_BOTHEDGE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x20000) >> 17
}
func (o *LPUART0_Type) SetBAUD_MATCFG(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0xc0000)|value<<18)
}
func (o *LPUART0_Type) GetBAUD_MATCFG() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0xc0000) >> 18
}
func (o *LPUART0_Type) SetBAUD_RDMAE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x200000)|value<<21)
}
func (o *LPUART0_Type) GetBAUD_RDMAE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x200000) >> 21
}
func (o *LPUART0_Type) SetBAUD_TDMAE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x800000)|value<<23)
}
func (o *LPUART0_Type) GetBAUD_TDMAE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x800000) >> 23
}
func (o *LPUART0_Type) SetBAUD_OSR(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x1f000000)|value<<24)
}
func (o *LPUART0_Type) GetBAUD_OSR() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x1f000000) >> 24
}
func (o *LPUART0_Type) SetBAUD_M10(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x20000000)|value<<29)
}
func (o *LPUART0_Type) GetBAUD_M10() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x20000000) >> 29
}
func (o *LPUART0_Type) SetBAUD_MAEN2(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x40000000)|value<<30)
}
func (o *LPUART0_Type) GetBAUD_MAEN2() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x40000000) >> 30
}
func (o *LPUART0_Type) SetBAUD_MAEN1(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x80000000)|value<<31)
}
func (o *LPUART0_Type) GetBAUD_MAEN1() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x80000000) >> 31
}

// LPUART0.STAT: LPUART Status Register
func (o *LPUART0_Type) SetSTAT_MA2F(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART0_Type) GetSTAT_MA2F() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4000) >> 14
}
func (o *LPUART0_Type) SetSTAT_MA1F(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART0_Type) GetSTAT_MA1F() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8000) >> 15
}
func (o *LPUART0_Type) SetSTAT_PF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000)|value<<16)
}
func (o *LPUART0_Type) GetSTAT_PF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000) >> 16
}
func (o *LPUART0_Type) SetSTAT_FE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART0_Type) GetSTAT_FE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20000) >> 17
}
func (o *LPUART0_Type) SetSTAT_NF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40000)|value<<18)
}
func (o *LPUART0_Type) GetSTAT_NF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40000) >> 18
}
func (o *LPUART0_Type) SetSTAT_OR(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80000)|value<<19)
}
func (o *LPUART0_Type) GetSTAT_OR() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80000) >> 19
}
func (o *LPUART0_Type) SetSTAT_IDLE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x100000)|value<<20)
}
func (o *LPUART0_Type) GetSTAT_IDLE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x100000) >> 20
}
func (o *LPUART0_Type) SetSTAT_RDRF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x200000)|value<<21)
}
func (o *LPUART0_Type) GetSTAT_RDRF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x200000) >> 21
}
func (o *LPUART0_Type) SetSTAT_TC(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x400000)|value<<22)
}
func (o *LPUART0_Type) GetSTAT_TC() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x400000) >> 22
}
func (o *LPUART0_Type) SetSTAT_TDRE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x800000)|value<<23)
}
func (o *LPUART0_Type) GetSTAT_TDRE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x800000) >> 23
}
func (o *LPUART0_Type) SetSTAT_RAF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1000000)|value<<24)
}
func (o *LPUART0_Type) GetSTAT_RAF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x1000000) >> 24
}
func (o *LPUART0_Type) SetSTAT_LBKDE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2000000)|value<<25)
}
func (o *LPUART0_Type) GetSTAT_LBKDE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2000000) >> 25
}
func (o *LPUART0_Type) SetSTAT_BRK13(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4000000)|value<<26)
}
func (o *LPUART0_Type) GetSTAT_BRK13() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4000000) >> 26
}
func (o *LPUART0_Type) SetSTAT_RWUID(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8000000)|value<<27)
}
func (o *LPUART0_Type) GetSTAT_RWUID() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8000000) >> 27
}
func (o *LPUART0_Type) SetSTAT_RXINV(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000000)|value<<28)
}
func (o *LPUART0_Type) GetSTAT_RXINV() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000000) >> 28
}
func (o *LPUART0_Type) SetSTAT_MSBF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20000000)|value<<29)
}
func (o *LPUART0_Type) GetSTAT_MSBF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20000000) >> 29
}
func (o *LPUART0_Type) SetSTAT_RXEDGIF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40000000)|value<<30)
}
func (o *LPUART0_Type) GetSTAT_RXEDGIF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40000000) >> 30
}
func (o *LPUART0_Type) SetSTAT_LBKDIF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80000000)|value<<31)
}
func (o *LPUART0_Type) GetSTAT_LBKDIF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80000000) >> 31
}

// LPUART0.CTRL: LPUART Control Register
func (o *LPUART0_Type) SetCTRL_PT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *LPUART0_Type) GetCTRL_PT() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *LPUART0_Type) SetCTRL_PE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *LPUART0_Type) GetCTRL_PE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *LPUART0_Type) SetCTRL_ILT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *LPUART0_Type) GetCTRL_ILT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *LPUART0_Type) SetCTRL_WAKE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *LPUART0_Type) GetCTRL_WAKE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *LPUART0_Type) SetCTRL_M(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *LPUART0_Type) GetCTRL_M() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *LPUART0_Type) SetCTRL_RSRC(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *LPUART0_Type) GetCTRL_RSRC() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *LPUART0_Type) SetCTRL_DOZEEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *LPUART0_Type) GetCTRL_DOZEEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *LPUART0_Type) SetCTRL_LOOPS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *LPUART0_Type) GetCTRL_LOOPS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *LPUART0_Type) SetCTRL_IDLECFG(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x700)|value<<8)
}
func (o *LPUART0_Type) GetCTRL_IDLECFG() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x700) >> 8
}
func (o *LPUART0_Type) SetCTRL_MA2IE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART0_Type) GetCTRL_MA2IE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000) >> 14
}
func (o *LPUART0_Type) SetCTRL_MA1IE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART0_Type) GetCTRL_MA1IE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000) >> 15
}
func (o *LPUART0_Type) SetCTRL_SBK(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *LPUART0_Type) GetCTRL_SBK() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *LPUART0_Type) SetCTRL_RWU(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART0_Type) GetCTRL_RWU() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000) >> 17
}
func (o *LPUART0_Type) SetCTRL_RE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *LPUART0_Type) GetCTRL_RE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *LPUART0_Type) SetCTRL_TE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *LPUART0_Type) GetCTRL_TE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *LPUART0_Type) SetCTRL_ILIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *LPUART0_Type) GetCTRL_ILIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *LPUART0_Type) SetCTRL_RIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *LPUART0_Type) GetCTRL_RIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *LPUART0_Type) SetCTRL_TCIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *LPUART0_Type) GetCTRL_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400000) >> 22
}
func (o *LPUART0_Type) SetCTRL_TIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *LPUART0_Type) GetCTRL_TIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800000) >> 23
}
func (o *LPUART0_Type) SetCTRL_PEIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *LPUART0_Type) GetCTRL_PEIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *LPUART0_Type) SetCTRL_FEIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *LPUART0_Type) GetCTRL_FEIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *LPUART0_Type) SetCTRL_NEIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *LPUART0_Type) GetCTRL_NEIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000000) >> 26
}
func (o *LPUART0_Type) SetCTRL_ORIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *LPUART0_Type) GetCTRL_ORIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000000) >> 27
}
func (o *LPUART0_Type) SetCTRL_TXINV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *LPUART0_Type) GetCTRL_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000000) >> 28
}
func (o *LPUART0_Type) SetCTRL_TXDIR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *LPUART0_Type) GetCTRL_TXDIR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *LPUART0_Type) SetCTRL_R9T8(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *LPUART0_Type) GetCTRL_R9T8() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *LPUART0_Type) SetCTRL_R8T9(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *LPUART0_Type) GetCTRL_R8T9() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// LPUART0.DATA: LPUART Data Register
func (o *LPUART0_Type) SetDATA_R0T0(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x1)|value)
}
func (o *LPUART0_Type) GetDATA_R0T0() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0x1
}
func (o *LPUART0_Type) SetDATA_R1T1(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x2)|value<<1)
}
func (o *LPUART0_Type) GetDATA_R1T1() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x2) >> 1
}
func (o *LPUART0_Type) SetDATA_R2T2(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x4)|value<<2)
}
func (o *LPUART0_Type) GetDATA_R2T2() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x4) >> 2
}
func (o *LPUART0_Type) SetDATA_R3T3(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x8)|value<<3)
}
func (o *LPUART0_Type) GetDATA_R3T3() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x8) >> 3
}
func (o *LPUART0_Type) SetDATA_R4T4(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x10)|value<<4)
}
func (o *LPUART0_Type) GetDATA_R4T4() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x10) >> 4
}
func (o *LPUART0_Type) SetDATA_R5T5(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x20)|value<<5)
}
func (o *LPUART0_Type) GetDATA_R5T5() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x20) >> 5
}
func (o *LPUART0_Type) SetDATA_R6T6(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x40)|value<<6)
}
func (o *LPUART0_Type) GetDATA_R6T6() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x40) >> 6
}
func (o *LPUART0_Type) SetDATA_R7T7(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x80)|value<<7)
}
func (o *LPUART0_Type) GetDATA_R7T7() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x80) >> 7
}
func (o *LPUART0_Type) SetDATA_R8T8(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x100)|value<<8)
}
func (o *LPUART0_Type) GetDATA_R8T8() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x100) >> 8
}
func (o *LPUART0_Type) SetDATA_R9T9(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x200)|value<<9)
}
func (o *LPUART0_Type) GetDATA_R9T9() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x200) >> 9
}
func (o *LPUART0_Type) SetDATA_IDLINE(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x800)|value<<11)
}
func (o *LPUART0_Type) GetDATA_IDLINE() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x800) >> 11
}
func (o *LPUART0_Type) SetDATA_RXEMPT(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x1000)|value<<12)
}
func (o *LPUART0_Type) GetDATA_RXEMPT() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x1000) >> 12
}
func (o *LPUART0_Type) SetDATA_FRETSC(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x2000)|value<<13)
}
func (o *LPUART0_Type) GetDATA_FRETSC() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x2000) >> 13
}
func (o *LPUART0_Type) SetDATA_PARITYE(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART0_Type) GetDATA_PARITYE() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x4000) >> 14
}
func (o *LPUART0_Type) SetDATA_NOISY(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART0_Type) GetDATA_NOISY() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x8000) >> 15
}

// LPUART0.MATCH: LPUART Match Address Register
func (o *LPUART0_Type) SetMATCH_MA1(value uint32) {
	volatile.StoreUint32(&o.MATCH.Reg, volatile.LoadUint32(&o.MATCH.Reg)&^(0x3ff)|value)
}
func (o *LPUART0_Type) GetMATCH_MA1() uint32 {
	return volatile.LoadUint32(&o.MATCH.Reg) & 0x3ff
}
func (o *LPUART0_Type) SetMATCH_MA2(value uint32) {
	volatile.StoreUint32(&o.MATCH.Reg, volatile.LoadUint32(&o.MATCH.Reg)&^(0x3ff0000)|value<<16)
}
func (o *LPUART0_Type) GetMATCH_MA2() uint32 {
	return (volatile.LoadUint32(&o.MATCH.Reg) & 0x3ff0000) >> 16
}

// LPUART0.MODIR: LPUART Modem IrDA Register
func (o *LPUART0_Type) SetMODIR_TXCTSE(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x1)|value)
}
func (o *LPUART0_Type) GetMODIR_TXCTSE() uint32 {
	return volatile.LoadUint32(&o.MODIR.Reg) & 0x1
}
func (o *LPUART0_Type) SetMODIR_TXRTSE(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x2)|value<<1)
}
func (o *LPUART0_Type) GetMODIR_TXRTSE() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x2) >> 1
}
func (o *LPUART0_Type) SetMODIR_TXRTSPOL(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x4)|value<<2)
}
func (o *LPUART0_Type) GetMODIR_TXRTSPOL() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x4) >> 2
}
func (o *LPUART0_Type) SetMODIR_RXRTSE(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x8)|value<<3)
}
func (o *LPUART0_Type) GetMODIR_RXRTSE() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x8) >> 3
}
func (o *LPUART0_Type) SetMODIR_TXCTSC(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x10)|value<<4)
}
func (o *LPUART0_Type) GetMODIR_TXCTSC() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x10) >> 4
}
func (o *LPUART0_Type) SetMODIR_TXCTSSRC(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x20)|value<<5)
}
func (o *LPUART0_Type) GetMODIR_TXCTSSRC() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x20) >> 5
}
func (o *LPUART0_Type) SetMODIR_TNP(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x30000)|value<<16)
}
func (o *LPUART0_Type) GetMODIR_TNP() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x30000) >> 16
}
func (o *LPUART0_Type) SetMODIR_IREN(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x40000)|value<<18)
}
func (o *LPUART0_Type) GetMODIR_IREN() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x40000) >> 18
}

// Timer/PWM Module
type TPM_Type struct {
	SC      volatile.Register32 // 0x0
	CNT     volatile.Register32 // 0x4
	MOD     volatile.Register32 // 0x8
	C0SC    volatile.Register32 // 0xC
	C0V     volatile.Register32 // 0x10
	C1SC    volatile.Register32 // 0x14
	C1V     volatile.Register32 // 0x18
	_       [52]byte
	STATUS  volatile.Register32 // 0x50
	_       [16]byte
	COMBINE volatile.Register32 // 0x64
	_       [8]byte
	POL     volatile.Register32 // 0x70
	_       [4]byte
	FILTER  volatile.Register32 // 0x78
	_       [4]byte
	QDCTRL  volatile.Register32 // 0x80
	CONF    volatile.Register32 // 0x84
}

// TPM.SC: Status and Control
func (o *TPM_Type) SetSC_PS(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x7)|value)
}
func (o *TPM_Type) GetSC_PS() uint32 {
	return volatile.LoadUint32(&o.SC.Reg) & 0x7
}
func (o *TPM_Type) SetSC_CMOD(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x18)|value<<3)
}
func (o *TPM_Type) GetSC_CMOD() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x18) >> 3
}
func (o *TPM_Type) SetSC_CPWMS(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x20)|value<<5)
}
func (o *TPM_Type) GetSC_CPWMS() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x20) >> 5
}
func (o *TPM_Type) SetSC_TOIE(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x40)|value<<6)
}
func (o *TPM_Type) GetSC_TOIE() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x40) >> 6
}
func (o *TPM_Type) SetSC_TOF(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x80)|value<<7)
}
func (o *TPM_Type) GetSC_TOF() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x80) >> 7
}
func (o *TPM_Type) SetSC_DMA(value uint32) {
	volatile.StoreUint32(&o.SC.Reg, volatile.LoadUint32(&o.SC.Reg)&^(0x100)|value<<8)
}
func (o *TPM_Type) GetSC_DMA() uint32 {
	return (volatile.LoadUint32(&o.SC.Reg) & 0x100) >> 8
}

// TPM.CNT: Counter
func (o *TPM_Type) SetCNT_COUNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *TPM_Type) GetCNT_COUNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// TPM.MOD: Modulo
func (o *TPM_Type) SetMOD(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0xffff)|value)
}
func (o *TPM_Type) GetMOD() uint32 {
	return volatile.LoadUint32(&o.MOD.Reg) & 0xffff
}

// TPM.C0SC: Channel (n) Status and Control
func (o *TPM_Type) SetC0SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x1)|value)
}
func (o *TPM_Type) GetC0SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C0SC.Reg) & 0x1
}
func (o *TPM_Type) SetC0SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x4)|value<<2)
}
func (o *TPM_Type) GetC0SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x4) >> 2
}
func (o *TPM_Type) SetC0SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x8)|value<<3)
}
func (o *TPM_Type) GetC0SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x8) >> 3
}
func (o *TPM_Type) SetC0SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x10)|value<<4)
}
func (o *TPM_Type) GetC0SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x10) >> 4
}
func (o *TPM_Type) SetC0SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x20)|value<<5)
}
func (o *TPM_Type) GetC0SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x20) >> 5
}
func (o *TPM_Type) SetC0SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x40)|value<<6)
}
func (o *TPM_Type) GetC0SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x40) >> 6
}
func (o *TPM_Type) SetC0SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C0SC.Reg, volatile.LoadUint32(&o.C0SC.Reg)&^(0x80)|value<<7)
}
func (o *TPM_Type) GetC0SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C0SC.Reg) & 0x80) >> 7
}

// TPM.C0V: Channel (n) Value
func (o *TPM_Type) SetC0V_VAL(value uint32) {
	volatile.StoreUint32(&o.C0V.Reg, volatile.LoadUint32(&o.C0V.Reg)&^(0xffff)|value)
}
func (o *TPM_Type) GetC0V_VAL() uint32 {
	return volatile.LoadUint32(&o.C0V.Reg) & 0xffff
}

// TPM.C1SC: Channel (n) Status and Control
func (o *TPM_Type) SetC1SC_DMA(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x1)|value)
}
func (o *TPM_Type) GetC1SC_DMA() uint32 {
	return volatile.LoadUint32(&o.C1SC.Reg) & 0x1
}
func (o *TPM_Type) SetC1SC_ELSA(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x4)|value<<2)
}
func (o *TPM_Type) GetC1SC_ELSA() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x4) >> 2
}
func (o *TPM_Type) SetC1SC_ELSB(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x8)|value<<3)
}
func (o *TPM_Type) GetC1SC_ELSB() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x8) >> 3
}
func (o *TPM_Type) SetC1SC_MSA(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x10)|value<<4)
}
func (o *TPM_Type) GetC1SC_MSA() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x10) >> 4
}
func (o *TPM_Type) SetC1SC_MSB(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x20)|value<<5)
}
func (o *TPM_Type) GetC1SC_MSB() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x20) >> 5
}
func (o *TPM_Type) SetC1SC_CHIE(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x40)|value<<6)
}
func (o *TPM_Type) GetC1SC_CHIE() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x40) >> 6
}
func (o *TPM_Type) SetC1SC_CHF(value uint32) {
	volatile.StoreUint32(&o.C1SC.Reg, volatile.LoadUint32(&o.C1SC.Reg)&^(0x80)|value<<7)
}
func (o *TPM_Type) GetC1SC_CHF() uint32 {
	return (volatile.LoadUint32(&o.C1SC.Reg) & 0x80) >> 7
}

// TPM.C1V: Channel (n) Value
func (o *TPM_Type) SetC1V_VAL(value uint32) {
	volatile.StoreUint32(&o.C1V.Reg, volatile.LoadUint32(&o.C1V.Reg)&^(0xffff)|value)
}
func (o *TPM_Type) GetC1V_VAL() uint32 {
	return volatile.LoadUint32(&o.C1V.Reg) & 0xffff
}

// TPM.STATUS: Capture and Compare Status
func (o *TPM_Type) SetSTATUS_CH0F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *TPM_Type) GetSTATUS_CH0F() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *TPM_Type) SetSTATUS_CH1F(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TPM_Type) GetSTATUS_CH1F() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *TPM_Type) SetSTATUS_TOF(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *TPM_Type) GetSTATUS_TOF() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}

// TPM.COMBINE: Combine Channel Register
func (o *TPM_Type) SetCOMBINE_COMBINE0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x1)|value)
}
func (o *TPM_Type) GetCOMBINE_COMBINE0() uint32 {
	return volatile.LoadUint32(&o.COMBINE.Reg) & 0x1
}
func (o *TPM_Type) SetCOMBINE_COMSWAP0(value uint32) {
	volatile.StoreUint32(&o.COMBINE.Reg, volatile.LoadUint32(&o.COMBINE.Reg)&^(0x2)|value<<1)
}
func (o *TPM_Type) GetCOMBINE_COMSWAP0() uint32 {
	return (volatile.LoadUint32(&o.COMBINE.Reg) & 0x2) >> 1
}

// TPM.POL: Channel Polarity
func (o *TPM_Type) SetPOL_POL0(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x1)|value)
}
func (o *TPM_Type) GetPOL_POL0() uint32 {
	return volatile.LoadUint32(&o.POL.Reg) & 0x1
}
func (o *TPM_Type) SetPOL_POL1(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x2)|value<<1)
}
func (o *TPM_Type) GetPOL_POL1() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x2) >> 1
}

// TPM.FILTER: Filter Control
func (o *TPM_Type) SetFILTER_CH0FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf)|value)
}
func (o *TPM_Type) GetFILTER_CH0FVAL() uint32 {
	return volatile.LoadUint32(&o.FILTER.Reg) & 0xf
}
func (o *TPM_Type) SetFILTER_CH1FVAL(value uint32) {
	volatile.StoreUint32(&o.FILTER.Reg, volatile.LoadUint32(&o.FILTER.Reg)&^(0xf0)|value<<4)
}
func (o *TPM_Type) GetFILTER_CH1FVAL() uint32 {
	return (volatile.LoadUint32(&o.FILTER.Reg) & 0xf0) >> 4
}

// TPM.QDCTRL: Quadrature Decoder Control and Status
func (o *TPM_Type) SetQDCTRL_QUADEN(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x1)|value)
}
func (o *TPM_Type) GetQDCTRL_QUADEN() uint32 {
	return volatile.LoadUint32(&o.QDCTRL.Reg) & 0x1
}
func (o *TPM_Type) SetQDCTRL_TOFDIR(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x2)|value<<1)
}
func (o *TPM_Type) GetQDCTRL_TOFDIR() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x2) >> 1
}
func (o *TPM_Type) SetQDCTRL_QUADIR(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x4)|value<<2)
}
func (o *TPM_Type) GetQDCTRL_QUADIR() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x4) >> 2
}
func (o *TPM_Type) SetQDCTRL_QUADMODE(value uint32) {
	volatile.StoreUint32(&o.QDCTRL.Reg, volatile.LoadUint32(&o.QDCTRL.Reg)&^(0x8)|value<<3)
}
func (o *TPM_Type) GetQDCTRL_QUADMODE() uint32 {
	return (volatile.LoadUint32(&o.QDCTRL.Reg) & 0x8) >> 3
}

// TPM.CONF: Configuration
func (o *TPM_Type) SetCONF_DOZEEN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20)|value<<5)
}
func (o *TPM_Type) GetCONF_DOZEEN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20) >> 5
}
func (o *TPM_Type) SetCONF_DBGMODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xc0)|value<<6)
}
func (o *TPM_Type) GetCONF_DBGMODE() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xc0) >> 6
}
func (o *TPM_Type) SetCONF_GTBSYNC(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x100)|value<<8)
}
func (o *TPM_Type) GetCONF_GTBSYNC() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x100) >> 8
}
func (o *TPM_Type) SetCONF_GTBEEN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x200)|value<<9)
}
func (o *TPM_Type) GetCONF_GTBEEN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x200) >> 9
}
func (o *TPM_Type) SetCONF_CSOT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10000)|value<<16)
}
func (o *TPM_Type) GetCONF_CSOT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10000) >> 16
}
func (o *TPM_Type) SetCONF_CSOO(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20000)|value<<17)
}
func (o *TPM_Type) GetCONF_CSOO() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20000) >> 17
}
func (o *TPM_Type) SetCONF_CROT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x40000)|value<<18)
}
func (o *TPM_Type) GetCONF_CROT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x40000) >> 18
}
func (o *TPM_Type) SetCONF_CPOT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80000)|value<<19)
}
func (o *TPM_Type) GetCONF_CPOT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80000) >> 19
}
func (o *TPM_Type) SetCONF_TRGPOL(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x400000)|value<<22)
}
func (o *TPM_Type) GetCONF_TRGPOL() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x400000) >> 22
}
func (o *TPM_Type) SetCONF_TRGSRC(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x800000)|value<<23)
}
func (o *TPM_Type) GetCONF_TRGSRC() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x800000) >> 23
}
func (o *TPM_Type) SetCONF_TRGSEL(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xf000000)|value<<24)
}
func (o *TPM_Type) GetCONF_TRGSEL() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xf000000) >> 24
}

// 12-Bit Digital-to-Analog Converter
type DAC_Type struct {
	DAT0L  volatile.Register8 // 0x0
	DAT0H  volatile.Register8 // 0x1
	DAT1L  volatile.Register8 // 0x2
	DAT1H  volatile.Register8 // 0x3
	DAT2L  volatile.Register8 // 0x4
	DAT2H  volatile.Register8 // 0x5
	DAT3L  volatile.Register8 // 0x6
	DAT3H  volatile.Register8 // 0x7
	DAT4L  volatile.Register8 // 0x8
	DAT4H  volatile.Register8 // 0x9
	DAT5L  volatile.Register8 // 0xA
	DAT5H  volatile.Register8 // 0xB
	DAT6L  volatile.Register8 // 0xC
	DAT6H  volatile.Register8 // 0xD
	DAT7L  volatile.Register8 // 0xE
	DAT7H  volatile.Register8 // 0xF
	DAT8L  volatile.Register8 // 0x10
	DAT8H  volatile.Register8 // 0x11
	DAT9L  volatile.Register8 // 0x12
	DAT9H  volatile.Register8 // 0x13
	DAT10L volatile.Register8 // 0x14
	DAT10H volatile.Register8 // 0x15
	DAT11L volatile.Register8 // 0x16
	DAT11H volatile.Register8 // 0x17
	DAT12L volatile.Register8 // 0x18
	DAT12H volatile.Register8 // 0x19
	DAT13L volatile.Register8 // 0x1A
	DAT13H volatile.Register8 // 0x1B
	DAT14L volatile.Register8 // 0x1C
	DAT14H volatile.Register8 // 0x1D
	DAT15L volatile.Register8 // 0x1E
	DAT15H volatile.Register8 // 0x1F
	SR     volatile.Register8 // 0x20
	C0     volatile.Register8 // 0x21
	C1     volatile.Register8 // 0x22
	C2     volatile.Register8 // 0x23
}

// DAC.DAT0L: DAC Data Low Register
func (o *DAC_Type) SetDAT0L(value uint8) {
	volatile.StoreUint8(&o.DAT0L.Reg, value)
}
func (o *DAC_Type) GetDAT0L() uint8 {
	return volatile.LoadUint8(&o.DAT0L.Reg)
}

// DAC.DAT0H: DAC Data High Register
func (o *DAC_Type) SetDAT0H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT0H.Reg, volatile.LoadUint8(&o.DAT0H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT0H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT0H.Reg) & 0xf
}

// DAC.DAT1L: DAC Data Low Register
func (o *DAC_Type) SetDAT1L(value uint8) {
	volatile.StoreUint8(&o.DAT1L.Reg, value)
}
func (o *DAC_Type) GetDAT1L() uint8 {
	return volatile.LoadUint8(&o.DAT1L.Reg)
}

// DAC.DAT1H: DAC Data High Register
func (o *DAC_Type) SetDAT1H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT1H.Reg, volatile.LoadUint8(&o.DAT1H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT1H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT1H.Reg) & 0xf
}

// DAC.DAT2L: DAC Data Low Register
func (o *DAC_Type) SetDAT2L(value uint8) {
	volatile.StoreUint8(&o.DAT2L.Reg, value)
}
func (o *DAC_Type) GetDAT2L() uint8 {
	return volatile.LoadUint8(&o.DAT2L.Reg)
}

// DAC.DAT2H: DAC Data High Register
func (o *DAC_Type) SetDAT2H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT2H.Reg, volatile.LoadUint8(&o.DAT2H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT2H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT2H.Reg) & 0xf
}

// DAC.DAT3L: DAC Data Low Register
func (o *DAC_Type) SetDAT3L(value uint8) {
	volatile.StoreUint8(&o.DAT3L.Reg, value)
}
func (o *DAC_Type) GetDAT3L() uint8 {
	return volatile.LoadUint8(&o.DAT3L.Reg)
}

// DAC.DAT3H: DAC Data High Register
func (o *DAC_Type) SetDAT3H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT3H.Reg, volatile.LoadUint8(&o.DAT3H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT3H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT3H.Reg) & 0xf
}

// DAC.DAT4L: DAC Data Low Register
func (o *DAC_Type) SetDAT4L(value uint8) {
	volatile.StoreUint8(&o.DAT4L.Reg, value)
}
func (o *DAC_Type) GetDAT4L() uint8 {
	return volatile.LoadUint8(&o.DAT4L.Reg)
}

// DAC.DAT4H: DAC Data High Register
func (o *DAC_Type) SetDAT4H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT4H.Reg, volatile.LoadUint8(&o.DAT4H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT4H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT4H.Reg) & 0xf
}

// DAC.DAT5L: DAC Data Low Register
func (o *DAC_Type) SetDAT5L(value uint8) {
	volatile.StoreUint8(&o.DAT5L.Reg, value)
}
func (o *DAC_Type) GetDAT5L() uint8 {
	return volatile.LoadUint8(&o.DAT5L.Reg)
}

// DAC.DAT5H: DAC Data High Register
func (o *DAC_Type) SetDAT5H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT5H.Reg, volatile.LoadUint8(&o.DAT5H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT5H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT5H.Reg) & 0xf
}

// DAC.DAT6L: DAC Data Low Register
func (o *DAC_Type) SetDAT6L(value uint8) {
	volatile.StoreUint8(&o.DAT6L.Reg, value)
}
func (o *DAC_Type) GetDAT6L() uint8 {
	return volatile.LoadUint8(&o.DAT6L.Reg)
}

// DAC.DAT6H: DAC Data High Register
func (o *DAC_Type) SetDAT6H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT6H.Reg, volatile.LoadUint8(&o.DAT6H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT6H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT6H.Reg) & 0xf
}

// DAC.DAT7L: DAC Data Low Register
func (o *DAC_Type) SetDAT7L(value uint8) {
	volatile.StoreUint8(&o.DAT7L.Reg, value)
}
func (o *DAC_Type) GetDAT7L() uint8 {
	return volatile.LoadUint8(&o.DAT7L.Reg)
}

// DAC.DAT7H: DAC Data High Register
func (o *DAC_Type) SetDAT7H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT7H.Reg, volatile.LoadUint8(&o.DAT7H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT7H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT7H.Reg) & 0xf
}

// DAC.DAT8L: DAC Data Low Register
func (o *DAC_Type) SetDAT8L(value uint8) {
	volatile.StoreUint8(&o.DAT8L.Reg, value)
}
func (o *DAC_Type) GetDAT8L() uint8 {
	return volatile.LoadUint8(&o.DAT8L.Reg)
}

// DAC.DAT8H: DAC Data High Register
func (o *DAC_Type) SetDAT8H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT8H.Reg, volatile.LoadUint8(&o.DAT8H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT8H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT8H.Reg) & 0xf
}

// DAC.DAT9L: DAC Data Low Register
func (o *DAC_Type) SetDAT9L(value uint8) {
	volatile.StoreUint8(&o.DAT9L.Reg, value)
}
func (o *DAC_Type) GetDAT9L() uint8 {
	return volatile.LoadUint8(&o.DAT9L.Reg)
}

// DAC.DAT9H: DAC Data High Register
func (o *DAC_Type) SetDAT9H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT9H.Reg, volatile.LoadUint8(&o.DAT9H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT9H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT9H.Reg) & 0xf
}

// DAC.DAT10L: DAC Data Low Register
func (o *DAC_Type) SetDAT10L(value uint8) {
	volatile.StoreUint8(&o.DAT10L.Reg, value)
}
func (o *DAC_Type) GetDAT10L() uint8 {
	return volatile.LoadUint8(&o.DAT10L.Reg)
}

// DAC.DAT10H: DAC Data High Register
func (o *DAC_Type) SetDAT10H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT10H.Reg, volatile.LoadUint8(&o.DAT10H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT10H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT10H.Reg) & 0xf
}

// DAC.DAT11L: DAC Data Low Register
func (o *DAC_Type) SetDAT11L(value uint8) {
	volatile.StoreUint8(&o.DAT11L.Reg, value)
}
func (o *DAC_Type) GetDAT11L() uint8 {
	return volatile.LoadUint8(&o.DAT11L.Reg)
}

// DAC.DAT11H: DAC Data High Register
func (o *DAC_Type) SetDAT11H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT11H.Reg, volatile.LoadUint8(&o.DAT11H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT11H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT11H.Reg) & 0xf
}

// DAC.DAT12L: DAC Data Low Register
func (o *DAC_Type) SetDAT12L(value uint8) {
	volatile.StoreUint8(&o.DAT12L.Reg, value)
}
func (o *DAC_Type) GetDAT12L() uint8 {
	return volatile.LoadUint8(&o.DAT12L.Reg)
}

// DAC.DAT12H: DAC Data High Register
func (o *DAC_Type) SetDAT12H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT12H.Reg, volatile.LoadUint8(&o.DAT12H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT12H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT12H.Reg) & 0xf
}

// DAC.DAT13L: DAC Data Low Register
func (o *DAC_Type) SetDAT13L(value uint8) {
	volatile.StoreUint8(&o.DAT13L.Reg, value)
}
func (o *DAC_Type) GetDAT13L() uint8 {
	return volatile.LoadUint8(&o.DAT13L.Reg)
}

// DAC.DAT13H: DAC Data High Register
func (o *DAC_Type) SetDAT13H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT13H.Reg, volatile.LoadUint8(&o.DAT13H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT13H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT13H.Reg) & 0xf
}

// DAC.DAT14L: DAC Data Low Register
func (o *DAC_Type) SetDAT14L(value uint8) {
	volatile.StoreUint8(&o.DAT14L.Reg, value)
}
func (o *DAC_Type) GetDAT14L() uint8 {
	return volatile.LoadUint8(&o.DAT14L.Reg)
}

// DAC.DAT14H: DAC Data High Register
func (o *DAC_Type) SetDAT14H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT14H.Reg, volatile.LoadUint8(&o.DAT14H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT14H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT14H.Reg) & 0xf
}

// DAC.DAT15L: DAC Data Low Register
func (o *DAC_Type) SetDAT15L(value uint8) {
	volatile.StoreUint8(&o.DAT15L.Reg, value)
}
func (o *DAC_Type) GetDAT15L() uint8 {
	return volatile.LoadUint8(&o.DAT15L.Reg)
}

// DAC.DAT15H: DAC Data High Register
func (o *DAC_Type) SetDAT15H_DATA1(value uint8) {
	volatile.StoreUint8(&o.DAT15H.Reg, volatile.LoadUint8(&o.DAT15H.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetDAT15H_DATA1() uint8 {
	return volatile.LoadUint8(&o.DAT15H.Reg) & 0xf
}

// DAC.SR: DAC Status Register
func (o *DAC_Type) SetSR_DACBFRPBF(value uint8) {
	volatile.StoreUint8(&o.SR.Reg, volatile.LoadUint8(&o.SR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSR_DACBFRPBF() uint8 {
	return volatile.LoadUint8(&o.SR.Reg) & 0x1
}
func (o *DAC_Type) SetSR_DACBFRPTF(value uint8) {
	volatile.StoreUint8(&o.SR.Reg, volatile.LoadUint8(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetSR_DACBFRPTF() uint8 {
	return (volatile.LoadUint8(&o.SR.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetSR_DACBFWMF(value uint8) {
	volatile.StoreUint8(&o.SR.Reg, volatile.LoadUint8(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetSR_DACBFWMF() uint8 {
	return (volatile.LoadUint8(&o.SR.Reg) & 0x4) >> 2
}

// DAC.C0: DAC Control Register
func (o *DAC_Type) SetC0_DACBBIEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetC0_DACBBIEN() uint8 {
	return volatile.LoadUint8(&o.C0.Reg) & 0x1
}
func (o *DAC_Type) SetC0_DACBTIEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetC0_DACBTIEN() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetC0_DACBWIEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetC0_DACBWIEN() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetC0_LPEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetC0_LPEN() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetC0_DACSWTRG(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetC0_DACSWTRG() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetC0_DACTRGSEL(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetC0_DACTRGSEL() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetC0_DACRFS(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetC0_DACRFS() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x40) >> 6
}
func (o *DAC_Type) SetC0_DACEN(value uint8) {
	volatile.StoreUint8(&o.C0.Reg, volatile.LoadUint8(&o.C0.Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetC0_DACEN() uint8 {
	return (volatile.LoadUint8(&o.C0.Reg) & 0x80) >> 7
}

// DAC.C1: DAC Control Register 1
func (o *DAC_Type) SetC1_DACBFEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetC1_DACBFEN() uint8 {
	return volatile.LoadUint8(&o.C1.Reg) & 0x1
}
func (o *DAC_Type) SetC1_DACBFMD(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x6)|value<<1)
}
func (o *DAC_Type) GetC1_DACBFMD() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x6) >> 1
}
func (o *DAC_Type) SetC1_DACBFWM(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x18)|value<<3)
}
func (o *DAC_Type) GetC1_DACBFWM() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x18) >> 3
}
func (o *DAC_Type) SetC1_DMAEN(value uint8) {
	volatile.StoreUint8(&o.C1.Reg, volatile.LoadUint8(&o.C1.Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetC1_DMAEN() uint8 {
	return (volatile.LoadUint8(&o.C1.Reg) & 0x80) >> 7
}

// DAC.C2: DAC Control Register 2
func (o *DAC_Type) SetC2_DACBFUP(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetC2_DACBFUP() uint8 {
	return volatile.LoadUint8(&o.C2.Reg) & 0xf
}
func (o *DAC_Type) SetC2_DACBFRP(value uint8) {
	volatile.StoreUint8(&o.C2.Reg, volatile.LoadUint8(&o.C2.Reg)&^(0xf0)|value<<4)
}
func (o *DAC_Type) GetC2_DACBFRP() uint8 {
	return (volatile.LoadUint8(&o.C2.Reg) & 0xf0) >> 4
}

// General Purpose Input/Output
type GPIO_Type struct {
	PDOR volatile.Register32 // 0x0
	PSOR volatile.Register32 // 0x4
	PCOR volatile.Register32 // 0x8
	PTOR volatile.Register32 // 0xC
	PDIR volatile.Register32 // 0x10
	PDDR volatile.Register32 // 0x14
}

// GPIO.PDOR: Port Data Output Register
func (o *GPIO_Type) SetPDOR_PDO0(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPDOR_PDO0() uint32 {
	return volatile.LoadUint32(&o.PDOR.Reg) & 0x1
}
func (o *GPIO_Type) SetPDOR_PDO1(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPDOR_PDO1() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPDOR_PDO2(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPDOR_PDO2() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPDOR_PDO3(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPDOR_PDO3() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPDOR_PDO4(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPDOR_PDO4() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPDOR_PDO5(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPDOR_PDO5() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPDOR_PDO6(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPDOR_PDO6() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPDOR_PDO7(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPDOR_PDO7() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPDOR_PDO8(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPDOR_PDO8() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPDOR_PDO9(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPDOR_PDO9() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPDOR_PDO10(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPDOR_PDO10() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPDOR_PDO11(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPDOR_PDO11() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPDOR_PDO12(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPDOR_PDO12() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPDOR_PDO13(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPDOR_PDO13() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPDOR_PDO14(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPDOR_PDO14() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPDOR_PDO15(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPDOR_PDO15() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPDOR_PDO16(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPDOR_PDO16() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPDOR_PDO17(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPDOR_PDO17() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPDOR_PDO18(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPDOR_PDO18() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPDOR_PDO19(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPDOR_PDO19() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPDOR_PDO20(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPDOR_PDO20() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPDOR_PDO21(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPDOR_PDO21() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPDOR_PDO22(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPDOR_PDO22() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPDOR_PDO23(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPDOR_PDO23() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPDOR_PDO24(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPDOR_PDO24() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPDOR_PDO25(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPDOR_PDO25() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPDOR_PDO26(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPDOR_PDO26() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPDOR_PDO27(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPDOR_PDO27() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPDOR_PDO28(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPDOR_PDO28() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPDOR_PDO29(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPDOR_PDO29() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPDOR_PDO30(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPDOR_PDO30() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPDOR_PDO31(value uint32) {
	volatile.StoreUint32(&o.PDOR.Reg, volatile.LoadUint32(&o.PDOR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPDOR_PDO31() uint32 {
	return (volatile.LoadUint32(&o.PDOR.Reg) & 0x80000000) >> 31
}

// GPIO.PSOR: Port Set Output Register
func (o *GPIO_Type) SetPSOR_PTSO0(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPSOR_PTSO0() uint32 {
	return volatile.LoadUint32(&o.PSOR.Reg) & 0x1
}
func (o *GPIO_Type) SetPSOR_PTSO1(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPSOR_PTSO1() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPSOR_PTSO2(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPSOR_PTSO2() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPSOR_PTSO3(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPSOR_PTSO3() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPSOR_PTSO4(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPSOR_PTSO4() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPSOR_PTSO5(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPSOR_PTSO5() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPSOR_PTSO6(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPSOR_PTSO6() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPSOR_PTSO7(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPSOR_PTSO7() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPSOR_PTSO8(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPSOR_PTSO8() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPSOR_PTSO9(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPSOR_PTSO9() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPSOR_PTSO10(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPSOR_PTSO10() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPSOR_PTSO11(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPSOR_PTSO11() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPSOR_PTSO12(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPSOR_PTSO12() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPSOR_PTSO13(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPSOR_PTSO13() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPSOR_PTSO14(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPSOR_PTSO14() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPSOR_PTSO15(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPSOR_PTSO15() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPSOR_PTSO16(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPSOR_PTSO16() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPSOR_PTSO17(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPSOR_PTSO17() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPSOR_PTSO18(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPSOR_PTSO18() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPSOR_PTSO19(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPSOR_PTSO19() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPSOR_PTSO20(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPSOR_PTSO20() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPSOR_PTSO21(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPSOR_PTSO21() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPSOR_PTSO22(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPSOR_PTSO22() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPSOR_PTSO23(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPSOR_PTSO23() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPSOR_PTSO24(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPSOR_PTSO24() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPSOR_PTSO25(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPSOR_PTSO25() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPSOR_PTSO26(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPSOR_PTSO26() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPSOR_PTSO27(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPSOR_PTSO27() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPSOR_PTSO28(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPSOR_PTSO28() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPSOR_PTSO29(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPSOR_PTSO29() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPSOR_PTSO30(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPSOR_PTSO30() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPSOR_PTSO31(value uint32) {
	volatile.StoreUint32(&o.PSOR.Reg, volatile.LoadUint32(&o.PSOR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPSOR_PTSO31() uint32 {
	return (volatile.LoadUint32(&o.PSOR.Reg) & 0x80000000) >> 31
}

// GPIO.PCOR: Port Clear Output Register
func (o *GPIO_Type) SetPCOR_PTCO0(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPCOR_PTCO0() uint32 {
	return volatile.LoadUint32(&o.PCOR.Reg) & 0x1
}
func (o *GPIO_Type) SetPCOR_PTCO1(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPCOR_PTCO1() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPCOR_PTCO2(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPCOR_PTCO2() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPCOR_PTCO3(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPCOR_PTCO3() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPCOR_PTCO4(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPCOR_PTCO4() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPCOR_PTCO5(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPCOR_PTCO5() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPCOR_PTCO6(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPCOR_PTCO6() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPCOR_PTCO7(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPCOR_PTCO7() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPCOR_PTCO8(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPCOR_PTCO8() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPCOR_PTCO9(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPCOR_PTCO9() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPCOR_PTCO10(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPCOR_PTCO10() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPCOR_PTCO11(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPCOR_PTCO11() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPCOR_PTCO12(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPCOR_PTCO12() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPCOR_PTCO13(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPCOR_PTCO13() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPCOR_PTCO14(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPCOR_PTCO14() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPCOR_PTCO15(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPCOR_PTCO15() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPCOR_PTCO16(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPCOR_PTCO16() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPCOR_PTCO17(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPCOR_PTCO17() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPCOR_PTCO18(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPCOR_PTCO18() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPCOR_PTCO19(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPCOR_PTCO19() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPCOR_PTCO20(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPCOR_PTCO20() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPCOR_PTCO21(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPCOR_PTCO21() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPCOR_PTCO22(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPCOR_PTCO22() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPCOR_PTCO23(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPCOR_PTCO23() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPCOR_PTCO24(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPCOR_PTCO24() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPCOR_PTCO25(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPCOR_PTCO25() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPCOR_PTCO26(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPCOR_PTCO26() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPCOR_PTCO27(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPCOR_PTCO27() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPCOR_PTCO28(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPCOR_PTCO28() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPCOR_PTCO29(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPCOR_PTCO29() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPCOR_PTCO30(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPCOR_PTCO30() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPCOR_PTCO31(value uint32) {
	volatile.StoreUint32(&o.PCOR.Reg, volatile.LoadUint32(&o.PCOR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPCOR_PTCO31() uint32 {
	return (volatile.LoadUint32(&o.PCOR.Reg) & 0x80000000) >> 31
}

// GPIO.PTOR: Port Toggle Output Register
func (o *GPIO_Type) SetPTOR_PTTO0(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPTOR_PTTO0() uint32 {
	return volatile.LoadUint32(&o.PTOR.Reg) & 0x1
}
func (o *GPIO_Type) SetPTOR_PTTO1(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPTOR_PTTO1() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPTOR_PTTO2(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPTOR_PTTO2() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPTOR_PTTO3(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPTOR_PTTO3() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPTOR_PTTO4(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPTOR_PTTO4() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPTOR_PTTO5(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPTOR_PTTO5() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPTOR_PTTO6(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPTOR_PTTO6() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPTOR_PTTO7(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPTOR_PTTO7() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPTOR_PTTO8(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPTOR_PTTO8() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPTOR_PTTO9(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPTOR_PTTO9() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPTOR_PTTO10(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPTOR_PTTO10() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPTOR_PTTO11(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPTOR_PTTO11() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPTOR_PTTO12(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPTOR_PTTO12() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPTOR_PTTO13(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPTOR_PTTO13() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPTOR_PTTO14(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPTOR_PTTO14() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPTOR_PTTO15(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPTOR_PTTO15() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPTOR_PTTO16(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPTOR_PTTO16() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPTOR_PTTO17(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPTOR_PTTO17() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPTOR_PTTO18(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPTOR_PTTO18() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPTOR_PTTO19(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPTOR_PTTO19() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPTOR_PTTO20(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPTOR_PTTO20() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPTOR_PTTO21(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPTOR_PTTO21() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPTOR_PTTO22(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPTOR_PTTO22() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPTOR_PTTO23(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPTOR_PTTO23() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPTOR_PTTO24(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPTOR_PTTO24() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPTOR_PTTO25(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPTOR_PTTO25() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPTOR_PTTO26(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPTOR_PTTO26() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPTOR_PTTO27(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPTOR_PTTO27() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPTOR_PTTO28(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPTOR_PTTO28() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPTOR_PTTO29(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPTOR_PTTO29() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPTOR_PTTO30(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPTOR_PTTO30() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPTOR_PTTO31(value uint32) {
	volatile.StoreUint32(&o.PTOR.Reg, volatile.LoadUint32(&o.PTOR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPTOR_PTTO31() uint32 {
	return (volatile.LoadUint32(&o.PTOR.Reg) & 0x80000000) >> 31
}

// GPIO.PDIR: Port Data Input Register
func (o *GPIO_Type) SetPDIR_PDI0(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPDIR_PDI0() uint32 {
	return volatile.LoadUint32(&o.PDIR.Reg) & 0x1
}
func (o *GPIO_Type) SetPDIR_PDI1(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPDIR_PDI1() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPDIR_PDI2(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPDIR_PDI2() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPDIR_PDI3(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPDIR_PDI3() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPDIR_PDI4(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPDIR_PDI4() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPDIR_PDI5(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPDIR_PDI5() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPDIR_PDI6(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPDIR_PDI6() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPDIR_PDI7(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPDIR_PDI7() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPDIR_PDI8(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPDIR_PDI8() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPDIR_PDI9(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPDIR_PDI9() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPDIR_PDI10(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPDIR_PDI10() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPDIR_PDI11(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPDIR_PDI11() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPDIR_PDI12(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPDIR_PDI12() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPDIR_PDI13(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPDIR_PDI13() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPDIR_PDI14(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPDIR_PDI14() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPDIR_PDI15(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPDIR_PDI15() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPDIR_PDI16(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPDIR_PDI16() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPDIR_PDI17(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPDIR_PDI17() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPDIR_PDI18(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPDIR_PDI18() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPDIR_PDI19(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPDIR_PDI19() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPDIR_PDI20(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPDIR_PDI20() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPDIR_PDI21(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPDIR_PDI21() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPDIR_PDI22(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPDIR_PDI22() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPDIR_PDI23(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPDIR_PDI23() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPDIR_PDI24(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPDIR_PDI24() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPDIR_PDI25(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPDIR_PDI25() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPDIR_PDI26(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPDIR_PDI26() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPDIR_PDI27(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPDIR_PDI27() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPDIR_PDI28(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPDIR_PDI28() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPDIR_PDI29(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPDIR_PDI29() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPDIR_PDI30(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPDIR_PDI30() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPDIR_PDI31(value uint32) {
	volatile.StoreUint32(&o.PDIR.Reg, volatile.LoadUint32(&o.PDIR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPDIR_PDI31() uint32 {
	return (volatile.LoadUint32(&o.PDIR.Reg) & 0x80000000) >> 31
}

// GPIO.PDDR: Port Data Direction Register
func (o *GPIO_Type) SetPDDR_PDD0(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPDDR_PDD0() uint32 {
	return volatile.LoadUint32(&o.PDDR.Reg) & 0x1
}
func (o *GPIO_Type) SetPDDR_PDD1(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPDDR_PDD1() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPDDR_PDD2(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPDDR_PDD2() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPDDR_PDD3(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPDDR_PDD3() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPDDR_PDD4(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPDDR_PDD4() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPDDR_PDD5(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPDDR_PDD5() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPDDR_PDD6(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPDDR_PDD6() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPDDR_PDD7(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPDDR_PDD7() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPDDR_PDD8(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPDDR_PDD8() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPDDR_PDD9(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPDDR_PDD9() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPDDR_PDD10(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPDDR_PDD10() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPDDR_PDD11(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPDDR_PDD11() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPDDR_PDD12(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPDDR_PDD12() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPDDR_PDD13(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPDDR_PDD13() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPDDR_PDD14(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPDDR_PDD14() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPDDR_PDD15(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPDDR_PDD15() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPDDR_PDD16(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPDDR_PDD16() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPDDR_PDD17(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPDDR_PDD17() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPDDR_PDD18(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPDDR_PDD18() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPDDR_PDD19(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPDDR_PDD19() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPDDR_PDD20(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPDDR_PDD20() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPDDR_PDD21(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPDDR_PDD21() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPDDR_PDD22(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPDDR_PDD22() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPDDR_PDD23(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPDDR_PDD23() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPDDR_PDD24(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPDDR_PDD24() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPDDR_PDD25(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPDDR_PDD25() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPDDR_PDD26(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPDDR_PDD26() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPDDR_PDD27(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPDDR_PDD27() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPDDR_PDD28(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPDDR_PDD28() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPDDR_PDD29(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPDDR_PDD29() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPDDR_PDD30(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPDDR_PDD30() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPDDR_PDD31(value uint32) {
	volatile.StoreUint32(&o.PDDR.Reg, volatile.LoadUint32(&o.PDDR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPDDR_PDD31() uint32 {
	return (volatile.LoadUint32(&o.PDDR.Reg) & 0x80000000) >> 31
}

// System Control Block
type SystemControl_Type struct {
	_      [8]byte
	ACTLR  volatile.Register32 // 0x8
	_      [3316]byte
	CPUID  volatile.Register32 // 0xD00
	ICSR   volatile.Register32 // 0xD04
	VTOR   volatile.Register32 // 0xD08
	AIRCR  volatile.Register32 // 0xD0C
	SCR    volatile.Register32 // 0xD10
	CCR    volatile.Register32 // 0xD14
	SHPR1  volatile.Register32 // 0xD18
	SHPR2  volatile.Register32 // 0xD1C
	SHPR3  volatile.Register32 // 0xD20
	SHCSR  volatile.Register32 // 0xD24
	CFSR   volatile.Register32 // 0xD28
	HFSR   volatile.Register32 // 0xD2C
	DFSR   volatile.Register32 // 0xD30
	MMFAR  volatile.Register32 // 0xD34
	BFAR   volatile.Register32 // 0xD38
	AFSR   volatile.Register32 // 0xD3C
	_      [72]byte
	CPACR  volatile.Register32 // 0xD88
	_      [424]byte
	FPCCR  volatile.Register32 // 0xF34
	FPCAR  volatile.Register32 // 0xF38
	FPDSCR volatile.Register32 // 0xF3C
}

// SystemControl.ACTLR: Auxiliary Control Register,
func (o *SystemControl_Type) SetACTLR_DISMCYCINT(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetACTLR_DISMCYCINT() uint32 {
	return volatile.LoadUint32(&o.ACTLR.Reg) & 0x1
}
func (o *SystemControl_Type) SetACTLR_DISDEFWBUF(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetACTLR_DISDEFWBUF() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetACTLR_DISFOLD(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetACTLR_DISFOLD() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x4) >> 2
}

// SystemControl.CPUID: CPUID Base Register
func (o *SystemControl_Type) SetCPUID_REVISION(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *SystemControl_Type) GetCPUID_REVISION() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}
func (o *SystemControl_Type) SetCPUID_PARTNO(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *SystemControl_Type) GetCPUID_PARTNO() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *SystemControl_Type) SetCPUID_VARIANT(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *SystemControl_Type) GetCPUID_VARIANT() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *SystemControl_Type) SetCPUID_IMPLEMENTER(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *SystemControl_Type) GetCPUID_IMPLEMENTER() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}

// SystemControl.ICSR: Interrupt Control and State Register
func (o *SystemControl_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *SystemControl_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}
func (o *SystemControl_Type) SetICSR_RETTOBASE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800)|value<<11)
}
func (o *SystemControl_Type) GetICSR_RETTOBASE() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800) >> 11
}
func (o *SystemControl_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x3f000)|value<<12)
}
func (o *SystemControl_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x3f000) >> 12
}
func (o *SystemControl_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *SystemControl_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *SystemControl_Type) SetICSR_ISRPREEMPT(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800000)|value<<23)
}
func (o *SystemControl_Type) GetICSR_ISRPREEMPT() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800000) >> 23
}
func (o *SystemControl_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SystemControl_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *SystemControl_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *SystemControl_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *SystemControl_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SystemControl_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *SystemControl_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *SystemControl_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *SystemControl_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SystemControl_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}

// SystemControl.VTOR: Vector Table Offset Register
func (o *SystemControl_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0xffffff80)|value<<7)
}
func (o *SystemControl_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0xffffff80) >> 7
}

// SystemControl.AIRCR: Application Interrupt and Reset Control Register
func (o *SystemControl_Type) SetAIRCR_VECTRESET(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetAIRCR_VECTRESET() uint32 {
	return volatile.LoadUint32(&o.AIRCR.Reg) & 0x1
}
func (o *SystemControl_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetAIRCR_PRIGROUP(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x700)|value<<8)
}
func (o *SystemControl_Type) GetAIRCR_PRIGROUP() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x700) >> 8
}
func (o *SystemControl_Type) SetAIRCR_ENDIANNESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *SystemControl_Type) GetAIRCR_ENDIANNESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *SystemControl_Type) SetAIRCR_VECTKEY(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SystemControl_Type) GetAIRCR_VECTKEY() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}

// SystemControl.SCR: System Control Register
func (o *SystemControl_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetSCR_SEVONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetSCR_SEVONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// SystemControl.CCR: Configuration and Control Register
func (o *SystemControl_Type) SetCCR_NONBASETHRDENA(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetCCR_NONBASETHRDENA() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *SystemControl_Type) SetCCR_USERSETMPEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetCCR_USERSETMPEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetCCR_UNALIGN_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetCCR_UNALIGN_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetCCR_DIV_0_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetCCR_DIV_0_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *SystemControl_Type) SetCCR_BFHFNMIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetCCR_BFHFNMIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *SystemControl_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}

// SystemControl.SHPR1: System Handler Priority Register 1
func (o *SystemControl_Type) SetSHPR1_PRI_4(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff)|value)
}
func (o *SystemControl_Type) GetSHPR1_PRI_4() uint32 {
	return volatile.LoadUint32(&o.SHPR1.Reg) & 0xff
}
func (o *SystemControl_Type) SetSHPR1_PRI_5(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff00)|value<<8)
}
func (o *SystemControl_Type) GetSHPR1_PRI_5() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff00) >> 8
}
func (o *SystemControl_Type) SetSHPR1_PRI_6(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *SystemControl_Type) GetSHPR1_PRI_6() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff0000) >> 16
}

// SystemControl.SHPR2: System Handler Priority Register 2
func (o *SystemControl_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SystemControl_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xff000000) >> 24
}

// SystemControl.SHPR3: System Handler Priority Register 3
func (o *SystemControl_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *SystemControl_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff0000) >> 16
}
func (o *SystemControl_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *SystemControl_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff000000) >> 24
}

// SystemControl.SHCSR: System Handler Control and State Register
func (o *SystemControl_Type) SetSHCSR_MEMFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetSHCSR_MEMFAULTACT() uint32 {
	return volatile.LoadUint32(&o.SHCSR.Reg) & 0x1
}
func (o *SystemControl_Type) SetSHCSR_BUSFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetSHCSR_BUSFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetSHCSR_USGFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetSHCSR_USGFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetSHCSR_SVCALLACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x80)|value<<7)
}
func (o *SystemControl_Type) GetSHCSR_SVCALLACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x80) >> 7
}
func (o *SystemControl_Type) SetSHCSR_MONITORACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetSHCSR_MONITORACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetSHCSR_PENDSVACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x400)|value<<10)
}
func (o *SystemControl_Type) GetSHCSR_PENDSVACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x400) >> 10
}
func (o *SystemControl_Type) SetSHCSR_SYSTICKACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x800)|value<<11)
}
func (o *SystemControl_Type) GetSHCSR_SYSTICKACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x800) >> 11
}
func (o *SystemControl_Type) SetSHCSR_USGFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1000)|value<<12)
}
func (o *SystemControl_Type) GetSHCSR_USGFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x1000) >> 12
}
func (o *SystemControl_Type) SetSHCSR_MEMFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2000)|value<<13)
}
func (o *SystemControl_Type) GetSHCSR_MEMFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2000) >> 13
}
func (o *SystemControl_Type) SetSHCSR_BUSFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x4000)|value<<14)
}
func (o *SystemControl_Type) GetSHCSR_BUSFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x4000) >> 14
}
func (o *SystemControl_Type) SetSHCSR_SVCALLPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8000)|value<<15)
}
func (o *SystemControl_Type) GetSHCSR_SVCALLPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8000) >> 15
}
func (o *SystemControl_Type) SetSHCSR_MEMFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x10000)|value<<16)
}
func (o *SystemControl_Type) GetSHCSR_MEMFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x10000) >> 16
}
func (o *SystemControl_Type) SetSHCSR_BUSFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x20000)|value<<17)
}
func (o *SystemControl_Type) GetSHCSR_BUSFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x20000) >> 17
}
func (o *SystemControl_Type) SetSHCSR_USGFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x40000)|value<<18)
}
func (o *SystemControl_Type) GetSHCSR_USGFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x40000) >> 18
}

// SystemControl.CFSR: Configurable Fault Status Registers
func (o *SystemControl_Type) SetCFSR_IACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetCFSR_IACCVIOL() uint32 {
	return volatile.LoadUint32(&o.CFSR.Reg) & 0x1
}
func (o *SystemControl_Type) SetCFSR_DACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetCFSR_DACCVIOL() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetCFSR_MUNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetCFSR_MUNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetCFSR_MSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetCFSR_MSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10) >> 4
}
func (o *SystemControl_Type) SetCFSR_MLSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20)|value<<5)
}
func (o *SystemControl_Type) GetCFSR_MLSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20) >> 5
}
func (o *SystemControl_Type) SetCFSR_MMARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80)|value<<7)
}
func (o *SystemControl_Type) GetCFSR_MMARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80) >> 7
}
func (o *SystemControl_Type) SetCFSR_IBUSERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetCFSR_IBUSERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetCFSR_PRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x200)|value<<9)
}
func (o *SystemControl_Type) GetCFSR_PRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x200) >> 9
}
func (o *SystemControl_Type) SetCFSR_IMPRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x400)|value<<10)
}
func (o *SystemControl_Type) GetCFSR_IMPRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x400) >> 10
}
func (o *SystemControl_Type) SetCFSR_UNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x800)|value<<11)
}
func (o *SystemControl_Type) GetCFSR_UNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x800) >> 11
}
func (o *SystemControl_Type) SetCFSR_STKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000)|value<<12)
}
func (o *SystemControl_Type) GetCFSR_STKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000) >> 12
}
func (o *SystemControl_Type) SetCFSR_LSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000)|value<<13)
}
func (o *SystemControl_Type) GetCFSR_LSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000) >> 13
}
func (o *SystemControl_Type) SetCFSR_BFARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8000)|value<<15)
}
func (o *SystemControl_Type) GetCFSR_BFARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8000) >> 15
}
func (o *SystemControl_Type) SetCFSR_UNDEFINSTR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SystemControl_Type) GetCFSR_UNDEFINSTR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10000) >> 16
}
func (o *SystemControl_Type) SetCFSR_INVSTATE(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20000)|value<<17)
}
func (o *SystemControl_Type) GetCFSR_INVSTATE() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20000) >> 17
}
func (o *SystemControl_Type) SetCFSR_INVPC(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x40000)|value<<18)
}
func (o *SystemControl_Type) GetCFSR_INVPC() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x40000) >> 18
}
func (o *SystemControl_Type) SetCFSR_NOCP(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80000)|value<<19)
}
func (o *SystemControl_Type) GetCFSR_NOCP() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80000) >> 19
}
func (o *SystemControl_Type) SetCFSR_UNALIGNED(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SystemControl_Type) GetCFSR_UNALIGNED() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000000) >> 24
}
func (o *SystemControl_Type) SetCFSR_DIVBYZERO(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SystemControl_Type) GetCFSR_DIVBYZERO() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000000) >> 25
}

// SystemControl.HFSR: HardFault Status register
func (o *SystemControl_Type) SetHFSR_VECTTBL(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetHFSR_VECTTBL() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetHFSR_FORCED(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *SystemControl_Type) GetHFSR_FORCED() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x40000000) >> 30
}
func (o *SystemControl_Type) SetHFSR_DEBUGEVT(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SystemControl_Type) GetHFSR_DEBUGEVT() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x80000000) >> 31
}

// SystemControl.DFSR: Debug Fault Status Register
func (o *SystemControl_Type) SetDFSR_HALTED(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetDFSR_HALTED() uint32 {
	return volatile.LoadUint32(&o.DFSR.Reg) & 0x1
}
func (o *SystemControl_Type) SetDFSR_BKPT(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetDFSR_BKPT() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetDFSR_DWTTRAP(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetDFSR_DWTTRAP() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetDFSR_VCATCH(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetDFSR_VCATCH() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetDFSR_EXTERNAL(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetDFSR_EXTERNAL() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x10) >> 4
}

// SystemControl.MMFAR: MemManage Address Register
func (o *SystemControl_Type) SetMMFAR(value uint32) {
	volatile.StoreUint32(&o.MMFAR.Reg, value)
}
func (o *SystemControl_Type) GetMMFAR() uint32 {
	return volatile.LoadUint32(&o.MMFAR.Reg)
}

// SystemControl.BFAR: BusFault Address Register
func (o *SystemControl_Type) SetBFAR(value uint32) {
	volatile.StoreUint32(&o.BFAR.Reg, value)
}
func (o *SystemControl_Type) GetBFAR() uint32 {
	return volatile.LoadUint32(&o.BFAR.Reg)
}

// SystemControl.AFSR: Auxiliary Fault Status Register
func (o *SystemControl_Type) SetAFSR(value uint32) {
	volatile.StoreUint32(&o.AFSR.Reg, value)
}
func (o *SystemControl_Type) GetAFSR() uint32 {
	return volatile.LoadUint32(&o.AFSR.Reg)
}

// SystemControl.CPACR: Coprocessor Access Control Register
func (o *SystemControl_Type) SetCPACR_CP10(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0x300000)|value<<20)
}
func (o *SystemControl_Type) GetCPACR_CP10() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0x300000) >> 20
}
func (o *SystemControl_Type) SetCPACR_CP11(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xc00000)|value<<22)
}
func (o *SystemControl_Type) GetCPACR_CP11() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xc00000) >> 22
}

// SystemControl.FPCCR: Floating-point Context Control Register
func (o *SystemControl_Type) SetFPCCR_LSPACT(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetFPCCR_LSPACT() uint32 {
	return volatile.LoadUint32(&o.FPCCR.Reg) & 0x1
}
func (o *SystemControl_Type) SetFPCCR_USER(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetFPCCR_USER() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetFPCCR_THREAD(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetFPCCR_THREAD() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetFPCCR_HFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetFPCCR_HFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x10) >> 4
}
func (o *SystemControl_Type) SetFPCCR_MMRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x20)|value<<5)
}
func (o *SystemControl_Type) GetFPCCR_MMRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x20) >> 5
}
func (o *SystemControl_Type) SetFPCCR_BFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40)|value<<6)
}
func (o *SystemControl_Type) GetFPCCR_BFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40) >> 6
}
func (o *SystemControl_Type) SetFPCCR_MONRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetFPCCR_MONRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetFPCCR_LSPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40000000)|value<<30)
}
func (o *SystemControl_Type) GetFPCCR_LSPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40000000) >> 30
}
func (o *SystemControl_Type) SetFPCCR_ASPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SystemControl_Type) GetFPCCR_ASPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x80000000) >> 31
}

// SystemControl.FPCAR: Floating-point Context Address Register
func (o *SystemControl_Type) SetFPCAR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.FPCAR.Reg, volatile.LoadUint32(&o.FPCAR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *SystemControl_Type) GetFPCAR_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.FPCAR.Reg) & 0xfffffff8) >> 3
}

// SystemControl.FPDSCR: Floating-point Default Status Control Register
func (o *SystemControl_Type) SetFPDSCR_RMode(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0xc00000)|value<<22)
}
func (o *SystemControl_Type) GetFPDSCR_RMode() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0xc00000) >> 22
}
func (o *SystemControl_Type) SetFPDSCR_FZ(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SystemControl_Type) GetFPDSCR_FZ() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x1000000) >> 24
}
func (o *SystemControl_Type) SetFPDSCR_DN(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x2000000)|value<<25)
}
func (o *SystemControl_Type) GetFPDSCR_DN() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x2000000) >> 25
}
func (o *SystemControl_Type) SetFPDSCR_AHP(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *SystemControl_Type) GetFPDSCR_AHP() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x4000000) >> 26
}

// System timer
type SysTick_Type struct {
	CSR   volatile.Register32 // 0x0
	RVR   volatile.Register32 // 0x4
	CVR   volatile.Register32 // 0x8
	CALIB volatile.Register32 // 0xC
}

// SysTick.CSR: SysTick Control and Status Register
func (o *SysTick_Type) SetCSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *SysTick_Type) GetCSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *SysTick_Type) SetCSR_TICKINT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *SysTick_Type) GetCSR_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *SysTick_Type) SetCSR_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *SysTick_Type) GetCSR_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *SysTick_Type) SetCSR_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000)|value<<16)
}
func (o *SysTick_Type) GetCSR_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000) >> 16
}

// SysTick.RVR: SysTick Reload Value Register
func (o *SysTick_Type) SetRVR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.RVR.Reg, volatile.LoadUint32(&o.RVR.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetRVR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.RVR.Reg) & 0xffffff
}

// SysTick.CVR: SysTick Current Value Register
func (o *SysTick_Type) SetCVR_CURRENT(value uint32) {
	volatile.StoreUint32(&o.CVR.Reg, volatile.LoadUint32(&o.CVR.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetCVR_CURRENT() uint32 {
	return volatile.LoadUint32(&o.CVR.Reg) & 0xffffff
}

// SysTick.CALIB: SysTick Calibration Value Register
func (o *SysTick_Type) SetCALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetCALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.CALIB.Reg) & 0xffffff
}
func (o *SysTick_Type) SetCALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *SysTick_Type) GetCALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x40000000) >> 30
}
func (o *SysTick_Type) SetCALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *SysTick_Type) GetCALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x80000000) >> 31
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	NVICISER0 volatile.Register32 // 0x0
	NVICISER1 volatile.Register32 // 0x4
	NVICISER2 volatile.Register32 // 0x8
	NVICISER3 volatile.Register32 // 0xC
	_         [112]byte
	NVICICER0 volatile.Register32 // 0x80
	NVICICER1 volatile.Register32 // 0x84
	NVICICER2 volatile.Register32 // 0x88
	NVICICER3 volatile.Register32 // 0x8C
	_         [112]byte
	NVICISPR0 volatile.Register32 // 0x100
	NVICISPR1 volatile.Register32 // 0x104
	NVICISPR2 volatile.Register32 // 0x108
	NVICISPR3 volatile.Register32 // 0x10C
	_         [112]byte
	NVICICPR0 volatile.Register32 // 0x180
	NVICICPR1 volatile.Register32 // 0x184
	NVICICPR2 volatile.Register32 // 0x188
	NVICICPR3 volatile.Register32 // 0x18C
	_         [112]byte
	NVICIABR0 volatile.Register32 // 0x200
	NVICIABR1 volatile.Register32 // 0x204
	NVICIABR2 volatile.Register32 // 0x208
	NVICIABR3 volatile.Register32 // 0x20C
	_         [240]byte
	NVICIP0   volatile.Register8 // 0x300
	NVICIP1   volatile.Register8 // 0x301
	NVICIP2   volatile.Register8 // 0x302
	NVICIP3   volatile.Register8 // 0x303
	NVICIP4   volatile.Register8 // 0x304
	NVICIP5   volatile.Register8 // 0x305
	NVICIP6   volatile.Register8 // 0x306
	NVICIP7   volatile.Register8 // 0x307
	NVICIP8   volatile.Register8 // 0x308
	NVICIP9   volatile.Register8 // 0x309
	NVICIP10  volatile.Register8 // 0x30A
	NVICIP11  volatile.Register8 // 0x30B
	NVICIP12  volatile.Register8 // 0x30C
	NVICIP13  volatile.Register8 // 0x30D
	NVICIP14  volatile.Register8 // 0x30E
	NVICIP15  volatile.Register8 // 0x30F
	NVICIP16  volatile.Register8 // 0x310
	NVICIP17  volatile.Register8 // 0x311
	NVICIP18  volatile.Register8 // 0x312
	NVICIP19  volatile.Register8 // 0x313
	NVICIP20  volatile.Register8 // 0x314
	NVICIP21  volatile.Register8 // 0x315
	NVICIP22  volatile.Register8 // 0x316
	NVICIP23  volatile.Register8 // 0x317
	NVICIP24  volatile.Register8 // 0x318
	NVICIP25  volatile.Register8 // 0x319
	NVICIP26  volatile.Register8 // 0x31A
	NVICIP27  volatile.Register8 // 0x31B
	NVICIP28  volatile.Register8 // 0x31C
	NVICIP29  volatile.Register8 // 0x31D
	NVICIP30  volatile.Register8 // 0x31E
	NVICIP31  volatile.Register8 // 0x31F
	NVICIP32  volatile.Register8 // 0x320
	NVICIP33  volatile.Register8 // 0x321
	NVICIP34  volatile.Register8 // 0x322
	NVICIP35  volatile.Register8 // 0x323
	NVICIP36  volatile.Register8 // 0x324
	NVICIP37  volatile.Register8 // 0x325
	NVICIP38  volatile.Register8 // 0x326
	NVICIP39  volatile.Register8 // 0x327
	NVICIP40  volatile.Register8 // 0x328
	NVICIP41  volatile.Register8 // 0x329
	NVICIP42  volatile.Register8 // 0x32A
	NVICIP43  volatile.Register8 // 0x32B
	NVICIP44  volatile.Register8 // 0x32C
	NVICIP45  volatile.Register8 // 0x32D
	NVICIP46  volatile.Register8 // 0x32E
	NVICIP47  volatile.Register8 // 0x32F
	NVICIP48  volatile.Register8 // 0x330
	NVICIP49  volatile.Register8 // 0x331
	NVICIP50  volatile.Register8 // 0x332
	NVICIP51  volatile.Register8 // 0x333
	NVICIP52  volatile.Register8 // 0x334
	NVICIP53  volatile.Register8 // 0x335
	NVICIP54  volatile.Register8 // 0x336
	NVICIP55  volatile.Register8 // 0x337
	NVICIP56  volatile.Register8 // 0x338
	NVICIP57  volatile.Register8 // 0x339
	NVICIP58  volatile.Register8 // 0x33A
	NVICIP59  volatile.Register8 // 0x33B
	NVICIP60  volatile.Register8 // 0x33C
	NVICIP61  volatile.Register8 // 0x33D
	NVICIP62  volatile.Register8 // 0x33E
	NVICIP63  volatile.Register8 // 0x33F
	NVICIP64  volatile.Register8 // 0x340
	NVICIP65  volatile.Register8 // 0x341
	NVICIP66  volatile.Register8 // 0x342
	NVICIP67  volatile.Register8 // 0x343
	NVICIP68  volatile.Register8 // 0x344
	NVICIP69  volatile.Register8 // 0x345
	NVICIP70  volatile.Register8 // 0x346
	NVICIP71  volatile.Register8 // 0x347
	NVICIP72  volatile.Register8 // 0x348
	NVICIP73  volatile.Register8 // 0x349
	NVICIP74  volatile.Register8 // 0x34A
	NVICIP75  volatile.Register8 // 0x34B
	NVICIP76  volatile.Register8 // 0x34C
	NVICIP77  volatile.Register8 // 0x34D
	NVICIP78  volatile.Register8 // 0x34E
	NVICIP79  volatile.Register8 // 0x34F
	NVICIP80  volatile.Register8 // 0x350
	NVICIP81  volatile.Register8 // 0x351
	NVICIP82  volatile.Register8 // 0x352
	NVICIP83  volatile.Register8 // 0x353
	NVICIP84  volatile.Register8 // 0x354
	NVICIP85  volatile.Register8 // 0x355
	NVICIP86  volatile.Register8 // 0x356
	NVICIP87  volatile.Register8 // 0x357
	NVICIP88  volatile.Register8 // 0x358
	NVICIP89  volatile.Register8 // 0x359
	NVICIP90  volatile.Register8 // 0x35A
	NVICIP91  volatile.Register8 // 0x35B
	NVICIP92  volatile.Register8 // 0x35C
	NVICIP93  volatile.Register8 // 0x35D
	NVICIP94  volatile.Register8 // 0x35E
	NVICIP95  volatile.Register8 // 0x35F
	NVICIP96  volatile.Register8 // 0x360
	NVICIP97  volatile.Register8 // 0x361
	NVICIP98  volatile.Register8 // 0x362
	NVICIP99  volatile.Register8 // 0x363
	NVICIP100 volatile.Register8 // 0x364
	NVICIP101 volatile.Register8 // 0x365
	NVICIP102 volatile.Register8 // 0x366
	NVICIP103 volatile.Register8 // 0x367
	NVICIP104 volatile.Register8 // 0x368
	NVICIP105 volatile.Register8 // 0x369
	_         [2710]byte
	NVICSTIR  volatile.Register32 // 0xE00
}

// NVIC.NVICISER0: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER0(value uint32) {
	volatile.StoreUint32(&o.NVICISER0.Reg, value)
}
func (o *NVIC_Type) GetNVICISER0() uint32 {
	return volatile.LoadUint32(&o.NVICISER0.Reg)
}

// NVIC.NVICISER1: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER1(value uint32) {
	volatile.StoreUint32(&o.NVICISER1.Reg, value)
}
func (o *NVIC_Type) GetNVICISER1() uint32 {
	return volatile.LoadUint32(&o.NVICISER1.Reg)
}

// NVIC.NVICISER2: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER2(value uint32) {
	volatile.StoreUint32(&o.NVICISER2.Reg, value)
}
func (o *NVIC_Type) GetNVICISER2() uint32 {
	return volatile.LoadUint32(&o.NVICISER2.Reg)
}

// NVIC.NVICISER3: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER3(value uint32) {
	volatile.StoreUint32(&o.NVICISER3.Reg, value)
}
func (o *NVIC_Type) GetNVICISER3() uint32 {
	return volatile.LoadUint32(&o.NVICISER3.Reg)
}

// NVIC.NVICICER0: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER0(value uint32) {
	volatile.StoreUint32(&o.NVICICER0.Reg, value)
}
func (o *NVIC_Type) GetNVICICER0() uint32 {
	return volatile.LoadUint32(&o.NVICICER0.Reg)
}

// NVIC.NVICICER1: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER1(value uint32) {
	volatile.StoreUint32(&o.NVICICER1.Reg, value)
}
func (o *NVIC_Type) GetNVICICER1() uint32 {
	return volatile.LoadUint32(&o.NVICICER1.Reg)
}

// NVIC.NVICICER2: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER2(value uint32) {
	volatile.StoreUint32(&o.NVICICER2.Reg, value)
}
func (o *NVIC_Type) GetNVICICER2() uint32 {
	return volatile.LoadUint32(&o.NVICICER2.Reg)
}

// NVIC.NVICICER3: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER3(value uint32) {
	volatile.StoreUint32(&o.NVICICER3.Reg, value)
}
func (o *NVIC_Type) GetNVICICER3() uint32 {
	return volatile.LoadUint32(&o.NVICICER3.Reg)
}

// NVIC.NVICISPR0: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR0(value uint32) {
	volatile.StoreUint32(&o.NVICISPR0.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR0() uint32 {
	return volatile.LoadUint32(&o.NVICISPR0.Reg)
}

// NVIC.NVICISPR1: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR1(value uint32) {
	volatile.StoreUint32(&o.NVICISPR1.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR1() uint32 {
	return volatile.LoadUint32(&o.NVICISPR1.Reg)
}

// NVIC.NVICISPR2: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR2(value uint32) {
	volatile.StoreUint32(&o.NVICISPR2.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR2() uint32 {
	return volatile.LoadUint32(&o.NVICISPR2.Reg)
}

// NVIC.NVICISPR3: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR3(value uint32) {
	volatile.StoreUint32(&o.NVICISPR3.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR3() uint32 {
	return volatile.LoadUint32(&o.NVICISPR3.Reg)
}

// NVIC.NVICICPR0: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR0(value uint32) {
	volatile.StoreUint32(&o.NVICICPR0.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR0() uint32 {
	return volatile.LoadUint32(&o.NVICICPR0.Reg)
}

// NVIC.NVICICPR1: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR1(value uint32) {
	volatile.StoreUint32(&o.NVICICPR1.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR1() uint32 {
	return volatile.LoadUint32(&o.NVICICPR1.Reg)
}

// NVIC.NVICICPR2: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR2(value uint32) {
	volatile.StoreUint32(&o.NVICICPR2.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR2() uint32 {
	return volatile.LoadUint32(&o.NVICICPR2.Reg)
}

// NVIC.NVICICPR3: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR3(value uint32) {
	volatile.StoreUint32(&o.NVICICPR3.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR3() uint32 {
	return volatile.LoadUint32(&o.NVICICPR3.Reg)
}

// NVIC.NVICIABR0: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR0(value uint32) {
	volatile.StoreUint32(&o.NVICIABR0.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR0() uint32 {
	return volatile.LoadUint32(&o.NVICIABR0.Reg)
}

// NVIC.NVICIABR1: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR1(value uint32) {
	volatile.StoreUint32(&o.NVICIABR1.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR1() uint32 {
	return volatile.LoadUint32(&o.NVICIABR1.Reg)
}

// NVIC.NVICIABR2: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR2(value uint32) {
	volatile.StoreUint32(&o.NVICIABR2.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR2() uint32 {
	return volatile.LoadUint32(&o.NVICIABR2.Reg)
}

// NVIC.NVICIABR3: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR3(value uint32) {
	volatile.StoreUint32(&o.NVICIABR3.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR3() uint32 {
	return volatile.LoadUint32(&o.NVICIABR3.Reg)
}

// NVIC.NVICIP0: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP0(value uint8) {
	volatile.StoreUint8(&o.NVICIP0.Reg, value)
}
func (o *NVIC_Type) GetNVICIP0() uint8 {
	return volatile.LoadUint8(&o.NVICIP0.Reg)
}

// NVIC.NVICIP1: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP1(value uint8) {
	volatile.StoreUint8(&o.NVICIP1.Reg, value)
}
func (o *NVIC_Type) GetNVICIP1() uint8 {
	return volatile.LoadUint8(&o.NVICIP1.Reg)
}

// NVIC.NVICIP2: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP2(value uint8) {
	volatile.StoreUint8(&o.NVICIP2.Reg, value)
}
func (o *NVIC_Type) GetNVICIP2() uint8 {
	return volatile.LoadUint8(&o.NVICIP2.Reg)
}

// NVIC.NVICIP3: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP3(value uint8) {
	volatile.StoreUint8(&o.NVICIP3.Reg, value)
}
func (o *NVIC_Type) GetNVICIP3() uint8 {
	return volatile.LoadUint8(&o.NVICIP3.Reg)
}

// NVIC.NVICIP4: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP4(value uint8) {
	volatile.StoreUint8(&o.NVICIP4.Reg, value)
}
func (o *NVIC_Type) GetNVICIP4() uint8 {
	return volatile.LoadUint8(&o.NVICIP4.Reg)
}

// NVIC.NVICIP5: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP5(value uint8) {
	volatile.StoreUint8(&o.NVICIP5.Reg, value)
}
func (o *NVIC_Type) GetNVICIP5() uint8 {
	return volatile.LoadUint8(&o.NVICIP5.Reg)
}

// NVIC.NVICIP6: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP6(value uint8) {
	volatile.StoreUint8(&o.NVICIP6.Reg, value)
}
func (o *NVIC_Type) GetNVICIP6() uint8 {
	return volatile.LoadUint8(&o.NVICIP6.Reg)
}

// NVIC.NVICIP7: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP7(value uint8) {
	volatile.StoreUint8(&o.NVICIP7.Reg, value)
}
func (o *NVIC_Type) GetNVICIP7() uint8 {
	return volatile.LoadUint8(&o.NVICIP7.Reg)
}

// NVIC.NVICIP8: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP8(value uint8) {
	volatile.StoreUint8(&o.NVICIP8.Reg, value)
}
func (o *NVIC_Type) GetNVICIP8() uint8 {
	return volatile.LoadUint8(&o.NVICIP8.Reg)
}

// NVIC.NVICIP9: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP9(value uint8) {
	volatile.StoreUint8(&o.NVICIP9.Reg, value)
}
func (o *NVIC_Type) GetNVICIP9() uint8 {
	return volatile.LoadUint8(&o.NVICIP9.Reg)
}

// NVIC.NVICIP10: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP10(value uint8) {
	volatile.StoreUint8(&o.NVICIP10.Reg, value)
}
func (o *NVIC_Type) GetNVICIP10() uint8 {
	return volatile.LoadUint8(&o.NVICIP10.Reg)
}

// NVIC.NVICIP11: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP11(value uint8) {
	volatile.StoreUint8(&o.NVICIP11.Reg, value)
}
func (o *NVIC_Type) GetNVICIP11() uint8 {
	return volatile.LoadUint8(&o.NVICIP11.Reg)
}

// NVIC.NVICIP12: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP12(value uint8) {
	volatile.StoreUint8(&o.NVICIP12.Reg, value)
}
func (o *NVIC_Type) GetNVICIP12() uint8 {
	return volatile.LoadUint8(&o.NVICIP12.Reg)
}

// NVIC.NVICIP13: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP13(value uint8) {
	volatile.StoreUint8(&o.NVICIP13.Reg, value)
}
func (o *NVIC_Type) GetNVICIP13() uint8 {
	return volatile.LoadUint8(&o.NVICIP13.Reg)
}

// NVIC.NVICIP14: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP14(value uint8) {
	volatile.StoreUint8(&o.NVICIP14.Reg, value)
}
func (o *NVIC_Type) GetNVICIP14() uint8 {
	return volatile.LoadUint8(&o.NVICIP14.Reg)
}

// NVIC.NVICIP15: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP15(value uint8) {
	volatile.StoreUint8(&o.NVICIP15.Reg, value)
}
func (o *NVIC_Type) GetNVICIP15() uint8 {
	return volatile.LoadUint8(&o.NVICIP15.Reg)
}

// NVIC.NVICIP16: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP16(value uint8) {
	volatile.StoreUint8(&o.NVICIP16.Reg, value)
}
func (o *NVIC_Type) GetNVICIP16() uint8 {
	return volatile.LoadUint8(&o.NVICIP16.Reg)
}

// NVIC.NVICIP17: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP17(value uint8) {
	volatile.StoreUint8(&o.NVICIP17.Reg, value)
}
func (o *NVIC_Type) GetNVICIP17() uint8 {
	return volatile.LoadUint8(&o.NVICIP17.Reg)
}

// NVIC.NVICIP18: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP18(value uint8) {
	volatile.StoreUint8(&o.NVICIP18.Reg, value)
}
func (o *NVIC_Type) GetNVICIP18() uint8 {
	return volatile.LoadUint8(&o.NVICIP18.Reg)
}

// NVIC.NVICIP19: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP19(value uint8) {
	volatile.StoreUint8(&o.NVICIP19.Reg, value)
}
func (o *NVIC_Type) GetNVICIP19() uint8 {
	return volatile.LoadUint8(&o.NVICIP19.Reg)
}

// NVIC.NVICIP20: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP20(value uint8) {
	volatile.StoreUint8(&o.NVICIP20.Reg, value)
}
func (o *NVIC_Type) GetNVICIP20() uint8 {
	return volatile.LoadUint8(&o.NVICIP20.Reg)
}

// NVIC.NVICIP21: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP21(value uint8) {
	volatile.StoreUint8(&o.NVICIP21.Reg, value)
}
func (o *NVIC_Type) GetNVICIP21() uint8 {
	return volatile.LoadUint8(&o.NVICIP21.Reg)
}

// NVIC.NVICIP22: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP22(value uint8) {
	volatile.StoreUint8(&o.NVICIP22.Reg, value)
}
func (o *NVIC_Type) GetNVICIP22() uint8 {
	return volatile.LoadUint8(&o.NVICIP22.Reg)
}

// NVIC.NVICIP23: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP23(value uint8) {
	volatile.StoreUint8(&o.NVICIP23.Reg, value)
}
func (o *NVIC_Type) GetNVICIP23() uint8 {
	return volatile.LoadUint8(&o.NVICIP23.Reg)
}

// NVIC.NVICIP24: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP24(value uint8) {
	volatile.StoreUint8(&o.NVICIP24.Reg, value)
}
func (o *NVIC_Type) GetNVICIP24() uint8 {
	return volatile.LoadUint8(&o.NVICIP24.Reg)
}

// NVIC.NVICIP25: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP25(value uint8) {
	volatile.StoreUint8(&o.NVICIP25.Reg, value)
}
func (o *NVIC_Type) GetNVICIP25() uint8 {
	return volatile.LoadUint8(&o.NVICIP25.Reg)
}

// NVIC.NVICIP26: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP26(value uint8) {
	volatile.StoreUint8(&o.NVICIP26.Reg, value)
}
func (o *NVIC_Type) GetNVICIP26() uint8 {
	return volatile.LoadUint8(&o.NVICIP26.Reg)
}

// NVIC.NVICIP27: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP27(value uint8) {
	volatile.StoreUint8(&o.NVICIP27.Reg, value)
}
func (o *NVIC_Type) GetNVICIP27() uint8 {
	return volatile.LoadUint8(&o.NVICIP27.Reg)
}

// NVIC.NVICIP28: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP28(value uint8) {
	volatile.StoreUint8(&o.NVICIP28.Reg, value)
}
func (o *NVIC_Type) GetNVICIP28() uint8 {
	return volatile.LoadUint8(&o.NVICIP28.Reg)
}

// NVIC.NVICIP29: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP29(value uint8) {
	volatile.StoreUint8(&o.NVICIP29.Reg, value)
}
func (o *NVIC_Type) GetNVICIP29() uint8 {
	return volatile.LoadUint8(&o.NVICIP29.Reg)
}

// NVIC.NVICIP30: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP30(value uint8) {
	volatile.StoreUint8(&o.NVICIP30.Reg, value)
}
func (o *NVIC_Type) GetNVICIP30() uint8 {
	return volatile.LoadUint8(&o.NVICIP30.Reg)
}

// NVIC.NVICIP31: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP31(value uint8) {
	volatile.StoreUint8(&o.NVICIP31.Reg, value)
}
func (o *NVIC_Type) GetNVICIP31() uint8 {
	return volatile.LoadUint8(&o.NVICIP31.Reg)
}

// NVIC.NVICIP32: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP32(value uint8) {
	volatile.StoreUint8(&o.NVICIP32.Reg, value)
}
func (o *NVIC_Type) GetNVICIP32() uint8 {
	return volatile.LoadUint8(&o.NVICIP32.Reg)
}

// NVIC.NVICIP33: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP33(value uint8) {
	volatile.StoreUint8(&o.NVICIP33.Reg, value)
}
func (o *NVIC_Type) GetNVICIP33() uint8 {
	return volatile.LoadUint8(&o.NVICIP33.Reg)
}

// NVIC.NVICIP34: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP34(value uint8) {
	volatile.StoreUint8(&o.NVICIP34.Reg, value)
}
func (o *NVIC_Type) GetNVICIP34() uint8 {
	return volatile.LoadUint8(&o.NVICIP34.Reg)
}

// NVIC.NVICIP35: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP35(value uint8) {
	volatile.StoreUint8(&o.NVICIP35.Reg, value)
}
func (o *NVIC_Type) GetNVICIP35() uint8 {
	return volatile.LoadUint8(&o.NVICIP35.Reg)
}

// NVIC.NVICIP36: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP36(value uint8) {
	volatile.StoreUint8(&o.NVICIP36.Reg, value)
}
func (o *NVIC_Type) GetNVICIP36() uint8 {
	return volatile.LoadUint8(&o.NVICIP36.Reg)
}

// NVIC.NVICIP37: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP37(value uint8) {
	volatile.StoreUint8(&o.NVICIP37.Reg, value)
}
func (o *NVIC_Type) GetNVICIP37() uint8 {
	return volatile.LoadUint8(&o.NVICIP37.Reg)
}

// NVIC.NVICIP38: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP38(value uint8) {
	volatile.StoreUint8(&o.NVICIP38.Reg, value)
}
func (o *NVIC_Type) GetNVICIP38() uint8 {
	return volatile.LoadUint8(&o.NVICIP38.Reg)
}

// NVIC.NVICIP39: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP39(value uint8) {
	volatile.StoreUint8(&o.NVICIP39.Reg, value)
}
func (o *NVIC_Type) GetNVICIP39() uint8 {
	return volatile.LoadUint8(&o.NVICIP39.Reg)
}

// NVIC.NVICIP40: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP40(value uint8) {
	volatile.StoreUint8(&o.NVICIP40.Reg, value)
}
func (o *NVIC_Type) GetNVICIP40() uint8 {
	return volatile.LoadUint8(&o.NVICIP40.Reg)
}

// NVIC.NVICIP41: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP41(value uint8) {
	volatile.StoreUint8(&o.NVICIP41.Reg, value)
}
func (o *NVIC_Type) GetNVICIP41() uint8 {
	return volatile.LoadUint8(&o.NVICIP41.Reg)
}

// NVIC.NVICIP42: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP42(value uint8) {
	volatile.StoreUint8(&o.NVICIP42.Reg, value)
}
func (o *NVIC_Type) GetNVICIP42() uint8 {
	return volatile.LoadUint8(&o.NVICIP42.Reg)
}

// NVIC.NVICIP43: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP43(value uint8) {
	volatile.StoreUint8(&o.NVICIP43.Reg, value)
}
func (o *NVIC_Type) GetNVICIP43() uint8 {
	return volatile.LoadUint8(&o.NVICIP43.Reg)
}

// NVIC.NVICIP44: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP44(value uint8) {
	volatile.StoreUint8(&o.NVICIP44.Reg, value)
}
func (o *NVIC_Type) GetNVICIP44() uint8 {
	return volatile.LoadUint8(&o.NVICIP44.Reg)
}

// NVIC.NVICIP45: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP45(value uint8) {
	volatile.StoreUint8(&o.NVICIP45.Reg, value)
}
func (o *NVIC_Type) GetNVICIP45() uint8 {
	return volatile.LoadUint8(&o.NVICIP45.Reg)
}

// NVIC.NVICIP46: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP46(value uint8) {
	volatile.StoreUint8(&o.NVICIP46.Reg, value)
}
func (o *NVIC_Type) GetNVICIP46() uint8 {
	return volatile.LoadUint8(&o.NVICIP46.Reg)
}

// NVIC.NVICIP47: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP47(value uint8) {
	volatile.StoreUint8(&o.NVICIP47.Reg, value)
}
func (o *NVIC_Type) GetNVICIP47() uint8 {
	return volatile.LoadUint8(&o.NVICIP47.Reg)
}

// NVIC.NVICIP48: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP48(value uint8) {
	volatile.StoreUint8(&o.NVICIP48.Reg, value)
}
func (o *NVIC_Type) GetNVICIP48() uint8 {
	return volatile.LoadUint8(&o.NVICIP48.Reg)
}

// NVIC.NVICIP49: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP49(value uint8) {
	volatile.StoreUint8(&o.NVICIP49.Reg, value)
}
func (o *NVIC_Type) GetNVICIP49() uint8 {
	return volatile.LoadUint8(&o.NVICIP49.Reg)
}

// NVIC.NVICIP50: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP50(value uint8) {
	volatile.StoreUint8(&o.NVICIP50.Reg, value)
}
func (o *NVIC_Type) GetNVICIP50() uint8 {
	return volatile.LoadUint8(&o.NVICIP50.Reg)
}

// NVIC.NVICIP51: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP51(value uint8) {
	volatile.StoreUint8(&o.NVICIP51.Reg, value)
}
func (o *NVIC_Type) GetNVICIP51() uint8 {
	return volatile.LoadUint8(&o.NVICIP51.Reg)
}

// NVIC.NVICIP52: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP52(value uint8) {
	volatile.StoreUint8(&o.NVICIP52.Reg, value)
}
func (o *NVIC_Type) GetNVICIP52() uint8 {
	return volatile.LoadUint8(&o.NVICIP52.Reg)
}

// NVIC.NVICIP53: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP53(value uint8) {
	volatile.StoreUint8(&o.NVICIP53.Reg, value)
}
func (o *NVIC_Type) GetNVICIP53() uint8 {
	return volatile.LoadUint8(&o.NVICIP53.Reg)
}

// NVIC.NVICIP54: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP54(value uint8) {
	volatile.StoreUint8(&o.NVICIP54.Reg, value)
}
func (o *NVIC_Type) GetNVICIP54() uint8 {
	return volatile.LoadUint8(&o.NVICIP54.Reg)
}

// NVIC.NVICIP55: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP55(value uint8) {
	volatile.StoreUint8(&o.NVICIP55.Reg, value)
}
func (o *NVIC_Type) GetNVICIP55() uint8 {
	return volatile.LoadUint8(&o.NVICIP55.Reg)
}

// NVIC.NVICIP56: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP56(value uint8) {
	volatile.StoreUint8(&o.NVICIP56.Reg, value)
}
func (o *NVIC_Type) GetNVICIP56() uint8 {
	return volatile.LoadUint8(&o.NVICIP56.Reg)
}

// NVIC.NVICIP57: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP57(value uint8) {
	volatile.StoreUint8(&o.NVICIP57.Reg, value)
}
func (o *NVIC_Type) GetNVICIP57() uint8 {
	return volatile.LoadUint8(&o.NVICIP57.Reg)
}

// NVIC.NVICIP58: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP58(value uint8) {
	volatile.StoreUint8(&o.NVICIP58.Reg, value)
}
func (o *NVIC_Type) GetNVICIP58() uint8 {
	return volatile.LoadUint8(&o.NVICIP58.Reg)
}

// NVIC.NVICIP59: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP59(value uint8) {
	volatile.StoreUint8(&o.NVICIP59.Reg, value)
}
func (o *NVIC_Type) GetNVICIP59() uint8 {
	return volatile.LoadUint8(&o.NVICIP59.Reg)
}

// NVIC.NVICIP60: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP60(value uint8) {
	volatile.StoreUint8(&o.NVICIP60.Reg, value)
}
func (o *NVIC_Type) GetNVICIP60() uint8 {
	return volatile.LoadUint8(&o.NVICIP60.Reg)
}

// NVIC.NVICIP61: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP61(value uint8) {
	volatile.StoreUint8(&o.NVICIP61.Reg, value)
}
func (o *NVIC_Type) GetNVICIP61() uint8 {
	return volatile.LoadUint8(&o.NVICIP61.Reg)
}

// NVIC.NVICIP62: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP62(value uint8) {
	volatile.StoreUint8(&o.NVICIP62.Reg, value)
}
func (o *NVIC_Type) GetNVICIP62() uint8 {
	return volatile.LoadUint8(&o.NVICIP62.Reg)
}

// NVIC.NVICIP63: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP63(value uint8) {
	volatile.StoreUint8(&o.NVICIP63.Reg, value)
}
func (o *NVIC_Type) GetNVICIP63() uint8 {
	return volatile.LoadUint8(&o.NVICIP63.Reg)
}

// NVIC.NVICIP64: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP64(value uint8) {
	volatile.StoreUint8(&o.NVICIP64.Reg, value)
}
func (o *NVIC_Type) GetNVICIP64() uint8 {
	return volatile.LoadUint8(&o.NVICIP64.Reg)
}

// NVIC.NVICIP65: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP65(value uint8) {
	volatile.StoreUint8(&o.NVICIP65.Reg, value)
}
func (o *NVIC_Type) GetNVICIP65() uint8 {
	return volatile.LoadUint8(&o.NVICIP65.Reg)
}

// NVIC.NVICIP66: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP66(value uint8) {
	volatile.StoreUint8(&o.NVICIP66.Reg, value)
}
func (o *NVIC_Type) GetNVICIP66() uint8 {
	return volatile.LoadUint8(&o.NVICIP66.Reg)
}

// NVIC.NVICIP67: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP67(value uint8) {
	volatile.StoreUint8(&o.NVICIP67.Reg, value)
}
func (o *NVIC_Type) GetNVICIP67() uint8 {
	return volatile.LoadUint8(&o.NVICIP67.Reg)
}

// NVIC.NVICIP68: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP68(value uint8) {
	volatile.StoreUint8(&o.NVICIP68.Reg, value)
}
func (o *NVIC_Type) GetNVICIP68() uint8 {
	return volatile.LoadUint8(&o.NVICIP68.Reg)
}

// NVIC.NVICIP69: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP69(value uint8) {
	volatile.StoreUint8(&o.NVICIP69.Reg, value)
}
func (o *NVIC_Type) GetNVICIP69() uint8 {
	return volatile.LoadUint8(&o.NVICIP69.Reg)
}

// NVIC.NVICIP70: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP70(value uint8) {
	volatile.StoreUint8(&o.NVICIP70.Reg, value)
}
func (o *NVIC_Type) GetNVICIP70() uint8 {
	return volatile.LoadUint8(&o.NVICIP70.Reg)
}

// NVIC.NVICIP71: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP71(value uint8) {
	volatile.StoreUint8(&o.NVICIP71.Reg, value)
}
func (o *NVIC_Type) GetNVICIP71() uint8 {
	return volatile.LoadUint8(&o.NVICIP71.Reg)
}

// NVIC.NVICIP72: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP72(value uint8) {
	volatile.StoreUint8(&o.NVICIP72.Reg, value)
}
func (o *NVIC_Type) GetNVICIP72() uint8 {
	return volatile.LoadUint8(&o.NVICIP72.Reg)
}

// NVIC.NVICIP73: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP73(value uint8) {
	volatile.StoreUint8(&o.NVICIP73.Reg, value)
}
func (o *NVIC_Type) GetNVICIP73() uint8 {
	return volatile.LoadUint8(&o.NVICIP73.Reg)
}

// NVIC.NVICIP74: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP74(value uint8) {
	volatile.StoreUint8(&o.NVICIP74.Reg, value)
}
func (o *NVIC_Type) GetNVICIP74() uint8 {
	return volatile.LoadUint8(&o.NVICIP74.Reg)
}

// NVIC.NVICIP75: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP75(value uint8) {
	volatile.StoreUint8(&o.NVICIP75.Reg, value)
}
func (o *NVIC_Type) GetNVICIP75() uint8 {
	return volatile.LoadUint8(&o.NVICIP75.Reg)
}

// NVIC.NVICIP76: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP76(value uint8) {
	volatile.StoreUint8(&o.NVICIP76.Reg, value)
}
func (o *NVIC_Type) GetNVICIP76() uint8 {
	return volatile.LoadUint8(&o.NVICIP76.Reg)
}

// NVIC.NVICIP77: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP77(value uint8) {
	volatile.StoreUint8(&o.NVICIP77.Reg, value)
}
func (o *NVIC_Type) GetNVICIP77() uint8 {
	return volatile.LoadUint8(&o.NVICIP77.Reg)
}

// NVIC.NVICIP78: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP78(value uint8) {
	volatile.StoreUint8(&o.NVICIP78.Reg, value)
}
func (o *NVIC_Type) GetNVICIP78() uint8 {
	return volatile.LoadUint8(&o.NVICIP78.Reg)
}

// NVIC.NVICIP79: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP79(value uint8) {
	volatile.StoreUint8(&o.NVICIP79.Reg, value)
}
func (o *NVIC_Type) GetNVICIP79() uint8 {
	return volatile.LoadUint8(&o.NVICIP79.Reg)
}

// NVIC.NVICIP80: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP80(value uint8) {
	volatile.StoreUint8(&o.NVICIP80.Reg, value)
}
func (o *NVIC_Type) GetNVICIP80() uint8 {
	return volatile.LoadUint8(&o.NVICIP80.Reg)
}

// NVIC.NVICIP81: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP81(value uint8) {
	volatile.StoreUint8(&o.NVICIP81.Reg, value)
}
func (o *NVIC_Type) GetNVICIP81() uint8 {
	return volatile.LoadUint8(&o.NVICIP81.Reg)
}

// NVIC.NVICIP82: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP82(value uint8) {
	volatile.StoreUint8(&o.NVICIP82.Reg, value)
}
func (o *NVIC_Type) GetNVICIP82() uint8 {
	return volatile.LoadUint8(&o.NVICIP82.Reg)
}

// NVIC.NVICIP83: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP83(value uint8) {
	volatile.StoreUint8(&o.NVICIP83.Reg, value)
}
func (o *NVIC_Type) GetNVICIP83() uint8 {
	return volatile.LoadUint8(&o.NVICIP83.Reg)
}

// NVIC.NVICIP84: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP84(value uint8) {
	volatile.StoreUint8(&o.NVICIP84.Reg, value)
}
func (o *NVIC_Type) GetNVICIP84() uint8 {
	return volatile.LoadUint8(&o.NVICIP84.Reg)
}

// NVIC.NVICIP85: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP85(value uint8) {
	volatile.StoreUint8(&o.NVICIP85.Reg, value)
}
func (o *NVIC_Type) GetNVICIP85() uint8 {
	return volatile.LoadUint8(&o.NVICIP85.Reg)
}

// NVIC.NVICIP86: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP86(value uint8) {
	volatile.StoreUint8(&o.NVICIP86.Reg, value)
}
func (o *NVIC_Type) GetNVICIP86() uint8 {
	return volatile.LoadUint8(&o.NVICIP86.Reg)
}

// NVIC.NVICIP87: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP87(value uint8) {
	volatile.StoreUint8(&o.NVICIP87.Reg, value)
}
func (o *NVIC_Type) GetNVICIP87() uint8 {
	return volatile.LoadUint8(&o.NVICIP87.Reg)
}

// NVIC.NVICIP88: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP88(value uint8) {
	volatile.StoreUint8(&o.NVICIP88.Reg, value)
}
func (o *NVIC_Type) GetNVICIP88() uint8 {
	return volatile.LoadUint8(&o.NVICIP88.Reg)
}

// NVIC.NVICIP89: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP89(value uint8) {
	volatile.StoreUint8(&o.NVICIP89.Reg, value)
}
func (o *NVIC_Type) GetNVICIP89() uint8 {
	return volatile.LoadUint8(&o.NVICIP89.Reg)
}

// NVIC.NVICIP90: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP90(value uint8) {
	volatile.StoreUint8(&o.NVICIP90.Reg, value)
}
func (o *NVIC_Type) GetNVICIP90() uint8 {
	return volatile.LoadUint8(&o.NVICIP90.Reg)
}

// NVIC.NVICIP91: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP91(value uint8) {
	volatile.StoreUint8(&o.NVICIP91.Reg, value)
}
func (o *NVIC_Type) GetNVICIP91() uint8 {
	return volatile.LoadUint8(&o.NVICIP91.Reg)
}

// NVIC.NVICIP92: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP92(value uint8) {
	volatile.StoreUint8(&o.NVICIP92.Reg, value)
}
func (o *NVIC_Type) GetNVICIP92() uint8 {
	return volatile.LoadUint8(&o.NVICIP92.Reg)
}

// NVIC.NVICIP93: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP93(value uint8) {
	volatile.StoreUint8(&o.NVICIP93.Reg, value)
}
func (o *NVIC_Type) GetNVICIP93() uint8 {
	return volatile.LoadUint8(&o.NVICIP93.Reg)
}

// NVIC.NVICIP94: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP94(value uint8) {
	volatile.StoreUint8(&o.NVICIP94.Reg, value)
}
func (o *NVIC_Type) GetNVICIP94() uint8 {
	return volatile.LoadUint8(&o.NVICIP94.Reg)
}

// NVIC.NVICIP95: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP95(value uint8) {
	volatile.StoreUint8(&o.NVICIP95.Reg, value)
}
func (o *NVIC_Type) GetNVICIP95() uint8 {
	return volatile.LoadUint8(&o.NVICIP95.Reg)
}

// NVIC.NVICIP96: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP96(value uint8) {
	volatile.StoreUint8(&o.NVICIP96.Reg, value)
}
func (o *NVIC_Type) GetNVICIP96() uint8 {
	return volatile.LoadUint8(&o.NVICIP96.Reg)
}

// NVIC.NVICIP97: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP97(value uint8) {
	volatile.StoreUint8(&o.NVICIP97.Reg, value)
}
func (o *NVIC_Type) GetNVICIP97() uint8 {
	return volatile.LoadUint8(&o.NVICIP97.Reg)
}

// NVIC.NVICIP98: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP98(value uint8) {
	volatile.StoreUint8(&o.NVICIP98.Reg, value)
}
func (o *NVIC_Type) GetNVICIP98() uint8 {
	return volatile.LoadUint8(&o.NVICIP98.Reg)
}

// NVIC.NVICIP99: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP99(value uint8) {
	volatile.StoreUint8(&o.NVICIP99.Reg, value)
}
func (o *NVIC_Type) GetNVICIP99() uint8 {
	return volatile.LoadUint8(&o.NVICIP99.Reg)
}

// NVIC.NVICIP100: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP100(value uint8) {
	volatile.StoreUint8(&o.NVICIP100.Reg, value)
}
func (o *NVIC_Type) GetNVICIP100() uint8 {
	return volatile.LoadUint8(&o.NVICIP100.Reg)
}

// NVIC.NVICIP101: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP101(value uint8) {
	volatile.StoreUint8(&o.NVICIP101.Reg, value)
}
func (o *NVIC_Type) GetNVICIP101() uint8 {
	return volatile.LoadUint8(&o.NVICIP101.Reg)
}

// NVIC.NVICIP102: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP102(value uint8) {
	volatile.StoreUint8(&o.NVICIP102.Reg, value)
}
func (o *NVIC_Type) GetNVICIP102() uint8 {
	return volatile.LoadUint8(&o.NVICIP102.Reg)
}

// NVIC.NVICIP103: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP103(value uint8) {
	volatile.StoreUint8(&o.NVICIP103.Reg, value)
}
func (o *NVIC_Type) GetNVICIP103() uint8 {
	return volatile.LoadUint8(&o.NVICIP103.Reg)
}

// NVIC.NVICIP104: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP104(value uint8) {
	volatile.StoreUint8(&o.NVICIP104.Reg, value)
}
func (o *NVIC_Type) GetNVICIP104() uint8 {
	return volatile.LoadUint8(&o.NVICIP104.Reg)
}

// NVIC.NVICIP105: Interrupt Priority Register n
func (o *NVIC_Type) SetNVICIP105(value uint8) {
	volatile.StoreUint8(&o.NVICIP105.Reg, value)
}
func (o *NVIC_Type) GetNVICIP105() uint8 {
	return volatile.LoadUint8(&o.NVICIP105.Reg)
}

// NVIC.NVICSTIR: Software Trigger Interrupt Register
func (o *NVIC_Type) SetNVICSTIR_INTID(value uint32) {
	volatile.StoreUint32(&o.NVICSTIR.Reg, volatile.LoadUint32(&o.NVICSTIR.Reg)&^(0x1ff)|value)
}
func (o *NVIC_Type) GetNVICSTIR_INTID() uint32 {
	return volatile.LoadUint32(&o.NVICSTIR.Reg) & 0x1ff
}

// Core Platform Miscellaneous Control Module
type MCM_Type struct {
	_      [8]byte
	PLASC  volatile.Register16 // 0x8
	PLAMC  volatile.Register16 // 0xA
	CR     volatile.Register32 // 0xC
	ISCR   volatile.Register32 // 0x10
	ETBCC  volatile.Register32 // 0x14
	ETBRL  volatile.Register32 // 0x18
	ETBCNT volatile.Register32 // 0x1C
	FADR   volatile.Register32 // 0x20
	FATR   volatile.Register32 // 0x24
	FDR    volatile.Register32 // 0x28
	_      [4]byte
	PID    volatile.Register32 // 0x30
	_      [12]byte
	CPO    volatile.Register32 // 0x40
}

// MCM.PLASC: Crossbar Switch (AXBS) Slave Configuration
func (o *MCM_Type) SetPLASC_ASC(value uint16) {
	volatile.StoreUint16(&o.PLASC.Reg, volatile.LoadUint16(&o.PLASC.Reg)&^(0xff)|value)
}
func (o *MCM_Type) GetPLASC_ASC() uint16 {
	return volatile.LoadUint16(&o.PLASC.Reg) & 0xff
}

// MCM.PLAMC: Crossbar Switch (AXBS) Master Configuration
func (o *MCM_Type) SetPLAMC_AMC(value uint16) {
	volatile.StoreUint16(&o.PLAMC.Reg, volatile.LoadUint16(&o.PLAMC.Reg)&^(0xff)|value)
}
func (o *MCM_Type) GetPLAMC_AMC() uint16 {
	return volatile.LoadUint16(&o.PLAMC.Reg) & 0xff
}

// MCM.CR: Control Register
func (o *MCM_Type) SetCR_SRAMUAP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3000000)|value<<24)
}
func (o *MCM_Type) GetCR_SRAMUAP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3000000) >> 24
}
func (o *MCM_Type) SetCR_SRAMUWP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *MCM_Type) GetCR_SRAMUWP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *MCM_Type) SetCR_SRAMLAP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000000)|value<<28)
}
func (o *MCM_Type) GetCR_SRAMLAP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000000) >> 28
}
func (o *MCM_Type) SetCR_SRAMLWP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *MCM_Type) GetCR_SRAMLWP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}

// MCM.ISCR: Interrupt Status Register
func (o *MCM_Type) SetISCR_IRQ(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x2)|value<<1)
}
func (o *MCM_Type) GetISCR_IRQ() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x2) >> 1
}
func (o *MCM_Type) SetISCR_NMI(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x4)|value<<2)
}
func (o *MCM_Type) GetISCR_NMI() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x4) >> 2
}
func (o *MCM_Type) SetISCR_DHREQ(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x8)|value<<3)
}
func (o *MCM_Type) GetISCR_DHREQ() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x8) >> 3
}
func (o *MCM_Type) SetISCR_FIOC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x100)|value<<8)
}
func (o *MCM_Type) GetISCR_FIOC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x100) >> 8
}
func (o *MCM_Type) SetISCR_FDZC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x200)|value<<9)
}
func (o *MCM_Type) GetISCR_FDZC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x200) >> 9
}
func (o *MCM_Type) SetISCR_FOFC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x400)|value<<10)
}
func (o *MCM_Type) GetISCR_FOFC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x400) >> 10
}
func (o *MCM_Type) SetISCR_FUFC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x800)|value<<11)
}
func (o *MCM_Type) GetISCR_FUFC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x800) >> 11
}
func (o *MCM_Type) SetISCR_FIXC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x1000)|value<<12)
}
func (o *MCM_Type) GetISCR_FIXC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x1000) >> 12
}
func (o *MCM_Type) SetISCR_FIDC(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x8000)|value<<15)
}
func (o *MCM_Type) GetISCR_FIDC() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x8000) >> 15
}
func (o *MCM_Type) SetISCR_FIOCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x1000000)|value<<24)
}
func (o *MCM_Type) GetISCR_FIOCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x1000000) >> 24
}
func (o *MCM_Type) SetISCR_FDZCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x2000000)|value<<25)
}
func (o *MCM_Type) GetISCR_FDZCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x2000000) >> 25
}
func (o *MCM_Type) SetISCR_FOFCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x4000000)|value<<26)
}
func (o *MCM_Type) GetISCR_FOFCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x4000000) >> 26
}
func (o *MCM_Type) SetISCR_FUFCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x8000000)|value<<27)
}
func (o *MCM_Type) GetISCR_FUFCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x8000000) >> 27
}
func (o *MCM_Type) SetISCR_FIXCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x10000000)|value<<28)
}
func (o *MCM_Type) GetISCR_FIXCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x10000000) >> 28
}
func (o *MCM_Type) SetISCR_FIDCE(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCM_Type) GetISCR_FIDCE() uint32 {
	return (volatile.LoadUint32(&o.ISCR.Reg) & 0x80000000) >> 31
}

// MCM.ETBCC: ETB Counter Control register
func (o *MCM_Type) SetETBCC_CNTEN(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x1)|value)
}
func (o *MCM_Type) GetETBCC_CNTEN() uint32 {
	return volatile.LoadUint32(&o.ETBCC.Reg) & 0x1
}
func (o *MCM_Type) SetETBCC_RSPT(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x6)|value<<1)
}
func (o *MCM_Type) GetETBCC_RSPT() uint32 {
	return (volatile.LoadUint32(&o.ETBCC.Reg) & 0x6) >> 1
}
func (o *MCM_Type) SetETBCC_RLRQ(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x8)|value<<3)
}
func (o *MCM_Type) GetETBCC_RLRQ() uint32 {
	return (volatile.LoadUint32(&o.ETBCC.Reg) & 0x8) >> 3
}
func (o *MCM_Type) SetETBCC_ETDIS(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x10)|value<<4)
}
func (o *MCM_Type) GetETBCC_ETDIS() uint32 {
	return (volatile.LoadUint32(&o.ETBCC.Reg) & 0x10) >> 4
}
func (o *MCM_Type) SetETBCC_ITDIS(value uint32) {
	volatile.StoreUint32(&o.ETBCC.Reg, volatile.LoadUint32(&o.ETBCC.Reg)&^(0x20)|value<<5)
}
func (o *MCM_Type) GetETBCC_ITDIS() uint32 {
	return (volatile.LoadUint32(&o.ETBCC.Reg) & 0x20) >> 5
}

// MCM.ETBRL: ETB Reload register
func (o *MCM_Type) SetETBRL_RELOAD(value uint32) {
	volatile.StoreUint32(&o.ETBRL.Reg, volatile.LoadUint32(&o.ETBRL.Reg)&^(0x7ff)|value)
}
func (o *MCM_Type) GetETBRL_RELOAD() uint32 {
	return volatile.LoadUint32(&o.ETBRL.Reg) & 0x7ff
}

// MCM.ETBCNT: ETB Counter Value register
func (o *MCM_Type) SetETBCNT_COUNTER(value uint32) {
	volatile.StoreUint32(&o.ETBCNT.Reg, volatile.LoadUint32(&o.ETBCNT.Reg)&^(0x7ff)|value)
}
func (o *MCM_Type) GetETBCNT_COUNTER() uint32 {
	return volatile.LoadUint32(&o.ETBCNT.Reg) & 0x7ff
}

// MCM.FADR: Fault address register
func (o *MCM_Type) SetFADR(value uint32) {
	volatile.StoreUint32(&o.FADR.Reg, value)
}
func (o *MCM_Type) GetFADR() uint32 {
	return volatile.LoadUint32(&o.FADR.Reg)
}

// MCM.FATR: Fault attributes register
func (o *MCM_Type) SetFATR_BEDA(value uint32) {
	volatile.StoreUint32(&o.FATR.Reg, volatile.LoadUint32(&o.FATR.Reg)&^(0x1)|value)
}
func (o *MCM_Type) GetFATR_BEDA() uint32 {
	return volatile.LoadUint32(&o.FATR.Reg) & 0x1
}
func (o *MCM_Type) SetFATR_BEMD(value uint32) {
	volatile.StoreUint32(&o.FATR.Reg, volatile.LoadUint32(&o.FATR.Reg)&^(0x2)|value<<1)
}
func (o *MCM_Type) GetFATR_BEMD() uint32 {
	return (volatile.LoadUint32(&o.FATR.Reg) & 0x2) >> 1
}
func (o *MCM_Type) SetFATR_BESZ(value uint32) {
	volatile.StoreUint32(&o.FATR.Reg, volatile.LoadUint32(&o.FATR.Reg)&^(0x30)|value<<4)
}
func (o *MCM_Type) GetFATR_BESZ() uint32 {
	return (volatile.LoadUint32(&o.FATR.Reg) & 0x30) >> 4
}
func (o *MCM_Type) SetFATR_BEWT(value uint32) {
	volatile.StoreUint32(&o.FATR.Reg, volatile.LoadUint32(&o.FATR.Reg)&^(0x80)|value<<7)
}
func (o *MCM_Type) GetFATR_BEWT() uint32 {
	return (volatile.LoadUint32(&o.FATR.Reg) & 0x80) >> 7
}
func (o *MCM_Type) SetFATR_BEMN(value uint32) {
	volatile.StoreUint32(&o.FATR.Reg, volatile.LoadUint32(&o.FATR.Reg)&^(0xf00)|value<<8)
}
func (o *MCM_Type) GetFATR_BEMN() uint32 {
	return (volatile.LoadUint32(&o.FATR.Reg) & 0xf00) >> 8
}
func (o *MCM_Type) SetFATR_BEOVR(value uint32) {
	volatile.StoreUint32(&o.FATR.Reg, volatile.LoadUint32(&o.FATR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCM_Type) GetFATR_BEOVR() uint32 {
	return (volatile.LoadUint32(&o.FATR.Reg) & 0x80000000) >> 31
}

// MCM.FDR: Fault data register
func (o *MCM_Type) SetFDR(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, value)
}
func (o *MCM_Type) GetFDR() uint32 {
	return volatile.LoadUint32(&o.FDR.Reg)
}

// MCM.PID: Process ID register
func (o *MCM_Type) SetPID(value uint32) {
	volatile.StoreUint32(&o.PID.Reg, volatile.LoadUint32(&o.PID.Reg)&^(0xff)|value)
}
func (o *MCM_Type) GetPID() uint32 {
	return volatile.LoadUint32(&o.PID.Reg) & 0xff
}

// MCM.CPO: Compute Operation Control Register
func (o *MCM_Type) SetCPO_CPOREQ(value uint32) {
	volatile.StoreUint32(&o.CPO.Reg, volatile.LoadUint32(&o.CPO.Reg)&^(0x1)|value)
}
func (o *MCM_Type) GetCPO_CPOREQ() uint32 {
	return volatile.LoadUint32(&o.CPO.Reg) & 0x1
}
func (o *MCM_Type) SetCPO_CPOACK(value uint32) {
	volatile.StoreUint32(&o.CPO.Reg, volatile.LoadUint32(&o.CPO.Reg)&^(0x2)|value<<1)
}
func (o *MCM_Type) GetCPO_CPOACK() uint32 {
	return (volatile.LoadUint32(&o.CPO.Reg) & 0x2) >> 1
}
func (o *MCM_Type) SetCPO_CPOWOI(value uint32) {
	volatile.StoreUint32(&o.CPO.Reg, volatile.LoadUint32(&o.CPO.Reg)&^(0x4)|value<<2)
}
func (o *MCM_Type) GetCPO_CPOWOI() uint32 {
	return (volatile.LoadUint32(&o.CPO.Reg) & 0x4) >> 2
}

// Memory Mapped Cryptographic Acceleration Unit (MMCAU)
type CAU_Type struct {
	CAU_DIRECT0    volatile.Register32 // 0x0
	CAU_DIRECT1    volatile.Register32 // 0x4
	CAU_DIRECT2    volatile.Register32 // 0x8
	CAU_DIRECT3    volatile.Register32 // 0xC
	CAU_DIRECT4    volatile.Register32 // 0x10
	CAU_DIRECT5    volatile.Register32 // 0x14
	CAU_DIRECT6    volatile.Register32 // 0x18
	CAU_DIRECT7    volatile.Register32 // 0x1C
	CAU_DIRECT8    volatile.Register32 // 0x20
	CAU_DIRECT9    volatile.Register32 // 0x24
	CAU_DIRECT10   volatile.Register32 // 0x28
	CAU_DIRECT11   volatile.Register32 // 0x2C
	CAU_DIRECT12   volatile.Register32 // 0x30
	CAU_DIRECT13   volatile.Register32 // 0x34
	CAU_DIRECT14   volatile.Register32 // 0x38
	CAU_DIRECT15   volatile.Register32 // 0x3C
	_              [2048]byte
	CAU_LDR_CASR   volatile.Register32 // 0x840
	CAU_LDR_CAA    volatile.Register32 // 0x844
	CAU_LDR_CA0    volatile.Register32 // 0x848
	CAU_LDR_CA1    volatile.Register32 // 0x84C
	CAU_LDR_CA2    volatile.Register32 // 0x850
	CAU_LDR_CA3    volatile.Register32 // 0x854
	CAU_LDR_CA4    volatile.Register32 // 0x858
	CAU_LDR_CA5    volatile.Register32 // 0x85C
	CAU_LDR_CA6    volatile.Register32 // 0x860
	CAU_LDR_CA7    volatile.Register32 // 0x864
	CAU_LDR_CA8    volatile.Register32 // 0x868
	_              [20]byte
	CAU_STR_CASR   volatile.Register32 // 0x880
	CAU_STR_CAA    volatile.Register32 // 0x884
	CAU_STR_CA0    volatile.Register32 // 0x888
	CAU_STR_CA1    volatile.Register32 // 0x88C
	CAU_STR_CA2    volatile.Register32 // 0x890
	CAU_STR_CA3    volatile.Register32 // 0x894
	CAU_STR_CA4    volatile.Register32 // 0x898
	CAU_STR_CA5    volatile.Register32 // 0x89C
	CAU_STR_CA6    volatile.Register32 // 0x8A0
	CAU_STR_CA7    volatile.Register32 // 0x8A4
	CAU_STR_CA8    volatile.Register32 // 0x8A8
	_              [20]byte
	CAU_ADR_CASR   volatile.Register32 // 0x8C0
	CAU_ADR_CAA    volatile.Register32 // 0x8C4
	CAU_ADR_CA0    volatile.Register32 // 0x8C8
	CAU_ADR_CA1    volatile.Register32 // 0x8CC
	CAU_ADR_CA2    volatile.Register32 // 0x8D0
	CAU_ADR_CA3    volatile.Register32 // 0x8D4
	CAU_ADR_CA4    volatile.Register32 // 0x8D8
	CAU_ADR_CA5    volatile.Register32 // 0x8DC
	CAU_ADR_CA6    volatile.Register32 // 0x8E0
	CAU_ADR_CA7    volatile.Register32 // 0x8E4
	CAU_ADR_CA8    volatile.Register32 // 0x8E8
	_              [20]byte
	CAU_RADR_CASR  volatile.Register32 // 0x900
	CAU_RADR_CAA   volatile.Register32 // 0x904
	CAU_RADR_CA0   volatile.Register32 // 0x908
	CAU_RADR_CA1   volatile.Register32 // 0x90C
	CAU_RADR_CA2   volatile.Register32 // 0x910
	CAU_RADR_CA3   volatile.Register32 // 0x914
	CAU_RADR_CA4   volatile.Register32 // 0x918
	CAU_RADR_CA5   volatile.Register32 // 0x91C
	CAU_RADR_CA6   volatile.Register32 // 0x920
	CAU_RADR_CA7   volatile.Register32 // 0x924
	CAU_RADR_CA8   volatile.Register32 // 0x928
	_              [84]byte
	CAU_XOR_CASR   volatile.Register32 // 0x980
	CAU_XOR_CAA    volatile.Register32 // 0x984
	CAU_XOR_CA0    volatile.Register32 // 0x988
	CAU_XOR_CA1    volatile.Register32 // 0x98C
	CAU_XOR_CA2    volatile.Register32 // 0x990
	CAU_XOR_CA3    volatile.Register32 // 0x994
	CAU_XOR_CA4    volatile.Register32 // 0x998
	CAU_XOR_CA5    volatile.Register32 // 0x99C
	CAU_XOR_CA6    volatile.Register32 // 0x9A0
	CAU_XOR_CA7    volatile.Register32 // 0x9A4
	CAU_XOR_CA8    volatile.Register32 // 0x9A8
	_              [20]byte
	CAU_ROTL_CASR  volatile.Register32 // 0x9C0
	CAU_ROTL_CAA   volatile.Register32 // 0x9C4
	CAU_ROTL_CA0   volatile.Register32 // 0x9C8
	CAU_ROTL_CA1   volatile.Register32 // 0x9CC
	CAU_ROTL_CA2   volatile.Register32 // 0x9D0
	CAU_ROTL_CA3   volatile.Register32 // 0x9D4
	CAU_ROTL_CA4   volatile.Register32 // 0x9D8
	CAU_ROTL_CA5   volatile.Register32 // 0x9DC
	CAU_ROTL_CA6   volatile.Register32 // 0x9E0
	CAU_ROTL_CA7   volatile.Register32 // 0x9E4
	CAU_ROTL_CA8   volatile.Register32 // 0x9E8
	_              [276]byte
	CAU_AESC_CASR  volatile.Register32 // 0xB00
	CAU_AESC_CAA   volatile.Register32 // 0xB04
	CAU_AESC_CA0   volatile.Register32 // 0xB08
	CAU_AESC_CA1   volatile.Register32 // 0xB0C
	CAU_AESC_CA2   volatile.Register32 // 0xB10
	CAU_AESC_CA3   volatile.Register32 // 0xB14
	CAU_AESC_CA4   volatile.Register32 // 0xB18
	CAU_AESC_CA5   volatile.Register32 // 0xB1C
	CAU_AESC_CA6   volatile.Register32 // 0xB20
	CAU_AESC_CA7   volatile.Register32 // 0xB24
	CAU_AESC_CA8   volatile.Register32 // 0xB28
	_              [20]byte
	CAU_AESIC_CASR volatile.Register32 // 0xB40
	CAU_AESIC_CAA  volatile.Register32 // 0xB44
	CAU_AESIC_CA0  volatile.Register32 // 0xB48
	CAU_AESIC_CA1  volatile.Register32 // 0xB4C
	CAU_AESIC_CA2  volatile.Register32 // 0xB50
	CAU_AESIC_CA3  volatile.Register32 // 0xB54
	CAU_AESIC_CA4  volatile.Register32 // 0xB58
	CAU_AESIC_CA5  volatile.Register32 // 0xB5C
	CAU_AESIC_CA6  volatile.Register32 // 0xB60
	CAU_AESIC_CA7  volatile.Register32 // 0xB64
	CAU_AESIC_CA8  volatile.Register32 // 0xB68
}

// CAU.CAU_DIRECT0: Direct access register 0
func (o *CAU_Type) SetCAU_DIRECT0(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT0.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT0() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT0.Reg)
}

// CAU.CAU_DIRECT1: Direct access register 1
func (o *CAU_Type) SetCAU_DIRECT1(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT1.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT1() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT1.Reg)
}

// CAU.CAU_DIRECT2: Direct access register 2
func (o *CAU_Type) SetCAU_DIRECT2(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT2.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT2() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT2.Reg)
}

// CAU.CAU_DIRECT3: Direct access register 3
func (o *CAU_Type) SetCAU_DIRECT3(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT3.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT3() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT3.Reg)
}

// CAU.CAU_DIRECT4: Direct access register 4
func (o *CAU_Type) SetCAU_DIRECT4(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT4.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT4() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT4.Reg)
}

// CAU.CAU_DIRECT5: Direct access register 5
func (o *CAU_Type) SetCAU_DIRECT5(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT5.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT5() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT5.Reg)
}

// CAU.CAU_DIRECT6: Direct access register 6
func (o *CAU_Type) SetCAU_DIRECT6(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT6.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT6() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT6.Reg)
}

// CAU.CAU_DIRECT7: Direct access register 7
func (o *CAU_Type) SetCAU_DIRECT7(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT7.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT7() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT7.Reg)
}

// CAU.CAU_DIRECT8: Direct access register 8
func (o *CAU_Type) SetCAU_DIRECT8(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT8.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT8() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT8.Reg)
}

// CAU.CAU_DIRECT9: Direct access register 9
func (o *CAU_Type) SetCAU_DIRECT9(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT9.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT9() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT9.Reg)
}

// CAU.CAU_DIRECT10: Direct access register 10
func (o *CAU_Type) SetCAU_DIRECT10(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT10.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT10() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT10.Reg)
}

// CAU.CAU_DIRECT11: Direct access register 11
func (o *CAU_Type) SetCAU_DIRECT11(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT11.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT11() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT11.Reg)
}

// CAU.CAU_DIRECT12: Direct access register 12
func (o *CAU_Type) SetCAU_DIRECT12(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT12.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT12() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT12.Reg)
}

// CAU.CAU_DIRECT13: Direct access register 13
func (o *CAU_Type) SetCAU_DIRECT13(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT13.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT13() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT13.Reg)
}

// CAU.CAU_DIRECT14: Direct access register 14
func (o *CAU_Type) SetCAU_DIRECT14(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT14.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT14() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT14.Reg)
}

// CAU.CAU_DIRECT15: Direct access register 15
func (o *CAU_Type) SetCAU_DIRECT15(value uint32) {
	volatile.StoreUint32(&o.CAU_DIRECT15.Reg, value)
}
func (o *CAU_Type) GetCAU_DIRECT15() uint32 {
	return volatile.LoadUint32(&o.CAU_DIRECT15.Reg)
}

// CAU.CAU_LDR_CASR: Status register - Load Register command
func (o *CAU_Type) SetCAU_LDR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CASR.Reg, volatile.LoadUint32(&o.CAU_LDR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_LDR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_LDR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CASR.Reg, volatile.LoadUint32(&o.CAU_LDR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_LDR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_LDR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_LDR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CASR.Reg, volatile.LoadUint32(&o.CAU_LDR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_LDR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_LDR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_LDR_CAA: Accumulator register - Load Register command
func (o *CAU_Type) SetCAU_LDR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CAA.Reg)
}

// CAU.CAU_LDR_CA0: General Purpose Register 0 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA0.Reg)
}

// CAU.CAU_LDR_CA1: General Purpose Register 1 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA1.Reg)
}

// CAU.CAU_LDR_CA2: General Purpose Register 2 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA2.Reg)
}

// CAU.CAU_LDR_CA3: General Purpose Register 3 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA3.Reg)
}

// CAU.CAU_LDR_CA4: General Purpose Register 4 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA4.Reg)
}

// CAU.CAU_LDR_CA5: General Purpose Register 5 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA5.Reg)
}

// CAU.CAU_LDR_CA6: General Purpose Register 6 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA6.Reg)
}

// CAU.CAU_LDR_CA7: General Purpose Register 7 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA7.Reg)
}

// CAU.CAU_LDR_CA8: General Purpose Register 8 - Load Register command
func (o *CAU_Type) SetCAU_LDR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_LDR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_LDR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_LDR_CA8.Reg)
}

// CAU.CAU_STR_CASR: Status register - Store Register command
func (o *CAU_Type) SetCAU_STR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CASR.Reg, volatile.LoadUint32(&o.CAU_STR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_STR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_STR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CASR.Reg, volatile.LoadUint32(&o.CAU_STR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_STR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_STR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_STR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CASR.Reg, volatile.LoadUint32(&o.CAU_STR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_STR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_STR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_STR_CAA: Accumulator register - Store Register command
func (o *CAU_Type) SetCAU_STR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CAA.Reg)
}

// CAU.CAU_STR_CA0: General Purpose Register 0 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA0.Reg)
}

// CAU.CAU_STR_CA1: General Purpose Register 1 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA1.Reg)
}

// CAU.CAU_STR_CA2: General Purpose Register 2 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA2.Reg)
}

// CAU.CAU_STR_CA3: General Purpose Register 3 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA3.Reg)
}

// CAU.CAU_STR_CA4: General Purpose Register 4 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA4.Reg)
}

// CAU.CAU_STR_CA5: General Purpose Register 5 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA5.Reg)
}

// CAU.CAU_STR_CA6: General Purpose Register 6 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA6.Reg)
}

// CAU.CAU_STR_CA7: General Purpose Register 7 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA7.Reg)
}

// CAU.CAU_STR_CA8: General Purpose Register 8 - Store Register command
func (o *CAU_Type) SetCAU_STR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_STR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_STR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_STR_CA8.Reg)
}

// CAU.CAU_ADR_CASR: Status register - Add Register command
func (o *CAU_Type) SetCAU_ADR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CASR.Reg, volatile.LoadUint32(&o.CAU_ADR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_ADR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_ADR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CASR.Reg, volatile.LoadUint32(&o.CAU_ADR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_ADR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_ADR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_ADR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CASR.Reg, volatile.LoadUint32(&o.CAU_ADR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_ADR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_ADR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_ADR_CAA: Accumulator register - Add to register command
func (o *CAU_Type) SetCAU_ADR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CAA.Reg)
}

// CAU.CAU_ADR_CA0: General Purpose Register 0 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA0.Reg)
}

// CAU.CAU_ADR_CA1: General Purpose Register 1 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA1.Reg)
}

// CAU.CAU_ADR_CA2: General Purpose Register 2 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA2.Reg)
}

// CAU.CAU_ADR_CA3: General Purpose Register 3 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA3.Reg)
}

// CAU.CAU_ADR_CA4: General Purpose Register 4 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA4.Reg)
}

// CAU.CAU_ADR_CA5: General Purpose Register 5 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA5.Reg)
}

// CAU.CAU_ADR_CA6: General Purpose Register 6 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA6.Reg)
}

// CAU.CAU_ADR_CA7: General Purpose Register 7 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA7.Reg)
}

// CAU.CAU_ADR_CA8: General Purpose Register 8 - Add to register command
func (o *CAU_Type) SetCAU_ADR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_ADR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_ADR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_ADR_CA8.Reg)
}

// CAU.CAU_RADR_CASR: Status register - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CASR.Reg, volatile.LoadUint32(&o.CAU_RADR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_RADR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_RADR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CASR.Reg, volatile.LoadUint32(&o.CAU_RADR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_RADR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_RADR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_RADR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CASR.Reg, volatile.LoadUint32(&o.CAU_RADR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_RADR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_RADR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_RADR_CAA: Accumulator register - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CAA.Reg)
}

// CAU.CAU_RADR_CA0: General Purpose Register 0 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA0.Reg)
}

// CAU.CAU_RADR_CA1: General Purpose Register 1 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA1.Reg)
}

// CAU.CAU_RADR_CA2: General Purpose Register 2 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA2.Reg)
}

// CAU.CAU_RADR_CA3: General Purpose Register 3 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA3.Reg)
}

// CAU.CAU_RADR_CA4: General Purpose Register 4 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA4.Reg)
}

// CAU.CAU_RADR_CA5: General Purpose Register 5 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA5.Reg)
}

// CAU.CAU_RADR_CA6: General Purpose Register 6 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA6.Reg)
}

// CAU.CAU_RADR_CA7: General Purpose Register 7 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA7.Reg)
}

// CAU.CAU_RADR_CA8: General Purpose Register 8 - Reverse and Add to Register command
func (o *CAU_Type) SetCAU_RADR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_RADR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_RADR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_RADR_CA8.Reg)
}

// CAU.CAU_XOR_CASR: Status register - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CASR.Reg, volatile.LoadUint32(&o.CAU_XOR_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_XOR_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_XOR_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CASR.Reg, volatile.LoadUint32(&o.CAU_XOR_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_XOR_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_XOR_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_XOR_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CASR.Reg, volatile.LoadUint32(&o.CAU_XOR_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_XOR_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_XOR_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_XOR_CAA: Accumulator register - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CAA.Reg)
}

// CAU.CAU_XOR_CA0: General Purpose Register 0 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA0.Reg)
}

// CAU.CAU_XOR_CA1: General Purpose Register 1 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA1.Reg)
}

// CAU.CAU_XOR_CA2: General Purpose Register 2 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA2.Reg)
}

// CAU.CAU_XOR_CA3: General Purpose Register 3 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA3.Reg)
}

// CAU.CAU_XOR_CA4: General Purpose Register 4 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA4.Reg)
}

// CAU.CAU_XOR_CA5: General Purpose Register 5 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA5.Reg)
}

// CAU.CAU_XOR_CA6: General Purpose Register 6 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA6.Reg)
}

// CAU.CAU_XOR_CA7: General Purpose Register 7 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA7.Reg)
}

// CAU.CAU_XOR_CA8: General Purpose Register 8 - Exclusive Or command
func (o *CAU_Type) SetCAU_XOR_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_XOR_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_XOR_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_XOR_CA8.Reg)
}

// CAU.CAU_ROTL_CASR: Status register - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CASR.Reg, volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_ROTL_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_ROTL_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CASR.Reg, volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_ROTL_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_ROTL_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CASR.Reg, volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_ROTL_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_ROTL_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_ROTL_CAA: Accumulator register - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CAA.Reg)
}

// CAU.CAU_ROTL_CA0: General Purpose Register 0 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA0.Reg)
}

// CAU.CAU_ROTL_CA1: General Purpose Register 1 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA1.Reg)
}

// CAU.CAU_ROTL_CA2: General Purpose Register 2 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA2.Reg)
}

// CAU.CAU_ROTL_CA3: General Purpose Register 3 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA3.Reg)
}

// CAU.CAU_ROTL_CA4: General Purpose Register 4 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA4.Reg)
}

// CAU.CAU_ROTL_CA5: General Purpose Register 5 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA5.Reg)
}

// CAU.CAU_ROTL_CA6: General Purpose Register 6 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA6.Reg)
}

// CAU.CAU_ROTL_CA7: General Purpose Register 7 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA7.Reg)
}

// CAU.CAU_ROTL_CA8: General Purpose Register 8 - Rotate Left command
func (o *CAU_Type) SetCAU_ROTL_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_ROTL_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_ROTL_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_ROTL_CA8.Reg)
}

// CAU.CAU_AESC_CASR: Status register - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESC_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_AESC_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_AESC_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESC_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_AESC_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_AESC_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_AESC_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESC_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_AESC_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_AESC_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_AESC_CAA: Accumulator register - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CAA.Reg)
}

// CAU.CAU_AESC_CA0: General Purpose Register 0 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA0.Reg)
}

// CAU.CAU_AESC_CA1: General Purpose Register 1 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA1.Reg)
}

// CAU.CAU_AESC_CA2: General Purpose Register 2 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA2.Reg)
}

// CAU.CAU_AESC_CA3: General Purpose Register 3 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA3.Reg)
}

// CAU.CAU_AESC_CA4: General Purpose Register 4 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA4.Reg)
}

// CAU.CAU_AESC_CA5: General Purpose Register 5 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA5.Reg)
}

// CAU.CAU_AESC_CA6: General Purpose Register 6 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA6.Reg)
}

// CAU.CAU_AESC_CA7: General Purpose Register 7 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA7.Reg)
}

// CAU.CAU_AESC_CA8: General Purpose Register 8 - AES Column Operation command
func (o *CAU_Type) SetCAU_AESC_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_AESC_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_AESC_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_AESC_CA8.Reg)
}

// CAU.CAU_AESIC_CASR: Status register - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CASR_IC(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg)&^(0x1)|value)
}
func (o *CAU_Type) GetCAU_AESIC_CASR_IC() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg) & 0x1
}
func (o *CAU_Type) SetCAU_AESIC_CASR_DPE(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg)&^(0x2)|value<<1)
}
func (o *CAU_Type) GetCAU_AESIC_CASR_DPE() uint32 {
	return (volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg) & 0x2) >> 1
}
func (o *CAU_Type) SetCAU_AESIC_CASR_VER(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CASR.Reg, volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAU_Type) GetCAU_AESIC_CASR_VER() uint32 {
	return (volatile.LoadUint32(&o.CAU_AESIC_CASR.Reg) & 0xf0000000) >> 28
}

// CAU.CAU_AESIC_CAA: Accumulator register - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CAA(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CAA.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CAA() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CAA.Reg)
}

// CAU.CAU_AESIC_CA0: General Purpose Register 0 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA0(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA0.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA0() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA0.Reg)
}

// CAU.CAU_AESIC_CA1: General Purpose Register 1 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA1(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA1.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA1() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA1.Reg)
}

// CAU.CAU_AESIC_CA2: General Purpose Register 2 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA2(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA2.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA2() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA2.Reg)
}

// CAU.CAU_AESIC_CA3: General Purpose Register 3 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA3(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA3.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA3() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA3.Reg)
}

// CAU.CAU_AESIC_CA4: General Purpose Register 4 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA4(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA4.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA4() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA4.Reg)
}

// CAU.CAU_AESIC_CA5: General Purpose Register 5 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA5(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA5.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA5() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA5.Reg)
}

// CAU.CAU_AESIC_CA6: General Purpose Register 6 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA6(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA6.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA6() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA6.Reg)
}

// CAU.CAU_AESIC_CA7: General Purpose Register 7 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA7(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA7.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA7() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA7.Reg)
}

// CAU.CAU_AESIC_CA8: General Purpose Register 8 - AES Inverse Column Operation command
func (o *CAU_Type) SetCAU_AESIC_CA8(value uint32) {
	volatile.StoreUint32(&o.CAU_AESIC_CA8.Reg, value)
}
func (o *CAU_Type) GetCAU_AESIC_CA8() uint32 {
	return volatile.LoadUint32(&o.CAU_AESIC_CA8.Reg)
}

// Local Memory Controller
type LMEM_Type struct {
	PCCCR  volatile.Register32 // 0x0
	PCCLCR volatile.Register32 // 0x4
	PCCSAR volatile.Register32 // 0x8
	PCCCVR volatile.Register32 // 0xC
	_      [16]byte
	PCCRMR volatile.Register32 // 0x20
}

// LMEM.PCCCR: Cache control register
func (o *LMEM_Type) SetPCCCR_ENCACHE(value uint32) {
	volatile.StoreUint32(&o.PCCCR.Reg, volatile.LoadUint32(&o.PCCCR.Reg)&^(0x1)|value)
}
func (o *LMEM_Type) GetPCCCR_ENCACHE() uint32 {
	return volatile.LoadUint32(&o.PCCCR.Reg) & 0x1
}
func (o *LMEM_Type) SetPCCCR_ENWRBUF(value uint32) {
	volatile.StoreUint32(&o.PCCCR.Reg, volatile.LoadUint32(&o.PCCCR.Reg)&^(0x2)|value<<1)
}
func (o *LMEM_Type) GetPCCCR_ENWRBUF() uint32 {
	return (volatile.LoadUint32(&o.PCCCR.Reg) & 0x2) >> 1
}
func (o *LMEM_Type) SetPCCCR_PCCR2(value uint32) {
	volatile.StoreUint32(&o.PCCCR.Reg, volatile.LoadUint32(&o.PCCCR.Reg)&^(0x4)|value<<2)
}
func (o *LMEM_Type) GetPCCCR_PCCR2() uint32 {
	return (volatile.LoadUint32(&o.PCCCR.Reg) & 0x4) >> 2
}
func (o *LMEM_Type) SetPCCCR_PCCR3(value uint32) {
	volatile.StoreUint32(&o.PCCCR.Reg, volatile.LoadUint32(&o.PCCCR.Reg)&^(0x8)|value<<3)
}
func (o *LMEM_Type) GetPCCCR_PCCR3() uint32 {
	return (volatile.LoadUint32(&o.PCCCR.Reg) & 0x8) >> 3
}
func (o *LMEM_Type) SetPCCCR_INVW0(value uint32) {
	volatile.StoreUint32(&o.PCCCR.Reg, volatile.LoadUint32(&o.PCCCR.Reg)&^(0x1000000)|value<<24)
}
func (o *LMEM_Type) GetPCCCR_INVW0() uint32 {
	return (volatile.LoadUint32(&o.PCCCR.Reg) & 0x1000000) >> 24
}
func (o *LMEM_Type) SetPCCCR_PUSHW0(value uint32) {
	volatile.StoreUint32(&o.PCCCR.Reg, volatile.LoadUint32(&o.PCCCR.Reg)&^(0x2000000)|value<<25)
}
func (o *LMEM_Type) GetPCCCR_PUSHW0() uint32 {
	return (volatile.LoadUint32(&o.PCCCR.Reg) & 0x2000000) >> 25
}
func (o *LMEM_Type) SetPCCCR_INVW1(value uint32) {
	volatile.StoreUint32(&o.PCCCR.Reg, volatile.LoadUint32(&o.PCCCR.Reg)&^(0x4000000)|value<<26)
}
func (o *LMEM_Type) GetPCCCR_INVW1() uint32 {
	return (volatile.LoadUint32(&o.PCCCR.Reg) & 0x4000000) >> 26
}
func (o *LMEM_Type) SetPCCCR_PUSHW1(value uint32) {
	volatile.StoreUint32(&o.PCCCR.Reg, volatile.LoadUint32(&o.PCCCR.Reg)&^(0x8000000)|value<<27)
}
func (o *LMEM_Type) GetPCCCR_PUSHW1() uint32 {
	return (volatile.LoadUint32(&o.PCCCR.Reg) & 0x8000000) >> 27
}
func (o *LMEM_Type) SetPCCCR_GO(value uint32) {
	volatile.StoreUint32(&o.PCCCR.Reg, volatile.LoadUint32(&o.PCCCR.Reg)&^(0x80000000)|value<<31)
}
func (o *LMEM_Type) GetPCCCR_GO() uint32 {
	return (volatile.LoadUint32(&o.PCCCR.Reg) & 0x80000000) >> 31
}

// LMEM.PCCLCR: Cache line control register
func (o *LMEM_Type) SetPCCLCR_LGO(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0x1)|value)
}
func (o *LMEM_Type) GetPCCLCR_LGO() uint32 {
	return volatile.LoadUint32(&o.PCCLCR.Reg) & 0x1
}
func (o *LMEM_Type) SetPCCLCR_CACHEADDR(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0xffc)|value<<2)
}
func (o *LMEM_Type) GetPCCLCR_CACHEADDR() uint32 {
	return (volatile.LoadUint32(&o.PCCLCR.Reg) & 0xffc) >> 2
}
func (o *LMEM_Type) SetPCCLCR_WSEL(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0x4000)|value<<14)
}
func (o *LMEM_Type) GetPCCLCR_WSEL() uint32 {
	return (volatile.LoadUint32(&o.PCCLCR.Reg) & 0x4000) >> 14
}
func (o *LMEM_Type) SetPCCLCR_TDSEL(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0x10000)|value<<16)
}
func (o *LMEM_Type) GetPCCLCR_TDSEL() uint32 {
	return (volatile.LoadUint32(&o.PCCLCR.Reg) & 0x10000) >> 16
}
func (o *LMEM_Type) SetPCCLCR_LCIVB(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0x100000)|value<<20)
}
func (o *LMEM_Type) GetPCCLCR_LCIVB() uint32 {
	return (volatile.LoadUint32(&o.PCCLCR.Reg) & 0x100000) >> 20
}
func (o *LMEM_Type) SetPCCLCR_LCIMB(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0x200000)|value<<21)
}
func (o *LMEM_Type) GetPCCLCR_LCIMB() uint32 {
	return (volatile.LoadUint32(&o.PCCLCR.Reg) & 0x200000) >> 21
}
func (o *LMEM_Type) SetPCCLCR_LCWAY(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0x400000)|value<<22)
}
func (o *LMEM_Type) GetPCCLCR_LCWAY() uint32 {
	return (volatile.LoadUint32(&o.PCCLCR.Reg) & 0x400000) >> 22
}
func (o *LMEM_Type) SetPCCLCR_LCMD(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0x3000000)|value<<24)
}
func (o *LMEM_Type) GetPCCLCR_LCMD() uint32 {
	return (volatile.LoadUint32(&o.PCCLCR.Reg) & 0x3000000) >> 24
}
func (o *LMEM_Type) SetPCCLCR_LADSEL(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0x4000000)|value<<26)
}
func (o *LMEM_Type) GetPCCLCR_LADSEL() uint32 {
	return (volatile.LoadUint32(&o.PCCLCR.Reg) & 0x4000000) >> 26
}
func (o *LMEM_Type) SetPCCLCR_LACC(value uint32) {
	volatile.StoreUint32(&o.PCCLCR.Reg, volatile.LoadUint32(&o.PCCLCR.Reg)&^(0x8000000)|value<<27)
}
func (o *LMEM_Type) GetPCCLCR_LACC() uint32 {
	return (volatile.LoadUint32(&o.PCCLCR.Reg) & 0x8000000) >> 27
}

// LMEM.PCCSAR: Cache search address register
func (o *LMEM_Type) SetPCCSAR_LGO(value uint32) {
	volatile.StoreUint32(&o.PCCSAR.Reg, volatile.LoadUint32(&o.PCCSAR.Reg)&^(0x1)|value)
}
func (o *LMEM_Type) GetPCCSAR_LGO() uint32 {
	return volatile.LoadUint32(&o.PCCSAR.Reg) & 0x1
}
func (o *LMEM_Type) SetPCCSAR_PHYADDR(value uint32) {
	volatile.StoreUint32(&o.PCCSAR.Reg, volatile.LoadUint32(&o.PCCSAR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LMEM_Type) GetPCCSAR_PHYADDR() uint32 {
	return (volatile.LoadUint32(&o.PCCSAR.Reg) & 0xfffffffc) >> 2
}

// LMEM.PCCCVR: Cache read/write value register
func (o *LMEM_Type) SetPCCCVR(value uint32) {
	volatile.StoreUint32(&o.PCCCVR.Reg, value)
}
func (o *LMEM_Type) GetPCCCVR() uint32 {
	return volatile.LoadUint32(&o.PCCCVR.Reg)
}

// LMEM.PCCRMR: Cache regions mode register
func (o *LMEM_Type) SetPCCRMR_R15(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0x3)|value)
}
func (o *LMEM_Type) GetPCCRMR_R15() uint32 {
	return volatile.LoadUint32(&o.PCCRMR.Reg) & 0x3
}
func (o *LMEM_Type) SetPCCRMR_R14(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0xc)|value<<2)
}
func (o *LMEM_Type) GetPCCRMR_R14() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0xc) >> 2
}
func (o *LMEM_Type) SetPCCRMR_R13(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0x30)|value<<4)
}
func (o *LMEM_Type) GetPCCRMR_R13() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0x30) >> 4
}
func (o *LMEM_Type) SetPCCRMR_R12(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0xc0)|value<<6)
}
func (o *LMEM_Type) GetPCCRMR_R12() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0xc0) >> 6
}
func (o *LMEM_Type) SetPCCRMR_R11(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0x300)|value<<8)
}
func (o *LMEM_Type) GetPCCRMR_R11() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0x300) >> 8
}
func (o *LMEM_Type) SetPCCRMR_R10(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0xc00)|value<<10)
}
func (o *LMEM_Type) GetPCCRMR_R10() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0xc00) >> 10
}
func (o *LMEM_Type) SetPCCRMR_R9(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0x3000)|value<<12)
}
func (o *LMEM_Type) GetPCCRMR_R9() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0x3000) >> 12
}
func (o *LMEM_Type) SetPCCRMR_R8(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0xc000)|value<<14)
}
func (o *LMEM_Type) GetPCCRMR_R8() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0xc000) >> 14
}
func (o *LMEM_Type) SetPCCRMR_R7(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0x30000)|value<<16)
}
func (o *LMEM_Type) GetPCCRMR_R7() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0x30000) >> 16
}
func (o *LMEM_Type) SetPCCRMR_R6(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0xc0000)|value<<18)
}
func (o *LMEM_Type) GetPCCRMR_R6() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0xc0000) >> 18
}
func (o *LMEM_Type) SetPCCRMR_R5(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0x300000)|value<<20)
}
func (o *LMEM_Type) GetPCCRMR_R5() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0x300000) >> 20
}
func (o *LMEM_Type) SetPCCRMR_R4(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0xc00000)|value<<22)
}
func (o *LMEM_Type) GetPCCRMR_R4() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0xc00000) >> 22
}
func (o *LMEM_Type) SetPCCRMR_R3(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0x3000000)|value<<24)
}
func (o *LMEM_Type) GetPCCRMR_R3() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0x3000000) >> 24
}
func (o *LMEM_Type) SetPCCRMR_R2(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0xc000000)|value<<26)
}
func (o *LMEM_Type) GetPCCRMR_R2() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0xc000000) >> 26
}
func (o *LMEM_Type) SetPCCRMR_R1(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0x30000000)|value<<28)
}
func (o *LMEM_Type) GetPCCRMR_R1() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0x30000000) >> 28
}
func (o *LMEM_Type) SetPCCRMR_R0(value uint32) {
	volatile.StoreUint32(&o.PCCRMR.Reg, volatile.LoadUint32(&o.PCCRMR.Reg)&^(0xc0000000)|value<<30)
}
func (o *LMEM_Type) GetPCCRMR_R0() uint32 {
	return (volatile.LoadUint32(&o.PCCRMR.Reg) & 0xc0000000) >> 30
}

// Constants for FTFE_FlashConfig: Flash configuration field
const (
	// BACKKEY3: Backdoor Comparison Key 3.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY3_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY3_KEY_Msk = 0xff

	// BACKKEY2: Backdoor Comparison Key 2.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY2_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY2_KEY_Msk = 0xff

	// BACKKEY1: Backdoor Comparison Key 1.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY1_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY1_KEY_Msk = 0xff

	// BACKKEY0: Backdoor Comparison Key 0.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY0_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY0_KEY_Msk = 0xff

	// BACKKEY7: Backdoor Comparison Key 7.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY7_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY7_KEY_Msk = 0xff

	// BACKKEY6: Backdoor Comparison Key 6.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY6_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY6_KEY_Msk = 0xff

	// BACKKEY5: Backdoor Comparison Key 5.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY5_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY5_KEY_Msk = 0xff

	// BACKKEY4: Backdoor Comparison Key 4.
	// Position of KEY field.
	FTFE_FlashConfig_BACKKEY4_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FTFE_FlashConfig_BACKKEY4_KEY_Msk = 0xff

	// FPROT3: Non-volatile P-Flash Protection 1 - Low Register
	// Position of PROT field.
	FTFE_FlashConfig_FPROT3_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FlashConfig_FPROT3_PROT_Msk = 0xff

	// FPROT2: Non-volatile P-Flash Protection 1 - High Register
	// Position of PROT field.
	FTFE_FlashConfig_FPROT2_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FlashConfig_FPROT2_PROT_Msk = 0xff

	// FPROT1: Non-volatile P-Flash Protection 0 - Low Register
	// Position of PROT field.
	FTFE_FlashConfig_FPROT1_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FlashConfig_FPROT1_PROT_Msk = 0xff

	// FPROT0: Non-volatile P-Flash Protection 0 - High Register
	// Position of PROT field.
	FTFE_FlashConfig_FPROT0_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FlashConfig_FPROT0_PROT_Msk = 0xff

	// FSEC: Non-volatile Flash Security Register
	// Position of SEC field.
	FTFE_FlashConfig_FSEC_SEC_Pos = 0x0
	// Bit mask of SEC field.
	FTFE_FlashConfig_FSEC_SEC_Msk = 0x3
	// MCU security status is unsecure
	FTFE_FlashConfig_FSEC_SEC_10 = 0x2
	// MCU security status is secure
	FTFE_FlashConfig_FSEC_SEC_11 = 0x3
	// Position of FSLACC field.
	FTFE_FlashConfig_FSEC_FSLACC_Pos = 0x2
	// Bit mask of FSLACC field.
	FTFE_FlashConfig_FSEC_FSLACC_Msk = 0xc
	// Freescale factory access denied
	FTFE_FlashConfig_FSEC_FSLACC_10 = 0x2
	// Freescale factory access granted
	FTFE_FlashConfig_FSEC_FSLACC_11 = 0x3
	// Position of MEEN field.
	FTFE_FlashConfig_FSEC_MEEN_Pos = 0x4
	// Bit mask of MEEN field.
	FTFE_FlashConfig_FSEC_MEEN_Msk = 0x30
	// Mass erase is disabled
	FTFE_FlashConfig_FSEC_MEEN_10 = 0x2
	// Mass erase is enabled
	FTFE_FlashConfig_FSEC_MEEN_11 = 0x3
	// Position of KEYEN field.
	FTFE_FlashConfig_FSEC_KEYEN_Pos = 0x6
	// Bit mask of KEYEN field.
	FTFE_FlashConfig_FSEC_KEYEN_Msk = 0xc0
	// Backdoor key access enabled
	FTFE_FlashConfig_FSEC_KEYEN_10 = 0x2
	// Backdoor key access disabled
	FTFE_FlashConfig_FSEC_KEYEN_11 = 0x3

	// FOPT: Non-volatile Flash Option Register
	// Position of LPBOOT field.
	FTFE_FlashConfig_FOPT_LPBOOT_Pos = 0x0
	// Bit mask of LPBOOT field.
	FTFE_FlashConfig_FOPT_LPBOOT_Msk = 0x1
	// Bit LPBOOT.
	FTFE_FlashConfig_FOPT_LPBOOT = 0x1
	// Low-power boot
	FTFE_FlashConfig_FOPT_LPBOOT_00 = 0x0
	// Normal boot
	FTFE_FlashConfig_FOPT_LPBOOT_01 = 0x1
	// Position of EZPORT_DIS field.
	FTFE_FlashConfig_FOPT_EZPORT_DIS_Pos = 0x1
	// Bit mask of EZPORT_DIS field.
	FTFE_FlashConfig_FOPT_EZPORT_DIS_Msk = 0x2
	// Bit EZPORT_DIS.
	FTFE_FlashConfig_FOPT_EZPORT_DIS = 0x2
	// EzPort operation is disabled
	FTFE_FlashConfig_FOPT_EZPORT_DIS_00 = 0x0
	// EzPort operation is enabled
	FTFE_FlashConfig_FOPT_EZPORT_DIS_01 = 0x1
	// Position of NMI_DIS field.
	FTFE_FlashConfig_FOPT_NMI_DIS_Pos = 0x2
	// Bit mask of NMI_DIS field.
	FTFE_FlashConfig_FOPT_NMI_DIS_Msk = 0x4
	// Bit NMI_DIS.
	FTFE_FlashConfig_FOPT_NMI_DIS = 0x4
	// NMI interrupts are always blocked
	FTFE_FlashConfig_FOPT_NMI_DIS_00 = 0x0
	// NMI_b pin/interrupts reset default to enabled
	FTFE_FlashConfig_FOPT_NMI_DIS_01 = 0x1

	// FEPROT: Non-volatile EERAM Protection Register
	// Position of EPROT field.
	FTFE_FlashConfig_FEPROT_EPROT_Pos = 0x0
	// Bit mask of EPROT field.
	FTFE_FlashConfig_FEPROT_EPROT_Msk = 0xff

	// FDPROT: Non-volatile D-Flash Protection Register
	// Position of DPROT field.
	FTFE_FlashConfig_FDPROT_DPROT_Pos = 0x0
	// Bit mask of DPROT field.
	FTFE_FlashConfig_FDPROT_DPROT_Msk = 0xff
)

// Constants for AIPS0: AIPS-Lite Bridge
const (
	// MPRA: Master Privilege Register A
	// Position of MPL6 field.
	AIPS_MPRA_MPL6_Pos = 0x4
	// Bit mask of MPL6 field.
	AIPS_MPRA_MPL6_Msk = 0x10
	// Bit MPL6.
	AIPS_MPRA_MPL6 = 0x10
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL6_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL6_1 = 0x1
	// Position of MTW6 field.
	AIPS_MPRA_MTW6_Pos = 0x5
	// Bit mask of MTW6 field.
	AIPS_MPRA_MTW6_Msk = 0x20
	// Bit MTW6.
	AIPS_MPRA_MTW6 = 0x20
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW6_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW6_1 = 0x1
	// Position of MTR6 field.
	AIPS_MPRA_MTR6_Pos = 0x6
	// Bit mask of MTR6 field.
	AIPS_MPRA_MTR6_Msk = 0x40
	// Bit MTR6.
	AIPS_MPRA_MTR6 = 0x40
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR6_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR6_1 = 0x1
	// Position of MPL5 field.
	AIPS_MPRA_MPL5_Pos = 0x8
	// Bit mask of MPL5 field.
	AIPS_MPRA_MPL5_Msk = 0x100
	// Bit MPL5.
	AIPS_MPRA_MPL5 = 0x100
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL5_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL5_1 = 0x1
	// Position of MTW5 field.
	AIPS_MPRA_MTW5_Pos = 0x9
	// Bit mask of MTW5 field.
	AIPS_MPRA_MTW5_Msk = 0x200
	// Bit MTW5.
	AIPS_MPRA_MTW5 = 0x200
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW5_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW5_1 = 0x1
	// Position of MTR5 field.
	AIPS_MPRA_MTR5_Pos = 0xa
	// Bit mask of MTR5 field.
	AIPS_MPRA_MTR5_Msk = 0x400
	// Bit MTR5.
	AIPS_MPRA_MTR5 = 0x400
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR5_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR5_1 = 0x1
	// Position of MPL4 field.
	AIPS_MPRA_MPL4_Pos = 0xc
	// Bit mask of MPL4 field.
	AIPS_MPRA_MPL4_Msk = 0x1000
	// Bit MPL4.
	AIPS_MPRA_MPL4 = 0x1000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL4_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL4_1 = 0x1
	// Position of MTW4 field.
	AIPS_MPRA_MTW4_Pos = 0xd
	// Bit mask of MTW4 field.
	AIPS_MPRA_MTW4_Msk = 0x2000
	// Bit MTW4.
	AIPS_MPRA_MTW4 = 0x2000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW4_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW4_1 = 0x1
	// Position of MTR4 field.
	AIPS_MPRA_MTR4_Pos = 0xe
	// Bit mask of MTR4 field.
	AIPS_MPRA_MTR4_Msk = 0x4000
	// Bit MTR4.
	AIPS_MPRA_MTR4 = 0x4000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR4_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR4_1 = 0x1
	// Position of MPL3 field.
	AIPS_MPRA_MPL3_Pos = 0x10
	// Bit mask of MPL3 field.
	AIPS_MPRA_MPL3_Msk = 0x10000
	// Bit MPL3.
	AIPS_MPRA_MPL3 = 0x10000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL3_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL3_1 = 0x1
	// Position of MTW3 field.
	AIPS_MPRA_MTW3_Pos = 0x11
	// Bit mask of MTW3 field.
	AIPS_MPRA_MTW3_Msk = 0x20000
	// Bit MTW3.
	AIPS_MPRA_MTW3 = 0x20000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW3_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW3_1 = 0x1
	// Position of MTR3 field.
	AIPS_MPRA_MTR3_Pos = 0x12
	// Bit mask of MTR3 field.
	AIPS_MPRA_MTR3_Msk = 0x40000
	// Bit MTR3.
	AIPS_MPRA_MTR3 = 0x40000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR3_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR3_1 = 0x1
	// Position of MPL2 field.
	AIPS_MPRA_MPL2_Pos = 0x14
	// Bit mask of MPL2 field.
	AIPS_MPRA_MPL2_Msk = 0x100000
	// Bit MPL2.
	AIPS_MPRA_MPL2 = 0x100000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL2_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL2_1 = 0x1
	// Position of MTW2 field.
	AIPS_MPRA_MTW2_Pos = 0x15
	// Bit mask of MTW2 field.
	AIPS_MPRA_MTW2_Msk = 0x200000
	// Bit MTW2.
	AIPS_MPRA_MTW2 = 0x200000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW2_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW2_1 = 0x1
	// Position of MTR2 field.
	AIPS_MPRA_MTR2_Pos = 0x16
	// Bit mask of MTR2 field.
	AIPS_MPRA_MTR2_Msk = 0x400000
	// Bit MTR2.
	AIPS_MPRA_MTR2 = 0x400000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR2_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR2_1 = 0x1
	// Position of MPL1 field.
	AIPS_MPRA_MPL1_Pos = 0x18
	// Bit mask of MPL1 field.
	AIPS_MPRA_MPL1_Msk = 0x1000000
	// Bit MPL1.
	AIPS_MPRA_MPL1 = 0x1000000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL1_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL1_1 = 0x1
	// Position of MTW1 field.
	AIPS_MPRA_MTW1_Pos = 0x19
	// Bit mask of MTW1 field.
	AIPS_MPRA_MTW1_Msk = 0x2000000
	// Bit MTW1.
	AIPS_MPRA_MTW1 = 0x2000000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW1_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW1_1 = 0x1
	// Position of MTR1 field.
	AIPS_MPRA_MTR1_Pos = 0x1a
	// Bit mask of MTR1 field.
	AIPS_MPRA_MTR1_Msk = 0x4000000
	// Bit MTR1.
	AIPS_MPRA_MTR1 = 0x4000000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR1_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR1_1 = 0x1
	// Position of MPL0 field.
	AIPS_MPRA_MPL0_Pos = 0x1c
	// Bit mask of MPL0 field.
	AIPS_MPRA_MPL0_Msk = 0x10000000
	// Bit MPL0.
	AIPS_MPRA_MPL0 = 0x10000000
	// Accesses from this master are forced to user-mode.
	AIPS_MPRA_MPL0_0 = 0x0
	// Accesses from this master are not forced to user-mode.
	AIPS_MPRA_MPL0_1 = 0x1
	// Position of MTW0 field.
	AIPS_MPRA_MTW0_Pos = 0x1d
	// Bit mask of MTW0 field.
	AIPS_MPRA_MTW0_Msk = 0x20000000
	// Bit MTW0.
	AIPS_MPRA_MTW0 = 0x20000000
	// This master is not trusted for write accesses.
	AIPS_MPRA_MTW0_0 = 0x0
	// This master is trusted for write accesses.
	AIPS_MPRA_MTW0_1 = 0x1
	// Position of MTR0 field.
	AIPS_MPRA_MTR0_Pos = 0x1e
	// Bit mask of MTR0 field.
	AIPS_MPRA_MTR0_Msk = 0x40000000
	// Bit MTR0.
	AIPS_MPRA_MTR0 = 0x40000000
	// This master is not trusted for read accesses.
	AIPS_MPRA_MTR0_0 = 0x0
	// This master is trusted for read accesses.
	AIPS_MPRA_MTR0_1 = 0x1

	// PACRA: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRA_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRA_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRA_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRA_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRA_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRA_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRA_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRA_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRA_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRA_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRA_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRA_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRA_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRA_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRA_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRA_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRA_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRA_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRA_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRA_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRA_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRA_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRA_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRA_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRA_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRA_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRA_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRA_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRA_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRA_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRA_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRA_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRA_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRA_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRA_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRA_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRA_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRA_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRA_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRA_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRA_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRA_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRA_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRA_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRA_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRA_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRA_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRA_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRA_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRA_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRA_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRA_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRA_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRA_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRA_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRA_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRA_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRA_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRA_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRA_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRA_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRA_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRA_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRA_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRA_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRA_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRA_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRA_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRA_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRA_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRA_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRA_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRA_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRA_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRA_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRA_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRA_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRA_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRA_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRA_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRA_SP0_1 = 0x1

	// PACRB: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRB_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRB_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRB_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRB_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRB_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRB_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRB_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRB_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRB_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRB_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRB_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRB_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRB_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRB_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRB_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRB_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRB_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRB_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRB_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRB_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRB_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRB_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRB_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRB_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRB_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRB_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRB_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRB_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRB_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRB_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRB_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRB_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRB_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRB_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRB_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRB_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRB_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRB_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRB_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRB_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRB_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRB_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRB_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRB_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRB_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRB_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRB_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRB_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRB_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRB_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRB_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRB_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRB_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRB_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRB_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRB_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRB_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRB_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRB_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRB_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRB_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRB_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRB_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRB_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRB_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRB_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRB_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRB_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRB_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRB_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRB_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRB_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRB_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRB_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRB_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRB_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRB_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRB_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRB_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRB_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRB_SP0_1 = 0x1

	// PACRC: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRC_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRC_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRC_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRC_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRC_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRC_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRC_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRC_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRC_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRC_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRC_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRC_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRC_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRC_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRC_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRC_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRC_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRC_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRC_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRC_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRC_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRC_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRC_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRC_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRC_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRC_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRC_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRC_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRC_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRC_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRC_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRC_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRC_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRC_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRC_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRC_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRC_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRC_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRC_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRC_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRC_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRC_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRC_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRC_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRC_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRC_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRC_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRC_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRC_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRC_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRC_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRC_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRC_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRC_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRC_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRC_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRC_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRC_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRC_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRC_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRC_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRC_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRC_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRC_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRC_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRC_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRC_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRC_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRC_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRC_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRC_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRC_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRC_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRC_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRC_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRC_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRC_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRC_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRC_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRC_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRC_SP0_1 = 0x1

	// PACRD: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRD_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRD_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRD_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRD_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRD_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRD_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRD_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRD_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRD_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRD_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRD_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRD_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRD_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRD_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRD_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRD_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRD_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRD_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRD_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRD_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRD_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRD_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRD_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRD_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRD_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRD_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRD_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRD_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRD_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRD_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRD_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRD_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRD_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRD_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRD_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRD_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRD_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRD_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRD_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRD_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRD_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRD_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRD_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRD_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRD_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRD_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRD_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRD_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRD_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRD_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRD_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRD_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRD_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRD_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRD_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRD_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRD_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRD_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRD_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRD_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRD_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRD_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRD_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRD_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRD_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRD_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRD_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRD_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRD_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRD_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRD_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRD_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRD_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRD_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRD_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRD_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRD_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRD_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRD_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRD_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRD_SP0_1 = 0x1

	// PACRE: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRE_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRE_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRE_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRE_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRE_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRE_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRE_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRE_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRE_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRE_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRE_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRE_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRE_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRE_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRE_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRE_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRE_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRE_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRE_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRE_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRE_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRE_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRE_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRE_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRE_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRE_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRE_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRE_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRE_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRE_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRE_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRE_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRE_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRE_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRE_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRE_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRE_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRE_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRE_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRE_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRE_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRE_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRE_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRE_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRE_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRE_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRE_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRE_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRE_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRE_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRE_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRE_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRE_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRE_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRE_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRE_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRE_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRE_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRE_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRE_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRE_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRE_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRE_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRE_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRE_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRE_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRE_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRE_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRE_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRE_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRE_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRE_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRE_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRE_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRE_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRE_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRE_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRE_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRE_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRE_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRE_SP0_1 = 0x1

	// PACRF: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRF_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRF_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRF_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRF_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRF_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRF_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRF_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRF_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRF_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRF_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRF_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRF_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRF_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRF_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRF_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRF_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRF_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRF_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRF_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRF_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRF_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRF_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRF_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRF_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRF_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRF_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRF_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRF_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRF_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRF_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRF_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRF_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRF_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRF_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRF_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRF_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRF_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRF_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRF_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRF_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRF_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRF_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRF_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRF_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRF_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRF_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRF_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRF_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRF_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRF_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRF_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRF_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRF_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRF_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRF_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRF_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRF_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRF_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRF_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRF_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRF_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRF_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRF_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRF_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRF_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRF_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRF_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRF_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRF_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRF_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRF_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRF_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRF_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRF_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRF_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRF_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRF_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRF_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRF_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRF_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRF_SP0_1 = 0x1

	// PACRG: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRG_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRG_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRG_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRG_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRG_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRG_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRG_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRG_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRG_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRG_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRG_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRG_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRG_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRG_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRG_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRG_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRG_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRG_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRG_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRG_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRG_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRG_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRG_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRG_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRG_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRG_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRG_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRG_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRG_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRG_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRG_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRG_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRG_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRG_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRG_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRG_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRG_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRG_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRG_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRG_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRG_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRG_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRG_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRG_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRG_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRG_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRG_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRG_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRG_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRG_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRG_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRG_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRG_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRG_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRG_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRG_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRG_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRG_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRG_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRG_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRG_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRG_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRG_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRG_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRG_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRG_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRG_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRG_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRG_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRG_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRG_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRG_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRG_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRG_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRG_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRG_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRG_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRG_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRG_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRG_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRG_SP0_1 = 0x1

	// PACRH: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRH_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRH_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRH_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRH_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRH_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRH_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRH_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRH_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRH_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRH_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRH_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRH_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRH_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRH_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRH_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRH_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRH_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRH_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRH_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRH_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRH_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRH_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRH_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRH_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRH_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRH_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRH_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRH_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRH_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRH_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRH_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRH_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRH_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRH_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRH_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRH_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRH_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRH_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRH_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRH_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRH_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRH_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRH_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRH_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRH_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRH_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRH_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRH_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRH_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRH_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRH_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRH_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRH_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRH_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRH_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRH_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRH_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRH_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRH_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRH_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRH_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRH_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRH_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRH_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRH_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRH_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRH_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRH_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRH_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRH_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRH_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRH_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRH_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRH_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRH_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRH_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRH_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRH_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRH_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRH_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRH_SP0_1 = 0x1

	// PACRI: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRI_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRI_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRI_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRI_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRI_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRI_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRI_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRI_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRI_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRI_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRI_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRI_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRI_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRI_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRI_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRI_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRI_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRI_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRI_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRI_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRI_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRI_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRI_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRI_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRI_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRI_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRI_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRI_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRI_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRI_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRI_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRI_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRI_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRI_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRI_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRI_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRI_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRI_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRI_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRI_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRI_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRI_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRI_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRI_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRI_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRI_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRI_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRI_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRI_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRI_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRI_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRI_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRI_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRI_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRI_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRI_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRI_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRI_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRI_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRI_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRI_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRI_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRI_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRI_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRI_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRI_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRI_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRI_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRI_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRI_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRI_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRI_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRI_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRI_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRI_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRI_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRI_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRI_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRI_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRI_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRI_SP0_1 = 0x1

	// PACRJ: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRJ_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRJ_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRJ_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRJ_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRJ_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRJ_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRJ_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRJ_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRJ_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRJ_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRJ_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRJ_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRJ_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRJ_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRJ_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRJ_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRJ_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRJ_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRJ_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRJ_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRJ_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRJ_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRJ_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRJ_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRJ_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRJ_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRJ_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRJ_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRJ_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRJ_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRJ_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRJ_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRJ_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRJ_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRJ_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRJ_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRJ_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRJ_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRJ_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRJ_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRJ_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRJ_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRJ_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRJ_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRJ_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRJ_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRJ_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRJ_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRJ_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRJ_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRJ_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRJ_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRJ_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRJ_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRJ_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRJ_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRJ_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRJ_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRJ_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRJ_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRJ_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRJ_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRJ_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRJ_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRJ_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRJ_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRJ_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRJ_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRJ_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRJ_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRJ_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRJ_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRJ_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRJ_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRJ_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRJ_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRJ_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRJ_SP0_1 = 0x1

	// PACRK: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRK_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRK_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRK_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRK_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRK_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRK_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRK_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRK_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRK_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRK_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRK_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRK_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRK_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRK_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRK_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRK_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRK_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRK_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRK_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRK_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRK_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRK_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRK_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRK_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRK_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRK_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRK_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRK_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRK_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRK_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRK_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRK_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRK_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRK_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRK_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRK_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRK_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRK_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRK_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRK_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRK_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRK_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRK_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRK_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRK_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRK_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRK_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRK_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRK_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRK_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRK_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRK_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRK_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRK_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRK_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRK_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRK_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRK_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRK_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRK_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRK_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRK_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRK_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRK_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRK_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRK_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRK_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRK_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRK_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRK_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRK_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRK_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRK_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRK_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRK_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRK_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRK_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRK_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRK_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRK_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRK_SP0_1 = 0x1

	// PACRL: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRL_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRL_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRL_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRL_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRL_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRL_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRL_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRL_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRL_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRL_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRL_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRL_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRL_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRL_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRL_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRL_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRL_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRL_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRL_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRL_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRL_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRL_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRL_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRL_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRL_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRL_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRL_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRL_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRL_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRL_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRL_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRL_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRL_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRL_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRL_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRL_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRL_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRL_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRL_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRL_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRL_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRL_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRL_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRL_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRL_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRL_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRL_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRL_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRL_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRL_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRL_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRL_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRL_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRL_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRL_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRL_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRL_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRL_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRL_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRL_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRL_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRL_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRL_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRL_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRL_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRL_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRL_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRL_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRL_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRL_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRL_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRL_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRL_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRL_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRL_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRL_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRL_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRL_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRL_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRL_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRL_SP0_1 = 0x1

	// PACRM: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRM_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRM_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRM_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRM_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRM_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRM_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRM_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRM_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRM_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRM_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRM_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRM_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRM_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRM_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRM_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRM_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRM_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRM_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRM_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRM_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRM_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRM_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRM_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRM_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRM_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRM_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRM_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRM_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRM_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRM_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRM_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRM_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRM_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRM_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRM_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRM_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRM_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRM_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRM_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRM_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRM_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRM_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRM_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRM_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRM_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRM_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRM_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRM_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRM_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRM_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRM_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRM_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRM_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRM_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRM_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRM_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRM_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRM_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRM_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRM_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRM_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRM_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRM_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRM_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRM_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRM_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRM_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRM_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRM_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRM_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRM_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRM_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRM_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRM_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRM_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRM_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRM_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRM_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRM_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRM_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRM_SP0_1 = 0x1

	// PACRN: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRN_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRN_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRN_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRN_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRN_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRN_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRN_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRN_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRN_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRN_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRN_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRN_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRN_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRN_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRN_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRN_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRN_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRN_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRN_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRN_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRN_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRN_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRN_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRN_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRN_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRN_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRN_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRN_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRN_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRN_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRN_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRN_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRN_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRN_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRN_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRN_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRN_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRN_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRN_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRN_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRN_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRN_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRN_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRN_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRN_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRN_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRN_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRN_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRN_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRN_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRN_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRN_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRN_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRN_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRN_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRN_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRN_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRN_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRN_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRN_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRN_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRN_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRN_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRN_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRN_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRN_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRN_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRN_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRN_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRN_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRN_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRN_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRN_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRN_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRN_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRN_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRN_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRN_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRN_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRN_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRN_SP0_1 = 0x1

	// PACRO: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRO_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRO_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRO_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRO_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRO_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRO_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRO_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRO_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRO_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRO_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRO_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRO_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRO_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRO_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRO_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRO_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRO_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRO_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRO_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRO_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRO_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRO_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRO_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRO_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRO_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRO_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRO_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRO_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRO_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRO_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRO_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRO_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRO_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRO_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRO_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRO_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRO_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRO_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRO_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRO_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRO_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRO_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRO_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRO_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRO_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRO_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRO_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRO_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRO_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRO_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRO_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRO_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRO_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRO_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRO_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRO_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRO_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRO_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRO_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRO_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRO_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRO_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRO_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRO_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRO_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRO_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRO_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRO_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRO_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRO_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRO_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRO_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRO_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRO_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRO_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRO_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRO_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRO_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRO_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRO_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRO_SP0_1 = 0x1

	// PACRP: Peripheral Access Control Register
	// Position of TP7 field.
	AIPS_PACRP_TP7_Pos = 0x0
	// Bit mask of TP7 field.
	AIPS_PACRP_TP7_Msk = 0x1
	// Bit TP7.
	AIPS_PACRP_TP7 = 0x1
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP7_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP7_1 = 0x1
	// Position of WP7 field.
	AIPS_PACRP_WP7_Pos = 0x1
	// Bit mask of WP7 field.
	AIPS_PACRP_WP7_Msk = 0x2
	// Bit WP7.
	AIPS_PACRP_WP7 = 0x2
	// This peripheral allows write accesses.
	AIPS_PACRP_WP7_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP7_1 = 0x1
	// Position of SP7 field.
	AIPS_PACRP_SP7_Pos = 0x2
	// Bit mask of SP7 field.
	AIPS_PACRP_SP7_Msk = 0x4
	// Bit SP7.
	AIPS_PACRP_SP7 = 0x4
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP7_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP7_1 = 0x1
	// Position of TP6 field.
	AIPS_PACRP_TP6_Pos = 0x4
	// Bit mask of TP6 field.
	AIPS_PACRP_TP6_Msk = 0x10
	// Bit TP6.
	AIPS_PACRP_TP6 = 0x10
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP6_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP6_1 = 0x1
	// Position of WP6 field.
	AIPS_PACRP_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	AIPS_PACRP_WP6_Msk = 0x20
	// Bit WP6.
	AIPS_PACRP_WP6 = 0x20
	// This peripheral allows write accesses.
	AIPS_PACRP_WP6_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP6_1 = 0x1
	// Position of SP6 field.
	AIPS_PACRP_SP6_Pos = 0x6
	// Bit mask of SP6 field.
	AIPS_PACRP_SP6_Msk = 0x40
	// Bit SP6.
	AIPS_PACRP_SP6 = 0x40
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP6_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP6_1 = 0x1
	// Position of TP5 field.
	AIPS_PACRP_TP5_Pos = 0x8
	// Bit mask of TP5 field.
	AIPS_PACRP_TP5_Msk = 0x100
	// Bit TP5.
	AIPS_PACRP_TP5 = 0x100
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP5_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP5_1 = 0x1
	// Position of WP5 field.
	AIPS_PACRP_WP5_Pos = 0x9
	// Bit mask of WP5 field.
	AIPS_PACRP_WP5_Msk = 0x200
	// Bit WP5.
	AIPS_PACRP_WP5 = 0x200
	// This peripheral allows write accesses.
	AIPS_PACRP_WP5_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP5_1 = 0x1
	// Position of SP5 field.
	AIPS_PACRP_SP5_Pos = 0xa
	// Bit mask of SP5 field.
	AIPS_PACRP_SP5_Msk = 0x400
	// Bit SP5.
	AIPS_PACRP_SP5 = 0x400
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP5_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP5_1 = 0x1
	// Position of TP4 field.
	AIPS_PACRP_TP4_Pos = 0xc
	// Bit mask of TP4 field.
	AIPS_PACRP_TP4_Msk = 0x1000
	// Bit TP4.
	AIPS_PACRP_TP4 = 0x1000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP4_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP4_1 = 0x1
	// Position of WP4 field.
	AIPS_PACRP_WP4_Pos = 0xd
	// Bit mask of WP4 field.
	AIPS_PACRP_WP4_Msk = 0x2000
	// Bit WP4.
	AIPS_PACRP_WP4 = 0x2000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP4_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP4_1 = 0x1
	// Position of SP4 field.
	AIPS_PACRP_SP4_Pos = 0xe
	// Bit mask of SP4 field.
	AIPS_PACRP_SP4_Msk = 0x4000
	// Bit SP4.
	AIPS_PACRP_SP4 = 0x4000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP4_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP4_1 = 0x1
	// Position of TP3 field.
	AIPS_PACRP_TP3_Pos = 0x10
	// Bit mask of TP3 field.
	AIPS_PACRP_TP3_Msk = 0x10000
	// Bit TP3.
	AIPS_PACRP_TP3 = 0x10000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP3_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP3_1 = 0x1
	// Position of WP3 field.
	AIPS_PACRP_WP3_Pos = 0x11
	// Bit mask of WP3 field.
	AIPS_PACRP_WP3_Msk = 0x20000
	// Bit WP3.
	AIPS_PACRP_WP3 = 0x20000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP3_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP3_1 = 0x1
	// Position of SP3 field.
	AIPS_PACRP_SP3_Pos = 0x12
	// Bit mask of SP3 field.
	AIPS_PACRP_SP3_Msk = 0x40000
	// Bit SP3.
	AIPS_PACRP_SP3 = 0x40000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP3_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP3_1 = 0x1
	// Position of TP2 field.
	AIPS_PACRP_TP2_Pos = 0x14
	// Bit mask of TP2 field.
	AIPS_PACRP_TP2_Msk = 0x100000
	// Bit TP2.
	AIPS_PACRP_TP2 = 0x100000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP2_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP2_1 = 0x1
	// Position of WP2 field.
	AIPS_PACRP_WP2_Pos = 0x15
	// Bit mask of WP2 field.
	AIPS_PACRP_WP2_Msk = 0x200000
	// Bit WP2.
	AIPS_PACRP_WP2 = 0x200000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP2_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP2_1 = 0x1
	// Position of SP2 field.
	AIPS_PACRP_SP2_Pos = 0x16
	// Bit mask of SP2 field.
	AIPS_PACRP_SP2_Msk = 0x400000
	// Bit SP2.
	AIPS_PACRP_SP2 = 0x400000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP2_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP2_1 = 0x1
	// Position of TP1 field.
	AIPS_PACRP_TP1_Pos = 0x18
	// Bit mask of TP1 field.
	AIPS_PACRP_TP1_Msk = 0x1000000
	// Bit TP1.
	AIPS_PACRP_TP1 = 0x1000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP1_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP1_1 = 0x1
	// Position of WP1 field.
	AIPS_PACRP_WP1_Pos = 0x19
	// Bit mask of WP1 field.
	AIPS_PACRP_WP1_Msk = 0x2000000
	// Bit WP1.
	AIPS_PACRP_WP1 = 0x2000000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP1_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP1_1 = 0x1
	// Position of SP1 field.
	AIPS_PACRP_SP1_Pos = 0x1a
	// Bit mask of SP1 field.
	AIPS_PACRP_SP1_Msk = 0x4000000
	// Bit SP1.
	AIPS_PACRP_SP1 = 0x4000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP1_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP1_1 = 0x1
	// Position of TP0 field.
	AIPS_PACRP_TP0_Pos = 0x1c
	// Bit mask of TP0 field.
	AIPS_PACRP_TP0_Msk = 0x10000000
	// Bit TP0.
	AIPS_PACRP_TP0 = 0x10000000
	// Accesses from an untrusted master are allowed.
	AIPS_PACRP_TP0_0 = 0x0
	// Accesses from an untrusted master are not allowed.
	AIPS_PACRP_TP0_1 = 0x1
	// Position of WP0 field.
	AIPS_PACRP_WP0_Pos = 0x1d
	// Bit mask of WP0 field.
	AIPS_PACRP_WP0_Msk = 0x20000000
	// Bit WP0.
	AIPS_PACRP_WP0 = 0x20000000
	// This peripheral allows write accesses.
	AIPS_PACRP_WP0_0 = 0x0
	// This peripheral is write protected.
	AIPS_PACRP_WP0_1 = 0x1
	// Position of SP0 field.
	AIPS_PACRP_SP0_Pos = 0x1e
	// Bit mask of SP0 field.
	AIPS_PACRP_SP0_Msk = 0x40000000
	// Bit SP0.
	AIPS_PACRP_SP0 = 0x40000000
	// This peripheral does not require supervisor privilege level for accesses.
	AIPS_PACRP_SP0_0 = 0x0
	// This peripheral requires supervisor privilege level for accesses.
	AIPS_PACRP_SP0_1 = 0x1
)

// Constants for AXBS: Crossbar switch
const (
	// PRS0: Priority Registers Slave
	// Position of M0 field.
	AXBS_PRS_M0_Pos = 0x0
	// Bit mask of M0 field.
	AXBS_PRS_M0_Msk = 0x7
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M0_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M0_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M0_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M0_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M0_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M0_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M0_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M0_111 = 0x7
	// Position of M1 field.
	AXBS_PRS_M1_Pos = 0x4
	// Bit mask of M1 field.
	AXBS_PRS_M1_Msk = 0x70
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M1_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M1_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M1_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M1_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M1_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M1_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M1_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M1_111 = 0x7
	// Position of M2 field.
	AXBS_PRS_M2_Pos = 0x8
	// Bit mask of M2 field.
	AXBS_PRS_M2_Msk = 0x700
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M2_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M2_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M2_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M2_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M2_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M2_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M2_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M2_111 = 0x7
	// Position of M3 field.
	AXBS_PRS_M3_Pos = 0xc
	// Bit mask of M3 field.
	AXBS_PRS_M3_Msk = 0x7000
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M3_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M3_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M3_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M3_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M3_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M3_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M3_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M3_111 = 0x7
	// Position of M4 field.
	AXBS_PRS_M4_Pos = 0x10
	// Bit mask of M4 field.
	AXBS_PRS_M4_Msk = 0x70000
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M4_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M4_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M4_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M4_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M4_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M4_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M4_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M4_111 = 0x7
	// Position of M5 field.
	AXBS_PRS_M5_Pos = 0x14
	// Bit mask of M5 field.
	AXBS_PRS_M5_Msk = 0x700000
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M5_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M5_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M5_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M5_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M5_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M5_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M5_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M5_111 = 0x7
	// Position of M6 field.
	AXBS_PRS_M6_Pos = 0x18
	// Bit mask of M6 field.
	AXBS_PRS_M6_Msk = 0x7000000
	// This master has level 1, or highest, priority when accessing the slave port.
	AXBS_PRS_M6_000 = 0x0
	// This master has level 2 priority when accessing the slave port.
	AXBS_PRS_M6_001 = 0x1
	// This master has level 3 priority when accessing the slave port.
	AXBS_PRS_M6_010 = 0x2
	// This master has level 4 priority when accessing the slave port.
	AXBS_PRS_M6_011 = 0x3
	// This master has level 5 priority when accessing the slave port.
	AXBS_PRS_M6_100 = 0x4
	// This master has level 6 priority when accessing the slave port.
	AXBS_PRS_M6_101 = 0x5
	// This master has level 7 priority when accessing the slave port.
	AXBS_PRS_M6_110 = 0x6
	// This master has level 8, or lowest, priority when accessing the slave port.
	AXBS_PRS_M6_111 = 0x7

	// CRS0: Control Register
	// Position of PARK field.
	AXBS_CRS_PARK_Pos = 0x0
	// Bit mask of PARK field.
	AXBS_CRS_PARK_Msk = 0x7
	// Park on master port M0
	AXBS_CRS_PARK_000 = 0x0
	// Park on master port M1
	AXBS_CRS_PARK_001 = 0x1
	// Park on master port M2
	AXBS_CRS_PARK_010 = 0x2
	// Park on master port M3
	AXBS_CRS_PARK_011 = 0x3
	// Park on master port M4
	AXBS_CRS_PARK_100 = 0x4
	// Park on master port M5
	AXBS_CRS_PARK_101 = 0x5
	// Park on master port M6
	AXBS_CRS_PARK_110 = 0x6
	// Park on master port M7
	AXBS_CRS_PARK_111 = 0x7
	// Position of PCTL field.
	AXBS_CRS_PCTL_Pos = 0x4
	// Bit mask of PCTL field.
	AXBS_CRS_PCTL_Msk = 0x30
	// When no master makes a request, the arbiter parks the slave port on the master port defined by the PARK field
	AXBS_CRS_PCTL_00 = 0x0
	// When no master makes a request, the arbiter parks the slave port on the last master to be in control of the slave port
	AXBS_CRS_PCTL_01 = 0x1
	// When no master makes a request, the slave port is not parked on a master and the arbiter drives all outputs to a constant safe state
	AXBS_CRS_PCTL_10 = 0x2
	// Position of ARB field.
	AXBS_CRS_ARB_Pos = 0x8
	// Bit mask of ARB field.
	AXBS_CRS_ARB_Msk = 0x300
	// Fixed priority
	AXBS_CRS_ARB_00 = 0x0
	// Round-robin, or rotating, priority
	AXBS_CRS_ARB_01 = 0x1
	// Position of HLP field.
	AXBS_CRS_HLP_Pos = 0x1e
	// Bit mask of HLP field.
	AXBS_CRS_HLP_Msk = 0x40000000
	// Bit HLP.
	AXBS_CRS_HLP = 0x40000000
	// The low power mode request has the highest priority for arbitration on this slave port
	AXBS_CRS_HLP_0 = 0x0
	// The low power mode request has the lowest initial priority for arbitration on this slave port
	AXBS_CRS_HLP_1 = 0x1
	// Position of RO field.
	AXBS_CRS_RO_Pos = 0x1f
	// Bit mask of RO field.
	AXBS_CRS_RO_Msk = 0x80000000
	// Bit RO.
	AXBS_CRS_RO = 0x80000000
	// The slave port's registers are writeable
	AXBS_CRS_RO_0 = 0x0
	// The slave port's registers are read-only and cannot be written. Attempted writes have no effect on the registers and result in a bus error response.
	AXBS_CRS_RO_1 = 0x1

	// MGPCR0: Master General Purpose Control Register
	// Position of AULB field.
	AXBS_MGPCR_AULB_Pos = 0x0
	// Bit mask of AULB field.
	AXBS_MGPCR_AULB_Msk = 0x7
	// No arbitration is allowed during an undefined length burst
	AXBS_MGPCR_AULB_000 = 0x0
	// Arbitration is allowed at any time during an undefined length burst
	AXBS_MGPCR_AULB_001 = 0x1
	// Arbitration is allowed after four beats of an undefined length burst
	AXBS_MGPCR_AULB_010 = 0x2
	// Arbitration is allowed after eight beats of an undefined length burst
	AXBS_MGPCR_AULB_011 = 0x3
	// Arbitration is allowed after 16 beats of an undefined length burst
	AXBS_MGPCR_AULB_100 = 0x4
)

// Constants for DMA: Enhanced direct memory access controller
const (
	// CR: Control Register
	// Position of EDBG field.
	DMA_CR_EDBG_Pos = 0x1
	// Bit mask of EDBG field.
	DMA_CR_EDBG_Msk = 0x2
	// Bit EDBG.
	DMA_CR_EDBG = 0x2
	// When in debug mode, the DMA continues to operate.
	DMA_CR_EDBG_0 = 0x0
	// When in debug mode, the DMA stalls the start of a new channel. Executing channels are allowed to complete. Channel execution resumes when the system exits debug mode or the EDBG bit is cleared.
	DMA_CR_EDBG_1 = 0x1
	// Position of ERCA field.
	DMA_CR_ERCA_Pos = 0x2
	// Bit mask of ERCA field.
	DMA_CR_ERCA_Msk = 0x4
	// Bit ERCA.
	DMA_CR_ERCA = 0x4
	// Fixed priority arbitration is used for channel selection within each group.
	DMA_CR_ERCA_0 = 0x0
	// Round robin arbitration is used for channel selection within each group.
	DMA_CR_ERCA_1 = 0x1
	// Position of ERGA field.
	DMA_CR_ERGA_Pos = 0x3
	// Bit mask of ERGA field.
	DMA_CR_ERGA_Msk = 0x8
	// Bit ERGA.
	DMA_CR_ERGA = 0x8
	// Fixed priority arbitration is used for selection among the groups.
	DMA_CR_ERGA_0 = 0x0
	// Round robin arbitration is used for selection among the groups.
	DMA_CR_ERGA_1 = 0x1
	// Position of HOE field.
	DMA_CR_HOE_Pos = 0x4
	// Bit mask of HOE field.
	DMA_CR_HOE_Msk = 0x10
	// Bit HOE.
	DMA_CR_HOE = 0x10
	// Normal operation
	DMA_CR_HOE_0 = 0x0
	// Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit is cleared.
	DMA_CR_HOE_1 = 0x1
	// Position of HALT field.
	DMA_CR_HALT_Pos = 0x5
	// Bit mask of HALT field.
	DMA_CR_HALT_Msk = 0x20
	// Bit HALT.
	DMA_CR_HALT = 0x20
	// Normal operation
	DMA_CR_HALT_0 = 0x0
	// Stall the start of any new channels. Executing channels are allowed to complete. Channel execution resumes when this bit is cleared.
	DMA_CR_HALT_1 = 0x1
	// Position of CLM field.
	DMA_CR_CLM_Pos = 0x6
	// Bit mask of CLM field.
	DMA_CR_CLM_Msk = 0x40
	// Bit CLM.
	DMA_CR_CLM = 0x40
	// A minor loop channel link made to itself goes through channel arbitration before being activated again.
	DMA_CR_CLM_0 = 0x0
	// A minor loop channel link made to itself does not go through channel arbitration before being activated again. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself. This effectively applies the minor loop offsets and restarts the next minor loop.
	DMA_CR_CLM_1 = 0x1
	// Position of EMLM field.
	DMA_CR_EMLM_Pos = 0x7
	// Bit mask of EMLM field.
	DMA_CR_EMLM_Msk = 0x80
	// Bit EMLM.
	DMA_CR_EMLM = 0x80
	// Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
	DMA_CR_EMLM_0 = 0x0
	// Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the NBYTES field. The individual enable fields allow the minor loop offset to be applied to the source address, the destination address, or both. The NBYTES field is reduced when either offset is enabled.
	DMA_CR_EMLM_1 = 0x1
	// Position of GRP0PRI field.
	DMA_CR_GRP0PRI_Pos = 0x8
	// Bit mask of GRP0PRI field.
	DMA_CR_GRP0PRI_Msk = 0x100
	// Bit GRP0PRI.
	DMA_CR_GRP0PRI = 0x100
	// Position of GRP1PRI field.
	DMA_CR_GRP1PRI_Pos = 0xa
	// Bit mask of GRP1PRI field.
	DMA_CR_GRP1PRI_Msk = 0x400
	// Bit GRP1PRI.
	DMA_CR_GRP1PRI = 0x400
	// Position of ECX field.
	DMA_CR_ECX_Pos = 0x10
	// Bit mask of ECX field.
	DMA_CR_ECX_Msk = 0x10000
	// Bit ECX.
	DMA_CR_ECX = 0x10000
	// Normal operation
	DMA_CR_ECX_0 = 0x0
	// Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to cancelling the transfer, ECX treats the cancel as an error condition, thus updating the Error Status register (DMAx_ES) and generating an optional error interrupt.
	DMA_CR_ECX_1 = 0x1
	// Position of CX field.
	DMA_CR_CX_Pos = 0x11
	// Bit mask of CX field.
	DMA_CR_CX_Msk = 0x20000
	// Bit CX.
	DMA_CR_CX = 0x20000
	// Normal operation
	DMA_CR_CX_0 = 0x0
	// Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The CX bit clears itself after the cancel has been honored. This cancel retires the channel normally as if the minor loop was completed.
	DMA_CR_CX_1 = 0x1

	// ES: Error Status Register
	// Position of DBE field.
	DMA_ES_DBE_Pos = 0x0
	// Bit mask of DBE field.
	DMA_ES_DBE_Msk = 0x1
	// Bit DBE.
	DMA_ES_DBE = 0x1
	// No destination bus error
	DMA_ES_DBE_0 = 0x0
	// The last recorded error was a bus error on a destination write
	DMA_ES_DBE_1 = 0x1
	// Position of SBE field.
	DMA_ES_SBE_Pos = 0x1
	// Bit mask of SBE field.
	DMA_ES_SBE_Msk = 0x2
	// Bit SBE.
	DMA_ES_SBE = 0x2
	// No source bus error
	DMA_ES_SBE_0 = 0x0
	// The last recorded error was a bus error on a source read
	DMA_ES_SBE_1 = 0x1
	// Position of SGE field.
	DMA_ES_SGE_Pos = 0x2
	// Bit mask of SGE field.
	DMA_ES_SGE_Msk = 0x4
	// Bit SGE.
	DMA_ES_SGE = 0x4
	// No scatter/gather configuration error
	DMA_ES_SGE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.
	DMA_ES_SGE_1 = 0x1
	// Position of NCE field.
	DMA_ES_NCE_Pos = 0x3
	// Bit mask of NCE field.
	DMA_ES_NCE_Msk = 0x8
	// Bit NCE.
	DMA_ES_NCE = 0x8
	// No NBYTES/CITER configuration error
	DMA_ES_NCE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
	DMA_ES_NCE_1 = 0x1
	// Position of DOE field.
	DMA_ES_DOE_Pos = 0x4
	// Bit mask of DOE field.
	DMA_ES_DOE_Msk = 0x10
	// Bit DOE.
	DMA_ES_DOE = 0x10
	// No destination offset configuration error
	DMA_ES_DOE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
	DMA_ES_DOE_1 = 0x1
	// Position of DAE field.
	DMA_ES_DAE_Pos = 0x5
	// Bit mask of DAE field.
	DMA_ES_DAE_Msk = 0x20
	// Bit DAE.
	DMA_ES_DAE = 0x20
	// No destination address configuration error
	DMA_ES_DAE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
	DMA_ES_DAE_1 = 0x1
	// Position of SOE field.
	DMA_ES_SOE_Pos = 0x6
	// Bit mask of SOE field.
	DMA_ES_SOE_Msk = 0x40
	// Bit SOE.
	DMA_ES_SOE = 0x40
	// No source offset configuration error
	DMA_ES_SOE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
	DMA_ES_SOE_1 = 0x1
	// Position of SAE field.
	DMA_ES_SAE_Pos = 0x7
	// Bit mask of SAE field.
	DMA_ES_SAE_Msk = 0x80
	// Bit SAE.
	DMA_ES_SAE = 0x80
	// No source address configuration error.
	DMA_ES_SAE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
	DMA_ES_SAE_1 = 0x1
	// Position of ERRCHN field.
	DMA_ES_ERRCHN_Pos = 0x8
	// Bit mask of ERRCHN field.
	DMA_ES_ERRCHN_Msk = 0x1f00
	// Position of CPE field.
	DMA_ES_CPE_Pos = 0xe
	// Bit mask of CPE field.
	DMA_ES_CPE_Msk = 0x4000
	// Bit CPE.
	DMA_ES_CPE = 0x4000
	// No channel priority error
	DMA_ES_CPE_0 = 0x0
	// The last recorded error was a configuration error in the channel priorities within a group. Channel priorities within a group are not unique.
	DMA_ES_CPE_1 = 0x1
	// Position of GPE field.
	DMA_ES_GPE_Pos = 0xf
	// Bit mask of GPE field.
	DMA_ES_GPE_Msk = 0x8000
	// Bit GPE.
	DMA_ES_GPE = 0x8000
	// No group priority error
	DMA_ES_GPE_0 = 0x0
	// The last recorded error was a configuration error among the group priorities. All group priorities are not unique.
	DMA_ES_GPE_1 = 0x1
	// Position of ECX field.
	DMA_ES_ECX_Pos = 0x10
	// Bit mask of ECX field.
	DMA_ES_ECX_Msk = 0x10000
	// Bit ECX.
	DMA_ES_ECX = 0x10000
	// No canceled transfers
	DMA_ES_ECX_0 = 0x0
	// The last recorded entry was a canceled transfer by the error cancel transfer input
	DMA_ES_ECX_1 = 0x1
	// Position of VLD field.
	DMA_ES_VLD_Pos = 0x1f
	// Bit mask of VLD field.
	DMA_ES_VLD_Msk = 0x80000000
	// Bit VLD.
	DMA_ES_VLD = 0x80000000
	// No ERR bits are set.
	DMA_ES_VLD_0 = 0x0
	// At least one ERR bit is set indicating a valid error exists that has not been cleared.
	DMA_ES_VLD_1 = 0x1

	// ERQ: Enable Request Register
	// Position of ERQ0 field.
	DMA_ERQ_ERQ0_Pos = 0x0
	// Bit mask of ERQ0 field.
	DMA_ERQ_ERQ0_Msk = 0x1
	// Bit ERQ0.
	DMA_ERQ_ERQ0 = 0x1
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ0_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ0_1 = 0x1
	// Position of ERQ1 field.
	DMA_ERQ_ERQ1_Pos = 0x1
	// Bit mask of ERQ1 field.
	DMA_ERQ_ERQ1_Msk = 0x2
	// Bit ERQ1.
	DMA_ERQ_ERQ1 = 0x2
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ1_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ1_1 = 0x1
	// Position of ERQ2 field.
	DMA_ERQ_ERQ2_Pos = 0x2
	// Bit mask of ERQ2 field.
	DMA_ERQ_ERQ2_Msk = 0x4
	// Bit ERQ2.
	DMA_ERQ_ERQ2 = 0x4
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ2_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ2_1 = 0x1
	// Position of ERQ3 field.
	DMA_ERQ_ERQ3_Pos = 0x3
	// Bit mask of ERQ3 field.
	DMA_ERQ_ERQ3_Msk = 0x8
	// Bit ERQ3.
	DMA_ERQ_ERQ3 = 0x8
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ3_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ3_1 = 0x1
	// Position of ERQ4 field.
	DMA_ERQ_ERQ4_Pos = 0x4
	// Bit mask of ERQ4 field.
	DMA_ERQ_ERQ4_Msk = 0x10
	// Bit ERQ4.
	DMA_ERQ_ERQ4 = 0x10
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ4_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ4_1 = 0x1
	// Position of ERQ5 field.
	DMA_ERQ_ERQ5_Pos = 0x5
	// Bit mask of ERQ5 field.
	DMA_ERQ_ERQ5_Msk = 0x20
	// Bit ERQ5.
	DMA_ERQ_ERQ5 = 0x20
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ5_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ5_1 = 0x1
	// Position of ERQ6 field.
	DMA_ERQ_ERQ6_Pos = 0x6
	// Bit mask of ERQ6 field.
	DMA_ERQ_ERQ6_Msk = 0x40
	// Bit ERQ6.
	DMA_ERQ_ERQ6 = 0x40
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ6_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ6_1 = 0x1
	// Position of ERQ7 field.
	DMA_ERQ_ERQ7_Pos = 0x7
	// Bit mask of ERQ7 field.
	DMA_ERQ_ERQ7_Msk = 0x80
	// Bit ERQ7.
	DMA_ERQ_ERQ7 = 0x80
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ7_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ7_1 = 0x1
	// Position of ERQ8 field.
	DMA_ERQ_ERQ8_Pos = 0x8
	// Bit mask of ERQ8 field.
	DMA_ERQ_ERQ8_Msk = 0x100
	// Bit ERQ8.
	DMA_ERQ_ERQ8 = 0x100
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ8_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ8_1 = 0x1
	// Position of ERQ9 field.
	DMA_ERQ_ERQ9_Pos = 0x9
	// Bit mask of ERQ9 field.
	DMA_ERQ_ERQ9_Msk = 0x200
	// Bit ERQ9.
	DMA_ERQ_ERQ9 = 0x200
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ9_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ9_1 = 0x1
	// Position of ERQ10 field.
	DMA_ERQ_ERQ10_Pos = 0xa
	// Bit mask of ERQ10 field.
	DMA_ERQ_ERQ10_Msk = 0x400
	// Bit ERQ10.
	DMA_ERQ_ERQ10 = 0x400
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ10_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ10_1 = 0x1
	// Position of ERQ11 field.
	DMA_ERQ_ERQ11_Pos = 0xb
	// Bit mask of ERQ11 field.
	DMA_ERQ_ERQ11_Msk = 0x800
	// Bit ERQ11.
	DMA_ERQ_ERQ11 = 0x800
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ11_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ11_1 = 0x1
	// Position of ERQ12 field.
	DMA_ERQ_ERQ12_Pos = 0xc
	// Bit mask of ERQ12 field.
	DMA_ERQ_ERQ12_Msk = 0x1000
	// Bit ERQ12.
	DMA_ERQ_ERQ12 = 0x1000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ12_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ12_1 = 0x1
	// Position of ERQ13 field.
	DMA_ERQ_ERQ13_Pos = 0xd
	// Bit mask of ERQ13 field.
	DMA_ERQ_ERQ13_Msk = 0x2000
	// Bit ERQ13.
	DMA_ERQ_ERQ13 = 0x2000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ13_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ13_1 = 0x1
	// Position of ERQ14 field.
	DMA_ERQ_ERQ14_Pos = 0xe
	// Bit mask of ERQ14 field.
	DMA_ERQ_ERQ14_Msk = 0x4000
	// Bit ERQ14.
	DMA_ERQ_ERQ14 = 0x4000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ14_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ14_1 = 0x1
	// Position of ERQ15 field.
	DMA_ERQ_ERQ15_Pos = 0xf
	// Bit mask of ERQ15 field.
	DMA_ERQ_ERQ15_Msk = 0x8000
	// Bit ERQ15.
	DMA_ERQ_ERQ15 = 0x8000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ15_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ15_1 = 0x1
	// Position of ERQ16 field.
	DMA_ERQ_ERQ16_Pos = 0x10
	// Bit mask of ERQ16 field.
	DMA_ERQ_ERQ16_Msk = 0x10000
	// Bit ERQ16.
	DMA_ERQ_ERQ16 = 0x10000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ16_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ16_1 = 0x1
	// Position of ERQ17 field.
	DMA_ERQ_ERQ17_Pos = 0x11
	// Bit mask of ERQ17 field.
	DMA_ERQ_ERQ17_Msk = 0x20000
	// Bit ERQ17.
	DMA_ERQ_ERQ17 = 0x20000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ17_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ17_1 = 0x1
	// Position of ERQ18 field.
	DMA_ERQ_ERQ18_Pos = 0x12
	// Bit mask of ERQ18 field.
	DMA_ERQ_ERQ18_Msk = 0x40000
	// Bit ERQ18.
	DMA_ERQ_ERQ18 = 0x40000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ18_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ18_1 = 0x1
	// Position of ERQ19 field.
	DMA_ERQ_ERQ19_Pos = 0x13
	// Bit mask of ERQ19 field.
	DMA_ERQ_ERQ19_Msk = 0x80000
	// Bit ERQ19.
	DMA_ERQ_ERQ19 = 0x80000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ19_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ19_1 = 0x1
	// Position of ERQ20 field.
	DMA_ERQ_ERQ20_Pos = 0x14
	// Bit mask of ERQ20 field.
	DMA_ERQ_ERQ20_Msk = 0x100000
	// Bit ERQ20.
	DMA_ERQ_ERQ20 = 0x100000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ20_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ20_1 = 0x1
	// Position of ERQ21 field.
	DMA_ERQ_ERQ21_Pos = 0x15
	// Bit mask of ERQ21 field.
	DMA_ERQ_ERQ21_Msk = 0x200000
	// Bit ERQ21.
	DMA_ERQ_ERQ21 = 0x200000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ21_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ21_1 = 0x1
	// Position of ERQ22 field.
	DMA_ERQ_ERQ22_Pos = 0x16
	// Bit mask of ERQ22 field.
	DMA_ERQ_ERQ22_Msk = 0x400000
	// Bit ERQ22.
	DMA_ERQ_ERQ22 = 0x400000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ22_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ22_1 = 0x1
	// Position of ERQ23 field.
	DMA_ERQ_ERQ23_Pos = 0x17
	// Bit mask of ERQ23 field.
	DMA_ERQ_ERQ23_Msk = 0x800000
	// Bit ERQ23.
	DMA_ERQ_ERQ23 = 0x800000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ23_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ23_1 = 0x1
	// Position of ERQ24 field.
	DMA_ERQ_ERQ24_Pos = 0x18
	// Bit mask of ERQ24 field.
	DMA_ERQ_ERQ24_Msk = 0x1000000
	// Bit ERQ24.
	DMA_ERQ_ERQ24 = 0x1000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ24_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ24_1 = 0x1
	// Position of ERQ25 field.
	DMA_ERQ_ERQ25_Pos = 0x19
	// Bit mask of ERQ25 field.
	DMA_ERQ_ERQ25_Msk = 0x2000000
	// Bit ERQ25.
	DMA_ERQ_ERQ25 = 0x2000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ25_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ25_1 = 0x1
	// Position of ERQ26 field.
	DMA_ERQ_ERQ26_Pos = 0x1a
	// Bit mask of ERQ26 field.
	DMA_ERQ_ERQ26_Msk = 0x4000000
	// Bit ERQ26.
	DMA_ERQ_ERQ26 = 0x4000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ26_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ26_1 = 0x1
	// Position of ERQ27 field.
	DMA_ERQ_ERQ27_Pos = 0x1b
	// Bit mask of ERQ27 field.
	DMA_ERQ_ERQ27_Msk = 0x8000000
	// Bit ERQ27.
	DMA_ERQ_ERQ27 = 0x8000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ27_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ27_1 = 0x1
	// Position of ERQ28 field.
	DMA_ERQ_ERQ28_Pos = 0x1c
	// Bit mask of ERQ28 field.
	DMA_ERQ_ERQ28_Msk = 0x10000000
	// Bit ERQ28.
	DMA_ERQ_ERQ28 = 0x10000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ28_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ28_1 = 0x1
	// Position of ERQ29 field.
	DMA_ERQ_ERQ29_Pos = 0x1d
	// Bit mask of ERQ29 field.
	DMA_ERQ_ERQ29_Msk = 0x20000000
	// Bit ERQ29.
	DMA_ERQ_ERQ29 = 0x20000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ29_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ29_1 = 0x1
	// Position of ERQ30 field.
	DMA_ERQ_ERQ30_Pos = 0x1e
	// Bit mask of ERQ30 field.
	DMA_ERQ_ERQ30_Msk = 0x40000000
	// Bit ERQ30.
	DMA_ERQ_ERQ30 = 0x40000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ30_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ30_1 = 0x1
	// Position of ERQ31 field.
	DMA_ERQ_ERQ31_Pos = 0x1f
	// Bit mask of ERQ31 field.
	DMA_ERQ_ERQ31_Msk = 0x80000000
	// Bit ERQ31.
	DMA_ERQ_ERQ31 = 0x80000000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ31_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ31_1 = 0x1

	// EEI: Enable Error Interrupt Register
	// Position of EEI0 field.
	DMA_EEI_EEI0_Pos = 0x0
	// Bit mask of EEI0 field.
	DMA_EEI_EEI0_Msk = 0x1
	// Bit EEI0.
	DMA_EEI_EEI0 = 0x1
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI0_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI0_1 = 0x1
	// Position of EEI1 field.
	DMA_EEI_EEI1_Pos = 0x1
	// Bit mask of EEI1 field.
	DMA_EEI_EEI1_Msk = 0x2
	// Bit EEI1.
	DMA_EEI_EEI1 = 0x2
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI1_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI1_1 = 0x1
	// Position of EEI2 field.
	DMA_EEI_EEI2_Pos = 0x2
	// Bit mask of EEI2 field.
	DMA_EEI_EEI2_Msk = 0x4
	// Bit EEI2.
	DMA_EEI_EEI2 = 0x4
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI2_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI2_1 = 0x1
	// Position of EEI3 field.
	DMA_EEI_EEI3_Pos = 0x3
	// Bit mask of EEI3 field.
	DMA_EEI_EEI3_Msk = 0x8
	// Bit EEI3.
	DMA_EEI_EEI3 = 0x8
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI3_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI3_1 = 0x1
	// Position of EEI4 field.
	DMA_EEI_EEI4_Pos = 0x4
	// Bit mask of EEI4 field.
	DMA_EEI_EEI4_Msk = 0x10
	// Bit EEI4.
	DMA_EEI_EEI4 = 0x10
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI4_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI4_1 = 0x1
	// Position of EEI5 field.
	DMA_EEI_EEI5_Pos = 0x5
	// Bit mask of EEI5 field.
	DMA_EEI_EEI5_Msk = 0x20
	// Bit EEI5.
	DMA_EEI_EEI5 = 0x20
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI5_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI5_1 = 0x1
	// Position of EEI6 field.
	DMA_EEI_EEI6_Pos = 0x6
	// Bit mask of EEI6 field.
	DMA_EEI_EEI6_Msk = 0x40
	// Bit EEI6.
	DMA_EEI_EEI6 = 0x40
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI6_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI6_1 = 0x1
	// Position of EEI7 field.
	DMA_EEI_EEI7_Pos = 0x7
	// Bit mask of EEI7 field.
	DMA_EEI_EEI7_Msk = 0x80
	// Bit EEI7.
	DMA_EEI_EEI7 = 0x80
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI7_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI7_1 = 0x1
	// Position of EEI8 field.
	DMA_EEI_EEI8_Pos = 0x8
	// Bit mask of EEI8 field.
	DMA_EEI_EEI8_Msk = 0x100
	// Bit EEI8.
	DMA_EEI_EEI8 = 0x100
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI8_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI8_1 = 0x1
	// Position of EEI9 field.
	DMA_EEI_EEI9_Pos = 0x9
	// Bit mask of EEI9 field.
	DMA_EEI_EEI9_Msk = 0x200
	// Bit EEI9.
	DMA_EEI_EEI9 = 0x200
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI9_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI9_1 = 0x1
	// Position of EEI10 field.
	DMA_EEI_EEI10_Pos = 0xa
	// Bit mask of EEI10 field.
	DMA_EEI_EEI10_Msk = 0x400
	// Bit EEI10.
	DMA_EEI_EEI10 = 0x400
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI10_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI10_1 = 0x1
	// Position of EEI11 field.
	DMA_EEI_EEI11_Pos = 0xb
	// Bit mask of EEI11 field.
	DMA_EEI_EEI11_Msk = 0x800
	// Bit EEI11.
	DMA_EEI_EEI11 = 0x800
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI11_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI11_1 = 0x1
	// Position of EEI12 field.
	DMA_EEI_EEI12_Pos = 0xc
	// Bit mask of EEI12 field.
	DMA_EEI_EEI12_Msk = 0x1000
	// Bit EEI12.
	DMA_EEI_EEI12 = 0x1000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI12_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI12_1 = 0x1
	// Position of EEI13 field.
	DMA_EEI_EEI13_Pos = 0xd
	// Bit mask of EEI13 field.
	DMA_EEI_EEI13_Msk = 0x2000
	// Bit EEI13.
	DMA_EEI_EEI13 = 0x2000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI13_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI13_1 = 0x1
	// Position of EEI14 field.
	DMA_EEI_EEI14_Pos = 0xe
	// Bit mask of EEI14 field.
	DMA_EEI_EEI14_Msk = 0x4000
	// Bit EEI14.
	DMA_EEI_EEI14 = 0x4000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI14_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI14_1 = 0x1
	// Position of EEI15 field.
	DMA_EEI_EEI15_Pos = 0xf
	// Bit mask of EEI15 field.
	DMA_EEI_EEI15_Msk = 0x8000
	// Bit EEI15.
	DMA_EEI_EEI15 = 0x8000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI15_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI15_1 = 0x1
	// Position of EEI16 field.
	DMA_EEI_EEI16_Pos = 0x10
	// Bit mask of EEI16 field.
	DMA_EEI_EEI16_Msk = 0x10000
	// Bit EEI16.
	DMA_EEI_EEI16 = 0x10000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI16_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI16_1 = 0x1
	// Position of EEI17 field.
	DMA_EEI_EEI17_Pos = 0x11
	// Bit mask of EEI17 field.
	DMA_EEI_EEI17_Msk = 0x20000
	// Bit EEI17.
	DMA_EEI_EEI17 = 0x20000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI17_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI17_1 = 0x1
	// Position of EEI18 field.
	DMA_EEI_EEI18_Pos = 0x12
	// Bit mask of EEI18 field.
	DMA_EEI_EEI18_Msk = 0x40000
	// Bit EEI18.
	DMA_EEI_EEI18 = 0x40000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI18_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI18_1 = 0x1
	// Position of EEI19 field.
	DMA_EEI_EEI19_Pos = 0x13
	// Bit mask of EEI19 field.
	DMA_EEI_EEI19_Msk = 0x80000
	// Bit EEI19.
	DMA_EEI_EEI19 = 0x80000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI19_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI19_1 = 0x1
	// Position of EEI20 field.
	DMA_EEI_EEI20_Pos = 0x14
	// Bit mask of EEI20 field.
	DMA_EEI_EEI20_Msk = 0x100000
	// Bit EEI20.
	DMA_EEI_EEI20 = 0x100000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI20_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI20_1 = 0x1
	// Position of EEI21 field.
	DMA_EEI_EEI21_Pos = 0x15
	// Bit mask of EEI21 field.
	DMA_EEI_EEI21_Msk = 0x200000
	// Bit EEI21.
	DMA_EEI_EEI21 = 0x200000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI21_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI21_1 = 0x1
	// Position of EEI22 field.
	DMA_EEI_EEI22_Pos = 0x16
	// Bit mask of EEI22 field.
	DMA_EEI_EEI22_Msk = 0x400000
	// Bit EEI22.
	DMA_EEI_EEI22 = 0x400000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI22_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI22_1 = 0x1
	// Position of EEI23 field.
	DMA_EEI_EEI23_Pos = 0x17
	// Bit mask of EEI23 field.
	DMA_EEI_EEI23_Msk = 0x800000
	// Bit EEI23.
	DMA_EEI_EEI23 = 0x800000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI23_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI23_1 = 0x1
	// Position of EEI24 field.
	DMA_EEI_EEI24_Pos = 0x18
	// Bit mask of EEI24 field.
	DMA_EEI_EEI24_Msk = 0x1000000
	// Bit EEI24.
	DMA_EEI_EEI24 = 0x1000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI24_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI24_1 = 0x1
	// Position of EEI25 field.
	DMA_EEI_EEI25_Pos = 0x19
	// Bit mask of EEI25 field.
	DMA_EEI_EEI25_Msk = 0x2000000
	// Bit EEI25.
	DMA_EEI_EEI25 = 0x2000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI25_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI25_1 = 0x1
	// Position of EEI26 field.
	DMA_EEI_EEI26_Pos = 0x1a
	// Bit mask of EEI26 field.
	DMA_EEI_EEI26_Msk = 0x4000000
	// Bit EEI26.
	DMA_EEI_EEI26 = 0x4000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI26_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI26_1 = 0x1
	// Position of EEI27 field.
	DMA_EEI_EEI27_Pos = 0x1b
	// Bit mask of EEI27 field.
	DMA_EEI_EEI27_Msk = 0x8000000
	// Bit EEI27.
	DMA_EEI_EEI27 = 0x8000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI27_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI27_1 = 0x1
	// Position of EEI28 field.
	DMA_EEI_EEI28_Pos = 0x1c
	// Bit mask of EEI28 field.
	DMA_EEI_EEI28_Msk = 0x10000000
	// Bit EEI28.
	DMA_EEI_EEI28 = 0x10000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI28_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI28_1 = 0x1
	// Position of EEI29 field.
	DMA_EEI_EEI29_Pos = 0x1d
	// Bit mask of EEI29 field.
	DMA_EEI_EEI29_Msk = 0x20000000
	// Bit EEI29.
	DMA_EEI_EEI29 = 0x20000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI29_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI29_1 = 0x1
	// Position of EEI30 field.
	DMA_EEI_EEI30_Pos = 0x1e
	// Bit mask of EEI30 field.
	DMA_EEI_EEI30_Msk = 0x40000000
	// Bit EEI30.
	DMA_EEI_EEI30 = 0x40000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI30_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI30_1 = 0x1
	// Position of EEI31 field.
	DMA_EEI_EEI31_Pos = 0x1f
	// Bit mask of EEI31 field.
	DMA_EEI_EEI31_Msk = 0x80000000
	// Bit EEI31.
	DMA_EEI_EEI31 = 0x80000000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI31_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI31_1 = 0x1

	// CEEI: Clear Enable Error Interrupt Register
	// Position of CEEI field.
	DMA_CEEI_CEEI_Pos = 0x0
	// Bit mask of CEEI field.
	DMA_CEEI_CEEI_Msk = 0x1f
	// Position of CAEE field.
	DMA_CEEI_CAEE_Pos = 0x6
	// Bit mask of CAEE field.
	DMA_CEEI_CAEE_Msk = 0x40
	// Bit CAEE.
	DMA_CEEI_CAEE = 0x40
	// Clear only the EEI bit specified in the CEEI field
	DMA_CEEI_CAEE_0 = 0x0
	// Clear all bits in EEI
	DMA_CEEI_CAEE_1 = 0x1
	// Position of NOP field.
	DMA_CEEI_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CEEI_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CEEI_NOP = 0x80
	// Normal operation
	DMA_CEEI_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CEEI_NOP_1 = 0x1

	// SEEI: Set Enable Error Interrupt Register
	// Position of SEEI field.
	DMA_SEEI_SEEI_Pos = 0x0
	// Bit mask of SEEI field.
	DMA_SEEI_SEEI_Msk = 0x1f
	// Position of SAEE field.
	DMA_SEEI_SAEE_Pos = 0x6
	// Bit mask of SAEE field.
	DMA_SEEI_SAEE_Msk = 0x40
	// Bit SAEE.
	DMA_SEEI_SAEE = 0x40
	// Set only the EEI bit specified in the SEEI field.
	DMA_SEEI_SAEE_0 = 0x0
	// Sets all bits in EEI
	DMA_SEEI_SAEE_1 = 0x1
	// Position of NOP field.
	DMA_SEEI_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SEEI_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SEEI_NOP = 0x80
	// Normal operation
	DMA_SEEI_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SEEI_NOP_1 = 0x1

	// CERQ: Clear Enable Request Register
	// Position of CERQ field.
	DMA_CERQ_CERQ_Pos = 0x0
	// Bit mask of CERQ field.
	DMA_CERQ_CERQ_Msk = 0x1f
	// Position of CAER field.
	DMA_CERQ_CAER_Pos = 0x6
	// Bit mask of CAER field.
	DMA_CERQ_CAER_Msk = 0x40
	// Bit CAER.
	DMA_CERQ_CAER = 0x40
	// Clear only the ERQ bit specified in the CERQ field
	DMA_CERQ_CAER_0 = 0x0
	// Clear all bits in ERQ
	DMA_CERQ_CAER_1 = 0x1
	// Position of NOP field.
	DMA_CERQ_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CERQ_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CERQ_NOP = 0x80
	// Normal operation
	DMA_CERQ_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CERQ_NOP_1 = 0x1

	// SERQ: Set Enable Request Register
	// Position of SERQ field.
	DMA_SERQ_SERQ_Pos = 0x0
	// Bit mask of SERQ field.
	DMA_SERQ_SERQ_Msk = 0x1f
	// Position of SAER field.
	DMA_SERQ_SAER_Pos = 0x6
	// Bit mask of SAER field.
	DMA_SERQ_SAER_Msk = 0x40
	// Bit SAER.
	DMA_SERQ_SAER = 0x40
	// Set only the ERQ bit specified in the SERQ field
	DMA_SERQ_SAER_0 = 0x0
	// Set all bits in ERQ
	DMA_SERQ_SAER_1 = 0x1
	// Position of NOP field.
	DMA_SERQ_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SERQ_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SERQ_NOP = 0x80
	// Normal operation
	DMA_SERQ_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SERQ_NOP_1 = 0x1

	// CDNE: Clear DONE Status Bit Register
	// Position of CDNE field.
	DMA_CDNE_CDNE_Pos = 0x0
	// Bit mask of CDNE field.
	DMA_CDNE_CDNE_Msk = 0x1f
	// Position of CADN field.
	DMA_CDNE_CADN_Pos = 0x6
	// Bit mask of CADN field.
	DMA_CDNE_CADN_Msk = 0x40
	// Bit CADN.
	DMA_CDNE_CADN = 0x40
	// Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
	DMA_CDNE_CADN_0 = 0x0
	// Clears all bits in TCDn_CSR[DONE]
	DMA_CDNE_CADN_1 = 0x1
	// Position of NOP field.
	DMA_CDNE_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CDNE_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CDNE_NOP = 0x80
	// Normal operation
	DMA_CDNE_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CDNE_NOP_1 = 0x1

	// SSRT: Set START Bit Register
	// Position of SSRT field.
	DMA_SSRT_SSRT_Pos = 0x0
	// Bit mask of SSRT field.
	DMA_SSRT_SSRT_Msk = 0x1f
	// Position of SAST field.
	DMA_SSRT_SAST_Pos = 0x6
	// Bit mask of SAST field.
	DMA_SSRT_SAST_Msk = 0x40
	// Bit SAST.
	DMA_SSRT_SAST = 0x40
	// Set only the TCDn_CSR[START] bit specified in the SSRT field
	DMA_SSRT_SAST_0 = 0x0
	// Set all bits in TCDn_CSR[START]
	DMA_SSRT_SAST_1 = 0x1
	// Position of NOP field.
	DMA_SSRT_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SSRT_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SSRT_NOP = 0x80
	// Normal operation
	DMA_SSRT_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SSRT_NOP_1 = 0x1

	// CERR: Clear Error Register
	// Position of CERR field.
	DMA_CERR_CERR_Pos = 0x0
	// Bit mask of CERR field.
	DMA_CERR_CERR_Msk = 0x1f
	// Position of CAEI field.
	DMA_CERR_CAEI_Pos = 0x6
	// Bit mask of CAEI field.
	DMA_CERR_CAEI_Msk = 0x40
	// Bit CAEI.
	DMA_CERR_CAEI = 0x40
	// Clear only the ERR bit specified in the CERR field
	DMA_CERR_CAEI_0 = 0x0
	// Clear all bits in ERR
	DMA_CERR_CAEI_1 = 0x1
	// Position of NOP field.
	DMA_CERR_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CERR_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CERR_NOP = 0x80
	// Normal operation
	DMA_CERR_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CERR_NOP_1 = 0x1

	// CINT: Clear Interrupt Request Register
	// Position of CINT field.
	DMA_CINT_CINT_Pos = 0x0
	// Bit mask of CINT field.
	DMA_CINT_CINT_Msk = 0x1f
	// Position of CAIR field.
	DMA_CINT_CAIR_Pos = 0x6
	// Bit mask of CAIR field.
	DMA_CINT_CAIR_Msk = 0x40
	// Bit CAIR.
	DMA_CINT_CAIR = 0x40
	// Clear only the INT bit specified in the CINT field
	DMA_CINT_CAIR_0 = 0x0
	// Clear all bits in INT
	DMA_CINT_CAIR_1 = 0x1
	// Position of NOP field.
	DMA_CINT_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CINT_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CINT_NOP = 0x80
	// Normal operation
	DMA_CINT_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CINT_NOP_1 = 0x1

	// INT: Interrupt Request Register
	// Position of INT0 field.
	DMA_INT_INT0_Pos = 0x0
	// Bit mask of INT0 field.
	DMA_INT_INT0_Msk = 0x1
	// Bit INT0.
	DMA_INT_INT0 = 0x1
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT0_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT0_1 = 0x1
	// Position of INT1 field.
	DMA_INT_INT1_Pos = 0x1
	// Bit mask of INT1 field.
	DMA_INT_INT1_Msk = 0x2
	// Bit INT1.
	DMA_INT_INT1 = 0x2
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT1_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT1_1 = 0x1
	// Position of INT2 field.
	DMA_INT_INT2_Pos = 0x2
	// Bit mask of INT2 field.
	DMA_INT_INT2_Msk = 0x4
	// Bit INT2.
	DMA_INT_INT2 = 0x4
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT2_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT2_1 = 0x1
	// Position of INT3 field.
	DMA_INT_INT3_Pos = 0x3
	// Bit mask of INT3 field.
	DMA_INT_INT3_Msk = 0x8
	// Bit INT3.
	DMA_INT_INT3 = 0x8
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT3_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT3_1 = 0x1
	// Position of INT4 field.
	DMA_INT_INT4_Pos = 0x4
	// Bit mask of INT4 field.
	DMA_INT_INT4_Msk = 0x10
	// Bit INT4.
	DMA_INT_INT4 = 0x10
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT4_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT4_1 = 0x1
	// Position of INT5 field.
	DMA_INT_INT5_Pos = 0x5
	// Bit mask of INT5 field.
	DMA_INT_INT5_Msk = 0x20
	// Bit INT5.
	DMA_INT_INT5 = 0x20
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT5_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT5_1 = 0x1
	// Position of INT6 field.
	DMA_INT_INT6_Pos = 0x6
	// Bit mask of INT6 field.
	DMA_INT_INT6_Msk = 0x40
	// Bit INT6.
	DMA_INT_INT6 = 0x40
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT6_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT6_1 = 0x1
	// Position of INT7 field.
	DMA_INT_INT7_Pos = 0x7
	// Bit mask of INT7 field.
	DMA_INT_INT7_Msk = 0x80
	// Bit INT7.
	DMA_INT_INT7 = 0x80
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT7_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT7_1 = 0x1
	// Position of INT8 field.
	DMA_INT_INT8_Pos = 0x8
	// Bit mask of INT8 field.
	DMA_INT_INT8_Msk = 0x100
	// Bit INT8.
	DMA_INT_INT8 = 0x100
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT8_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT8_1 = 0x1
	// Position of INT9 field.
	DMA_INT_INT9_Pos = 0x9
	// Bit mask of INT9 field.
	DMA_INT_INT9_Msk = 0x200
	// Bit INT9.
	DMA_INT_INT9 = 0x200
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT9_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT9_1 = 0x1
	// Position of INT10 field.
	DMA_INT_INT10_Pos = 0xa
	// Bit mask of INT10 field.
	DMA_INT_INT10_Msk = 0x400
	// Bit INT10.
	DMA_INT_INT10 = 0x400
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT10_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT10_1 = 0x1
	// Position of INT11 field.
	DMA_INT_INT11_Pos = 0xb
	// Bit mask of INT11 field.
	DMA_INT_INT11_Msk = 0x800
	// Bit INT11.
	DMA_INT_INT11 = 0x800
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT11_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT11_1 = 0x1
	// Position of INT12 field.
	DMA_INT_INT12_Pos = 0xc
	// Bit mask of INT12 field.
	DMA_INT_INT12_Msk = 0x1000
	// Bit INT12.
	DMA_INT_INT12 = 0x1000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT12_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT12_1 = 0x1
	// Position of INT13 field.
	DMA_INT_INT13_Pos = 0xd
	// Bit mask of INT13 field.
	DMA_INT_INT13_Msk = 0x2000
	// Bit INT13.
	DMA_INT_INT13 = 0x2000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT13_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT13_1 = 0x1
	// Position of INT14 field.
	DMA_INT_INT14_Pos = 0xe
	// Bit mask of INT14 field.
	DMA_INT_INT14_Msk = 0x4000
	// Bit INT14.
	DMA_INT_INT14 = 0x4000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT14_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT14_1 = 0x1
	// Position of INT15 field.
	DMA_INT_INT15_Pos = 0xf
	// Bit mask of INT15 field.
	DMA_INT_INT15_Msk = 0x8000
	// Bit INT15.
	DMA_INT_INT15 = 0x8000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT15_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT15_1 = 0x1
	// Position of INT16 field.
	DMA_INT_INT16_Pos = 0x10
	// Bit mask of INT16 field.
	DMA_INT_INT16_Msk = 0x10000
	// Bit INT16.
	DMA_INT_INT16 = 0x10000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT16_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT16_1 = 0x1
	// Position of INT17 field.
	DMA_INT_INT17_Pos = 0x11
	// Bit mask of INT17 field.
	DMA_INT_INT17_Msk = 0x20000
	// Bit INT17.
	DMA_INT_INT17 = 0x20000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT17_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT17_1 = 0x1
	// Position of INT18 field.
	DMA_INT_INT18_Pos = 0x12
	// Bit mask of INT18 field.
	DMA_INT_INT18_Msk = 0x40000
	// Bit INT18.
	DMA_INT_INT18 = 0x40000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT18_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT18_1 = 0x1
	// Position of INT19 field.
	DMA_INT_INT19_Pos = 0x13
	// Bit mask of INT19 field.
	DMA_INT_INT19_Msk = 0x80000
	// Bit INT19.
	DMA_INT_INT19 = 0x80000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT19_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT19_1 = 0x1
	// Position of INT20 field.
	DMA_INT_INT20_Pos = 0x14
	// Bit mask of INT20 field.
	DMA_INT_INT20_Msk = 0x100000
	// Bit INT20.
	DMA_INT_INT20 = 0x100000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT20_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT20_1 = 0x1
	// Position of INT21 field.
	DMA_INT_INT21_Pos = 0x15
	// Bit mask of INT21 field.
	DMA_INT_INT21_Msk = 0x200000
	// Bit INT21.
	DMA_INT_INT21 = 0x200000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT21_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT21_1 = 0x1
	// Position of INT22 field.
	DMA_INT_INT22_Pos = 0x16
	// Bit mask of INT22 field.
	DMA_INT_INT22_Msk = 0x400000
	// Bit INT22.
	DMA_INT_INT22 = 0x400000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT22_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT22_1 = 0x1
	// Position of INT23 field.
	DMA_INT_INT23_Pos = 0x17
	// Bit mask of INT23 field.
	DMA_INT_INT23_Msk = 0x800000
	// Bit INT23.
	DMA_INT_INT23 = 0x800000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT23_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT23_1 = 0x1
	// Position of INT24 field.
	DMA_INT_INT24_Pos = 0x18
	// Bit mask of INT24 field.
	DMA_INT_INT24_Msk = 0x1000000
	// Bit INT24.
	DMA_INT_INT24 = 0x1000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT24_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT24_1 = 0x1
	// Position of INT25 field.
	DMA_INT_INT25_Pos = 0x19
	// Bit mask of INT25 field.
	DMA_INT_INT25_Msk = 0x2000000
	// Bit INT25.
	DMA_INT_INT25 = 0x2000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT25_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT25_1 = 0x1
	// Position of INT26 field.
	DMA_INT_INT26_Pos = 0x1a
	// Bit mask of INT26 field.
	DMA_INT_INT26_Msk = 0x4000000
	// Bit INT26.
	DMA_INT_INT26 = 0x4000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT26_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT26_1 = 0x1
	// Position of INT27 field.
	DMA_INT_INT27_Pos = 0x1b
	// Bit mask of INT27 field.
	DMA_INT_INT27_Msk = 0x8000000
	// Bit INT27.
	DMA_INT_INT27 = 0x8000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT27_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT27_1 = 0x1
	// Position of INT28 field.
	DMA_INT_INT28_Pos = 0x1c
	// Bit mask of INT28 field.
	DMA_INT_INT28_Msk = 0x10000000
	// Bit INT28.
	DMA_INT_INT28 = 0x10000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT28_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT28_1 = 0x1
	// Position of INT29 field.
	DMA_INT_INT29_Pos = 0x1d
	// Bit mask of INT29 field.
	DMA_INT_INT29_Msk = 0x20000000
	// Bit INT29.
	DMA_INT_INT29 = 0x20000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT29_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT29_1 = 0x1
	// Position of INT30 field.
	DMA_INT_INT30_Pos = 0x1e
	// Bit mask of INT30 field.
	DMA_INT_INT30_Msk = 0x40000000
	// Bit INT30.
	DMA_INT_INT30 = 0x40000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT30_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT30_1 = 0x1
	// Position of INT31 field.
	DMA_INT_INT31_Pos = 0x1f
	// Bit mask of INT31 field.
	DMA_INT_INT31_Msk = 0x80000000
	// Bit INT31.
	DMA_INT_INT31 = 0x80000000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT31_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT31_1 = 0x1

	// ERR: Error Register
	// Position of ERR0 field.
	DMA_ERR_ERR0_Pos = 0x0
	// Bit mask of ERR0 field.
	DMA_ERR_ERR0_Msk = 0x1
	// Bit ERR0.
	DMA_ERR_ERR0 = 0x1
	// An error in this channel has not occurred
	DMA_ERR_ERR0_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR0_1 = 0x1
	// Position of ERR1 field.
	DMA_ERR_ERR1_Pos = 0x1
	// Bit mask of ERR1 field.
	DMA_ERR_ERR1_Msk = 0x2
	// Bit ERR1.
	DMA_ERR_ERR1 = 0x2
	// An error in this channel has not occurred
	DMA_ERR_ERR1_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR1_1 = 0x1
	// Position of ERR2 field.
	DMA_ERR_ERR2_Pos = 0x2
	// Bit mask of ERR2 field.
	DMA_ERR_ERR2_Msk = 0x4
	// Bit ERR2.
	DMA_ERR_ERR2 = 0x4
	// An error in this channel has not occurred
	DMA_ERR_ERR2_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR2_1 = 0x1
	// Position of ERR3 field.
	DMA_ERR_ERR3_Pos = 0x3
	// Bit mask of ERR3 field.
	DMA_ERR_ERR3_Msk = 0x8
	// Bit ERR3.
	DMA_ERR_ERR3 = 0x8
	// An error in this channel has not occurred
	DMA_ERR_ERR3_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR3_1 = 0x1
	// Position of ERR4 field.
	DMA_ERR_ERR4_Pos = 0x4
	// Bit mask of ERR4 field.
	DMA_ERR_ERR4_Msk = 0x10
	// Bit ERR4.
	DMA_ERR_ERR4 = 0x10
	// An error in this channel has not occurred
	DMA_ERR_ERR4_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR4_1 = 0x1
	// Position of ERR5 field.
	DMA_ERR_ERR5_Pos = 0x5
	// Bit mask of ERR5 field.
	DMA_ERR_ERR5_Msk = 0x20
	// Bit ERR5.
	DMA_ERR_ERR5 = 0x20
	// An error in this channel has not occurred
	DMA_ERR_ERR5_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR5_1 = 0x1
	// Position of ERR6 field.
	DMA_ERR_ERR6_Pos = 0x6
	// Bit mask of ERR6 field.
	DMA_ERR_ERR6_Msk = 0x40
	// Bit ERR6.
	DMA_ERR_ERR6 = 0x40
	// An error in this channel has not occurred
	DMA_ERR_ERR6_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR6_1 = 0x1
	// Position of ERR7 field.
	DMA_ERR_ERR7_Pos = 0x7
	// Bit mask of ERR7 field.
	DMA_ERR_ERR7_Msk = 0x80
	// Bit ERR7.
	DMA_ERR_ERR7 = 0x80
	// An error in this channel has not occurred
	DMA_ERR_ERR7_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR7_1 = 0x1
	// Position of ERR8 field.
	DMA_ERR_ERR8_Pos = 0x8
	// Bit mask of ERR8 field.
	DMA_ERR_ERR8_Msk = 0x100
	// Bit ERR8.
	DMA_ERR_ERR8 = 0x100
	// An error in this channel has not occurred
	DMA_ERR_ERR8_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR8_1 = 0x1
	// Position of ERR9 field.
	DMA_ERR_ERR9_Pos = 0x9
	// Bit mask of ERR9 field.
	DMA_ERR_ERR9_Msk = 0x200
	// Bit ERR9.
	DMA_ERR_ERR9 = 0x200
	// An error in this channel has not occurred
	DMA_ERR_ERR9_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR9_1 = 0x1
	// Position of ERR10 field.
	DMA_ERR_ERR10_Pos = 0xa
	// Bit mask of ERR10 field.
	DMA_ERR_ERR10_Msk = 0x400
	// Bit ERR10.
	DMA_ERR_ERR10 = 0x400
	// An error in this channel has not occurred
	DMA_ERR_ERR10_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR10_1 = 0x1
	// Position of ERR11 field.
	DMA_ERR_ERR11_Pos = 0xb
	// Bit mask of ERR11 field.
	DMA_ERR_ERR11_Msk = 0x800
	// Bit ERR11.
	DMA_ERR_ERR11 = 0x800
	// An error in this channel has not occurred
	DMA_ERR_ERR11_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR11_1 = 0x1
	// Position of ERR12 field.
	DMA_ERR_ERR12_Pos = 0xc
	// Bit mask of ERR12 field.
	DMA_ERR_ERR12_Msk = 0x1000
	// Bit ERR12.
	DMA_ERR_ERR12 = 0x1000
	// An error in this channel has not occurred
	DMA_ERR_ERR12_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR12_1 = 0x1
	// Position of ERR13 field.
	DMA_ERR_ERR13_Pos = 0xd
	// Bit mask of ERR13 field.
	DMA_ERR_ERR13_Msk = 0x2000
	// Bit ERR13.
	DMA_ERR_ERR13 = 0x2000
	// An error in this channel has not occurred
	DMA_ERR_ERR13_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR13_1 = 0x1
	// Position of ERR14 field.
	DMA_ERR_ERR14_Pos = 0xe
	// Bit mask of ERR14 field.
	DMA_ERR_ERR14_Msk = 0x4000
	// Bit ERR14.
	DMA_ERR_ERR14 = 0x4000
	// An error in this channel has not occurred
	DMA_ERR_ERR14_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR14_1 = 0x1
	// Position of ERR15 field.
	DMA_ERR_ERR15_Pos = 0xf
	// Bit mask of ERR15 field.
	DMA_ERR_ERR15_Msk = 0x8000
	// Bit ERR15.
	DMA_ERR_ERR15 = 0x8000
	// An error in this channel has not occurred
	DMA_ERR_ERR15_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR15_1 = 0x1
	// Position of ERR16 field.
	DMA_ERR_ERR16_Pos = 0x10
	// Bit mask of ERR16 field.
	DMA_ERR_ERR16_Msk = 0x10000
	// Bit ERR16.
	DMA_ERR_ERR16 = 0x10000
	// An error in this channel has not occurred
	DMA_ERR_ERR16_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR16_1 = 0x1
	// Position of ERR17 field.
	DMA_ERR_ERR17_Pos = 0x11
	// Bit mask of ERR17 field.
	DMA_ERR_ERR17_Msk = 0x20000
	// Bit ERR17.
	DMA_ERR_ERR17 = 0x20000
	// An error in this channel has not occurred
	DMA_ERR_ERR17_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR17_1 = 0x1
	// Position of ERR18 field.
	DMA_ERR_ERR18_Pos = 0x12
	// Bit mask of ERR18 field.
	DMA_ERR_ERR18_Msk = 0x40000
	// Bit ERR18.
	DMA_ERR_ERR18 = 0x40000
	// An error in this channel has not occurred
	DMA_ERR_ERR18_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR18_1 = 0x1
	// Position of ERR19 field.
	DMA_ERR_ERR19_Pos = 0x13
	// Bit mask of ERR19 field.
	DMA_ERR_ERR19_Msk = 0x80000
	// Bit ERR19.
	DMA_ERR_ERR19 = 0x80000
	// An error in this channel has not occurred
	DMA_ERR_ERR19_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR19_1 = 0x1
	// Position of ERR20 field.
	DMA_ERR_ERR20_Pos = 0x14
	// Bit mask of ERR20 field.
	DMA_ERR_ERR20_Msk = 0x100000
	// Bit ERR20.
	DMA_ERR_ERR20 = 0x100000
	// An error in this channel has not occurred
	DMA_ERR_ERR20_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR20_1 = 0x1
	// Position of ERR21 field.
	DMA_ERR_ERR21_Pos = 0x15
	// Bit mask of ERR21 field.
	DMA_ERR_ERR21_Msk = 0x200000
	// Bit ERR21.
	DMA_ERR_ERR21 = 0x200000
	// An error in this channel has not occurred
	DMA_ERR_ERR21_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR21_1 = 0x1
	// Position of ERR22 field.
	DMA_ERR_ERR22_Pos = 0x16
	// Bit mask of ERR22 field.
	DMA_ERR_ERR22_Msk = 0x400000
	// Bit ERR22.
	DMA_ERR_ERR22 = 0x400000
	// An error in this channel has not occurred
	DMA_ERR_ERR22_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR22_1 = 0x1
	// Position of ERR23 field.
	DMA_ERR_ERR23_Pos = 0x17
	// Bit mask of ERR23 field.
	DMA_ERR_ERR23_Msk = 0x800000
	// Bit ERR23.
	DMA_ERR_ERR23 = 0x800000
	// An error in this channel has not occurred
	DMA_ERR_ERR23_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR23_1 = 0x1
	// Position of ERR24 field.
	DMA_ERR_ERR24_Pos = 0x18
	// Bit mask of ERR24 field.
	DMA_ERR_ERR24_Msk = 0x1000000
	// Bit ERR24.
	DMA_ERR_ERR24 = 0x1000000
	// An error in this channel has not occurred
	DMA_ERR_ERR24_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR24_1 = 0x1
	// Position of ERR25 field.
	DMA_ERR_ERR25_Pos = 0x19
	// Bit mask of ERR25 field.
	DMA_ERR_ERR25_Msk = 0x2000000
	// Bit ERR25.
	DMA_ERR_ERR25 = 0x2000000
	// An error in this channel has not occurred
	DMA_ERR_ERR25_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR25_1 = 0x1
	// Position of ERR26 field.
	DMA_ERR_ERR26_Pos = 0x1a
	// Bit mask of ERR26 field.
	DMA_ERR_ERR26_Msk = 0x4000000
	// Bit ERR26.
	DMA_ERR_ERR26 = 0x4000000
	// An error in this channel has not occurred
	DMA_ERR_ERR26_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR26_1 = 0x1
	// Position of ERR27 field.
	DMA_ERR_ERR27_Pos = 0x1b
	// Bit mask of ERR27 field.
	DMA_ERR_ERR27_Msk = 0x8000000
	// Bit ERR27.
	DMA_ERR_ERR27 = 0x8000000
	// An error in this channel has not occurred
	DMA_ERR_ERR27_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR27_1 = 0x1
	// Position of ERR28 field.
	DMA_ERR_ERR28_Pos = 0x1c
	// Bit mask of ERR28 field.
	DMA_ERR_ERR28_Msk = 0x10000000
	// Bit ERR28.
	DMA_ERR_ERR28 = 0x10000000
	// An error in this channel has not occurred
	DMA_ERR_ERR28_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR28_1 = 0x1
	// Position of ERR29 field.
	DMA_ERR_ERR29_Pos = 0x1d
	// Bit mask of ERR29 field.
	DMA_ERR_ERR29_Msk = 0x20000000
	// Bit ERR29.
	DMA_ERR_ERR29 = 0x20000000
	// An error in this channel has not occurred
	DMA_ERR_ERR29_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR29_1 = 0x1
	// Position of ERR30 field.
	DMA_ERR_ERR30_Pos = 0x1e
	// Bit mask of ERR30 field.
	DMA_ERR_ERR30_Msk = 0x40000000
	// Bit ERR30.
	DMA_ERR_ERR30 = 0x40000000
	// An error in this channel has not occurred
	DMA_ERR_ERR30_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR30_1 = 0x1
	// Position of ERR31 field.
	DMA_ERR_ERR31_Pos = 0x1f
	// Bit mask of ERR31 field.
	DMA_ERR_ERR31_Msk = 0x80000000
	// Bit ERR31.
	DMA_ERR_ERR31 = 0x80000000
	// An error in this channel has not occurred
	DMA_ERR_ERR31_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR31_1 = 0x1

	// HRS: Hardware Request Status Register
	// Position of HRS0 field.
	DMA_HRS_HRS0_Pos = 0x0
	// Bit mask of HRS0 field.
	DMA_HRS_HRS0_Msk = 0x1
	// Bit HRS0.
	DMA_HRS_HRS0 = 0x1
	// A hardware service request for channel 0 is not present
	DMA_HRS_HRS0_0 = 0x0
	// A hardware service request for channel 0 is present
	DMA_HRS_HRS0_1 = 0x1
	// Position of HRS1 field.
	DMA_HRS_HRS1_Pos = 0x1
	// Bit mask of HRS1 field.
	DMA_HRS_HRS1_Msk = 0x2
	// Bit HRS1.
	DMA_HRS_HRS1 = 0x2
	// A hardware service request for channel 1 is not present
	DMA_HRS_HRS1_0 = 0x0
	// A hardware service request for channel 1 is present
	DMA_HRS_HRS1_1 = 0x1
	// Position of HRS2 field.
	DMA_HRS_HRS2_Pos = 0x2
	// Bit mask of HRS2 field.
	DMA_HRS_HRS2_Msk = 0x4
	// Bit HRS2.
	DMA_HRS_HRS2 = 0x4
	// A hardware service request for channel 2 is not present
	DMA_HRS_HRS2_0 = 0x0
	// A hardware service request for channel 2 is present
	DMA_HRS_HRS2_1 = 0x1
	// Position of HRS3 field.
	DMA_HRS_HRS3_Pos = 0x3
	// Bit mask of HRS3 field.
	DMA_HRS_HRS3_Msk = 0x8
	// Bit HRS3.
	DMA_HRS_HRS3 = 0x8
	// A hardware service request for channel 3 is not present
	DMA_HRS_HRS3_0 = 0x0
	// A hardware service request for channel 3 is present
	DMA_HRS_HRS3_1 = 0x1
	// Position of HRS4 field.
	DMA_HRS_HRS4_Pos = 0x4
	// Bit mask of HRS4 field.
	DMA_HRS_HRS4_Msk = 0x10
	// Bit HRS4.
	DMA_HRS_HRS4 = 0x10
	// A hardware service request for channel 4 is not present
	DMA_HRS_HRS4_0 = 0x0
	// A hardware service request for channel 4 is present
	DMA_HRS_HRS4_1 = 0x1
	// Position of HRS5 field.
	DMA_HRS_HRS5_Pos = 0x5
	// Bit mask of HRS5 field.
	DMA_HRS_HRS5_Msk = 0x20
	// Bit HRS5.
	DMA_HRS_HRS5 = 0x20
	// A hardware service request for channel 5 is not present
	DMA_HRS_HRS5_0 = 0x0
	// A hardware service request for channel 5 is present
	DMA_HRS_HRS5_1 = 0x1
	// Position of HRS6 field.
	DMA_HRS_HRS6_Pos = 0x6
	// Bit mask of HRS6 field.
	DMA_HRS_HRS6_Msk = 0x40
	// Bit HRS6.
	DMA_HRS_HRS6 = 0x40
	// A hardware service request for channel 6 is not present
	DMA_HRS_HRS6_0 = 0x0
	// A hardware service request for channel 6 is present
	DMA_HRS_HRS6_1 = 0x1
	// Position of HRS7 field.
	DMA_HRS_HRS7_Pos = 0x7
	// Bit mask of HRS7 field.
	DMA_HRS_HRS7_Msk = 0x80
	// Bit HRS7.
	DMA_HRS_HRS7 = 0x80
	// A hardware service request for channel 7 is not present
	DMA_HRS_HRS7_0 = 0x0
	// A hardware service request for channel 7 is present
	DMA_HRS_HRS7_1 = 0x1
	// Position of HRS8 field.
	DMA_HRS_HRS8_Pos = 0x8
	// Bit mask of HRS8 field.
	DMA_HRS_HRS8_Msk = 0x100
	// Bit HRS8.
	DMA_HRS_HRS8 = 0x100
	// A hardware service request for channel 8 is not present
	DMA_HRS_HRS8_0 = 0x0
	// A hardware service request for channel 8 is present
	DMA_HRS_HRS8_1 = 0x1
	// Position of HRS9 field.
	DMA_HRS_HRS9_Pos = 0x9
	// Bit mask of HRS9 field.
	DMA_HRS_HRS9_Msk = 0x200
	// Bit HRS9.
	DMA_HRS_HRS9 = 0x200
	// A hardware service request for channel 9 is not present
	DMA_HRS_HRS9_0 = 0x0
	// A hardware service request for channel 9 is present
	DMA_HRS_HRS9_1 = 0x1
	// Position of HRS10 field.
	DMA_HRS_HRS10_Pos = 0xa
	// Bit mask of HRS10 field.
	DMA_HRS_HRS10_Msk = 0x400
	// Bit HRS10.
	DMA_HRS_HRS10 = 0x400
	// A hardware service request for channel 10 is not present
	DMA_HRS_HRS10_0 = 0x0
	// A hardware service request for channel 10 is present
	DMA_HRS_HRS10_1 = 0x1
	// Position of HRS11 field.
	DMA_HRS_HRS11_Pos = 0xb
	// Bit mask of HRS11 field.
	DMA_HRS_HRS11_Msk = 0x800
	// Bit HRS11.
	DMA_HRS_HRS11 = 0x800
	// A hardware service request for channel 11 is not present
	DMA_HRS_HRS11_0 = 0x0
	// A hardware service request for channel 11 is present
	DMA_HRS_HRS11_1 = 0x1
	// Position of HRS12 field.
	DMA_HRS_HRS12_Pos = 0xc
	// Bit mask of HRS12 field.
	DMA_HRS_HRS12_Msk = 0x1000
	// Bit HRS12.
	DMA_HRS_HRS12 = 0x1000
	// A hardware service request for channel 12 is not present
	DMA_HRS_HRS12_0 = 0x0
	// A hardware service request for channel 12 is present
	DMA_HRS_HRS12_1 = 0x1
	// Position of HRS13 field.
	DMA_HRS_HRS13_Pos = 0xd
	// Bit mask of HRS13 field.
	DMA_HRS_HRS13_Msk = 0x2000
	// Bit HRS13.
	DMA_HRS_HRS13 = 0x2000
	// A hardware service request for channel 13 is not present
	DMA_HRS_HRS13_0 = 0x0
	// A hardware service request for channel 13 is present
	DMA_HRS_HRS13_1 = 0x1
	// Position of HRS14 field.
	DMA_HRS_HRS14_Pos = 0xe
	// Bit mask of HRS14 field.
	DMA_HRS_HRS14_Msk = 0x4000
	// Bit HRS14.
	DMA_HRS_HRS14 = 0x4000
	// A hardware service request for channel 14 is not present
	DMA_HRS_HRS14_0 = 0x0
	// A hardware service request for channel 14 is present
	DMA_HRS_HRS14_1 = 0x1
	// Position of HRS15 field.
	DMA_HRS_HRS15_Pos = 0xf
	// Bit mask of HRS15 field.
	DMA_HRS_HRS15_Msk = 0x8000
	// Bit HRS15.
	DMA_HRS_HRS15 = 0x8000
	// A hardware service request for channel 15 is not present
	DMA_HRS_HRS15_0 = 0x0
	// A hardware service request for channel 15 is present
	DMA_HRS_HRS15_1 = 0x1
	// Position of HRS16 field.
	DMA_HRS_HRS16_Pos = 0x10
	// Bit mask of HRS16 field.
	DMA_HRS_HRS16_Msk = 0x10000
	// Bit HRS16.
	DMA_HRS_HRS16 = 0x10000
	// A hardware service request for channel 16 is not present
	DMA_HRS_HRS16_0 = 0x0
	// A hardware service request for channel 16 is present
	DMA_HRS_HRS16_1 = 0x1
	// Position of HRS17 field.
	DMA_HRS_HRS17_Pos = 0x11
	// Bit mask of HRS17 field.
	DMA_HRS_HRS17_Msk = 0x20000
	// Bit HRS17.
	DMA_HRS_HRS17 = 0x20000
	// A hardware service request for channel 17 is not present
	DMA_HRS_HRS17_0 = 0x0
	// A hardware service request for channel 17 is present
	DMA_HRS_HRS17_1 = 0x1
	// Position of HRS18 field.
	DMA_HRS_HRS18_Pos = 0x12
	// Bit mask of HRS18 field.
	DMA_HRS_HRS18_Msk = 0x40000
	// Bit HRS18.
	DMA_HRS_HRS18 = 0x40000
	// A hardware service request for channel 18 is not present
	DMA_HRS_HRS18_0 = 0x0
	// A hardware service request for channel 18 is present
	DMA_HRS_HRS18_1 = 0x1
	// Position of HRS19 field.
	DMA_HRS_HRS19_Pos = 0x13
	// Bit mask of HRS19 field.
	DMA_HRS_HRS19_Msk = 0x80000
	// Bit HRS19.
	DMA_HRS_HRS19 = 0x80000
	// A hardware service request for channel 19 is not present
	DMA_HRS_HRS19_0 = 0x0
	// A hardware service request for channel 19 is present
	DMA_HRS_HRS19_1 = 0x1
	// Position of HRS20 field.
	DMA_HRS_HRS20_Pos = 0x14
	// Bit mask of HRS20 field.
	DMA_HRS_HRS20_Msk = 0x100000
	// Bit HRS20.
	DMA_HRS_HRS20 = 0x100000
	// A hardware service request for channel 20 is not present
	DMA_HRS_HRS20_0 = 0x0
	// A hardware service request for channel 20 is present
	DMA_HRS_HRS20_1 = 0x1
	// Position of HRS21 field.
	DMA_HRS_HRS21_Pos = 0x15
	// Bit mask of HRS21 field.
	DMA_HRS_HRS21_Msk = 0x200000
	// Bit HRS21.
	DMA_HRS_HRS21 = 0x200000
	// A hardware service request for channel 21 is not present
	DMA_HRS_HRS21_0 = 0x0
	// A hardware service request for channel 21 is present
	DMA_HRS_HRS21_1 = 0x1
	// Position of HRS22 field.
	DMA_HRS_HRS22_Pos = 0x16
	// Bit mask of HRS22 field.
	DMA_HRS_HRS22_Msk = 0x400000
	// Bit HRS22.
	DMA_HRS_HRS22 = 0x400000
	// A hardware service request for channel 22 is not present
	DMA_HRS_HRS22_0 = 0x0
	// A hardware service request for channel 22 is present
	DMA_HRS_HRS22_1 = 0x1
	// Position of HRS23 field.
	DMA_HRS_HRS23_Pos = 0x17
	// Bit mask of HRS23 field.
	DMA_HRS_HRS23_Msk = 0x800000
	// Bit HRS23.
	DMA_HRS_HRS23 = 0x800000
	// A hardware service request for channel 23 is not present
	DMA_HRS_HRS23_0 = 0x0
	// A hardware service request for channel 23 is present
	DMA_HRS_HRS23_1 = 0x1
	// Position of HRS24 field.
	DMA_HRS_HRS24_Pos = 0x18
	// Bit mask of HRS24 field.
	DMA_HRS_HRS24_Msk = 0x1000000
	// Bit HRS24.
	DMA_HRS_HRS24 = 0x1000000
	// A hardware service request for channel 24 is not present
	DMA_HRS_HRS24_0 = 0x0
	// A hardware service request for channel 24 is present
	DMA_HRS_HRS24_1 = 0x1
	// Position of HRS25 field.
	DMA_HRS_HRS25_Pos = 0x19
	// Bit mask of HRS25 field.
	DMA_HRS_HRS25_Msk = 0x2000000
	// Bit HRS25.
	DMA_HRS_HRS25 = 0x2000000
	// A hardware service request for channel 25 is not present
	DMA_HRS_HRS25_0 = 0x0
	// A hardware service request for channel 25 is present
	DMA_HRS_HRS25_1 = 0x1
	// Position of HRS26 field.
	DMA_HRS_HRS26_Pos = 0x1a
	// Bit mask of HRS26 field.
	DMA_HRS_HRS26_Msk = 0x4000000
	// Bit HRS26.
	DMA_HRS_HRS26 = 0x4000000
	// A hardware service request for channel 26 is not present
	DMA_HRS_HRS26_0 = 0x0
	// A hardware service request for channel 26 is present
	DMA_HRS_HRS26_1 = 0x1
	// Position of HRS27 field.
	DMA_HRS_HRS27_Pos = 0x1b
	// Bit mask of HRS27 field.
	DMA_HRS_HRS27_Msk = 0x8000000
	// Bit HRS27.
	DMA_HRS_HRS27 = 0x8000000
	// A hardware service request for channel 27 is not present
	DMA_HRS_HRS27_0 = 0x0
	// A hardware service request for channel 27 is present
	DMA_HRS_HRS27_1 = 0x1
	// Position of HRS28 field.
	DMA_HRS_HRS28_Pos = 0x1c
	// Bit mask of HRS28 field.
	DMA_HRS_HRS28_Msk = 0x10000000
	// Bit HRS28.
	DMA_HRS_HRS28 = 0x10000000
	// A hardware service request for channel 28 is not present
	DMA_HRS_HRS28_0 = 0x0
	// A hardware service request for channel 28 is present
	DMA_HRS_HRS28_1 = 0x1
	// Position of HRS29 field.
	DMA_HRS_HRS29_Pos = 0x1d
	// Bit mask of HRS29 field.
	DMA_HRS_HRS29_Msk = 0x20000000
	// Bit HRS29.
	DMA_HRS_HRS29 = 0x20000000
	// A hardware service request for channel 29 is not preset
	DMA_HRS_HRS29_0 = 0x0
	// A hardware service request for channel 29 is present
	DMA_HRS_HRS29_1 = 0x1
	// Position of HRS30 field.
	DMA_HRS_HRS30_Pos = 0x1e
	// Bit mask of HRS30 field.
	DMA_HRS_HRS30_Msk = 0x40000000
	// Bit HRS30.
	DMA_HRS_HRS30 = 0x40000000
	// A hardware service request for channel 30 is not present
	DMA_HRS_HRS30_0 = 0x0
	// A hardware service request for for channel 30 is present
	DMA_HRS_HRS30_1 = 0x1
	// Position of HRS31 field.
	DMA_HRS_HRS31_Pos = 0x1f
	// Bit mask of HRS31 field.
	DMA_HRS_HRS31_Msk = 0x80000000
	// Bit HRS31.
	DMA_HRS_HRS31 = 0x80000000
	// A hardware service request for channel 31 is not present
	DMA_HRS_HRS31_0 = 0x0
	// A hardware service request for channel 31 is present
	DMA_HRS_HRS31_1 = 0x1

	// EARS: Enable Asynchronous Request in Stop Register
	// Position of EDREQ_0 field.
	DMA_EARS_EDREQ_0_Pos = 0x0
	// Bit mask of EDREQ_0 field.
	DMA_EARS_EDREQ_0_Msk = 0x1
	// Bit EDREQ_0.
	DMA_EARS_EDREQ_0 = 0x1
	// Disable asynchronous DMA request for channel 0.
	DMA_EARS_EDREQ_0_0 = 0x0
	// Enable asynchronous DMA request for channel 0.
	DMA_EARS_EDREQ_0_1 = 0x1
	// Position of EDREQ_1 field.
	DMA_EARS_EDREQ_1_Pos = 0x1
	// Bit mask of EDREQ_1 field.
	DMA_EARS_EDREQ_1_Msk = 0x2
	// Bit EDREQ_1.
	DMA_EARS_EDREQ_1 = 0x2
	// Disable asynchronous DMA request for channel 1
	DMA_EARS_EDREQ_1_0 = 0x0
	// Enable asynchronous DMA request for channel 1.
	DMA_EARS_EDREQ_1_1 = 0x1
	// Position of EDREQ_2 field.
	DMA_EARS_EDREQ_2_Pos = 0x2
	// Bit mask of EDREQ_2 field.
	DMA_EARS_EDREQ_2_Msk = 0x4
	// Bit EDREQ_2.
	DMA_EARS_EDREQ_2 = 0x4
	// Disable asynchronous DMA request for channel 2.
	DMA_EARS_EDREQ_2_0 = 0x0
	// Enable asynchronous DMA request for channel 2.
	DMA_EARS_EDREQ_2_1 = 0x1
	// Position of EDREQ_3 field.
	DMA_EARS_EDREQ_3_Pos = 0x3
	// Bit mask of EDREQ_3 field.
	DMA_EARS_EDREQ_3_Msk = 0x8
	// Bit EDREQ_3.
	DMA_EARS_EDREQ_3 = 0x8
	// Disable asynchronous DMA request for channel 3.
	DMA_EARS_EDREQ_3_0 = 0x0
	// Enable asynchronous DMA request for channel 3.
	DMA_EARS_EDREQ_3_1 = 0x1
	// Position of EDREQ_4 field.
	DMA_EARS_EDREQ_4_Pos = 0x4
	// Bit mask of EDREQ_4 field.
	DMA_EARS_EDREQ_4_Msk = 0x10
	// Bit EDREQ_4.
	DMA_EARS_EDREQ_4 = 0x10
	// Disable asynchronous DMA request for channel 4.
	DMA_EARS_EDREQ_4_0 = 0x0
	// Enable asynchronous DMA request for channel 4.
	DMA_EARS_EDREQ_4_1 = 0x1
	// Position of EDREQ_5 field.
	DMA_EARS_EDREQ_5_Pos = 0x5
	// Bit mask of EDREQ_5 field.
	DMA_EARS_EDREQ_5_Msk = 0x20
	// Bit EDREQ_5.
	DMA_EARS_EDREQ_5 = 0x20
	// Disable asynchronous DMA request for channel 5.
	DMA_EARS_EDREQ_5_0 = 0x0
	// Enable asynchronous DMA request for channel 5.
	DMA_EARS_EDREQ_5_1 = 0x1
	// Position of EDREQ_6 field.
	DMA_EARS_EDREQ_6_Pos = 0x6
	// Bit mask of EDREQ_6 field.
	DMA_EARS_EDREQ_6_Msk = 0x40
	// Bit EDREQ_6.
	DMA_EARS_EDREQ_6 = 0x40
	// Disable asynchronous DMA request for channel 6.
	DMA_EARS_EDREQ_6_0 = 0x0
	// Enable asynchronous DMA request for channel 6.
	DMA_EARS_EDREQ_6_1 = 0x1
	// Position of EDREQ_7 field.
	DMA_EARS_EDREQ_7_Pos = 0x7
	// Bit mask of EDREQ_7 field.
	DMA_EARS_EDREQ_7_Msk = 0x80
	// Bit EDREQ_7.
	DMA_EARS_EDREQ_7 = 0x80
	// Disable asynchronous DMA request for channel 7.
	DMA_EARS_EDREQ_7_0 = 0x0
	// Enable asynchronous DMA request for channel 7.
	DMA_EARS_EDREQ_7_1 = 0x1
	// Position of EDREQ_8 field.
	DMA_EARS_EDREQ_8_Pos = 0x8
	// Bit mask of EDREQ_8 field.
	DMA_EARS_EDREQ_8_Msk = 0x100
	// Bit EDREQ_8.
	DMA_EARS_EDREQ_8 = 0x100
	// Disable asynchronous DMA request for channel 8.
	DMA_EARS_EDREQ_8_0 = 0x0
	// Enable asynchronous DMA request for channel 8.
	DMA_EARS_EDREQ_8_1 = 0x1
	// Position of EDREQ_9 field.
	DMA_EARS_EDREQ_9_Pos = 0x9
	// Bit mask of EDREQ_9 field.
	DMA_EARS_EDREQ_9_Msk = 0x200
	// Bit EDREQ_9.
	DMA_EARS_EDREQ_9 = 0x200
	// Disable asynchronous DMA request for channel 9.
	DMA_EARS_EDREQ_9_0 = 0x0
	// Enable asynchronous DMA request for channel 9.
	DMA_EARS_EDREQ_9_1 = 0x1
	// Position of EDREQ_10 field.
	DMA_EARS_EDREQ_10_Pos = 0xa
	// Bit mask of EDREQ_10 field.
	DMA_EARS_EDREQ_10_Msk = 0x400
	// Bit EDREQ_10.
	DMA_EARS_EDREQ_10 = 0x400
	// Disable asynchronous DMA request for channel 10.
	DMA_EARS_EDREQ_10_0 = 0x0
	// Enable asynchronous DMA request for channel 10.
	DMA_EARS_EDREQ_10_1 = 0x1
	// Position of EDREQ_11 field.
	DMA_EARS_EDREQ_11_Pos = 0xb
	// Bit mask of EDREQ_11 field.
	DMA_EARS_EDREQ_11_Msk = 0x800
	// Bit EDREQ_11.
	DMA_EARS_EDREQ_11 = 0x800
	// Disable asynchronous DMA request for channel 11.
	DMA_EARS_EDREQ_11_0 = 0x0
	// Enable asynchronous DMA request for channel 11.
	DMA_EARS_EDREQ_11_1 = 0x1
	// Position of EDREQ_12 field.
	DMA_EARS_EDREQ_12_Pos = 0xc
	// Bit mask of EDREQ_12 field.
	DMA_EARS_EDREQ_12_Msk = 0x1000
	// Bit EDREQ_12.
	DMA_EARS_EDREQ_12 = 0x1000
	// Disable asynchronous DMA request for channel 12.
	DMA_EARS_EDREQ_12_0 = 0x0
	// Enable asynchronous DMA request for channel 12.
	DMA_EARS_EDREQ_12_1 = 0x1
	// Position of EDREQ_13 field.
	DMA_EARS_EDREQ_13_Pos = 0xd
	// Bit mask of EDREQ_13 field.
	DMA_EARS_EDREQ_13_Msk = 0x2000
	// Bit EDREQ_13.
	DMA_EARS_EDREQ_13 = 0x2000
	// Disable asynchronous DMA request for channel 13.
	DMA_EARS_EDREQ_13_0 = 0x0
	// Enable asynchronous DMA request for channel 13.
	DMA_EARS_EDREQ_13_1 = 0x1
	// Position of EDREQ_14 field.
	DMA_EARS_EDREQ_14_Pos = 0xe
	// Bit mask of EDREQ_14 field.
	DMA_EARS_EDREQ_14_Msk = 0x4000
	// Bit EDREQ_14.
	DMA_EARS_EDREQ_14 = 0x4000
	// Disable asynchronous DMA request for channel 14.
	DMA_EARS_EDREQ_14_0 = 0x0
	// Enable asynchronous DMA request for channel 14.
	DMA_EARS_EDREQ_14_1 = 0x1
	// Position of EDREQ_15 field.
	DMA_EARS_EDREQ_15_Pos = 0xf
	// Bit mask of EDREQ_15 field.
	DMA_EARS_EDREQ_15_Msk = 0x8000
	// Bit EDREQ_15.
	DMA_EARS_EDREQ_15 = 0x8000
	// Disable asynchronous DMA request for channel 15.
	DMA_EARS_EDREQ_15_0 = 0x0
	// Enable asynchronous DMA request for channel 15.
	DMA_EARS_EDREQ_15_1 = 0x1
	// Position of EDREQ_16 field.
	DMA_EARS_EDREQ_16_Pos = 0x10
	// Bit mask of EDREQ_16 field.
	DMA_EARS_EDREQ_16_Msk = 0x10000
	// Bit EDREQ_16.
	DMA_EARS_EDREQ_16 = 0x10000
	// Disable asynchronous DMA request for channel 16
	DMA_EARS_EDREQ_16_0 = 0x0
	// Enable asynchronous DMA request for channel 16
	DMA_EARS_EDREQ_16_1 = 0x1
	// Position of EDREQ_17 field.
	DMA_EARS_EDREQ_17_Pos = 0x11
	// Bit mask of EDREQ_17 field.
	DMA_EARS_EDREQ_17_Msk = 0x20000
	// Bit EDREQ_17.
	DMA_EARS_EDREQ_17 = 0x20000
	// Disable asynchronous DMA request for channel 17
	DMA_EARS_EDREQ_17_0 = 0x0
	// Enable asynchronous DMA request for channel 17
	DMA_EARS_EDREQ_17_1 = 0x1
	// Position of EDREQ_18 field.
	DMA_EARS_EDREQ_18_Pos = 0x12
	// Bit mask of EDREQ_18 field.
	DMA_EARS_EDREQ_18_Msk = 0x40000
	// Bit EDREQ_18.
	DMA_EARS_EDREQ_18 = 0x40000
	// Disable asynchronous DMA request for channel 18
	DMA_EARS_EDREQ_18_0 = 0x0
	// Enable asynchronous DMA request for channel 18
	DMA_EARS_EDREQ_18_1 = 0x1
	// Position of EDREQ_19 field.
	DMA_EARS_EDREQ_19_Pos = 0x13
	// Bit mask of EDREQ_19 field.
	DMA_EARS_EDREQ_19_Msk = 0x80000
	// Bit EDREQ_19.
	DMA_EARS_EDREQ_19 = 0x80000
	// Disable asynchronous DMA request for channel 19
	DMA_EARS_EDREQ_19_0 = 0x0
	// Enable asynchronous DMA request for channel 19
	DMA_EARS_EDREQ_19_1 = 0x1
	// Position of EDREQ_20 field.
	DMA_EARS_EDREQ_20_Pos = 0x14
	// Bit mask of EDREQ_20 field.
	DMA_EARS_EDREQ_20_Msk = 0x100000
	// Bit EDREQ_20.
	DMA_EARS_EDREQ_20 = 0x100000
	// Disable asynchronous DMA request for channel 20
	DMA_EARS_EDREQ_20_0 = 0x0
	// Enable asynchronous DMA request for channel 20
	DMA_EARS_EDREQ_20_1 = 0x1
	// Position of EDREQ_21 field.
	DMA_EARS_EDREQ_21_Pos = 0x15
	// Bit mask of EDREQ_21 field.
	DMA_EARS_EDREQ_21_Msk = 0x200000
	// Bit EDREQ_21.
	DMA_EARS_EDREQ_21 = 0x200000
	// Disable asynchronous DMA request for channel 21
	DMA_EARS_EDREQ_21_0 = 0x0
	// Enable asynchronous DMA request for channel 21
	DMA_EARS_EDREQ_21_1 = 0x1
	// Position of EDREQ_22 field.
	DMA_EARS_EDREQ_22_Pos = 0x16
	// Bit mask of EDREQ_22 field.
	DMA_EARS_EDREQ_22_Msk = 0x400000
	// Bit EDREQ_22.
	DMA_EARS_EDREQ_22 = 0x400000
	// Disable asynchronous DMA request for channel 22
	DMA_EARS_EDREQ_22_0 = 0x0
	// Enable asynchronous DMA request for channel 22
	DMA_EARS_EDREQ_22_1 = 0x1
	// Position of EDREQ_23 field.
	DMA_EARS_EDREQ_23_Pos = 0x17
	// Bit mask of EDREQ_23 field.
	DMA_EARS_EDREQ_23_Msk = 0x800000
	// Bit EDREQ_23.
	DMA_EARS_EDREQ_23 = 0x800000
	// Disable asynchronous DMA request for channel 23
	DMA_EARS_EDREQ_23_0 = 0x0
	// Enable asynchronous DMA request for channel 23
	DMA_EARS_EDREQ_23_1 = 0x1
	// Position of EDREQ_24 field.
	DMA_EARS_EDREQ_24_Pos = 0x18
	// Bit mask of EDREQ_24 field.
	DMA_EARS_EDREQ_24_Msk = 0x1000000
	// Bit EDREQ_24.
	DMA_EARS_EDREQ_24 = 0x1000000
	// Disable asynchronous DMA request for channel 24
	DMA_EARS_EDREQ_24_0 = 0x0
	// Enable asynchronous DMA request for channel 24
	DMA_EARS_EDREQ_24_1 = 0x1
	// Position of EDREQ_25 field.
	DMA_EARS_EDREQ_25_Pos = 0x19
	// Bit mask of EDREQ_25 field.
	DMA_EARS_EDREQ_25_Msk = 0x2000000
	// Bit EDREQ_25.
	DMA_EARS_EDREQ_25 = 0x2000000
	// Disable asynchronous DMA request for channel 25
	DMA_EARS_EDREQ_25_0 = 0x0
	// Enable asynchronous DMA request for channel 25
	DMA_EARS_EDREQ_25_1 = 0x1
	// Position of EDREQ_26 field.
	DMA_EARS_EDREQ_26_Pos = 0x1a
	// Bit mask of EDREQ_26 field.
	DMA_EARS_EDREQ_26_Msk = 0x4000000
	// Bit EDREQ_26.
	DMA_EARS_EDREQ_26 = 0x4000000
	// Disable asynchronous DMA request for channel 26
	DMA_EARS_EDREQ_26_0 = 0x0
	// Enable asynchronous DMA request for channel 26
	DMA_EARS_EDREQ_26_1 = 0x1
	// Position of EDREQ_27 field.
	DMA_EARS_EDREQ_27_Pos = 0x1b
	// Bit mask of EDREQ_27 field.
	DMA_EARS_EDREQ_27_Msk = 0x8000000
	// Bit EDREQ_27.
	DMA_EARS_EDREQ_27 = 0x8000000
	// Disable asynchronous DMA request for channel 27
	DMA_EARS_EDREQ_27_0 = 0x0
	// Enable asynchronous DMA request for channel 27
	DMA_EARS_EDREQ_27_1 = 0x1
	// Position of EDREQ_28 field.
	DMA_EARS_EDREQ_28_Pos = 0x1c
	// Bit mask of EDREQ_28 field.
	DMA_EARS_EDREQ_28_Msk = 0x10000000
	// Bit EDREQ_28.
	DMA_EARS_EDREQ_28 = 0x10000000
	// Disable asynchronous DMA request for channel 28
	DMA_EARS_EDREQ_28_0 = 0x0
	// Enable asynchronous DMA request for channel 28
	DMA_EARS_EDREQ_28_1 = 0x1
	// Position of EDREQ_29 field.
	DMA_EARS_EDREQ_29_Pos = 0x1d
	// Bit mask of EDREQ_29 field.
	DMA_EARS_EDREQ_29_Msk = 0x20000000
	// Bit EDREQ_29.
	DMA_EARS_EDREQ_29 = 0x20000000
	// Disable asynchronous DMA request for channel 29
	DMA_EARS_EDREQ_29_0 = 0x0
	// Enable asynchronous DMA request for channel 29
	DMA_EARS_EDREQ_29_1 = 0x1
	// Position of EDREQ_30 field.
	DMA_EARS_EDREQ_30_Pos = 0x1e
	// Bit mask of EDREQ_30 field.
	DMA_EARS_EDREQ_30_Msk = 0x40000000
	// Bit EDREQ_30.
	DMA_EARS_EDREQ_30 = 0x40000000
	// Disable asynchronous DMA request for channel 30
	DMA_EARS_EDREQ_30_0 = 0x0
	// Enable asynchronous DMA request for channel 30
	DMA_EARS_EDREQ_30_1 = 0x1
	// Position of EDREQ_31 field.
	DMA_EARS_EDREQ_31_Pos = 0x1f
	// Bit mask of EDREQ_31 field.
	DMA_EARS_EDREQ_31_Msk = 0x80000000
	// Bit EDREQ_31.
	DMA_EARS_EDREQ_31 = 0x80000000
	// Disable asynchronous DMA request for channel 31
	DMA_EARS_EDREQ_31_0 = 0x0
	// Enable asynchronous DMA request for channel 31
	DMA_EARS_EDREQ_31_1 = 0x1

	// DCHPRI3: Channel n Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI_CHPRI_Msk = 0xf
	// Position of GRPPRI field.
	DMA_DCHPRI_GRPPRI_Pos = 0x4
	// Bit mask of GRPPRI field.
	DMA_DCHPRI_GRPPRI_Msk = 0x30
	// Position of DPA field.
	DMA_DCHPRI_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI_ECP_1 = 0x1

	// TCD0_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD_SADDR_SADDR_Msk = 0xffffffff

	// TCD0_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD_SOFF_SOFF_Msk = 0xffff

	// TCD0_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD_ATTR_SSIZE_000 = 0x0
	// 16-bit
	DMA_TCD_ATTR_SSIZE_001 = 0x1
	// 32-bit
	DMA_TCD_ATTR_SSIZE_010 = 0x2
	// 16-byte burst
	DMA_TCD_ATTR_SSIZE_100 = 0x4
	// 32-byte burst
	DMA_TCD_ATTR_SSIZE_101 = 0x5
	// Position of SMOD field.
	DMA_TCD_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD_ATTR_SMOD_0 = 0x0

	// TCD0_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD0_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD_NBYTES_MLOFFNO_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD_NBYTES_MLOFFNO_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD_NBYTES_MLOFFNO_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD_NBYTES_MLOFFNO_SMLOE_1 = 0x1

	// TCD0_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD_NBYTES_MLOFFYES_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD_NBYTES_MLOFFYES_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD_NBYTES_MLOFFYES_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD_NBYTES_MLOFFYES_SMLOE_1 = 0x1

	// TCD0_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD_SLAST_SLAST_Msk = 0xffffffff

	// TCD0_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD_DADDR_DADDR_Msk = 0xffffffff

	// TCD0_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD_DOFF_DOFF_Msk = 0xffff

	// TCD0_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD_CITER_ELINKNO_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD_CITER_ELINKNO_ELINK_1 = 0x1

	// TCD0_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD_CITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD_CITER_ELINKYES_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD_CITER_ELINKYES_ELINK_1 = 0x1

	// TCD0_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD0_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD_CSR_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD_CSR_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD_CSR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD_CSR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD_CSR_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD_CSR_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD_CSR_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD_CSR_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD_CSR_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD_CSR_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD_CSR_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD_CSR_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD_CSR_MAJORLINKCH_Msk = 0x1f00
	// Position of BWC field.
	DMA_TCD_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls
	DMA_TCD_CSR_BWC_00 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD_CSR_BWC_10 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD_CSR_BWC_11 = 0x3

	// TCD0_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD_BITER_ELINKNO_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD_BITER_ELINKNO_ELINK_1 = 0x1

	// TCD0_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD_BITER_ELINKYES_LINKCH_Msk = 0x3e00
	// Position of ELINK field.
	DMA_TCD_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD_BITER_ELINKYES_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD_BITER_ELINKYES_ELINK_1 = 0x1
)

// Constants for FB: FlexBus external bus interface
const (
	// CSAR0: Chip Select Address Register
	// Position of BA field.
	FB_CSAR_BA_Pos = 0x10
	// Bit mask of BA field.
	FB_CSAR_BA_Msk = 0xffff0000

	// CSMR0: Chip Select Mask Register
	// Position of V field.
	FB_CSMR_V_Pos = 0x0
	// Bit mask of V field.
	FB_CSMR_V_Msk = 0x1
	// Bit V.
	FB_CSMR_V = 0x1
	// Chip-select is invalid.
	FB_CSMR_V_0 = 0x0
	// Chip-select is valid.
	FB_CSMR_V_1 = 0x1
	// Position of WP field.
	FB_CSMR_WP_Pos = 0x8
	// Bit mask of WP field.
	FB_CSMR_WP_Msk = 0x100
	// Bit WP.
	FB_CSMR_WP = 0x100
	// Write accesses are allowed.
	FB_CSMR_WP_0 = 0x0
	// Write accesses are not allowed. Attempting to write to the range of addresses for which the WP bit is set results in a bus error termination of the internal cycle and no external cycle.
	FB_CSMR_WP_1 = 0x1
	// Position of BAM field.
	FB_CSMR_BAM_Pos = 0x10
	// Bit mask of BAM field.
	FB_CSMR_BAM_Msk = 0xffff0000
	// The corresponding address bit in CSAR is used in the chip-select decode.
	FB_CSMR_BAM_0 = 0x0
	// The corresponding address bit in CSAR is a don't care in the chip-select decode.
	FB_CSMR_BAM_1 = 0x1

	// CSCR0: Chip Select Control Register
	// Position of BSTW field.
	FB_CSCR_BSTW_Pos = 0x3
	// Bit mask of BSTW field.
	FB_CSCR_BSTW_Msk = 0x8
	// Bit BSTW.
	FB_CSCR_BSTW = 0x8
	// Disabled. Data exceeding the specified port size is broken into individual, port-sized, non-burst writes. For example, a 32-bit write to an 8-bit port takes four byte writes.
	FB_CSCR_BSTW_0 = 0x0
	// Enabled. Enables burst write of data larger than the specified port size, including 32-bit writes to 8- and 16-bit ports, 16-bit writes to 8-bit ports, and line writes to 8-, 16-, and 32-bit ports.
	FB_CSCR_BSTW_1 = 0x1
	// Position of BSTR field.
	FB_CSCR_BSTR_Pos = 0x4
	// Bit mask of BSTR field.
	FB_CSCR_BSTR_Msk = 0x10
	// Bit BSTR.
	FB_CSCR_BSTR = 0x10
	// Disabled. Data exceeding the specified port size is broken into individual, port-sized, non-burst reads. For example, a 32-bit read from an 8-bit port is broken into four 8-bit reads.
	FB_CSCR_BSTR_0 = 0x0
	// Enabled. Enables data burst reads larger than the specified port size, including 32-bit reads from 8- and 16-bit ports, 16-bit reads from 8-bit ports, and line reads from 8-, 16-, and 32-bit ports.
	FB_CSCR_BSTR_1 = 0x1
	// Position of BEM field.
	FB_CSCR_BEM_Pos = 0x5
	// Bit mask of BEM field.
	FB_CSCR_BEM_Msk = 0x20
	// Bit BEM.
	FB_CSCR_BEM = 0x20
	// FB_BE is asserted for data write only.
	FB_CSCR_BEM_0 = 0x0
	// FB_BE is asserted for data read and write accesses.
	FB_CSCR_BEM_1 = 0x1
	// Position of PS field.
	FB_CSCR_PS_Pos = 0x6
	// Bit mask of PS field.
	FB_CSCR_PS_Msk = 0xc0
	// 32-bit port size. Valid data is sampled and driven on FB_D[31:0].
	FB_CSCR_PS_00 = 0x0
	// 8-bit port size. Valid data is sampled and driven on FB_D[31:24] when BLS is 0b, or FB_D[7:0] when BLS is 1b.
	FB_CSCR_PS_01 = 0x1
	// Position of AA field.
	FB_CSCR_AA_Pos = 0x8
	// Bit mask of AA field.
	FB_CSCR_AA_Msk = 0x100
	// Bit AA.
	FB_CSCR_AA = 0x100
	// Disabled. No internal transfer acknowledge is asserted and the cycle is terminated externally.
	FB_CSCR_AA_0 = 0x0
	// Enabled. Internal transfer acknowledge is asserted as specified by WS.
	FB_CSCR_AA_1 = 0x1
	// Position of BLS field.
	FB_CSCR_BLS_Pos = 0x9
	// Bit mask of BLS field.
	FB_CSCR_BLS_Msk = 0x200
	// Bit BLS.
	FB_CSCR_BLS = 0x200
	// Not shifted. Data is left-aligned on FB_AD.
	FB_CSCR_BLS_0 = 0x0
	// Shifted. Data is right-aligned on FB_AD.
	FB_CSCR_BLS_1 = 0x1
	// Position of WS field.
	FB_CSCR_WS_Pos = 0xa
	// Bit mask of WS field.
	FB_CSCR_WS_Msk = 0xfc00
	// Position of WRAH field.
	FB_CSCR_WRAH_Pos = 0x10
	// Bit mask of WRAH field.
	FB_CSCR_WRAH_Msk = 0x30000
	// 1 cycle (default for all but FB_CS0 )
	FB_CSCR_WRAH_00 = 0x0
	// 2 cycles
	FB_CSCR_WRAH_01 = 0x1
	// 3 cycles
	FB_CSCR_WRAH_10 = 0x2
	// 4 cycles (default for FB_CS0 )
	FB_CSCR_WRAH_11 = 0x3
	// Position of RDAH field.
	FB_CSCR_RDAH_Pos = 0x12
	// Bit mask of RDAH field.
	FB_CSCR_RDAH_Msk = 0xc0000
	// When AA is 1b, 1 cycle. When AA is 0b, 0 cycles.
	FB_CSCR_RDAH_00 = 0x0
	// When AA is 1b, 2 cycles. When AA is 0b, 1 cycle.
	FB_CSCR_RDAH_01 = 0x1
	// When AA is 1b, 3 cycles. When AA is 0b, 2 cycles.
	FB_CSCR_RDAH_10 = 0x2
	// When AA is 1b, 4 cycles. When AA is 0b, 3 cycles.
	FB_CSCR_RDAH_11 = 0x3
	// Position of ASET field.
	FB_CSCR_ASET_Pos = 0x14
	// Bit mask of ASET field.
	FB_CSCR_ASET_Msk = 0x300000
	// Assert FB_CSn on the first rising clock edge after the address is asserted (default for all but FB_CS0 ).
	FB_CSCR_ASET_00 = 0x0
	// Assert FB_CSn on the second rising clock edge after the address is asserted.
	FB_CSCR_ASET_01 = 0x1
	// Assert FB_CSn on the third rising clock edge after the address is asserted.
	FB_CSCR_ASET_10 = 0x2
	// Assert FB_CSn on the fourth rising clock edge after the address is asserted (default for FB_CS0 ).
	FB_CSCR_ASET_11 = 0x3
	// Position of EXTS field.
	FB_CSCR_EXTS_Pos = 0x16
	// Bit mask of EXTS field.
	FB_CSCR_EXTS_Msk = 0x400000
	// Bit EXTS.
	FB_CSCR_EXTS = 0x400000
	// Disabled. FB_TS /FB_ALE asserts for one bus clock cycle.
	FB_CSCR_EXTS_0 = 0x0
	// Enabled. FB_TS /FB_ALE remains asserted until the first positive clock edge after FB_CSn asserts.
	FB_CSCR_EXTS_1 = 0x1
	// Position of SWSEN field.
	FB_CSCR_SWSEN_Pos = 0x17
	// Bit mask of SWSEN field.
	FB_CSCR_SWSEN_Msk = 0x800000
	// Bit SWSEN.
	FB_CSCR_SWSEN = 0x800000
	// Disabled. A number of wait states (specified by WS) are inserted before an internal transfer acknowledge is generated for all transfers.
	FB_CSCR_SWSEN_0 = 0x0
	// Enabled. A number of wait states (specified by SWS) are inserted before an internal transfer acknowledge is generated for burst transfer secondary terminations.
	FB_CSCR_SWSEN_1 = 0x1
	// Position of SWS field.
	FB_CSCR_SWS_Pos = 0x1a
	// Bit mask of SWS field.
	FB_CSCR_SWS_Msk = 0xfc000000

	// CSPMCR: Chip Select port Multiplexing Control Register
	// Position of GROUP5 field.
	FB_CSPMCR_GROUP5_Pos = 0xc
	// Bit mask of GROUP5 field.
	FB_CSPMCR_GROUP5_Msk = 0xf000
	// FB_TA
	FB_CSPMCR_GROUP5_0000 = 0x0
	// FB_CS3 . You must also write 1b to CSCR[AA].
	FB_CSPMCR_GROUP5_0001 = 0x1
	// FB_BE_7_0 . You must also write 1b to CSCR[AA].
	FB_CSPMCR_GROUP5_0010 = 0x2
	// Position of GROUP4 field.
	FB_CSPMCR_GROUP4_Pos = 0x10
	// Bit mask of GROUP4 field.
	FB_CSPMCR_GROUP4_Msk = 0xf0000
	// FB_TBST
	FB_CSPMCR_GROUP4_0000 = 0x0
	// FB_CS2
	FB_CSPMCR_GROUP4_0001 = 0x1
	// FB_BE_15_8
	FB_CSPMCR_GROUP4_0010 = 0x2
	// Position of GROUP3 field.
	FB_CSPMCR_GROUP3_Pos = 0x14
	// Bit mask of GROUP3 field.
	FB_CSPMCR_GROUP3_Msk = 0xf00000
	// FB_CS5
	FB_CSPMCR_GROUP3_0000 = 0x0
	// FB_TSIZ1
	FB_CSPMCR_GROUP3_0001 = 0x1
	// FB_BE_23_16
	FB_CSPMCR_GROUP3_0010 = 0x2
	// Position of GROUP2 field.
	FB_CSPMCR_GROUP2_Pos = 0x18
	// Bit mask of GROUP2 field.
	FB_CSPMCR_GROUP2_Msk = 0xf000000
	// FB_CS4
	FB_CSPMCR_GROUP2_0000 = 0x0
	// FB_TSIZ0
	FB_CSPMCR_GROUP2_0001 = 0x1
	// FB_BE_31_24
	FB_CSPMCR_GROUP2_0010 = 0x2
	// Position of GROUP1 field.
	FB_CSPMCR_GROUP1_Pos = 0x1c
	// Bit mask of GROUP1 field.
	FB_CSPMCR_GROUP1_Msk = 0xf0000000
	// FB_ALE
	FB_CSPMCR_GROUP1_0000 = 0x0
	// FB_CS1
	FB_CSPMCR_GROUP1_0001 = 0x1
	// FB_TS
	FB_CSPMCR_GROUP1_0010 = 0x2
)

// Constants for SYSMPU: Memory protection unit
const (
	// CESR: Control/Error Status Register
	// Position of VLD field.
	SYSMPU_CESR_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SYSMPU_CESR_VLD_Msk = 0x1
	// Bit VLD.
	SYSMPU_CESR_VLD = 0x1
	// MPU is disabled. All accesses from all bus masters are allowed.
	SYSMPU_CESR_VLD_0 = 0x0
	// MPU is enabled
	SYSMPU_CESR_VLD_1 = 0x1
	// Position of NRGD field.
	SYSMPU_CESR_NRGD_Pos = 0x8
	// Bit mask of NRGD field.
	SYSMPU_CESR_NRGD_Msk = 0xf00
	// 8 region descriptors
	SYSMPU_CESR_NRGD_0000 = 0x0
	// 12 region descriptors
	SYSMPU_CESR_NRGD_0001 = 0x1
	// 16 region descriptors
	SYSMPU_CESR_NRGD_0010 = 0x2
	// Position of NSP field.
	SYSMPU_CESR_NSP_Pos = 0xc
	// Bit mask of NSP field.
	SYSMPU_CESR_NSP_Msk = 0xf000
	// Position of HRL field.
	SYSMPU_CESR_HRL_Pos = 0x10
	// Bit mask of HRL field.
	SYSMPU_CESR_HRL_Msk = 0xf0000
	// Position of SPERR field.
	SYSMPU_CESR_SPERR_Pos = 0x1b
	// Bit mask of SPERR field.
	SYSMPU_CESR_SPERR_Msk = 0xf8000000
	// No error has occurred for slave port n.
	SYSMPU_CESR_SPERR_0 = 0x0
	// An error has occurred for slave port n.
	SYSMPU_CESR_SPERR_1 = 0x1

	// EAR0: Error Address Register, slave port n
	// Position of EADDR field.
	SYSMPU_EAR_EADDR_Pos = 0x0
	// Bit mask of EADDR field.
	SYSMPU_EAR_EADDR_Msk = 0xffffffff

	// EDR0: Error Detail Register, slave port n
	// Position of ERW field.
	SYSMPU_EDR_ERW_Pos = 0x0
	// Bit mask of ERW field.
	SYSMPU_EDR_ERW_Msk = 0x1
	// Bit ERW.
	SYSMPU_EDR_ERW = 0x1
	// Read
	SYSMPU_EDR_ERW_0 = 0x0
	// Write
	SYSMPU_EDR_ERW_1 = 0x1
	// Position of EATTR field.
	SYSMPU_EDR_EATTR_Pos = 0x1
	// Bit mask of EATTR field.
	SYSMPU_EDR_EATTR_Msk = 0xe
	// User mode, instruction access
	SYSMPU_EDR_EATTR_000 = 0x0
	// User mode, data access
	SYSMPU_EDR_EATTR_001 = 0x1
	// Supervisor mode, instruction access
	SYSMPU_EDR_EATTR_010 = 0x2
	// Supervisor mode, data access
	SYSMPU_EDR_EATTR_011 = 0x3
	// Position of EMN field.
	SYSMPU_EDR_EMN_Pos = 0x4
	// Bit mask of EMN field.
	SYSMPU_EDR_EMN_Msk = 0xf0
	// Position of EPID field.
	SYSMPU_EDR_EPID_Pos = 0x8
	// Bit mask of EPID field.
	SYSMPU_EDR_EPID_Msk = 0xff00
	// Position of EACD field.
	SYSMPU_EDR_EACD_Pos = 0x10
	// Bit mask of EACD field.
	SYSMPU_EDR_EACD_Msk = 0xffff0000

	// RGD0_WORD0: Region Descriptor n, Word 0
	// Position of SRTADDR field.
	SYSMPU_RGD_WORD0_SRTADDR_Pos = 0x5
	// Bit mask of SRTADDR field.
	SYSMPU_RGD_WORD0_SRTADDR_Msk = 0xffffffe0

	// RGD0_WORD1: Region Descriptor n, Word 1
	// Position of ENDADDR field.
	SYSMPU_RGD_WORD1_ENDADDR_Pos = 0x5
	// Bit mask of ENDADDR field.
	SYSMPU_RGD_WORD1_ENDADDR_Msk = 0xffffffe0

	// RGD0_WORD2: Region Descriptor n, Word 2
	// Position of M0UM field.
	SYSMPU_RGD_WORD2_M0UM_Pos = 0x0
	// Bit mask of M0UM field.
	SYSMPU_RGD_WORD2_M0UM_Msk = 0x7
	// Position of M0SM field.
	SYSMPU_RGD_WORD2_M0SM_Pos = 0x3
	// Bit mask of M0SM field.
	SYSMPU_RGD_WORD2_M0SM_Msk = 0x18
	// Position of M0PE field.
	SYSMPU_RGD_WORD2_M0PE_Pos = 0x5
	// Bit mask of M0PE field.
	SYSMPU_RGD_WORD2_M0PE_Msk = 0x20
	// Bit M0PE.
	SYSMPU_RGD_WORD2_M0PE = 0x20
	// Position of M1UM field.
	SYSMPU_RGD_WORD2_M1UM_Pos = 0x6
	// Bit mask of M1UM field.
	SYSMPU_RGD_WORD2_M1UM_Msk = 0x1c0
	// Position of M1SM field.
	SYSMPU_RGD_WORD2_M1SM_Pos = 0x9
	// Bit mask of M1SM field.
	SYSMPU_RGD_WORD2_M1SM_Msk = 0x600
	// Position of M1PE field.
	SYSMPU_RGD_WORD2_M1PE_Pos = 0xb
	// Bit mask of M1PE field.
	SYSMPU_RGD_WORD2_M1PE_Msk = 0x800
	// Bit M1PE.
	SYSMPU_RGD_WORD2_M1PE = 0x800
	// Position of M2UM field.
	SYSMPU_RGD_WORD2_M2UM_Pos = 0xc
	// Bit mask of M2UM field.
	SYSMPU_RGD_WORD2_M2UM_Msk = 0x7000
	// Position of M2SM field.
	SYSMPU_RGD_WORD2_M2SM_Pos = 0xf
	// Bit mask of M2SM field.
	SYSMPU_RGD_WORD2_M2SM_Msk = 0x18000
	// Position of M2PE field.
	SYSMPU_RGD_WORD2_M2PE_Pos = 0x11
	// Bit mask of M2PE field.
	SYSMPU_RGD_WORD2_M2PE_Msk = 0x20000
	// Bit M2PE.
	SYSMPU_RGD_WORD2_M2PE = 0x20000
	// Position of M3UM field.
	SYSMPU_RGD_WORD2_M3UM_Pos = 0x12
	// Bit mask of M3UM field.
	SYSMPU_RGD_WORD2_M3UM_Msk = 0x1c0000
	// An attempted access of that mode may be terminated with an access error (if not allowed by another descriptor) and the access not performed.
	SYSMPU_RGD_WORD2_M3UM_0 = 0x0
	// Allows the given access type to occur
	SYSMPU_RGD_WORD2_M3UM_1 = 0x1
	// Position of M3SM field.
	SYSMPU_RGD_WORD2_M3SM_Pos = 0x15
	// Bit mask of M3SM field.
	SYSMPU_RGD_WORD2_M3SM_Msk = 0x600000
	// r/w/x; read, write and execute allowed
	SYSMPU_RGD_WORD2_M3SM_00 = 0x0
	// r/x; read and execute allowed, but no write
	SYSMPU_RGD_WORD2_M3SM_01 = 0x1
	// r/w; read and write allowed, but no execute
	SYSMPU_RGD_WORD2_M3SM_10 = 0x2
	// Same as User mode defined in M3UM
	SYSMPU_RGD_WORD2_M3SM_11 = 0x3
	// Position of M3PE field.
	SYSMPU_RGD_WORD2_M3PE_Pos = 0x17
	// Bit mask of M3PE field.
	SYSMPU_RGD_WORD2_M3PE_Msk = 0x800000
	// Bit M3PE.
	SYSMPU_RGD_WORD2_M3PE = 0x800000
	// Do not include the process identifier in the evaluation
	SYSMPU_RGD_WORD2_M3PE_0 = 0x0
	// Include the process identifier and mask (RGDn_WORD3) in the region hit evaluation
	SYSMPU_RGD_WORD2_M3PE_1 = 0x1
	// Position of M4WE field.
	SYSMPU_RGD_WORD2_M4WE_Pos = 0x18
	// Bit mask of M4WE field.
	SYSMPU_RGD_WORD2_M4WE_Msk = 0x1000000
	// Bit M4WE.
	SYSMPU_RGD_WORD2_M4WE = 0x1000000
	// Bus master 4 writes terminate with an access error and the write is not performed
	SYSMPU_RGD_WORD2_M4WE_0 = 0x0
	// Bus master 4 writes allowed
	SYSMPU_RGD_WORD2_M4WE_1 = 0x1
	// Position of M4RE field.
	SYSMPU_RGD_WORD2_M4RE_Pos = 0x19
	// Bit mask of M4RE field.
	SYSMPU_RGD_WORD2_M4RE_Msk = 0x2000000
	// Bit M4RE.
	SYSMPU_RGD_WORD2_M4RE = 0x2000000
	// Bus master 4 reads terminate with an access error and the read is not performed
	SYSMPU_RGD_WORD2_M4RE_0 = 0x0
	// Bus master 4 reads allowed
	SYSMPU_RGD_WORD2_M4RE_1 = 0x1
	// Position of M5WE field.
	SYSMPU_RGD_WORD2_M5WE_Pos = 0x1a
	// Bit mask of M5WE field.
	SYSMPU_RGD_WORD2_M5WE_Msk = 0x4000000
	// Bit M5WE.
	SYSMPU_RGD_WORD2_M5WE = 0x4000000
	// Bus master 5 writes terminate with an access error and the write is not performed
	SYSMPU_RGD_WORD2_M5WE_0 = 0x0
	// Bus master 5 writes allowed
	SYSMPU_RGD_WORD2_M5WE_1 = 0x1
	// Position of M5RE field.
	SYSMPU_RGD_WORD2_M5RE_Pos = 0x1b
	// Bit mask of M5RE field.
	SYSMPU_RGD_WORD2_M5RE_Msk = 0x8000000
	// Bit M5RE.
	SYSMPU_RGD_WORD2_M5RE = 0x8000000
	// Bus master 5 reads terminate with an access error and the read is not performed
	SYSMPU_RGD_WORD2_M5RE_0 = 0x0
	// Bus master 5 reads allowed
	SYSMPU_RGD_WORD2_M5RE_1 = 0x1
	// Position of M6WE field.
	SYSMPU_RGD_WORD2_M6WE_Pos = 0x1c
	// Bit mask of M6WE field.
	SYSMPU_RGD_WORD2_M6WE_Msk = 0x10000000
	// Bit M6WE.
	SYSMPU_RGD_WORD2_M6WE = 0x10000000
	// Bus master 6 writes terminate with an access error and the write is not performed
	SYSMPU_RGD_WORD2_M6WE_0 = 0x0
	// Bus master 6 writes allowed
	SYSMPU_RGD_WORD2_M6WE_1 = 0x1
	// Position of M6RE field.
	SYSMPU_RGD_WORD2_M6RE_Pos = 0x1d
	// Bit mask of M6RE field.
	SYSMPU_RGD_WORD2_M6RE_Msk = 0x20000000
	// Bit M6RE.
	SYSMPU_RGD_WORD2_M6RE = 0x20000000
	// Bus master 6 reads terminate with an access error and the read is not performed
	SYSMPU_RGD_WORD2_M6RE_0 = 0x0
	// Bus master 6 reads allowed
	SYSMPU_RGD_WORD2_M6RE_1 = 0x1
	// Position of M7WE field.
	SYSMPU_RGD_WORD2_M7WE_Pos = 0x1e
	// Bit mask of M7WE field.
	SYSMPU_RGD_WORD2_M7WE_Msk = 0x40000000
	// Bit M7WE.
	SYSMPU_RGD_WORD2_M7WE = 0x40000000
	// Bus master 7 writes terminate with an access error and the write is not performed
	SYSMPU_RGD_WORD2_M7WE_0 = 0x0
	// Bus master 7 writes allowed
	SYSMPU_RGD_WORD2_M7WE_1 = 0x1
	// Position of M7RE field.
	SYSMPU_RGD_WORD2_M7RE_Pos = 0x1f
	// Bit mask of M7RE field.
	SYSMPU_RGD_WORD2_M7RE_Msk = 0x80000000
	// Bit M7RE.
	SYSMPU_RGD_WORD2_M7RE = 0x80000000
	// Bus master 7 reads terminate with an access error and the read is not performed
	SYSMPU_RGD_WORD2_M7RE_0 = 0x0
	// Bus master 7 reads allowed
	SYSMPU_RGD_WORD2_M7RE_1 = 0x1

	// RGD0_WORD3: Region Descriptor n, Word 3
	// Position of VLD field.
	SYSMPU_RGD_WORD3_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SYSMPU_RGD_WORD3_VLD_Msk = 0x1
	// Bit VLD.
	SYSMPU_RGD_WORD3_VLD = 0x1
	// Region descriptor is invalid
	SYSMPU_RGD_WORD3_VLD_0 = 0x0
	// Region descriptor is valid
	SYSMPU_RGD_WORD3_VLD_1 = 0x1
	// Position of PIDMASK field.
	SYSMPU_RGD_WORD3_PIDMASK_Pos = 0x10
	// Bit mask of PIDMASK field.
	SYSMPU_RGD_WORD3_PIDMASK_Msk = 0xff0000
	// Position of PID field.
	SYSMPU_RGD_WORD3_PID_Pos = 0x18
	// Bit mask of PID field.
	SYSMPU_RGD_WORD3_PID_Msk = 0xff000000

	// RGDAAC0: Region Descriptor Alternate Access Control n
	// Position of M0UM field.
	SYSMPU_RGDAAC_M0UM_Pos = 0x0
	// Bit mask of M0UM field.
	SYSMPU_RGDAAC_M0UM_Msk = 0x7
	// Position of M0SM field.
	SYSMPU_RGDAAC_M0SM_Pos = 0x3
	// Bit mask of M0SM field.
	SYSMPU_RGDAAC_M0SM_Msk = 0x18
	// Position of M0PE field.
	SYSMPU_RGDAAC_M0PE_Pos = 0x5
	// Bit mask of M0PE field.
	SYSMPU_RGDAAC_M0PE_Msk = 0x20
	// Bit M0PE.
	SYSMPU_RGDAAC_M0PE = 0x20
	// Position of M1UM field.
	SYSMPU_RGDAAC_M1UM_Pos = 0x6
	// Bit mask of M1UM field.
	SYSMPU_RGDAAC_M1UM_Msk = 0x1c0
	// Position of M1SM field.
	SYSMPU_RGDAAC_M1SM_Pos = 0x9
	// Bit mask of M1SM field.
	SYSMPU_RGDAAC_M1SM_Msk = 0x600
	// Position of M1PE field.
	SYSMPU_RGDAAC_M1PE_Pos = 0xb
	// Bit mask of M1PE field.
	SYSMPU_RGDAAC_M1PE_Msk = 0x800
	// Bit M1PE.
	SYSMPU_RGDAAC_M1PE = 0x800
	// Position of M2UM field.
	SYSMPU_RGDAAC_M2UM_Pos = 0xc
	// Bit mask of M2UM field.
	SYSMPU_RGDAAC_M2UM_Msk = 0x7000
	// Position of M2SM field.
	SYSMPU_RGDAAC_M2SM_Pos = 0xf
	// Bit mask of M2SM field.
	SYSMPU_RGDAAC_M2SM_Msk = 0x18000
	// Position of M2PE field.
	SYSMPU_RGDAAC_M2PE_Pos = 0x11
	// Bit mask of M2PE field.
	SYSMPU_RGDAAC_M2PE_Msk = 0x20000
	// Bit M2PE.
	SYSMPU_RGDAAC_M2PE = 0x20000
	// Position of M3UM field.
	SYSMPU_RGDAAC_M3UM_Pos = 0x12
	// Bit mask of M3UM field.
	SYSMPU_RGDAAC_M3UM_Msk = 0x1c0000
	// An attempted access of that mode may be terminated with an access error (if not allowed by another descriptor) and the access not performed.
	SYSMPU_RGDAAC_M3UM_0 = 0x0
	// Allows the given access type to occur
	SYSMPU_RGDAAC_M3UM_1 = 0x1
	// Position of M3SM field.
	SYSMPU_RGDAAC_M3SM_Pos = 0x15
	// Bit mask of M3SM field.
	SYSMPU_RGDAAC_M3SM_Msk = 0x600000
	// r/w/x; read, write and execute allowed
	SYSMPU_RGDAAC_M3SM_00 = 0x0
	// r/x; read and execute allowed, but no write
	SYSMPU_RGDAAC_M3SM_01 = 0x1
	// r/w; read and write allowed, but no execute
	SYSMPU_RGDAAC_M3SM_10 = 0x2
	// Same as User mode defined in M3UM
	SYSMPU_RGDAAC_M3SM_11 = 0x3
	// Position of M3PE field.
	SYSMPU_RGDAAC_M3PE_Pos = 0x17
	// Bit mask of M3PE field.
	SYSMPU_RGDAAC_M3PE_Msk = 0x800000
	// Bit M3PE.
	SYSMPU_RGDAAC_M3PE = 0x800000
	// Do not include the process identifier in the evaluation
	SYSMPU_RGDAAC_M3PE_0 = 0x0
	// Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
	SYSMPU_RGDAAC_M3PE_1 = 0x1
	// Position of M4WE field.
	SYSMPU_RGDAAC_M4WE_Pos = 0x18
	// Bit mask of M4WE field.
	SYSMPU_RGDAAC_M4WE_Msk = 0x1000000
	// Bit M4WE.
	SYSMPU_RGDAAC_M4WE = 0x1000000
	// Bus master 4 writes terminate with an access error and the write is not performed
	SYSMPU_RGDAAC_M4WE_0 = 0x0
	// Bus master 4 writes allowed
	SYSMPU_RGDAAC_M4WE_1 = 0x1
	// Position of M4RE field.
	SYSMPU_RGDAAC_M4RE_Pos = 0x19
	// Bit mask of M4RE field.
	SYSMPU_RGDAAC_M4RE_Msk = 0x2000000
	// Bit M4RE.
	SYSMPU_RGDAAC_M4RE = 0x2000000
	// Bus master 4 reads terminate with an access error and the read is not performed
	SYSMPU_RGDAAC_M4RE_0 = 0x0
	// Bus master 4 reads allowed
	SYSMPU_RGDAAC_M4RE_1 = 0x1
	// Position of M5WE field.
	SYSMPU_RGDAAC_M5WE_Pos = 0x1a
	// Bit mask of M5WE field.
	SYSMPU_RGDAAC_M5WE_Msk = 0x4000000
	// Bit M5WE.
	SYSMPU_RGDAAC_M5WE = 0x4000000
	// Bus master 5 writes terminate with an access error and the write is not performed
	SYSMPU_RGDAAC_M5WE_0 = 0x0
	// Bus master 5 writes allowed
	SYSMPU_RGDAAC_M5WE_1 = 0x1
	// Position of M5RE field.
	SYSMPU_RGDAAC_M5RE_Pos = 0x1b
	// Bit mask of M5RE field.
	SYSMPU_RGDAAC_M5RE_Msk = 0x8000000
	// Bit M5RE.
	SYSMPU_RGDAAC_M5RE = 0x8000000
	// Bus master 5 reads terminate with an access error and the read is not performed
	SYSMPU_RGDAAC_M5RE_0 = 0x0
	// Bus master 5 reads allowed
	SYSMPU_RGDAAC_M5RE_1 = 0x1
	// Position of M6WE field.
	SYSMPU_RGDAAC_M6WE_Pos = 0x1c
	// Bit mask of M6WE field.
	SYSMPU_RGDAAC_M6WE_Msk = 0x10000000
	// Bit M6WE.
	SYSMPU_RGDAAC_M6WE = 0x10000000
	// Bus master 6 writes terminate with an access error and the write is not performed
	SYSMPU_RGDAAC_M6WE_0 = 0x0
	// Bus master 6 writes allowed
	SYSMPU_RGDAAC_M6WE_1 = 0x1
	// Position of M6RE field.
	SYSMPU_RGDAAC_M6RE_Pos = 0x1d
	// Bit mask of M6RE field.
	SYSMPU_RGDAAC_M6RE_Msk = 0x20000000
	// Bit M6RE.
	SYSMPU_RGDAAC_M6RE = 0x20000000
	// Bus master 6 reads terminate with an access error and the read is not performed
	SYSMPU_RGDAAC_M6RE_0 = 0x0
	// Bus master 6 reads allowed
	SYSMPU_RGDAAC_M6RE_1 = 0x1
	// Position of M7WE field.
	SYSMPU_RGDAAC_M7WE_Pos = 0x1e
	// Bit mask of M7WE field.
	SYSMPU_RGDAAC_M7WE_Msk = 0x40000000
	// Bit M7WE.
	SYSMPU_RGDAAC_M7WE = 0x40000000
	// Bus master 7 writes terminate with an access error and the write is not performed
	SYSMPU_RGDAAC_M7WE_0 = 0x0
	// Bus master 7 writes allowed
	SYSMPU_RGDAAC_M7WE_1 = 0x1
	// Position of M7RE field.
	SYSMPU_RGDAAC_M7RE_Pos = 0x1f
	// Bit mask of M7RE field.
	SYSMPU_RGDAAC_M7RE_Msk = 0x80000000
	// Bit M7RE.
	SYSMPU_RGDAAC_M7RE = 0x80000000
	// Bus master 7 reads terminate with an access error and the read is not performed
	SYSMPU_RGDAAC_M7RE_0 = 0x0
	// Bus master 7 reads allowed
	SYSMPU_RGDAAC_M7RE_1 = 0x1
)

// Constants for SDRAM: Synchronous DRAM Controller
const (
	// CTRL: Control Register
	// Position of RC field.
	SDRAM_CTRL_RC_Pos = 0x0
	// Bit mask of RC field.
	SDRAM_CTRL_RC_Msk = 0x1ff
	// Position of RTIM field.
	SDRAM_CTRL_RTIM_Pos = 0x9
	// Bit mask of RTIM field.
	SDRAM_CTRL_RTIM_Msk = 0x600
	// 3 clocks
	SDRAM_CTRL_RTIM_00 = 0x0
	// 6 clocks
	SDRAM_CTRL_RTIM_01 = 0x1
	// 9 clocks
	SDRAM_CTRL_RTIM_10 = 0x2
	// 9 clocks
	SDRAM_CTRL_RTIM_11 = 0x3
	// Position of IS field.
	SDRAM_CTRL_IS_Pos = 0xb
	// Bit mask of IS field.
	SDRAM_CTRL_IS_Msk = 0x800
	// Bit IS.
	SDRAM_CTRL_IS = 0x800
	// Take no action or issue a selfx command to exit self refresh.
	SDRAM_CTRL_IS_0 = 0x0
	// SDRAM controller sends a self command to both SDRAM blocks to put them in low-power, self-refresh state where they remain until IS is cleared. When IS is cleared, the controller sends a selfx command for the SDRAMs to exit self-refresh. The refresh counter is suspended while the SDRAMs are in self-refresh; the SDRAM controls the refresh period.
	SDRAM_CTRL_IS_1 = 0x1

	// AC0: Address and Control Register
	// Position of IP field.
	SDRAM_AC_IP_Pos = 0x3
	// Bit mask of IP field.
	SDRAM_AC_IP_Msk = 0x8
	// Bit IP.
	SDRAM_AC_IP = 0x8
	// Take no action.
	SDRAM_AC_IP_0 = 0x0
	// A pall command is sent to the associated SDRAM block. During initialization, this command is executed after all DRAM controller registers are programmed. After IP is set, the next write to an appropriate SDRAM address generates the pall command to the SDRAM block.
	SDRAM_AC_IP_1 = 0x1
	// Position of PS field.
	SDRAM_AC_PS_Pos = 0x4
	// Bit mask of PS field.
	SDRAM_AC_PS_Msk = 0x30
	// 32-bit port
	SDRAM_AC_PS_00 = 0x0
	// 8-bit port
	SDRAM_AC_PS_01 = 0x1
	// 16-bit port
	SDRAM_AC_PS_10 = 0x2
	// 16-bit port
	SDRAM_AC_PS_11 = 0x3
	// Position of IMRS field.
	SDRAM_AC_IMRS_Pos = 0x6
	// Bit mask of IMRS field.
	SDRAM_AC_IMRS_Msk = 0x40
	// Bit IMRS.
	SDRAM_AC_IMRS = 0x40
	// Take no action
	SDRAM_AC_IMRS_0 = 0x0
	// Initiate mrs command
	SDRAM_AC_IMRS_1 = 0x1
	// Position of CBM field.
	SDRAM_AC_CBM_Pos = 0x8
	// Bit mask of CBM field.
	SDRAM_AC_CBM_Msk = 0x700
	// Position of CASL field.
	SDRAM_AC_CASL_Pos = 0xc
	// Bit mask of CASL field.
	SDRAM_AC_CASL_Msk = 0x3000
	// Position of RE field.
	SDRAM_AC_RE_Pos = 0xf
	// Bit mask of RE field.
	SDRAM_AC_RE_Msk = 0x8000
	// Bit RE.
	SDRAM_AC_RE = 0x8000
	// Do not refresh associated DRAM block
	SDRAM_AC_RE_0 = 0x0
	// Refresh associated DRAM block
	SDRAM_AC_RE_1 = 0x1
	// Position of BA field.
	SDRAM_AC_BA_Pos = 0x12
	// Bit mask of BA field.
	SDRAM_AC_BA_Msk = 0xfffc0000

	// CM0: Control Mask
	// Position of V field.
	SDRAM_CM_V_Pos = 0x0
	// Bit mask of V field.
	SDRAM_CM_V_Msk = 0x1
	// Bit V.
	SDRAM_CM_V = 0x1
	// Do not decode DRAM accesses.
	SDRAM_CM_V_0 = 0x0
	// Registers controlling the DRAM block are initialized; DRAM accesses can be decoded
	SDRAM_CM_V_1 = 0x1
	// Position of WP field.
	SDRAM_CM_WP_Pos = 0x8
	// Bit mask of WP field.
	SDRAM_CM_WP_Msk = 0x100
	// Bit WP.
	SDRAM_CM_WP = 0x100
	// Allow write accesses
	SDRAM_CM_WP_0 = 0x0
	// Ignore write accesses. The DRAM controller ignores write accesses to the memory block and an address exception occurs. Write accesses to a write-protected DRAM region are compared in the chip select module for a hit. If no hit occurs, an external bus cycle is generated. If this external bus cycle is not acknowledged, an access exception occurs.
	SDRAM_CM_WP_1 = 0x1
	// Position of BAM field.
	SDRAM_CM_BAM_Pos = 0x12
	// Bit mask of BAM field.
	SDRAM_CM_BAM_Msk = 0xfffc0000
	// The associated address bit is used in decoding the DRAM hit to a memory block
	SDRAM_CM_BAM_0 = 0x0
	// The associated address bit is not used in the DRAM hit decode
	SDRAM_CM_BAM_1 = 0x1
)

// Constants for FMC: Flash Memory Controller-greg
const (
	// PFAPR: Flash Access Protection Register
	// Position of M0AP field.
	FMC_PFAPR_M0AP_Pos = 0x0
	// Bit mask of M0AP field.
	FMC_PFAPR_M0AP_Msk = 0x3
	// No access may be performed by this master
	FMC_PFAPR_M0AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M0AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M0AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M0AP_11 = 0x3
	// Position of M1AP field.
	FMC_PFAPR_M1AP_Pos = 0x2
	// Bit mask of M1AP field.
	FMC_PFAPR_M1AP_Msk = 0xc
	// No access may be performed by this master
	FMC_PFAPR_M1AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M1AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M1AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M1AP_11 = 0x3
	// Position of M2AP field.
	FMC_PFAPR_M2AP_Pos = 0x4
	// Bit mask of M2AP field.
	FMC_PFAPR_M2AP_Msk = 0x30
	// No access may be performed by this master
	FMC_PFAPR_M2AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M2AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M2AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M2AP_11 = 0x3
	// Position of M3AP field.
	FMC_PFAPR_M3AP_Pos = 0x6
	// Bit mask of M3AP field.
	FMC_PFAPR_M3AP_Msk = 0xc0
	// No access may be performed by this master
	FMC_PFAPR_M3AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M3AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M3AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M3AP_11 = 0x3
	// Position of M4AP field.
	FMC_PFAPR_M4AP_Pos = 0x8
	// Bit mask of M4AP field.
	FMC_PFAPR_M4AP_Msk = 0x300
	// No access may be performed by this master
	FMC_PFAPR_M4AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M4AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M4AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M4AP_11 = 0x3
	// Position of M5AP field.
	FMC_PFAPR_M5AP_Pos = 0xa
	// Bit mask of M5AP field.
	FMC_PFAPR_M5AP_Msk = 0xc00
	// No access may be performed by this master
	FMC_PFAPR_M5AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M5AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M5AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M5AP_11 = 0x3
	// Position of M6AP field.
	FMC_PFAPR_M6AP_Pos = 0xc
	// Bit mask of M6AP field.
	FMC_PFAPR_M6AP_Msk = 0x3000
	// No access may be performed by this master
	FMC_PFAPR_M6AP_00 = 0x0
	// Only read accesses may be performed by this master
	FMC_PFAPR_M6AP_01 = 0x1
	// Only write accesses may be performed by this master
	FMC_PFAPR_M6AP_10 = 0x2
	// Both read and write accesses may be performed by this master
	FMC_PFAPR_M6AP_11 = 0x3
	// Position of M7AP field.
	FMC_PFAPR_M7AP_Pos = 0xe
	// Bit mask of M7AP field.
	FMC_PFAPR_M7AP_Msk = 0xc000
	// No access may be performed by this master.
	FMC_PFAPR_M7AP_00 = 0x0
	// Only read accesses may be performed by this master.
	FMC_PFAPR_M7AP_01 = 0x1
	// Only write accesses may be performed by this master.
	FMC_PFAPR_M7AP_10 = 0x2
	// Both read and write accesses may be performed by this master.
	FMC_PFAPR_M7AP_11 = 0x3
	// Position of M0PFD field.
	FMC_PFAPR_M0PFD_Pos = 0x10
	// Bit mask of M0PFD field.
	FMC_PFAPR_M0PFD_Msk = 0x10000
	// Bit M0PFD.
	FMC_PFAPR_M0PFD = 0x10000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M0PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M0PFD_1 = 0x1
	// Position of M1PFD field.
	FMC_PFAPR_M1PFD_Pos = 0x11
	// Bit mask of M1PFD field.
	FMC_PFAPR_M1PFD_Msk = 0x20000
	// Bit M1PFD.
	FMC_PFAPR_M1PFD = 0x20000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M1PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M1PFD_1 = 0x1
	// Position of M2PFD field.
	FMC_PFAPR_M2PFD_Pos = 0x12
	// Bit mask of M2PFD field.
	FMC_PFAPR_M2PFD_Msk = 0x40000
	// Bit M2PFD.
	FMC_PFAPR_M2PFD = 0x40000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M2PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M2PFD_1 = 0x1
	// Position of M3PFD field.
	FMC_PFAPR_M3PFD_Pos = 0x13
	// Bit mask of M3PFD field.
	FMC_PFAPR_M3PFD_Msk = 0x80000
	// Bit M3PFD.
	FMC_PFAPR_M3PFD = 0x80000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M3PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M3PFD_1 = 0x1
	// Position of M4PFD field.
	FMC_PFAPR_M4PFD_Pos = 0x14
	// Bit mask of M4PFD field.
	FMC_PFAPR_M4PFD_Msk = 0x100000
	// Bit M4PFD.
	FMC_PFAPR_M4PFD = 0x100000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M4PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M4PFD_1 = 0x1
	// Position of M5PFD field.
	FMC_PFAPR_M5PFD_Pos = 0x15
	// Bit mask of M5PFD field.
	FMC_PFAPR_M5PFD_Msk = 0x200000
	// Bit M5PFD.
	FMC_PFAPR_M5PFD = 0x200000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M5PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M5PFD_1 = 0x1
	// Position of M6PFD field.
	FMC_PFAPR_M6PFD_Pos = 0x16
	// Bit mask of M6PFD field.
	FMC_PFAPR_M6PFD_Msk = 0x400000
	// Bit M6PFD.
	FMC_PFAPR_M6PFD = 0x400000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M6PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M6PFD_1 = 0x1
	// Position of M7PFD field.
	FMC_PFAPR_M7PFD_Pos = 0x17
	// Bit mask of M7PFD field.
	FMC_PFAPR_M7PFD_Msk = 0x800000
	// Bit M7PFD.
	FMC_PFAPR_M7PFD = 0x800000
	// Prefetching for this master is enabled.
	FMC_PFAPR_M7PFD_0 = 0x0
	// Prefetching for this master is disabled.
	FMC_PFAPR_M7PFD_1 = 0x1

	// PFB01CR: Flash Bank 0-1 Control Register
	// Position of RFU field.
	FMC_PFB01CR_RFU_Pos = 0x0
	// Bit mask of RFU field.
	FMC_PFB01CR_RFU_Msk = 0x1
	// Bit RFU.
	FMC_PFB01CR_RFU = 0x1
	// Position of B0IPE field.
	FMC_PFB01CR_B0IPE_Pos = 0x1
	// Bit mask of B0IPE field.
	FMC_PFB01CR_B0IPE_Msk = 0x2
	// Bit B0IPE.
	FMC_PFB01CR_B0IPE = 0x2
	// Do not prefetch in response to instruction fetches.
	FMC_PFB01CR_B0IPE_0 = 0x0
	// Enable prefetches in response to instruction fetches.
	FMC_PFB01CR_B0IPE_1 = 0x1
	// Position of B0DPE field.
	FMC_PFB01CR_B0DPE_Pos = 0x2
	// Bit mask of B0DPE field.
	FMC_PFB01CR_B0DPE_Msk = 0x4
	// Bit B0DPE.
	FMC_PFB01CR_B0DPE = 0x4
	// Do not prefetch in response to data references.
	FMC_PFB01CR_B0DPE_0 = 0x0
	// Enable prefetches in response to data references.
	FMC_PFB01CR_B0DPE_1 = 0x1
	// Position of B0ICE field.
	FMC_PFB01CR_B0ICE_Pos = 0x3
	// Bit mask of B0ICE field.
	FMC_PFB01CR_B0ICE_Msk = 0x8
	// Bit B0ICE.
	FMC_PFB01CR_B0ICE = 0x8
	// Do not cache instruction fetches.
	FMC_PFB01CR_B0ICE_0 = 0x0
	// Cache instruction fetches.
	FMC_PFB01CR_B0ICE_1 = 0x1
	// Position of B0DCE field.
	FMC_PFB01CR_B0DCE_Pos = 0x4
	// Bit mask of B0DCE field.
	FMC_PFB01CR_B0DCE_Msk = 0x10
	// Bit B0DCE.
	FMC_PFB01CR_B0DCE = 0x10
	// Do not cache data references.
	FMC_PFB01CR_B0DCE_0 = 0x0
	// Cache data references.
	FMC_PFB01CR_B0DCE_1 = 0x1
	// Position of CRC field.
	FMC_PFB01CR_CRC_Pos = 0x5
	// Bit mask of CRC field.
	FMC_PFB01CR_CRC_Msk = 0xe0
	// LRU replacement algorithm per set across all four ways
	FMC_PFB01CR_CRC_000 = 0x0
	// Independent LRU with ways [0-1] for ifetches, [2-3] for data
	FMC_PFB01CR_CRC_010 = 0x2
	// Independent LRU with ways [0-2] for ifetches, [3] for data
	FMC_PFB01CR_CRC_011 = 0x3
	// Position of B0MW field.
	FMC_PFB01CR_B0MW_Pos = 0x11
	// Bit mask of B0MW field.
	FMC_PFB01CR_B0MW_Msk = 0x60000
	// 32 bits
	FMC_PFB01CR_B0MW_00 = 0x0
	// 64 bits
	FMC_PFB01CR_B0MW_01 = 0x1
	// 128 bits
	FMC_PFB01CR_B0MW_10 = 0x2
	// Position of S_B_INV field.
	FMC_PFB01CR_S_B_INV_Pos = 0x13
	// Bit mask of S_B_INV field.
	FMC_PFB01CR_S_B_INV_Msk = 0x80000
	// Bit S_B_INV.
	FMC_PFB01CR_S_B_INV = 0x80000
	// Speculation buffer is not affected
	FMC_PFB01CR_S_B_INV_0 = 0x0
	// Invalidate (clear) speculation buffer
	FMC_PFB01CR_S_B_INV_1 = 0x1
	// Position of CINV_WAY field.
	FMC_PFB01CR_CINV_WAY_Pos = 0x14
	// Bit mask of CINV_WAY field.
	FMC_PFB01CR_CINV_WAY_Msk = 0xf00000
	// No cache way invalidation for the corresponding cache
	FMC_PFB01CR_CINV_WAY_0 = 0x0
	// Invalidate cache way for the corresponding cache: clear the tag, data, and vld bits of ways selected
	FMC_PFB01CR_CINV_WAY_1 = 0x1
	// Position of CLCK_WAY field.
	FMC_PFB01CR_CLCK_WAY_Pos = 0x18
	// Bit mask of CLCK_WAY field.
	FMC_PFB01CR_CLCK_WAY_Msk = 0xf000000
	// Cache way is unlocked and may be displaced
	FMC_PFB01CR_CLCK_WAY_0 = 0x0
	// Cache way is locked and its contents are not displaced
	FMC_PFB01CR_CLCK_WAY_1 = 0x1
	// Position of B0RWSC field.
	FMC_PFB01CR_B0RWSC_Pos = 0x1c
	// Bit mask of B0RWSC field.
	FMC_PFB01CR_B0RWSC_Msk = 0xf0000000

	// PFB23CR: Flash Bank 2-3 Control Register
	// Position of RFU field.
	FMC_PFB23CR_RFU_Pos = 0x0
	// Bit mask of RFU field.
	FMC_PFB23CR_RFU_Msk = 0x1
	// Bit RFU.
	FMC_PFB23CR_RFU = 0x1
	// Position of B1IPE field.
	FMC_PFB23CR_B1IPE_Pos = 0x1
	// Bit mask of B1IPE field.
	FMC_PFB23CR_B1IPE_Msk = 0x2
	// Bit B1IPE.
	FMC_PFB23CR_B1IPE = 0x2
	// Do not prefetch in response to instruction fetches.
	FMC_PFB23CR_B1IPE_0 = 0x0
	// Enable prefetches in response to instruction fetches.
	FMC_PFB23CR_B1IPE_1 = 0x1
	// Position of B1DPE field.
	FMC_PFB23CR_B1DPE_Pos = 0x2
	// Bit mask of B1DPE field.
	FMC_PFB23CR_B1DPE_Msk = 0x4
	// Bit B1DPE.
	FMC_PFB23CR_B1DPE = 0x4
	// Do not prefetch in response to data references.
	FMC_PFB23CR_B1DPE_0 = 0x0
	// Enable prefetches in response to data references.
	FMC_PFB23CR_B1DPE_1 = 0x1
	// Position of B1ICE field.
	FMC_PFB23CR_B1ICE_Pos = 0x3
	// Bit mask of B1ICE field.
	FMC_PFB23CR_B1ICE_Msk = 0x8
	// Bit B1ICE.
	FMC_PFB23CR_B1ICE = 0x8
	// Do not cache instruction fetches.
	FMC_PFB23CR_B1ICE_0 = 0x0
	// Cache instruction fetches.
	FMC_PFB23CR_B1ICE_1 = 0x1
	// Position of B1DCE field.
	FMC_PFB23CR_B1DCE_Pos = 0x4
	// Bit mask of B1DCE field.
	FMC_PFB23CR_B1DCE_Msk = 0x10
	// Bit B1DCE.
	FMC_PFB23CR_B1DCE = 0x10
	// Do not cache data references.
	FMC_PFB23CR_B1DCE_0 = 0x0
	// Cache data references.
	FMC_PFB23CR_B1DCE_1 = 0x1
	// Position of B1MW field.
	FMC_PFB23CR_B1MW_Pos = 0x11
	// Bit mask of B1MW field.
	FMC_PFB23CR_B1MW_Msk = 0x60000
	// 32 bits
	FMC_PFB23CR_B1MW_00 = 0x0
	// 64 bits
	FMC_PFB23CR_B1MW_01 = 0x1
	// 128 bits
	FMC_PFB23CR_B1MW_10 = 0x2
	// Position of B1RWSC field.
	FMC_PFB23CR_B1RWSC_Pos = 0x1c
	// Bit mask of B1RWSC field.
	FMC_PFB23CR_B1RWSC_Msk = 0xf0000000

	// TAGVDW0S0: Cache Tag Storage
	// Position of VALID field.
	FMC_TAGVDW0S_VALID_Pos = 0x0
	// Bit mask of VALID field.
	FMC_TAGVDW0S_VALID_Msk = 0x1
	// Bit VALID.
	FMC_TAGVDW0S_VALID = 0x1
	// Position of TAG field.
	FMC_TAGVDW0S_TAG_Pos = 0x6
	// Bit mask of TAG field.
	FMC_TAGVDW0S_TAG_Msk = 0x3fffc0

	// TAGVDW1S0: Cache Tag Storage
	// Position of VALID field.
	FMC_TAGVDW1S_VALID_Pos = 0x0
	// Bit mask of VALID field.
	FMC_TAGVDW1S_VALID_Msk = 0x1
	// Bit VALID.
	FMC_TAGVDW1S_VALID = 0x1
	// Position of TAG field.
	FMC_TAGVDW1S_TAG_Pos = 0x6
	// Bit mask of TAG field.
	FMC_TAGVDW1S_TAG_Msk = 0x3fffc0

	// TAGVDW2S0: Cache Tag Storage
	// Position of VALID field.
	FMC_TAGVDW2S_VALID_Pos = 0x0
	// Bit mask of VALID field.
	FMC_TAGVDW2S_VALID_Msk = 0x1
	// Bit VALID.
	FMC_TAGVDW2S_VALID = 0x1
	// Position of TAG field.
	FMC_TAGVDW2S_TAG_Pos = 0x6
	// Bit mask of TAG field.
	FMC_TAGVDW2S_TAG_Msk = 0x3fffc0

	// TAGVDW3S0: Cache Tag Storage
	// Position of VALID field.
	FMC_TAGVDW3S_VALID_Pos = 0x0
	// Bit mask of VALID field.
	FMC_TAGVDW3S_VALID_Msk = 0x1
	// Bit VALID.
	FMC_TAGVDW3S_VALID = 0x1
	// Position of TAG field.
	FMC_TAGVDW3S_TAG_Pos = 0x6
	// Bit mask of TAG field.
	FMC_TAGVDW3S_TAG_Msk = 0x3fffc0

	// DATAW0S0UM: Cache Data Storage (uppermost word)
	// Position of DATA field.
	FMC_DATAW0SUM_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW0SUM_DATA_Msk = 0xffffffff

	// DATAW0S0MU: Cache Data Storage (mid-upper word)
	// Position of DATA field.
	FMC_DATAW0SMU_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW0SMU_DATA_Msk = 0xffffffff

	// DATAW0S0ML: Cache Data Storage (mid-lower word)
	// Position of DATA field.
	FMC_DATAW0SML_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW0SML_DATA_Msk = 0xffffffff

	// DATAW0S0LM: Cache Data Storage (lowermost word)
	// Position of DATA field.
	FMC_DATAW0SLM_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW0SLM_DATA_Msk = 0xffffffff

	// DATAW1S0UM: Cache Data Storage (uppermost word)
	// Position of DATA field.
	FMC_DATAW1SUM_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW1SUM_DATA_Msk = 0xffffffff

	// DATAW1S0MU: Cache Data Storage (mid-upper word)
	// Position of DATA field.
	FMC_DATAW1SMU_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW1SMU_DATA_Msk = 0xffffffff

	// DATAW1S0ML: Cache Data Storage (mid-lower word)
	// Position of DATA field.
	FMC_DATAW1SML_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW1SML_DATA_Msk = 0xffffffff

	// DATAW1S0LM: Cache Data Storage (lowermost word)
	// Position of DATA field.
	FMC_DATAW1SLM_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW1SLM_DATA_Msk = 0xffffffff

	// DATAW2S0UM: Cache Data Storage (uppermost word)
	// Position of DATA field.
	FMC_DATAW2SUM_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW2SUM_DATA_Msk = 0xffffffff

	// DATAW2S0MU: Cache Data Storage (mid-upper word)
	// Position of DATA field.
	FMC_DATAW2SMU_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW2SMU_DATA_Msk = 0xffffffff

	// DATAW2S0ML: Cache Data Storage (mid-lower word)
	// Position of DATA field.
	FMC_DATAW2SML_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW2SML_DATA_Msk = 0xffffffff

	// DATAW2S0LM: Cache Data Storage (lowermost word)
	// Position of DATA field.
	FMC_DATAW2SLM_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW2SLM_DATA_Msk = 0xffffffff

	// DATAW3S0UM: Cache Data Storage (uppermost word)
	// Position of DATA field.
	FMC_DATAW3SUM_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW3SUM_DATA_Msk = 0xffffffff

	// DATAW3S0MU: Cache Data Storage (mid-upper word)
	// Position of DATA field.
	FMC_DATAW3SMU_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW3SMU_DATA_Msk = 0xffffffff

	// DATAW3S0ML: Cache Data Storage (mid-lower word)
	// Position of DATA field.
	FMC_DATAW3SML_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW3SML_DATA_Msk = 0xffffffff

	// DATAW3S0LM: Cache Data Storage (lowermost word)
	// Position of DATA field.
	FMC_DATAW3SLM_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FMC_DATAW3SLM_DATA_Msk = 0xffffffff
)

// Constants for FTFE: Flash Memory Interface
const (
	// FSTAT: Flash Status Register
	// Position of MGSTAT0 field.
	FTFE_FSTAT_MGSTAT0_Pos = 0x0
	// Bit mask of MGSTAT0 field.
	FTFE_FSTAT_MGSTAT0_Msk = 0x1
	// Bit MGSTAT0.
	FTFE_FSTAT_MGSTAT0 = 0x1
	// Position of FPVIOL field.
	FTFE_FSTAT_FPVIOL_Pos = 0x4
	// Bit mask of FPVIOL field.
	FTFE_FSTAT_FPVIOL_Msk = 0x10
	// Bit FPVIOL.
	FTFE_FSTAT_FPVIOL = 0x10
	// No protection violation detected
	FTFE_FSTAT_FPVIOL_0 = 0x0
	// Protection violation detected
	FTFE_FSTAT_FPVIOL_1 = 0x1
	// Position of ACCERR field.
	FTFE_FSTAT_ACCERR_Pos = 0x5
	// Bit mask of ACCERR field.
	FTFE_FSTAT_ACCERR_Msk = 0x20
	// Bit ACCERR.
	FTFE_FSTAT_ACCERR = 0x20
	// No access error detected
	FTFE_FSTAT_ACCERR_0 = 0x0
	// Access error detected
	FTFE_FSTAT_ACCERR_1 = 0x1
	// Position of RDCOLERR field.
	FTFE_FSTAT_RDCOLERR_Pos = 0x6
	// Bit mask of RDCOLERR field.
	FTFE_FSTAT_RDCOLERR_Msk = 0x40
	// Bit RDCOLERR.
	FTFE_FSTAT_RDCOLERR = 0x40
	// No collision error detected
	FTFE_FSTAT_RDCOLERR_0 = 0x0
	// Collision error detected
	FTFE_FSTAT_RDCOLERR_1 = 0x1
	// Position of CCIF field.
	FTFE_FSTAT_CCIF_Pos = 0x7
	// Bit mask of CCIF field.
	FTFE_FSTAT_CCIF_Msk = 0x80
	// Bit CCIF.
	FTFE_FSTAT_CCIF = 0x80
	// FTFE command or EEPROM file system operation in progress
	FTFE_FSTAT_CCIF_0 = 0x0
	// FTFE command or EEPROM file system operation has completed
	FTFE_FSTAT_CCIF_1 = 0x1

	// FCNFG: Flash Configuration Register
	// Position of EEERDY field.
	FTFE_FCNFG_EEERDY_Pos = 0x0
	// Bit mask of EEERDY field.
	FTFE_FCNFG_EEERDY_Msk = 0x1
	// Bit EEERDY.
	FTFE_FCNFG_EEERDY = 0x1
	// For devices with FlexNVM: FlexRAM is not available for EEPROM operation For devices without FlexNVM: See RAMRDY for availability of programming acceleration RAM
	FTFE_FCNFG_EEERDY_0 = 0x0
	// For devices with FlexNVM: FlexRAM is available for EEPROM operations where: reads from the FlexRAM return data previously written to the FlexRAM in EEPROM mode and writes launch an EEPROM operation to store the written data in the FlexRAM and EEPROM backup For devices without FlexNVM: Reserved
	FTFE_FCNFG_EEERDY_1 = 0x1
	// Position of RAMRDY field.
	FTFE_FCNFG_RAMRDY_Pos = 0x1
	// Bit mask of RAMRDY field.
	FTFE_FCNFG_RAMRDY_Msk = 0x2
	// Bit RAMRDY.
	FTFE_FCNFG_RAMRDY = 0x2
	// For devices with FlexNVM: FlexRAM is not available for traditional RAM access For devices without FlexNVM: Programming acceleration RAM is not available
	FTFE_FCNFG_RAMRDY_0 = 0x0
	// For devices with FlexNVM: FlexRAM is available as traditional RAM only; writes to the FlexRAM do not trigger EEPROM operations For devices without FlexNVM: Programming acceleration RAM is available
	FTFE_FCNFG_RAMRDY_1 = 0x1
	// Position of PFLSH field.
	FTFE_FCNFG_PFLSH_Pos = 0x2
	// Bit mask of PFLSH field.
	FTFE_FCNFG_PFLSH_Msk = 0x4
	// Bit PFLSH.
	FTFE_FCNFG_PFLSH = 0x4
	// For devices with FlexNVM: FTFE configuration supports two or three program flash blocks and two FlexNVM blocks For devices with program flash only: Reserved
	FTFE_FCNFG_PFLSH_0 = 0x0
	// For devices with FlexNVM: Reserved For devices with program flash only: FTFE configuration supports four program flash blocks
	FTFE_FCNFG_PFLSH_1 = 0x1
	// Position of SWAP field.
	FTFE_FCNFG_SWAP_Pos = 0x3
	// Bit mask of SWAP field.
	FTFE_FCNFG_SWAP_Msk = 0x8
	// Bit SWAP.
	FTFE_FCNFG_SWAP = 0x8
	// For devices with FlexNVM: Program flash 0 block is located at relative address 0x0000 For devices with program flash only: Program flash 0/1 blocks are located at relative address 0x0000
	FTFE_FCNFG_SWAP_0 = 0x0
	// For devices with FlexNVM: Reserved For devices with program flash only: Program flash 2/3 blocks are located at relative address 0x0000
	FTFE_FCNFG_SWAP_1 = 0x1
	// Position of ERSSUSP field.
	FTFE_FCNFG_ERSSUSP_Pos = 0x4
	// Bit mask of ERSSUSP field.
	FTFE_FCNFG_ERSSUSP_Msk = 0x10
	// Bit ERSSUSP.
	FTFE_FCNFG_ERSSUSP = 0x10
	// No suspend requested
	FTFE_FCNFG_ERSSUSP_0 = 0x0
	// Suspend the current Erase Flash Sector command execution
	FTFE_FCNFG_ERSSUSP_1 = 0x1
	// Position of ERSAREQ field.
	FTFE_FCNFG_ERSAREQ_Pos = 0x5
	// Bit mask of ERSAREQ field.
	FTFE_FCNFG_ERSAREQ_Msk = 0x20
	// Bit ERSAREQ.
	FTFE_FCNFG_ERSAREQ = 0x20
	// No request or request complete
	FTFE_FCNFG_ERSAREQ_0 = 0x0
	// Request to: run the Erase All Blocks command, verify the erased state, program the security byte in the Flash Configuration Field to the unsecure state, and release MCU security by setting the FSEC[SEC] field to the unsecure state
	FTFE_FCNFG_ERSAREQ_1 = 0x1
	// Position of RDCOLLIE field.
	FTFE_FCNFG_RDCOLLIE_Pos = 0x6
	// Bit mask of RDCOLLIE field.
	FTFE_FCNFG_RDCOLLIE_Msk = 0x40
	// Bit RDCOLLIE.
	FTFE_FCNFG_RDCOLLIE = 0x40
	// Read collision error interrupt disabled
	FTFE_FCNFG_RDCOLLIE_0 = 0x0
	// Read collision error interrupt enabled. An interrupt request is generated whenever an FTFE read collision error is detected (see the description of FSTAT[RDCOLERR]).
	FTFE_FCNFG_RDCOLLIE_1 = 0x1
	// Position of CCIE field.
	FTFE_FCNFG_CCIE_Pos = 0x7
	// Bit mask of CCIE field.
	FTFE_FCNFG_CCIE_Msk = 0x80
	// Bit CCIE.
	FTFE_FCNFG_CCIE = 0x80
	// Command complete interrupt disabled
	FTFE_FCNFG_CCIE_0 = 0x0
	// Command complete interrupt enabled. An interrupt request is generated whenever the FSTAT[CCIF] flag is set.
	FTFE_FCNFG_CCIE_1 = 0x1

	// FSEC: Flash Security Register
	// Position of SEC field.
	FTFE_FSEC_SEC_Pos = 0x0
	// Bit mask of SEC field.
	FTFE_FSEC_SEC_Msk = 0x3
	// MCU security status is secure
	FTFE_FSEC_SEC_00 = 0x0
	// MCU security status is secure
	FTFE_FSEC_SEC_01 = 0x1
	// MCU security status is unsecure (The standard shipping condition of the FTFE is unsecure.)
	FTFE_FSEC_SEC_10 = 0x2
	// MCU security status is secure
	FTFE_FSEC_SEC_11 = 0x3
	// Position of FSLACC field.
	FTFE_FSEC_FSLACC_Pos = 0x2
	// Bit mask of FSLACC field.
	FTFE_FSEC_FSLACC_Msk = 0xc
	// Freescale factory access granted
	FTFE_FSEC_FSLACC_00 = 0x0
	// Freescale factory access denied
	FTFE_FSEC_FSLACC_01 = 0x1
	// Freescale factory access denied
	FTFE_FSEC_FSLACC_10 = 0x2
	// Freescale factory access granted
	FTFE_FSEC_FSLACC_11 = 0x3
	// Position of MEEN field.
	FTFE_FSEC_MEEN_Pos = 0x4
	// Bit mask of MEEN field.
	FTFE_FSEC_MEEN_Msk = 0x30
	// Mass erase is enabled
	FTFE_FSEC_MEEN_00 = 0x0
	// Mass erase is enabled
	FTFE_FSEC_MEEN_01 = 0x1
	// Mass erase is disabled
	FTFE_FSEC_MEEN_10 = 0x2
	// Mass erase is enabled
	FTFE_FSEC_MEEN_11 = 0x3
	// Position of KEYEN field.
	FTFE_FSEC_KEYEN_Pos = 0x6
	// Bit mask of KEYEN field.
	FTFE_FSEC_KEYEN_Msk = 0xc0
	// Backdoor key access disabled
	FTFE_FSEC_KEYEN_00 = 0x0
	// Backdoor key access disabled (preferred KEYEN state to disable backdoor key access)
	FTFE_FSEC_KEYEN_01 = 0x1
	// Backdoor key access enabled
	FTFE_FSEC_KEYEN_10 = 0x2
	// Backdoor key access disabled
	FTFE_FSEC_KEYEN_11 = 0x3

	// FOPT: Flash Option Register
	// Position of OPT field.
	FTFE_FOPT_OPT_Pos = 0x0
	// Bit mask of OPT field.
	FTFE_FOPT_OPT_Msk = 0xff

	// FCCOB3: Flash Common Command Object Registers
	// Position of CCOBn field.
	FTFE_FCCOB_CCOBn_Pos = 0x0
	// Bit mask of CCOBn field.
	FTFE_FCCOB_CCOBn_Msk = 0xff

	// FPROT3: Program Flash Protection Registers
	// Position of PROT field.
	FTFE_FPROT_PROT_Pos = 0x0
	// Bit mask of PROT field.
	FTFE_FPROT_PROT_Msk = 0xff
	// Program flash region is protected.
	FTFE_FPROT_PROT_0 = 0x0
	// Program flash region is not protected
	FTFE_FPROT_PROT_1 = 0x1

	// FEPROT: EEPROM Protection Register
	// Position of EPROT field.
	FTFE_FEPROT_EPROT_Pos = 0x0
	// Bit mask of EPROT field.
	FTFE_FEPROT_EPROT_Msk = 0xff
	// For devices with program flash only: Reserved For devices with FlexNVM: EEPROM region is protected
	FTFE_FEPROT_EPROT_0 = 0x0
	// For devices with program flash only: Reserved For devices with FlexNVM: EEPROM region is not protected
	FTFE_FEPROT_EPROT_1 = 0x1

	// FDPROT: Data Flash Protection Register
	// Position of DPROT field.
	FTFE_FDPROT_DPROT_Pos = 0x0
	// Bit mask of DPROT field.
	FTFE_FDPROT_DPROT_Msk = 0xff
	// Data Flash region is protected
	FTFE_FDPROT_DPROT_0 = 0x0
	// Data Flash region is not protected
	FTFE_FDPROT_DPROT_1 = 0x1

	// XACCH3: Execute-only Access Registers
	// Position of XA field.
	FTFE_XACC_XA_Pos = 0x0
	// Bit mask of XA field.
	FTFE_XACC_XA_Msk = 0xff
	// Associated segment is accessible in execute mode only (as an instruction fetch)
	FTFE_XACC_XA_0 = 0x0
	// Associated segment is accessible as data or in execute mode
	FTFE_XACC_XA_1 = 0x1

	// SACCH3: Supervisor-only Access Registers
	// Position of SA field.
	FTFE_SACC_SA_Pos = 0x0
	// Bit mask of SA field.
	FTFE_SACC_SA_Msk = 0xff
	// Associated segment is accessible in supervisor mode only
	FTFE_SACC_SA_0 = 0x0
	// Associated segment is accessible in user or supervisor mode
	FTFE_SACC_SA_1 = 0x1

	// FACSS: Flash Access Segment Size Register
	// Position of SGSIZE field.
	FTFE_FACSS_SGSIZE_Pos = 0x0
	// Bit mask of SGSIZE field.
	FTFE_FACSS_SGSIZE_Msk = 0xff

	// FACSN: Flash Access Segment Number Register
	// Position of NUMSG field.
	FTFE_FACSN_NUMSG_Pos = 0x0
	// Bit mask of NUMSG field.
	FTFE_FACSN_NUMSG_Msk = 0xff
	// Program flash memory is divided into 48 segments (768 Kbytes, 1.5 Mbytes)
	FTFE_FACSN_NUMSG_110000 = 0x30
	// Program flash memory is divided into 64 segments (512 Kbytes, 1 Mbyte, 2 Mbytes)
	FTFE_FACSN_NUMSG_1000000 = 0x40
)

// Constants for DMAMUX: DMA channel multiplexor
const (
	// CHCFG0: Channel Configuration register
	// Position of SOURCE field.
	DMAMUX_CHCFG_SOURCE_Pos = 0x0
	// Bit mask of SOURCE field.
	DMAMUX_CHCFG_SOURCE_Msk = 0x3f
	// Disable_Signal
	DMAMUX_CHCFG_SOURCE_0 = 0x0
	// TSI0_Signal
	DMAMUX_CHCFG_SOURCE_1 = 0x1
	// UART0_Rx_Signal
	DMAMUX_CHCFG_SOURCE_2 = 0x2
	// UART0_Tx_Signal
	DMAMUX_CHCFG_SOURCE_3 = 0x3
	// UART1_Rx_Signal
	DMAMUX_CHCFG_SOURCE_4 = 0x4
	// UART1_Tx_Signal
	DMAMUX_CHCFG_SOURCE_5 = 0x5
	// UART2_Rx_Signal
	DMAMUX_CHCFG_SOURCE_6 = 0x6
	// UART2_Tx_Signal
	DMAMUX_CHCFG_SOURCE_7 = 0x7
	// UART3_Rx_Signal
	DMAMUX_CHCFG_SOURCE_8 = 0x8
	// UART3_Tx_Signal
	DMAMUX_CHCFG_SOURCE_9 = 0x9
	// UART4_Signal
	DMAMUX_CHCFG_SOURCE_10 = 0xa
	// I2S0_Rx_Signal
	DMAMUX_CHCFG_SOURCE_12 = 0xc
	// I2S0_Tx_Signal
	DMAMUX_CHCFG_SOURCE_13 = 0xd
	// SPI0_Rx_Signal
	DMAMUX_CHCFG_SOURCE_14 = 0xe
	// SPI0_Tx_Signal
	DMAMUX_CHCFG_SOURCE_15 = 0xf
	// SPI1_Rx_Signal
	DMAMUX_CHCFG_SOURCE_16 = 0x10
	// SPI1_Tx_Signal
	DMAMUX_CHCFG_SOURCE_17 = 0x11
	// I2C0_I2C3_Signal
	DMAMUX_CHCFG_SOURCE_18 = 0x12
	// I2C1_I2C2_Signal
	DMAMUX_CHCFG_SOURCE_19 = 0x13
	// FTM0_Channel0_Signal
	DMAMUX_CHCFG_SOURCE_20 = 0x14
	// FTM0_Channel1_Signal
	DMAMUX_CHCFG_SOURCE_21 = 0x15
	// FTM0_Channel2_Signal
	DMAMUX_CHCFG_SOURCE_22 = 0x16
	// FTM0_Channel3_Signal
	DMAMUX_CHCFG_SOURCE_23 = 0x17
	// FTM0_Channel4_Signal
	DMAMUX_CHCFG_SOURCE_24 = 0x18
	// FTM0_Channel5_Signal
	DMAMUX_CHCFG_SOURCE_25 = 0x19
	// FTM0_Channel6_Signal
	DMAMUX_CHCFG_SOURCE_26 = 0x1a
	// FTM0_Channel7_Signal
	DMAMUX_CHCFG_SOURCE_27 = 0x1b
	// FTM1_TPM1_Channel0_Signal
	DMAMUX_CHCFG_SOURCE_28 = 0x1c
	// FTM1_TPM1_Channel1_Signal
	DMAMUX_CHCFG_SOURCE_29 = 0x1d
	// FTM2_TPM2_Channel0_Signal
	DMAMUX_CHCFG_SOURCE_30 = 0x1e
	// FTM2_TPM2_Channel1_Signal
	DMAMUX_CHCFG_SOURCE_31 = 0x1f
	// FTM3_Channel0_Signal
	DMAMUX_CHCFG_SOURCE_32 = 0x20
	// FTM3_Channel1_Signal
	DMAMUX_CHCFG_SOURCE_33 = 0x21
	// FTM3_Channel2_Signal
	DMAMUX_CHCFG_SOURCE_34 = 0x22
	// FTM3_Channel3_Signal
	DMAMUX_CHCFG_SOURCE_35 = 0x23
	// FTM3_Channel4_Signal
	DMAMUX_CHCFG_SOURCE_36 = 0x24
	// FTM3_Channel5_Signal
	DMAMUX_CHCFG_SOURCE_37 = 0x25
	// FTM3_Channel6_SPI2_Rx_Signal
	DMAMUX_CHCFG_SOURCE_38 = 0x26
	// FTM3_Channel7_SPI2_Tx_Signal
	DMAMUX_CHCFG_SOURCE_39 = 0x27
	// ADC0_Signal
	DMAMUX_CHCFG_SOURCE_40 = 0x28
	// ADC1_Signal
	DMAMUX_CHCFG_SOURCE_41 = 0x29
	// CMP0_Signal
	DMAMUX_CHCFG_SOURCE_42 = 0x2a
	// CMP1_Signal
	DMAMUX_CHCFG_SOURCE_43 = 0x2b
	// CMP2_CMP3_Signal
	DMAMUX_CHCFG_SOURCE_44 = 0x2c
	// DAC0_Signal
	DMAMUX_CHCFG_SOURCE_45 = 0x2d
	// DAC1_Signal
	DMAMUX_CHCFG_SOURCE_46 = 0x2e
	// CMT_Signal
	DMAMUX_CHCFG_SOURCE_47 = 0x2f
	// PDB_Signal
	DMAMUX_CHCFG_SOURCE_48 = 0x30
	// PortA_Signal
	DMAMUX_CHCFG_SOURCE_49 = 0x31
	// PortB_Signal
	DMAMUX_CHCFG_SOURCE_50 = 0x32
	// PortC_Signal
	DMAMUX_CHCFG_SOURCE_51 = 0x33
	// PortD_Signal
	DMAMUX_CHCFG_SOURCE_52 = 0x34
	// PortE_Signal
	DMAMUX_CHCFG_SOURCE_53 = 0x35
	// IEEE1588Timer0_Signal
	DMAMUX_CHCFG_SOURCE_54 = 0x36
	// IEEE1588Timer1_TPM1_Overflow_Signal
	DMAMUX_CHCFG_SOURCE_55 = 0x37
	// IEEE1588Timer2_TPM2_Overflow_Signal
	DMAMUX_CHCFG_SOURCE_56 = 0x38
	// IEEE1588Timer3_Signal
	DMAMUX_CHCFG_SOURCE_57 = 0x39
	// LPUART0_Rx_Signal
	DMAMUX_CHCFG_SOURCE_58 = 0x3a
	// LPUART0_Tx_Signal
	DMAMUX_CHCFG_SOURCE_59 = 0x3b
	// AlwaysOn60_Signal
	DMAMUX_CHCFG_SOURCE_60 = 0x3c
	// AlwaysOn61_Signal
	DMAMUX_CHCFG_SOURCE_61 = 0x3d
	// AlwaysOn62_Signal
	DMAMUX_CHCFG_SOURCE_62 = 0x3e
	// AlwaysOn63_Signal
	DMAMUX_CHCFG_SOURCE_63 = 0x3f
	// Position of TRIG field.
	DMAMUX_CHCFG_TRIG_Pos = 0x6
	// Bit mask of TRIG field.
	DMAMUX_CHCFG_TRIG_Msk = 0x40
	// Bit TRIG.
	DMAMUX_CHCFG_TRIG = 0x40
	// Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
	DMAMUX_CHCFG_TRIG_0 = 0x0
	// Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
	DMAMUX_CHCFG_TRIG_1 = 0x1
	// Position of ENBL field.
	DMAMUX_CHCFG_ENBL_Pos = 0x7
	// Bit mask of ENBL field.
	DMAMUX_CHCFG_ENBL_Msk = 0x80
	// Bit ENBL.
	DMAMUX_CHCFG_ENBL = 0x80
	// DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
	DMAMUX_CHCFG_ENBL_0 = 0x0
	// DMA channel is enabled
	DMAMUX_CHCFG_ENBL_1 = 0x1
)

// Constants for CAN0: Flex Controller Area Network module
const (
	// MCR: Module Configuration Register
	// Position of MAXMB field.
	CAN_MCR_MAXMB_Pos = 0x0
	// Bit mask of MAXMB field.
	CAN_MCR_MAXMB_Msk = 0x7f
	// Position of IDAM field.
	CAN_MCR_IDAM_Pos = 0x8
	// Bit mask of IDAM field.
	CAN_MCR_IDAM_Msk = 0x300
	// Format A: One full ID (standard and extended) per ID Filter Table element.
	CAN_MCR_IDAM_00 = 0x0
	// Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID Filter Table element.
	CAN_MCR_IDAM_01 = 0x1
	// Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
	CAN_MCR_IDAM_10 = 0x2
	// Format D: All frames rejected.
	CAN_MCR_IDAM_11 = 0x3
	// Position of AEN field.
	CAN_MCR_AEN_Pos = 0xc
	// Bit mask of AEN field.
	CAN_MCR_AEN_Msk = 0x1000
	// Bit AEN.
	CAN_MCR_AEN = 0x1000
	// Abort disabled.
	CAN_MCR_AEN_0 = 0x0
	// Abort enabled.
	CAN_MCR_AEN_1 = 0x1
	// Position of LPRIOEN field.
	CAN_MCR_LPRIOEN_Pos = 0xd
	// Bit mask of LPRIOEN field.
	CAN_MCR_LPRIOEN_Msk = 0x2000
	// Bit LPRIOEN.
	CAN_MCR_LPRIOEN = 0x2000
	// Local Priority disabled.
	CAN_MCR_LPRIOEN_0 = 0x0
	// Local Priority enabled.
	CAN_MCR_LPRIOEN_1 = 0x1
	// Position of IRMQ field.
	CAN_MCR_IRMQ_Pos = 0x10
	// Bit mask of IRMQ field.
	CAN_MCR_IRMQ_Msk = 0x10000
	// Bit IRMQ.
	CAN_MCR_IRMQ = 0x10000
	// Individual Rx masking and queue feature are disabled. For backward compatibility with legacy applications, the reading of C/S word locks the MB even if it is EMPTY.
	CAN_MCR_IRMQ_0 = 0x0
	// Individual Rx masking and queue feature are enabled.
	CAN_MCR_IRMQ_1 = 0x1
	// Position of SRXDIS field.
	CAN_MCR_SRXDIS_Pos = 0x11
	// Bit mask of SRXDIS field.
	CAN_MCR_SRXDIS_Msk = 0x20000
	// Bit SRXDIS.
	CAN_MCR_SRXDIS = 0x20000
	// Self reception enabled.
	CAN_MCR_SRXDIS_0 = 0x0
	// Self reception disabled.
	CAN_MCR_SRXDIS_1 = 0x1
	// Position of WAKSRC field.
	CAN_MCR_WAKSRC_Pos = 0x13
	// Bit mask of WAKSRC field.
	CAN_MCR_WAKSRC_Msk = 0x80000
	// Bit WAKSRC.
	CAN_MCR_WAKSRC = 0x80000
	// FlexCAN uses the unfiltered Rx input to detect recessive to dominant edges on the CAN bus.
	CAN_MCR_WAKSRC_0 = 0x0
	// FlexCAN uses the filtered Rx input to detect recessive to dominant edges on the CAN bus.
	CAN_MCR_WAKSRC_1 = 0x1
	// Position of LPMACK field.
	CAN_MCR_LPMACK_Pos = 0x14
	// Bit mask of LPMACK field.
	CAN_MCR_LPMACK_Msk = 0x100000
	// Bit LPMACK.
	CAN_MCR_LPMACK = 0x100000
	// FlexCAN is not in a low-power mode.
	CAN_MCR_LPMACK_0 = 0x0
	// FlexCAN is in a low-power mode.
	CAN_MCR_LPMACK_1 = 0x1
	// Position of WRNEN field.
	CAN_MCR_WRNEN_Pos = 0x15
	// Bit mask of WRNEN field.
	CAN_MCR_WRNEN_Msk = 0x200000
	// Bit WRNEN.
	CAN_MCR_WRNEN = 0x200000
	// TWRNINT and RWRNINT bits are zero, independent of the values in the error counters.
	CAN_MCR_WRNEN_0 = 0x0
	// TWRNINT and RWRNINT bits are set when the respective error counter transitions from less than 96 to greater than or equal to 96.
	CAN_MCR_WRNEN_1 = 0x1
	// Position of SLFWAK field.
	CAN_MCR_SLFWAK_Pos = 0x16
	// Bit mask of SLFWAK field.
	CAN_MCR_SLFWAK_Msk = 0x400000
	// Bit SLFWAK.
	CAN_MCR_SLFWAK = 0x400000
	// FlexCAN Self Wake Up feature is disabled.
	CAN_MCR_SLFWAK_0 = 0x0
	// FlexCAN Self Wake Up feature is enabled.
	CAN_MCR_SLFWAK_1 = 0x1
	// Position of SUPV field.
	CAN_MCR_SUPV_Pos = 0x17
	// Bit mask of SUPV field.
	CAN_MCR_SUPV_Msk = 0x800000
	// Bit SUPV.
	CAN_MCR_SUPV = 0x800000
	// FlexCAN is in User mode. Affected registers allow both Supervisor and Unrestricted accesses .
	CAN_MCR_SUPV_0 = 0x0
	// FlexCAN is in Supervisor mode. Affected registers allow only Supervisor access. Unrestricted access behaves as though the access was done to an unimplemented register location .
	CAN_MCR_SUPV_1 = 0x1
	// Position of FRZACK field.
	CAN_MCR_FRZACK_Pos = 0x18
	// Bit mask of FRZACK field.
	CAN_MCR_FRZACK_Msk = 0x1000000
	// Bit FRZACK.
	CAN_MCR_FRZACK = 0x1000000
	// FlexCAN not in Freeze mode, prescaler running.
	CAN_MCR_FRZACK_0 = 0x0
	// FlexCAN in Freeze mode, prescaler stopped.
	CAN_MCR_FRZACK_1 = 0x1
	// Position of SOFTRST field.
	CAN_MCR_SOFTRST_Pos = 0x19
	// Bit mask of SOFTRST field.
	CAN_MCR_SOFTRST_Msk = 0x2000000
	// Bit SOFTRST.
	CAN_MCR_SOFTRST = 0x2000000
	// No reset request.
	CAN_MCR_SOFTRST_0 = 0x0
	// Resets the registers affected by soft reset.
	CAN_MCR_SOFTRST_1 = 0x1
	// Position of WAKMSK field.
	CAN_MCR_WAKMSK_Pos = 0x1a
	// Bit mask of WAKMSK field.
	CAN_MCR_WAKMSK_Msk = 0x4000000
	// Bit WAKMSK.
	CAN_MCR_WAKMSK = 0x4000000
	// Wake Up Interrupt is disabled.
	CAN_MCR_WAKMSK_0 = 0x0
	// Wake Up Interrupt is enabled.
	CAN_MCR_WAKMSK_1 = 0x1
	// Position of NOTRDY field.
	CAN_MCR_NOTRDY_Pos = 0x1b
	// Bit mask of NOTRDY field.
	CAN_MCR_NOTRDY_Msk = 0x8000000
	// Bit NOTRDY.
	CAN_MCR_NOTRDY = 0x8000000
	// FlexCAN module is either in Normal mode, Listen-Only mode or Loop-Back mode.
	CAN_MCR_NOTRDY_0 = 0x0
	// FlexCAN module is either in Disable mode , Stop mode or Freeze mode.
	CAN_MCR_NOTRDY_1 = 0x1
	// Position of HALT field.
	CAN_MCR_HALT_Pos = 0x1c
	// Bit mask of HALT field.
	CAN_MCR_HALT_Msk = 0x10000000
	// Bit HALT.
	CAN_MCR_HALT = 0x10000000
	// No Freeze mode request.
	CAN_MCR_HALT_0 = 0x0
	// Enters Freeze mode if the FRZ bit is asserted.
	CAN_MCR_HALT_1 = 0x1
	// Position of RFEN field.
	CAN_MCR_RFEN_Pos = 0x1d
	// Bit mask of RFEN field.
	CAN_MCR_RFEN_Msk = 0x20000000
	// Bit RFEN.
	CAN_MCR_RFEN = 0x20000000
	// Rx FIFO not enabled.
	CAN_MCR_RFEN_0 = 0x0
	// Rx FIFO enabled.
	CAN_MCR_RFEN_1 = 0x1
	// Position of FRZ field.
	CAN_MCR_FRZ_Pos = 0x1e
	// Bit mask of FRZ field.
	CAN_MCR_FRZ_Msk = 0x40000000
	// Bit FRZ.
	CAN_MCR_FRZ = 0x40000000
	// Not enabled to enter Freeze mode.
	CAN_MCR_FRZ_0 = 0x0
	// Enabled to enter Freeze mode.
	CAN_MCR_FRZ_1 = 0x1
	// Position of MDIS field.
	CAN_MCR_MDIS_Pos = 0x1f
	// Bit mask of MDIS field.
	CAN_MCR_MDIS_Msk = 0x80000000
	// Bit MDIS.
	CAN_MCR_MDIS = 0x80000000
	// Enable the FlexCAN module.
	CAN_MCR_MDIS_0 = 0x0
	// Disable the FlexCAN module.
	CAN_MCR_MDIS_1 = 0x1

	// CTRL1: Control 1 register
	// Position of PROPSEG field.
	CAN_CTRL1_PROPSEG_Pos = 0x0
	// Bit mask of PROPSEG field.
	CAN_CTRL1_PROPSEG_Msk = 0x7
	// Position of LOM field.
	CAN_CTRL1_LOM_Pos = 0x3
	// Bit mask of LOM field.
	CAN_CTRL1_LOM_Msk = 0x8
	// Bit LOM.
	CAN_CTRL1_LOM = 0x8
	// Listen-Only mode is deactivated.
	CAN_CTRL1_LOM_0 = 0x0
	// FlexCAN module operates in Listen-Only mode.
	CAN_CTRL1_LOM_1 = 0x1
	// Position of LBUF field.
	CAN_CTRL1_LBUF_Pos = 0x4
	// Bit mask of LBUF field.
	CAN_CTRL1_LBUF_Msk = 0x10
	// Bit LBUF.
	CAN_CTRL1_LBUF = 0x10
	// Buffer with highest priority is transmitted first.
	CAN_CTRL1_LBUF_0 = 0x0
	// Lowest number buffer is transmitted first.
	CAN_CTRL1_LBUF_1 = 0x1
	// Position of TSYN field.
	CAN_CTRL1_TSYN_Pos = 0x5
	// Bit mask of TSYN field.
	CAN_CTRL1_TSYN_Msk = 0x20
	// Bit TSYN.
	CAN_CTRL1_TSYN = 0x20
	// Timer Sync feature disabled
	CAN_CTRL1_TSYN_0 = 0x0
	// Timer Sync feature enabled
	CAN_CTRL1_TSYN_1 = 0x1
	// Position of BOFFREC field.
	CAN_CTRL1_BOFFREC_Pos = 0x6
	// Bit mask of BOFFREC field.
	CAN_CTRL1_BOFFREC_Msk = 0x40
	// Bit BOFFREC.
	CAN_CTRL1_BOFFREC = 0x40
	// Automatic recovering from Bus Off state enabled, according to CAN Spec 2.0 part B.
	CAN_CTRL1_BOFFREC_0 = 0x0
	// Automatic recovering from Bus Off state disabled.
	CAN_CTRL1_BOFFREC_1 = 0x1
	// Position of SMP field.
	CAN_CTRL1_SMP_Pos = 0x7
	// Bit mask of SMP field.
	CAN_CTRL1_SMP_Msk = 0x80
	// Bit SMP.
	CAN_CTRL1_SMP = 0x80
	// Just one sample is used to determine the bit value.
	CAN_CTRL1_SMP_0 = 0x0
	// Three samples are used to determine the value of the received bit: the regular one (sample point) and 2 preceding samples; a majority rule is used.
	CAN_CTRL1_SMP_1 = 0x1
	// Position of RWRNMSK field.
	CAN_CTRL1_RWRNMSK_Pos = 0xa
	// Bit mask of RWRNMSK field.
	CAN_CTRL1_RWRNMSK_Msk = 0x400
	// Bit RWRNMSK.
	CAN_CTRL1_RWRNMSK = 0x400
	// Rx Warning Interrupt disabled.
	CAN_CTRL1_RWRNMSK_0 = 0x0
	// Rx Warning Interrupt enabled.
	CAN_CTRL1_RWRNMSK_1 = 0x1
	// Position of TWRNMSK field.
	CAN_CTRL1_TWRNMSK_Pos = 0xb
	// Bit mask of TWRNMSK field.
	CAN_CTRL1_TWRNMSK_Msk = 0x800
	// Bit TWRNMSK.
	CAN_CTRL1_TWRNMSK = 0x800
	// Tx Warning Interrupt disabled.
	CAN_CTRL1_TWRNMSK_0 = 0x0
	// Tx Warning Interrupt enabled.
	CAN_CTRL1_TWRNMSK_1 = 0x1
	// Position of LPB field.
	CAN_CTRL1_LPB_Pos = 0xc
	// Bit mask of LPB field.
	CAN_CTRL1_LPB_Msk = 0x1000
	// Bit LPB.
	CAN_CTRL1_LPB = 0x1000
	// Loop Back disabled.
	CAN_CTRL1_LPB_0 = 0x0
	// Loop Back enabled.
	CAN_CTRL1_LPB_1 = 0x1
	// Position of CLKSRC field.
	CAN_CTRL1_CLKSRC_Pos = 0xd
	// Bit mask of CLKSRC field.
	CAN_CTRL1_CLKSRC_Msk = 0x2000
	// Bit CLKSRC.
	CAN_CTRL1_CLKSRC = 0x2000
	// The CAN engine clock source is the oscillator clock. Under this condition, the oscillator clock frequency must be lower than the bus clock.
	CAN_CTRL1_CLKSRC_0 = 0x0
	// The CAN engine clock source is the peripheral clock.
	CAN_CTRL1_CLKSRC_1 = 0x1
	// Position of ERRMSK field.
	CAN_CTRL1_ERRMSK_Pos = 0xe
	// Bit mask of ERRMSK field.
	CAN_CTRL1_ERRMSK_Msk = 0x4000
	// Bit ERRMSK.
	CAN_CTRL1_ERRMSK = 0x4000
	// Error interrupt disabled.
	CAN_CTRL1_ERRMSK_0 = 0x0
	// Error interrupt enabled.
	CAN_CTRL1_ERRMSK_1 = 0x1
	// Position of BOFFMSK field.
	CAN_CTRL1_BOFFMSK_Pos = 0xf
	// Bit mask of BOFFMSK field.
	CAN_CTRL1_BOFFMSK_Msk = 0x8000
	// Bit BOFFMSK.
	CAN_CTRL1_BOFFMSK = 0x8000
	// Bus Off interrupt disabled.
	CAN_CTRL1_BOFFMSK_0 = 0x0
	// Bus Off interrupt enabled.
	CAN_CTRL1_BOFFMSK_1 = 0x1
	// Position of PSEG2 field.
	CAN_CTRL1_PSEG2_Pos = 0x10
	// Bit mask of PSEG2 field.
	CAN_CTRL1_PSEG2_Msk = 0x70000
	// Position of PSEG1 field.
	CAN_CTRL1_PSEG1_Pos = 0x13
	// Bit mask of PSEG1 field.
	CAN_CTRL1_PSEG1_Msk = 0x380000
	// Position of RJW field.
	CAN_CTRL1_RJW_Pos = 0x16
	// Bit mask of RJW field.
	CAN_CTRL1_RJW_Msk = 0xc00000
	// Position of PRESDIV field.
	CAN_CTRL1_PRESDIV_Pos = 0x18
	// Bit mask of PRESDIV field.
	CAN_CTRL1_PRESDIV_Msk = 0xff000000

	// TIMER: Free Running Timer
	// Position of TIMER field.
	CAN_TIMER_TIMER_Pos = 0x0
	// Bit mask of TIMER field.
	CAN_TIMER_TIMER_Msk = 0xffff

	// RXMGMASK: Rx Mailboxes Global Mask Register
	// Position of MG0 field.
	CAN_RXMGMASK_MG0_Pos = 0x0
	// Bit mask of MG0 field.
	CAN_RXMGMASK_MG0_Msk = 0x1
	// Bit MG0.
	CAN_RXMGMASK_MG0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG0_1 = 0x1
	// Position of MG1 field.
	CAN_RXMGMASK_MG1_Pos = 0x1
	// Bit mask of MG1 field.
	CAN_RXMGMASK_MG1_Msk = 0x2
	// Bit MG1.
	CAN_RXMGMASK_MG1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG1_1 = 0x1
	// Position of MG2 field.
	CAN_RXMGMASK_MG2_Pos = 0x2
	// Bit mask of MG2 field.
	CAN_RXMGMASK_MG2_Msk = 0x4
	// Bit MG2.
	CAN_RXMGMASK_MG2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG2_1 = 0x1
	// Position of MG3 field.
	CAN_RXMGMASK_MG3_Pos = 0x3
	// Bit mask of MG3 field.
	CAN_RXMGMASK_MG3_Msk = 0x8
	// Bit MG3.
	CAN_RXMGMASK_MG3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG3_1 = 0x1
	// Position of MG4 field.
	CAN_RXMGMASK_MG4_Pos = 0x4
	// Bit mask of MG4 field.
	CAN_RXMGMASK_MG4_Msk = 0x10
	// Bit MG4.
	CAN_RXMGMASK_MG4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG4_1 = 0x1
	// Position of MG5 field.
	CAN_RXMGMASK_MG5_Pos = 0x5
	// Bit mask of MG5 field.
	CAN_RXMGMASK_MG5_Msk = 0x20
	// Bit MG5.
	CAN_RXMGMASK_MG5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG5_1 = 0x1
	// Position of MG6 field.
	CAN_RXMGMASK_MG6_Pos = 0x6
	// Bit mask of MG6 field.
	CAN_RXMGMASK_MG6_Msk = 0x40
	// Bit MG6.
	CAN_RXMGMASK_MG6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG6_1 = 0x1
	// Position of MG7 field.
	CAN_RXMGMASK_MG7_Pos = 0x7
	// Bit mask of MG7 field.
	CAN_RXMGMASK_MG7_Msk = 0x80
	// Bit MG7.
	CAN_RXMGMASK_MG7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG7_1 = 0x1
	// Position of MG8 field.
	CAN_RXMGMASK_MG8_Pos = 0x8
	// Bit mask of MG8 field.
	CAN_RXMGMASK_MG8_Msk = 0x100
	// Bit MG8.
	CAN_RXMGMASK_MG8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG8_1 = 0x1
	// Position of MG9 field.
	CAN_RXMGMASK_MG9_Pos = 0x9
	// Bit mask of MG9 field.
	CAN_RXMGMASK_MG9_Msk = 0x200
	// Bit MG9.
	CAN_RXMGMASK_MG9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG9_1 = 0x1
	// Position of MG10 field.
	CAN_RXMGMASK_MG10_Pos = 0xa
	// Bit mask of MG10 field.
	CAN_RXMGMASK_MG10_Msk = 0x400
	// Bit MG10.
	CAN_RXMGMASK_MG10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG10_1 = 0x1
	// Position of MG11 field.
	CAN_RXMGMASK_MG11_Pos = 0xb
	// Bit mask of MG11 field.
	CAN_RXMGMASK_MG11_Msk = 0x800
	// Bit MG11.
	CAN_RXMGMASK_MG11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG11_1 = 0x1
	// Position of MG12 field.
	CAN_RXMGMASK_MG12_Pos = 0xc
	// Bit mask of MG12 field.
	CAN_RXMGMASK_MG12_Msk = 0x1000
	// Bit MG12.
	CAN_RXMGMASK_MG12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG12_1 = 0x1
	// Position of MG13 field.
	CAN_RXMGMASK_MG13_Pos = 0xd
	// Bit mask of MG13 field.
	CAN_RXMGMASK_MG13_Msk = 0x2000
	// Bit MG13.
	CAN_RXMGMASK_MG13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG13_1 = 0x1
	// Position of MG14 field.
	CAN_RXMGMASK_MG14_Pos = 0xe
	// Bit mask of MG14 field.
	CAN_RXMGMASK_MG14_Msk = 0x4000
	// Bit MG14.
	CAN_RXMGMASK_MG14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG14_1 = 0x1
	// Position of MG15 field.
	CAN_RXMGMASK_MG15_Pos = 0xf
	// Bit mask of MG15 field.
	CAN_RXMGMASK_MG15_Msk = 0x8000
	// Bit MG15.
	CAN_RXMGMASK_MG15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG15_1 = 0x1
	// Position of MG16 field.
	CAN_RXMGMASK_MG16_Pos = 0x10
	// Bit mask of MG16 field.
	CAN_RXMGMASK_MG16_Msk = 0x10000
	// Bit MG16.
	CAN_RXMGMASK_MG16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG16_1 = 0x1
	// Position of MG17 field.
	CAN_RXMGMASK_MG17_Pos = 0x11
	// Bit mask of MG17 field.
	CAN_RXMGMASK_MG17_Msk = 0x20000
	// Bit MG17.
	CAN_RXMGMASK_MG17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG17_1 = 0x1
	// Position of MG18 field.
	CAN_RXMGMASK_MG18_Pos = 0x12
	// Bit mask of MG18 field.
	CAN_RXMGMASK_MG18_Msk = 0x40000
	// Bit MG18.
	CAN_RXMGMASK_MG18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG18_1 = 0x1
	// Position of MG19 field.
	CAN_RXMGMASK_MG19_Pos = 0x13
	// Bit mask of MG19 field.
	CAN_RXMGMASK_MG19_Msk = 0x80000
	// Bit MG19.
	CAN_RXMGMASK_MG19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG19_1 = 0x1
	// Position of MG20 field.
	CAN_RXMGMASK_MG20_Pos = 0x14
	// Bit mask of MG20 field.
	CAN_RXMGMASK_MG20_Msk = 0x100000
	// Bit MG20.
	CAN_RXMGMASK_MG20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG20_1 = 0x1
	// Position of MG21 field.
	CAN_RXMGMASK_MG21_Pos = 0x15
	// Bit mask of MG21 field.
	CAN_RXMGMASK_MG21_Msk = 0x200000
	// Bit MG21.
	CAN_RXMGMASK_MG21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG21_1 = 0x1
	// Position of MG22 field.
	CAN_RXMGMASK_MG22_Pos = 0x16
	// Bit mask of MG22 field.
	CAN_RXMGMASK_MG22_Msk = 0x400000
	// Bit MG22.
	CAN_RXMGMASK_MG22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG22_1 = 0x1
	// Position of MG23 field.
	CAN_RXMGMASK_MG23_Pos = 0x17
	// Bit mask of MG23 field.
	CAN_RXMGMASK_MG23_Msk = 0x800000
	// Bit MG23.
	CAN_RXMGMASK_MG23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG23_1 = 0x1
	// Position of MG24 field.
	CAN_RXMGMASK_MG24_Pos = 0x18
	// Bit mask of MG24 field.
	CAN_RXMGMASK_MG24_Msk = 0x1000000
	// Bit MG24.
	CAN_RXMGMASK_MG24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG24_1 = 0x1
	// Position of MG25 field.
	CAN_RXMGMASK_MG25_Pos = 0x19
	// Bit mask of MG25 field.
	CAN_RXMGMASK_MG25_Msk = 0x2000000
	// Bit MG25.
	CAN_RXMGMASK_MG25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG25_1 = 0x1
	// Position of MG26 field.
	CAN_RXMGMASK_MG26_Pos = 0x1a
	// Bit mask of MG26 field.
	CAN_RXMGMASK_MG26_Msk = 0x4000000
	// Bit MG26.
	CAN_RXMGMASK_MG26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG26_1 = 0x1
	// Position of MG27 field.
	CAN_RXMGMASK_MG27_Pos = 0x1b
	// Bit mask of MG27 field.
	CAN_RXMGMASK_MG27_Msk = 0x8000000
	// Bit MG27.
	CAN_RXMGMASK_MG27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG27_1 = 0x1
	// Position of MG28 field.
	CAN_RXMGMASK_MG28_Pos = 0x1c
	// Bit mask of MG28 field.
	CAN_RXMGMASK_MG28_Msk = 0x10000000
	// Bit MG28.
	CAN_RXMGMASK_MG28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG28_1 = 0x1
	// Position of MG29 field.
	CAN_RXMGMASK_MG29_Pos = 0x1d
	// Bit mask of MG29 field.
	CAN_RXMGMASK_MG29_Msk = 0x20000000
	// Bit MG29.
	CAN_RXMGMASK_MG29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG29_1 = 0x1
	// Position of MG30 field.
	CAN_RXMGMASK_MG30_Pos = 0x1e
	// Bit mask of MG30 field.
	CAN_RXMGMASK_MG30_Msk = 0x40000000
	// Bit MG30.
	CAN_RXMGMASK_MG30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG30_1 = 0x1
	// Position of MG31 field.
	CAN_RXMGMASK_MG31_Pos = 0x1f
	// Bit mask of MG31 field.
	CAN_RXMGMASK_MG31_Msk = 0x80000000
	// Bit MG31.
	CAN_RXMGMASK_MG31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXMGMASK_MG31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXMGMASK_MG31_1 = 0x1

	// RX14MASK: Rx 14 Mask register
	// Position of RX14M0 field.
	CAN_RX14MASK_RX14M0_Pos = 0x0
	// Bit mask of RX14M0 field.
	CAN_RX14MASK_RX14M0_Msk = 0x1
	// Bit RX14M0.
	CAN_RX14MASK_RX14M0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M0_1 = 0x1
	// Position of RX14M1 field.
	CAN_RX14MASK_RX14M1_Pos = 0x1
	// Bit mask of RX14M1 field.
	CAN_RX14MASK_RX14M1_Msk = 0x2
	// Bit RX14M1.
	CAN_RX14MASK_RX14M1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M1_1 = 0x1
	// Position of RX14M2 field.
	CAN_RX14MASK_RX14M2_Pos = 0x2
	// Bit mask of RX14M2 field.
	CAN_RX14MASK_RX14M2_Msk = 0x4
	// Bit RX14M2.
	CAN_RX14MASK_RX14M2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M2_1 = 0x1
	// Position of RX14M3 field.
	CAN_RX14MASK_RX14M3_Pos = 0x3
	// Bit mask of RX14M3 field.
	CAN_RX14MASK_RX14M3_Msk = 0x8
	// Bit RX14M3.
	CAN_RX14MASK_RX14M3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M3_1 = 0x1
	// Position of RX14M4 field.
	CAN_RX14MASK_RX14M4_Pos = 0x4
	// Bit mask of RX14M4 field.
	CAN_RX14MASK_RX14M4_Msk = 0x10
	// Bit RX14M4.
	CAN_RX14MASK_RX14M4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M4_1 = 0x1
	// Position of RX14M5 field.
	CAN_RX14MASK_RX14M5_Pos = 0x5
	// Bit mask of RX14M5 field.
	CAN_RX14MASK_RX14M5_Msk = 0x20
	// Bit RX14M5.
	CAN_RX14MASK_RX14M5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M5_1 = 0x1
	// Position of RX14M6 field.
	CAN_RX14MASK_RX14M6_Pos = 0x6
	// Bit mask of RX14M6 field.
	CAN_RX14MASK_RX14M6_Msk = 0x40
	// Bit RX14M6.
	CAN_RX14MASK_RX14M6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M6_1 = 0x1
	// Position of RX14M7 field.
	CAN_RX14MASK_RX14M7_Pos = 0x7
	// Bit mask of RX14M7 field.
	CAN_RX14MASK_RX14M7_Msk = 0x80
	// Bit RX14M7.
	CAN_RX14MASK_RX14M7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M7_1 = 0x1
	// Position of RX14M8 field.
	CAN_RX14MASK_RX14M8_Pos = 0x8
	// Bit mask of RX14M8 field.
	CAN_RX14MASK_RX14M8_Msk = 0x100
	// Bit RX14M8.
	CAN_RX14MASK_RX14M8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M8_1 = 0x1
	// Position of RX14M9 field.
	CAN_RX14MASK_RX14M9_Pos = 0x9
	// Bit mask of RX14M9 field.
	CAN_RX14MASK_RX14M9_Msk = 0x200
	// Bit RX14M9.
	CAN_RX14MASK_RX14M9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M9_1 = 0x1
	// Position of RX14M10 field.
	CAN_RX14MASK_RX14M10_Pos = 0xa
	// Bit mask of RX14M10 field.
	CAN_RX14MASK_RX14M10_Msk = 0x400
	// Bit RX14M10.
	CAN_RX14MASK_RX14M10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M10_1 = 0x1
	// Position of RX14M11 field.
	CAN_RX14MASK_RX14M11_Pos = 0xb
	// Bit mask of RX14M11 field.
	CAN_RX14MASK_RX14M11_Msk = 0x800
	// Bit RX14M11.
	CAN_RX14MASK_RX14M11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M11_1 = 0x1
	// Position of RX14M12 field.
	CAN_RX14MASK_RX14M12_Pos = 0xc
	// Bit mask of RX14M12 field.
	CAN_RX14MASK_RX14M12_Msk = 0x1000
	// Bit RX14M12.
	CAN_RX14MASK_RX14M12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M12_1 = 0x1
	// Position of RX14M13 field.
	CAN_RX14MASK_RX14M13_Pos = 0xd
	// Bit mask of RX14M13 field.
	CAN_RX14MASK_RX14M13_Msk = 0x2000
	// Bit RX14M13.
	CAN_RX14MASK_RX14M13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M13_1 = 0x1
	// Position of RX14M14 field.
	CAN_RX14MASK_RX14M14_Pos = 0xe
	// Bit mask of RX14M14 field.
	CAN_RX14MASK_RX14M14_Msk = 0x4000
	// Bit RX14M14.
	CAN_RX14MASK_RX14M14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M14_1 = 0x1
	// Position of RX14M15 field.
	CAN_RX14MASK_RX14M15_Pos = 0xf
	// Bit mask of RX14M15 field.
	CAN_RX14MASK_RX14M15_Msk = 0x8000
	// Bit RX14M15.
	CAN_RX14MASK_RX14M15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M15_1 = 0x1
	// Position of RX14M16 field.
	CAN_RX14MASK_RX14M16_Pos = 0x10
	// Bit mask of RX14M16 field.
	CAN_RX14MASK_RX14M16_Msk = 0x10000
	// Bit RX14M16.
	CAN_RX14MASK_RX14M16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M16_1 = 0x1
	// Position of RX14M17 field.
	CAN_RX14MASK_RX14M17_Pos = 0x11
	// Bit mask of RX14M17 field.
	CAN_RX14MASK_RX14M17_Msk = 0x20000
	// Bit RX14M17.
	CAN_RX14MASK_RX14M17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M17_1 = 0x1
	// Position of RX14M18 field.
	CAN_RX14MASK_RX14M18_Pos = 0x12
	// Bit mask of RX14M18 field.
	CAN_RX14MASK_RX14M18_Msk = 0x40000
	// Bit RX14M18.
	CAN_RX14MASK_RX14M18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M18_1 = 0x1
	// Position of RX14M19 field.
	CAN_RX14MASK_RX14M19_Pos = 0x13
	// Bit mask of RX14M19 field.
	CAN_RX14MASK_RX14M19_Msk = 0x80000
	// Bit RX14M19.
	CAN_RX14MASK_RX14M19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M19_1 = 0x1
	// Position of RX14M20 field.
	CAN_RX14MASK_RX14M20_Pos = 0x14
	// Bit mask of RX14M20 field.
	CAN_RX14MASK_RX14M20_Msk = 0x100000
	// Bit RX14M20.
	CAN_RX14MASK_RX14M20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M20_1 = 0x1
	// Position of RX14M21 field.
	CAN_RX14MASK_RX14M21_Pos = 0x15
	// Bit mask of RX14M21 field.
	CAN_RX14MASK_RX14M21_Msk = 0x200000
	// Bit RX14M21.
	CAN_RX14MASK_RX14M21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M21_1 = 0x1
	// Position of RX14M22 field.
	CAN_RX14MASK_RX14M22_Pos = 0x16
	// Bit mask of RX14M22 field.
	CAN_RX14MASK_RX14M22_Msk = 0x400000
	// Bit RX14M22.
	CAN_RX14MASK_RX14M22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M22_1 = 0x1
	// Position of RX14M23 field.
	CAN_RX14MASK_RX14M23_Pos = 0x17
	// Bit mask of RX14M23 field.
	CAN_RX14MASK_RX14M23_Msk = 0x800000
	// Bit RX14M23.
	CAN_RX14MASK_RX14M23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M23_1 = 0x1
	// Position of RX14M24 field.
	CAN_RX14MASK_RX14M24_Pos = 0x18
	// Bit mask of RX14M24 field.
	CAN_RX14MASK_RX14M24_Msk = 0x1000000
	// Bit RX14M24.
	CAN_RX14MASK_RX14M24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M24_1 = 0x1
	// Position of RX14M25 field.
	CAN_RX14MASK_RX14M25_Pos = 0x19
	// Bit mask of RX14M25 field.
	CAN_RX14MASK_RX14M25_Msk = 0x2000000
	// Bit RX14M25.
	CAN_RX14MASK_RX14M25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M25_1 = 0x1
	// Position of RX14M26 field.
	CAN_RX14MASK_RX14M26_Pos = 0x1a
	// Bit mask of RX14M26 field.
	CAN_RX14MASK_RX14M26_Msk = 0x4000000
	// Bit RX14M26.
	CAN_RX14MASK_RX14M26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M26_1 = 0x1
	// Position of RX14M27 field.
	CAN_RX14MASK_RX14M27_Pos = 0x1b
	// Bit mask of RX14M27 field.
	CAN_RX14MASK_RX14M27_Msk = 0x8000000
	// Bit RX14M27.
	CAN_RX14MASK_RX14M27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M27_1 = 0x1
	// Position of RX14M28 field.
	CAN_RX14MASK_RX14M28_Pos = 0x1c
	// Bit mask of RX14M28 field.
	CAN_RX14MASK_RX14M28_Msk = 0x10000000
	// Bit RX14M28.
	CAN_RX14MASK_RX14M28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M28_1 = 0x1
	// Position of RX14M29 field.
	CAN_RX14MASK_RX14M29_Pos = 0x1d
	// Bit mask of RX14M29 field.
	CAN_RX14MASK_RX14M29_Msk = 0x20000000
	// Bit RX14M29.
	CAN_RX14MASK_RX14M29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M29_1 = 0x1
	// Position of RX14M30 field.
	CAN_RX14MASK_RX14M30_Pos = 0x1e
	// Bit mask of RX14M30 field.
	CAN_RX14MASK_RX14M30_Msk = 0x40000000
	// Bit RX14M30.
	CAN_RX14MASK_RX14M30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M30_1 = 0x1
	// Position of RX14M31 field.
	CAN_RX14MASK_RX14M31_Pos = 0x1f
	// Bit mask of RX14M31 field.
	CAN_RX14MASK_RX14M31_Msk = 0x80000000
	// Bit RX14M31.
	CAN_RX14MASK_RX14M31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX14MASK_RX14M31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX14MASK_RX14M31_1 = 0x1

	// RX15MASK: Rx 15 Mask register
	// Position of RX15M0 field.
	CAN_RX15MASK_RX15M0_Pos = 0x0
	// Bit mask of RX15M0 field.
	CAN_RX15MASK_RX15M0_Msk = 0x1
	// Bit RX15M0.
	CAN_RX15MASK_RX15M0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M0_1 = 0x1
	// Position of RX15M1 field.
	CAN_RX15MASK_RX15M1_Pos = 0x1
	// Bit mask of RX15M1 field.
	CAN_RX15MASK_RX15M1_Msk = 0x2
	// Bit RX15M1.
	CAN_RX15MASK_RX15M1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M1_1 = 0x1
	// Position of RX15M2 field.
	CAN_RX15MASK_RX15M2_Pos = 0x2
	// Bit mask of RX15M2 field.
	CAN_RX15MASK_RX15M2_Msk = 0x4
	// Bit RX15M2.
	CAN_RX15MASK_RX15M2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M2_1 = 0x1
	// Position of RX15M3 field.
	CAN_RX15MASK_RX15M3_Pos = 0x3
	// Bit mask of RX15M3 field.
	CAN_RX15MASK_RX15M3_Msk = 0x8
	// Bit RX15M3.
	CAN_RX15MASK_RX15M3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M3_1 = 0x1
	// Position of RX15M4 field.
	CAN_RX15MASK_RX15M4_Pos = 0x4
	// Bit mask of RX15M4 field.
	CAN_RX15MASK_RX15M4_Msk = 0x10
	// Bit RX15M4.
	CAN_RX15MASK_RX15M4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M4_1 = 0x1
	// Position of RX15M5 field.
	CAN_RX15MASK_RX15M5_Pos = 0x5
	// Bit mask of RX15M5 field.
	CAN_RX15MASK_RX15M5_Msk = 0x20
	// Bit RX15M5.
	CAN_RX15MASK_RX15M5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M5_1 = 0x1
	// Position of RX15M6 field.
	CAN_RX15MASK_RX15M6_Pos = 0x6
	// Bit mask of RX15M6 field.
	CAN_RX15MASK_RX15M6_Msk = 0x40
	// Bit RX15M6.
	CAN_RX15MASK_RX15M6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M6_1 = 0x1
	// Position of RX15M7 field.
	CAN_RX15MASK_RX15M7_Pos = 0x7
	// Bit mask of RX15M7 field.
	CAN_RX15MASK_RX15M7_Msk = 0x80
	// Bit RX15M7.
	CAN_RX15MASK_RX15M7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M7_1 = 0x1
	// Position of RX15M8 field.
	CAN_RX15MASK_RX15M8_Pos = 0x8
	// Bit mask of RX15M8 field.
	CAN_RX15MASK_RX15M8_Msk = 0x100
	// Bit RX15M8.
	CAN_RX15MASK_RX15M8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M8_1 = 0x1
	// Position of RX15M9 field.
	CAN_RX15MASK_RX15M9_Pos = 0x9
	// Bit mask of RX15M9 field.
	CAN_RX15MASK_RX15M9_Msk = 0x200
	// Bit RX15M9.
	CAN_RX15MASK_RX15M9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M9_1 = 0x1
	// Position of RX15M10 field.
	CAN_RX15MASK_RX15M10_Pos = 0xa
	// Bit mask of RX15M10 field.
	CAN_RX15MASK_RX15M10_Msk = 0x400
	// Bit RX15M10.
	CAN_RX15MASK_RX15M10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M10_1 = 0x1
	// Position of RX15M11 field.
	CAN_RX15MASK_RX15M11_Pos = 0xb
	// Bit mask of RX15M11 field.
	CAN_RX15MASK_RX15M11_Msk = 0x800
	// Bit RX15M11.
	CAN_RX15MASK_RX15M11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M11_1 = 0x1
	// Position of RX15M12 field.
	CAN_RX15MASK_RX15M12_Pos = 0xc
	// Bit mask of RX15M12 field.
	CAN_RX15MASK_RX15M12_Msk = 0x1000
	// Bit RX15M12.
	CAN_RX15MASK_RX15M12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M12_1 = 0x1
	// Position of RX15M13 field.
	CAN_RX15MASK_RX15M13_Pos = 0xd
	// Bit mask of RX15M13 field.
	CAN_RX15MASK_RX15M13_Msk = 0x2000
	// Bit RX15M13.
	CAN_RX15MASK_RX15M13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M13_1 = 0x1
	// Position of RX15M14 field.
	CAN_RX15MASK_RX15M14_Pos = 0xe
	// Bit mask of RX15M14 field.
	CAN_RX15MASK_RX15M14_Msk = 0x4000
	// Bit RX15M14.
	CAN_RX15MASK_RX15M14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M14_1 = 0x1
	// Position of RX15M15 field.
	CAN_RX15MASK_RX15M15_Pos = 0xf
	// Bit mask of RX15M15 field.
	CAN_RX15MASK_RX15M15_Msk = 0x8000
	// Bit RX15M15.
	CAN_RX15MASK_RX15M15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M15_1 = 0x1
	// Position of RX15M16 field.
	CAN_RX15MASK_RX15M16_Pos = 0x10
	// Bit mask of RX15M16 field.
	CAN_RX15MASK_RX15M16_Msk = 0x10000
	// Bit RX15M16.
	CAN_RX15MASK_RX15M16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M16_1 = 0x1
	// Position of RX15M17 field.
	CAN_RX15MASK_RX15M17_Pos = 0x11
	// Bit mask of RX15M17 field.
	CAN_RX15MASK_RX15M17_Msk = 0x20000
	// Bit RX15M17.
	CAN_RX15MASK_RX15M17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M17_1 = 0x1
	// Position of RX15M18 field.
	CAN_RX15MASK_RX15M18_Pos = 0x12
	// Bit mask of RX15M18 field.
	CAN_RX15MASK_RX15M18_Msk = 0x40000
	// Bit RX15M18.
	CAN_RX15MASK_RX15M18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M18_1 = 0x1
	// Position of RX15M19 field.
	CAN_RX15MASK_RX15M19_Pos = 0x13
	// Bit mask of RX15M19 field.
	CAN_RX15MASK_RX15M19_Msk = 0x80000
	// Bit RX15M19.
	CAN_RX15MASK_RX15M19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M19_1 = 0x1
	// Position of RX15M20 field.
	CAN_RX15MASK_RX15M20_Pos = 0x14
	// Bit mask of RX15M20 field.
	CAN_RX15MASK_RX15M20_Msk = 0x100000
	// Bit RX15M20.
	CAN_RX15MASK_RX15M20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M20_1 = 0x1
	// Position of RX15M21 field.
	CAN_RX15MASK_RX15M21_Pos = 0x15
	// Bit mask of RX15M21 field.
	CAN_RX15MASK_RX15M21_Msk = 0x200000
	// Bit RX15M21.
	CAN_RX15MASK_RX15M21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M21_1 = 0x1
	// Position of RX15M22 field.
	CAN_RX15MASK_RX15M22_Pos = 0x16
	// Bit mask of RX15M22 field.
	CAN_RX15MASK_RX15M22_Msk = 0x400000
	// Bit RX15M22.
	CAN_RX15MASK_RX15M22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M22_1 = 0x1
	// Position of RX15M23 field.
	CAN_RX15MASK_RX15M23_Pos = 0x17
	// Bit mask of RX15M23 field.
	CAN_RX15MASK_RX15M23_Msk = 0x800000
	// Bit RX15M23.
	CAN_RX15MASK_RX15M23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M23_1 = 0x1
	// Position of RX15M24 field.
	CAN_RX15MASK_RX15M24_Pos = 0x18
	// Bit mask of RX15M24 field.
	CAN_RX15MASK_RX15M24_Msk = 0x1000000
	// Bit RX15M24.
	CAN_RX15MASK_RX15M24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M24_1 = 0x1
	// Position of RX15M25 field.
	CAN_RX15MASK_RX15M25_Pos = 0x19
	// Bit mask of RX15M25 field.
	CAN_RX15MASK_RX15M25_Msk = 0x2000000
	// Bit RX15M25.
	CAN_RX15MASK_RX15M25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M25_1 = 0x1
	// Position of RX15M26 field.
	CAN_RX15MASK_RX15M26_Pos = 0x1a
	// Bit mask of RX15M26 field.
	CAN_RX15MASK_RX15M26_Msk = 0x4000000
	// Bit RX15M26.
	CAN_RX15MASK_RX15M26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M26_1 = 0x1
	// Position of RX15M27 field.
	CAN_RX15MASK_RX15M27_Pos = 0x1b
	// Bit mask of RX15M27 field.
	CAN_RX15MASK_RX15M27_Msk = 0x8000000
	// Bit RX15M27.
	CAN_RX15MASK_RX15M27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M27_1 = 0x1
	// Position of RX15M28 field.
	CAN_RX15MASK_RX15M28_Pos = 0x1c
	// Bit mask of RX15M28 field.
	CAN_RX15MASK_RX15M28_Msk = 0x10000000
	// Bit RX15M28.
	CAN_RX15MASK_RX15M28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M28_1 = 0x1
	// Position of RX15M29 field.
	CAN_RX15MASK_RX15M29_Pos = 0x1d
	// Bit mask of RX15M29 field.
	CAN_RX15MASK_RX15M29_Msk = 0x20000000
	// Bit RX15M29.
	CAN_RX15MASK_RX15M29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M29_1 = 0x1
	// Position of RX15M30 field.
	CAN_RX15MASK_RX15M30_Pos = 0x1e
	// Bit mask of RX15M30 field.
	CAN_RX15MASK_RX15M30_Msk = 0x40000000
	// Bit RX15M30.
	CAN_RX15MASK_RX15M30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M30_1 = 0x1
	// Position of RX15M31 field.
	CAN_RX15MASK_RX15M31_Pos = 0x1f
	// Bit mask of RX15M31 field.
	CAN_RX15MASK_RX15M31_Msk = 0x80000000
	// Bit RX15M31.
	CAN_RX15MASK_RX15M31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN_RX15MASK_RX15M31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RX15MASK_RX15M31_1 = 0x1

	// ECR: Error Counter
	// Position of TXERRCNT field.
	CAN_ECR_TXERRCNT_Pos = 0x0
	// Bit mask of TXERRCNT field.
	CAN_ECR_TXERRCNT_Msk = 0xff
	// Position of RXERRCNT field.
	CAN_ECR_RXERRCNT_Pos = 0x8
	// Bit mask of RXERRCNT field.
	CAN_ECR_RXERRCNT_Msk = 0xff00

	// ESR1: Error and Status 1 register
	// Position of WAKINT field.
	CAN_ESR1_WAKINT_Pos = 0x0
	// Bit mask of WAKINT field.
	CAN_ESR1_WAKINT_Msk = 0x1
	// Bit WAKINT.
	CAN_ESR1_WAKINT = 0x1
	// No such occurrence.
	CAN_ESR1_WAKINT_0 = 0x0
	// Indicates a recessive to dominant transition was received on the CAN bus.
	CAN_ESR1_WAKINT_1 = 0x1
	// Position of ERRINT field.
	CAN_ESR1_ERRINT_Pos = 0x1
	// Bit mask of ERRINT field.
	CAN_ESR1_ERRINT_Msk = 0x2
	// Bit ERRINT.
	CAN_ESR1_ERRINT = 0x2
	// No such occurrence.
	CAN_ESR1_ERRINT_0 = 0x0
	// Indicates setting of any Error Bit in the Error and Status Register.
	CAN_ESR1_ERRINT_1 = 0x1
	// Position of BOFFINT field.
	CAN_ESR1_BOFFINT_Pos = 0x2
	// Bit mask of BOFFINT field.
	CAN_ESR1_BOFFINT_Msk = 0x4
	// Bit BOFFINT.
	CAN_ESR1_BOFFINT = 0x4
	// No such occurrence.
	CAN_ESR1_BOFFINT_0 = 0x0
	// FlexCAN module entered Bus Off state.
	CAN_ESR1_BOFFINT_1 = 0x1
	// Position of RX field.
	CAN_ESR1_RX_Pos = 0x3
	// Bit mask of RX field.
	CAN_ESR1_RX_Msk = 0x8
	// Bit RX.
	CAN_ESR1_RX = 0x8
	// FlexCAN is not receiving a message.
	CAN_ESR1_RX_0 = 0x0
	// FlexCAN is receiving a message.
	CAN_ESR1_RX_1 = 0x1
	// Position of FLTCONF field.
	CAN_ESR1_FLTCONF_Pos = 0x4
	// Bit mask of FLTCONF field.
	CAN_ESR1_FLTCONF_Msk = 0x30
	// Error Active
	CAN_ESR1_FLTCONF_00 = 0x0
	// Error Passive
	CAN_ESR1_FLTCONF_01 = 0x1
	// Position of TX field.
	CAN_ESR1_TX_Pos = 0x6
	// Bit mask of TX field.
	CAN_ESR1_TX_Msk = 0x40
	// Bit TX.
	CAN_ESR1_TX = 0x40
	// FlexCAN is not transmitting a message.
	CAN_ESR1_TX_0 = 0x0
	// FlexCAN is transmitting a message.
	CAN_ESR1_TX_1 = 0x1
	// Position of IDLE field.
	CAN_ESR1_IDLE_Pos = 0x7
	// Bit mask of IDLE field.
	CAN_ESR1_IDLE_Msk = 0x80
	// Bit IDLE.
	CAN_ESR1_IDLE = 0x80
	// No such occurrence.
	CAN_ESR1_IDLE_0 = 0x0
	// CAN bus is now IDLE.
	CAN_ESR1_IDLE_1 = 0x1
	// Position of RXWRN field.
	CAN_ESR1_RXWRN_Pos = 0x8
	// Bit mask of RXWRN field.
	CAN_ESR1_RXWRN_Msk = 0x100
	// Bit RXWRN.
	CAN_ESR1_RXWRN = 0x100
	// No such occurrence.
	CAN_ESR1_RXWRN_0 = 0x0
	// RXERRCNT is greater than or equal to 96.
	CAN_ESR1_RXWRN_1 = 0x1
	// Position of TXWRN field.
	CAN_ESR1_TXWRN_Pos = 0x9
	// Bit mask of TXWRN field.
	CAN_ESR1_TXWRN_Msk = 0x200
	// Bit TXWRN.
	CAN_ESR1_TXWRN = 0x200
	// No such occurrence.
	CAN_ESR1_TXWRN_0 = 0x0
	// TXERRCNT is greater than or equal to 96.
	CAN_ESR1_TXWRN_1 = 0x1
	// Position of STFERR field.
	CAN_ESR1_STFERR_Pos = 0xa
	// Bit mask of STFERR field.
	CAN_ESR1_STFERR_Msk = 0x400
	// Bit STFERR.
	CAN_ESR1_STFERR = 0x400
	// No such occurrence.
	CAN_ESR1_STFERR_0 = 0x0
	// A Stuffing Error occurred since last read of this register.
	CAN_ESR1_STFERR_1 = 0x1
	// Position of FRMERR field.
	CAN_ESR1_FRMERR_Pos = 0xb
	// Bit mask of FRMERR field.
	CAN_ESR1_FRMERR_Msk = 0x800
	// Bit FRMERR.
	CAN_ESR1_FRMERR = 0x800
	// No such occurrence.
	CAN_ESR1_FRMERR_0 = 0x0
	// A Form Error occurred since last read of this register.
	CAN_ESR1_FRMERR_1 = 0x1
	// Position of CRCERR field.
	CAN_ESR1_CRCERR_Pos = 0xc
	// Bit mask of CRCERR field.
	CAN_ESR1_CRCERR_Msk = 0x1000
	// Bit CRCERR.
	CAN_ESR1_CRCERR = 0x1000
	// No such occurrence.
	CAN_ESR1_CRCERR_0 = 0x0
	// A CRC error occurred since last read of this register.
	CAN_ESR1_CRCERR_1 = 0x1
	// Position of ACKERR field.
	CAN_ESR1_ACKERR_Pos = 0xd
	// Bit mask of ACKERR field.
	CAN_ESR1_ACKERR_Msk = 0x2000
	// Bit ACKERR.
	CAN_ESR1_ACKERR = 0x2000
	// No such occurrence.
	CAN_ESR1_ACKERR_0 = 0x0
	// An ACK error occurred since last read of this register.
	CAN_ESR1_ACKERR_1 = 0x1
	// Position of BIT0ERR field.
	CAN_ESR1_BIT0ERR_Pos = 0xe
	// Bit mask of BIT0ERR field.
	CAN_ESR1_BIT0ERR_Msk = 0x4000
	// Bit BIT0ERR.
	CAN_ESR1_BIT0ERR = 0x4000
	// No such occurrence.
	CAN_ESR1_BIT0ERR_0 = 0x0
	// At least one bit sent as dominant is received as recessive.
	CAN_ESR1_BIT0ERR_1 = 0x1
	// Position of BIT1ERR field.
	CAN_ESR1_BIT1ERR_Pos = 0xf
	// Bit mask of BIT1ERR field.
	CAN_ESR1_BIT1ERR_Msk = 0x8000
	// Bit BIT1ERR.
	CAN_ESR1_BIT1ERR = 0x8000
	// No such occurrence.
	CAN_ESR1_BIT1ERR_0 = 0x0
	// At least one bit sent as recessive is received as dominant.
	CAN_ESR1_BIT1ERR_1 = 0x1
	// Position of RWRNINT field.
	CAN_ESR1_RWRNINT_Pos = 0x10
	// Bit mask of RWRNINT field.
	CAN_ESR1_RWRNINT_Msk = 0x10000
	// Bit RWRNINT.
	CAN_ESR1_RWRNINT = 0x10000
	// No such occurrence.
	CAN_ESR1_RWRNINT_0 = 0x0
	// The Rx error counter transitioned from less than 96 to greater than or equal to 96.
	CAN_ESR1_RWRNINT_1 = 0x1
	// Position of TWRNINT field.
	CAN_ESR1_TWRNINT_Pos = 0x11
	// Bit mask of TWRNINT field.
	CAN_ESR1_TWRNINT_Msk = 0x20000
	// Bit TWRNINT.
	CAN_ESR1_TWRNINT = 0x20000
	// No such occurrence.
	CAN_ESR1_TWRNINT_0 = 0x0
	// The Tx error counter transitioned from less than 96 to greater than or equal to 96.
	CAN_ESR1_TWRNINT_1 = 0x1
	// Position of SYNCH field.
	CAN_ESR1_SYNCH_Pos = 0x12
	// Bit mask of SYNCH field.
	CAN_ESR1_SYNCH_Msk = 0x40000
	// Bit SYNCH.
	CAN_ESR1_SYNCH = 0x40000
	// FlexCAN is not synchronized to the CAN bus.
	CAN_ESR1_SYNCH_0 = 0x0
	// FlexCAN is synchronized to the CAN bus.
	CAN_ESR1_SYNCH_1 = 0x1

	// IMASK1: Interrupt Masks 1 register
	// Position of BUFLM0 field.
	CAN_IMASK1_BUFLM0_Pos = 0x0
	// Bit mask of BUFLM0 field.
	CAN_IMASK1_BUFLM0_Msk = 0x1
	// Bit BUFLM0.
	CAN_IMASK1_BUFLM0 = 0x1
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM0_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM0_1 = 0x1
	// Position of BUFLM1 field.
	CAN_IMASK1_BUFLM1_Pos = 0x1
	// Bit mask of BUFLM1 field.
	CAN_IMASK1_BUFLM1_Msk = 0x2
	// Bit BUFLM1.
	CAN_IMASK1_BUFLM1 = 0x2
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM1_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM1_1 = 0x1
	// Position of BUFLM2 field.
	CAN_IMASK1_BUFLM2_Pos = 0x2
	// Bit mask of BUFLM2 field.
	CAN_IMASK1_BUFLM2_Msk = 0x4
	// Bit BUFLM2.
	CAN_IMASK1_BUFLM2 = 0x4
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM2_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM2_1 = 0x1
	// Position of BUFLM3 field.
	CAN_IMASK1_BUFLM3_Pos = 0x3
	// Bit mask of BUFLM3 field.
	CAN_IMASK1_BUFLM3_Msk = 0x8
	// Bit BUFLM3.
	CAN_IMASK1_BUFLM3 = 0x8
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM3_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM3_1 = 0x1
	// Position of BUFLM4 field.
	CAN_IMASK1_BUFLM4_Pos = 0x4
	// Bit mask of BUFLM4 field.
	CAN_IMASK1_BUFLM4_Msk = 0x10
	// Bit BUFLM4.
	CAN_IMASK1_BUFLM4 = 0x10
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM4_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM4_1 = 0x1
	// Position of BUFLM5 field.
	CAN_IMASK1_BUFLM5_Pos = 0x5
	// Bit mask of BUFLM5 field.
	CAN_IMASK1_BUFLM5_Msk = 0x20
	// Bit BUFLM5.
	CAN_IMASK1_BUFLM5 = 0x20
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM5_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM5_1 = 0x1
	// Position of BUFLM6 field.
	CAN_IMASK1_BUFLM6_Pos = 0x6
	// Bit mask of BUFLM6 field.
	CAN_IMASK1_BUFLM6_Msk = 0x40
	// Bit BUFLM6.
	CAN_IMASK1_BUFLM6 = 0x40
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM6_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM6_1 = 0x1
	// Position of BUFLM7 field.
	CAN_IMASK1_BUFLM7_Pos = 0x7
	// Bit mask of BUFLM7 field.
	CAN_IMASK1_BUFLM7_Msk = 0x80
	// Bit BUFLM7.
	CAN_IMASK1_BUFLM7 = 0x80
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM7_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM7_1 = 0x1
	// Position of BUFLM8 field.
	CAN_IMASK1_BUFLM8_Pos = 0x8
	// Bit mask of BUFLM8 field.
	CAN_IMASK1_BUFLM8_Msk = 0x100
	// Bit BUFLM8.
	CAN_IMASK1_BUFLM8 = 0x100
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM8_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM8_1 = 0x1
	// Position of BUFLM9 field.
	CAN_IMASK1_BUFLM9_Pos = 0x9
	// Bit mask of BUFLM9 field.
	CAN_IMASK1_BUFLM9_Msk = 0x200
	// Bit BUFLM9.
	CAN_IMASK1_BUFLM9 = 0x200
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM9_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM9_1 = 0x1
	// Position of BUFLM10 field.
	CAN_IMASK1_BUFLM10_Pos = 0xa
	// Bit mask of BUFLM10 field.
	CAN_IMASK1_BUFLM10_Msk = 0x400
	// Bit BUFLM10.
	CAN_IMASK1_BUFLM10 = 0x400
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM10_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM10_1 = 0x1
	// Position of BUFLM11 field.
	CAN_IMASK1_BUFLM11_Pos = 0xb
	// Bit mask of BUFLM11 field.
	CAN_IMASK1_BUFLM11_Msk = 0x800
	// Bit BUFLM11.
	CAN_IMASK1_BUFLM11 = 0x800
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM11_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM11_1 = 0x1
	// Position of BUFLM12 field.
	CAN_IMASK1_BUFLM12_Pos = 0xc
	// Bit mask of BUFLM12 field.
	CAN_IMASK1_BUFLM12_Msk = 0x1000
	// Bit BUFLM12.
	CAN_IMASK1_BUFLM12 = 0x1000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM12_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM12_1 = 0x1
	// Position of BUFLM13 field.
	CAN_IMASK1_BUFLM13_Pos = 0xd
	// Bit mask of BUFLM13 field.
	CAN_IMASK1_BUFLM13_Msk = 0x2000
	// Bit BUFLM13.
	CAN_IMASK1_BUFLM13 = 0x2000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM13_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM13_1 = 0x1
	// Position of BUFLM14 field.
	CAN_IMASK1_BUFLM14_Pos = 0xe
	// Bit mask of BUFLM14 field.
	CAN_IMASK1_BUFLM14_Msk = 0x4000
	// Bit BUFLM14.
	CAN_IMASK1_BUFLM14 = 0x4000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM14_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM14_1 = 0x1
	// Position of BUFLM15 field.
	CAN_IMASK1_BUFLM15_Pos = 0xf
	// Bit mask of BUFLM15 field.
	CAN_IMASK1_BUFLM15_Msk = 0x8000
	// Bit BUFLM15.
	CAN_IMASK1_BUFLM15 = 0x8000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM15_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM15_1 = 0x1
	// Position of BUFLM16 field.
	CAN_IMASK1_BUFLM16_Pos = 0x10
	// Bit mask of BUFLM16 field.
	CAN_IMASK1_BUFLM16_Msk = 0x10000
	// Bit BUFLM16.
	CAN_IMASK1_BUFLM16 = 0x10000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM16_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM16_1 = 0x1
	// Position of BUFLM17 field.
	CAN_IMASK1_BUFLM17_Pos = 0x11
	// Bit mask of BUFLM17 field.
	CAN_IMASK1_BUFLM17_Msk = 0x20000
	// Bit BUFLM17.
	CAN_IMASK1_BUFLM17 = 0x20000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM17_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM17_1 = 0x1
	// Position of BUFLM18 field.
	CAN_IMASK1_BUFLM18_Pos = 0x12
	// Bit mask of BUFLM18 field.
	CAN_IMASK1_BUFLM18_Msk = 0x40000
	// Bit BUFLM18.
	CAN_IMASK1_BUFLM18 = 0x40000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM18_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM18_1 = 0x1
	// Position of BUFLM19 field.
	CAN_IMASK1_BUFLM19_Pos = 0x13
	// Bit mask of BUFLM19 field.
	CAN_IMASK1_BUFLM19_Msk = 0x80000
	// Bit BUFLM19.
	CAN_IMASK1_BUFLM19 = 0x80000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM19_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM19_1 = 0x1
	// Position of BUFLM20 field.
	CAN_IMASK1_BUFLM20_Pos = 0x14
	// Bit mask of BUFLM20 field.
	CAN_IMASK1_BUFLM20_Msk = 0x100000
	// Bit BUFLM20.
	CAN_IMASK1_BUFLM20 = 0x100000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM20_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM20_1 = 0x1
	// Position of BUFLM21 field.
	CAN_IMASK1_BUFLM21_Pos = 0x15
	// Bit mask of BUFLM21 field.
	CAN_IMASK1_BUFLM21_Msk = 0x200000
	// Bit BUFLM21.
	CAN_IMASK1_BUFLM21 = 0x200000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM21_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM21_1 = 0x1
	// Position of BUFLM22 field.
	CAN_IMASK1_BUFLM22_Pos = 0x16
	// Bit mask of BUFLM22 field.
	CAN_IMASK1_BUFLM22_Msk = 0x400000
	// Bit BUFLM22.
	CAN_IMASK1_BUFLM22 = 0x400000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM22_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM22_1 = 0x1
	// Position of BUFLM23 field.
	CAN_IMASK1_BUFLM23_Pos = 0x17
	// Bit mask of BUFLM23 field.
	CAN_IMASK1_BUFLM23_Msk = 0x800000
	// Bit BUFLM23.
	CAN_IMASK1_BUFLM23 = 0x800000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM23_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM23_1 = 0x1
	// Position of BUFLM24 field.
	CAN_IMASK1_BUFLM24_Pos = 0x18
	// Bit mask of BUFLM24 field.
	CAN_IMASK1_BUFLM24_Msk = 0x1000000
	// Bit BUFLM24.
	CAN_IMASK1_BUFLM24 = 0x1000000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM24_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM24_1 = 0x1
	// Position of BUFLM25 field.
	CAN_IMASK1_BUFLM25_Pos = 0x19
	// Bit mask of BUFLM25 field.
	CAN_IMASK1_BUFLM25_Msk = 0x2000000
	// Bit BUFLM25.
	CAN_IMASK1_BUFLM25 = 0x2000000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM25_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM25_1 = 0x1
	// Position of BUFLM26 field.
	CAN_IMASK1_BUFLM26_Pos = 0x1a
	// Bit mask of BUFLM26 field.
	CAN_IMASK1_BUFLM26_Msk = 0x4000000
	// Bit BUFLM26.
	CAN_IMASK1_BUFLM26 = 0x4000000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM26_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM26_1 = 0x1
	// Position of BUFLM27 field.
	CAN_IMASK1_BUFLM27_Pos = 0x1b
	// Bit mask of BUFLM27 field.
	CAN_IMASK1_BUFLM27_Msk = 0x8000000
	// Bit BUFLM27.
	CAN_IMASK1_BUFLM27 = 0x8000000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM27_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM27_1 = 0x1
	// Position of BUFLM28 field.
	CAN_IMASK1_BUFLM28_Pos = 0x1c
	// Bit mask of BUFLM28 field.
	CAN_IMASK1_BUFLM28_Msk = 0x10000000
	// Bit BUFLM28.
	CAN_IMASK1_BUFLM28 = 0x10000000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM28_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM28_1 = 0x1
	// Position of BUFLM29 field.
	CAN_IMASK1_BUFLM29_Pos = 0x1d
	// Bit mask of BUFLM29 field.
	CAN_IMASK1_BUFLM29_Msk = 0x20000000
	// Bit BUFLM29.
	CAN_IMASK1_BUFLM29 = 0x20000000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM29_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM29_1 = 0x1
	// Position of BUFLM30 field.
	CAN_IMASK1_BUFLM30_Pos = 0x1e
	// Bit mask of BUFLM30 field.
	CAN_IMASK1_BUFLM30_Msk = 0x40000000
	// Bit BUFLM30.
	CAN_IMASK1_BUFLM30 = 0x40000000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM30_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM30_1 = 0x1
	// Position of BUFLM31 field.
	CAN_IMASK1_BUFLM31_Pos = 0x1f
	// Bit mask of BUFLM31 field.
	CAN_IMASK1_BUFLM31_Msk = 0x80000000
	// Bit BUFLM31.
	CAN_IMASK1_BUFLM31 = 0x80000000
	// The corresponding buffer Interrupt is disabled.
	CAN_IMASK1_BUFLM31_0 = 0x0
	// The corresponding buffer Interrupt is enabled.
	CAN_IMASK1_BUFLM31_1 = 0x1

	// IFLAG1: Interrupt Flags 1 register
	// Position of BUF0I field.
	CAN_IFLAG1_BUF0I_Pos = 0x0
	// Bit mask of BUF0I field.
	CAN_IFLAG1_BUF0I_Msk = 0x1
	// Bit BUF0I.
	CAN_IFLAG1_BUF0I = 0x1
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF0I_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF0I_1 = 0x1
	// Position of BUF4TO1I0 field.
	CAN_IFLAG1_BUF4TO1I0_Pos = 0x1
	// Bit mask of BUF4TO1I0 field.
	CAN_IFLAG1_BUF4TO1I0_Msk = 0x2
	// Bit BUF4TO1I0.
	CAN_IFLAG1_BUF4TO1I0 = 0x2
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF4TO1I0_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF4TO1I0_1 = 0x1
	// Position of BUF4TO1I1 field.
	CAN_IFLAG1_BUF4TO1I1_Pos = 0x2
	// Bit mask of BUF4TO1I1 field.
	CAN_IFLAG1_BUF4TO1I1_Msk = 0x4
	// Bit BUF4TO1I1.
	CAN_IFLAG1_BUF4TO1I1 = 0x4
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF4TO1I1_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF4TO1I1_1 = 0x1
	// Position of BUF4TO1I2 field.
	CAN_IFLAG1_BUF4TO1I2_Pos = 0x3
	// Bit mask of BUF4TO1I2 field.
	CAN_IFLAG1_BUF4TO1I2_Msk = 0x8
	// Bit BUF4TO1I2.
	CAN_IFLAG1_BUF4TO1I2 = 0x8
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF4TO1I2_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF4TO1I2_1 = 0x1
	// Position of BUF4TO1I3 field.
	CAN_IFLAG1_BUF4TO1I3_Pos = 0x4
	// Bit mask of BUF4TO1I3 field.
	CAN_IFLAG1_BUF4TO1I3_Msk = 0x10
	// Bit BUF4TO1I3.
	CAN_IFLAG1_BUF4TO1I3 = 0x10
	// The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF4TO1I3_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
	CAN_IFLAG1_BUF4TO1I3_1 = 0x1
	// Position of BUF5I field.
	CAN_IFLAG1_BUF5I_Pos = 0x5
	// Bit mask of BUF5I field.
	CAN_IFLAG1_BUF5I_Msk = 0x20
	// Bit BUF5I.
	CAN_IFLAG1_BUF5I = 0x20
	// No occurrence of MB5 completing transmission/reception when MCR[RFEN]=0, or of frame(s) available in the FIFO, when MCR[RFEN]=1
	CAN_IFLAG1_BUF5I_0 = 0x0
	// MB5 completed transmission/reception when MCR[RFEN]=0, or frame(s) available in the Rx FIFO when MCR[RFEN]=1
	CAN_IFLAG1_BUF5I_1 = 0x1
	// Position of BUF6I field.
	CAN_IFLAG1_BUF6I_Pos = 0x6
	// Bit mask of BUF6I field.
	CAN_IFLAG1_BUF6I_Msk = 0x40
	// Bit BUF6I.
	CAN_IFLAG1_BUF6I = 0x40
	// No occurrence of MB6 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1
	CAN_IFLAG1_BUF6I_0 = 0x0
	// MB6 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO almost full when MCR[RFEN]=1
	CAN_IFLAG1_BUF6I_1 = 0x1
	// Position of BUF7I field.
	CAN_IFLAG1_BUF7I_Pos = 0x7
	// Bit mask of BUF7I field.
	CAN_IFLAG1_BUF7I_Msk = 0x80
	// Bit BUF7I.
	CAN_IFLAG1_BUF7I = 0x80
	// No occurrence of MB7 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1
	CAN_IFLAG1_BUF7I_0 = 0x0
	// MB7 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO overflow when MCR[RFEN]=1
	CAN_IFLAG1_BUF7I_1 = 0x1
	// Position of BUF31TO8I0 field.
	CAN_IFLAG1_BUF31TO8I0_Pos = 0x8
	// Bit mask of BUF31TO8I0 field.
	CAN_IFLAG1_BUF31TO8I0_Msk = 0x100
	// Bit BUF31TO8I0.
	CAN_IFLAG1_BUF31TO8I0 = 0x100
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I0_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I0_1 = 0x1
	// Position of BUF31TO8I1 field.
	CAN_IFLAG1_BUF31TO8I1_Pos = 0x9
	// Bit mask of BUF31TO8I1 field.
	CAN_IFLAG1_BUF31TO8I1_Msk = 0x200
	// Bit BUF31TO8I1.
	CAN_IFLAG1_BUF31TO8I1 = 0x200
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I1_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I1_1 = 0x1
	// Position of BUF31TO8I2 field.
	CAN_IFLAG1_BUF31TO8I2_Pos = 0xa
	// Bit mask of BUF31TO8I2 field.
	CAN_IFLAG1_BUF31TO8I2_Msk = 0x400
	// Bit BUF31TO8I2.
	CAN_IFLAG1_BUF31TO8I2 = 0x400
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I2_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I2_1 = 0x1
	// Position of BUF31TO8I3 field.
	CAN_IFLAG1_BUF31TO8I3_Pos = 0xb
	// Bit mask of BUF31TO8I3 field.
	CAN_IFLAG1_BUF31TO8I3_Msk = 0x800
	// Bit BUF31TO8I3.
	CAN_IFLAG1_BUF31TO8I3 = 0x800
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I3_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I3_1 = 0x1
	// Position of BUF31TO8I4 field.
	CAN_IFLAG1_BUF31TO8I4_Pos = 0xc
	// Bit mask of BUF31TO8I4 field.
	CAN_IFLAG1_BUF31TO8I4_Msk = 0x1000
	// Bit BUF31TO8I4.
	CAN_IFLAG1_BUF31TO8I4 = 0x1000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I4_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I4_1 = 0x1
	// Position of BUF31TO8I5 field.
	CAN_IFLAG1_BUF31TO8I5_Pos = 0xd
	// Bit mask of BUF31TO8I5 field.
	CAN_IFLAG1_BUF31TO8I5_Msk = 0x2000
	// Bit BUF31TO8I5.
	CAN_IFLAG1_BUF31TO8I5 = 0x2000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I5_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I5_1 = 0x1
	// Position of BUF31TO8I6 field.
	CAN_IFLAG1_BUF31TO8I6_Pos = 0xe
	// Bit mask of BUF31TO8I6 field.
	CAN_IFLAG1_BUF31TO8I6_Msk = 0x4000
	// Bit BUF31TO8I6.
	CAN_IFLAG1_BUF31TO8I6 = 0x4000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I6_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I6_1 = 0x1
	// Position of BUF31TO8I7 field.
	CAN_IFLAG1_BUF31TO8I7_Pos = 0xf
	// Bit mask of BUF31TO8I7 field.
	CAN_IFLAG1_BUF31TO8I7_Msk = 0x8000
	// Bit BUF31TO8I7.
	CAN_IFLAG1_BUF31TO8I7 = 0x8000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I7_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I7_1 = 0x1
	// Position of BUF31TO8I8 field.
	CAN_IFLAG1_BUF31TO8I8_Pos = 0x10
	// Bit mask of BUF31TO8I8 field.
	CAN_IFLAG1_BUF31TO8I8_Msk = 0x10000
	// Bit BUF31TO8I8.
	CAN_IFLAG1_BUF31TO8I8 = 0x10000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I8_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I8_1 = 0x1
	// Position of BUF31TO8I9 field.
	CAN_IFLAG1_BUF31TO8I9_Pos = 0x11
	// Bit mask of BUF31TO8I9 field.
	CAN_IFLAG1_BUF31TO8I9_Msk = 0x20000
	// Bit BUF31TO8I9.
	CAN_IFLAG1_BUF31TO8I9 = 0x20000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I9_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I9_1 = 0x1
	// Position of BUF31TO8I10 field.
	CAN_IFLAG1_BUF31TO8I10_Pos = 0x12
	// Bit mask of BUF31TO8I10 field.
	CAN_IFLAG1_BUF31TO8I10_Msk = 0x40000
	// Bit BUF31TO8I10.
	CAN_IFLAG1_BUF31TO8I10 = 0x40000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I10_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I10_1 = 0x1
	// Position of BUF31TO8I11 field.
	CAN_IFLAG1_BUF31TO8I11_Pos = 0x13
	// Bit mask of BUF31TO8I11 field.
	CAN_IFLAG1_BUF31TO8I11_Msk = 0x80000
	// Bit BUF31TO8I11.
	CAN_IFLAG1_BUF31TO8I11 = 0x80000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I11_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I11_1 = 0x1
	// Position of BUF31TO8I12 field.
	CAN_IFLAG1_BUF31TO8I12_Pos = 0x14
	// Bit mask of BUF31TO8I12 field.
	CAN_IFLAG1_BUF31TO8I12_Msk = 0x100000
	// Bit BUF31TO8I12.
	CAN_IFLAG1_BUF31TO8I12 = 0x100000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I12_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I12_1 = 0x1
	// Position of BUF31TO8I13 field.
	CAN_IFLAG1_BUF31TO8I13_Pos = 0x15
	// Bit mask of BUF31TO8I13 field.
	CAN_IFLAG1_BUF31TO8I13_Msk = 0x200000
	// Bit BUF31TO8I13.
	CAN_IFLAG1_BUF31TO8I13 = 0x200000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I13_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I13_1 = 0x1
	// Position of BUF31TO8I14 field.
	CAN_IFLAG1_BUF31TO8I14_Pos = 0x16
	// Bit mask of BUF31TO8I14 field.
	CAN_IFLAG1_BUF31TO8I14_Msk = 0x400000
	// Bit BUF31TO8I14.
	CAN_IFLAG1_BUF31TO8I14 = 0x400000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I14_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I14_1 = 0x1
	// Position of BUF31TO8I15 field.
	CAN_IFLAG1_BUF31TO8I15_Pos = 0x17
	// Bit mask of BUF31TO8I15 field.
	CAN_IFLAG1_BUF31TO8I15_Msk = 0x800000
	// Bit BUF31TO8I15.
	CAN_IFLAG1_BUF31TO8I15 = 0x800000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I15_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I15_1 = 0x1
	// Position of BUF31TO8I16 field.
	CAN_IFLAG1_BUF31TO8I16_Pos = 0x18
	// Bit mask of BUF31TO8I16 field.
	CAN_IFLAG1_BUF31TO8I16_Msk = 0x1000000
	// Bit BUF31TO8I16.
	CAN_IFLAG1_BUF31TO8I16 = 0x1000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I16_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I16_1 = 0x1
	// Position of BUF31TO8I17 field.
	CAN_IFLAG1_BUF31TO8I17_Pos = 0x19
	// Bit mask of BUF31TO8I17 field.
	CAN_IFLAG1_BUF31TO8I17_Msk = 0x2000000
	// Bit BUF31TO8I17.
	CAN_IFLAG1_BUF31TO8I17 = 0x2000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I17_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I17_1 = 0x1
	// Position of BUF31TO8I18 field.
	CAN_IFLAG1_BUF31TO8I18_Pos = 0x1a
	// Bit mask of BUF31TO8I18 field.
	CAN_IFLAG1_BUF31TO8I18_Msk = 0x4000000
	// Bit BUF31TO8I18.
	CAN_IFLAG1_BUF31TO8I18 = 0x4000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I18_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I18_1 = 0x1
	// Position of BUF31TO8I19 field.
	CAN_IFLAG1_BUF31TO8I19_Pos = 0x1b
	// Bit mask of BUF31TO8I19 field.
	CAN_IFLAG1_BUF31TO8I19_Msk = 0x8000000
	// Bit BUF31TO8I19.
	CAN_IFLAG1_BUF31TO8I19 = 0x8000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I19_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I19_1 = 0x1
	// Position of BUF31TO8I20 field.
	CAN_IFLAG1_BUF31TO8I20_Pos = 0x1c
	// Bit mask of BUF31TO8I20 field.
	CAN_IFLAG1_BUF31TO8I20_Msk = 0x10000000
	// Bit BUF31TO8I20.
	CAN_IFLAG1_BUF31TO8I20 = 0x10000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I20_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I20_1 = 0x1
	// Position of BUF31TO8I21 field.
	CAN_IFLAG1_BUF31TO8I21_Pos = 0x1d
	// Bit mask of BUF31TO8I21 field.
	CAN_IFLAG1_BUF31TO8I21_Msk = 0x20000000
	// Bit BUF31TO8I21.
	CAN_IFLAG1_BUF31TO8I21 = 0x20000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I21_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I21_1 = 0x1
	// Position of BUF31TO8I22 field.
	CAN_IFLAG1_BUF31TO8I22_Pos = 0x1e
	// Bit mask of BUF31TO8I22 field.
	CAN_IFLAG1_BUF31TO8I22_Msk = 0x40000000
	// Bit BUF31TO8I22.
	CAN_IFLAG1_BUF31TO8I22 = 0x40000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I22_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I22_1 = 0x1
	// Position of BUF31TO8I23 field.
	CAN_IFLAG1_BUF31TO8I23_Pos = 0x1f
	// Bit mask of BUF31TO8I23 field.
	CAN_IFLAG1_BUF31TO8I23_Msk = 0x80000000
	// Bit BUF31TO8I23.
	CAN_IFLAG1_BUF31TO8I23 = 0x80000000
	// The corresponding buffer has no occurrence of successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I23_0 = 0x0
	// The corresponding buffer has successfully completed transmission or reception.
	CAN_IFLAG1_BUF31TO8I23_1 = 0x1

	// CTRL2: Control 2 register
	// Position of EACEN field.
	CAN_CTRL2_EACEN_Pos = 0x10
	// Bit mask of EACEN field.
	CAN_CTRL2_EACEN_Msk = 0x10000
	// Bit EACEN.
	CAN_CTRL2_EACEN = 0x10000
	// Rx Mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
	CAN_CTRL2_EACEN_0 = 0x0
	// Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.
	CAN_CTRL2_EACEN_1 = 0x1
	// Position of RRS field.
	CAN_CTRL2_RRS_Pos = 0x11
	// Bit mask of RRS field.
	CAN_CTRL2_RRS_Msk = 0x20000
	// Bit RRS.
	CAN_CTRL2_RRS = 0x20000
	// Remote Response Frame is generated.
	CAN_CTRL2_RRS_0 = 0x0
	// Remote Request Frame is stored.
	CAN_CTRL2_RRS_1 = 0x1
	// Position of MRP field.
	CAN_CTRL2_MRP_Pos = 0x12
	// Bit mask of MRP field.
	CAN_CTRL2_MRP_Msk = 0x40000
	// Bit MRP.
	CAN_CTRL2_MRP = 0x40000
	// Matching starts from Rx FIFO and continues on Mailboxes.
	CAN_CTRL2_MRP_0 = 0x0
	// Matching starts from Mailboxes and continues on Rx FIFO.
	CAN_CTRL2_MRP_1 = 0x1
	// Position of TASD field.
	CAN_CTRL2_TASD_Pos = 0x13
	// Bit mask of TASD field.
	CAN_CTRL2_TASD_Msk = 0xf80000
	// Position of RFFN field.
	CAN_CTRL2_RFFN_Pos = 0x18
	// Bit mask of RFFN field.
	CAN_CTRL2_RFFN_Msk = 0xf000000
	// Position of WRMFRZ field.
	CAN_CTRL2_WRMFRZ_Pos = 0x1c
	// Bit mask of WRMFRZ field.
	CAN_CTRL2_WRMFRZ_Msk = 0x10000000
	// Bit WRMFRZ.
	CAN_CTRL2_WRMFRZ = 0x10000000
	// Maintain the write access restrictions.
	CAN_CTRL2_WRMFRZ_0 = 0x0
	// Enable unrestricted write access to FlexCAN memory.
	CAN_CTRL2_WRMFRZ_1 = 0x1

	// ESR2: Error and Status 2 register
	// Position of IMB field.
	CAN_ESR2_IMB_Pos = 0xd
	// Bit mask of IMB field.
	CAN_ESR2_IMB_Msk = 0x2000
	// Bit IMB.
	CAN_ESR2_IMB = 0x2000
	// If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
	CAN_ESR2_IMB_0 = 0x0
	// If ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM content is the number of the first one.
	CAN_ESR2_IMB_1 = 0x1
	// Position of VPS field.
	CAN_ESR2_VPS_Pos = 0xe
	// Bit mask of VPS field.
	CAN_ESR2_VPS_Msk = 0x4000
	// Bit VPS.
	CAN_ESR2_VPS = 0x4000
	// Contents of IMB and LPTM are invalid.
	CAN_ESR2_VPS_0 = 0x0
	// Contents of IMB and LPTM are valid.
	CAN_ESR2_VPS_1 = 0x1
	// Position of LPTM field.
	CAN_ESR2_LPTM_Pos = 0x10
	// Bit mask of LPTM field.
	CAN_ESR2_LPTM_Msk = 0x7f0000

	// CRCR: CRC Register
	// Position of TXCRC field.
	CAN_CRCR_TXCRC_Pos = 0x0
	// Bit mask of TXCRC field.
	CAN_CRCR_TXCRC_Msk = 0x7fff
	// Position of MBCRC field.
	CAN_CRCR_MBCRC_Pos = 0x10
	// Bit mask of MBCRC field.
	CAN_CRCR_MBCRC_Msk = 0x7f0000

	// RXFGMASK: Rx FIFO Global Mask register
	// Position of FGM0 field.
	CAN_RXFGMASK_FGM0_Pos = 0x0
	// Bit mask of FGM0 field.
	CAN_RXFGMASK_FGM0_Msk = 0x1
	// Bit FGM0.
	CAN_RXFGMASK_FGM0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM0_1 = 0x1
	// Position of FGM1 field.
	CAN_RXFGMASK_FGM1_Pos = 0x1
	// Bit mask of FGM1 field.
	CAN_RXFGMASK_FGM1_Msk = 0x2
	// Bit FGM1.
	CAN_RXFGMASK_FGM1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM1_1 = 0x1
	// Position of FGM2 field.
	CAN_RXFGMASK_FGM2_Pos = 0x2
	// Bit mask of FGM2 field.
	CAN_RXFGMASK_FGM2_Msk = 0x4
	// Bit FGM2.
	CAN_RXFGMASK_FGM2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM2_1 = 0x1
	// Position of FGM3 field.
	CAN_RXFGMASK_FGM3_Pos = 0x3
	// Bit mask of FGM3 field.
	CAN_RXFGMASK_FGM3_Msk = 0x8
	// Bit FGM3.
	CAN_RXFGMASK_FGM3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM3_1 = 0x1
	// Position of FGM4 field.
	CAN_RXFGMASK_FGM4_Pos = 0x4
	// Bit mask of FGM4 field.
	CAN_RXFGMASK_FGM4_Msk = 0x10
	// Bit FGM4.
	CAN_RXFGMASK_FGM4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM4_1 = 0x1
	// Position of FGM5 field.
	CAN_RXFGMASK_FGM5_Pos = 0x5
	// Bit mask of FGM5 field.
	CAN_RXFGMASK_FGM5_Msk = 0x20
	// Bit FGM5.
	CAN_RXFGMASK_FGM5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM5_1 = 0x1
	// Position of FGM6 field.
	CAN_RXFGMASK_FGM6_Pos = 0x6
	// Bit mask of FGM6 field.
	CAN_RXFGMASK_FGM6_Msk = 0x40
	// Bit FGM6.
	CAN_RXFGMASK_FGM6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM6_1 = 0x1
	// Position of FGM7 field.
	CAN_RXFGMASK_FGM7_Pos = 0x7
	// Bit mask of FGM7 field.
	CAN_RXFGMASK_FGM7_Msk = 0x80
	// Bit FGM7.
	CAN_RXFGMASK_FGM7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM7_1 = 0x1
	// Position of FGM8 field.
	CAN_RXFGMASK_FGM8_Pos = 0x8
	// Bit mask of FGM8 field.
	CAN_RXFGMASK_FGM8_Msk = 0x100
	// Bit FGM8.
	CAN_RXFGMASK_FGM8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM8_1 = 0x1
	// Position of FGM9 field.
	CAN_RXFGMASK_FGM9_Pos = 0x9
	// Bit mask of FGM9 field.
	CAN_RXFGMASK_FGM9_Msk = 0x200
	// Bit FGM9.
	CAN_RXFGMASK_FGM9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM9_1 = 0x1
	// Position of FGM10 field.
	CAN_RXFGMASK_FGM10_Pos = 0xa
	// Bit mask of FGM10 field.
	CAN_RXFGMASK_FGM10_Msk = 0x400
	// Bit FGM10.
	CAN_RXFGMASK_FGM10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM10_1 = 0x1
	// Position of FGM11 field.
	CAN_RXFGMASK_FGM11_Pos = 0xb
	// Bit mask of FGM11 field.
	CAN_RXFGMASK_FGM11_Msk = 0x800
	// Bit FGM11.
	CAN_RXFGMASK_FGM11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM11_1 = 0x1
	// Position of FGM12 field.
	CAN_RXFGMASK_FGM12_Pos = 0xc
	// Bit mask of FGM12 field.
	CAN_RXFGMASK_FGM12_Msk = 0x1000
	// Bit FGM12.
	CAN_RXFGMASK_FGM12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM12_1 = 0x1
	// Position of FGM13 field.
	CAN_RXFGMASK_FGM13_Pos = 0xd
	// Bit mask of FGM13 field.
	CAN_RXFGMASK_FGM13_Msk = 0x2000
	// Bit FGM13.
	CAN_RXFGMASK_FGM13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM13_1 = 0x1
	// Position of FGM14 field.
	CAN_RXFGMASK_FGM14_Pos = 0xe
	// Bit mask of FGM14 field.
	CAN_RXFGMASK_FGM14_Msk = 0x4000
	// Bit FGM14.
	CAN_RXFGMASK_FGM14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM14_1 = 0x1
	// Position of FGM15 field.
	CAN_RXFGMASK_FGM15_Pos = 0xf
	// Bit mask of FGM15 field.
	CAN_RXFGMASK_FGM15_Msk = 0x8000
	// Bit FGM15.
	CAN_RXFGMASK_FGM15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM15_1 = 0x1
	// Position of FGM16 field.
	CAN_RXFGMASK_FGM16_Pos = 0x10
	// Bit mask of FGM16 field.
	CAN_RXFGMASK_FGM16_Msk = 0x10000
	// Bit FGM16.
	CAN_RXFGMASK_FGM16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM16_1 = 0x1
	// Position of FGM17 field.
	CAN_RXFGMASK_FGM17_Pos = 0x11
	// Bit mask of FGM17 field.
	CAN_RXFGMASK_FGM17_Msk = 0x20000
	// Bit FGM17.
	CAN_RXFGMASK_FGM17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM17_1 = 0x1
	// Position of FGM18 field.
	CAN_RXFGMASK_FGM18_Pos = 0x12
	// Bit mask of FGM18 field.
	CAN_RXFGMASK_FGM18_Msk = 0x40000
	// Bit FGM18.
	CAN_RXFGMASK_FGM18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM18_1 = 0x1
	// Position of FGM19 field.
	CAN_RXFGMASK_FGM19_Pos = 0x13
	// Bit mask of FGM19 field.
	CAN_RXFGMASK_FGM19_Msk = 0x80000
	// Bit FGM19.
	CAN_RXFGMASK_FGM19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM19_1 = 0x1
	// Position of FGM20 field.
	CAN_RXFGMASK_FGM20_Pos = 0x14
	// Bit mask of FGM20 field.
	CAN_RXFGMASK_FGM20_Msk = 0x100000
	// Bit FGM20.
	CAN_RXFGMASK_FGM20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM20_1 = 0x1
	// Position of FGM21 field.
	CAN_RXFGMASK_FGM21_Pos = 0x15
	// Bit mask of FGM21 field.
	CAN_RXFGMASK_FGM21_Msk = 0x200000
	// Bit FGM21.
	CAN_RXFGMASK_FGM21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM21_1 = 0x1
	// Position of FGM22 field.
	CAN_RXFGMASK_FGM22_Pos = 0x16
	// Bit mask of FGM22 field.
	CAN_RXFGMASK_FGM22_Msk = 0x400000
	// Bit FGM22.
	CAN_RXFGMASK_FGM22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM22_1 = 0x1
	// Position of FGM23 field.
	CAN_RXFGMASK_FGM23_Pos = 0x17
	// Bit mask of FGM23 field.
	CAN_RXFGMASK_FGM23_Msk = 0x800000
	// Bit FGM23.
	CAN_RXFGMASK_FGM23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM23_1 = 0x1
	// Position of FGM24 field.
	CAN_RXFGMASK_FGM24_Pos = 0x18
	// Bit mask of FGM24 field.
	CAN_RXFGMASK_FGM24_Msk = 0x1000000
	// Bit FGM24.
	CAN_RXFGMASK_FGM24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM24_1 = 0x1
	// Position of FGM25 field.
	CAN_RXFGMASK_FGM25_Pos = 0x19
	// Bit mask of FGM25 field.
	CAN_RXFGMASK_FGM25_Msk = 0x2000000
	// Bit FGM25.
	CAN_RXFGMASK_FGM25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM25_1 = 0x1
	// Position of FGM26 field.
	CAN_RXFGMASK_FGM26_Pos = 0x1a
	// Bit mask of FGM26 field.
	CAN_RXFGMASK_FGM26_Msk = 0x4000000
	// Bit FGM26.
	CAN_RXFGMASK_FGM26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM26_1 = 0x1
	// Position of FGM27 field.
	CAN_RXFGMASK_FGM27_Pos = 0x1b
	// Bit mask of FGM27 field.
	CAN_RXFGMASK_FGM27_Msk = 0x8000000
	// Bit FGM27.
	CAN_RXFGMASK_FGM27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM27_1 = 0x1
	// Position of FGM28 field.
	CAN_RXFGMASK_FGM28_Pos = 0x1c
	// Bit mask of FGM28 field.
	CAN_RXFGMASK_FGM28_Msk = 0x10000000
	// Bit FGM28.
	CAN_RXFGMASK_FGM28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM28_1 = 0x1
	// Position of FGM29 field.
	CAN_RXFGMASK_FGM29_Pos = 0x1d
	// Bit mask of FGM29 field.
	CAN_RXFGMASK_FGM29_Msk = 0x20000000
	// Bit FGM29.
	CAN_RXFGMASK_FGM29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM29_1 = 0x1
	// Position of FGM30 field.
	CAN_RXFGMASK_FGM30_Pos = 0x1e
	// Bit mask of FGM30 field.
	CAN_RXFGMASK_FGM30_Msk = 0x40000000
	// Bit FGM30.
	CAN_RXFGMASK_FGM30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM30_1 = 0x1
	// Position of FGM31 field.
	CAN_RXFGMASK_FGM31_Pos = 0x1f
	// Bit mask of FGM31 field.
	CAN_RXFGMASK_FGM31_Msk = 0x80000000
	// Bit FGM31.
	CAN_RXFGMASK_FGM31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXFGMASK_FGM31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXFGMASK_FGM31_1 = 0x1

	// RXFIR: Rx FIFO Information Register
	// Position of IDHIT field.
	CAN_RXFIR_IDHIT_Pos = 0x0
	// Bit mask of IDHIT field.
	CAN_RXFIR_IDHIT_Msk = 0x1ff

	// CS0: Message Buffer 0 CS Register
	// Position of TIME_STAMP field.
	CAN_CS0_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS0_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS0_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS0_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS0_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS0_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS0_RTR = 0x100000
	// Position of IDE field.
	CAN_CS0_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS0_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS0_IDE = 0x200000
	// Position of SRR field.
	CAN_CS0_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS0_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS0_SRR = 0x400000
	// Position of CODE field.
	CAN_CS0_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS0_CODE_Msk = 0xf000000

	// ID0: Message Buffer 0 ID Register
	// Position of EXT field.
	CAN_ID0_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID0_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID0_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID0_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID0_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID0_PRIO_Msk = 0xe0000000

	// WORD00: Message Buffer 0 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD00_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD00_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD00_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD00_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD00_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD00_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD00_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD00_DATA_BYTE_0_Msk = 0xff000000

	// WORD10: Message Buffer 0 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD10_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD10_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD10_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD10_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD10_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD10_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD10_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD10_DATA_BYTE_4_Msk = 0xff000000

	// CS1: Message Buffer 1 CS Register
	// Position of TIME_STAMP field.
	CAN_CS1_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS1_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS1_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS1_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS1_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS1_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS1_RTR = 0x100000
	// Position of IDE field.
	CAN_CS1_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS1_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS1_IDE = 0x200000
	// Position of SRR field.
	CAN_CS1_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS1_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS1_SRR = 0x400000
	// Position of CODE field.
	CAN_CS1_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS1_CODE_Msk = 0xf000000

	// ID1: Message Buffer 1 ID Register
	// Position of EXT field.
	CAN_ID1_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID1_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID1_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID1_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID1_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID1_PRIO_Msk = 0xe0000000

	// WORD01: Message Buffer 1 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD01_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD01_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD01_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD01_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD01_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD01_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD01_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD01_DATA_BYTE_0_Msk = 0xff000000

	// WORD11: Message Buffer 1 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD11_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD11_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD11_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD11_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD11_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD11_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD11_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD11_DATA_BYTE_4_Msk = 0xff000000

	// CS2: Message Buffer 2 CS Register
	// Position of TIME_STAMP field.
	CAN_CS2_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS2_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS2_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS2_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS2_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS2_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS2_RTR = 0x100000
	// Position of IDE field.
	CAN_CS2_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS2_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS2_IDE = 0x200000
	// Position of SRR field.
	CAN_CS2_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS2_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS2_SRR = 0x400000
	// Position of CODE field.
	CAN_CS2_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS2_CODE_Msk = 0xf000000

	// ID2: Message Buffer 2 ID Register
	// Position of EXT field.
	CAN_ID2_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID2_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID2_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID2_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID2_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID2_PRIO_Msk = 0xe0000000

	// WORD02: Message Buffer 2 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD02_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD02_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD02_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD02_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD02_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD02_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD02_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD02_DATA_BYTE_0_Msk = 0xff000000

	// WORD12: Message Buffer 2 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD12_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD12_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD12_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD12_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD12_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD12_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD12_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD12_DATA_BYTE_4_Msk = 0xff000000

	// CS3: Message Buffer 3 CS Register
	// Position of TIME_STAMP field.
	CAN_CS3_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS3_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS3_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS3_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS3_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS3_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS3_RTR = 0x100000
	// Position of IDE field.
	CAN_CS3_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS3_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS3_IDE = 0x200000
	// Position of SRR field.
	CAN_CS3_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS3_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS3_SRR = 0x400000
	// Position of CODE field.
	CAN_CS3_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS3_CODE_Msk = 0xf000000

	// ID3: Message Buffer 3 ID Register
	// Position of EXT field.
	CAN_ID3_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID3_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID3_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID3_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID3_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID3_PRIO_Msk = 0xe0000000

	// WORD03: Message Buffer 3 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD03_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD03_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD03_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD03_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD03_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD03_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD03_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD03_DATA_BYTE_0_Msk = 0xff000000

	// WORD13: Message Buffer 3 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD13_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD13_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD13_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD13_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD13_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD13_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD13_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD13_DATA_BYTE_4_Msk = 0xff000000

	// CS4: Message Buffer 4 CS Register
	// Position of TIME_STAMP field.
	CAN_CS4_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS4_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS4_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS4_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS4_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS4_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS4_RTR = 0x100000
	// Position of IDE field.
	CAN_CS4_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS4_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS4_IDE = 0x200000
	// Position of SRR field.
	CAN_CS4_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS4_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS4_SRR = 0x400000
	// Position of CODE field.
	CAN_CS4_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS4_CODE_Msk = 0xf000000

	// ID4: Message Buffer 4 ID Register
	// Position of EXT field.
	CAN_ID4_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID4_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID4_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID4_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID4_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID4_PRIO_Msk = 0xe0000000

	// WORD04: Message Buffer 4 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD04_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD04_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD04_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD04_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD04_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD04_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD04_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD04_DATA_BYTE_0_Msk = 0xff000000

	// WORD14: Message Buffer 4 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD14_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD14_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD14_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD14_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD14_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD14_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD14_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD14_DATA_BYTE_4_Msk = 0xff000000

	// CS5: Message Buffer 5 CS Register
	// Position of TIME_STAMP field.
	CAN_CS5_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS5_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS5_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS5_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS5_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS5_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS5_RTR = 0x100000
	// Position of IDE field.
	CAN_CS5_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS5_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS5_IDE = 0x200000
	// Position of SRR field.
	CAN_CS5_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS5_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS5_SRR = 0x400000
	// Position of CODE field.
	CAN_CS5_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS5_CODE_Msk = 0xf000000

	// ID5: Message Buffer 5 ID Register
	// Position of EXT field.
	CAN_ID5_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID5_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID5_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID5_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID5_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID5_PRIO_Msk = 0xe0000000

	// WORD05: Message Buffer 5 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD05_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD05_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD05_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD05_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD05_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD05_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD05_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD05_DATA_BYTE_0_Msk = 0xff000000

	// WORD15: Message Buffer 5 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD15_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD15_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD15_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD15_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD15_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD15_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD15_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD15_DATA_BYTE_4_Msk = 0xff000000

	// CS6: Message Buffer 6 CS Register
	// Position of TIME_STAMP field.
	CAN_CS6_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS6_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS6_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS6_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS6_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS6_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS6_RTR = 0x100000
	// Position of IDE field.
	CAN_CS6_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS6_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS6_IDE = 0x200000
	// Position of SRR field.
	CAN_CS6_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS6_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS6_SRR = 0x400000
	// Position of CODE field.
	CAN_CS6_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS6_CODE_Msk = 0xf000000

	// ID6: Message Buffer 6 ID Register
	// Position of EXT field.
	CAN_ID6_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID6_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID6_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID6_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID6_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID6_PRIO_Msk = 0xe0000000

	// WORD06: Message Buffer 6 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD06_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD06_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD06_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD06_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD06_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD06_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD06_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD06_DATA_BYTE_0_Msk = 0xff000000

	// WORD16: Message Buffer 6 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD16_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD16_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD16_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD16_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD16_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD16_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD16_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD16_DATA_BYTE_4_Msk = 0xff000000

	// CS7: Message Buffer 7 CS Register
	// Position of TIME_STAMP field.
	CAN_CS7_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS7_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS7_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS7_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS7_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS7_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS7_RTR = 0x100000
	// Position of IDE field.
	CAN_CS7_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS7_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS7_IDE = 0x200000
	// Position of SRR field.
	CAN_CS7_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS7_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS7_SRR = 0x400000
	// Position of CODE field.
	CAN_CS7_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS7_CODE_Msk = 0xf000000

	// ID7: Message Buffer 7 ID Register
	// Position of EXT field.
	CAN_ID7_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID7_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID7_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID7_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID7_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID7_PRIO_Msk = 0xe0000000

	// WORD07: Message Buffer 7 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD07_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD07_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD07_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD07_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD07_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD07_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD07_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD07_DATA_BYTE_0_Msk = 0xff000000

	// WORD17: Message Buffer 7 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD17_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD17_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD17_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD17_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD17_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD17_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD17_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD17_DATA_BYTE_4_Msk = 0xff000000

	// CS8: Message Buffer 8 CS Register
	// Position of TIME_STAMP field.
	CAN_CS8_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS8_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS8_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS8_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS8_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS8_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS8_RTR = 0x100000
	// Position of IDE field.
	CAN_CS8_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS8_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS8_IDE = 0x200000
	// Position of SRR field.
	CAN_CS8_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS8_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS8_SRR = 0x400000
	// Position of CODE field.
	CAN_CS8_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS8_CODE_Msk = 0xf000000

	// ID8: Message Buffer 8 ID Register
	// Position of EXT field.
	CAN_ID8_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID8_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID8_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID8_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID8_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID8_PRIO_Msk = 0xe0000000

	// WORD08: Message Buffer 8 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD08_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD08_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD08_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD08_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD08_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD08_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD08_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD08_DATA_BYTE_0_Msk = 0xff000000

	// WORD18: Message Buffer 8 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD18_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD18_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD18_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD18_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD18_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD18_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD18_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD18_DATA_BYTE_4_Msk = 0xff000000

	// CS9: Message Buffer 9 CS Register
	// Position of TIME_STAMP field.
	CAN_CS9_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS9_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS9_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS9_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS9_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS9_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS9_RTR = 0x100000
	// Position of IDE field.
	CAN_CS9_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS9_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS9_IDE = 0x200000
	// Position of SRR field.
	CAN_CS9_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS9_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS9_SRR = 0x400000
	// Position of CODE field.
	CAN_CS9_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS9_CODE_Msk = 0xf000000

	// ID9: Message Buffer 9 ID Register
	// Position of EXT field.
	CAN_ID9_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID9_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID9_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID9_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID9_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID9_PRIO_Msk = 0xe0000000

	// WORD09: Message Buffer 9 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD09_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD09_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD09_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD09_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD09_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD09_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD09_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD09_DATA_BYTE_0_Msk = 0xff000000

	// WORD19: Message Buffer 9 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD19_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD19_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD19_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD19_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD19_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD19_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD19_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD19_DATA_BYTE_4_Msk = 0xff000000

	// CS10: Message Buffer 10 CS Register
	// Position of TIME_STAMP field.
	CAN_CS10_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS10_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS10_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS10_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS10_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS10_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS10_RTR = 0x100000
	// Position of IDE field.
	CAN_CS10_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS10_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS10_IDE = 0x200000
	// Position of SRR field.
	CAN_CS10_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS10_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS10_SRR = 0x400000
	// Position of CODE field.
	CAN_CS10_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS10_CODE_Msk = 0xf000000

	// ID10: Message Buffer 10 ID Register
	// Position of EXT field.
	CAN_ID10_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID10_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID10_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID10_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID10_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID10_PRIO_Msk = 0xe0000000

	// WORD010: Message Buffer 10 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD010_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD010_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD010_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD010_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD010_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD010_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD010_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD010_DATA_BYTE_0_Msk = 0xff000000

	// WORD110: Message Buffer 10 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD110_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD110_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD110_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD110_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD110_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD110_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD110_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD110_DATA_BYTE_4_Msk = 0xff000000

	// CS11: Message Buffer 11 CS Register
	// Position of TIME_STAMP field.
	CAN_CS11_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS11_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS11_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS11_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS11_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS11_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS11_RTR = 0x100000
	// Position of IDE field.
	CAN_CS11_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS11_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS11_IDE = 0x200000
	// Position of SRR field.
	CAN_CS11_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS11_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS11_SRR = 0x400000
	// Position of CODE field.
	CAN_CS11_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS11_CODE_Msk = 0xf000000

	// ID11: Message Buffer 11 ID Register
	// Position of EXT field.
	CAN_ID11_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID11_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID11_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID11_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID11_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID11_PRIO_Msk = 0xe0000000

	// WORD011: Message Buffer 11 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD011_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD011_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD011_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD011_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD011_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD011_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD011_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD011_DATA_BYTE_0_Msk = 0xff000000

	// WORD111: Message Buffer 11 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD111_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD111_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD111_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD111_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD111_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD111_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD111_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD111_DATA_BYTE_4_Msk = 0xff000000

	// CS12: Message Buffer 12 CS Register
	// Position of TIME_STAMP field.
	CAN_CS12_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS12_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS12_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS12_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS12_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS12_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS12_RTR = 0x100000
	// Position of IDE field.
	CAN_CS12_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS12_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS12_IDE = 0x200000
	// Position of SRR field.
	CAN_CS12_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS12_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS12_SRR = 0x400000
	// Position of CODE field.
	CAN_CS12_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS12_CODE_Msk = 0xf000000

	// ID12: Message Buffer 12 ID Register
	// Position of EXT field.
	CAN_ID12_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID12_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID12_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID12_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID12_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID12_PRIO_Msk = 0xe0000000

	// WORD012: Message Buffer 12 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD012_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD012_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD012_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD012_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD012_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD012_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD012_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD012_DATA_BYTE_0_Msk = 0xff000000

	// WORD112: Message Buffer 12 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD112_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD112_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD112_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD112_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD112_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD112_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD112_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD112_DATA_BYTE_4_Msk = 0xff000000

	// CS13: Message Buffer 13 CS Register
	// Position of TIME_STAMP field.
	CAN_CS13_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS13_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS13_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS13_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS13_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS13_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS13_RTR = 0x100000
	// Position of IDE field.
	CAN_CS13_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS13_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS13_IDE = 0x200000
	// Position of SRR field.
	CAN_CS13_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS13_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS13_SRR = 0x400000
	// Position of CODE field.
	CAN_CS13_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS13_CODE_Msk = 0xf000000

	// ID13: Message Buffer 13 ID Register
	// Position of EXT field.
	CAN_ID13_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID13_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID13_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID13_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID13_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID13_PRIO_Msk = 0xe0000000

	// WORD013: Message Buffer 13 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD013_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD013_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD013_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD013_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD013_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD013_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD013_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD013_DATA_BYTE_0_Msk = 0xff000000

	// WORD113: Message Buffer 13 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD113_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD113_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD113_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD113_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD113_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD113_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD113_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD113_DATA_BYTE_4_Msk = 0xff000000

	// CS14: Message Buffer 14 CS Register
	// Position of TIME_STAMP field.
	CAN_CS14_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS14_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS14_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS14_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS14_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS14_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS14_RTR = 0x100000
	// Position of IDE field.
	CAN_CS14_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS14_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS14_IDE = 0x200000
	// Position of SRR field.
	CAN_CS14_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS14_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS14_SRR = 0x400000
	// Position of CODE field.
	CAN_CS14_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS14_CODE_Msk = 0xf000000

	// ID14: Message Buffer 14 ID Register
	// Position of EXT field.
	CAN_ID14_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID14_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID14_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID14_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID14_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID14_PRIO_Msk = 0xe0000000

	// WORD014: Message Buffer 14 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD014_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD014_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD014_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD014_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD014_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD014_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD014_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD014_DATA_BYTE_0_Msk = 0xff000000

	// WORD114: Message Buffer 14 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD114_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD114_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD114_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD114_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD114_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD114_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD114_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD114_DATA_BYTE_4_Msk = 0xff000000

	// CS15: Message Buffer 15 CS Register
	// Position of TIME_STAMP field.
	CAN_CS15_TIME_STAMP_Pos = 0x0
	// Bit mask of TIME_STAMP field.
	CAN_CS15_TIME_STAMP_Msk = 0xffff
	// Position of DLC field.
	CAN_CS15_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_CS15_DLC_Msk = 0xf0000
	// Position of RTR field.
	CAN_CS15_RTR_Pos = 0x14
	// Bit mask of RTR field.
	CAN_CS15_RTR_Msk = 0x100000
	// Bit RTR.
	CAN_CS15_RTR = 0x100000
	// Position of IDE field.
	CAN_CS15_IDE_Pos = 0x15
	// Bit mask of IDE field.
	CAN_CS15_IDE_Msk = 0x200000
	// Bit IDE.
	CAN_CS15_IDE = 0x200000
	// Position of SRR field.
	CAN_CS15_SRR_Pos = 0x16
	// Bit mask of SRR field.
	CAN_CS15_SRR_Msk = 0x400000
	// Bit SRR.
	CAN_CS15_SRR = 0x400000
	// Position of CODE field.
	CAN_CS15_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_CS15_CODE_Msk = 0xf000000

	// ID15: Message Buffer 15 ID Register
	// Position of EXT field.
	CAN_ID15_EXT_Pos = 0x0
	// Bit mask of EXT field.
	CAN_ID15_EXT_Msk = 0x3ffff
	// Position of STD field.
	CAN_ID15_STD_Pos = 0x12
	// Bit mask of STD field.
	CAN_ID15_STD_Msk = 0x1ffc0000
	// Position of PRIO field.
	CAN_ID15_PRIO_Pos = 0x1d
	// Bit mask of PRIO field.
	CAN_ID15_PRIO_Msk = 0xe0000000

	// WORD015: Message Buffer 15 WORD0 Register
	// Position of DATA_BYTE_3 field.
	CAN_WORD015_DATA_BYTE_3_Pos = 0x0
	// Bit mask of DATA_BYTE_3 field.
	CAN_WORD015_DATA_BYTE_3_Msk = 0xff
	// Position of DATA_BYTE_2 field.
	CAN_WORD015_DATA_BYTE_2_Pos = 0x8
	// Bit mask of DATA_BYTE_2 field.
	CAN_WORD015_DATA_BYTE_2_Msk = 0xff00
	// Position of DATA_BYTE_1 field.
	CAN_WORD015_DATA_BYTE_1_Pos = 0x10
	// Bit mask of DATA_BYTE_1 field.
	CAN_WORD015_DATA_BYTE_1_Msk = 0xff0000
	// Position of DATA_BYTE_0 field.
	CAN_WORD015_DATA_BYTE_0_Pos = 0x18
	// Bit mask of DATA_BYTE_0 field.
	CAN_WORD015_DATA_BYTE_0_Msk = 0xff000000

	// WORD115: Message Buffer 15 WORD1 Register
	// Position of DATA_BYTE_7 field.
	CAN_WORD115_DATA_BYTE_7_Pos = 0x0
	// Bit mask of DATA_BYTE_7 field.
	CAN_WORD115_DATA_BYTE_7_Msk = 0xff
	// Position of DATA_BYTE_6 field.
	CAN_WORD115_DATA_BYTE_6_Pos = 0x8
	// Bit mask of DATA_BYTE_6 field.
	CAN_WORD115_DATA_BYTE_6_Msk = 0xff00
	// Position of DATA_BYTE_5 field.
	CAN_WORD115_DATA_BYTE_5_Pos = 0x10
	// Bit mask of DATA_BYTE_5 field.
	CAN_WORD115_DATA_BYTE_5_Msk = 0xff0000
	// Position of DATA_BYTE_4 field.
	CAN_WORD115_DATA_BYTE_4_Pos = 0x18
	// Bit mask of DATA_BYTE_4 field.
	CAN_WORD115_DATA_BYTE_4_Msk = 0xff000000

	// RXIMR0: Rx Individual Mask Registers
	// Position of MI0 field.
	CAN_RXIMR_MI0_Pos = 0x0
	// Bit mask of MI0 field.
	CAN_RXIMR_MI0_Msk = 0x1
	// Bit MI0.
	CAN_RXIMR_MI0 = 0x1
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI0_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI0_1 = 0x1
	// Position of MI1 field.
	CAN_RXIMR_MI1_Pos = 0x1
	// Bit mask of MI1 field.
	CAN_RXIMR_MI1_Msk = 0x2
	// Bit MI1.
	CAN_RXIMR_MI1 = 0x2
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI1_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI1_1 = 0x1
	// Position of MI2 field.
	CAN_RXIMR_MI2_Pos = 0x2
	// Bit mask of MI2 field.
	CAN_RXIMR_MI2_Msk = 0x4
	// Bit MI2.
	CAN_RXIMR_MI2 = 0x4
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI2_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI2_1 = 0x1
	// Position of MI3 field.
	CAN_RXIMR_MI3_Pos = 0x3
	// Bit mask of MI3 field.
	CAN_RXIMR_MI3_Msk = 0x8
	// Bit MI3.
	CAN_RXIMR_MI3 = 0x8
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI3_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI3_1 = 0x1
	// Position of MI4 field.
	CAN_RXIMR_MI4_Pos = 0x4
	// Bit mask of MI4 field.
	CAN_RXIMR_MI4_Msk = 0x10
	// Bit MI4.
	CAN_RXIMR_MI4 = 0x10
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI4_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI4_1 = 0x1
	// Position of MI5 field.
	CAN_RXIMR_MI5_Pos = 0x5
	// Bit mask of MI5 field.
	CAN_RXIMR_MI5_Msk = 0x20
	// Bit MI5.
	CAN_RXIMR_MI5 = 0x20
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI5_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI5_1 = 0x1
	// Position of MI6 field.
	CAN_RXIMR_MI6_Pos = 0x6
	// Bit mask of MI6 field.
	CAN_RXIMR_MI6_Msk = 0x40
	// Bit MI6.
	CAN_RXIMR_MI6 = 0x40
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI6_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI6_1 = 0x1
	// Position of MI7 field.
	CAN_RXIMR_MI7_Pos = 0x7
	// Bit mask of MI7 field.
	CAN_RXIMR_MI7_Msk = 0x80
	// Bit MI7.
	CAN_RXIMR_MI7 = 0x80
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI7_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI7_1 = 0x1
	// Position of MI8 field.
	CAN_RXIMR_MI8_Pos = 0x8
	// Bit mask of MI8 field.
	CAN_RXIMR_MI8_Msk = 0x100
	// Bit MI8.
	CAN_RXIMR_MI8 = 0x100
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI8_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI8_1 = 0x1
	// Position of MI9 field.
	CAN_RXIMR_MI9_Pos = 0x9
	// Bit mask of MI9 field.
	CAN_RXIMR_MI9_Msk = 0x200
	// Bit MI9.
	CAN_RXIMR_MI9 = 0x200
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI9_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI9_1 = 0x1
	// Position of MI10 field.
	CAN_RXIMR_MI10_Pos = 0xa
	// Bit mask of MI10 field.
	CAN_RXIMR_MI10_Msk = 0x400
	// Bit MI10.
	CAN_RXIMR_MI10 = 0x400
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI10_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI10_1 = 0x1
	// Position of MI11 field.
	CAN_RXIMR_MI11_Pos = 0xb
	// Bit mask of MI11 field.
	CAN_RXIMR_MI11_Msk = 0x800
	// Bit MI11.
	CAN_RXIMR_MI11 = 0x800
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI11_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI11_1 = 0x1
	// Position of MI12 field.
	CAN_RXIMR_MI12_Pos = 0xc
	// Bit mask of MI12 field.
	CAN_RXIMR_MI12_Msk = 0x1000
	// Bit MI12.
	CAN_RXIMR_MI12 = 0x1000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI12_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI12_1 = 0x1
	// Position of MI13 field.
	CAN_RXIMR_MI13_Pos = 0xd
	// Bit mask of MI13 field.
	CAN_RXIMR_MI13_Msk = 0x2000
	// Bit MI13.
	CAN_RXIMR_MI13 = 0x2000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI13_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI13_1 = 0x1
	// Position of MI14 field.
	CAN_RXIMR_MI14_Pos = 0xe
	// Bit mask of MI14 field.
	CAN_RXIMR_MI14_Msk = 0x4000
	// Bit MI14.
	CAN_RXIMR_MI14 = 0x4000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI14_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI14_1 = 0x1
	// Position of MI15 field.
	CAN_RXIMR_MI15_Pos = 0xf
	// Bit mask of MI15 field.
	CAN_RXIMR_MI15_Msk = 0x8000
	// Bit MI15.
	CAN_RXIMR_MI15 = 0x8000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI15_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI15_1 = 0x1
	// Position of MI16 field.
	CAN_RXIMR_MI16_Pos = 0x10
	// Bit mask of MI16 field.
	CAN_RXIMR_MI16_Msk = 0x10000
	// Bit MI16.
	CAN_RXIMR_MI16 = 0x10000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI16_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI16_1 = 0x1
	// Position of MI17 field.
	CAN_RXIMR_MI17_Pos = 0x11
	// Bit mask of MI17 field.
	CAN_RXIMR_MI17_Msk = 0x20000
	// Bit MI17.
	CAN_RXIMR_MI17 = 0x20000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI17_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI17_1 = 0x1
	// Position of MI18 field.
	CAN_RXIMR_MI18_Pos = 0x12
	// Bit mask of MI18 field.
	CAN_RXIMR_MI18_Msk = 0x40000
	// Bit MI18.
	CAN_RXIMR_MI18 = 0x40000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI18_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI18_1 = 0x1
	// Position of MI19 field.
	CAN_RXIMR_MI19_Pos = 0x13
	// Bit mask of MI19 field.
	CAN_RXIMR_MI19_Msk = 0x80000
	// Bit MI19.
	CAN_RXIMR_MI19 = 0x80000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI19_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI19_1 = 0x1
	// Position of MI20 field.
	CAN_RXIMR_MI20_Pos = 0x14
	// Bit mask of MI20 field.
	CAN_RXIMR_MI20_Msk = 0x100000
	// Bit MI20.
	CAN_RXIMR_MI20 = 0x100000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI20_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI20_1 = 0x1
	// Position of MI21 field.
	CAN_RXIMR_MI21_Pos = 0x15
	// Bit mask of MI21 field.
	CAN_RXIMR_MI21_Msk = 0x200000
	// Bit MI21.
	CAN_RXIMR_MI21 = 0x200000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI21_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI21_1 = 0x1
	// Position of MI22 field.
	CAN_RXIMR_MI22_Pos = 0x16
	// Bit mask of MI22 field.
	CAN_RXIMR_MI22_Msk = 0x400000
	// Bit MI22.
	CAN_RXIMR_MI22 = 0x400000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI22_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI22_1 = 0x1
	// Position of MI23 field.
	CAN_RXIMR_MI23_Pos = 0x17
	// Bit mask of MI23 field.
	CAN_RXIMR_MI23_Msk = 0x800000
	// Bit MI23.
	CAN_RXIMR_MI23 = 0x800000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI23_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI23_1 = 0x1
	// Position of MI24 field.
	CAN_RXIMR_MI24_Pos = 0x18
	// Bit mask of MI24 field.
	CAN_RXIMR_MI24_Msk = 0x1000000
	// Bit MI24.
	CAN_RXIMR_MI24 = 0x1000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI24_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI24_1 = 0x1
	// Position of MI25 field.
	CAN_RXIMR_MI25_Pos = 0x19
	// Bit mask of MI25 field.
	CAN_RXIMR_MI25_Msk = 0x2000000
	// Bit MI25.
	CAN_RXIMR_MI25 = 0x2000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI25_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI25_1 = 0x1
	// Position of MI26 field.
	CAN_RXIMR_MI26_Pos = 0x1a
	// Bit mask of MI26 field.
	CAN_RXIMR_MI26_Msk = 0x4000000
	// Bit MI26.
	CAN_RXIMR_MI26 = 0x4000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI26_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI26_1 = 0x1
	// Position of MI27 field.
	CAN_RXIMR_MI27_Pos = 0x1b
	// Bit mask of MI27 field.
	CAN_RXIMR_MI27_Msk = 0x8000000
	// Bit MI27.
	CAN_RXIMR_MI27 = 0x8000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI27_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI27_1 = 0x1
	// Position of MI28 field.
	CAN_RXIMR_MI28_Pos = 0x1c
	// Bit mask of MI28 field.
	CAN_RXIMR_MI28_Msk = 0x10000000
	// Bit MI28.
	CAN_RXIMR_MI28 = 0x10000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI28_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI28_1 = 0x1
	// Position of MI29 field.
	CAN_RXIMR_MI29_Pos = 0x1d
	// Bit mask of MI29 field.
	CAN_RXIMR_MI29_Msk = 0x20000000
	// Bit MI29.
	CAN_RXIMR_MI29 = 0x20000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI29_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI29_1 = 0x1
	// Position of MI30 field.
	CAN_RXIMR_MI30_Pos = 0x1e
	// Bit mask of MI30 field.
	CAN_RXIMR_MI30_Msk = 0x40000000
	// Bit MI30.
	CAN_RXIMR_MI30 = 0x40000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI30_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI30_1 = 0x1
	// Position of MI31 field.
	CAN_RXIMR_MI31_Pos = 0x1f
	// Bit mask of MI31 field.
	CAN_RXIMR_MI31_Msk = 0x80000000
	// Bit MI31.
	CAN_RXIMR_MI31 = 0x80000000
	// The corresponding bit in the filter is "don't care."
	CAN_RXIMR_MI31_0 = 0x0
	// The corresponding bit in the filter is checked.
	CAN_RXIMR_MI31_1 = 0x1
)

// Constants for SPI0: Serial Peripheral Interface
const (
	// MCR: Module Configuration Register
	// Position of HALT field.
	SPI_MCR_HALT_Pos = 0x0
	// Bit mask of HALT field.
	SPI_MCR_HALT_Msk = 0x1
	// Bit HALT.
	SPI_MCR_HALT = 0x1
	// Start transfers.
	SPI_MCR_HALT_0 = 0x0
	// Stop transfers.
	SPI_MCR_HALT_1 = 0x1
	// Position of SMPL_PT field.
	SPI_MCR_SMPL_PT_Pos = 0x8
	// Bit mask of SMPL_PT field.
	SPI_MCR_SMPL_PT_Msk = 0x300
	// 0 protocol clock cycles between SCK edge and SIN sample
	SPI_MCR_SMPL_PT_00 = 0x0
	// 1 protocol clock cycle between SCK edge and SIN sample
	SPI_MCR_SMPL_PT_01 = 0x1
	// 2 protocol clock cycles between SCK edge and SIN sample
	SPI_MCR_SMPL_PT_10 = 0x2
	// Position of CLR_RXF field.
	SPI_MCR_CLR_RXF_Pos = 0xa
	// Bit mask of CLR_RXF field.
	SPI_MCR_CLR_RXF_Msk = 0x400
	// Bit CLR_RXF.
	SPI_MCR_CLR_RXF = 0x400
	// Do not clear the RX FIFO counter.
	SPI_MCR_CLR_RXF_0 = 0x0
	// Clear the RX FIFO counter.
	SPI_MCR_CLR_RXF_1 = 0x1
	// Position of CLR_TXF field.
	SPI_MCR_CLR_TXF_Pos = 0xb
	// Bit mask of CLR_TXF field.
	SPI_MCR_CLR_TXF_Msk = 0x800
	// Bit CLR_TXF.
	SPI_MCR_CLR_TXF = 0x800
	// Do not clear the TX FIFO counter.
	SPI_MCR_CLR_TXF_0 = 0x0
	// Clear the TX FIFO counter.
	SPI_MCR_CLR_TXF_1 = 0x1
	// Position of DIS_RXF field.
	SPI_MCR_DIS_RXF_Pos = 0xc
	// Bit mask of DIS_RXF field.
	SPI_MCR_DIS_RXF_Msk = 0x1000
	// Bit DIS_RXF.
	SPI_MCR_DIS_RXF = 0x1000
	// RX FIFO is enabled.
	SPI_MCR_DIS_RXF_0 = 0x0
	// RX FIFO is disabled.
	SPI_MCR_DIS_RXF_1 = 0x1
	// Position of DIS_TXF field.
	SPI_MCR_DIS_TXF_Pos = 0xd
	// Bit mask of DIS_TXF field.
	SPI_MCR_DIS_TXF_Msk = 0x2000
	// Bit DIS_TXF.
	SPI_MCR_DIS_TXF = 0x2000
	// TX FIFO is enabled.
	SPI_MCR_DIS_TXF_0 = 0x0
	// TX FIFO is disabled.
	SPI_MCR_DIS_TXF_1 = 0x1
	// Position of MDIS field.
	SPI_MCR_MDIS_Pos = 0xe
	// Bit mask of MDIS field.
	SPI_MCR_MDIS_Msk = 0x4000
	// Bit MDIS.
	SPI_MCR_MDIS = 0x4000
	// Enables the module clocks.
	SPI_MCR_MDIS_0 = 0x0
	// Allows external logic to disable the module clocks.
	SPI_MCR_MDIS_1 = 0x1
	// Position of DOZE field.
	SPI_MCR_DOZE_Pos = 0xf
	// Bit mask of DOZE field.
	SPI_MCR_DOZE_Msk = 0x8000
	// Bit DOZE.
	SPI_MCR_DOZE = 0x8000
	// Doze mode has no effect on the module.
	SPI_MCR_DOZE_0 = 0x0
	// Doze mode disables the module.
	SPI_MCR_DOZE_1 = 0x1
	// Position of PCSIS0 field.
	SPI_MCR_PCSIS0_Pos = 0x10
	// Bit mask of PCSIS0 field.
	SPI_MCR_PCSIS0_Msk = 0x10000
	// Bit PCSIS0.
	SPI_MCR_PCSIS0 = 0x10000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS0_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS0_1 = 0x1
	// Position of PCSIS1 field.
	SPI_MCR_PCSIS1_Pos = 0x11
	// Bit mask of PCSIS1 field.
	SPI_MCR_PCSIS1_Msk = 0x20000
	// Bit PCSIS1.
	SPI_MCR_PCSIS1 = 0x20000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS1_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS1_1 = 0x1
	// Position of PCSIS2 field.
	SPI_MCR_PCSIS2_Pos = 0x12
	// Bit mask of PCSIS2 field.
	SPI_MCR_PCSIS2_Msk = 0x40000
	// Bit PCSIS2.
	SPI_MCR_PCSIS2 = 0x40000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS2_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS2_1 = 0x1
	// Position of PCSIS3 field.
	SPI_MCR_PCSIS3_Pos = 0x13
	// Bit mask of PCSIS3 field.
	SPI_MCR_PCSIS3_Msk = 0x80000
	// Bit PCSIS3.
	SPI_MCR_PCSIS3 = 0x80000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS3_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS3_1 = 0x1
	// Position of PCSIS4 field.
	SPI_MCR_PCSIS4_Pos = 0x14
	// Bit mask of PCSIS4 field.
	SPI_MCR_PCSIS4_Msk = 0x100000
	// Bit PCSIS4.
	SPI_MCR_PCSIS4 = 0x100000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS4_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS4_1 = 0x1
	// Position of PCSIS5 field.
	SPI_MCR_PCSIS5_Pos = 0x15
	// Bit mask of PCSIS5 field.
	SPI_MCR_PCSIS5_Msk = 0x200000
	// Bit PCSIS5.
	SPI_MCR_PCSIS5 = 0x200000
	// The inactive state of PCSx is low.
	SPI_MCR_PCSIS5_0 = 0x0
	// The inactive state of PCSx is high.
	SPI_MCR_PCSIS5_1 = 0x1
	// Position of ROOE field.
	SPI_MCR_ROOE_Pos = 0x18
	// Bit mask of ROOE field.
	SPI_MCR_ROOE_Msk = 0x1000000
	// Bit ROOE.
	SPI_MCR_ROOE = 0x1000000
	// Incoming data is ignored.
	SPI_MCR_ROOE_0 = 0x0
	// Incoming data is shifted into the shift register.
	SPI_MCR_ROOE_1 = 0x1
	// Position of PCSSE field.
	SPI_MCR_PCSSE_Pos = 0x19
	// Bit mask of PCSSE field.
	SPI_MCR_PCSSE_Msk = 0x2000000
	// Bit PCSSE.
	SPI_MCR_PCSSE = 0x2000000
	// PCS5/ PCSS is used as the Peripheral Chip Select[5] signal.
	SPI_MCR_PCSSE_0 = 0x0
	// PCS5/ PCSS is used as an active-low PCS Strobe signal.
	SPI_MCR_PCSSE_1 = 0x1
	// Position of MTFE field.
	SPI_MCR_MTFE_Pos = 0x1a
	// Bit mask of MTFE field.
	SPI_MCR_MTFE_Msk = 0x4000000
	// Bit MTFE.
	SPI_MCR_MTFE = 0x4000000
	// Modified SPI transfer format disabled.
	SPI_MCR_MTFE_0 = 0x0
	// Modified SPI transfer format enabled.
	SPI_MCR_MTFE_1 = 0x1
	// Position of FRZ field.
	SPI_MCR_FRZ_Pos = 0x1b
	// Bit mask of FRZ field.
	SPI_MCR_FRZ_Msk = 0x8000000
	// Bit FRZ.
	SPI_MCR_FRZ = 0x8000000
	// Do not halt serial transfers in Debug mode.
	SPI_MCR_FRZ_0 = 0x0
	// Halt serial transfers in Debug mode.
	SPI_MCR_FRZ_1 = 0x1
	// Position of DCONF field.
	SPI_MCR_DCONF_Pos = 0x1c
	// Bit mask of DCONF field.
	SPI_MCR_DCONF_Msk = 0x30000000
	// SPI
	SPI_MCR_DCONF_00 = 0x0
	// Position of CONT_SCKE field.
	SPI_MCR_CONT_SCKE_Pos = 0x1e
	// Bit mask of CONT_SCKE field.
	SPI_MCR_CONT_SCKE_Msk = 0x40000000
	// Bit CONT_SCKE.
	SPI_MCR_CONT_SCKE = 0x40000000
	// Continuous SCK disabled.
	SPI_MCR_CONT_SCKE_0 = 0x0
	// Continuous SCK enabled.
	SPI_MCR_CONT_SCKE_1 = 0x1
	// Position of MSTR field.
	SPI_MCR_MSTR_Pos = 0x1f
	// Bit mask of MSTR field.
	SPI_MCR_MSTR_Msk = 0x80000000
	// Bit MSTR.
	SPI_MCR_MSTR = 0x80000000
	// Enables Slave mode
	SPI_MCR_MSTR_0 = 0x0
	// Enables Master mode
	SPI_MCR_MSTR_1 = 0x1

	// TCR: Transfer Count Register
	// Position of SPI_TCNT field.
	SPI_TCR_SPI_TCNT_Pos = 0x10
	// Bit mask of SPI_TCNT field.
	SPI_TCR_SPI_TCNT_Msk = 0xffff0000

	// CTAR0: Clock and Transfer Attributes Register (In Master Mode)
	// Position of BR field.
	SPI_CTAR_BR_Pos = 0x0
	// Bit mask of BR field.
	SPI_CTAR_BR_Msk = 0xf
	// Position of DT field.
	SPI_CTAR_DT_Pos = 0x4
	// Bit mask of DT field.
	SPI_CTAR_DT_Msk = 0xf0
	// Position of ASC field.
	SPI_CTAR_ASC_Pos = 0x8
	// Bit mask of ASC field.
	SPI_CTAR_ASC_Msk = 0xf00
	// Position of CSSCK field.
	SPI_CTAR_CSSCK_Pos = 0xc
	// Bit mask of CSSCK field.
	SPI_CTAR_CSSCK_Msk = 0xf000
	// Position of PBR field.
	SPI_CTAR_PBR_Pos = 0x10
	// Bit mask of PBR field.
	SPI_CTAR_PBR_Msk = 0x30000
	// Baud Rate Prescaler value is 2.
	SPI_CTAR_PBR_00 = 0x0
	// Baud Rate Prescaler value is 3.
	SPI_CTAR_PBR_01 = 0x1
	// Baud Rate Prescaler value is 5.
	SPI_CTAR_PBR_10 = 0x2
	// Baud Rate Prescaler value is 7.
	SPI_CTAR_PBR_11 = 0x3
	// Position of PDT field.
	SPI_CTAR_PDT_Pos = 0x12
	// Bit mask of PDT field.
	SPI_CTAR_PDT_Msk = 0xc0000
	// Delay after Transfer Prescaler value is 1.
	SPI_CTAR_PDT_00 = 0x0
	// Delay after Transfer Prescaler value is 3.
	SPI_CTAR_PDT_01 = 0x1
	// Delay after Transfer Prescaler value is 5.
	SPI_CTAR_PDT_10 = 0x2
	// Delay after Transfer Prescaler value is 7.
	SPI_CTAR_PDT_11 = 0x3
	// Position of PASC field.
	SPI_CTAR_PASC_Pos = 0x14
	// Bit mask of PASC field.
	SPI_CTAR_PASC_Msk = 0x300000
	// Delay after Transfer Prescaler value is 1.
	SPI_CTAR_PASC_00 = 0x0
	// Delay after Transfer Prescaler value is 3.
	SPI_CTAR_PASC_01 = 0x1
	// Delay after Transfer Prescaler value is 5.
	SPI_CTAR_PASC_10 = 0x2
	// Delay after Transfer Prescaler value is 7.
	SPI_CTAR_PASC_11 = 0x3
	// Position of PCSSCK field.
	SPI_CTAR_PCSSCK_Pos = 0x16
	// Bit mask of PCSSCK field.
	SPI_CTAR_PCSSCK_Msk = 0xc00000
	// PCS to SCK Prescaler value is 1.
	SPI_CTAR_PCSSCK_00 = 0x0
	// PCS to SCK Prescaler value is 3.
	SPI_CTAR_PCSSCK_01 = 0x1
	// PCS to SCK Prescaler value is 5.
	SPI_CTAR_PCSSCK_10 = 0x2
	// PCS to SCK Prescaler value is 7.
	SPI_CTAR_PCSSCK_11 = 0x3
	// Position of LSBFE field.
	SPI_CTAR_LSBFE_Pos = 0x18
	// Bit mask of LSBFE field.
	SPI_CTAR_LSBFE_Msk = 0x1000000
	// Bit LSBFE.
	SPI_CTAR_LSBFE = 0x1000000
	// Data is transferred MSB first.
	SPI_CTAR_LSBFE_0 = 0x0
	// Data is transferred LSB first.
	SPI_CTAR_LSBFE_1 = 0x1
	// Position of CPHA field.
	SPI_CTAR_CPHA_Pos = 0x19
	// Bit mask of CPHA field.
	SPI_CTAR_CPHA_Msk = 0x2000000
	// Bit CPHA.
	SPI_CTAR_CPHA = 0x2000000
	// Data is captured on the leading edge of SCK and changed on the following edge.
	SPI_CTAR_CPHA_0 = 0x0
	// Data is changed on the leading edge of SCK and captured on the following edge.
	SPI_CTAR_CPHA_1 = 0x1
	// Position of CPOL field.
	SPI_CTAR_CPOL_Pos = 0x1a
	// Bit mask of CPOL field.
	SPI_CTAR_CPOL_Msk = 0x4000000
	// Bit CPOL.
	SPI_CTAR_CPOL = 0x4000000
	// The inactive state value of SCK is low.
	SPI_CTAR_CPOL_0 = 0x0
	// The inactive state value of SCK is high.
	SPI_CTAR_CPOL_1 = 0x1
	// Position of FMSZ field.
	SPI_CTAR_FMSZ_Pos = 0x1b
	// Bit mask of FMSZ field.
	SPI_CTAR_FMSZ_Msk = 0x78000000
	// Position of DBR field.
	SPI_CTAR_DBR_Pos = 0x1f
	// Bit mask of DBR field.
	SPI_CTAR_DBR_Msk = 0x80000000
	// Bit DBR.
	SPI_CTAR_DBR = 0x80000000
	// The baud rate is computed normally with a 50/50 duty cycle.
	SPI_CTAR_DBR_0 = 0x0
	// The baud rate is doubled with the duty cycle depending on the Baud Rate Prescaler.
	SPI_CTAR_DBR_1 = 0x1

	// CTAR_SLAVE: Clock and Transfer Attributes Register (In Slave Mode)
	// Position of CPHA field.
	SPI_CTAR_SLAVE_CPHA_Pos = 0x19
	// Bit mask of CPHA field.
	SPI_CTAR_SLAVE_CPHA_Msk = 0x2000000
	// Bit CPHA.
	SPI_CTAR_SLAVE_CPHA = 0x2000000
	// Data is captured on the leading edge of SCK and changed on the following edge.
	SPI_CTAR_SLAVE_CPHA_0 = 0x0
	// Data is changed on the leading edge of SCK and captured on the following edge.
	SPI_CTAR_SLAVE_CPHA_1 = 0x1
	// Position of CPOL field.
	SPI_CTAR_SLAVE_CPOL_Pos = 0x1a
	// Bit mask of CPOL field.
	SPI_CTAR_SLAVE_CPOL_Msk = 0x4000000
	// Bit CPOL.
	SPI_CTAR_SLAVE_CPOL = 0x4000000
	// The inactive state value of SCK is low.
	SPI_CTAR_SLAVE_CPOL_0 = 0x0
	// The inactive state value of SCK is high.
	SPI_CTAR_SLAVE_CPOL_1 = 0x1
	// Position of FMSZ field.
	SPI_CTAR_SLAVE_FMSZ_Pos = 0x1b
	// Bit mask of FMSZ field.
	SPI_CTAR_SLAVE_FMSZ_Msk = 0x78000000

	// SR: Status Register
	// Position of POPNXTPTR field.
	SPI_SR_POPNXTPTR_Pos = 0x0
	// Bit mask of POPNXTPTR field.
	SPI_SR_POPNXTPTR_Msk = 0xf
	// Position of RXCTR field.
	SPI_SR_RXCTR_Pos = 0x4
	// Bit mask of RXCTR field.
	SPI_SR_RXCTR_Msk = 0xf0
	// Position of TXNXTPTR field.
	SPI_SR_TXNXTPTR_Pos = 0x8
	// Bit mask of TXNXTPTR field.
	SPI_SR_TXNXTPTR_Msk = 0xf00
	// Position of TXCTR field.
	SPI_SR_TXCTR_Pos = 0xc
	// Bit mask of TXCTR field.
	SPI_SR_TXCTR_Msk = 0xf000
	// Position of RFDF field.
	SPI_SR_RFDF_Pos = 0x11
	// Bit mask of RFDF field.
	SPI_SR_RFDF_Msk = 0x20000
	// Bit RFDF.
	SPI_SR_RFDF = 0x20000
	// RX FIFO is empty.
	SPI_SR_RFDF_0 = 0x0
	// RX FIFO is not empty.
	SPI_SR_RFDF_1 = 0x1
	// Position of RFOF field.
	SPI_SR_RFOF_Pos = 0x13
	// Bit mask of RFOF field.
	SPI_SR_RFOF_Msk = 0x80000
	// Bit RFOF.
	SPI_SR_RFOF = 0x80000
	// No Rx FIFO overflow.
	SPI_SR_RFOF_0 = 0x0
	// Rx FIFO overflow has occurred.
	SPI_SR_RFOF_1 = 0x1
	// Position of TFFF field.
	SPI_SR_TFFF_Pos = 0x19
	// Bit mask of TFFF field.
	SPI_SR_TFFF_Msk = 0x2000000
	// Bit TFFF.
	SPI_SR_TFFF = 0x2000000
	// TX FIFO is full.
	SPI_SR_TFFF_0 = 0x0
	// TX FIFO is not full.
	SPI_SR_TFFF_1 = 0x1
	// Position of TFUF field.
	SPI_SR_TFUF_Pos = 0x1b
	// Bit mask of TFUF field.
	SPI_SR_TFUF_Msk = 0x8000000
	// Bit TFUF.
	SPI_SR_TFUF = 0x8000000
	// No TX FIFO underflow.
	SPI_SR_TFUF_0 = 0x0
	// TX FIFO underflow has occurred.
	SPI_SR_TFUF_1 = 0x1
	// Position of EOQF field.
	SPI_SR_EOQF_Pos = 0x1c
	// Bit mask of EOQF field.
	SPI_SR_EOQF_Msk = 0x10000000
	// Bit EOQF.
	SPI_SR_EOQF = 0x10000000
	// EOQ is not set in the executing command.
	SPI_SR_EOQF_0 = 0x0
	// EOQ is set in the executing SPI command.
	SPI_SR_EOQF_1 = 0x1
	// Position of TXRXS field.
	SPI_SR_TXRXS_Pos = 0x1e
	// Bit mask of TXRXS field.
	SPI_SR_TXRXS_Msk = 0x40000000
	// Bit TXRXS.
	SPI_SR_TXRXS = 0x40000000
	// Transmit and receive operations are disabled (The module is in Stopped state).
	SPI_SR_TXRXS_0 = 0x0
	// Transmit and receive operations are enabled (The module is in Running state).
	SPI_SR_TXRXS_1 = 0x1
	// Position of TCF field.
	SPI_SR_TCF_Pos = 0x1f
	// Bit mask of TCF field.
	SPI_SR_TCF_Msk = 0x80000000
	// Bit TCF.
	SPI_SR_TCF = 0x80000000
	// Transfer not complete.
	SPI_SR_TCF_0 = 0x0
	// Transfer complete.
	SPI_SR_TCF_1 = 0x1

	// RSER: DMA/Interrupt Request Select and Enable Register
	// Position of RFDF_DIRS field.
	SPI_RSER_RFDF_DIRS_Pos = 0x10
	// Bit mask of RFDF_DIRS field.
	SPI_RSER_RFDF_DIRS_Msk = 0x10000
	// Bit RFDF_DIRS.
	SPI_RSER_RFDF_DIRS = 0x10000
	// Interrupt request.
	SPI_RSER_RFDF_DIRS_0 = 0x0
	// DMA request.
	SPI_RSER_RFDF_DIRS_1 = 0x1
	// Position of RFDF_RE field.
	SPI_RSER_RFDF_RE_Pos = 0x11
	// Bit mask of RFDF_RE field.
	SPI_RSER_RFDF_RE_Msk = 0x20000
	// Bit RFDF_RE.
	SPI_RSER_RFDF_RE = 0x20000
	// RFDF interrupt or DMA requests are disabled.
	SPI_RSER_RFDF_RE_0 = 0x0
	// RFDF interrupt or DMA requests are enabled.
	SPI_RSER_RFDF_RE_1 = 0x1
	// Position of RFOF_RE field.
	SPI_RSER_RFOF_RE_Pos = 0x13
	// Bit mask of RFOF_RE field.
	SPI_RSER_RFOF_RE_Msk = 0x80000
	// Bit RFOF_RE.
	SPI_RSER_RFOF_RE = 0x80000
	// RFOF interrupt requests are disabled.
	SPI_RSER_RFOF_RE_0 = 0x0
	// RFOF interrupt requests are enabled.
	SPI_RSER_RFOF_RE_1 = 0x1
	// Position of TFFF_DIRS field.
	SPI_RSER_TFFF_DIRS_Pos = 0x18
	// Bit mask of TFFF_DIRS field.
	SPI_RSER_TFFF_DIRS_Msk = 0x1000000
	// Bit TFFF_DIRS.
	SPI_RSER_TFFF_DIRS = 0x1000000
	// TFFF flag generates interrupt requests.
	SPI_RSER_TFFF_DIRS_0 = 0x0
	// TFFF flag generates DMA requests.
	SPI_RSER_TFFF_DIRS_1 = 0x1
	// Position of TFFF_RE field.
	SPI_RSER_TFFF_RE_Pos = 0x19
	// Bit mask of TFFF_RE field.
	SPI_RSER_TFFF_RE_Msk = 0x2000000
	// Bit TFFF_RE.
	SPI_RSER_TFFF_RE = 0x2000000
	// TFFF interrupts or DMA requests are disabled.
	SPI_RSER_TFFF_RE_0 = 0x0
	// TFFF interrupts or DMA requests are enabled.
	SPI_RSER_TFFF_RE_1 = 0x1
	// Position of TFUF_RE field.
	SPI_RSER_TFUF_RE_Pos = 0x1b
	// Bit mask of TFUF_RE field.
	SPI_RSER_TFUF_RE_Msk = 0x8000000
	// Bit TFUF_RE.
	SPI_RSER_TFUF_RE = 0x8000000
	// TFUF interrupt requests are disabled.
	SPI_RSER_TFUF_RE_0 = 0x0
	// TFUF interrupt requests are enabled.
	SPI_RSER_TFUF_RE_1 = 0x1
	// Position of EOQF_RE field.
	SPI_RSER_EOQF_RE_Pos = 0x1c
	// Bit mask of EOQF_RE field.
	SPI_RSER_EOQF_RE_Msk = 0x10000000
	// Bit EOQF_RE.
	SPI_RSER_EOQF_RE = 0x10000000
	// EOQF interrupt requests are disabled.
	SPI_RSER_EOQF_RE_0 = 0x0
	// EOQF interrupt requests are enabled.
	SPI_RSER_EOQF_RE_1 = 0x1
	// Position of TCF_RE field.
	SPI_RSER_TCF_RE_Pos = 0x1f
	// Bit mask of TCF_RE field.
	SPI_RSER_TCF_RE_Msk = 0x80000000
	// Bit TCF_RE.
	SPI_RSER_TCF_RE = 0x80000000
	// TCF interrupt requests are disabled.
	SPI_RSER_TCF_RE_0 = 0x0
	// TCF interrupt requests are enabled.
	SPI_RSER_TCF_RE_1 = 0x1

	// PUSHR: PUSH TX FIFO Register In Master Mode
	// Position of TXDATA field.
	SPI_PUSHR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	SPI_PUSHR_TXDATA_Msk = 0xffff
	// Position of PCS0 field.
	SPI_PUSHR_PCS0_Pos = 0x10
	// Bit mask of PCS0 field.
	SPI_PUSHR_PCS0_Msk = 0x10000
	// Bit PCS0.
	SPI_PUSHR_PCS0 = 0x10000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS0_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS0_1 = 0x1
	// Position of PCS1 field.
	SPI_PUSHR_PCS1_Pos = 0x11
	// Bit mask of PCS1 field.
	SPI_PUSHR_PCS1_Msk = 0x20000
	// Bit PCS1.
	SPI_PUSHR_PCS1 = 0x20000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS1_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS1_1 = 0x1
	// Position of PCS2 field.
	SPI_PUSHR_PCS2_Pos = 0x12
	// Bit mask of PCS2 field.
	SPI_PUSHR_PCS2_Msk = 0x40000
	// Bit PCS2.
	SPI_PUSHR_PCS2 = 0x40000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS2_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS2_1 = 0x1
	// Position of PCS3 field.
	SPI_PUSHR_PCS3_Pos = 0x13
	// Bit mask of PCS3 field.
	SPI_PUSHR_PCS3_Msk = 0x80000
	// Bit PCS3.
	SPI_PUSHR_PCS3 = 0x80000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS3_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS3_1 = 0x1
	// Position of PCS4 field.
	SPI_PUSHR_PCS4_Pos = 0x14
	// Bit mask of PCS4 field.
	SPI_PUSHR_PCS4_Msk = 0x100000
	// Bit PCS4.
	SPI_PUSHR_PCS4 = 0x100000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS4_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS4_1 = 0x1
	// Position of PCS5 field.
	SPI_PUSHR_PCS5_Pos = 0x15
	// Bit mask of PCS5 field.
	SPI_PUSHR_PCS5_Msk = 0x200000
	// Bit PCS5.
	SPI_PUSHR_PCS5 = 0x200000
	// Negate the PCS[x] signal.
	SPI_PUSHR_PCS5_0 = 0x0
	// Assert the PCS[x] signal.
	SPI_PUSHR_PCS5_1 = 0x1
	// Position of CTCNT field.
	SPI_PUSHR_CTCNT_Pos = 0x1a
	// Bit mask of CTCNT field.
	SPI_PUSHR_CTCNT_Msk = 0x4000000
	// Bit CTCNT.
	SPI_PUSHR_CTCNT = 0x4000000
	// Do not clear the TCR[TCNT] field.
	SPI_PUSHR_CTCNT_0 = 0x0
	// Clear the TCR[TCNT] field.
	SPI_PUSHR_CTCNT_1 = 0x1
	// Position of EOQ field.
	SPI_PUSHR_EOQ_Pos = 0x1b
	// Bit mask of EOQ field.
	SPI_PUSHR_EOQ_Msk = 0x8000000
	// Bit EOQ.
	SPI_PUSHR_EOQ = 0x8000000
	// The SPI data is not the last data to transfer.
	SPI_PUSHR_EOQ_0 = 0x0
	// The SPI data is the last data to transfer.
	SPI_PUSHR_EOQ_1 = 0x1
	// Position of CTAS field.
	SPI_PUSHR_CTAS_Pos = 0x1c
	// Bit mask of CTAS field.
	SPI_PUSHR_CTAS_Msk = 0x70000000
	// CTAR0
	SPI_PUSHR_CTAS_000 = 0x0
	// CTAR1
	SPI_PUSHR_CTAS_001 = 0x1
	// Position of CONT field.
	SPI_PUSHR_CONT_Pos = 0x1f
	// Bit mask of CONT field.
	SPI_PUSHR_CONT_Msk = 0x80000000
	// Bit CONT.
	SPI_PUSHR_CONT = 0x80000000
	// Return PCSn signals to their inactive state between transfers.
	SPI_PUSHR_CONT_0 = 0x0
	// Keep PCSn signals asserted between transfers.
	SPI_PUSHR_CONT_1 = 0x1

	// PUSHR_SLAVE: PUSH TX FIFO Register In Slave Mode
	// Position of TXDATA field.
	SPI_PUSHR_SLAVE_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	SPI_PUSHR_SLAVE_TXDATA_Msk = 0xffffffff

	// POPR: POP RX FIFO Register
	// Position of RXDATA field.
	SPI_POPR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	SPI_POPR_RXDATA_Msk = 0xffffffff

	// TXFR0: Transmit FIFO Registers
	// Position of TXDATA field.
	SPI_TXFR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	SPI_TXFR_TXDATA_Msk = 0xffff
	// Position of TXCMD_TXDATA field.
	SPI_TXFR_TXCMD_TXDATA_Pos = 0x10
	// Bit mask of TXCMD_TXDATA field.
	SPI_TXFR_TXCMD_TXDATA_Msk = 0xffff0000

	// RXFR0: Receive FIFO Registers
	// Position of RXDATA field.
	SPI_RXFR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	SPI_RXFR_RXDATA_Msk = 0xffffffff
)

// Constants for I2S0: Inter-IC Sound / Synchronous Audio Interface
const (
	// TCSR: SAI Transmit Control Register
	// Position of FRDE field.
	I2S0_TCSR_FRDE_Pos = 0x0
	// Bit mask of FRDE field.
	I2S0_TCSR_FRDE_Msk = 0x1
	// Bit FRDE.
	I2S0_TCSR_FRDE = 0x1
	// Disables the DMA request.
	I2S0_TCSR_FRDE_0 = 0x0
	// Enables the DMA request.
	I2S0_TCSR_FRDE_1 = 0x1
	// Position of FWDE field.
	I2S0_TCSR_FWDE_Pos = 0x1
	// Bit mask of FWDE field.
	I2S0_TCSR_FWDE_Msk = 0x2
	// Bit FWDE.
	I2S0_TCSR_FWDE = 0x2
	// Disables the DMA request.
	I2S0_TCSR_FWDE_0 = 0x0
	// Enables the DMA request.
	I2S0_TCSR_FWDE_1 = 0x1
	// Position of FRIE field.
	I2S0_TCSR_FRIE_Pos = 0x8
	// Bit mask of FRIE field.
	I2S0_TCSR_FRIE_Msk = 0x100
	// Bit FRIE.
	I2S0_TCSR_FRIE = 0x100
	// Disables the interrupt.
	I2S0_TCSR_FRIE_0 = 0x0
	// Enables the interrupt.
	I2S0_TCSR_FRIE_1 = 0x1
	// Position of FWIE field.
	I2S0_TCSR_FWIE_Pos = 0x9
	// Bit mask of FWIE field.
	I2S0_TCSR_FWIE_Msk = 0x200
	// Bit FWIE.
	I2S0_TCSR_FWIE = 0x200
	// Disables the interrupt.
	I2S0_TCSR_FWIE_0 = 0x0
	// Enables the interrupt.
	I2S0_TCSR_FWIE_1 = 0x1
	// Position of FEIE field.
	I2S0_TCSR_FEIE_Pos = 0xa
	// Bit mask of FEIE field.
	I2S0_TCSR_FEIE_Msk = 0x400
	// Bit FEIE.
	I2S0_TCSR_FEIE = 0x400
	// Disables the interrupt.
	I2S0_TCSR_FEIE_0 = 0x0
	// Enables the interrupt.
	I2S0_TCSR_FEIE_1 = 0x1
	// Position of SEIE field.
	I2S0_TCSR_SEIE_Pos = 0xb
	// Bit mask of SEIE field.
	I2S0_TCSR_SEIE_Msk = 0x800
	// Bit SEIE.
	I2S0_TCSR_SEIE = 0x800
	// Disables interrupt.
	I2S0_TCSR_SEIE_0 = 0x0
	// Enables interrupt.
	I2S0_TCSR_SEIE_1 = 0x1
	// Position of WSIE field.
	I2S0_TCSR_WSIE_Pos = 0xc
	// Bit mask of WSIE field.
	I2S0_TCSR_WSIE_Msk = 0x1000
	// Bit WSIE.
	I2S0_TCSR_WSIE = 0x1000
	// Disables interrupt.
	I2S0_TCSR_WSIE_0 = 0x0
	// Enables interrupt.
	I2S0_TCSR_WSIE_1 = 0x1
	// Position of FRF field.
	I2S0_TCSR_FRF_Pos = 0x10
	// Bit mask of FRF field.
	I2S0_TCSR_FRF_Msk = 0x10000
	// Bit FRF.
	I2S0_TCSR_FRF = 0x10000
	// Transmit FIFO watermark has not been reached.
	I2S0_TCSR_FRF_0 = 0x0
	// Transmit FIFO watermark has been reached.
	I2S0_TCSR_FRF_1 = 0x1
	// Position of FWF field.
	I2S0_TCSR_FWF_Pos = 0x11
	// Bit mask of FWF field.
	I2S0_TCSR_FWF_Msk = 0x20000
	// Bit FWF.
	I2S0_TCSR_FWF = 0x20000
	// No enabled transmit FIFO is empty.
	I2S0_TCSR_FWF_0 = 0x0
	// Enabled transmit FIFO is empty.
	I2S0_TCSR_FWF_1 = 0x1
	// Position of FEF field.
	I2S0_TCSR_FEF_Pos = 0x12
	// Bit mask of FEF field.
	I2S0_TCSR_FEF_Msk = 0x40000
	// Bit FEF.
	I2S0_TCSR_FEF = 0x40000
	// Transmit underrun not detected.
	I2S0_TCSR_FEF_0 = 0x0
	// Transmit underrun detected.
	I2S0_TCSR_FEF_1 = 0x1
	// Position of SEF field.
	I2S0_TCSR_SEF_Pos = 0x13
	// Bit mask of SEF field.
	I2S0_TCSR_SEF_Msk = 0x80000
	// Bit SEF.
	I2S0_TCSR_SEF = 0x80000
	// Sync error not detected.
	I2S0_TCSR_SEF_0 = 0x0
	// Frame sync error detected.
	I2S0_TCSR_SEF_1 = 0x1
	// Position of WSF field.
	I2S0_TCSR_WSF_Pos = 0x14
	// Bit mask of WSF field.
	I2S0_TCSR_WSF_Msk = 0x100000
	// Bit WSF.
	I2S0_TCSR_WSF = 0x100000
	// Start of word not detected.
	I2S0_TCSR_WSF_0 = 0x0
	// Start of word detected.
	I2S0_TCSR_WSF_1 = 0x1
	// Position of SR field.
	I2S0_TCSR_SR_Pos = 0x18
	// Bit mask of SR field.
	I2S0_TCSR_SR_Msk = 0x1000000
	// Bit SR.
	I2S0_TCSR_SR = 0x1000000
	// No effect.
	I2S0_TCSR_SR_0 = 0x0
	// Software reset.
	I2S0_TCSR_SR_1 = 0x1
	// Position of FR field.
	I2S0_TCSR_FR_Pos = 0x19
	// Bit mask of FR field.
	I2S0_TCSR_FR_Msk = 0x2000000
	// Bit FR.
	I2S0_TCSR_FR = 0x2000000
	// No effect.
	I2S0_TCSR_FR_0 = 0x0
	// FIFO reset.
	I2S0_TCSR_FR_1 = 0x1
	// Position of BCE field.
	I2S0_TCSR_BCE_Pos = 0x1c
	// Bit mask of BCE field.
	I2S0_TCSR_BCE_Msk = 0x10000000
	// Bit BCE.
	I2S0_TCSR_BCE = 0x10000000
	// Transmit bit clock is disabled.
	I2S0_TCSR_BCE_0 = 0x0
	// Transmit bit clock is enabled.
	I2S0_TCSR_BCE_1 = 0x1
	// Position of DBGE field.
	I2S0_TCSR_DBGE_Pos = 0x1d
	// Bit mask of DBGE field.
	I2S0_TCSR_DBGE_Msk = 0x20000000
	// Bit DBGE.
	I2S0_TCSR_DBGE = 0x20000000
	// Transmitter is disabled in Debug mode, after completing the current frame.
	I2S0_TCSR_DBGE_0 = 0x0
	// Transmitter is enabled in Debug mode.
	I2S0_TCSR_DBGE_1 = 0x1
	// Position of STOPE field.
	I2S0_TCSR_STOPE_Pos = 0x1e
	// Bit mask of STOPE field.
	I2S0_TCSR_STOPE_Msk = 0x40000000
	// Bit STOPE.
	I2S0_TCSR_STOPE = 0x40000000
	// Transmitter disabled in Stop mode.
	I2S0_TCSR_STOPE_0 = 0x0
	// Transmitter enabled in Stop mode.
	I2S0_TCSR_STOPE_1 = 0x1
	// Position of TE field.
	I2S0_TCSR_TE_Pos = 0x1f
	// Bit mask of TE field.
	I2S0_TCSR_TE_Msk = 0x80000000
	// Bit TE.
	I2S0_TCSR_TE = 0x80000000
	// Transmitter is disabled.
	I2S0_TCSR_TE_0 = 0x0
	// Transmitter is enabled, or transmitter has been disabled and has not yet reached end of frame.
	I2S0_TCSR_TE_1 = 0x1

	// TCR1: SAI Transmit Configuration 1 Register
	// Position of TFW field.
	I2S0_TCR1_TFW_Pos = 0x0
	// Bit mask of TFW field.
	I2S0_TCR1_TFW_Msk = 0x7

	// TCR2: SAI Transmit Configuration 2 Register
	// Position of DIV field.
	I2S0_TCR2_DIV_Pos = 0x0
	// Bit mask of DIV field.
	I2S0_TCR2_DIV_Msk = 0xff
	// Position of BCD field.
	I2S0_TCR2_BCD_Pos = 0x18
	// Bit mask of BCD field.
	I2S0_TCR2_BCD_Msk = 0x1000000
	// Bit BCD.
	I2S0_TCR2_BCD = 0x1000000
	// Bit clock is generated externally in Slave mode.
	I2S0_TCR2_BCD_0 = 0x0
	// Bit clock is generated internally in Master mode.
	I2S0_TCR2_BCD_1 = 0x1
	// Position of BCP field.
	I2S0_TCR2_BCP_Pos = 0x19
	// Bit mask of BCP field.
	I2S0_TCR2_BCP_Msk = 0x2000000
	// Bit BCP.
	I2S0_TCR2_BCP = 0x2000000
	// Bit clock is active high with drive outputs on rising edge and sample inputs on falling edge.
	I2S0_TCR2_BCP_0 = 0x0
	// Bit clock is active low with drive outputs on falling edge and sample inputs on rising edge.
	I2S0_TCR2_BCP_1 = 0x1
	// Position of MSEL field.
	I2S0_TCR2_MSEL_Pos = 0x1a
	// Bit mask of MSEL field.
	I2S0_TCR2_MSEL_Msk = 0xc000000
	// Bus Clock selected.
	I2S0_TCR2_MSEL_00 = 0x0
	// Master Clock (MCLK) 1 option selected.
	I2S0_TCR2_MSEL_01 = 0x1
	// Master Clock (MCLK) 2 option selected.
	I2S0_TCR2_MSEL_10 = 0x2
	// Master Clock (MCLK) 3 option selected.
	I2S0_TCR2_MSEL_11 = 0x3
	// Position of BCI field.
	I2S0_TCR2_BCI_Pos = 0x1c
	// Bit mask of BCI field.
	I2S0_TCR2_BCI_Msk = 0x10000000
	// Bit BCI.
	I2S0_TCR2_BCI = 0x10000000
	// No effect.
	I2S0_TCR2_BCI_0 = 0x0
	// Internal logic is clocked as if bit clock was externally generated.
	I2S0_TCR2_BCI_1 = 0x1
	// Position of BCS field.
	I2S0_TCR2_BCS_Pos = 0x1d
	// Bit mask of BCS field.
	I2S0_TCR2_BCS_Msk = 0x20000000
	// Bit BCS.
	I2S0_TCR2_BCS = 0x20000000
	// Use the normal bit clock source.
	I2S0_TCR2_BCS_0 = 0x0
	// Swap the bit clock source.
	I2S0_TCR2_BCS_1 = 0x1
	// Position of SYNC field.
	I2S0_TCR2_SYNC_Pos = 0x1e
	// Bit mask of SYNC field.
	I2S0_TCR2_SYNC_Msk = 0xc0000000
	// Asynchronous mode.
	I2S0_TCR2_SYNC_00 = 0x0
	// Synchronous with receiver.
	I2S0_TCR2_SYNC_01 = 0x1
	// Synchronous with another SAI transmitter.
	I2S0_TCR2_SYNC_10 = 0x2
	// Synchronous with another SAI receiver.
	I2S0_TCR2_SYNC_11 = 0x3

	// TCR3: SAI Transmit Configuration 3 Register
	// Position of WDFL field.
	I2S0_TCR3_WDFL_Pos = 0x0
	// Bit mask of WDFL field.
	I2S0_TCR3_WDFL_Msk = 0x1f
	// Position of TCE0 field.
	I2S0_TCR3_TCE0_Pos = 0x10
	// Bit mask of TCE0 field.
	I2S0_TCR3_TCE0_Msk = 0x10000
	// Bit TCE0.
	I2S0_TCR3_TCE0 = 0x10000
	// Transmit data channel N is disabled.
	I2S0_TCR3_TCE0_0 = 0x0
	// Transmit data channel N is enabled.
	I2S0_TCR3_TCE0_1 = 0x1
	// Position of TCE1 field.
	I2S0_TCR3_TCE1_Pos = 0x11
	// Bit mask of TCE1 field.
	I2S0_TCR3_TCE1_Msk = 0x20000
	// Bit TCE1.
	I2S0_TCR3_TCE1 = 0x20000
	// Transmit data channel N is disabled.
	I2S0_TCR3_TCE1_0 = 0x0
	// Transmit data channel N is enabled.
	I2S0_TCR3_TCE1_1 = 0x1
	// Position of CFR0 field.
	I2S0_TCR3_CFR0_Pos = 0x18
	// Bit mask of CFR0 field.
	I2S0_TCR3_CFR0_Msk = 0x1000000
	// Bit CFR0.
	I2S0_TCR3_CFR0 = 0x1000000
	// No effect.
	I2S0_TCR3_CFR0_0 = 0x0
	// Transmit data channel N FIFO is reset.
	I2S0_TCR3_CFR0_1 = 0x1
	// Position of CFR1 field.
	I2S0_TCR3_CFR1_Pos = 0x19
	// Bit mask of CFR1 field.
	I2S0_TCR3_CFR1_Msk = 0x2000000
	// Bit CFR1.
	I2S0_TCR3_CFR1 = 0x2000000
	// No effect.
	I2S0_TCR3_CFR1_0 = 0x0
	// Transmit data channel N FIFO is reset.
	I2S0_TCR3_CFR1_1 = 0x1

	// TCR4: SAI Transmit Configuration 4 Register
	// Position of FSD field.
	I2S0_TCR4_FSD_Pos = 0x0
	// Bit mask of FSD field.
	I2S0_TCR4_FSD_Msk = 0x1
	// Bit FSD.
	I2S0_TCR4_FSD = 0x1
	// Frame sync is generated externally in Slave mode.
	I2S0_TCR4_FSD_0 = 0x0
	// Frame sync is generated internally in Master mode.
	I2S0_TCR4_FSD_1 = 0x1
	// Position of FSP field.
	I2S0_TCR4_FSP_Pos = 0x1
	// Bit mask of FSP field.
	I2S0_TCR4_FSP_Msk = 0x2
	// Bit FSP.
	I2S0_TCR4_FSP = 0x2
	// Frame sync is active high.
	I2S0_TCR4_FSP_0 = 0x0
	// Frame sync is active low.
	I2S0_TCR4_FSP_1 = 0x1
	// Position of ONDEM field.
	I2S0_TCR4_ONDEM_Pos = 0x2
	// Bit mask of ONDEM field.
	I2S0_TCR4_ONDEM_Msk = 0x4
	// Bit ONDEM.
	I2S0_TCR4_ONDEM = 0x4
	// Internal frame sync is generated continuously.
	I2S0_TCR4_ONDEM_0 = 0x0
	// Internal frame sync is generated when the FIFO warning flag is clear.
	I2S0_TCR4_ONDEM_1 = 0x1
	// Position of FSE field.
	I2S0_TCR4_FSE_Pos = 0x3
	// Bit mask of FSE field.
	I2S0_TCR4_FSE_Msk = 0x8
	// Bit FSE.
	I2S0_TCR4_FSE = 0x8
	// Frame sync asserts with the first bit of the frame.
	I2S0_TCR4_FSE_0 = 0x0
	// Frame sync asserts one bit before the first bit of the frame.
	I2S0_TCR4_FSE_1 = 0x1
	// Position of MF field.
	I2S0_TCR4_MF_Pos = 0x4
	// Bit mask of MF field.
	I2S0_TCR4_MF_Msk = 0x10
	// Bit MF.
	I2S0_TCR4_MF = 0x10
	// LSB is transmitted first.
	I2S0_TCR4_MF_0 = 0x0
	// MSB is transmitted first.
	I2S0_TCR4_MF_1 = 0x1
	// Position of SYWD field.
	I2S0_TCR4_SYWD_Pos = 0x8
	// Bit mask of SYWD field.
	I2S0_TCR4_SYWD_Msk = 0x1f00
	// Position of FRSZ field.
	I2S0_TCR4_FRSZ_Pos = 0x10
	// Bit mask of FRSZ field.
	I2S0_TCR4_FRSZ_Msk = 0x1f0000
	// Position of FPACK field.
	I2S0_TCR4_FPACK_Pos = 0x18
	// Bit mask of FPACK field.
	I2S0_TCR4_FPACK_Msk = 0x3000000
	// FIFO packing is disabled
	I2S0_TCR4_FPACK_00 = 0x0
	// 8-bit FIFO packing is enabled
	I2S0_TCR4_FPACK_10 = 0x2
	// 16-bit FIFO packing is enabled
	I2S0_TCR4_FPACK_11 = 0x3
	// Position of FCOMB field.
	I2S0_TCR4_FCOMB_Pos = 0x1a
	// Bit mask of FCOMB field.
	I2S0_TCR4_FCOMB_Msk = 0xc000000
	// FIFO combine mode disabled.
	I2S0_TCR4_FCOMB_00 = 0x0
	// FIFO combine mode enabled on FIFO reads (from transmit shift registers).
	I2S0_TCR4_FCOMB_01 = 0x1
	// FIFO combine mode enabled on FIFO writes (by software).
	I2S0_TCR4_FCOMB_10 = 0x2
	// FIFO combine mode enabled on FIFO reads (from transmit shift registers) and writes (by software).
	I2S0_TCR4_FCOMB_11 = 0x3
	// Position of FCONT field.
	I2S0_TCR4_FCONT_Pos = 0x1c
	// Bit mask of FCONT field.
	I2S0_TCR4_FCONT_Msk = 0x10000000
	// Bit FCONT.
	I2S0_TCR4_FCONT = 0x10000000
	// On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
	I2S0_TCR4_FCONT_0 = 0x0
	// On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.
	I2S0_TCR4_FCONT_1 = 0x1

	// TCR5: SAI Transmit Configuration 5 Register
	// Position of FBT field.
	I2S0_TCR5_FBT_Pos = 0x8
	// Bit mask of FBT field.
	I2S0_TCR5_FBT_Msk = 0x1f00
	// Position of W0W field.
	I2S0_TCR5_W0W_Pos = 0x10
	// Bit mask of W0W field.
	I2S0_TCR5_W0W_Msk = 0x1f0000
	// Position of WNW field.
	I2S0_TCR5_WNW_Pos = 0x18
	// Bit mask of WNW field.
	I2S0_TCR5_WNW_Msk = 0x1f000000

	// TDR0: SAI Transmit Data Register
	// Position of TDR field.
	I2S0_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	I2S0_TDR_TDR_Msk = 0xffffffff

	// TFR0: SAI Transmit FIFO Register
	// Position of RFP field.
	I2S0_TFR_RFP_Pos = 0x0
	// Bit mask of RFP field.
	I2S0_TFR_RFP_Msk = 0xf
	// Position of WFP field.
	I2S0_TFR_WFP_Pos = 0x10
	// Bit mask of WFP field.
	I2S0_TFR_WFP_Msk = 0xf0000
	// Position of WCP field.
	I2S0_TFR_WCP_Pos = 0x1f
	// Bit mask of WCP field.
	I2S0_TFR_WCP_Msk = 0x80000000
	// Bit WCP.
	I2S0_TFR_WCP = 0x80000000
	// No effect.
	I2S0_TFR_WCP_0 = 0x0
	// FIFO combine is enabled for FIFO writes and this FIFO will be written on the next FIFO write.
	I2S0_TFR_WCP_1 = 0x1

	// TMR: SAI Transmit Mask Register
	// Position of TWM0 field.
	I2S0_TMR_TWM0_Pos = 0x0
	// Bit mask of TWM0 field.
	I2S0_TMR_TWM0_Msk = 0x1
	// Bit TWM0.
	I2S0_TMR_TWM0 = 0x1
	// Word N is enabled.
	I2S0_TMR_TWM0_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM0_1 = 0x1
	// Position of TWM1 field.
	I2S0_TMR_TWM1_Pos = 0x1
	// Bit mask of TWM1 field.
	I2S0_TMR_TWM1_Msk = 0x2
	// Bit TWM1.
	I2S0_TMR_TWM1 = 0x2
	// Word N is enabled.
	I2S0_TMR_TWM1_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM1_1 = 0x1
	// Position of TWM2 field.
	I2S0_TMR_TWM2_Pos = 0x2
	// Bit mask of TWM2 field.
	I2S0_TMR_TWM2_Msk = 0x4
	// Bit TWM2.
	I2S0_TMR_TWM2 = 0x4
	// Word N is enabled.
	I2S0_TMR_TWM2_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM2_1 = 0x1
	// Position of TWM3 field.
	I2S0_TMR_TWM3_Pos = 0x3
	// Bit mask of TWM3 field.
	I2S0_TMR_TWM3_Msk = 0x8
	// Bit TWM3.
	I2S0_TMR_TWM3 = 0x8
	// Word N is enabled.
	I2S0_TMR_TWM3_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM3_1 = 0x1
	// Position of TWM4 field.
	I2S0_TMR_TWM4_Pos = 0x4
	// Bit mask of TWM4 field.
	I2S0_TMR_TWM4_Msk = 0x10
	// Bit TWM4.
	I2S0_TMR_TWM4 = 0x10
	// Word N is enabled.
	I2S0_TMR_TWM4_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM4_1 = 0x1
	// Position of TWM5 field.
	I2S0_TMR_TWM5_Pos = 0x5
	// Bit mask of TWM5 field.
	I2S0_TMR_TWM5_Msk = 0x20
	// Bit TWM5.
	I2S0_TMR_TWM5 = 0x20
	// Word N is enabled.
	I2S0_TMR_TWM5_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM5_1 = 0x1
	// Position of TWM6 field.
	I2S0_TMR_TWM6_Pos = 0x6
	// Bit mask of TWM6 field.
	I2S0_TMR_TWM6_Msk = 0x40
	// Bit TWM6.
	I2S0_TMR_TWM6 = 0x40
	// Word N is enabled.
	I2S0_TMR_TWM6_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM6_1 = 0x1
	// Position of TWM7 field.
	I2S0_TMR_TWM7_Pos = 0x7
	// Bit mask of TWM7 field.
	I2S0_TMR_TWM7_Msk = 0x80
	// Bit TWM7.
	I2S0_TMR_TWM7 = 0x80
	// Word N is enabled.
	I2S0_TMR_TWM7_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM7_1 = 0x1
	// Position of TWM8 field.
	I2S0_TMR_TWM8_Pos = 0x8
	// Bit mask of TWM8 field.
	I2S0_TMR_TWM8_Msk = 0x100
	// Bit TWM8.
	I2S0_TMR_TWM8 = 0x100
	// Word N is enabled.
	I2S0_TMR_TWM8_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM8_1 = 0x1
	// Position of TWM9 field.
	I2S0_TMR_TWM9_Pos = 0x9
	// Bit mask of TWM9 field.
	I2S0_TMR_TWM9_Msk = 0x200
	// Bit TWM9.
	I2S0_TMR_TWM9 = 0x200
	// Word N is enabled.
	I2S0_TMR_TWM9_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM9_1 = 0x1
	// Position of TWM10 field.
	I2S0_TMR_TWM10_Pos = 0xa
	// Bit mask of TWM10 field.
	I2S0_TMR_TWM10_Msk = 0x400
	// Bit TWM10.
	I2S0_TMR_TWM10 = 0x400
	// Word N is enabled.
	I2S0_TMR_TWM10_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM10_1 = 0x1
	// Position of TWM11 field.
	I2S0_TMR_TWM11_Pos = 0xb
	// Bit mask of TWM11 field.
	I2S0_TMR_TWM11_Msk = 0x800
	// Bit TWM11.
	I2S0_TMR_TWM11 = 0x800
	// Word N is enabled.
	I2S0_TMR_TWM11_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM11_1 = 0x1
	// Position of TWM12 field.
	I2S0_TMR_TWM12_Pos = 0xc
	// Bit mask of TWM12 field.
	I2S0_TMR_TWM12_Msk = 0x1000
	// Bit TWM12.
	I2S0_TMR_TWM12 = 0x1000
	// Word N is enabled.
	I2S0_TMR_TWM12_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM12_1 = 0x1
	// Position of TWM13 field.
	I2S0_TMR_TWM13_Pos = 0xd
	// Bit mask of TWM13 field.
	I2S0_TMR_TWM13_Msk = 0x2000
	// Bit TWM13.
	I2S0_TMR_TWM13 = 0x2000
	// Word N is enabled.
	I2S0_TMR_TWM13_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM13_1 = 0x1
	// Position of TWM14 field.
	I2S0_TMR_TWM14_Pos = 0xe
	// Bit mask of TWM14 field.
	I2S0_TMR_TWM14_Msk = 0x4000
	// Bit TWM14.
	I2S0_TMR_TWM14 = 0x4000
	// Word N is enabled.
	I2S0_TMR_TWM14_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM14_1 = 0x1
	// Position of TWM15 field.
	I2S0_TMR_TWM15_Pos = 0xf
	// Bit mask of TWM15 field.
	I2S0_TMR_TWM15_Msk = 0x8000
	// Bit TWM15.
	I2S0_TMR_TWM15 = 0x8000
	// Word N is enabled.
	I2S0_TMR_TWM15_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM15_1 = 0x1
	// Position of TWM16 field.
	I2S0_TMR_TWM16_Pos = 0x10
	// Bit mask of TWM16 field.
	I2S0_TMR_TWM16_Msk = 0x10000
	// Bit TWM16.
	I2S0_TMR_TWM16 = 0x10000
	// Word N is enabled.
	I2S0_TMR_TWM16_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM16_1 = 0x1
	// Position of TWM17 field.
	I2S0_TMR_TWM17_Pos = 0x11
	// Bit mask of TWM17 field.
	I2S0_TMR_TWM17_Msk = 0x20000
	// Bit TWM17.
	I2S0_TMR_TWM17 = 0x20000
	// Word N is enabled.
	I2S0_TMR_TWM17_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM17_1 = 0x1
	// Position of TWM18 field.
	I2S0_TMR_TWM18_Pos = 0x12
	// Bit mask of TWM18 field.
	I2S0_TMR_TWM18_Msk = 0x40000
	// Bit TWM18.
	I2S0_TMR_TWM18 = 0x40000
	// Word N is enabled.
	I2S0_TMR_TWM18_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM18_1 = 0x1
	// Position of TWM19 field.
	I2S0_TMR_TWM19_Pos = 0x13
	// Bit mask of TWM19 field.
	I2S0_TMR_TWM19_Msk = 0x80000
	// Bit TWM19.
	I2S0_TMR_TWM19 = 0x80000
	// Word N is enabled.
	I2S0_TMR_TWM19_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM19_1 = 0x1
	// Position of TWM20 field.
	I2S0_TMR_TWM20_Pos = 0x14
	// Bit mask of TWM20 field.
	I2S0_TMR_TWM20_Msk = 0x100000
	// Bit TWM20.
	I2S0_TMR_TWM20 = 0x100000
	// Word N is enabled.
	I2S0_TMR_TWM20_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM20_1 = 0x1
	// Position of TWM21 field.
	I2S0_TMR_TWM21_Pos = 0x15
	// Bit mask of TWM21 field.
	I2S0_TMR_TWM21_Msk = 0x200000
	// Bit TWM21.
	I2S0_TMR_TWM21 = 0x200000
	// Word N is enabled.
	I2S0_TMR_TWM21_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM21_1 = 0x1
	// Position of TWM22 field.
	I2S0_TMR_TWM22_Pos = 0x16
	// Bit mask of TWM22 field.
	I2S0_TMR_TWM22_Msk = 0x400000
	// Bit TWM22.
	I2S0_TMR_TWM22 = 0x400000
	// Word N is enabled.
	I2S0_TMR_TWM22_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM22_1 = 0x1
	// Position of TWM23 field.
	I2S0_TMR_TWM23_Pos = 0x17
	// Bit mask of TWM23 field.
	I2S0_TMR_TWM23_Msk = 0x800000
	// Bit TWM23.
	I2S0_TMR_TWM23 = 0x800000
	// Word N is enabled.
	I2S0_TMR_TWM23_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM23_1 = 0x1
	// Position of TWM24 field.
	I2S0_TMR_TWM24_Pos = 0x18
	// Bit mask of TWM24 field.
	I2S0_TMR_TWM24_Msk = 0x1000000
	// Bit TWM24.
	I2S0_TMR_TWM24 = 0x1000000
	// Word N is enabled.
	I2S0_TMR_TWM24_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM24_1 = 0x1
	// Position of TWM25 field.
	I2S0_TMR_TWM25_Pos = 0x19
	// Bit mask of TWM25 field.
	I2S0_TMR_TWM25_Msk = 0x2000000
	// Bit TWM25.
	I2S0_TMR_TWM25 = 0x2000000
	// Word N is enabled.
	I2S0_TMR_TWM25_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM25_1 = 0x1
	// Position of TWM26 field.
	I2S0_TMR_TWM26_Pos = 0x1a
	// Bit mask of TWM26 field.
	I2S0_TMR_TWM26_Msk = 0x4000000
	// Bit TWM26.
	I2S0_TMR_TWM26 = 0x4000000
	// Word N is enabled.
	I2S0_TMR_TWM26_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM26_1 = 0x1
	// Position of TWM27 field.
	I2S0_TMR_TWM27_Pos = 0x1b
	// Bit mask of TWM27 field.
	I2S0_TMR_TWM27_Msk = 0x8000000
	// Bit TWM27.
	I2S0_TMR_TWM27 = 0x8000000
	// Word N is enabled.
	I2S0_TMR_TWM27_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM27_1 = 0x1
	// Position of TWM28 field.
	I2S0_TMR_TWM28_Pos = 0x1c
	// Bit mask of TWM28 field.
	I2S0_TMR_TWM28_Msk = 0x10000000
	// Bit TWM28.
	I2S0_TMR_TWM28 = 0x10000000
	// Word N is enabled.
	I2S0_TMR_TWM28_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM28_1 = 0x1
	// Position of TWM29 field.
	I2S0_TMR_TWM29_Pos = 0x1d
	// Bit mask of TWM29 field.
	I2S0_TMR_TWM29_Msk = 0x20000000
	// Bit TWM29.
	I2S0_TMR_TWM29 = 0x20000000
	// Word N is enabled.
	I2S0_TMR_TWM29_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM29_1 = 0x1
	// Position of TWM30 field.
	I2S0_TMR_TWM30_Pos = 0x1e
	// Bit mask of TWM30 field.
	I2S0_TMR_TWM30_Msk = 0x40000000
	// Bit TWM30.
	I2S0_TMR_TWM30 = 0x40000000
	// Word N is enabled.
	I2S0_TMR_TWM30_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM30_1 = 0x1
	// Position of TWM31 field.
	I2S0_TMR_TWM31_Pos = 0x1f
	// Bit mask of TWM31 field.
	I2S0_TMR_TWM31_Msk = 0x80000000
	// Bit TWM31.
	I2S0_TMR_TWM31 = 0x80000000
	// Word N is enabled.
	I2S0_TMR_TWM31_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated when masked.
	I2S0_TMR_TWM31_1 = 0x1

	// RCSR: SAI Receive Control Register
	// Position of FRDE field.
	I2S0_RCSR_FRDE_Pos = 0x0
	// Bit mask of FRDE field.
	I2S0_RCSR_FRDE_Msk = 0x1
	// Bit FRDE.
	I2S0_RCSR_FRDE = 0x1
	// Disables the DMA request.
	I2S0_RCSR_FRDE_0 = 0x0
	// Enables the DMA request.
	I2S0_RCSR_FRDE_1 = 0x1
	// Position of FWDE field.
	I2S0_RCSR_FWDE_Pos = 0x1
	// Bit mask of FWDE field.
	I2S0_RCSR_FWDE_Msk = 0x2
	// Bit FWDE.
	I2S0_RCSR_FWDE = 0x2
	// Disables the DMA request.
	I2S0_RCSR_FWDE_0 = 0x0
	// Enables the DMA request.
	I2S0_RCSR_FWDE_1 = 0x1
	// Position of FRIE field.
	I2S0_RCSR_FRIE_Pos = 0x8
	// Bit mask of FRIE field.
	I2S0_RCSR_FRIE_Msk = 0x100
	// Bit FRIE.
	I2S0_RCSR_FRIE = 0x100
	// Disables the interrupt.
	I2S0_RCSR_FRIE_0 = 0x0
	// Enables the interrupt.
	I2S0_RCSR_FRIE_1 = 0x1
	// Position of FWIE field.
	I2S0_RCSR_FWIE_Pos = 0x9
	// Bit mask of FWIE field.
	I2S0_RCSR_FWIE_Msk = 0x200
	// Bit FWIE.
	I2S0_RCSR_FWIE = 0x200
	// Disables the interrupt.
	I2S0_RCSR_FWIE_0 = 0x0
	// Enables the interrupt.
	I2S0_RCSR_FWIE_1 = 0x1
	// Position of FEIE field.
	I2S0_RCSR_FEIE_Pos = 0xa
	// Bit mask of FEIE field.
	I2S0_RCSR_FEIE_Msk = 0x400
	// Bit FEIE.
	I2S0_RCSR_FEIE = 0x400
	// Disables the interrupt.
	I2S0_RCSR_FEIE_0 = 0x0
	// Enables the interrupt.
	I2S0_RCSR_FEIE_1 = 0x1
	// Position of SEIE field.
	I2S0_RCSR_SEIE_Pos = 0xb
	// Bit mask of SEIE field.
	I2S0_RCSR_SEIE_Msk = 0x800
	// Bit SEIE.
	I2S0_RCSR_SEIE = 0x800
	// Disables interrupt.
	I2S0_RCSR_SEIE_0 = 0x0
	// Enables interrupt.
	I2S0_RCSR_SEIE_1 = 0x1
	// Position of WSIE field.
	I2S0_RCSR_WSIE_Pos = 0xc
	// Bit mask of WSIE field.
	I2S0_RCSR_WSIE_Msk = 0x1000
	// Bit WSIE.
	I2S0_RCSR_WSIE = 0x1000
	// Disables interrupt.
	I2S0_RCSR_WSIE_0 = 0x0
	// Enables interrupt.
	I2S0_RCSR_WSIE_1 = 0x1
	// Position of FRF field.
	I2S0_RCSR_FRF_Pos = 0x10
	// Bit mask of FRF field.
	I2S0_RCSR_FRF_Msk = 0x10000
	// Bit FRF.
	I2S0_RCSR_FRF = 0x10000
	// Receive FIFO watermark not reached.
	I2S0_RCSR_FRF_0 = 0x0
	// Receive FIFO watermark has been reached.
	I2S0_RCSR_FRF_1 = 0x1
	// Position of FWF field.
	I2S0_RCSR_FWF_Pos = 0x11
	// Bit mask of FWF field.
	I2S0_RCSR_FWF_Msk = 0x20000
	// Bit FWF.
	I2S0_RCSR_FWF = 0x20000
	// No enabled receive FIFO is full.
	I2S0_RCSR_FWF_0 = 0x0
	// Enabled receive FIFO is full.
	I2S0_RCSR_FWF_1 = 0x1
	// Position of FEF field.
	I2S0_RCSR_FEF_Pos = 0x12
	// Bit mask of FEF field.
	I2S0_RCSR_FEF_Msk = 0x40000
	// Bit FEF.
	I2S0_RCSR_FEF = 0x40000
	// Receive overflow not detected.
	I2S0_RCSR_FEF_0 = 0x0
	// Receive overflow detected.
	I2S0_RCSR_FEF_1 = 0x1
	// Position of SEF field.
	I2S0_RCSR_SEF_Pos = 0x13
	// Bit mask of SEF field.
	I2S0_RCSR_SEF_Msk = 0x80000
	// Bit SEF.
	I2S0_RCSR_SEF = 0x80000
	// Sync error not detected.
	I2S0_RCSR_SEF_0 = 0x0
	// Frame sync error detected.
	I2S0_RCSR_SEF_1 = 0x1
	// Position of WSF field.
	I2S0_RCSR_WSF_Pos = 0x14
	// Bit mask of WSF field.
	I2S0_RCSR_WSF_Msk = 0x100000
	// Bit WSF.
	I2S0_RCSR_WSF = 0x100000
	// Start of word not detected.
	I2S0_RCSR_WSF_0 = 0x0
	// Start of word detected.
	I2S0_RCSR_WSF_1 = 0x1
	// Position of SR field.
	I2S0_RCSR_SR_Pos = 0x18
	// Bit mask of SR field.
	I2S0_RCSR_SR_Msk = 0x1000000
	// Bit SR.
	I2S0_RCSR_SR = 0x1000000
	// No effect.
	I2S0_RCSR_SR_0 = 0x0
	// Software reset.
	I2S0_RCSR_SR_1 = 0x1
	// Position of FR field.
	I2S0_RCSR_FR_Pos = 0x19
	// Bit mask of FR field.
	I2S0_RCSR_FR_Msk = 0x2000000
	// Bit FR.
	I2S0_RCSR_FR = 0x2000000
	// No effect.
	I2S0_RCSR_FR_0 = 0x0
	// FIFO reset.
	I2S0_RCSR_FR_1 = 0x1
	// Position of BCE field.
	I2S0_RCSR_BCE_Pos = 0x1c
	// Bit mask of BCE field.
	I2S0_RCSR_BCE_Msk = 0x10000000
	// Bit BCE.
	I2S0_RCSR_BCE = 0x10000000
	// Receive bit clock is disabled.
	I2S0_RCSR_BCE_0 = 0x0
	// Receive bit clock is enabled.
	I2S0_RCSR_BCE_1 = 0x1
	// Position of DBGE field.
	I2S0_RCSR_DBGE_Pos = 0x1d
	// Bit mask of DBGE field.
	I2S0_RCSR_DBGE_Msk = 0x20000000
	// Bit DBGE.
	I2S0_RCSR_DBGE = 0x20000000
	// Receiver is disabled in Debug mode, after completing the current frame.
	I2S0_RCSR_DBGE_0 = 0x0
	// Receiver is enabled in Debug mode.
	I2S0_RCSR_DBGE_1 = 0x1
	// Position of STOPE field.
	I2S0_RCSR_STOPE_Pos = 0x1e
	// Bit mask of STOPE field.
	I2S0_RCSR_STOPE_Msk = 0x40000000
	// Bit STOPE.
	I2S0_RCSR_STOPE = 0x40000000
	// Receiver disabled in Stop mode.
	I2S0_RCSR_STOPE_0 = 0x0
	// Receiver enabled in Stop mode.
	I2S0_RCSR_STOPE_1 = 0x1
	// Position of RE field.
	I2S0_RCSR_RE_Pos = 0x1f
	// Bit mask of RE field.
	I2S0_RCSR_RE_Msk = 0x80000000
	// Bit RE.
	I2S0_RCSR_RE = 0x80000000
	// Receiver is disabled.
	I2S0_RCSR_RE_0 = 0x0
	// Receiver is enabled, or receiver has been disabled and has not yet reached end of frame.
	I2S0_RCSR_RE_1 = 0x1

	// RCR1: SAI Receive Configuration 1 Register
	// Position of RFW field.
	I2S0_RCR1_RFW_Pos = 0x0
	// Bit mask of RFW field.
	I2S0_RCR1_RFW_Msk = 0x7

	// RCR2: SAI Receive Configuration 2 Register
	// Position of DIV field.
	I2S0_RCR2_DIV_Pos = 0x0
	// Bit mask of DIV field.
	I2S0_RCR2_DIV_Msk = 0xff
	// Position of BCD field.
	I2S0_RCR2_BCD_Pos = 0x18
	// Bit mask of BCD field.
	I2S0_RCR2_BCD_Msk = 0x1000000
	// Bit BCD.
	I2S0_RCR2_BCD = 0x1000000
	// Bit clock is generated externally in Slave mode.
	I2S0_RCR2_BCD_0 = 0x0
	// Bit clock is generated internally in Master mode.
	I2S0_RCR2_BCD_1 = 0x1
	// Position of BCP field.
	I2S0_RCR2_BCP_Pos = 0x19
	// Bit mask of BCP field.
	I2S0_RCR2_BCP_Msk = 0x2000000
	// Bit BCP.
	I2S0_RCR2_BCP = 0x2000000
	// Bit Clock is active high with drive outputs on rising edge and sample inputs on falling edge.
	I2S0_RCR2_BCP_0 = 0x0
	// Bit Clock is active low with drive outputs on falling edge and sample inputs on rising edge.
	I2S0_RCR2_BCP_1 = 0x1
	// Position of MSEL field.
	I2S0_RCR2_MSEL_Pos = 0x1a
	// Bit mask of MSEL field.
	I2S0_RCR2_MSEL_Msk = 0xc000000
	// Bus Clock selected.
	I2S0_RCR2_MSEL_00 = 0x0
	// Master Clock (MCLK) 1 option selected.
	I2S0_RCR2_MSEL_01 = 0x1
	// Master Clock (MCLK) 2 option selected.
	I2S0_RCR2_MSEL_10 = 0x2
	// Master Clock (MCLK) 3 option selected.
	I2S0_RCR2_MSEL_11 = 0x3
	// Position of BCI field.
	I2S0_RCR2_BCI_Pos = 0x1c
	// Bit mask of BCI field.
	I2S0_RCR2_BCI_Msk = 0x10000000
	// Bit BCI.
	I2S0_RCR2_BCI = 0x10000000
	// No effect.
	I2S0_RCR2_BCI_0 = 0x0
	// Internal logic is clocked as if bit clock was externally generated.
	I2S0_RCR2_BCI_1 = 0x1
	// Position of BCS field.
	I2S0_RCR2_BCS_Pos = 0x1d
	// Bit mask of BCS field.
	I2S0_RCR2_BCS_Msk = 0x20000000
	// Bit BCS.
	I2S0_RCR2_BCS = 0x20000000
	// Use the normal bit clock source.
	I2S0_RCR2_BCS_0 = 0x0
	// Swap the bit clock source.
	I2S0_RCR2_BCS_1 = 0x1
	// Position of SYNC field.
	I2S0_RCR2_SYNC_Pos = 0x1e
	// Bit mask of SYNC field.
	I2S0_RCR2_SYNC_Msk = 0xc0000000
	// Asynchronous mode.
	I2S0_RCR2_SYNC_00 = 0x0
	// Synchronous with transmitter.
	I2S0_RCR2_SYNC_01 = 0x1
	// Synchronous with another SAI receiver.
	I2S0_RCR2_SYNC_10 = 0x2
	// Synchronous with another SAI transmitter.
	I2S0_RCR2_SYNC_11 = 0x3

	// RCR3: SAI Receive Configuration 3 Register
	// Position of WDFL field.
	I2S0_RCR3_WDFL_Pos = 0x0
	// Bit mask of WDFL field.
	I2S0_RCR3_WDFL_Msk = 0x1f
	// Position of RCE0 field.
	I2S0_RCR3_RCE0_Pos = 0x10
	// Bit mask of RCE0 field.
	I2S0_RCR3_RCE0_Msk = 0x10000
	// Bit RCE0.
	I2S0_RCR3_RCE0 = 0x10000
	// Receive data channel N is disabled.
	I2S0_RCR3_RCE0_0 = 0x0
	// Receive data channel N is enabled.
	I2S0_RCR3_RCE0_1 = 0x1
	// Position of RCE1 field.
	I2S0_RCR3_RCE1_Pos = 0x11
	// Bit mask of RCE1 field.
	I2S0_RCR3_RCE1_Msk = 0x20000
	// Bit RCE1.
	I2S0_RCR3_RCE1 = 0x20000
	// Receive data channel N is disabled.
	I2S0_RCR3_RCE1_0 = 0x0
	// Receive data channel N is enabled.
	I2S0_RCR3_RCE1_1 = 0x1
	// Position of CFR0 field.
	I2S0_RCR3_CFR0_Pos = 0x18
	// Bit mask of CFR0 field.
	I2S0_RCR3_CFR0_Msk = 0x1000000
	// Bit CFR0.
	I2S0_RCR3_CFR0 = 0x1000000
	// No effect.
	I2S0_RCR3_CFR0_0 = 0x0
	// Receive data channel N FIFO is reset.
	I2S0_RCR3_CFR0_1 = 0x1
	// Position of CFR1 field.
	I2S0_RCR3_CFR1_Pos = 0x19
	// Bit mask of CFR1 field.
	I2S0_RCR3_CFR1_Msk = 0x2000000
	// Bit CFR1.
	I2S0_RCR3_CFR1 = 0x2000000
	// No effect.
	I2S0_RCR3_CFR1_0 = 0x0
	// Receive data channel N FIFO is reset.
	I2S0_RCR3_CFR1_1 = 0x1

	// RCR4: SAI Receive Configuration 4 Register
	// Position of FSD field.
	I2S0_RCR4_FSD_Pos = 0x0
	// Bit mask of FSD field.
	I2S0_RCR4_FSD_Msk = 0x1
	// Bit FSD.
	I2S0_RCR4_FSD = 0x1
	// Frame Sync is generated externally in Slave mode.
	I2S0_RCR4_FSD_0 = 0x0
	// Frame Sync is generated internally in Master mode.
	I2S0_RCR4_FSD_1 = 0x1
	// Position of FSP field.
	I2S0_RCR4_FSP_Pos = 0x1
	// Bit mask of FSP field.
	I2S0_RCR4_FSP_Msk = 0x2
	// Bit FSP.
	I2S0_RCR4_FSP = 0x2
	// Frame sync is active high.
	I2S0_RCR4_FSP_0 = 0x0
	// Frame sync is active low.
	I2S0_RCR4_FSP_1 = 0x1
	// Position of ONDEM field.
	I2S0_RCR4_ONDEM_Pos = 0x2
	// Bit mask of ONDEM field.
	I2S0_RCR4_ONDEM_Msk = 0x4
	// Bit ONDEM.
	I2S0_RCR4_ONDEM = 0x4
	// Internal frame sync is generated continuously.
	I2S0_RCR4_ONDEM_0 = 0x0
	// Internal frame sync is generated when the FIFO warning flag is clear.
	I2S0_RCR4_ONDEM_1 = 0x1
	// Position of FSE field.
	I2S0_RCR4_FSE_Pos = 0x3
	// Bit mask of FSE field.
	I2S0_RCR4_FSE_Msk = 0x8
	// Bit FSE.
	I2S0_RCR4_FSE = 0x8
	// Frame sync asserts with the first bit of the frame.
	I2S0_RCR4_FSE_0 = 0x0
	// Frame sync asserts one bit before the first bit of the frame.
	I2S0_RCR4_FSE_1 = 0x1
	// Position of MF field.
	I2S0_RCR4_MF_Pos = 0x4
	// Bit mask of MF field.
	I2S0_RCR4_MF_Msk = 0x10
	// Bit MF.
	I2S0_RCR4_MF = 0x10
	// LSB is received first.
	I2S0_RCR4_MF_0 = 0x0
	// MSB is received first.
	I2S0_RCR4_MF_1 = 0x1
	// Position of SYWD field.
	I2S0_RCR4_SYWD_Pos = 0x8
	// Bit mask of SYWD field.
	I2S0_RCR4_SYWD_Msk = 0x1f00
	// Position of FRSZ field.
	I2S0_RCR4_FRSZ_Pos = 0x10
	// Bit mask of FRSZ field.
	I2S0_RCR4_FRSZ_Msk = 0x1f0000
	// Position of FPACK field.
	I2S0_RCR4_FPACK_Pos = 0x18
	// Bit mask of FPACK field.
	I2S0_RCR4_FPACK_Msk = 0x3000000
	// FIFO packing is disabled
	I2S0_RCR4_FPACK_00 = 0x0
	// 8-bit FIFO packing is enabled
	I2S0_RCR4_FPACK_10 = 0x2
	// 16-bit FIFO packing is enabled
	I2S0_RCR4_FPACK_11 = 0x3
	// Position of FCOMB field.
	I2S0_RCR4_FCOMB_Pos = 0x1a
	// Bit mask of FCOMB field.
	I2S0_RCR4_FCOMB_Msk = 0xc000000
	// FIFO combine mode disabled.
	I2S0_RCR4_FCOMB_00 = 0x0
	// FIFO combine mode enabled on FIFO writes (from receive shift registers).
	I2S0_RCR4_FCOMB_01 = 0x1
	// FIFO combine mode enabled on FIFO reads (by software).
	I2S0_RCR4_FCOMB_10 = 0x2
	// FIFO combine mode enabled on FIFO writes (from receive shift registers) and reads (by software).
	I2S0_RCR4_FCOMB_11 = 0x3
	// Position of FCONT field.
	I2S0_RCR4_FCONT_Pos = 0x1c
	// Bit mask of FCONT field.
	I2S0_RCR4_FCONT_Msk = 0x10000000
	// Bit FCONT.
	I2S0_RCR4_FCONT = 0x10000000
	// On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
	I2S0_RCR4_FCONT_0 = 0x0
	// On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.
	I2S0_RCR4_FCONT_1 = 0x1

	// RCR5: SAI Receive Configuration 5 Register
	// Position of FBT field.
	I2S0_RCR5_FBT_Pos = 0x8
	// Bit mask of FBT field.
	I2S0_RCR5_FBT_Msk = 0x1f00
	// Position of W0W field.
	I2S0_RCR5_W0W_Pos = 0x10
	// Bit mask of W0W field.
	I2S0_RCR5_W0W_Msk = 0x1f0000
	// Position of WNW field.
	I2S0_RCR5_WNW_Pos = 0x18
	// Bit mask of WNW field.
	I2S0_RCR5_WNW_Msk = 0x1f000000

	// RDR0: SAI Receive Data Register
	// Position of RDR field.
	I2S0_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	I2S0_RDR_RDR_Msk = 0xffffffff

	// RFR0: SAI Receive FIFO Register
	// Position of RFP field.
	I2S0_RFR_RFP_Pos = 0x0
	// Bit mask of RFP field.
	I2S0_RFR_RFP_Msk = 0xf
	// Position of RCP field.
	I2S0_RFR_RCP_Pos = 0xf
	// Bit mask of RCP field.
	I2S0_RFR_RCP_Msk = 0x8000
	// Bit RCP.
	I2S0_RFR_RCP = 0x8000
	// No effect.
	I2S0_RFR_RCP_0 = 0x0
	// FIFO combine is enabled for FIFO reads and this FIFO will be read on the next FIFO read.
	I2S0_RFR_RCP_1 = 0x1
	// Position of WFP field.
	I2S0_RFR_WFP_Pos = 0x10
	// Bit mask of WFP field.
	I2S0_RFR_WFP_Msk = 0xf0000

	// RMR: SAI Receive Mask Register
	// Position of RWM0 field.
	I2S0_RMR_RWM0_Pos = 0x0
	// Bit mask of RWM0 field.
	I2S0_RMR_RWM0_Msk = 0x1
	// Bit RWM0.
	I2S0_RMR_RWM0 = 0x1
	// Word N is enabled.
	I2S0_RMR_RWM0_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM0_1 = 0x1
	// Position of RWM1 field.
	I2S0_RMR_RWM1_Pos = 0x1
	// Bit mask of RWM1 field.
	I2S0_RMR_RWM1_Msk = 0x2
	// Bit RWM1.
	I2S0_RMR_RWM1 = 0x2
	// Word N is enabled.
	I2S0_RMR_RWM1_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM1_1 = 0x1
	// Position of RWM2 field.
	I2S0_RMR_RWM2_Pos = 0x2
	// Bit mask of RWM2 field.
	I2S0_RMR_RWM2_Msk = 0x4
	// Bit RWM2.
	I2S0_RMR_RWM2 = 0x4
	// Word N is enabled.
	I2S0_RMR_RWM2_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM2_1 = 0x1
	// Position of RWM3 field.
	I2S0_RMR_RWM3_Pos = 0x3
	// Bit mask of RWM3 field.
	I2S0_RMR_RWM3_Msk = 0x8
	// Bit RWM3.
	I2S0_RMR_RWM3 = 0x8
	// Word N is enabled.
	I2S0_RMR_RWM3_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM3_1 = 0x1
	// Position of RWM4 field.
	I2S0_RMR_RWM4_Pos = 0x4
	// Bit mask of RWM4 field.
	I2S0_RMR_RWM4_Msk = 0x10
	// Bit RWM4.
	I2S0_RMR_RWM4 = 0x10
	// Word N is enabled.
	I2S0_RMR_RWM4_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM4_1 = 0x1
	// Position of RWM5 field.
	I2S0_RMR_RWM5_Pos = 0x5
	// Bit mask of RWM5 field.
	I2S0_RMR_RWM5_Msk = 0x20
	// Bit RWM5.
	I2S0_RMR_RWM5 = 0x20
	// Word N is enabled.
	I2S0_RMR_RWM5_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM5_1 = 0x1
	// Position of RWM6 field.
	I2S0_RMR_RWM6_Pos = 0x6
	// Bit mask of RWM6 field.
	I2S0_RMR_RWM6_Msk = 0x40
	// Bit RWM6.
	I2S0_RMR_RWM6 = 0x40
	// Word N is enabled.
	I2S0_RMR_RWM6_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM6_1 = 0x1
	// Position of RWM7 field.
	I2S0_RMR_RWM7_Pos = 0x7
	// Bit mask of RWM7 field.
	I2S0_RMR_RWM7_Msk = 0x80
	// Bit RWM7.
	I2S0_RMR_RWM7 = 0x80
	// Word N is enabled.
	I2S0_RMR_RWM7_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM7_1 = 0x1
	// Position of RWM8 field.
	I2S0_RMR_RWM8_Pos = 0x8
	// Bit mask of RWM8 field.
	I2S0_RMR_RWM8_Msk = 0x100
	// Bit RWM8.
	I2S0_RMR_RWM8 = 0x100
	// Word N is enabled.
	I2S0_RMR_RWM8_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM8_1 = 0x1
	// Position of RWM9 field.
	I2S0_RMR_RWM9_Pos = 0x9
	// Bit mask of RWM9 field.
	I2S0_RMR_RWM9_Msk = 0x200
	// Bit RWM9.
	I2S0_RMR_RWM9 = 0x200
	// Word N is enabled.
	I2S0_RMR_RWM9_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM9_1 = 0x1
	// Position of RWM10 field.
	I2S0_RMR_RWM10_Pos = 0xa
	// Bit mask of RWM10 field.
	I2S0_RMR_RWM10_Msk = 0x400
	// Bit RWM10.
	I2S0_RMR_RWM10 = 0x400
	// Word N is enabled.
	I2S0_RMR_RWM10_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM10_1 = 0x1
	// Position of RWM11 field.
	I2S0_RMR_RWM11_Pos = 0xb
	// Bit mask of RWM11 field.
	I2S0_RMR_RWM11_Msk = 0x800
	// Bit RWM11.
	I2S0_RMR_RWM11 = 0x800
	// Word N is enabled.
	I2S0_RMR_RWM11_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM11_1 = 0x1
	// Position of RWM12 field.
	I2S0_RMR_RWM12_Pos = 0xc
	// Bit mask of RWM12 field.
	I2S0_RMR_RWM12_Msk = 0x1000
	// Bit RWM12.
	I2S0_RMR_RWM12 = 0x1000
	// Word N is enabled.
	I2S0_RMR_RWM12_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM12_1 = 0x1
	// Position of RWM13 field.
	I2S0_RMR_RWM13_Pos = 0xd
	// Bit mask of RWM13 field.
	I2S0_RMR_RWM13_Msk = 0x2000
	// Bit RWM13.
	I2S0_RMR_RWM13 = 0x2000
	// Word N is enabled.
	I2S0_RMR_RWM13_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM13_1 = 0x1
	// Position of RWM14 field.
	I2S0_RMR_RWM14_Pos = 0xe
	// Bit mask of RWM14 field.
	I2S0_RMR_RWM14_Msk = 0x4000
	// Bit RWM14.
	I2S0_RMR_RWM14 = 0x4000
	// Word N is enabled.
	I2S0_RMR_RWM14_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM14_1 = 0x1
	// Position of RWM15 field.
	I2S0_RMR_RWM15_Pos = 0xf
	// Bit mask of RWM15 field.
	I2S0_RMR_RWM15_Msk = 0x8000
	// Bit RWM15.
	I2S0_RMR_RWM15 = 0x8000
	// Word N is enabled.
	I2S0_RMR_RWM15_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM15_1 = 0x1
	// Position of RWM16 field.
	I2S0_RMR_RWM16_Pos = 0x10
	// Bit mask of RWM16 field.
	I2S0_RMR_RWM16_Msk = 0x10000
	// Bit RWM16.
	I2S0_RMR_RWM16 = 0x10000
	// Word N is enabled.
	I2S0_RMR_RWM16_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM16_1 = 0x1
	// Position of RWM17 field.
	I2S0_RMR_RWM17_Pos = 0x11
	// Bit mask of RWM17 field.
	I2S0_RMR_RWM17_Msk = 0x20000
	// Bit RWM17.
	I2S0_RMR_RWM17 = 0x20000
	// Word N is enabled.
	I2S0_RMR_RWM17_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM17_1 = 0x1
	// Position of RWM18 field.
	I2S0_RMR_RWM18_Pos = 0x12
	// Bit mask of RWM18 field.
	I2S0_RMR_RWM18_Msk = 0x40000
	// Bit RWM18.
	I2S0_RMR_RWM18 = 0x40000
	// Word N is enabled.
	I2S0_RMR_RWM18_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM18_1 = 0x1
	// Position of RWM19 field.
	I2S0_RMR_RWM19_Pos = 0x13
	// Bit mask of RWM19 field.
	I2S0_RMR_RWM19_Msk = 0x80000
	// Bit RWM19.
	I2S0_RMR_RWM19 = 0x80000
	// Word N is enabled.
	I2S0_RMR_RWM19_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM19_1 = 0x1
	// Position of RWM20 field.
	I2S0_RMR_RWM20_Pos = 0x14
	// Bit mask of RWM20 field.
	I2S0_RMR_RWM20_Msk = 0x100000
	// Bit RWM20.
	I2S0_RMR_RWM20 = 0x100000
	// Word N is enabled.
	I2S0_RMR_RWM20_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM20_1 = 0x1
	// Position of RWM21 field.
	I2S0_RMR_RWM21_Pos = 0x15
	// Bit mask of RWM21 field.
	I2S0_RMR_RWM21_Msk = 0x200000
	// Bit RWM21.
	I2S0_RMR_RWM21 = 0x200000
	// Word N is enabled.
	I2S0_RMR_RWM21_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM21_1 = 0x1
	// Position of RWM22 field.
	I2S0_RMR_RWM22_Pos = 0x16
	// Bit mask of RWM22 field.
	I2S0_RMR_RWM22_Msk = 0x400000
	// Bit RWM22.
	I2S0_RMR_RWM22 = 0x400000
	// Word N is enabled.
	I2S0_RMR_RWM22_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM22_1 = 0x1
	// Position of RWM23 field.
	I2S0_RMR_RWM23_Pos = 0x17
	// Bit mask of RWM23 field.
	I2S0_RMR_RWM23_Msk = 0x800000
	// Bit RWM23.
	I2S0_RMR_RWM23 = 0x800000
	// Word N is enabled.
	I2S0_RMR_RWM23_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM23_1 = 0x1
	// Position of RWM24 field.
	I2S0_RMR_RWM24_Pos = 0x18
	// Bit mask of RWM24 field.
	I2S0_RMR_RWM24_Msk = 0x1000000
	// Bit RWM24.
	I2S0_RMR_RWM24 = 0x1000000
	// Word N is enabled.
	I2S0_RMR_RWM24_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM24_1 = 0x1
	// Position of RWM25 field.
	I2S0_RMR_RWM25_Pos = 0x19
	// Bit mask of RWM25 field.
	I2S0_RMR_RWM25_Msk = 0x2000000
	// Bit RWM25.
	I2S0_RMR_RWM25 = 0x2000000
	// Word N is enabled.
	I2S0_RMR_RWM25_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM25_1 = 0x1
	// Position of RWM26 field.
	I2S0_RMR_RWM26_Pos = 0x1a
	// Bit mask of RWM26 field.
	I2S0_RMR_RWM26_Msk = 0x4000000
	// Bit RWM26.
	I2S0_RMR_RWM26 = 0x4000000
	// Word N is enabled.
	I2S0_RMR_RWM26_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM26_1 = 0x1
	// Position of RWM27 field.
	I2S0_RMR_RWM27_Pos = 0x1b
	// Bit mask of RWM27 field.
	I2S0_RMR_RWM27_Msk = 0x8000000
	// Bit RWM27.
	I2S0_RMR_RWM27 = 0x8000000
	// Word N is enabled.
	I2S0_RMR_RWM27_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM27_1 = 0x1
	// Position of RWM28 field.
	I2S0_RMR_RWM28_Pos = 0x1c
	// Bit mask of RWM28 field.
	I2S0_RMR_RWM28_Msk = 0x10000000
	// Bit RWM28.
	I2S0_RMR_RWM28 = 0x10000000
	// Word N is enabled.
	I2S0_RMR_RWM28_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM28_1 = 0x1
	// Position of RWM29 field.
	I2S0_RMR_RWM29_Pos = 0x1d
	// Bit mask of RWM29 field.
	I2S0_RMR_RWM29_Msk = 0x20000000
	// Bit RWM29.
	I2S0_RMR_RWM29 = 0x20000000
	// Word N is enabled.
	I2S0_RMR_RWM29_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM29_1 = 0x1
	// Position of RWM30 field.
	I2S0_RMR_RWM30_Pos = 0x1e
	// Bit mask of RWM30 field.
	I2S0_RMR_RWM30_Msk = 0x40000000
	// Bit RWM30.
	I2S0_RMR_RWM30 = 0x40000000
	// Word N is enabled.
	I2S0_RMR_RWM30_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM30_1 = 0x1
	// Position of RWM31 field.
	I2S0_RMR_RWM31_Pos = 0x1f
	// Bit mask of RWM31 field.
	I2S0_RMR_RWM31_Msk = 0x80000000
	// Bit RWM31.
	I2S0_RMR_RWM31 = 0x80000000
	// Word N is enabled.
	I2S0_RMR_RWM31_0 = 0x0
	// Word N is masked.
	I2S0_RMR_RWM31_1 = 0x1

	// MCR: SAI MCLK Control Register
	// Position of MICS field.
	I2S0_MCR_MICS_Pos = 0x18
	// Bit mask of MICS field.
	I2S0_MCR_MICS_Msk = 0x3000000
	// MCLK divider input clock 0 is selected.
	I2S0_MCR_MICS_00 = 0x0
	// MCLK divider input clock 1 is selected.
	I2S0_MCR_MICS_01 = 0x1
	// MCLK divider input clock 2 is selected.
	I2S0_MCR_MICS_10 = 0x2
	// MCLK divider input clock 3 is selected.
	I2S0_MCR_MICS_11 = 0x3
	// Position of MOE field.
	I2S0_MCR_MOE_Pos = 0x1e
	// Bit mask of MOE field.
	I2S0_MCR_MOE_Msk = 0x40000000
	// Bit MOE.
	I2S0_MCR_MOE = 0x40000000
	// MCLK signal pin is configured as an input that bypasses the MCLK divider.
	I2S0_MCR_MOE_0 = 0x0
	// MCLK signal pin is configured as an output from the MCLK divider and the MCLK divider is enabled.
	I2S0_MCR_MOE_1 = 0x1
	// Position of DUF field.
	I2S0_MCR_DUF_Pos = 0x1f
	// Bit mask of DUF field.
	I2S0_MCR_DUF_Msk = 0x80000000
	// Bit DUF.
	I2S0_MCR_DUF = 0x80000000
	// MCLK divider ratio is not being updated currently.
	I2S0_MCR_DUF_0 = 0x0
	// MCLK divider ratio is updating on-the-fly. Further updates to the MCLK divider ratio are blocked while this flag remains set.
	I2S0_MCR_DUF_1 = 0x1

	// MDR: SAI MCLK Divide Register
	// Position of DIVIDE field.
	I2S0_MDR_DIVIDE_Pos = 0x0
	// Bit mask of DIVIDE field.
	I2S0_MDR_DIVIDE_Msk = 0xfff
	// Position of FRACT field.
	I2S0_MDR_FRACT_Pos = 0xc
	// Bit mask of FRACT field.
	I2S0_MDR_FRACT_Msk = 0xff000
)

// Constants for CRC: Cyclic Redundancy Check
const (
	// DATA: CRC Data register
	// Position of LL field.
	CRC_DATA_LL_Pos = 0x0
	// Bit mask of LL field.
	CRC_DATA_LL_Msk = 0xff
	// Position of LU field.
	CRC_DATA_LU_Pos = 0x8
	// Bit mask of LU field.
	CRC_DATA_LU_Msk = 0xff00
	// Position of HL field.
	CRC_DATA_HL_Pos = 0x10
	// Bit mask of HL field.
	CRC_DATA_HL_Msk = 0xff0000
	// Position of HU field.
	CRC_DATA_HU_Pos = 0x18
	// Bit mask of HU field.
	CRC_DATA_HU_Msk = 0xff000000

	// DATAL: CRC_DATAL register.
	// Position of DATAL field.
	CRC_DATAL_DATAL_Pos = 0x0
	// Bit mask of DATAL field.
	CRC_DATAL_DATAL_Msk = 0xffff

	// DATALL: CRC_DATALL register.
	// Position of DATALL field.
	CRC_DATALL_DATALL_Pos = 0x0
	// Bit mask of DATALL field.
	CRC_DATALL_DATALL_Msk = 0xff

	// DATALU: CRC_DATALU register.
	// Position of DATALU field.
	CRC_DATALU_DATALU_Pos = 0x0
	// Bit mask of DATALU field.
	CRC_DATALU_DATALU_Msk = 0xff

	// DATAH: CRC_DATAH register.
	// Position of DATAH field.
	CRC_DATAH_DATAH_Pos = 0x0
	// Bit mask of DATAH field.
	CRC_DATAH_DATAH_Msk = 0xffff

	// DATAHL: CRC_DATAHL register.
	// Position of DATAHL field.
	CRC_DATAHL_DATAHL_Pos = 0x0
	// Bit mask of DATAHL field.
	CRC_DATAHL_DATAHL_Msk = 0xff

	// DATAHU: CRC_DATAHU register.
	// Position of DATAHU field.
	CRC_DATAHU_DATAHU_Pos = 0x0
	// Bit mask of DATAHU field.
	CRC_DATAHU_DATAHU_Msk = 0xff

	// GPOLY: CRC Polynomial register
	// Position of LOW field.
	CRC_GPOLY_LOW_Pos = 0x0
	// Bit mask of LOW field.
	CRC_GPOLY_LOW_Msk = 0xffff
	// Position of HIGH field.
	CRC_GPOLY_HIGH_Pos = 0x10
	// Bit mask of HIGH field.
	CRC_GPOLY_HIGH_Msk = 0xffff0000

	// GPOLYL: CRC_GPOLYL register.
	// Position of GPOLYL field.
	CRC_GPOLYL_GPOLYL_Pos = 0x0
	// Bit mask of GPOLYL field.
	CRC_GPOLYL_GPOLYL_Msk = 0xffff

	// GPOLYLL: CRC_GPOLYLL register.
	// Position of GPOLYLL field.
	CRC_GPOLYLL_GPOLYLL_Pos = 0x0
	// Bit mask of GPOLYLL field.
	CRC_GPOLYLL_GPOLYLL_Msk = 0xff

	// GPOLYLU: CRC_GPOLYLU register.
	// Position of GPOLYLU field.
	CRC_GPOLYLU_GPOLYLU_Pos = 0x0
	// Bit mask of GPOLYLU field.
	CRC_GPOLYLU_GPOLYLU_Msk = 0xff

	// GPOLYH: CRC_GPOLYH register.
	// Position of GPOLYH field.
	CRC_GPOLYH_GPOLYH_Pos = 0x0
	// Bit mask of GPOLYH field.
	CRC_GPOLYH_GPOLYH_Msk = 0xffff

	// GPOLYHL: CRC_GPOLYHL register.
	// Position of GPOLYHL field.
	CRC_GPOLYHL_GPOLYHL_Pos = 0x0
	// Bit mask of GPOLYHL field.
	CRC_GPOLYHL_GPOLYHL_Msk = 0xff

	// GPOLYHU: CRC_GPOLYHU register.
	// Position of GPOLYHU field.
	CRC_GPOLYHU_GPOLYHU_Pos = 0x0
	// Bit mask of GPOLYHU field.
	CRC_GPOLYHU_GPOLYHU_Msk = 0xff

	// CTRL: CRC Control register
	// Position of TCRC field.
	CRC_CTRL_TCRC_Pos = 0x18
	// Bit mask of TCRC field.
	CRC_CTRL_TCRC_Msk = 0x1000000
	// Bit TCRC.
	CRC_CTRL_TCRC = 0x1000000
	// 16-bit CRC protocol.
	CRC_CTRL_TCRC_0 = 0x0
	// 32-bit CRC protocol.
	CRC_CTRL_TCRC_1 = 0x1
	// Position of WAS field.
	CRC_CTRL_WAS_Pos = 0x19
	// Bit mask of WAS field.
	CRC_CTRL_WAS_Msk = 0x2000000
	// Bit WAS.
	CRC_CTRL_WAS = 0x2000000
	// Writes to the CRC data register are data values.
	CRC_CTRL_WAS_0 = 0x0
	// Writes to the CRC data register are seed values.
	CRC_CTRL_WAS_1 = 0x1
	// Position of FXOR field.
	CRC_CTRL_FXOR_Pos = 0x1a
	// Bit mask of FXOR field.
	CRC_CTRL_FXOR_Msk = 0x4000000
	// Bit FXOR.
	CRC_CTRL_FXOR = 0x4000000
	// No XOR on reading.
	CRC_CTRL_FXOR_0 = 0x0
	// Invert or complement the read value of the CRC Data register.
	CRC_CTRL_FXOR_1 = 0x1
	// Position of TOTR field.
	CRC_CTRL_TOTR_Pos = 0x1c
	// Bit mask of TOTR field.
	CRC_CTRL_TOTR_Msk = 0x30000000
	// No transposition.
	CRC_CTRL_TOTR_00 = 0x0
	// Bits in bytes are transposed; bytes are not transposed.
	CRC_CTRL_TOTR_01 = 0x1
	// Both bits in bytes and bytes are transposed.
	CRC_CTRL_TOTR_10 = 0x2
	// Only bytes are transposed; no bits in a byte are transposed.
	CRC_CTRL_TOTR_11 = 0x3
	// Position of TOT field.
	CRC_CTRL_TOT_Pos = 0x1e
	// Bit mask of TOT field.
	CRC_CTRL_TOT_Msk = 0xc0000000
	// No transposition.
	CRC_CTRL_TOT_00 = 0x0
	// Bits in bytes are transposed; bytes are not transposed.
	CRC_CTRL_TOT_01 = 0x1
	// Both bits in bytes and bytes are transposed.
	CRC_CTRL_TOT_10 = 0x2
	// Only bytes are transposed; no bits in a byte are transposed.
	CRC_CTRL_TOT_11 = 0x3

	// CTRLHU: CRC_CTRLHU register.
	// Position of TCRC field.
	CRC_CTRLHU_TCRC_Pos = 0x0
	// Bit mask of TCRC field.
	CRC_CTRLHU_TCRC_Msk = 0x1
	// Bit TCRC.
	CRC_CTRLHU_TCRC = 0x1
	// 16-bit CRC protocol.
	CRC_CTRLHU_TCRC_0 = 0x0
	// 32-bit CRC protocol.
	CRC_CTRLHU_TCRC_1 = 0x1
	// Position of WAS field.
	CRC_CTRLHU_WAS_Pos = 0x1
	// Bit mask of WAS field.
	CRC_CTRLHU_WAS_Msk = 0x2
	// Bit WAS.
	CRC_CTRLHU_WAS = 0x2
	// Writes to CRC data register are data values.
	CRC_CTRLHU_WAS_0 = 0x0
	// Writes to CRC data reguster are seed values.
	CRC_CTRLHU_WAS_1 = 0x1
	// Position of FXOR field.
	CRC_CTRLHU_FXOR_Pos = 0x2
	// Bit mask of FXOR field.
	CRC_CTRLHU_FXOR_Msk = 0x4
	// Bit FXOR.
	CRC_CTRLHU_FXOR = 0x4
	// No XOR on reading.
	CRC_CTRLHU_FXOR_0 = 0x0
	// Invert or complement the read value of CRC data register.
	CRC_CTRLHU_FXOR_1 = 0x1
	// Position of TOTR field.
	CRC_CTRLHU_TOTR_Pos = 0x4
	// Bit mask of TOTR field.
	CRC_CTRLHU_TOTR_Msk = 0x30
	// No Transposition.
	CRC_CTRLHU_TOTR_00 = 0x0
	// Bits in bytes are transposed, bytes are not transposed.
	CRC_CTRLHU_TOTR_01 = 0x1
	// Both bits in bytes and bytes are transposed.
	CRC_CTRLHU_TOTR_10 = 0x2
	// Only bytes are transposed; no bits in a byte are transposed.
	CRC_CTRLHU_TOTR_11 = 0x3
	// Position of TOT field.
	CRC_CTRLHU_TOT_Pos = 0x6
	// Bit mask of TOT field.
	CRC_CTRLHU_TOT_Msk = 0xc0
	// No Transposition.
	CRC_CTRLHU_TOT_00 = 0x0
	// Bits in bytes are transposed, bytes are not transposed.
	CRC_CTRLHU_TOT_01 = 0x1
	// Both bits in bytes and bytes are transposed.
	CRC_CTRLHU_TOT_10 = 0x2
	// Only bytes are transposed; no bits in a byte are transposed.
	CRC_CTRLHU_TOT_11 = 0x3
)

// Constants for USBDCD: USB Device Charger Detection module
const (
	// CONTROL: Control register
	// Position of IACK field.
	USBDCD_CONTROL_IACK_Pos = 0x0
	// Bit mask of IACK field.
	USBDCD_CONTROL_IACK_Msk = 0x1
	// Bit IACK.
	USBDCD_CONTROL_IACK = 0x1
	// Do not clear the interrupt.
	USBDCD_CONTROL_IACK_0 = 0x0
	// Clear the IF bit (interrupt flag).
	USBDCD_CONTROL_IACK_1 = 0x1
	// Position of IF field.
	USBDCD_CONTROL_IF_Pos = 0x8
	// Bit mask of IF field.
	USBDCD_CONTROL_IF_Msk = 0x100
	// Bit IF.
	USBDCD_CONTROL_IF = 0x100
	// No interrupt is pending.
	USBDCD_CONTROL_IF_0 = 0x0
	// An interrupt is pending.
	USBDCD_CONTROL_IF_1 = 0x1
	// Position of IE field.
	USBDCD_CONTROL_IE_Pos = 0x10
	// Bit mask of IE field.
	USBDCD_CONTROL_IE_Msk = 0x10000
	// Bit IE.
	USBDCD_CONTROL_IE = 0x10000
	// Disable interrupts to the system.
	USBDCD_CONTROL_IE_0 = 0x0
	// Enable interrupts to the system.
	USBDCD_CONTROL_IE_1 = 0x1
	// Position of BC12 field.
	USBDCD_CONTROL_BC12_Pos = 0x11
	// Bit mask of BC12 field.
	USBDCD_CONTROL_BC12_Msk = 0x20000
	// Bit BC12.
	USBDCD_CONTROL_BC12 = 0x20000
	// Compatible with BC1.1 (default)
	USBDCD_CONTROL_BC12_0 = 0x0
	// Compatible with BC1.2
	USBDCD_CONTROL_BC12_1 = 0x1
	// Position of START field.
	USBDCD_CONTROL_START_Pos = 0x18
	// Bit mask of START field.
	USBDCD_CONTROL_START_Msk = 0x1000000
	// Bit START.
	USBDCD_CONTROL_START = 0x1000000
	// Do not start the sequence. Writes of this value have no effect.
	USBDCD_CONTROL_START_0 = 0x0
	// Initiate the charger detection sequence. If the sequence is already running, writes of this value have no effect.
	USBDCD_CONTROL_START_1 = 0x1
	// Position of SR field.
	USBDCD_CONTROL_SR_Pos = 0x19
	// Bit mask of SR field.
	USBDCD_CONTROL_SR_Msk = 0x2000000
	// Bit SR.
	USBDCD_CONTROL_SR = 0x2000000
	// Do not perform a software reset.
	USBDCD_CONTROL_SR_0 = 0x0
	// Perform a software reset.
	USBDCD_CONTROL_SR_1 = 0x1

	// CLOCK: Clock register
	// Position of CLOCK_UNIT field.
	USBDCD_CLOCK_CLOCK_UNIT_Pos = 0x0
	// Bit mask of CLOCK_UNIT field.
	USBDCD_CLOCK_CLOCK_UNIT_Msk = 0x1
	// Bit CLOCK_UNIT.
	USBDCD_CLOCK_CLOCK_UNIT = 0x1
	// kHz Speed (between 1 kHz and 1023 kHz)
	USBDCD_CLOCK_CLOCK_UNIT_0 = 0x0
	// MHz Speed (between 1 MHz and 1023 MHz)
	USBDCD_CLOCK_CLOCK_UNIT_1 = 0x1
	// Position of CLOCK_SPEED field.
	USBDCD_CLOCK_CLOCK_SPEED_Pos = 0x2
	// Bit mask of CLOCK_SPEED field.
	USBDCD_CLOCK_CLOCK_SPEED_Msk = 0xffc

	// STATUS: Status register
	// Position of SEQ_RES field.
	USBDCD_STATUS_SEQ_RES_Pos = 0x10
	// Bit mask of SEQ_RES field.
	USBDCD_STATUS_SEQ_RES_Msk = 0x30000
	// No results to report.
	USBDCD_STATUS_SEQ_RES_00 = 0x0
	// Attached to an SDP. Must comply with USB 2.0 by drawing only 2.5 mA (max) until connected.
	USBDCD_STATUS_SEQ_RES_01 = 0x1
	// Attached to a charging port. The exact meaning depends on bit 18: 0: Attached to either a CDP or a DCP. The charger type detection has not completed. 1: Attached to a CDP. The charger type detection has completed.
	USBDCD_STATUS_SEQ_RES_10 = 0x2
	// Attached to a DCP.
	USBDCD_STATUS_SEQ_RES_11 = 0x3
	// Position of SEQ_STAT field.
	USBDCD_STATUS_SEQ_STAT_Pos = 0x12
	// Bit mask of SEQ_STAT field.
	USBDCD_STATUS_SEQ_STAT_Msk = 0xc0000
	// The module is either not enabled, or the module is enabled but the data pins have not yet been detected.
	USBDCD_STATUS_SEQ_STAT_00 = 0x0
	// Data pin contact detection is complete.
	USBDCD_STATUS_SEQ_STAT_01 = 0x1
	// Charging port detection is complete.
	USBDCD_STATUS_SEQ_STAT_10 = 0x2
	// Charger type detection is complete.
	USBDCD_STATUS_SEQ_STAT_11 = 0x3
	// Position of ERR field.
	USBDCD_STATUS_ERR_Pos = 0x14
	// Bit mask of ERR field.
	USBDCD_STATUS_ERR_Msk = 0x100000
	// Bit ERR.
	USBDCD_STATUS_ERR = 0x100000
	// No sequence errors.
	USBDCD_STATUS_ERR_0 = 0x0
	// Error in the detection sequence. See the SEQ_STAT field to determine the phase in which the error occurred.
	USBDCD_STATUS_ERR_1 = 0x1
	// Position of TO field.
	USBDCD_STATUS_TO_Pos = 0x15
	// Bit mask of TO field.
	USBDCD_STATUS_TO_Msk = 0x200000
	// Bit TO.
	USBDCD_STATUS_TO = 0x200000
	// The detection sequence has not been running for over 1 s.
	USBDCD_STATUS_TO_0 = 0x0
	// It has been over 1 s since the data pin contact was detected and debounced.
	USBDCD_STATUS_TO_1 = 0x1
	// Position of ACTIVE field.
	USBDCD_STATUS_ACTIVE_Pos = 0x16
	// Bit mask of ACTIVE field.
	USBDCD_STATUS_ACTIVE_Msk = 0x400000
	// Bit ACTIVE.
	USBDCD_STATUS_ACTIVE = 0x400000
	// The sequence is not running.
	USBDCD_STATUS_ACTIVE_0 = 0x0
	// The sequence is running.
	USBDCD_STATUS_ACTIVE_1 = 0x1

	// SIGNAL_OVERRIDE: Signal Override Register
	// Position of PS field.
	USBDCD_SIGNAL_OVERRIDE_PS_Pos = 0x0
	// Bit mask of PS field.
	USBDCD_SIGNAL_OVERRIDE_PS_Msk = 0x3
	// No overrides. Bit field must remain at this value during normal USB data communication to prevent unexpected conditions on USB_DP and USB_DM pins. (Default)
	USBDCD_SIGNAL_OVERRIDE_PS_00 = 0x0
	// Reserved, not for customer use.
	USBDCD_SIGNAL_OVERRIDE_PS_01 = 0x1
	// Enables VDP_SRC voltage source for the USB_DP pin and IDM_SINK current source for the USB_DM pin.
	USBDCD_SIGNAL_OVERRIDE_PS_10 = 0x2
	// Reserved, not for customer use.
	USBDCD_SIGNAL_OVERRIDE_PS_11 = 0x3

	// TIMER0: TIMER0 register
	// Position of TUNITCON field.
	USBDCD_TIMER0_TUNITCON_Pos = 0x0
	// Bit mask of TUNITCON field.
	USBDCD_TIMER0_TUNITCON_Msk = 0xfff
	// Position of TSEQ_INIT field.
	USBDCD_TIMER0_TSEQ_INIT_Pos = 0x10
	// Bit mask of TSEQ_INIT field.
	USBDCD_TIMER0_TSEQ_INIT_Msk = 0x3ff0000

	// TIMER1: TIMER1 register
	// Position of TVDPSRC_ON field.
	USBDCD_TIMER1_TVDPSRC_ON_Pos = 0x0
	// Bit mask of TVDPSRC_ON field.
	USBDCD_TIMER1_TVDPSRC_ON_Msk = 0x3ff
	// Position of TDCD_DBNC field.
	USBDCD_TIMER1_TDCD_DBNC_Pos = 0x10
	// Bit mask of TDCD_DBNC field.
	USBDCD_TIMER1_TDCD_DBNC_Msk = 0x3ff0000

	// TIMER2_BC11: TIMER2_BC11 register
	// Position of CHECK_DM field.
	USBDCD_TIMER2_BC11_CHECK_DM_Pos = 0x0
	// Bit mask of CHECK_DM field.
	USBDCD_TIMER2_BC11_CHECK_DM_Msk = 0xf
	// Position of TVDPSRC_CON field.
	USBDCD_TIMER2_BC11_TVDPSRC_CON_Pos = 0x10
	// Bit mask of TVDPSRC_CON field.
	USBDCD_TIMER2_BC11_TVDPSRC_CON_Msk = 0x3ff0000

	// TIMER2_BC12: TIMER2_BC12 register
	// Position of TVDMSRC_ON field.
	USBDCD_TIMER2_BC12_TVDMSRC_ON_Pos = 0x0
	// Bit mask of TVDMSRC_ON field.
	USBDCD_TIMER2_BC12_TVDMSRC_ON_Msk = 0x3ff
	// Position of TWAIT_AFTER_PRD field.
	USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD_Pos = 0x10
	// Bit mask of TWAIT_AFTER_PRD field.
	USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD_Msk = 0x3ff0000
)

// Constants for PDB0: Programmable Delay Block
const (
	// SC: Status and Control register
	// Position of LDOK field.
	PDB0_SC_LDOK_Pos = 0x0
	// Bit mask of LDOK field.
	PDB0_SC_LDOK_Msk = 0x1
	// Bit LDOK.
	PDB0_SC_LDOK = 0x1
	// Position of CONT field.
	PDB0_SC_CONT_Pos = 0x1
	// Bit mask of CONT field.
	PDB0_SC_CONT_Msk = 0x2
	// Bit CONT.
	PDB0_SC_CONT = 0x2
	// PDB operation in One-Shot mode
	PDB0_SC_CONT_0 = 0x0
	// PDB operation in Continuous mode
	PDB0_SC_CONT_1 = 0x1
	// Position of MULT field.
	PDB0_SC_MULT_Pos = 0x2
	// Bit mask of MULT field.
	PDB0_SC_MULT_Msk = 0xc
	// Multiplication factor is 1.
	PDB0_SC_MULT_00 = 0x0
	// Multiplication factor is 10.
	PDB0_SC_MULT_01 = 0x1
	// Multiplication factor is 20.
	PDB0_SC_MULT_10 = 0x2
	// Multiplication factor is 40.
	PDB0_SC_MULT_11 = 0x3
	// Position of PDBIE field.
	PDB0_SC_PDBIE_Pos = 0x5
	// Bit mask of PDBIE field.
	PDB0_SC_PDBIE_Msk = 0x20
	// Bit PDBIE.
	PDB0_SC_PDBIE = 0x20
	// PDB interrupt disabled.
	PDB0_SC_PDBIE_0 = 0x0
	// PDB interrupt enabled.
	PDB0_SC_PDBIE_1 = 0x1
	// Position of PDBIF field.
	PDB0_SC_PDBIF_Pos = 0x6
	// Bit mask of PDBIF field.
	PDB0_SC_PDBIF_Msk = 0x40
	// Bit PDBIF.
	PDB0_SC_PDBIF = 0x40
	// Position of PDBEN field.
	PDB0_SC_PDBEN_Pos = 0x7
	// Bit mask of PDBEN field.
	PDB0_SC_PDBEN_Msk = 0x80
	// Bit PDBEN.
	PDB0_SC_PDBEN = 0x80
	// PDB disabled. Counter is off.
	PDB0_SC_PDBEN_0 = 0x0
	// PDB enabled.
	PDB0_SC_PDBEN_1 = 0x1
	// Position of TRGSEL field.
	PDB0_SC_TRGSEL_Pos = 0x8
	// Bit mask of TRGSEL field.
	PDB0_SC_TRGSEL_Msk = 0xf00
	// Trigger-In 0 is selected.
	PDB0_SC_TRGSEL_0000 = 0x0
	// Trigger-In 1 is selected.
	PDB0_SC_TRGSEL_0001 = 0x1
	// Trigger-In 2 is selected.
	PDB0_SC_TRGSEL_0010 = 0x2
	// Trigger-In 3 is selected.
	PDB0_SC_TRGSEL_0011 = 0x3
	// Trigger-In 4 is selected.
	PDB0_SC_TRGSEL_0100 = 0x4
	// Trigger-In 5 is selected.
	PDB0_SC_TRGSEL_0101 = 0x5
	// Trigger-In 6 is selected.
	PDB0_SC_TRGSEL_0110 = 0x6
	// Trigger-In 7 is selected.
	PDB0_SC_TRGSEL_0111 = 0x7
	// Trigger-In 8 is selected.
	PDB0_SC_TRGSEL_1000 = 0x8
	// Trigger-In 9 is selected.
	PDB0_SC_TRGSEL_1001 = 0x9
	// Trigger-In 10 is selected.
	PDB0_SC_TRGSEL_1010 = 0xa
	// Trigger-In 11 is selected.
	PDB0_SC_TRGSEL_1011 = 0xb
	// Trigger-In 12 is selected.
	PDB0_SC_TRGSEL_1100 = 0xc
	// Trigger-In 13 is selected.
	PDB0_SC_TRGSEL_1101 = 0xd
	// Trigger-In 14 is selected.
	PDB0_SC_TRGSEL_1110 = 0xe
	// Software trigger is selected.
	PDB0_SC_TRGSEL_1111 = 0xf
	// Position of PRESCALER field.
	PDB0_SC_PRESCALER_Pos = 0xc
	// Bit mask of PRESCALER field.
	PDB0_SC_PRESCALER_Msk = 0x7000
	// Counting uses the peripheral clock divided by multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_000 = 0x0
	// Counting uses the peripheral clock divided by twice of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_001 = 0x1
	// Counting uses the peripheral clock divided by four times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_010 = 0x2
	// Counting uses the peripheral clock divided by eight times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_011 = 0x3
	// Counting uses the peripheral clock divided by 16 times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_100 = 0x4
	// Counting uses the peripheral clock divided by 32 times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_101 = 0x5
	// Counting uses the peripheral clock divided by 64 times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_110 = 0x6
	// Counting uses the peripheral clock divided by 128 times of the multiplication factor selected by MULT.
	PDB0_SC_PRESCALER_111 = 0x7
	// Position of DMAEN field.
	PDB0_SC_DMAEN_Pos = 0xf
	// Bit mask of DMAEN field.
	PDB0_SC_DMAEN_Msk = 0x8000
	// Bit DMAEN.
	PDB0_SC_DMAEN = 0x8000
	// DMA disabled.
	PDB0_SC_DMAEN_0 = 0x0
	// DMA enabled.
	PDB0_SC_DMAEN_1 = 0x1
	// Position of SWTRIG field.
	PDB0_SC_SWTRIG_Pos = 0x10
	// Bit mask of SWTRIG field.
	PDB0_SC_SWTRIG_Msk = 0x10000
	// Bit SWTRIG.
	PDB0_SC_SWTRIG = 0x10000
	// Position of PDBEIE field.
	PDB0_SC_PDBEIE_Pos = 0x11
	// Bit mask of PDBEIE field.
	PDB0_SC_PDBEIE_Msk = 0x20000
	// Bit PDBEIE.
	PDB0_SC_PDBEIE = 0x20000
	// PDB sequence error interrupt disabled.
	PDB0_SC_PDBEIE_0 = 0x0
	// PDB sequence error interrupt enabled.
	PDB0_SC_PDBEIE_1 = 0x1
	// Position of LDMOD field.
	PDB0_SC_LDMOD_Pos = 0x12
	// Bit mask of LDMOD field.
	PDB0_SC_LDMOD_Msk = 0xc0000
	// The internal registers are loaded with the values from their buffers immediately after 1 is written to LDOK.
	PDB0_SC_LDMOD_00 = 0x0
	// The internal registers are loaded with the values from their buffers when the PDB counter reaches the MOD register value after 1 is written to LDOK.
	PDB0_SC_LDMOD_01 = 0x1
	// The internal registers are loaded with the values from their buffers when a trigger input event is detected after 1 is written to LDOK.
	PDB0_SC_LDMOD_10 = 0x2
	// The internal registers are loaded with the values from their buffers when either the PDB counter reaches the MOD register value or a trigger input event is detected, after 1 is written to LDOK.
	PDB0_SC_LDMOD_11 = 0x3

	// MOD: Modulus register
	// Position of MOD field.
	PDB0_MOD_MOD_Pos = 0x0
	// Bit mask of MOD field.
	PDB0_MOD_MOD_Msk = 0xffff

	// CNT: Counter register
	// Position of CNT field.
	PDB0_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PDB0_CNT_CNT_Msk = 0xffff

	// IDLY: Interrupt Delay register
	// Position of IDLY field.
	PDB0_IDLY_IDLY_Pos = 0x0
	// Bit mask of IDLY field.
	PDB0_IDLY_IDLY_Msk = 0xffff

	// CH0C1: Channel n Control register 1
	// Position of EN0 field.
	PDB0_CHC1_EN0_Pos = 0x0
	// Bit mask of EN0 field.
	PDB0_CHC1_EN0_Msk = 0x1
	// Bit EN0.
	PDB0_CHC1_EN0 = 0x1
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN0_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN0_1 = 0x1
	// Position of EN1 field.
	PDB0_CHC1_EN1_Pos = 0x1
	// Bit mask of EN1 field.
	PDB0_CHC1_EN1_Msk = 0x2
	// Bit EN1.
	PDB0_CHC1_EN1 = 0x2
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN1_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN1_1 = 0x1
	// Position of EN2 field.
	PDB0_CHC1_EN2_Pos = 0x2
	// Bit mask of EN2 field.
	PDB0_CHC1_EN2_Msk = 0x4
	// Bit EN2.
	PDB0_CHC1_EN2 = 0x4
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN2_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN2_1 = 0x1
	// Position of EN3 field.
	PDB0_CHC1_EN3_Pos = 0x3
	// Bit mask of EN3 field.
	PDB0_CHC1_EN3_Msk = 0x8
	// Bit EN3.
	PDB0_CHC1_EN3 = 0x8
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN3_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN3_1 = 0x1
	// Position of EN4 field.
	PDB0_CHC1_EN4_Pos = 0x4
	// Bit mask of EN4 field.
	PDB0_CHC1_EN4_Msk = 0x10
	// Bit EN4.
	PDB0_CHC1_EN4 = 0x10
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN4_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN4_1 = 0x1
	// Position of EN5 field.
	PDB0_CHC1_EN5_Pos = 0x5
	// Bit mask of EN5 field.
	PDB0_CHC1_EN5_Msk = 0x20
	// Bit EN5.
	PDB0_CHC1_EN5 = 0x20
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN5_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN5_1 = 0x1
	// Position of EN6 field.
	PDB0_CHC1_EN6_Pos = 0x6
	// Bit mask of EN6 field.
	PDB0_CHC1_EN6_Msk = 0x40
	// Bit EN6.
	PDB0_CHC1_EN6 = 0x40
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN6_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN6_1 = 0x1
	// Position of EN7 field.
	PDB0_CHC1_EN7_Pos = 0x7
	// Bit mask of EN7 field.
	PDB0_CHC1_EN7_Msk = 0x80
	// Bit EN7.
	PDB0_CHC1_EN7 = 0x80
	// PDB channel's corresponding pre-trigger disabled.
	PDB0_CHC1_EN7_0 = 0x0
	// PDB channel's corresponding pre-trigger enabled.
	PDB0_CHC1_EN7_1 = 0x1
	// Position of TOS0 field.
	PDB0_CHC1_TOS0_Pos = 0x8
	// Bit mask of TOS0 field.
	PDB0_CHC1_TOS0_Msk = 0x100
	// Bit TOS0.
	PDB0_CHC1_TOS0 = 0x100
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS0_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS0_1 = 0x1
	// Position of TOS1 field.
	PDB0_CHC1_TOS1_Pos = 0x9
	// Bit mask of TOS1 field.
	PDB0_CHC1_TOS1_Msk = 0x200
	// Bit TOS1.
	PDB0_CHC1_TOS1 = 0x200
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS1_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS1_1 = 0x1
	// Position of TOS2 field.
	PDB0_CHC1_TOS2_Pos = 0xa
	// Bit mask of TOS2 field.
	PDB0_CHC1_TOS2_Msk = 0x400
	// Bit TOS2.
	PDB0_CHC1_TOS2 = 0x400
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS2_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS2_1 = 0x1
	// Position of TOS3 field.
	PDB0_CHC1_TOS3_Pos = 0xb
	// Bit mask of TOS3 field.
	PDB0_CHC1_TOS3_Msk = 0x800
	// Bit TOS3.
	PDB0_CHC1_TOS3 = 0x800
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS3_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS3_1 = 0x1
	// Position of TOS4 field.
	PDB0_CHC1_TOS4_Pos = 0xc
	// Bit mask of TOS4 field.
	PDB0_CHC1_TOS4_Msk = 0x1000
	// Bit TOS4.
	PDB0_CHC1_TOS4 = 0x1000
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS4_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS4_1 = 0x1
	// Position of TOS5 field.
	PDB0_CHC1_TOS5_Pos = 0xd
	// Bit mask of TOS5 field.
	PDB0_CHC1_TOS5_Msk = 0x2000
	// Bit TOS5.
	PDB0_CHC1_TOS5 = 0x2000
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS5_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS5_1 = 0x1
	// Position of TOS6 field.
	PDB0_CHC1_TOS6_Pos = 0xe
	// Bit mask of TOS6 field.
	PDB0_CHC1_TOS6_Msk = 0x4000
	// Bit TOS6.
	PDB0_CHC1_TOS6 = 0x4000
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS6_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS6_1 = 0x1
	// Position of TOS7 field.
	PDB0_CHC1_TOS7_Pos = 0xf
	// Bit mask of TOS7 field.
	PDB0_CHC1_TOS7_Msk = 0x8000
	// Bit TOS7.
	PDB0_CHC1_TOS7 = 0x8000
	// PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_CHC1_TOS7_0 = 0x0
	// PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SETRIG is written with 1.
	PDB0_CHC1_TOS7_1 = 0x1
	// Position of BB0 field.
	PDB0_CHC1_BB0_Pos = 0x10
	// Bit mask of BB0 field.
	PDB0_CHC1_BB0_Msk = 0x10000
	// Bit BB0.
	PDB0_CHC1_BB0 = 0x10000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB0_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB0_1 = 0x1
	// Position of BB1 field.
	PDB0_CHC1_BB1_Pos = 0x11
	// Bit mask of BB1 field.
	PDB0_CHC1_BB1_Msk = 0x20000
	// Bit BB1.
	PDB0_CHC1_BB1 = 0x20000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB1_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB1_1 = 0x1
	// Position of BB2 field.
	PDB0_CHC1_BB2_Pos = 0x12
	// Bit mask of BB2 field.
	PDB0_CHC1_BB2_Msk = 0x40000
	// Bit BB2.
	PDB0_CHC1_BB2 = 0x40000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB2_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB2_1 = 0x1
	// Position of BB3 field.
	PDB0_CHC1_BB3_Pos = 0x13
	// Bit mask of BB3 field.
	PDB0_CHC1_BB3_Msk = 0x80000
	// Bit BB3.
	PDB0_CHC1_BB3 = 0x80000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB3_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB3_1 = 0x1
	// Position of BB4 field.
	PDB0_CHC1_BB4_Pos = 0x14
	// Bit mask of BB4 field.
	PDB0_CHC1_BB4_Msk = 0x100000
	// Bit BB4.
	PDB0_CHC1_BB4 = 0x100000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB4_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB4_1 = 0x1
	// Position of BB5 field.
	PDB0_CHC1_BB5_Pos = 0x15
	// Bit mask of BB5 field.
	PDB0_CHC1_BB5_Msk = 0x200000
	// Bit BB5.
	PDB0_CHC1_BB5 = 0x200000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB5_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB5_1 = 0x1
	// Position of BB6 field.
	PDB0_CHC1_BB6_Pos = 0x16
	// Bit mask of BB6 field.
	PDB0_CHC1_BB6_Msk = 0x400000
	// Bit BB6.
	PDB0_CHC1_BB6 = 0x400000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB6_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB6_1 = 0x1
	// Position of BB7 field.
	PDB0_CHC1_BB7_Pos = 0x17
	// Bit mask of BB7 field.
	PDB0_CHC1_BB7_Msk = 0x800000
	// Bit BB7.
	PDB0_CHC1_BB7 = 0x800000
	// PDB channel's corresponding pre-trigger back-to-back operation disabled.
	PDB0_CHC1_BB7_0 = 0x0
	// PDB channel's corresponding pre-trigger back-to-back operation enabled.
	PDB0_CHC1_BB7_1 = 0x1

	// CH0S: Channel n Status register
	// Position of ERR0 field.
	PDB0_CHS_ERR0_Pos = 0x0
	// Bit mask of ERR0 field.
	PDB0_CHS_ERR0_Msk = 0x1
	// Bit ERR0.
	PDB0_CHS_ERR0 = 0x1
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR0_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR0_1 = 0x1
	// Position of ERR1 field.
	PDB0_CHS_ERR1_Pos = 0x1
	// Bit mask of ERR1 field.
	PDB0_CHS_ERR1_Msk = 0x2
	// Bit ERR1.
	PDB0_CHS_ERR1 = 0x2
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR1_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR1_1 = 0x1
	// Position of ERR2 field.
	PDB0_CHS_ERR2_Pos = 0x2
	// Bit mask of ERR2 field.
	PDB0_CHS_ERR2_Msk = 0x4
	// Bit ERR2.
	PDB0_CHS_ERR2 = 0x4
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR2_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR2_1 = 0x1
	// Position of ERR3 field.
	PDB0_CHS_ERR3_Pos = 0x3
	// Bit mask of ERR3 field.
	PDB0_CHS_ERR3_Msk = 0x8
	// Bit ERR3.
	PDB0_CHS_ERR3 = 0x8
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR3_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR3_1 = 0x1
	// Position of ERR4 field.
	PDB0_CHS_ERR4_Pos = 0x4
	// Bit mask of ERR4 field.
	PDB0_CHS_ERR4_Msk = 0x10
	// Bit ERR4.
	PDB0_CHS_ERR4 = 0x10
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR4_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR4_1 = 0x1
	// Position of ERR5 field.
	PDB0_CHS_ERR5_Pos = 0x5
	// Bit mask of ERR5 field.
	PDB0_CHS_ERR5_Msk = 0x20
	// Bit ERR5.
	PDB0_CHS_ERR5 = 0x20
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR5_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR5_1 = 0x1
	// Position of ERR6 field.
	PDB0_CHS_ERR6_Pos = 0x6
	// Bit mask of ERR6 field.
	PDB0_CHS_ERR6_Msk = 0x40
	// Bit ERR6.
	PDB0_CHS_ERR6 = 0x40
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR6_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR6_1 = 0x1
	// Position of ERR7 field.
	PDB0_CHS_ERR7_Pos = 0x7
	// Bit mask of ERR7 field.
	PDB0_CHS_ERR7_Msk = 0x80
	// Bit ERR7.
	PDB0_CHS_ERR7 = 0x80
	// Sequence error not detected on PDB channel's corresponding pre-trigger.
	PDB0_CHS_ERR7_0 = 0x0
	// Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
	PDB0_CHS_ERR7_1 = 0x1
	// Position of CF field.
	PDB0_CHS_CF_Pos = 0x10
	// Bit mask of CF field.
	PDB0_CHS_CF_Msk = 0xff0000

	// CH0DLY0: Channel n Delay 0 register
	// Position of DLY field.
	PDB0_CHDLY0_DLY_Pos = 0x0
	// Bit mask of DLY field.
	PDB0_CHDLY0_DLY_Msk = 0xffff

	// CH0DLY1: Channel n Delay 1 register
	// Position of DLY field.
	PDB0_CHDLY1_DLY_Pos = 0x0
	// Bit mask of DLY field.
	PDB0_CHDLY1_DLY_Msk = 0xffff

	// DACINTC0: DAC Interval Trigger n Control register
	// Position of TOE field.
	PDB0_DACINTC_TOE_Pos = 0x0
	// Bit mask of TOE field.
	PDB0_DACINTC_TOE_Msk = 0x1
	// Bit TOE.
	PDB0_DACINTC_TOE = 0x1
	// DAC interval trigger disabled.
	PDB0_DACINTC_TOE_0 = 0x0
	// DAC interval trigger enabled.
	PDB0_DACINTC_TOE_1 = 0x1
	// Position of EXT field.
	PDB0_DACINTC_EXT_Pos = 0x1
	// Bit mask of EXT field.
	PDB0_DACINTC_EXT_Msk = 0x2
	// Bit EXT.
	PDB0_DACINTC_EXT = 0x2
	// DAC external trigger input disabled. DAC interval counter is reset and counting starts when a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
	PDB0_DACINTC_EXT_0 = 0x0
	// DAC external trigger input enabled. DAC interval counter is bypassed and DAC external trigger input triggers the DAC interval trigger.
	PDB0_DACINTC_EXT_1 = 0x1

	// DACINT0: DAC Interval n register
	// Position of INT field.
	PDB0_DACINT_INT_Pos = 0x0
	// Bit mask of INT field.
	PDB0_DACINT_INT_Msk = 0xffff

	// POEN: Pulse-Out n Enable register
	// Position of POEN0 field.
	PDB0_POEN_POEN0_Pos = 0x0
	// Bit mask of POEN0 field.
	PDB0_POEN_POEN0_Msk = 0x1
	// Bit POEN0.
	PDB0_POEN_POEN0 = 0x1
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN0_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN0_1 = 0x1
	// Position of POEN1 field.
	PDB0_POEN_POEN1_Pos = 0x1
	// Bit mask of POEN1 field.
	PDB0_POEN_POEN1_Msk = 0x2
	// Bit POEN1.
	PDB0_POEN_POEN1 = 0x2
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN1_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN1_1 = 0x1
	// Position of POEN2 field.
	PDB0_POEN_POEN2_Pos = 0x2
	// Bit mask of POEN2 field.
	PDB0_POEN_POEN2_Msk = 0x4
	// Bit POEN2.
	PDB0_POEN_POEN2 = 0x4
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN2_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN2_1 = 0x1
	// Position of POEN3 field.
	PDB0_POEN_POEN3_Pos = 0x3
	// Bit mask of POEN3 field.
	PDB0_POEN_POEN3_Msk = 0x8
	// Bit POEN3.
	PDB0_POEN_POEN3 = 0x8
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN3_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN3_1 = 0x1
	// Position of POEN4 field.
	PDB0_POEN_POEN4_Pos = 0x4
	// Bit mask of POEN4 field.
	PDB0_POEN_POEN4_Msk = 0x10
	// Bit POEN4.
	PDB0_POEN_POEN4 = 0x10
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN4_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN4_1 = 0x1
	// Position of POEN5 field.
	PDB0_POEN_POEN5_Pos = 0x5
	// Bit mask of POEN5 field.
	PDB0_POEN_POEN5_Msk = 0x20
	// Bit POEN5.
	PDB0_POEN_POEN5 = 0x20
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN5_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN5_1 = 0x1
	// Position of POEN6 field.
	PDB0_POEN_POEN6_Pos = 0x6
	// Bit mask of POEN6 field.
	PDB0_POEN_POEN6_Msk = 0x40
	// Bit POEN6.
	PDB0_POEN_POEN6 = 0x40
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN6_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN6_1 = 0x1
	// Position of POEN7 field.
	PDB0_POEN_POEN7_Pos = 0x7
	// Bit mask of POEN7 field.
	PDB0_POEN_POEN7_Msk = 0x80
	// Bit POEN7.
	PDB0_POEN_POEN7 = 0x80
	// PDB Pulse-Out disabled
	PDB0_POEN_POEN7_0 = 0x0
	// PDB Pulse-Out enabled
	PDB0_POEN_POEN7_1 = 0x1

	// PO0DLY: Pulse-Out n Delay register
	// Position of DLY2 field.
	PDB0_PODLY_DLY2_Pos = 0x0
	// Bit mask of DLY2 field.
	PDB0_PODLY_DLY2_Msk = 0xffff
	// Position of DLY1 field.
	PDB0_PODLY_DLY1_Pos = 0x10
	// Bit mask of DLY1 field.
	PDB0_PODLY_DLY1_Msk = 0xffff0000
)

// Constants for PIT: Periodic Interrupt Timer
const (
	// MCR: PIT Module Control Register
	// Position of FRZ field.
	PIT_MCR_FRZ_Pos = 0x0
	// Bit mask of FRZ field.
	PIT_MCR_FRZ_Msk = 0x1
	// Bit FRZ.
	PIT_MCR_FRZ = 0x1
	// Timers continue to run in Debug mode.
	PIT_MCR_FRZ_0 = 0x0
	// Timers are stopped in Debug mode.
	PIT_MCR_FRZ_1 = 0x1
	// Position of MDIS field.
	PIT_MCR_MDIS_Pos = 0x1
	// Bit mask of MDIS field.
	PIT_MCR_MDIS_Msk = 0x2
	// Bit MDIS.
	PIT_MCR_MDIS = 0x2
	// Clock for standard PIT timers is enabled.
	PIT_MCR_MDIS_0 = 0x0
	// Clock for standard PIT timers is disabled.
	PIT_MCR_MDIS_1 = 0x1

	// LTMR64H: PIT Upper Lifetime Timer Register
	// Position of LTH field.
	PIT_LTMR64H_LTH_Pos = 0x0
	// Bit mask of LTH field.
	PIT_LTMR64H_LTH_Msk = 0xffffffff

	// LTMR64L: PIT Lower Lifetime Timer Register
	// Position of LTL field.
	PIT_LTMR64L_LTL_Pos = 0x0
	// Bit mask of LTL field.
	PIT_LTMR64L_LTL_Msk = 0xffffffff

	// LDVAL0: Timer Load Value Register
	// Position of TSV field.
	PIT_LDVAL_TSV_Pos = 0x0
	// Bit mask of TSV field.
	PIT_LDVAL_TSV_Msk = 0xffffffff

	// CVAL0: Current Timer Value Register
	// Position of TVL field.
	PIT_CVAL_TVL_Pos = 0x0
	// Bit mask of TVL field.
	PIT_CVAL_TVL_Msk = 0xffffffff

	// TCTRL0: Timer Control Register
	// Position of TEN field.
	PIT_TCTRL_TEN_Pos = 0x0
	// Bit mask of TEN field.
	PIT_TCTRL_TEN_Msk = 0x1
	// Bit TEN.
	PIT_TCTRL_TEN = 0x1
	// Timer n is disabled.
	PIT_TCTRL_TEN_0 = 0x0
	// Timer n is enabled.
	PIT_TCTRL_TEN_1 = 0x1
	// Position of TIE field.
	PIT_TCTRL_TIE_Pos = 0x1
	// Bit mask of TIE field.
	PIT_TCTRL_TIE_Msk = 0x2
	// Bit TIE.
	PIT_TCTRL_TIE = 0x2
	// Interrupt requests from Timer n are disabled.
	PIT_TCTRL_TIE_0 = 0x0
	// Interrupt will be requested whenever TIF is set.
	PIT_TCTRL_TIE_1 = 0x1
	// Position of CHN field.
	PIT_TCTRL_CHN_Pos = 0x2
	// Bit mask of CHN field.
	PIT_TCTRL_CHN_Msk = 0x4
	// Bit CHN.
	PIT_TCTRL_CHN = 0x4
	// Timer is not chained.
	PIT_TCTRL_CHN_0 = 0x0
	// Timer is chained to previous timer. For example, for Channel 2, if this field is set, Timer 2 is chained to Timer 1.
	PIT_TCTRL_CHN_1 = 0x1

	// TFLG0: Timer Flag Register
	// Position of TIF field.
	PIT_TFLG_TIF_Pos = 0x0
	// Bit mask of TIF field.
	PIT_TFLG_TIF_Msk = 0x1
	// Bit TIF.
	PIT_TFLG_TIF = 0x1
	// Timeout has not yet occurred.
	PIT_TFLG_TIF_0 = 0x0
	// Timeout has occurred.
	PIT_TFLG_TIF_1 = 0x1
)

// Constants for FTM0: FlexTimer Module
const (
	// SC: Status And Control
	// Position of PS field.
	FTM_SC_PS_Pos = 0x0
	// Bit mask of PS field.
	FTM_SC_PS_Msk = 0x7
	// Divide by 1
	FTM_SC_PS_000 = 0x0
	// Divide by 2
	FTM_SC_PS_001 = 0x1
	// Divide by 4
	FTM_SC_PS_010 = 0x2
	// Divide by 8
	FTM_SC_PS_011 = 0x3
	// Divide by 16
	FTM_SC_PS_100 = 0x4
	// Divide by 32
	FTM_SC_PS_101 = 0x5
	// Divide by 64
	FTM_SC_PS_110 = 0x6
	// Divide by 128
	FTM_SC_PS_111 = 0x7
	// Position of CLKS field.
	FTM_SC_CLKS_Pos = 0x3
	// Bit mask of CLKS field.
	FTM_SC_CLKS_Msk = 0x18
	// No clock selected. This in effect disables the FTM counter.
	FTM_SC_CLKS_00 = 0x0
	// System clock
	FTM_SC_CLKS_01 = 0x1
	// Fixed frequency clock
	FTM_SC_CLKS_10 = 0x2
	// External clock
	FTM_SC_CLKS_11 = 0x3
	// Position of CPWMS field.
	FTM_SC_CPWMS_Pos = 0x5
	// Bit mask of CPWMS field.
	FTM_SC_CPWMS_Msk = 0x20
	// Bit CPWMS.
	FTM_SC_CPWMS = 0x20
	// FTM counter operates in Up Counting mode.
	FTM_SC_CPWMS_0 = 0x0
	// FTM counter operates in Up-Down Counting mode.
	FTM_SC_CPWMS_1 = 0x1
	// Position of TOIE field.
	FTM_SC_TOIE_Pos = 0x6
	// Bit mask of TOIE field.
	FTM_SC_TOIE_Msk = 0x40
	// Bit TOIE.
	FTM_SC_TOIE = 0x40
	// Disable TOF interrupts. Use software polling.
	FTM_SC_TOIE_0 = 0x0
	// Enable TOF interrupts. An interrupt is generated when TOF equals one.
	FTM_SC_TOIE_1 = 0x1
	// Position of TOF field.
	FTM_SC_TOF_Pos = 0x7
	// Bit mask of TOF field.
	FTM_SC_TOF_Msk = 0x80
	// Bit TOF.
	FTM_SC_TOF = 0x80
	// FTM counter has not overflowed.
	FTM_SC_TOF_0 = 0x0
	// FTM counter has overflowed.
	FTM_SC_TOF_1 = 0x1

	// CNT: Counter
	// Position of COUNT field.
	FTM_CNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	FTM_CNT_COUNT_Msk = 0xffff

	// MOD: Modulo
	// Position of MOD field.
	FTM_MOD_MOD_Pos = 0x0
	// Bit mask of MOD field.
	FTM_MOD_MOD_Msk = 0xffff

	// C0SC: Channel (n) Status And Control
	// Position of DMA field.
	FTM_CSC_DMA_Pos = 0x0
	// Bit mask of DMA field.
	FTM_CSC_DMA_Msk = 0x1
	// Bit DMA.
	FTM_CSC_DMA = 0x1
	// Disable DMA transfers.
	FTM_CSC_DMA_0 = 0x0
	// Enable DMA transfers.
	FTM_CSC_DMA_1 = 0x1
	// Position of ELSA field.
	FTM_CSC_ELSA_Pos = 0x2
	// Bit mask of ELSA field.
	FTM_CSC_ELSA_Msk = 0x4
	// Bit ELSA.
	FTM_CSC_ELSA = 0x4
	// Position of ELSB field.
	FTM_CSC_ELSB_Pos = 0x3
	// Bit mask of ELSB field.
	FTM_CSC_ELSB_Msk = 0x8
	// Bit ELSB.
	FTM_CSC_ELSB = 0x8
	// Position of MSA field.
	FTM_CSC_MSA_Pos = 0x4
	// Bit mask of MSA field.
	FTM_CSC_MSA_Msk = 0x10
	// Bit MSA.
	FTM_CSC_MSA = 0x10
	// Position of MSB field.
	FTM_CSC_MSB_Pos = 0x5
	// Bit mask of MSB field.
	FTM_CSC_MSB_Msk = 0x20
	// Bit MSB.
	FTM_CSC_MSB = 0x20
	// Position of CHIE field.
	FTM_CSC_CHIE_Pos = 0x6
	// Bit mask of CHIE field.
	FTM_CSC_CHIE_Msk = 0x40
	// Bit CHIE.
	FTM_CSC_CHIE = 0x40
	// Disable channel interrupts. Use software polling.
	FTM_CSC_CHIE_0 = 0x0
	// Enable channel interrupts.
	FTM_CSC_CHIE_1 = 0x1
	// Position of CHF field.
	FTM_CSC_CHF_Pos = 0x7
	// Bit mask of CHF field.
	FTM_CSC_CHF_Msk = 0x80
	// Bit CHF.
	FTM_CSC_CHF = 0x80
	// No channel event has occurred.
	FTM_CSC_CHF_0 = 0x0
	// A channel event has occurred.
	FTM_CSC_CHF_1 = 0x1

	// C0V: Channel (n) Value
	// Position of VAL field.
	FTM_CV_VAL_Pos = 0x0
	// Bit mask of VAL field.
	FTM_CV_VAL_Msk = 0xffff

	// CNTIN: Counter Initial Value
	// Position of INIT field.
	FTM_CNTIN_INIT_Pos = 0x0
	// Bit mask of INIT field.
	FTM_CNTIN_INIT_Msk = 0xffff

	// STATUS: Capture And Compare Status
	// Position of CH0F field.
	FTM_STATUS_CH0F_Pos = 0x0
	// Bit mask of CH0F field.
	FTM_STATUS_CH0F_Msk = 0x1
	// Bit CH0F.
	FTM_STATUS_CH0F = 0x1
	// No channel event has occurred.
	FTM_STATUS_CH0F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH0F_1 = 0x1
	// Position of CH1F field.
	FTM_STATUS_CH1F_Pos = 0x1
	// Bit mask of CH1F field.
	FTM_STATUS_CH1F_Msk = 0x2
	// Bit CH1F.
	FTM_STATUS_CH1F = 0x2
	// No channel event has occurred.
	FTM_STATUS_CH1F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH1F_1 = 0x1
	// Position of CH2F field.
	FTM_STATUS_CH2F_Pos = 0x2
	// Bit mask of CH2F field.
	FTM_STATUS_CH2F_Msk = 0x4
	// Bit CH2F.
	FTM_STATUS_CH2F = 0x4
	// No channel event has occurred.
	FTM_STATUS_CH2F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH2F_1 = 0x1
	// Position of CH3F field.
	FTM_STATUS_CH3F_Pos = 0x3
	// Bit mask of CH3F field.
	FTM_STATUS_CH3F_Msk = 0x8
	// Bit CH3F.
	FTM_STATUS_CH3F = 0x8
	// No channel event has occurred.
	FTM_STATUS_CH3F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH3F_1 = 0x1
	// Position of CH4F field.
	FTM_STATUS_CH4F_Pos = 0x4
	// Bit mask of CH4F field.
	FTM_STATUS_CH4F_Msk = 0x10
	// Bit CH4F.
	FTM_STATUS_CH4F = 0x10
	// No channel event has occurred.
	FTM_STATUS_CH4F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH4F_1 = 0x1
	// Position of CH5F field.
	FTM_STATUS_CH5F_Pos = 0x5
	// Bit mask of CH5F field.
	FTM_STATUS_CH5F_Msk = 0x20
	// Bit CH5F.
	FTM_STATUS_CH5F = 0x20
	// No channel event has occurred.
	FTM_STATUS_CH5F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH5F_1 = 0x1
	// Position of CH6F field.
	FTM_STATUS_CH6F_Pos = 0x6
	// Bit mask of CH6F field.
	FTM_STATUS_CH6F_Msk = 0x40
	// Bit CH6F.
	FTM_STATUS_CH6F = 0x40
	// No channel event has occurred.
	FTM_STATUS_CH6F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH6F_1 = 0x1
	// Position of CH7F field.
	FTM_STATUS_CH7F_Pos = 0x7
	// Bit mask of CH7F field.
	FTM_STATUS_CH7F_Msk = 0x80
	// Bit CH7F.
	FTM_STATUS_CH7F = 0x80
	// No channel event has occurred.
	FTM_STATUS_CH7F_0 = 0x0
	// A channel event has occurred.
	FTM_STATUS_CH7F_1 = 0x1

	// MODE: Features Mode Selection
	// Position of FTMEN field.
	FTM_MODE_FTMEN_Pos = 0x0
	// Bit mask of FTMEN field.
	FTM_MODE_FTMEN_Msk = 0x1
	// Bit FTMEN.
	FTM_MODE_FTMEN = 0x1
	// TPM compatibility. Free running counter and synchronization compatible with TPM.
	FTM_MODE_FTMEN_0 = 0x0
	// Free running counter and synchronization are different from TPM behavior.
	FTM_MODE_FTMEN_1 = 0x1
	// Position of INIT field.
	FTM_MODE_INIT_Pos = 0x1
	// Bit mask of INIT field.
	FTM_MODE_INIT_Msk = 0x2
	// Bit INIT.
	FTM_MODE_INIT = 0x2
	// Position of WPDIS field.
	FTM_MODE_WPDIS_Pos = 0x2
	// Bit mask of WPDIS field.
	FTM_MODE_WPDIS_Msk = 0x4
	// Bit WPDIS.
	FTM_MODE_WPDIS = 0x4
	// Write protection is enabled.
	FTM_MODE_WPDIS_0 = 0x0
	// Write protection is disabled.
	FTM_MODE_WPDIS_1 = 0x1
	// Position of PWMSYNC field.
	FTM_MODE_PWMSYNC_Pos = 0x3
	// Bit mask of PWMSYNC field.
	FTM_MODE_PWMSYNC_Msk = 0x8
	// Bit PWMSYNC.
	FTM_MODE_PWMSYNC = 0x8
	// No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization.
	FTM_MODE_PWMSYNC_0 = 0x0
	// Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization.
	FTM_MODE_PWMSYNC_1 = 0x1
	// Position of CAPTEST field.
	FTM_MODE_CAPTEST_Pos = 0x4
	// Bit mask of CAPTEST field.
	FTM_MODE_CAPTEST_Msk = 0x10
	// Bit CAPTEST.
	FTM_MODE_CAPTEST = 0x10
	// Capture test mode is disabled.
	FTM_MODE_CAPTEST_0 = 0x0
	// Capture test mode is enabled.
	FTM_MODE_CAPTEST_1 = 0x1
	// Position of FAULTM field.
	FTM_MODE_FAULTM_Pos = 0x5
	// Bit mask of FAULTM field.
	FTM_MODE_FAULTM_Msk = 0x60
	// Fault control is disabled for all channels.
	FTM_MODE_FAULTM_00 = 0x0
	// Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing.
	FTM_MODE_FAULTM_01 = 0x1
	// Fault control is enabled for all channels, and the selected mode is the manual fault clearing.
	FTM_MODE_FAULTM_10 = 0x2
	// Fault control is enabled for all channels, and the selected mode is the automatic fault clearing.
	FTM_MODE_FAULTM_11 = 0x3
	// Position of FAULTIE field.
	FTM_MODE_FAULTIE_Pos = 0x7
	// Bit mask of FAULTIE field.
	FTM_MODE_FAULTIE_Msk = 0x80
	// Bit FAULTIE.
	FTM_MODE_FAULTIE = 0x80
	// Fault control interrupt is disabled.
	FTM_MODE_FAULTIE_0 = 0x0
	// Fault control interrupt is enabled.
	FTM_MODE_FAULTIE_1 = 0x1

	// SYNC: Synchronization
	// Position of CNTMIN field.
	FTM_SYNC_CNTMIN_Pos = 0x0
	// Bit mask of CNTMIN field.
	FTM_SYNC_CNTMIN_Msk = 0x1
	// Bit CNTMIN.
	FTM_SYNC_CNTMIN = 0x1
	// The minimum loading point is disabled.
	FTM_SYNC_CNTMIN_0 = 0x0
	// The minimum loading point is enabled.
	FTM_SYNC_CNTMIN_1 = 0x1
	// Position of CNTMAX field.
	FTM_SYNC_CNTMAX_Pos = 0x1
	// Bit mask of CNTMAX field.
	FTM_SYNC_CNTMAX_Msk = 0x2
	// Bit CNTMAX.
	FTM_SYNC_CNTMAX = 0x2
	// The maximum loading point is disabled.
	FTM_SYNC_CNTMAX_0 = 0x0
	// The maximum loading point is enabled.
	FTM_SYNC_CNTMAX_1 = 0x1
	// Position of REINIT field.
	FTM_SYNC_REINIT_Pos = 0x2
	// Bit mask of REINIT field.
	FTM_SYNC_REINIT_Msk = 0x4
	// Bit REINIT.
	FTM_SYNC_REINIT = 0x4
	// FTM counter continues to count normally.
	FTM_SYNC_REINIT_0 = 0x0
	// FTM counter is updated with its initial value when the selected trigger is detected.
	FTM_SYNC_REINIT_1 = 0x1
	// Position of SYNCHOM field.
	FTM_SYNC_SYNCHOM_Pos = 0x3
	// Bit mask of SYNCHOM field.
	FTM_SYNC_SYNCHOM_Msk = 0x8
	// Bit SYNCHOM.
	FTM_SYNC_SYNCHOM = 0x8
	// OUTMASK register is updated with the value of its buffer in all rising edges of the system clock.
	FTM_SYNC_SYNCHOM_0 = 0x0
	// OUTMASK register is updated with the value of its buffer only by the PWM synchronization.
	FTM_SYNC_SYNCHOM_1 = 0x1
	// Position of TRIG0 field.
	FTM_SYNC_TRIG0_Pos = 0x4
	// Bit mask of TRIG0 field.
	FTM_SYNC_TRIG0_Msk = 0x10
	// Bit TRIG0.
	FTM_SYNC_TRIG0 = 0x10
	// Trigger is disabled.
	FTM_SYNC_TRIG0_0 = 0x0
	// Trigger is enabled.
	FTM_SYNC_TRIG0_1 = 0x1
	// Position of TRIG1 field.
	FTM_SYNC_TRIG1_Pos = 0x5
	// Bit mask of TRIG1 field.
	FTM_SYNC_TRIG1_Msk = 0x20
	// Bit TRIG1.
	FTM_SYNC_TRIG1 = 0x20
	// Trigger is disabled.
	FTM_SYNC_TRIG1_0 = 0x0
	// Trigger is enabled.
	FTM_SYNC_TRIG1_1 = 0x1
	// Position of TRIG2 field.
	FTM_SYNC_TRIG2_Pos = 0x6
	// Bit mask of TRIG2 field.
	FTM_SYNC_TRIG2_Msk = 0x40
	// Bit TRIG2.
	FTM_SYNC_TRIG2 = 0x40
	// Trigger is disabled.
	FTM_SYNC_TRIG2_0 = 0x0
	// Trigger is enabled.
	FTM_SYNC_TRIG2_1 = 0x1
	// Position of SWSYNC field.
	FTM_SYNC_SWSYNC_Pos = 0x7
	// Bit mask of SWSYNC field.
	FTM_SYNC_SWSYNC_Msk = 0x80
	// Bit SWSYNC.
	FTM_SYNC_SWSYNC = 0x80
	// Software trigger is not selected.
	FTM_SYNC_SWSYNC_0 = 0x0
	// Software trigger is selected.
	FTM_SYNC_SWSYNC_1 = 0x1

	// OUTINIT: Initial State For Channels Output
	// Position of CH0OI field.
	FTM_OUTINIT_CH0OI_Pos = 0x0
	// Bit mask of CH0OI field.
	FTM_OUTINIT_CH0OI_Msk = 0x1
	// Bit CH0OI.
	FTM_OUTINIT_CH0OI = 0x1
	// The initialization value is 0.
	FTM_OUTINIT_CH0OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH0OI_1 = 0x1
	// Position of CH1OI field.
	FTM_OUTINIT_CH1OI_Pos = 0x1
	// Bit mask of CH1OI field.
	FTM_OUTINIT_CH1OI_Msk = 0x2
	// Bit CH1OI.
	FTM_OUTINIT_CH1OI = 0x2
	// The initialization value is 0.
	FTM_OUTINIT_CH1OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH1OI_1 = 0x1
	// Position of CH2OI field.
	FTM_OUTINIT_CH2OI_Pos = 0x2
	// Bit mask of CH2OI field.
	FTM_OUTINIT_CH2OI_Msk = 0x4
	// Bit CH2OI.
	FTM_OUTINIT_CH2OI = 0x4
	// The initialization value is 0.
	FTM_OUTINIT_CH2OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH2OI_1 = 0x1
	// Position of CH3OI field.
	FTM_OUTINIT_CH3OI_Pos = 0x3
	// Bit mask of CH3OI field.
	FTM_OUTINIT_CH3OI_Msk = 0x8
	// Bit CH3OI.
	FTM_OUTINIT_CH3OI = 0x8
	// The initialization value is 0.
	FTM_OUTINIT_CH3OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH3OI_1 = 0x1
	// Position of CH4OI field.
	FTM_OUTINIT_CH4OI_Pos = 0x4
	// Bit mask of CH4OI field.
	FTM_OUTINIT_CH4OI_Msk = 0x10
	// Bit CH4OI.
	FTM_OUTINIT_CH4OI = 0x10
	// The initialization value is 0.
	FTM_OUTINIT_CH4OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH4OI_1 = 0x1
	// Position of CH5OI field.
	FTM_OUTINIT_CH5OI_Pos = 0x5
	// Bit mask of CH5OI field.
	FTM_OUTINIT_CH5OI_Msk = 0x20
	// Bit CH5OI.
	FTM_OUTINIT_CH5OI = 0x20
	// The initialization value is 0.
	FTM_OUTINIT_CH5OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH5OI_1 = 0x1
	// Position of CH6OI field.
	FTM_OUTINIT_CH6OI_Pos = 0x6
	// Bit mask of CH6OI field.
	FTM_OUTINIT_CH6OI_Msk = 0x40
	// Bit CH6OI.
	FTM_OUTINIT_CH6OI = 0x40
	// The initialization value is 0.
	FTM_OUTINIT_CH6OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH6OI_1 = 0x1
	// Position of CH7OI field.
	FTM_OUTINIT_CH7OI_Pos = 0x7
	// Bit mask of CH7OI field.
	FTM_OUTINIT_CH7OI_Msk = 0x80
	// Bit CH7OI.
	FTM_OUTINIT_CH7OI = 0x80
	// The initialization value is 0.
	FTM_OUTINIT_CH7OI_0 = 0x0
	// The initialization value is 1.
	FTM_OUTINIT_CH7OI_1 = 0x1

	// OUTMASK: Output Mask
	// Position of CH0OM field.
	FTM_OUTMASK_CH0OM_Pos = 0x0
	// Bit mask of CH0OM field.
	FTM_OUTMASK_CH0OM_Msk = 0x1
	// Bit CH0OM.
	FTM_OUTMASK_CH0OM = 0x1
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH0OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH0OM_1 = 0x1
	// Position of CH1OM field.
	FTM_OUTMASK_CH1OM_Pos = 0x1
	// Bit mask of CH1OM field.
	FTM_OUTMASK_CH1OM_Msk = 0x2
	// Bit CH1OM.
	FTM_OUTMASK_CH1OM = 0x2
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH1OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH1OM_1 = 0x1
	// Position of CH2OM field.
	FTM_OUTMASK_CH2OM_Pos = 0x2
	// Bit mask of CH2OM field.
	FTM_OUTMASK_CH2OM_Msk = 0x4
	// Bit CH2OM.
	FTM_OUTMASK_CH2OM = 0x4
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH2OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH2OM_1 = 0x1
	// Position of CH3OM field.
	FTM_OUTMASK_CH3OM_Pos = 0x3
	// Bit mask of CH3OM field.
	FTM_OUTMASK_CH3OM_Msk = 0x8
	// Bit CH3OM.
	FTM_OUTMASK_CH3OM = 0x8
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH3OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH3OM_1 = 0x1
	// Position of CH4OM field.
	FTM_OUTMASK_CH4OM_Pos = 0x4
	// Bit mask of CH4OM field.
	FTM_OUTMASK_CH4OM_Msk = 0x10
	// Bit CH4OM.
	FTM_OUTMASK_CH4OM = 0x10
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH4OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH4OM_1 = 0x1
	// Position of CH5OM field.
	FTM_OUTMASK_CH5OM_Pos = 0x5
	// Bit mask of CH5OM field.
	FTM_OUTMASK_CH5OM_Msk = 0x20
	// Bit CH5OM.
	FTM_OUTMASK_CH5OM = 0x20
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH5OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH5OM_1 = 0x1
	// Position of CH6OM field.
	FTM_OUTMASK_CH6OM_Pos = 0x6
	// Bit mask of CH6OM field.
	FTM_OUTMASK_CH6OM_Msk = 0x40
	// Bit CH6OM.
	FTM_OUTMASK_CH6OM = 0x40
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH6OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH6OM_1 = 0x1
	// Position of CH7OM field.
	FTM_OUTMASK_CH7OM_Pos = 0x7
	// Bit mask of CH7OM field.
	FTM_OUTMASK_CH7OM_Msk = 0x80
	// Bit CH7OM.
	FTM_OUTMASK_CH7OM = 0x80
	// Channel output is not masked. It continues to operate normally.
	FTM_OUTMASK_CH7OM_0 = 0x0
	// Channel output is masked. It is forced to its inactive state.
	FTM_OUTMASK_CH7OM_1 = 0x1

	// COMBINE: Function For Linked Channels
	// Position of COMBINE0 field.
	FTM_COMBINE_COMBINE0_Pos = 0x0
	// Bit mask of COMBINE0 field.
	FTM_COMBINE_COMBINE0_Msk = 0x1
	// Bit COMBINE0.
	FTM_COMBINE_COMBINE0 = 0x1
	// Channels (n) and (n+1) are independent.
	FTM_COMBINE_COMBINE0_0 = 0x0
	// Channels (n) and (n+1) are combined.
	FTM_COMBINE_COMBINE0_1 = 0x1
	// Position of COMP0 field.
	FTM_COMBINE_COMP0_Pos = 0x1
	// Bit mask of COMP0 field.
	FTM_COMBINE_COMP0_Msk = 0x2
	// Bit COMP0.
	FTM_COMBINE_COMP0 = 0x2
	// The channel (n+1) output is the same as the channel (n) output.
	FTM_COMBINE_COMP0_0 = 0x0
	// The channel (n+1) output is the complement of the channel (n) output.
	FTM_COMBINE_COMP0_1 = 0x1
	// Position of DECAPEN0 field.
	FTM_COMBINE_DECAPEN0_Pos = 0x2
	// Bit mask of DECAPEN0 field.
	FTM_COMBINE_DECAPEN0_Msk = 0x4
	// Bit DECAPEN0.
	FTM_COMBINE_DECAPEN0 = 0x4
	// The Dual Edge Capture mode in this pair of channels is disabled.
	FTM_COMBINE_DECAPEN0_0 = 0x0
	// The Dual Edge Capture mode in this pair of channels is enabled.
	FTM_COMBINE_DECAPEN0_1 = 0x1
	// Position of DECAP0 field.
	FTM_COMBINE_DECAP0_Pos = 0x3
	// Bit mask of DECAP0 field.
	FTM_COMBINE_DECAP0_Msk = 0x8
	// Bit DECAP0.
	FTM_COMBINE_DECAP0 = 0x8
	// The dual edge captures are inactive.
	FTM_COMBINE_DECAP0_0 = 0x0
	// The dual edge captures are active.
	FTM_COMBINE_DECAP0_1 = 0x1
	// Position of DTEN0 field.
	FTM_COMBINE_DTEN0_Pos = 0x4
	// Bit mask of DTEN0 field.
	FTM_COMBINE_DTEN0_Msk = 0x10
	// Bit DTEN0.
	FTM_COMBINE_DTEN0 = 0x10
	// The deadtime insertion in this pair of channels is disabled.
	FTM_COMBINE_DTEN0_0 = 0x0
	// The deadtime insertion in this pair of channels is enabled.
	FTM_COMBINE_DTEN0_1 = 0x1
	// Position of SYNCEN0 field.
	FTM_COMBINE_SYNCEN0_Pos = 0x5
	// Bit mask of SYNCEN0 field.
	FTM_COMBINE_SYNCEN0_Msk = 0x20
	// Bit SYNCEN0.
	FTM_COMBINE_SYNCEN0 = 0x20
	// The PWM synchronization in this pair of channels is disabled.
	FTM_COMBINE_SYNCEN0_0 = 0x0
	// The PWM synchronization in this pair of channels is enabled.
	FTM_COMBINE_SYNCEN0_1 = 0x1
	// Position of FAULTEN0 field.
	FTM_COMBINE_FAULTEN0_Pos = 0x6
	// Bit mask of FAULTEN0 field.
	FTM_COMBINE_FAULTEN0_Msk = 0x40
	// Bit FAULTEN0.
	FTM_COMBINE_FAULTEN0 = 0x40
	// The fault control in this pair of channels is disabled.
	FTM_COMBINE_FAULTEN0_0 = 0x0
	// The fault control in this pair of channels is enabled.
	FTM_COMBINE_FAULTEN0_1 = 0x1
	// Position of COMBINE1 field.
	FTM_COMBINE_COMBINE1_Pos = 0x8
	// Bit mask of COMBINE1 field.
	FTM_COMBINE_COMBINE1_Msk = 0x100
	// Bit COMBINE1.
	FTM_COMBINE_COMBINE1 = 0x100
	// Channels (n) and (n+1) are independent.
	FTM_COMBINE_COMBINE1_0 = 0x0
	// Channels (n) and (n+1) are combined.
	FTM_COMBINE_COMBINE1_1 = 0x1
	// Position of COMP1 field.
	FTM_COMBINE_COMP1_Pos = 0x9
	// Bit mask of COMP1 field.
	FTM_COMBINE_COMP1_Msk = 0x200
	// Bit COMP1.
	FTM_COMBINE_COMP1 = 0x200
	// The channel (n+1) output is the same as the channel (n) output.
	FTM_COMBINE_COMP1_0 = 0x0
	// The channel (n+1) output is the complement of the channel (n) output.
	FTM_COMBINE_COMP1_1 = 0x1
	// Position of DECAPEN1 field.
	FTM_COMBINE_DECAPEN1_Pos = 0xa
	// Bit mask of DECAPEN1 field.
	FTM_COMBINE_DECAPEN1_Msk = 0x400
	// Bit DECAPEN1.
	FTM_COMBINE_DECAPEN1 = 0x400
	// The Dual Edge Capture mode in this pair of channels is disabled.
	FTM_COMBINE_DECAPEN1_0 = 0x0
	// The Dual Edge Capture mode in this pair of channels is enabled.
	FTM_COMBINE_DECAPEN1_1 = 0x1
	// Position of DECAP1 field.
	FTM_COMBINE_DECAP1_Pos = 0xb
	// Bit mask of DECAP1 field.
	FTM_COMBINE_DECAP1_Msk = 0x800
	// Bit DECAP1.
	FTM_COMBINE_DECAP1 = 0x800
	// The dual edge captures are inactive.
	FTM_COMBINE_DECAP1_0 = 0x0
	// The dual edge captures are active.
	FTM_COMBINE_DECAP1_1 = 0x1
	// Position of DTEN1 field.
	FTM_COMBINE_DTEN1_Pos = 0xc
	// Bit mask of DTEN1 field.
	FTM_COMBINE_DTEN1_Msk = 0x1000
	// Bit DTEN1.
	FTM_COMBINE_DTEN1 = 0x1000
	// The deadtime insertion in this pair of channels is disabled.
	FTM_COMBINE_DTEN1_0 = 0x0
	// The deadtime insertion in this pair of channels is enabled.
	FTM_COMBINE_DTEN1_1 = 0x1
	// Position of SYNCEN1 field.
	FTM_COMBINE_SYNCEN1_Pos = 0xd
	// Bit mask of SYNCEN1 field.
	FTM_COMBINE_SYNCEN1_Msk = 0x2000
	// Bit SYNCEN1.
	FTM_COMBINE_SYNCEN1 = 0x2000
	// The PWM synchronization in this pair of channels is disabled.
	FTM_COMBINE_SYNCEN1_0 = 0x0
	// The PWM synchronization in this pair of channels is enabled.
	FTM_COMBINE_SYNCEN1_1 = 0x1
	// Position of FAULTEN1 field.
	FTM_COMBINE_FAULTEN1_Pos = 0xe
	// Bit mask of FAULTEN1 field.
	FTM_COMBINE_FAULTEN1_Msk = 0x4000
	// Bit FAULTEN1.
	FTM_COMBINE_FAULTEN1 = 0x4000
	// The fault control in this pair of channels is disabled.
	FTM_COMBINE_FAULTEN1_0 = 0x0
	// The fault control in this pair of channels is enabled.
	FTM_COMBINE_FAULTEN1_1 = 0x1
	// Position of COMBINE2 field.
	FTM_COMBINE_COMBINE2_Pos = 0x10
	// Bit mask of COMBINE2 field.
	FTM_COMBINE_COMBINE2_Msk = 0x10000
	// Bit COMBINE2.
	FTM_COMBINE_COMBINE2 = 0x10000
	// Channels (n) and (n+1) are independent.
	FTM_COMBINE_COMBINE2_0 = 0x0
	// Channels (n) and (n+1) are combined.
	FTM_COMBINE_COMBINE2_1 = 0x1
	// Position of COMP2 field.
	FTM_COMBINE_COMP2_Pos = 0x11
	// Bit mask of COMP2 field.
	FTM_COMBINE_COMP2_Msk = 0x20000
	// Bit COMP2.
	FTM_COMBINE_COMP2 = 0x20000
	// The channel (n+1) output is the same as the channel (n) output.
	FTM_COMBINE_COMP2_0 = 0x0
	// The channel (n+1) output is the complement of the channel (n) output.
	FTM_COMBINE_COMP2_1 = 0x1
	// Position of DECAPEN2 field.
	FTM_COMBINE_DECAPEN2_Pos = 0x12
	// Bit mask of DECAPEN2 field.
	FTM_COMBINE_DECAPEN2_Msk = 0x40000
	// Bit DECAPEN2.
	FTM_COMBINE_DECAPEN2 = 0x40000
	// The Dual Edge Capture mode in this pair of channels is disabled.
	FTM_COMBINE_DECAPEN2_0 = 0x0
	// The Dual Edge Capture mode in this pair of channels is enabled.
	FTM_COMBINE_DECAPEN2_1 = 0x1
	// Position of DECAP2 field.
	FTM_COMBINE_DECAP2_Pos = 0x13
	// Bit mask of DECAP2 field.
	FTM_COMBINE_DECAP2_Msk = 0x80000
	// Bit DECAP2.
	FTM_COMBINE_DECAP2 = 0x80000
	// The dual edge captures are inactive.
	FTM_COMBINE_DECAP2_0 = 0x0
	// The dual edge captures are active.
	FTM_COMBINE_DECAP2_1 = 0x1
	// Position of DTEN2 field.
	FTM_COMBINE_DTEN2_Pos = 0x14
	// Bit mask of DTEN2 field.
	FTM_COMBINE_DTEN2_Msk = 0x100000
	// Bit DTEN2.
	FTM_COMBINE_DTEN2 = 0x100000
	// The deadtime insertion in this pair of channels is disabled.
	FTM_COMBINE_DTEN2_0 = 0x0
	// The deadtime insertion in this pair of channels is enabled.
	FTM_COMBINE_DTEN2_1 = 0x1
	// Position of SYNCEN2 field.
	FTM_COMBINE_SYNCEN2_Pos = 0x15
	// Bit mask of SYNCEN2 field.
	FTM_COMBINE_SYNCEN2_Msk = 0x200000
	// Bit SYNCEN2.
	FTM_COMBINE_SYNCEN2 = 0x200000
	// The PWM synchronization in this pair of channels is disabled.
	FTM_COMBINE_SYNCEN2_0 = 0x0
	// The PWM synchronization in this pair of channels is enabled.
	FTM_COMBINE_SYNCEN2_1 = 0x1
	// Position of FAULTEN2 field.
	FTM_COMBINE_FAULTEN2_Pos = 0x16
	// Bit mask of FAULTEN2 field.
	FTM_COMBINE_FAULTEN2_Msk = 0x400000
	// Bit FAULTEN2.
	FTM_COMBINE_FAULTEN2 = 0x400000
	// The fault control in this pair of channels is disabled.
	FTM_COMBINE_FAULTEN2_0 = 0x0
	// The fault control in this pair of channels is enabled.
	FTM_COMBINE_FAULTEN2_1 = 0x1
	// Position of COMBINE3 field.
	FTM_COMBINE_COMBINE3_Pos = 0x18
	// Bit mask of COMBINE3 field.
	FTM_COMBINE_COMBINE3_Msk = 0x1000000
	// Bit COMBINE3.
	FTM_COMBINE_COMBINE3 = 0x1000000
	// Channels (n) and (n+1) are independent.
	FTM_COMBINE_COMBINE3_0 = 0x0
	// Channels (n) and (n+1) are combined.
	FTM_COMBINE_COMBINE3_1 = 0x1
	// Position of COMP3 field.
	FTM_COMBINE_COMP3_Pos = 0x19
	// Bit mask of COMP3 field.
	FTM_COMBINE_COMP3_Msk = 0x2000000
	// Bit COMP3.
	FTM_COMBINE_COMP3 = 0x2000000
	// The channel (n+1) output is the same as the channel (n) output.
	FTM_COMBINE_COMP3_0 = 0x0
	// The channel (n+1) output is the complement of the channel (n) output.
	FTM_COMBINE_COMP3_1 = 0x1
	// Position of DECAPEN3 field.
	FTM_COMBINE_DECAPEN3_Pos = 0x1a
	// Bit mask of DECAPEN3 field.
	FTM_COMBINE_DECAPEN3_Msk = 0x4000000
	// Bit DECAPEN3.
	FTM_COMBINE_DECAPEN3 = 0x4000000
	// The Dual Edge Capture mode in this pair of channels is disabled.
	FTM_COMBINE_DECAPEN3_0 = 0x0
	// The Dual Edge Capture mode in this pair of channels is enabled.
	FTM_COMBINE_DECAPEN3_1 = 0x1
	// Position of DECAP3 field.
	FTM_COMBINE_DECAP3_Pos = 0x1b
	// Bit mask of DECAP3 field.
	FTM_COMBINE_DECAP3_Msk = 0x8000000
	// Bit DECAP3.
	FTM_COMBINE_DECAP3 = 0x8000000
	// The dual edge captures are inactive.
	FTM_COMBINE_DECAP3_0 = 0x0
	// The dual edge captures are active.
	FTM_COMBINE_DECAP3_1 = 0x1
	// Position of DTEN3 field.
	FTM_COMBINE_DTEN3_Pos = 0x1c
	// Bit mask of DTEN3 field.
	FTM_COMBINE_DTEN3_Msk = 0x10000000
	// Bit DTEN3.
	FTM_COMBINE_DTEN3 = 0x10000000
	// The deadtime insertion in this pair of channels is disabled.
	FTM_COMBINE_DTEN3_0 = 0x0
	// The deadtime insertion in this pair of channels is enabled.
	FTM_COMBINE_DTEN3_1 = 0x1
	// Position of SYNCEN3 field.
	FTM_COMBINE_SYNCEN3_Pos = 0x1d
	// Bit mask of SYNCEN3 field.
	FTM_COMBINE_SYNCEN3_Msk = 0x20000000
	// Bit SYNCEN3.
	FTM_COMBINE_SYNCEN3 = 0x20000000
	// The PWM synchronization in this pair of channels is disabled.
	FTM_COMBINE_SYNCEN3_0 = 0x0
	// The PWM synchronization in this pair of channels is enabled.
	FTM_COMBINE_SYNCEN3_1 = 0x1
	// Position of FAULTEN3 field.
	FTM_COMBINE_FAULTEN3_Pos = 0x1e
	// Bit mask of FAULTEN3 field.
	FTM_COMBINE_FAULTEN3_Msk = 0x40000000
	// Bit FAULTEN3.
	FTM_COMBINE_FAULTEN3 = 0x40000000
	// The fault control in this pair of channels is disabled.
	FTM_COMBINE_FAULTEN3_0 = 0x0
	// The fault control in this pair of channels is enabled.
	FTM_COMBINE_FAULTEN3_1 = 0x1

	// DEADTIME: Deadtime Insertion Control
	// Position of DTVAL field.
	FTM_DEADTIME_DTVAL_Pos = 0x0
	// Bit mask of DTVAL field.
	FTM_DEADTIME_DTVAL_Msk = 0x3f
	// Position of DTPS field.
	FTM_DEADTIME_DTPS_Pos = 0x6
	// Bit mask of DTPS field.
	FTM_DEADTIME_DTPS_Msk = 0xc0
	// Divide the system clock by 4.
	FTM_DEADTIME_DTPS_10 = 0x2
	// Divide the system clock by 16.
	FTM_DEADTIME_DTPS_11 = 0x3

	// EXTTRIG: FTM External Trigger
	// Position of CH2TRIG field.
	FTM_EXTTRIG_CH2TRIG_Pos = 0x0
	// Bit mask of CH2TRIG field.
	FTM_EXTTRIG_CH2TRIG_Msk = 0x1
	// Bit CH2TRIG.
	FTM_EXTTRIG_CH2TRIG = 0x1
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH2TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH2TRIG_1 = 0x1
	// Position of CH3TRIG field.
	FTM_EXTTRIG_CH3TRIG_Pos = 0x1
	// Bit mask of CH3TRIG field.
	FTM_EXTTRIG_CH3TRIG_Msk = 0x2
	// Bit CH3TRIG.
	FTM_EXTTRIG_CH3TRIG = 0x2
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH3TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH3TRIG_1 = 0x1
	// Position of CH4TRIG field.
	FTM_EXTTRIG_CH4TRIG_Pos = 0x2
	// Bit mask of CH4TRIG field.
	FTM_EXTTRIG_CH4TRIG_Msk = 0x4
	// Bit CH4TRIG.
	FTM_EXTTRIG_CH4TRIG = 0x4
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH4TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH4TRIG_1 = 0x1
	// Position of CH5TRIG field.
	FTM_EXTTRIG_CH5TRIG_Pos = 0x3
	// Bit mask of CH5TRIG field.
	FTM_EXTTRIG_CH5TRIG_Msk = 0x8
	// Bit CH5TRIG.
	FTM_EXTTRIG_CH5TRIG = 0x8
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH5TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH5TRIG_1 = 0x1
	// Position of CH0TRIG field.
	FTM_EXTTRIG_CH0TRIG_Pos = 0x4
	// Bit mask of CH0TRIG field.
	FTM_EXTTRIG_CH0TRIG_Msk = 0x10
	// Bit CH0TRIG.
	FTM_EXTTRIG_CH0TRIG = 0x10
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH0TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH0TRIG_1 = 0x1
	// Position of CH1TRIG field.
	FTM_EXTTRIG_CH1TRIG_Pos = 0x5
	// Bit mask of CH1TRIG field.
	FTM_EXTTRIG_CH1TRIG_Msk = 0x20
	// Bit CH1TRIG.
	FTM_EXTTRIG_CH1TRIG = 0x20
	// The generation of the channel trigger is disabled.
	FTM_EXTTRIG_CH1TRIG_0 = 0x0
	// The generation of the channel trigger is enabled.
	FTM_EXTTRIG_CH1TRIG_1 = 0x1
	// Position of INITTRIGEN field.
	FTM_EXTTRIG_INITTRIGEN_Pos = 0x6
	// Bit mask of INITTRIGEN field.
	FTM_EXTTRIG_INITTRIGEN_Msk = 0x40
	// Bit INITTRIGEN.
	FTM_EXTTRIG_INITTRIGEN = 0x40
	// The generation of initialization trigger is disabled.
	FTM_EXTTRIG_INITTRIGEN_0 = 0x0
	// The generation of initialization trigger is enabled.
	FTM_EXTTRIG_INITTRIGEN_1 = 0x1
	// Position of TRIGF field.
	FTM_EXTTRIG_TRIGF_Pos = 0x7
	// Bit mask of TRIGF field.
	FTM_EXTTRIG_TRIGF_Msk = 0x80
	// Bit TRIGF.
	FTM_EXTTRIG_TRIGF = 0x80
	// No channel trigger was generated.
	FTM_EXTTRIG_TRIGF_0 = 0x0
	// A channel trigger was generated.
	FTM_EXTTRIG_TRIGF_1 = 0x1

	// POL: Channels Polarity
	// Position of POL0 field.
	FTM_POL_POL0_Pos = 0x0
	// Bit mask of POL0 field.
	FTM_POL_POL0_Msk = 0x1
	// Bit POL0.
	FTM_POL_POL0 = 0x1
	// The channel polarity is active high.
	FTM_POL_POL0_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL0_1 = 0x1
	// Position of POL1 field.
	FTM_POL_POL1_Pos = 0x1
	// Bit mask of POL1 field.
	FTM_POL_POL1_Msk = 0x2
	// Bit POL1.
	FTM_POL_POL1 = 0x2
	// The channel polarity is active high.
	FTM_POL_POL1_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL1_1 = 0x1
	// Position of POL2 field.
	FTM_POL_POL2_Pos = 0x2
	// Bit mask of POL2 field.
	FTM_POL_POL2_Msk = 0x4
	// Bit POL2.
	FTM_POL_POL2 = 0x4
	// The channel polarity is active high.
	FTM_POL_POL2_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL2_1 = 0x1
	// Position of POL3 field.
	FTM_POL_POL3_Pos = 0x3
	// Bit mask of POL3 field.
	FTM_POL_POL3_Msk = 0x8
	// Bit POL3.
	FTM_POL_POL3 = 0x8
	// The channel polarity is active high.
	FTM_POL_POL3_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL3_1 = 0x1
	// Position of POL4 field.
	FTM_POL_POL4_Pos = 0x4
	// Bit mask of POL4 field.
	FTM_POL_POL4_Msk = 0x10
	// Bit POL4.
	FTM_POL_POL4 = 0x10
	// The channel polarity is active high.
	FTM_POL_POL4_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL4_1 = 0x1
	// Position of POL5 field.
	FTM_POL_POL5_Pos = 0x5
	// Bit mask of POL5 field.
	FTM_POL_POL5_Msk = 0x20
	// Bit POL5.
	FTM_POL_POL5 = 0x20
	// The channel polarity is active high.
	FTM_POL_POL5_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL5_1 = 0x1
	// Position of POL6 field.
	FTM_POL_POL6_Pos = 0x6
	// Bit mask of POL6 field.
	FTM_POL_POL6_Msk = 0x40
	// Bit POL6.
	FTM_POL_POL6 = 0x40
	// The channel polarity is active high.
	FTM_POL_POL6_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL6_1 = 0x1
	// Position of POL7 field.
	FTM_POL_POL7_Pos = 0x7
	// Bit mask of POL7 field.
	FTM_POL_POL7_Msk = 0x80
	// Bit POL7.
	FTM_POL_POL7 = 0x80
	// The channel polarity is active high.
	FTM_POL_POL7_0 = 0x0
	// The channel polarity is active low.
	FTM_POL_POL7_1 = 0x1

	// FMS: Fault Mode Status
	// Position of FAULTF0 field.
	FTM_FMS_FAULTF0_Pos = 0x0
	// Bit mask of FAULTF0 field.
	FTM_FMS_FAULTF0_Msk = 0x1
	// Bit FAULTF0.
	FTM_FMS_FAULTF0 = 0x1
	// No fault condition was detected at the fault input.
	FTM_FMS_FAULTF0_0 = 0x0
	// A fault condition was detected at the fault input.
	FTM_FMS_FAULTF0_1 = 0x1
	// Position of FAULTF1 field.
	FTM_FMS_FAULTF1_Pos = 0x1
	// Bit mask of FAULTF1 field.
	FTM_FMS_FAULTF1_Msk = 0x2
	// Bit FAULTF1.
	FTM_FMS_FAULTF1 = 0x2
	// No fault condition was detected at the fault input.
	FTM_FMS_FAULTF1_0 = 0x0
	// A fault condition was detected at the fault input.
	FTM_FMS_FAULTF1_1 = 0x1
	// Position of FAULTF2 field.
	FTM_FMS_FAULTF2_Pos = 0x2
	// Bit mask of FAULTF2 field.
	FTM_FMS_FAULTF2_Msk = 0x4
	// Bit FAULTF2.
	FTM_FMS_FAULTF2 = 0x4
	// No fault condition was detected at the fault input.
	FTM_FMS_FAULTF2_0 = 0x0
	// A fault condition was detected at the fault input.
	FTM_FMS_FAULTF2_1 = 0x1
	// Position of FAULTF3 field.
	FTM_FMS_FAULTF3_Pos = 0x3
	// Bit mask of FAULTF3 field.
	FTM_FMS_FAULTF3_Msk = 0x8
	// Bit FAULTF3.
	FTM_FMS_FAULTF3 = 0x8
	// No fault condition was detected at the fault input.
	FTM_FMS_FAULTF3_0 = 0x0
	// A fault condition was detected at the fault input.
	FTM_FMS_FAULTF3_1 = 0x1
	// Position of FAULTIN field.
	FTM_FMS_FAULTIN_Pos = 0x5
	// Bit mask of FAULTIN field.
	FTM_FMS_FAULTIN_Msk = 0x20
	// Bit FAULTIN.
	FTM_FMS_FAULTIN = 0x20
	// The logic OR of the enabled fault inputs is 0.
	FTM_FMS_FAULTIN_0 = 0x0
	// The logic OR of the enabled fault inputs is 1.
	FTM_FMS_FAULTIN_1 = 0x1
	// Position of WPEN field.
	FTM_FMS_WPEN_Pos = 0x6
	// Bit mask of WPEN field.
	FTM_FMS_WPEN_Msk = 0x40
	// Bit WPEN.
	FTM_FMS_WPEN = 0x40
	// Write protection is disabled. Write protected bits can be written.
	FTM_FMS_WPEN_0 = 0x0
	// Write protection is enabled. Write protected bits cannot be written.
	FTM_FMS_WPEN_1 = 0x1
	// Position of FAULTF field.
	FTM_FMS_FAULTF_Pos = 0x7
	// Bit mask of FAULTF field.
	FTM_FMS_FAULTF_Msk = 0x80
	// Bit FAULTF.
	FTM_FMS_FAULTF = 0x80
	// No fault condition was detected.
	FTM_FMS_FAULTF_0 = 0x0
	// A fault condition was detected.
	FTM_FMS_FAULTF_1 = 0x1

	// FILTER: Input Capture Filter Control
	// Position of CH0FVAL field.
	FTM_FILTER_CH0FVAL_Pos = 0x0
	// Bit mask of CH0FVAL field.
	FTM_FILTER_CH0FVAL_Msk = 0xf
	// Position of CH1FVAL field.
	FTM_FILTER_CH1FVAL_Pos = 0x4
	// Bit mask of CH1FVAL field.
	FTM_FILTER_CH1FVAL_Msk = 0xf0
	// Position of CH2FVAL field.
	FTM_FILTER_CH2FVAL_Pos = 0x8
	// Bit mask of CH2FVAL field.
	FTM_FILTER_CH2FVAL_Msk = 0xf00
	// Position of CH3FVAL field.
	FTM_FILTER_CH3FVAL_Pos = 0xc
	// Bit mask of CH3FVAL field.
	FTM_FILTER_CH3FVAL_Msk = 0xf000

	// FLTCTRL: Fault Control
	// Position of FAULT0EN field.
	FTM_FLTCTRL_FAULT0EN_Pos = 0x0
	// Bit mask of FAULT0EN field.
	FTM_FLTCTRL_FAULT0EN_Msk = 0x1
	// Bit FAULT0EN.
	FTM_FLTCTRL_FAULT0EN = 0x1
	// Fault input is disabled.
	FTM_FLTCTRL_FAULT0EN_0 = 0x0
	// Fault input is enabled.
	FTM_FLTCTRL_FAULT0EN_1 = 0x1
	// Position of FAULT1EN field.
	FTM_FLTCTRL_FAULT1EN_Pos = 0x1
	// Bit mask of FAULT1EN field.
	FTM_FLTCTRL_FAULT1EN_Msk = 0x2
	// Bit FAULT1EN.
	FTM_FLTCTRL_FAULT1EN = 0x2
	// Fault input is disabled.
	FTM_FLTCTRL_FAULT1EN_0 = 0x0
	// Fault input is enabled.
	FTM_FLTCTRL_FAULT1EN_1 = 0x1
	// Position of FAULT2EN field.
	FTM_FLTCTRL_FAULT2EN_Pos = 0x2
	// Bit mask of FAULT2EN field.
	FTM_FLTCTRL_FAULT2EN_Msk = 0x4
	// Bit FAULT2EN.
	FTM_FLTCTRL_FAULT2EN = 0x4
	// Fault input is disabled.
	FTM_FLTCTRL_FAULT2EN_0 = 0x0
	// Fault input is enabled.
	FTM_FLTCTRL_FAULT2EN_1 = 0x1
	// Position of FAULT3EN field.
	FTM_FLTCTRL_FAULT3EN_Pos = 0x3
	// Bit mask of FAULT3EN field.
	FTM_FLTCTRL_FAULT3EN_Msk = 0x8
	// Bit FAULT3EN.
	FTM_FLTCTRL_FAULT3EN = 0x8
	// Fault input is disabled.
	FTM_FLTCTRL_FAULT3EN_0 = 0x0
	// Fault input is enabled.
	FTM_FLTCTRL_FAULT3EN_1 = 0x1
	// Position of FFLTR0EN field.
	FTM_FLTCTRL_FFLTR0EN_Pos = 0x4
	// Bit mask of FFLTR0EN field.
	FTM_FLTCTRL_FFLTR0EN_Msk = 0x10
	// Bit FFLTR0EN.
	FTM_FLTCTRL_FFLTR0EN = 0x10
	// Fault input filter is disabled.
	FTM_FLTCTRL_FFLTR0EN_0 = 0x0
	// Fault input filter is enabled.
	FTM_FLTCTRL_FFLTR0EN_1 = 0x1
	// Position of FFLTR1EN field.
	FTM_FLTCTRL_FFLTR1EN_Pos = 0x5
	// Bit mask of FFLTR1EN field.
	FTM_FLTCTRL_FFLTR1EN_Msk = 0x20
	// Bit FFLTR1EN.
	FTM_FLTCTRL_FFLTR1EN = 0x20
	// Fault input filter is disabled.
	FTM_FLTCTRL_FFLTR1EN_0 = 0x0
	// Fault input filter is enabled.
	FTM_FLTCTRL_FFLTR1EN_1 = 0x1
	// Position of FFLTR2EN field.
	FTM_FLTCTRL_FFLTR2EN_Pos = 0x6
	// Bit mask of FFLTR2EN field.
	FTM_FLTCTRL_FFLTR2EN_Msk = 0x40
	// Bit FFLTR2EN.
	FTM_FLTCTRL_FFLTR2EN = 0x40
	// Fault input filter is disabled.
	FTM_FLTCTRL_FFLTR2EN_0 = 0x0
	// Fault input filter is enabled.
	FTM_FLTCTRL_FFLTR2EN_1 = 0x1
	// Position of FFLTR3EN field.
	FTM_FLTCTRL_FFLTR3EN_Pos = 0x7
	// Bit mask of FFLTR3EN field.
	FTM_FLTCTRL_FFLTR3EN_Msk = 0x80
	// Bit FFLTR3EN.
	FTM_FLTCTRL_FFLTR3EN = 0x80
	// Fault input filter is disabled.
	FTM_FLTCTRL_FFLTR3EN_0 = 0x0
	// Fault input filter is enabled.
	FTM_FLTCTRL_FFLTR3EN_1 = 0x1
	// Position of FFVAL field.
	FTM_FLTCTRL_FFVAL_Pos = 0x8
	// Bit mask of FFVAL field.
	FTM_FLTCTRL_FFVAL_Msk = 0xf00

	// QDCTRL: Quadrature Decoder Control And Status
	// Position of QUADEN field.
	FTM_QDCTRL_QUADEN_Pos = 0x0
	// Bit mask of QUADEN field.
	FTM_QDCTRL_QUADEN_Msk = 0x1
	// Bit QUADEN.
	FTM_QDCTRL_QUADEN = 0x1
	// Quadrature Decoder mode is disabled.
	FTM_QDCTRL_QUADEN_0 = 0x0
	// Quadrature Decoder mode is enabled.
	FTM_QDCTRL_QUADEN_1 = 0x1
	// Position of TOFDIR field.
	FTM_QDCTRL_TOFDIR_Pos = 0x1
	// Bit mask of TOFDIR field.
	FTM_QDCTRL_TOFDIR_Msk = 0x2
	// Bit TOFDIR.
	FTM_QDCTRL_TOFDIR = 0x2
	// TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (CNTIN register) to its maximum value (MOD register).
	FTM_QDCTRL_TOFDIR_0 = 0x0
	// TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (CNTIN register).
	FTM_QDCTRL_TOFDIR_1 = 0x1
	// Position of QUADIR field.
	FTM_QDCTRL_QUADIR_Pos = 0x2
	// Bit mask of QUADIR field.
	FTM_QDCTRL_QUADIR_Msk = 0x4
	// Bit QUADIR.
	FTM_QDCTRL_QUADIR = 0x4
	// Counting direction is decreasing (FTM counter decrement).
	FTM_QDCTRL_QUADIR_0 = 0x0
	// Counting direction is increasing (FTM counter increment).
	FTM_QDCTRL_QUADIR_1 = 0x1
	// Position of QUADMODE field.
	FTM_QDCTRL_QUADMODE_Pos = 0x3
	// Bit mask of QUADMODE field.
	FTM_QDCTRL_QUADMODE_Msk = 0x8
	// Bit QUADMODE.
	FTM_QDCTRL_QUADMODE = 0x8
	// Phase A and phase B encoding mode.
	FTM_QDCTRL_QUADMODE_0 = 0x0
	// Count and direction encoding mode.
	FTM_QDCTRL_QUADMODE_1 = 0x1
	// Position of PHBPOL field.
	FTM_QDCTRL_PHBPOL_Pos = 0x4
	// Bit mask of PHBPOL field.
	FTM_QDCTRL_PHBPOL_Msk = 0x10
	// Bit PHBPOL.
	FTM_QDCTRL_PHBPOL = 0x10
	// Normal polarity. Phase B input signal is not inverted before identifying the rising and falling edges of this signal.
	FTM_QDCTRL_PHBPOL_0 = 0x0
	// Inverted polarity. Phase B input signal is inverted before identifying the rising and falling edges of this signal.
	FTM_QDCTRL_PHBPOL_1 = 0x1
	// Position of PHAPOL field.
	FTM_QDCTRL_PHAPOL_Pos = 0x5
	// Bit mask of PHAPOL field.
	FTM_QDCTRL_PHAPOL_Msk = 0x20
	// Bit PHAPOL.
	FTM_QDCTRL_PHAPOL = 0x20
	// Normal polarity. Phase A input signal is not inverted before identifying the rising and falling edges of this signal.
	FTM_QDCTRL_PHAPOL_0 = 0x0
	// Inverted polarity. Phase A input signal is inverted before identifying the rising and falling edges of this signal.
	FTM_QDCTRL_PHAPOL_1 = 0x1
	// Position of PHBFLTREN field.
	FTM_QDCTRL_PHBFLTREN_Pos = 0x6
	// Bit mask of PHBFLTREN field.
	FTM_QDCTRL_PHBFLTREN_Msk = 0x40
	// Bit PHBFLTREN.
	FTM_QDCTRL_PHBFLTREN = 0x40
	// Phase B input filter is disabled.
	FTM_QDCTRL_PHBFLTREN_0 = 0x0
	// Phase B input filter is enabled.
	FTM_QDCTRL_PHBFLTREN_1 = 0x1
	// Position of PHAFLTREN field.
	FTM_QDCTRL_PHAFLTREN_Pos = 0x7
	// Bit mask of PHAFLTREN field.
	FTM_QDCTRL_PHAFLTREN_Msk = 0x80
	// Bit PHAFLTREN.
	FTM_QDCTRL_PHAFLTREN = 0x80
	// Phase A input filter is disabled.
	FTM_QDCTRL_PHAFLTREN_0 = 0x0
	// Phase A input filter is enabled.
	FTM_QDCTRL_PHAFLTREN_1 = 0x1

	// CONF: Configuration
	// Position of NUMTOF field.
	FTM_CONF_NUMTOF_Pos = 0x0
	// Bit mask of NUMTOF field.
	FTM_CONF_NUMTOF_Msk = 0x1f
	// Position of BDMMODE field.
	FTM_CONF_BDMMODE_Pos = 0x6
	// Bit mask of BDMMODE field.
	FTM_CONF_BDMMODE_Msk = 0xc0
	// Position of GTBEEN field.
	FTM_CONF_GTBEEN_Pos = 0x9
	// Bit mask of GTBEEN field.
	FTM_CONF_GTBEEN_Msk = 0x200
	// Bit GTBEEN.
	FTM_CONF_GTBEEN = 0x200
	// Use of an external global time base is disabled.
	FTM_CONF_GTBEEN_0 = 0x0
	// Use of an external global time base is enabled.
	FTM_CONF_GTBEEN_1 = 0x1
	// Position of GTBEOUT field.
	FTM_CONF_GTBEOUT_Pos = 0xa
	// Bit mask of GTBEOUT field.
	FTM_CONF_GTBEOUT_Msk = 0x400
	// Bit GTBEOUT.
	FTM_CONF_GTBEOUT = 0x400
	// A global time base signal generation is disabled.
	FTM_CONF_GTBEOUT_0 = 0x0
	// A global time base signal generation is enabled.
	FTM_CONF_GTBEOUT_1 = 0x1

	// FLTPOL: FTM Fault Input Polarity
	// Position of FLT0POL field.
	FTM_FLTPOL_FLT0POL_Pos = 0x0
	// Bit mask of FLT0POL field.
	FTM_FLTPOL_FLT0POL_Msk = 0x1
	// Bit FLT0POL.
	FTM_FLTPOL_FLT0POL = 0x1
	// The fault input polarity is active high. A 1 at the fault input indicates a fault.
	FTM_FLTPOL_FLT0POL_0 = 0x0
	// The fault input polarity is active low. A 0 at the fault input indicates a fault.
	FTM_FLTPOL_FLT0POL_1 = 0x1
	// Position of FLT1POL field.
	FTM_FLTPOL_FLT1POL_Pos = 0x1
	// Bit mask of FLT1POL field.
	FTM_FLTPOL_FLT1POL_Msk = 0x2
	// Bit FLT1POL.
	FTM_FLTPOL_FLT1POL = 0x2
	// The fault input polarity is active high. A 1 at the fault input indicates a fault.
	FTM_FLTPOL_FLT1POL_0 = 0x0
	// The fault input polarity is active low. A 0 at the fault input indicates a fault.
	FTM_FLTPOL_FLT1POL_1 = 0x1
	// Position of FLT2POL field.
	FTM_FLTPOL_FLT2POL_Pos = 0x2
	// Bit mask of FLT2POL field.
	FTM_FLTPOL_FLT2POL_Msk = 0x4
	// Bit FLT2POL.
	FTM_FLTPOL_FLT2POL = 0x4
	// The fault input polarity is active high. A 1 at the fault input indicates a fault.
	FTM_FLTPOL_FLT2POL_0 = 0x0
	// The fault input polarity is active low. A 0 at the fault input indicates a fault.
	FTM_FLTPOL_FLT2POL_1 = 0x1
	// Position of FLT3POL field.
	FTM_FLTPOL_FLT3POL_Pos = 0x3
	// Bit mask of FLT3POL field.
	FTM_FLTPOL_FLT3POL_Msk = 0x8
	// Bit FLT3POL.
	FTM_FLTPOL_FLT3POL = 0x8
	// The fault input polarity is active high. A 1 at the fault input indicates a fault.
	FTM_FLTPOL_FLT3POL_0 = 0x0
	// The fault input polarity is active low. A 0 at the fault input indicates a fault.
	FTM_FLTPOL_FLT3POL_1 = 0x1

	// SYNCONF: Synchronization Configuration
	// Position of HWTRIGMODE field.
	FTM_SYNCONF_HWTRIGMODE_Pos = 0x0
	// Bit mask of HWTRIGMODE field.
	FTM_SYNCONF_HWTRIGMODE_Msk = 0x1
	// Bit HWTRIGMODE.
	FTM_SYNCONF_HWTRIGMODE = 0x1
	// FTM clears the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
	FTM_SYNCONF_HWTRIGMODE_0 = 0x0
	// FTM does not clear the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
	FTM_SYNCONF_HWTRIGMODE_1 = 0x1
	// Position of CNTINC field.
	FTM_SYNCONF_CNTINC_Pos = 0x2
	// Bit mask of CNTINC field.
	FTM_SYNCONF_CNTINC_Msk = 0x4
	// Bit CNTINC.
	FTM_SYNCONF_CNTINC = 0x4
	// CNTIN register is updated with its buffer value at all rising edges of system clock.
	FTM_SYNCONF_CNTINC_0 = 0x0
	// CNTIN register is updated with its buffer value by the PWM synchronization.
	FTM_SYNCONF_CNTINC_1 = 0x1
	// Position of INVC field.
	FTM_SYNCONF_INVC_Pos = 0x4
	// Bit mask of INVC field.
	FTM_SYNCONF_INVC_Msk = 0x10
	// Bit INVC.
	FTM_SYNCONF_INVC = 0x10
	// INVCTRL register is updated with its buffer value at all rising edges of system clock.
	FTM_SYNCONF_INVC_0 = 0x0
	// INVCTRL register is updated with its buffer value by the PWM synchronization.
	FTM_SYNCONF_INVC_1 = 0x1
	// Position of SWOC field.
	FTM_SYNCONF_SWOC_Pos = 0x5
	// Bit mask of SWOC field.
	FTM_SYNCONF_SWOC_Msk = 0x20
	// Bit SWOC.
	FTM_SYNCONF_SWOC = 0x20
	// SWOCTRL register is updated with its buffer value at all rising edges of system clock.
	FTM_SYNCONF_SWOC_0 = 0x0
	// SWOCTRL register is updated with its buffer value by the PWM synchronization.
	FTM_SYNCONF_SWOC_1 = 0x1
	// Position of SYNCMODE field.
	FTM_SYNCONF_SYNCMODE_Pos = 0x7
	// Bit mask of SYNCMODE field.
	FTM_SYNCONF_SYNCMODE_Msk = 0x80
	// Bit SYNCMODE.
	FTM_SYNCONF_SYNCMODE = 0x80
	// Legacy PWM synchronization is selected.
	FTM_SYNCONF_SYNCMODE_0 = 0x0
	// Enhanced PWM synchronization is selected.
	FTM_SYNCONF_SYNCMODE_1 = 0x1
	// Position of SWRSTCNT field.
	FTM_SYNCONF_SWRSTCNT_Pos = 0x8
	// Bit mask of SWRSTCNT field.
	FTM_SYNCONF_SWRSTCNT_Msk = 0x100
	// Bit SWRSTCNT.
	FTM_SYNCONF_SWRSTCNT = 0x100
	// The software trigger does not activate the FTM counter synchronization.
	FTM_SYNCONF_SWRSTCNT_0 = 0x0
	// The software trigger activates the FTM counter synchronization.
	FTM_SYNCONF_SWRSTCNT_1 = 0x1
	// Position of SWWRBUF field.
	FTM_SYNCONF_SWWRBUF_Pos = 0x9
	// Bit mask of SWWRBUF field.
	FTM_SYNCONF_SWWRBUF_Msk = 0x200
	// Bit SWWRBUF.
	FTM_SYNCONF_SWWRBUF = 0x200
	// The software trigger does not activate MOD, CNTIN, and CV registers synchronization.
	FTM_SYNCONF_SWWRBUF_0 = 0x0
	// The software trigger activates MOD, CNTIN, and CV registers synchronization.
	FTM_SYNCONF_SWWRBUF_1 = 0x1
	// Position of SWOM field.
	FTM_SYNCONF_SWOM_Pos = 0xa
	// Bit mask of SWOM field.
	FTM_SYNCONF_SWOM_Msk = 0x400
	// Bit SWOM.
	FTM_SYNCONF_SWOM = 0x400
	// The software trigger does not activate the OUTMASK register synchronization.
	FTM_SYNCONF_SWOM_0 = 0x0
	// The software trigger activates the OUTMASK register synchronization.
	FTM_SYNCONF_SWOM_1 = 0x1
	// Position of SWINVC field.
	FTM_SYNCONF_SWINVC_Pos = 0xb
	// Bit mask of SWINVC field.
	FTM_SYNCONF_SWINVC_Msk = 0x800
	// Bit SWINVC.
	FTM_SYNCONF_SWINVC = 0x800
	// The software trigger does not activate the INVCTRL register synchronization.
	FTM_SYNCONF_SWINVC_0 = 0x0
	// The software trigger activates the INVCTRL register synchronization.
	FTM_SYNCONF_SWINVC_1 = 0x1
	// Position of SWSOC field.
	FTM_SYNCONF_SWSOC_Pos = 0xc
	// Bit mask of SWSOC field.
	FTM_SYNCONF_SWSOC_Msk = 0x1000
	// Bit SWSOC.
	FTM_SYNCONF_SWSOC = 0x1000
	// The software trigger does not activate the SWOCTRL register synchronization.
	FTM_SYNCONF_SWSOC_0 = 0x0
	// The software trigger activates the SWOCTRL register synchronization.
	FTM_SYNCONF_SWSOC_1 = 0x1
	// Position of HWRSTCNT field.
	FTM_SYNCONF_HWRSTCNT_Pos = 0x10
	// Bit mask of HWRSTCNT field.
	FTM_SYNCONF_HWRSTCNT_Msk = 0x10000
	// Bit HWRSTCNT.
	FTM_SYNCONF_HWRSTCNT = 0x10000
	// A hardware trigger does not activate the FTM counter synchronization.
	FTM_SYNCONF_HWRSTCNT_0 = 0x0
	// A hardware trigger activates the FTM counter synchronization.
	FTM_SYNCONF_HWRSTCNT_1 = 0x1
	// Position of HWWRBUF field.
	FTM_SYNCONF_HWWRBUF_Pos = 0x11
	// Bit mask of HWWRBUF field.
	FTM_SYNCONF_HWWRBUF_Msk = 0x20000
	// Bit HWWRBUF.
	FTM_SYNCONF_HWWRBUF = 0x20000
	// A hardware trigger does not activate MOD, CNTIN, and CV registers synchronization.
	FTM_SYNCONF_HWWRBUF_0 = 0x0
	// A hardware trigger activates MOD, CNTIN, and CV registers synchronization.
	FTM_SYNCONF_HWWRBUF_1 = 0x1
	// Position of HWOM field.
	FTM_SYNCONF_HWOM_Pos = 0x12
	// Bit mask of HWOM field.
	FTM_SYNCONF_HWOM_Msk = 0x40000
	// Bit HWOM.
	FTM_SYNCONF_HWOM = 0x40000
	// A hardware trigger does not activate the OUTMASK register synchronization.
	FTM_SYNCONF_HWOM_0 = 0x0
	// A hardware trigger activates the OUTMASK register synchronization.
	FTM_SYNCONF_HWOM_1 = 0x1
	// Position of HWINVC field.
	FTM_SYNCONF_HWINVC_Pos = 0x13
	// Bit mask of HWINVC field.
	FTM_SYNCONF_HWINVC_Msk = 0x80000
	// Bit HWINVC.
	FTM_SYNCONF_HWINVC = 0x80000
	// A hardware trigger does not activate the INVCTRL register synchronization.
	FTM_SYNCONF_HWINVC_0 = 0x0
	// A hardware trigger activates the INVCTRL register synchronization.
	FTM_SYNCONF_HWINVC_1 = 0x1
	// Position of HWSOC field.
	FTM_SYNCONF_HWSOC_Pos = 0x14
	// Bit mask of HWSOC field.
	FTM_SYNCONF_HWSOC_Msk = 0x100000
	// Bit HWSOC.
	FTM_SYNCONF_HWSOC = 0x100000
	// A hardware trigger does not activate the SWOCTRL register synchronization.
	FTM_SYNCONF_HWSOC_0 = 0x0
	// A hardware trigger activates the SWOCTRL register synchronization.
	FTM_SYNCONF_HWSOC_1 = 0x1

	// INVCTRL: FTM Inverting Control
	// Position of INV0EN field.
	FTM_INVCTRL_INV0EN_Pos = 0x0
	// Bit mask of INV0EN field.
	FTM_INVCTRL_INV0EN_Msk = 0x1
	// Bit INV0EN.
	FTM_INVCTRL_INV0EN = 0x1
	// Inverting is disabled.
	FTM_INVCTRL_INV0EN_0 = 0x0
	// Inverting is enabled.
	FTM_INVCTRL_INV0EN_1 = 0x1
	// Position of INV1EN field.
	FTM_INVCTRL_INV1EN_Pos = 0x1
	// Bit mask of INV1EN field.
	FTM_INVCTRL_INV1EN_Msk = 0x2
	// Bit INV1EN.
	FTM_INVCTRL_INV1EN = 0x2
	// Inverting is disabled.
	FTM_INVCTRL_INV1EN_0 = 0x0
	// Inverting is enabled.
	FTM_INVCTRL_INV1EN_1 = 0x1
	// Position of INV2EN field.
	FTM_INVCTRL_INV2EN_Pos = 0x2
	// Bit mask of INV2EN field.
	FTM_INVCTRL_INV2EN_Msk = 0x4
	// Bit INV2EN.
	FTM_INVCTRL_INV2EN = 0x4
	// Inverting is disabled.
	FTM_INVCTRL_INV2EN_0 = 0x0
	// Inverting is enabled.
	FTM_INVCTRL_INV2EN_1 = 0x1
	// Position of INV3EN field.
	FTM_INVCTRL_INV3EN_Pos = 0x3
	// Bit mask of INV3EN field.
	FTM_INVCTRL_INV3EN_Msk = 0x8
	// Bit INV3EN.
	FTM_INVCTRL_INV3EN = 0x8
	// Inverting is disabled.
	FTM_INVCTRL_INV3EN_0 = 0x0
	// Inverting is enabled.
	FTM_INVCTRL_INV3EN_1 = 0x1

	// SWOCTRL: FTM Software Output Control
	// Position of CH0OC field.
	FTM_SWOCTRL_CH0OC_Pos = 0x0
	// Bit mask of CH0OC field.
	FTM_SWOCTRL_CH0OC_Msk = 0x1
	// Bit CH0OC.
	FTM_SWOCTRL_CH0OC = 0x1
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH0OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH0OC_1 = 0x1
	// Position of CH1OC field.
	FTM_SWOCTRL_CH1OC_Pos = 0x1
	// Bit mask of CH1OC field.
	FTM_SWOCTRL_CH1OC_Msk = 0x2
	// Bit CH1OC.
	FTM_SWOCTRL_CH1OC = 0x2
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH1OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH1OC_1 = 0x1
	// Position of CH2OC field.
	FTM_SWOCTRL_CH2OC_Pos = 0x2
	// Bit mask of CH2OC field.
	FTM_SWOCTRL_CH2OC_Msk = 0x4
	// Bit CH2OC.
	FTM_SWOCTRL_CH2OC = 0x4
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH2OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH2OC_1 = 0x1
	// Position of CH3OC field.
	FTM_SWOCTRL_CH3OC_Pos = 0x3
	// Bit mask of CH3OC field.
	FTM_SWOCTRL_CH3OC_Msk = 0x8
	// Bit CH3OC.
	FTM_SWOCTRL_CH3OC = 0x8
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH3OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH3OC_1 = 0x1
	// Position of CH4OC field.
	FTM_SWOCTRL_CH4OC_Pos = 0x4
	// Bit mask of CH4OC field.
	FTM_SWOCTRL_CH4OC_Msk = 0x10
	// Bit CH4OC.
	FTM_SWOCTRL_CH4OC = 0x10
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH4OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH4OC_1 = 0x1
	// Position of CH5OC field.
	FTM_SWOCTRL_CH5OC_Pos = 0x5
	// Bit mask of CH5OC field.
	FTM_SWOCTRL_CH5OC_Msk = 0x20
	// Bit CH5OC.
	FTM_SWOCTRL_CH5OC = 0x20
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH5OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH5OC_1 = 0x1
	// Position of CH6OC field.
	FTM_SWOCTRL_CH6OC_Pos = 0x6
	// Bit mask of CH6OC field.
	FTM_SWOCTRL_CH6OC_Msk = 0x40
	// Bit CH6OC.
	FTM_SWOCTRL_CH6OC = 0x40
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH6OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH6OC_1 = 0x1
	// Position of CH7OC field.
	FTM_SWOCTRL_CH7OC_Pos = 0x7
	// Bit mask of CH7OC field.
	FTM_SWOCTRL_CH7OC_Msk = 0x80
	// Bit CH7OC.
	FTM_SWOCTRL_CH7OC = 0x80
	// The channel output is not affected by software output control.
	FTM_SWOCTRL_CH7OC_0 = 0x0
	// The channel output is affected by software output control.
	FTM_SWOCTRL_CH7OC_1 = 0x1
	// Position of CH0OCV field.
	FTM_SWOCTRL_CH0OCV_Pos = 0x8
	// Bit mask of CH0OCV field.
	FTM_SWOCTRL_CH0OCV_Msk = 0x100
	// Bit CH0OCV.
	FTM_SWOCTRL_CH0OCV = 0x100
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH0OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH0OCV_1 = 0x1
	// Position of CH1OCV field.
	FTM_SWOCTRL_CH1OCV_Pos = 0x9
	// Bit mask of CH1OCV field.
	FTM_SWOCTRL_CH1OCV_Msk = 0x200
	// Bit CH1OCV.
	FTM_SWOCTRL_CH1OCV = 0x200
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH1OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH1OCV_1 = 0x1
	// Position of CH2OCV field.
	FTM_SWOCTRL_CH2OCV_Pos = 0xa
	// Bit mask of CH2OCV field.
	FTM_SWOCTRL_CH2OCV_Msk = 0x400
	// Bit CH2OCV.
	FTM_SWOCTRL_CH2OCV = 0x400
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH2OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH2OCV_1 = 0x1
	// Position of CH3OCV field.
	FTM_SWOCTRL_CH3OCV_Pos = 0xb
	// Bit mask of CH3OCV field.
	FTM_SWOCTRL_CH3OCV_Msk = 0x800
	// Bit CH3OCV.
	FTM_SWOCTRL_CH3OCV = 0x800
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH3OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH3OCV_1 = 0x1
	// Position of CH4OCV field.
	FTM_SWOCTRL_CH4OCV_Pos = 0xc
	// Bit mask of CH4OCV field.
	FTM_SWOCTRL_CH4OCV_Msk = 0x1000
	// Bit CH4OCV.
	FTM_SWOCTRL_CH4OCV = 0x1000
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH4OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH4OCV_1 = 0x1
	// Position of CH5OCV field.
	FTM_SWOCTRL_CH5OCV_Pos = 0xd
	// Bit mask of CH5OCV field.
	FTM_SWOCTRL_CH5OCV_Msk = 0x2000
	// Bit CH5OCV.
	FTM_SWOCTRL_CH5OCV = 0x2000
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH5OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH5OCV_1 = 0x1
	// Position of CH6OCV field.
	FTM_SWOCTRL_CH6OCV_Pos = 0xe
	// Bit mask of CH6OCV field.
	FTM_SWOCTRL_CH6OCV_Msk = 0x4000
	// Bit CH6OCV.
	FTM_SWOCTRL_CH6OCV = 0x4000
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH6OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH6OCV_1 = 0x1
	// Position of CH7OCV field.
	FTM_SWOCTRL_CH7OCV_Pos = 0xf
	// Bit mask of CH7OCV field.
	FTM_SWOCTRL_CH7OCV_Msk = 0x8000
	// Bit CH7OCV.
	FTM_SWOCTRL_CH7OCV = 0x8000
	// The software output control forces 0 to the channel output.
	FTM_SWOCTRL_CH7OCV_0 = 0x0
	// The software output control forces 1 to the channel output.
	FTM_SWOCTRL_CH7OCV_1 = 0x1

	// PWMLOAD: FTM PWM Load
	// Position of CH0SEL field.
	FTM_PWMLOAD_CH0SEL_Pos = 0x0
	// Bit mask of CH0SEL field.
	FTM_PWMLOAD_CH0SEL_Msk = 0x1
	// Bit CH0SEL.
	FTM_PWMLOAD_CH0SEL = 0x1
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH0SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH0SEL_1 = 0x1
	// Position of CH1SEL field.
	FTM_PWMLOAD_CH1SEL_Pos = 0x1
	// Bit mask of CH1SEL field.
	FTM_PWMLOAD_CH1SEL_Msk = 0x2
	// Bit CH1SEL.
	FTM_PWMLOAD_CH1SEL = 0x2
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH1SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH1SEL_1 = 0x1
	// Position of CH2SEL field.
	FTM_PWMLOAD_CH2SEL_Pos = 0x2
	// Bit mask of CH2SEL field.
	FTM_PWMLOAD_CH2SEL_Msk = 0x4
	// Bit CH2SEL.
	FTM_PWMLOAD_CH2SEL = 0x4
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH2SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH2SEL_1 = 0x1
	// Position of CH3SEL field.
	FTM_PWMLOAD_CH3SEL_Pos = 0x3
	// Bit mask of CH3SEL field.
	FTM_PWMLOAD_CH3SEL_Msk = 0x8
	// Bit CH3SEL.
	FTM_PWMLOAD_CH3SEL = 0x8
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH3SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH3SEL_1 = 0x1
	// Position of CH4SEL field.
	FTM_PWMLOAD_CH4SEL_Pos = 0x4
	// Bit mask of CH4SEL field.
	FTM_PWMLOAD_CH4SEL_Msk = 0x10
	// Bit CH4SEL.
	FTM_PWMLOAD_CH4SEL = 0x10
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH4SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH4SEL_1 = 0x1
	// Position of CH5SEL field.
	FTM_PWMLOAD_CH5SEL_Pos = 0x5
	// Bit mask of CH5SEL field.
	FTM_PWMLOAD_CH5SEL_Msk = 0x20
	// Bit CH5SEL.
	FTM_PWMLOAD_CH5SEL = 0x20
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH5SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH5SEL_1 = 0x1
	// Position of CH6SEL field.
	FTM_PWMLOAD_CH6SEL_Pos = 0x6
	// Bit mask of CH6SEL field.
	FTM_PWMLOAD_CH6SEL_Msk = 0x40
	// Bit CH6SEL.
	FTM_PWMLOAD_CH6SEL = 0x40
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH6SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH6SEL_1 = 0x1
	// Position of CH7SEL field.
	FTM_PWMLOAD_CH7SEL_Pos = 0x7
	// Bit mask of CH7SEL field.
	FTM_PWMLOAD_CH7SEL_Msk = 0x80
	// Bit CH7SEL.
	FTM_PWMLOAD_CH7SEL = 0x80
	// Do not include the channel in the matching process.
	FTM_PWMLOAD_CH7SEL_0 = 0x0
	// Include the channel in the matching process.
	FTM_PWMLOAD_CH7SEL_1 = 0x1
	// Position of LDOK field.
	FTM_PWMLOAD_LDOK_Pos = 0x9
	// Bit mask of LDOK field.
	FTM_PWMLOAD_LDOK_Msk = 0x200
	// Bit LDOK.
	FTM_PWMLOAD_LDOK = 0x200
	// Loading updated values is disabled.
	FTM_PWMLOAD_LDOK_0 = 0x0
	// Loading updated values is enabled.
	FTM_PWMLOAD_LDOK_1 = 0x1
)

// Constants for ADC0: Analog-to-Digital Converter
const (
	// SC1A: ADC Status and Control Registers 1
	// Position of ADCH field.
	ADC_SC1_ADCH_Pos = 0x0
	// Bit mask of ADCH field.
	ADC_SC1_ADCH_Msk = 0x1f
	// When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input.
	ADC_SC1_ADCH_00000 = 0x0
	// When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input.
	ADC_SC1_ADCH_00001 = 0x1
	// When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input.
	ADC_SC1_ADCH_00010 = 0x2
	// When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input.
	ADC_SC1_ADCH_00011 = 0x3
	// When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_00100 = 0x4
	// When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_00101 = 0x5
	// When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_00110 = 0x6
	// When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_00111 = 0x7
	// When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01000 = 0x8
	// When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01001 = 0x9
	// When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01010 = 0xa
	// When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01011 = 0xb
	// When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01100 = 0xc
	// When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01101 = 0xd
	// When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01110 = 0xe
	// When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_01111 = 0xf
	// When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10000 = 0x10
	// When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10001 = 0x11
	// When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10010 = 0x12
	// When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10011 = 0x13
	// When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10100 = 0x14
	// When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10101 = 0x15
	// When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10110 = 0x16
	// When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
	ADC_SC1_ADCH_10111 = 0x17
	// When DIFF=0, Temp Sensor (single-ended) is selected as input; when DIFF=1, Temp Sensor (differential) is selected as input.
	ADC_SC1_ADCH_11010 = 0x1a
	// When DIFF=0, Bandgap (single-ended) is selected as input; when DIFF=1, Bandgap (differential) is selected as input.
	ADC_SC1_ADCH_11011 = 0x1b
	// When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected as input. Voltage reference selected is determined by SC2[REFSEL].
	ADC_SC1_ADCH_11101 = 0x1d
	// When DIFF=0,VREFSL is selected as input; when DIFF=1, it is reserved. Voltage reference selected is determined by SC2[REFSEL].
	ADC_SC1_ADCH_11110 = 0x1e
	// Module is disabled.
	ADC_SC1_ADCH_11111 = 0x1f
	// Position of DIFF field.
	ADC_SC1_DIFF_Pos = 0x5
	// Bit mask of DIFF field.
	ADC_SC1_DIFF_Msk = 0x20
	// Bit DIFF.
	ADC_SC1_DIFF = 0x20
	// Single-ended conversions and input channels are selected.
	ADC_SC1_DIFF_0 = 0x0
	// Differential conversions and input channels are selected.
	ADC_SC1_DIFF_1 = 0x1
	// Position of AIEN field.
	ADC_SC1_AIEN_Pos = 0x6
	// Bit mask of AIEN field.
	ADC_SC1_AIEN_Msk = 0x40
	// Bit AIEN.
	ADC_SC1_AIEN = 0x40
	// Conversion complete interrupt is disabled.
	ADC_SC1_AIEN_0 = 0x0
	// Conversion complete interrupt is enabled.
	ADC_SC1_AIEN_1 = 0x1
	// Position of COCO field.
	ADC_SC1_COCO_Pos = 0x7
	// Bit mask of COCO field.
	ADC_SC1_COCO_Msk = 0x80
	// Bit COCO.
	ADC_SC1_COCO = 0x80
	// Conversion is not completed.
	ADC_SC1_COCO_0 = 0x0
	// Conversion is completed.
	ADC_SC1_COCO_1 = 0x1

	// CFG1: ADC Configuration Register 1
	// Position of ADICLK field.
	ADC_CFG1_ADICLK_Pos = 0x0
	// Bit mask of ADICLK field.
	ADC_CFG1_ADICLK_Msk = 0x3
	// Bus clock
	ADC_CFG1_ADICLK_00 = 0x0
	// Bus clock divided by 2(BUSCLK/2)
	ADC_CFG1_ADICLK_01 = 0x1
	// Alternate clock (ALTCLK)
	ADC_CFG1_ADICLK_10 = 0x2
	// Asynchronous clock (ADACK)
	ADC_CFG1_ADICLK_11 = 0x3
	// Position of MODE field.
	ADC_CFG1_MODE_Pos = 0x2
	// Bit mask of MODE field.
	ADC_CFG1_MODE_Msk = 0xc
	// When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is differential 9-bit conversion with 2's complement output.
	ADC_CFG1_MODE_00 = 0x0
	// When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is differential 13-bit conversion with 2's complement output.
	ADC_CFG1_MODE_01 = 0x1
	// When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it is differential 11-bit conversion with 2's complement output
	ADC_CFG1_MODE_10 = 0x2
	// When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it is differential 16-bit conversion with 2's complement output
	ADC_CFG1_MODE_11 = 0x3
	// Position of ADLSMP field.
	ADC_CFG1_ADLSMP_Pos = 0x4
	// Bit mask of ADLSMP field.
	ADC_CFG1_ADLSMP_Msk = 0x10
	// Bit ADLSMP.
	ADC_CFG1_ADLSMP = 0x10
	// Short sample time.
	ADC_CFG1_ADLSMP_0 = 0x0
	// Long sample time.
	ADC_CFG1_ADLSMP_1 = 0x1
	// Position of ADIV field.
	ADC_CFG1_ADIV_Pos = 0x5
	// Bit mask of ADIV field.
	ADC_CFG1_ADIV_Msk = 0x60
	// The divide ratio is 1 and the clock rate is input clock.
	ADC_CFG1_ADIV_00 = 0x0
	// The divide ratio is 2 and the clock rate is (input clock)/2.
	ADC_CFG1_ADIV_01 = 0x1
	// The divide ratio is 4 and the clock rate is (input clock)/4.
	ADC_CFG1_ADIV_10 = 0x2
	// The divide ratio is 8 and the clock rate is (input clock)/8.
	ADC_CFG1_ADIV_11 = 0x3
	// Position of ADLPC field.
	ADC_CFG1_ADLPC_Pos = 0x7
	// Bit mask of ADLPC field.
	ADC_CFG1_ADLPC_Msk = 0x80
	// Bit ADLPC.
	ADC_CFG1_ADLPC = 0x80
	// Normal power configuration.
	ADC_CFG1_ADLPC_0 = 0x0
	// Low-power configuration. The power is reduced at the expense of maximum clock speed.
	ADC_CFG1_ADLPC_1 = 0x1

	// CFG2: ADC Configuration Register 2
	// Position of ADLSTS field.
	ADC_CFG2_ADLSTS_Pos = 0x0
	// Bit mask of ADLSTS field.
	ADC_CFG2_ADLSTS_Msk = 0x3
	// Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles total.
	ADC_CFG2_ADLSTS_00 = 0x0
	// 12 extra ADCK cycles; 16 ADCK cycles total sample time.
	ADC_CFG2_ADLSTS_01 = 0x1
	// 6 extra ADCK cycles; 10 ADCK cycles total sample time.
	ADC_CFG2_ADLSTS_10 = 0x2
	// 2 extra ADCK cycles; 6 ADCK cycles total sample time.
	ADC_CFG2_ADLSTS_11 = 0x3
	// Position of ADHSC field.
	ADC_CFG2_ADHSC_Pos = 0x2
	// Bit mask of ADHSC field.
	ADC_CFG2_ADHSC_Msk = 0x4
	// Bit ADHSC.
	ADC_CFG2_ADHSC = 0x4
	// Normal conversion sequence selected.
	ADC_CFG2_ADHSC_0 = 0x0
	// High-speed conversion sequence selected with 2 additional ADCK cycles to total conversion time.
	ADC_CFG2_ADHSC_1 = 0x1
	// Position of ADACKEN field.
	ADC_CFG2_ADACKEN_Pos = 0x3
	// Bit mask of ADACKEN field.
	ADC_CFG2_ADACKEN_Msk = 0x8
	// Bit ADACKEN.
	ADC_CFG2_ADACKEN = 0x8
	// Asynchronous clock output disabled; Asynchronous clock is enabled only if selected by ADICLK and a conversion is active.
	ADC_CFG2_ADACKEN_0 = 0x0
	// Asynchronous clock and clock output is enabled regardless of the state of the ADC.
	ADC_CFG2_ADACKEN_1 = 0x1
	// Position of MUXSEL field.
	ADC_CFG2_MUXSEL_Pos = 0x4
	// Bit mask of MUXSEL field.
	ADC_CFG2_MUXSEL_Msk = 0x10
	// Bit MUXSEL.
	ADC_CFG2_MUXSEL = 0x10
	// ADxxa channels are selected.
	ADC_CFG2_MUXSEL_0 = 0x0
	// ADxxb channels are selected.
	ADC_CFG2_MUXSEL_1 = 0x1

	// RA: ADC Data Result Register
	// Position of D field.
	ADC_R_D_Pos = 0x0
	// Bit mask of D field.
	ADC_R_D_Msk = 0xffff

	// CV1: Compare Value Registers
	// Position of CV field.
	ADC_CV_CV_Pos = 0x0
	// Bit mask of CV field.
	ADC_CV_CV_Msk = 0xffff

	// SC2: Status and Control Register 2
	// Position of REFSEL field.
	ADC_SC2_REFSEL_Pos = 0x0
	// Bit mask of REFSEL field.
	ADC_SC2_REFSEL_Msk = 0x3
	// Default voltage reference pin pair, that is, external pins VREFH and VREFL
	ADC_SC2_REFSEL_00 = 0x0
	// Alternate reference pair, that is, VALTH and VALTL . This pair may be additional external pins or internal sources depending on the MCU configuration. See the chip configuration information for details specific to this MCU
	ADC_SC2_REFSEL_01 = 0x1
	// Position of DMAEN field.
	ADC_SC2_DMAEN_Pos = 0x2
	// Bit mask of DMAEN field.
	ADC_SC2_DMAEN_Msk = 0x4
	// Bit DMAEN.
	ADC_SC2_DMAEN = 0x4
	// DMA is disabled.
	ADC_SC2_DMAEN_0 = 0x0
	// DMA is enabled and will assert the ADC DMA request during an ADC conversion complete event noted when any of the SC1n[COCO] flags is asserted.
	ADC_SC2_DMAEN_1 = 0x1
	// Position of ACREN field.
	ADC_SC2_ACREN_Pos = 0x3
	// Bit mask of ACREN field.
	ADC_SC2_ACREN_Msk = 0x8
	// Bit ACREN.
	ADC_SC2_ACREN = 0x8
	// Range function disabled. Only CV1 is compared.
	ADC_SC2_ACREN_0 = 0x0
	// Range function enabled. Both CV1 and CV2 are compared.
	ADC_SC2_ACREN_1 = 0x1
	// Position of ACFGT field.
	ADC_SC2_ACFGT_Pos = 0x4
	// Bit mask of ACFGT field.
	ADC_SC2_ACFGT_Msk = 0x10
	// Bit ACFGT.
	ADC_SC2_ACFGT = 0x10
	// Configures less than threshold, outside range not inclusive and inside range not inclusive; functionality based on the values placed in CV1 and CV2.
	ADC_SC2_ACFGT_0 = 0x0
	// Configures greater than or equal to threshold, outside and inside ranges inclusive; functionality based on the values placed in CV1 and CV2.
	ADC_SC2_ACFGT_1 = 0x1
	// Position of ACFE field.
	ADC_SC2_ACFE_Pos = 0x5
	// Bit mask of ACFE field.
	ADC_SC2_ACFE_Msk = 0x20
	// Bit ACFE.
	ADC_SC2_ACFE = 0x20
	// Compare function disabled.
	ADC_SC2_ACFE_0 = 0x0
	// Compare function enabled.
	ADC_SC2_ACFE_1 = 0x1
	// Position of ADTRG field.
	ADC_SC2_ADTRG_Pos = 0x6
	// Bit mask of ADTRG field.
	ADC_SC2_ADTRG_Msk = 0x40
	// Bit ADTRG.
	ADC_SC2_ADTRG = 0x40
	// Software trigger selected.
	ADC_SC2_ADTRG_0 = 0x0
	// Hardware trigger selected.
	ADC_SC2_ADTRG_1 = 0x1
	// Position of ADACT field.
	ADC_SC2_ADACT_Pos = 0x7
	// Bit mask of ADACT field.
	ADC_SC2_ADACT_Msk = 0x80
	// Bit ADACT.
	ADC_SC2_ADACT = 0x80
	// Conversion not in progress.
	ADC_SC2_ADACT_0 = 0x0
	// Conversion in progress.
	ADC_SC2_ADACT_1 = 0x1

	// SC3: Status and Control Register 3
	// Position of AVGS field.
	ADC_SC3_AVGS_Pos = 0x0
	// Bit mask of AVGS field.
	ADC_SC3_AVGS_Msk = 0x3
	// 4 samples averaged.
	ADC_SC3_AVGS_00 = 0x0
	// 8 samples averaged.
	ADC_SC3_AVGS_01 = 0x1
	// 16 samples averaged.
	ADC_SC3_AVGS_10 = 0x2
	// 32 samples averaged.
	ADC_SC3_AVGS_11 = 0x3
	// Position of AVGE field.
	ADC_SC3_AVGE_Pos = 0x2
	// Bit mask of AVGE field.
	ADC_SC3_AVGE_Msk = 0x4
	// Bit AVGE.
	ADC_SC3_AVGE = 0x4
	// Hardware average function disabled.
	ADC_SC3_AVGE_0 = 0x0
	// Hardware average function enabled.
	ADC_SC3_AVGE_1 = 0x1
	// Position of ADCO field.
	ADC_SC3_ADCO_Pos = 0x3
	// Bit mask of ADCO field.
	ADC_SC3_ADCO_Msk = 0x8
	// Bit ADCO.
	ADC_SC3_ADCO = 0x8
	// One conversion or one set of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
	ADC_SC3_ADCO_0 = 0x0
	// Continuous conversions or sets of conversions if the hardware average function is enabled, that is, AVGE=1, after initiating a conversion.
	ADC_SC3_ADCO_1 = 0x1
	// Position of CALF field.
	ADC_SC3_CALF_Pos = 0x6
	// Bit mask of CALF field.
	ADC_SC3_CALF_Msk = 0x40
	// Bit CALF.
	ADC_SC3_CALF = 0x40
	// Calibration completed normally.
	ADC_SC3_CALF_0 = 0x0
	// Calibration failed. ADC accuracy specifications are not guaranteed.
	ADC_SC3_CALF_1 = 0x1
	// Position of CAL field.
	ADC_SC3_CAL_Pos = 0x7
	// Bit mask of CAL field.
	ADC_SC3_CAL_Msk = 0x80
	// Bit CAL.
	ADC_SC3_CAL = 0x80

	// OFS: ADC Offset Correction Register
	// Position of OFS field.
	ADC_OFS_OFS_Pos = 0x0
	// Bit mask of OFS field.
	ADC_OFS_OFS_Msk = 0xffff

	// PG: ADC Plus-Side Gain Register
	// Position of PG field.
	ADC_PG_PG_Pos = 0x0
	// Bit mask of PG field.
	ADC_PG_PG_Msk = 0xffff

	// MG: ADC Minus-Side Gain Register
	// Position of MG field.
	ADC_MG_MG_Pos = 0x0
	// Bit mask of MG field.
	ADC_MG_MG_Msk = 0xffff

	// CLPD: ADC Plus-Side General Calibration Value Register
	// Position of CLPD field.
	ADC_CLPD_CLPD_Pos = 0x0
	// Bit mask of CLPD field.
	ADC_CLPD_CLPD_Msk = 0x3f

	// CLPS: ADC Plus-Side General Calibration Value Register
	// Position of CLPS field.
	ADC_CLPS_CLPS_Pos = 0x0
	// Bit mask of CLPS field.
	ADC_CLPS_CLPS_Msk = 0x3f

	// CLP4: ADC Plus-Side General Calibration Value Register
	// Position of CLP4 field.
	ADC_CLP4_CLP4_Pos = 0x0
	// Bit mask of CLP4 field.
	ADC_CLP4_CLP4_Msk = 0x3ff

	// CLP3: ADC Plus-Side General Calibration Value Register
	// Position of CLP3 field.
	ADC_CLP3_CLP3_Pos = 0x0
	// Bit mask of CLP3 field.
	ADC_CLP3_CLP3_Msk = 0x1ff

	// CLP2: ADC Plus-Side General Calibration Value Register
	// Position of CLP2 field.
	ADC_CLP2_CLP2_Pos = 0x0
	// Bit mask of CLP2 field.
	ADC_CLP2_CLP2_Msk = 0xff

	// CLP1: ADC Plus-Side General Calibration Value Register
	// Position of CLP1 field.
	ADC_CLP1_CLP1_Pos = 0x0
	// Bit mask of CLP1 field.
	ADC_CLP1_CLP1_Msk = 0x7f

	// CLP0: ADC Plus-Side General Calibration Value Register
	// Position of CLP0 field.
	ADC_CLP0_CLP0_Pos = 0x0
	// Bit mask of CLP0 field.
	ADC_CLP0_CLP0_Msk = 0x3f

	// CLMD: ADC Minus-Side General Calibration Value Register
	// Position of CLMD field.
	ADC_CLMD_CLMD_Pos = 0x0
	// Bit mask of CLMD field.
	ADC_CLMD_CLMD_Msk = 0x3f

	// CLMS: ADC Minus-Side General Calibration Value Register
	// Position of CLMS field.
	ADC_CLMS_CLMS_Pos = 0x0
	// Bit mask of CLMS field.
	ADC_CLMS_CLMS_Msk = 0x3f

	// CLM4: ADC Minus-Side General Calibration Value Register
	// Position of CLM4 field.
	ADC_CLM4_CLM4_Pos = 0x0
	// Bit mask of CLM4 field.
	ADC_CLM4_CLM4_Msk = 0x3ff

	// CLM3: ADC Minus-Side General Calibration Value Register
	// Position of CLM3 field.
	ADC_CLM3_CLM3_Pos = 0x0
	// Bit mask of CLM3 field.
	ADC_CLM3_CLM3_Msk = 0x1ff

	// CLM2: ADC Minus-Side General Calibration Value Register
	// Position of CLM2 field.
	ADC_CLM2_CLM2_Pos = 0x0
	// Bit mask of CLM2 field.
	ADC_CLM2_CLM2_Msk = 0xff

	// CLM1: ADC Minus-Side General Calibration Value Register
	// Position of CLM1 field.
	ADC_CLM1_CLM1_Pos = 0x0
	// Bit mask of CLM1 field.
	ADC_CLM1_CLM1_Msk = 0x7f

	// CLM0: ADC Minus-Side General Calibration Value Register
	// Position of CLM0 field.
	ADC_CLM0_CLM0_Pos = 0x0
	// Bit mask of CLM0 field.
	ADC_CLM0_CLM0_Msk = 0x3f
)

// Constants for RTC: Secure Real Time Clock
const (
	// TSR: RTC Time Seconds Register
	// Position of TSR field.
	RTC_TSR_TSR_Pos = 0x0
	// Bit mask of TSR field.
	RTC_TSR_TSR_Msk = 0xffffffff

	// TPR: RTC Time Prescaler Register
	// Position of TPR field.
	RTC_TPR_TPR_Pos = 0x0
	// Bit mask of TPR field.
	RTC_TPR_TPR_Msk = 0xffff

	// TAR: RTC Time Alarm Register
	// Position of TAR field.
	RTC_TAR_TAR_Pos = 0x0
	// Bit mask of TAR field.
	RTC_TAR_TAR_Msk = 0xffffffff

	// TCR: RTC Time Compensation Register
	// Position of TCR field.
	RTC_TCR_TCR_Pos = 0x0
	// Bit mask of TCR field.
	RTC_TCR_TCR_Msk = 0xff
	// Time Prescaler Register overflows every 32896 clock cycles.
	RTC_TCR_TCR_10000000 = 0x80
	// Time Prescaler Register overflows every 32769 clock cycles.
	RTC_TCR_TCR_11111111 = 0xff
	// Time Prescaler Register overflows every 32768 clock cycles.
	RTC_TCR_TCR_0 = 0x0
	// Time Prescaler Register overflows every 32767 clock cycles.
	RTC_TCR_TCR_1 = 0x1
	// Time Prescaler Register overflows every 32641 clock cycles.
	RTC_TCR_TCR_1111111 = 0x7f
	// Position of CIR field.
	RTC_TCR_CIR_Pos = 0x8
	// Bit mask of CIR field.
	RTC_TCR_CIR_Msk = 0xff00
	// Position of TCV field.
	RTC_TCR_TCV_Pos = 0x10
	// Bit mask of TCV field.
	RTC_TCR_TCV_Msk = 0xff0000
	// Position of CIC field.
	RTC_TCR_CIC_Pos = 0x18
	// Bit mask of CIC field.
	RTC_TCR_CIC_Msk = 0xff000000

	// CR: RTC Control Register
	// Position of SWR field.
	RTC_CR_SWR_Pos = 0x0
	// Bit mask of SWR field.
	RTC_CR_SWR_Msk = 0x1
	// Bit SWR.
	RTC_CR_SWR = 0x1
	// No effect.
	RTC_CR_SWR_0 = 0x0
	// Resets all RTC registers except for the SWR bit and the RTC_WAR and RTC_RAR registers . The SWR bit is cleared by VBAT POR and by software explicitly clearing it.
	RTC_CR_SWR_1 = 0x1
	// Position of WPE field.
	RTC_CR_WPE_Pos = 0x1
	// Bit mask of WPE field.
	RTC_CR_WPE_Msk = 0x2
	// Bit WPE.
	RTC_CR_WPE = 0x2
	// Wakeup pin is disabled.
	RTC_CR_WPE_0 = 0x0
	// Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt asserts or the wakeup pin is turned on.
	RTC_CR_WPE_1 = 0x1
	// Position of SUP field.
	RTC_CR_SUP_Pos = 0x2
	// Bit mask of SUP field.
	RTC_CR_SUP_Msk = 0x4
	// Bit SUP.
	RTC_CR_SUP = 0x4
	// Non-supervisor mode write accesses are not supported and generate a bus error.
	RTC_CR_SUP_0 = 0x0
	// Non-supervisor mode write accesses are supported.
	RTC_CR_SUP_1 = 0x1
	// Position of UM field.
	RTC_CR_UM_Pos = 0x3
	// Bit mask of UM field.
	RTC_CR_UM_Msk = 0x8
	// Bit UM.
	RTC_CR_UM = 0x8
	// Registers cannot be written when locked.
	RTC_CR_UM_0 = 0x0
	// Registers can be written when locked under limited conditions.
	RTC_CR_UM_1 = 0x1
	// Position of WPS field.
	RTC_CR_WPS_Pos = 0x4
	// Bit mask of WPS field.
	RTC_CR_WPS_Msk = 0x10
	// Bit WPS.
	RTC_CR_WPS = 0x10
	// Wakeup pin asserts (active low, open drain) if the RTC interrupt asserts or the wakeup pin is turned on.
	RTC_CR_WPS_0 = 0x0
	// Wakeup pin instead outputs the RTC 32kHz clock, provided the wakeup pin is turned on and the 32kHz clock is output to other peripherals.
	RTC_CR_WPS_1 = 0x1
	// Position of OSCE field.
	RTC_CR_OSCE_Pos = 0x8
	// Bit mask of OSCE field.
	RTC_CR_OSCE_Msk = 0x100
	// Bit OSCE.
	RTC_CR_OSCE = 0x100
	// 32.768 kHz oscillator is disabled.
	RTC_CR_OSCE_0 = 0x0
	// 32.768 kHz oscillator is enabled. After setting this bit, wait the oscillator startup time before enabling the time counter to allow the 32.768 kHz clock time to stabilize.
	RTC_CR_OSCE_1 = 0x1
	// Position of CLKO field.
	RTC_CR_CLKO_Pos = 0x9
	// Bit mask of CLKO field.
	RTC_CR_CLKO_Msk = 0x200
	// Bit CLKO.
	RTC_CR_CLKO = 0x200
	// The 32 kHz clock is output to other peripherals.
	RTC_CR_CLKO_0 = 0x0
	// The 32 kHz clock is not output to other peripherals.
	RTC_CR_CLKO_1 = 0x1
	// Position of SC16P field.
	RTC_CR_SC16P_Pos = 0xa
	// Bit mask of SC16P field.
	RTC_CR_SC16P_Msk = 0x400
	// Bit SC16P.
	RTC_CR_SC16P = 0x400
	// Disable the load.
	RTC_CR_SC16P_0 = 0x0
	// Enable the additional load.
	RTC_CR_SC16P_1 = 0x1
	// Position of SC8P field.
	RTC_CR_SC8P_Pos = 0xb
	// Bit mask of SC8P field.
	RTC_CR_SC8P_Msk = 0x800
	// Bit SC8P.
	RTC_CR_SC8P = 0x800
	// Disable the load.
	RTC_CR_SC8P_0 = 0x0
	// Enable the additional load.
	RTC_CR_SC8P_1 = 0x1
	// Position of SC4P field.
	RTC_CR_SC4P_Pos = 0xc
	// Bit mask of SC4P field.
	RTC_CR_SC4P_Msk = 0x1000
	// Bit SC4P.
	RTC_CR_SC4P = 0x1000
	// Disable the load.
	RTC_CR_SC4P_0 = 0x0
	// Enable the additional load.
	RTC_CR_SC4P_1 = 0x1
	// Position of SC2P field.
	RTC_CR_SC2P_Pos = 0xd
	// Bit mask of SC2P field.
	RTC_CR_SC2P_Msk = 0x2000
	// Bit SC2P.
	RTC_CR_SC2P = 0x2000
	// Disable the load.
	RTC_CR_SC2P_0 = 0x0
	// Enable the additional load.
	RTC_CR_SC2P_1 = 0x1

	// SR: RTC Status Register
	// Position of TIF field.
	RTC_SR_TIF_Pos = 0x0
	// Bit mask of TIF field.
	RTC_SR_TIF_Msk = 0x1
	// Bit TIF.
	RTC_SR_TIF = 0x1
	// Time is valid.
	RTC_SR_TIF_0 = 0x0
	// Time is invalid and time counter is read as zero.
	RTC_SR_TIF_1 = 0x1
	// Position of TOF field.
	RTC_SR_TOF_Pos = 0x1
	// Bit mask of TOF field.
	RTC_SR_TOF_Msk = 0x2
	// Bit TOF.
	RTC_SR_TOF = 0x2
	// Time overflow has not occurred.
	RTC_SR_TOF_0 = 0x0
	// Time overflow has occurred and time counter is read as zero.
	RTC_SR_TOF_1 = 0x1
	// Position of TAF field.
	RTC_SR_TAF_Pos = 0x2
	// Bit mask of TAF field.
	RTC_SR_TAF_Msk = 0x4
	// Bit TAF.
	RTC_SR_TAF = 0x4
	// Time alarm has not occurred.
	RTC_SR_TAF_0 = 0x0
	// Time alarm has occurred.
	RTC_SR_TAF_1 = 0x1
	// Position of MOF field.
	RTC_SR_MOF_Pos = 0x3
	// Bit mask of MOF field.
	RTC_SR_MOF_Msk = 0x8
	// Bit MOF.
	RTC_SR_MOF = 0x8
	// Monotonic counter overflow has not occurred.
	RTC_SR_MOF_0 = 0x0
	// Monotonic counter overflow has occurred and monotonic counter is read as zero.
	RTC_SR_MOF_1 = 0x1
	// Position of TCE field.
	RTC_SR_TCE_Pos = 0x4
	// Bit mask of TCE field.
	RTC_SR_TCE_Msk = 0x10
	// Bit TCE.
	RTC_SR_TCE = 0x10
	// Time counter is disabled.
	RTC_SR_TCE_0 = 0x0
	// Time counter is enabled.
	RTC_SR_TCE_1 = 0x1

	// LR: RTC Lock Register
	// Position of TCL field.
	RTC_LR_TCL_Pos = 0x3
	// Bit mask of TCL field.
	RTC_LR_TCL_Msk = 0x8
	// Bit TCL.
	RTC_LR_TCL = 0x8
	// Time Compensation Register is locked and writes are ignored.
	RTC_LR_TCL_0 = 0x0
	// Time Compensation Register is not locked and writes complete as normal.
	RTC_LR_TCL_1 = 0x1
	// Position of CRL field.
	RTC_LR_CRL_Pos = 0x4
	// Bit mask of CRL field.
	RTC_LR_CRL_Msk = 0x10
	// Bit CRL.
	RTC_LR_CRL = 0x10
	// Control Register is locked and writes are ignored.
	RTC_LR_CRL_0 = 0x0
	// Control Register is not locked and writes complete as normal.
	RTC_LR_CRL_1 = 0x1
	// Position of SRL field.
	RTC_LR_SRL_Pos = 0x5
	// Bit mask of SRL field.
	RTC_LR_SRL_Msk = 0x20
	// Bit SRL.
	RTC_LR_SRL = 0x20
	// Status Register is locked and writes are ignored.
	RTC_LR_SRL_0 = 0x0
	// Status Register is not locked and writes complete as normal.
	RTC_LR_SRL_1 = 0x1
	// Position of LRL field.
	RTC_LR_LRL_Pos = 0x6
	// Bit mask of LRL field.
	RTC_LR_LRL_Msk = 0x40
	// Bit LRL.
	RTC_LR_LRL = 0x40
	// Lock Register is locked and writes are ignored.
	RTC_LR_LRL_0 = 0x0
	// Lock Register is not locked and writes complete as normal.
	RTC_LR_LRL_1 = 0x1
	// Position of TTSL field.
	RTC_LR_TTSL_Pos = 0x8
	// Bit mask of TTSL field.
	RTC_LR_TTSL_Msk = 0x100
	// Bit TTSL.
	RTC_LR_TTSL = 0x100
	// Tamper Time Seconds Register is locked and writes are ignored.
	RTC_LR_TTSL_0 = 0x0
	// Tamper Time Seconds Register is not locked and writes complete as normal.
	RTC_LR_TTSL_1 = 0x1
	// Position of MEL field.
	RTC_LR_MEL_Pos = 0x9
	// Bit mask of MEL field.
	RTC_LR_MEL_Msk = 0x200
	// Bit MEL.
	RTC_LR_MEL = 0x200
	// Monotonic Enable Register is locked and writes are ignored.
	RTC_LR_MEL_0 = 0x0
	// Monotonic Enable Register is not locked and writes complete as normal.
	RTC_LR_MEL_1 = 0x1
	// Position of MCLL field.
	RTC_LR_MCLL_Pos = 0xa
	// Bit mask of MCLL field.
	RTC_LR_MCLL_Msk = 0x400
	// Bit MCLL.
	RTC_LR_MCLL = 0x400
	// Monotonic Counter Low Register is locked and writes are ignored.
	RTC_LR_MCLL_0 = 0x0
	// Monotonic Counter Low Register is not locked and writes complete as normal.
	RTC_LR_MCLL_1 = 0x1
	// Position of MCHL field.
	RTC_LR_MCHL_Pos = 0xb
	// Bit mask of MCHL field.
	RTC_LR_MCHL_Msk = 0x800
	// Bit MCHL.
	RTC_LR_MCHL = 0x800
	// Monotonic Counter High Register is locked and writes are ignored.
	RTC_LR_MCHL_0 = 0x0
	// Monotonic Counter High Register is not locked and writes complete as normal.
	RTC_LR_MCHL_1 = 0x1

	// IER: RTC Interrupt Enable Register
	// Position of TIIE field.
	RTC_IER_TIIE_Pos = 0x0
	// Bit mask of TIIE field.
	RTC_IER_TIIE_Msk = 0x1
	// Bit TIIE.
	RTC_IER_TIIE = 0x1
	// Time invalid flag does not generate an interrupt.
	RTC_IER_TIIE_0 = 0x0
	// Time invalid flag does generate an interrupt.
	RTC_IER_TIIE_1 = 0x1
	// Position of TOIE field.
	RTC_IER_TOIE_Pos = 0x1
	// Bit mask of TOIE field.
	RTC_IER_TOIE_Msk = 0x2
	// Bit TOIE.
	RTC_IER_TOIE = 0x2
	// Time overflow flag does not generate an interrupt.
	RTC_IER_TOIE_0 = 0x0
	// Time overflow flag does generate an interrupt.
	RTC_IER_TOIE_1 = 0x1
	// Position of TAIE field.
	RTC_IER_TAIE_Pos = 0x2
	// Bit mask of TAIE field.
	RTC_IER_TAIE_Msk = 0x4
	// Bit TAIE.
	RTC_IER_TAIE = 0x4
	// Time alarm flag does not generate an interrupt.
	RTC_IER_TAIE_0 = 0x0
	// Time alarm flag does generate an interrupt.
	RTC_IER_TAIE_1 = 0x1
	// Position of MOIE field.
	RTC_IER_MOIE_Pos = 0x3
	// Bit mask of MOIE field.
	RTC_IER_MOIE_Msk = 0x8
	// Bit MOIE.
	RTC_IER_MOIE = 0x8
	// Monotonic overflow flag does not generate an interrupt.
	RTC_IER_MOIE_0 = 0x0
	// Monotonic overflow flag does generate an interrupt.
	RTC_IER_MOIE_1 = 0x1
	// Position of TSIE field.
	RTC_IER_TSIE_Pos = 0x4
	// Bit mask of TSIE field.
	RTC_IER_TSIE_Msk = 0x10
	// Bit TSIE.
	RTC_IER_TSIE = 0x10
	// Seconds interrupt is disabled.
	RTC_IER_TSIE_0 = 0x0
	// Seconds interrupt is enabled.
	RTC_IER_TSIE_1 = 0x1
	// Position of WPON field.
	RTC_IER_WPON_Pos = 0x7
	// Bit mask of WPON field.
	RTC_IER_WPON_Msk = 0x80
	// Bit WPON.
	RTC_IER_WPON = 0x80
	// No effect.
	RTC_IER_WPON_0 = 0x0
	// If the wakeup pin is enabled, then the wakeup pin will assert.
	RTC_IER_WPON_1 = 0x1

	// TTSR: RTC Tamper Time Seconds Register
	// Position of TTS field.
	RTC_TTSR_TTS_Pos = 0x0
	// Bit mask of TTS field.
	RTC_TTSR_TTS_Msk = 0xffffffff

	// MER: RTC Monotonic Enable Register
	// Position of MCE field.
	RTC_MER_MCE_Pos = 0x4
	// Bit mask of MCE field.
	RTC_MER_MCE_Msk = 0x10
	// Bit MCE.
	RTC_MER_MCE = 0x10
	// Writes to the monotonic counter load the counter with the value written.
	RTC_MER_MCE_0 = 0x0
	// Writes to the monotonic counter increment the counter.
	RTC_MER_MCE_1 = 0x1

	// MCLR: RTC Monotonic Counter Low Register
	// Position of MCL field.
	RTC_MCLR_MCL_Pos = 0x0
	// Bit mask of MCL field.
	RTC_MCLR_MCL_Msk = 0xffffffff

	// MCHR: RTC Monotonic Counter High Register
	// Position of MCH field.
	RTC_MCHR_MCH_Pos = 0x0
	// Bit mask of MCH field.
	RTC_MCHR_MCH_Msk = 0xffffffff

	// WAR: RTC Write Access Register
	// Position of TSRW field.
	RTC_WAR_TSRW_Pos = 0x0
	// Bit mask of TSRW field.
	RTC_WAR_TSRW_Msk = 0x1
	// Bit TSRW.
	RTC_WAR_TSRW = 0x1
	// Writes to the Time Seconds Register are ignored.
	RTC_WAR_TSRW_0 = 0x0
	// Writes to the Time Seconds Register complete as normal.
	RTC_WAR_TSRW_1 = 0x1
	// Position of TPRW field.
	RTC_WAR_TPRW_Pos = 0x1
	// Bit mask of TPRW field.
	RTC_WAR_TPRW_Msk = 0x2
	// Bit TPRW.
	RTC_WAR_TPRW = 0x2
	// Writes to the Time Prescaler Register are ignored.
	RTC_WAR_TPRW_0 = 0x0
	// Writes to the Time Prescaler Register complete as normal.
	RTC_WAR_TPRW_1 = 0x1
	// Position of TARW field.
	RTC_WAR_TARW_Pos = 0x2
	// Bit mask of TARW field.
	RTC_WAR_TARW_Msk = 0x4
	// Bit TARW.
	RTC_WAR_TARW = 0x4
	// Writes to the Time Alarm Register are ignored.
	RTC_WAR_TARW_0 = 0x0
	// Writes to the Time Alarm Register complete as normal.
	RTC_WAR_TARW_1 = 0x1
	// Position of TCRW field.
	RTC_WAR_TCRW_Pos = 0x3
	// Bit mask of TCRW field.
	RTC_WAR_TCRW_Msk = 0x8
	// Bit TCRW.
	RTC_WAR_TCRW = 0x8
	// Writes to the Time Compensation Register are ignored.
	RTC_WAR_TCRW_0 = 0x0
	// Writes to the Time Compensation Register complete as normal.
	RTC_WAR_TCRW_1 = 0x1
	// Position of CRW field.
	RTC_WAR_CRW_Pos = 0x4
	// Bit mask of CRW field.
	RTC_WAR_CRW_Msk = 0x10
	// Bit CRW.
	RTC_WAR_CRW = 0x10
	// Writes to the Control Register are ignored.
	RTC_WAR_CRW_0 = 0x0
	// Writes to the Control Register complete as normal.
	RTC_WAR_CRW_1 = 0x1
	// Position of SRW field.
	RTC_WAR_SRW_Pos = 0x5
	// Bit mask of SRW field.
	RTC_WAR_SRW_Msk = 0x20
	// Bit SRW.
	RTC_WAR_SRW = 0x20
	// Writes to the Status Register are ignored.
	RTC_WAR_SRW_0 = 0x0
	// Writes to the Status Register complete as normal.
	RTC_WAR_SRW_1 = 0x1
	// Position of LRW field.
	RTC_WAR_LRW_Pos = 0x6
	// Bit mask of LRW field.
	RTC_WAR_LRW_Msk = 0x40
	// Bit LRW.
	RTC_WAR_LRW = 0x40
	// Writes to the Lock Register are ignored.
	RTC_WAR_LRW_0 = 0x0
	// Writes to the Lock Register complete as normal.
	RTC_WAR_LRW_1 = 0x1
	// Position of IERW field.
	RTC_WAR_IERW_Pos = 0x7
	// Bit mask of IERW field.
	RTC_WAR_IERW_Msk = 0x80
	// Bit IERW.
	RTC_WAR_IERW = 0x80
	// Writes to the Interupt Enable Register are ignored.
	RTC_WAR_IERW_0 = 0x0
	// Writes to the Interrupt Enable Register complete as normal.
	RTC_WAR_IERW_1 = 0x1
	// Position of TTSW field.
	RTC_WAR_TTSW_Pos = 0x8
	// Bit mask of TTSW field.
	RTC_WAR_TTSW_Msk = 0x100
	// Bit TTSW.
	RTC_WAR_TTSW = 0x100
	// Writes to the Tamper Time Seconds Register are ignored.
	RTC_WAR_TTSW_0 = 0x0
	// Writes to the Tamper Time Seconds Register complete as normal.
	RTC_WAR_TTSW_1 = 0x1
	// Position of MERW field.
	RTC_WAR_MERW_Pos = 0x9
	// Bit mask of MERW field.
	RTC_WAR_MERW_Msk = 0x200
	// Bit MERW.
	RTC_WAR_MERW = 0x200
	// Writes to the Monotonic Enable Register are ignored.
	RTC_WAR_MERW_0 = 0x0
	// Writes to the Monotonic Enable Register complete as normal.
	RTC_WAR_MERW_1 = 0x1
	// Position of MCLW field.
	RTC_WAR_MCLW_Pos = 0xa
	// Bit mask of MCLW field.
	RTC_WAR_MCLW_Msk = 0x400
	// Bit MCLW.
	RTC_WAR_MCLW = 0x400
	// Writes to the Monotonic Counter Low Register are ignored.
	RTC_WAR_MCLW_0 = 0x0
	// Writes to the Monotonic Counter Low Register complete as normal.
	RTC_WAR_MCLW_1 = 0x1
	// Position of MCHW field.
	RTC_WAR_MCHW_Pos = 0xb
	// Bit mask of MCHW field.
	RTC_WAR_MCHW_Msk = 0x800
	// Bit MCHW.
	RTC_WAR_MCHW = 0x800
	// Writes to the Monotonic Counter High Register are ignored.
	RTC_WAR_MCHW_0 = 0x0
	// Writes to the Monotonic Counter High Register complete as normal.
	RTC_WAR_MCHW_1 = 0x1

	// RAR: RTC Read Access Register
	// Position of TSRR field.
	RTC_RAR_TSRR_Pos = 0x0
	// Bit mask of TSRR field.
	RTC_RAR_TSRR_Msk = 0x1
	// Bit TSRR.
	RTC_RAR_TSRR = 0x1
	// Reads to the Time Seconds Register are ignored.
	RTC_RAR_TSRR_0 = 0x0
	// Reads to the Time Seconds Register complete as normal.
	RTC_RAR_TSRR_1 = 0x1
	// Position of TPRR field.
	RTC_RAR_TPRR_Pos = 0x1
	// Bit mask of TPRR field.
	RTC_RAR_TPRR_Msk = 0x2
	// Bit TPRR.
	RTC_RAR_TPRR = 0x2
	// Reads to the Time Pprescaler Register are ignored.
	RTC_RAR_TPRR_0 = 0x0
	// Reads to the Time Prescaler Register complete as normal.
	RTC_RAR_TPRR_1 = 0x1
	// Position of TARR field.
	RTC_RAR_TARR_Pos = 0x2
	// Bit mask of TARR field.
	RTC_RAR_TARR_Msk = 0x4
	// Bit TARR.
	RTC_RAR_TARR = 0x4
	// Reads to the Time Alarm Register are ignored.
	RTC_RAR_TARR_0 = 0x0
	// Reads to the Time Alarm Register complete as normal.
	RTC_RAR_TARR_1 = 0x1
	// Position of TCRR field.
	RTC_RAR_TCRR_Pos = 0x3
	// Bit mask of TCRR field.
	RTC_RAR_TCRR_Msk = 0x8
	// Bit TCRR.
	RTC_RAR_TCRR = 0x8
	// Reads to the Time Compensation Register are ignored.
	RTC_RAR_TCRR_0 = 0x0
	// Reads to the Time Compensation Register complete as normal.
	RTC_RAR_TCRR_1 = 0x1
	// Position of CRR field.
	RTC_RAR_CRR_Pos = 0x4
	// Bit mask of CRR field.
	RTC_RAR_CRR_Msk = 0x10
	// Bit CRR.
	RTC_RAR_CRR = 0x10
	// Reads to the Control Register are ignored.
	RTC_RAR_CRR_0 = 0x0
	// Reads to the Control Register complete as normal.
	RTC_RAR_CRR_1 = 0x1
	// Position of SRR field.
	RTC_RAR_SRR_Pos = 0x5
	// Bit mask of SRR field.
	RTC_RAR_SRR_Msk = 0x20
	// Bit SRR.
	RTC_RAR_SRR = 0x20
	// Reads to the Status Register are ignored.
	RTC_RAR_SRR_0 = 0x0
	// Reads to the Status Register complete as normal.
	RTC_RAR_SRR_1 = 0x1
	// Position of LRR field.
	RTC_RAR_LRR_Pos = 0x6
	// Bit mask of LRR field.
	RTC_RAR_LRR_Msk = 0x40
	// Bit LRR.
	RTC_RAR_LRR = 0x40
	// Reads to the Lock Register are ignored.
	RTC_RAR_LRR_0 = 0x0
	// Reads to the Lock Register complete as normal.
	RTC_RAR_LRR_1 = 0x1
	// Position of IERR field.
	RTC_RAR_IERR_Pos = 0x7
	// Bit mask of IERR field.
	RTC_RAR_IERR_Msk = 0x80
	// Bit IERR.
	RTC_RAR_IERR = 0x80
	// Reads to the Interrupt Enable Register are ignored.
	RTC_RAR_IERR_0 = 0x0
	// Reads to the Interrupt Enable Register complete as normal.
	RTC_RAR_IERR_1 = 0x1
	// Position of TTSR field.
	RTC_RAR_TTSR_Pos = 0x8
	// Bit mask of TTSR field.
	RTC_RAR_TTSR_Msk = 0x100
	// Bit TTSR.
	RTC_RAR_TTSR = 0x100
	// Reads to the Tamper Time Seconds Register are ignored.
	RTC_RAR_TTSR_0 = 0x0
	// Reads to the Tamper Time Seconds Register complete as normal.
	RTC_RAR_TTSR_1 = 0x1
	// Position of MERR field.
	RTC_RAR_MERR_Pos = 0x9
	// Bit mask of MERR field.
	RTC_RAR_MERR_Msk = 0x200
	// Bit MERR.
	RTC_RAR_MERR = 0x200
	// Reads to the Monotonic Enable Register are ignored.
	RTC_RAR_MERR_0 = 0x0
	// Reads to the Monotonic Enable Register complete as normal.
	RTC_RAR_MERR_1 = 0x1
	// Position of MCLR field.
	RTC_RAR_MCLR_Pos = 0xa
	// Bit mask of MCLR field.
	RTC_RAR_MCLR_Msk = 0x400
	// Bit MCLR.
	RTC_RAR_MCLR = 0x400
	// Reads to the Monotonic Counter Low Register are ignored.
	RTC_RAR_MCLR_0 = 0x0
	// Reads to the Monotonic Counter Low Register complete as normal.
	RTC_RAR_MCLR_1 = 0x1
	// Position of MCHR field.
	RTC_RAR_MCHR_Pos = 0xb
	// Bit mask of MCHR field.
	RTC_RAR_MCHR_Msk = 0x800
	// Bit MCHR.
	RTC_RAR_MCHR = 0x800
	// Reads to the Monotonic Counter High Register are ignored.
	RTC_RAR_MCHR_0 = 0x0
	// Reads to the Monotonic Counter High Register complete as normal.
	RTC_RAR_MCHR_1 = 0x1
)

// Constants for RFVBAT: VBAT register file
const (
	// REG0: VBAT register file register
	// Position of LL field.
	RFVBAT_REG_LL_Pos = 0x0
	// Bit mask of LL field.
	RFVBAT_REG_LL_Msk = 0xff
	// Position of LH field.
	RFVBAT_REG_LH_Pos = 0x8
	// Bit mask of LH field.
	RFVBAT_REG_LH_Msk = 0xff00
	// Position of HL field.
	RFVBAT_REG_HL_Pos = 0x10
	// Bit mask of HL field.
	RFVBAT_REG_HL_Msk = 0xff0000
	// Position of HH field.
	RFVBAT_REG_HH_Pos = 0x18
	// Bit mask of HH field.
	RFVBAT_REG_HH_Msk = 0xff000000
)

// Constants for LPTMR0: Low Power Timer
const (
	// CSR: Low Power Timer Control Status Register
	// Position of TEN field.
	LPTMR0_CSR_TEN_Pos = 0x0
	// Bit mask of TEN field.
	LPTMR0_CSR_TEN_Msk = 0x1
	// Bit TEN.
	LPTMR0_CSR_TEN = 0x1
	// LPTMR is disabled and internal logic is reset.
	LPTMR0_CSR_TEN_0 = 0x0
	// LPTMR is enabled.
	LPTMR0_CSR_TEN_1 = 0x1
	// Position of TMS field.
	LPTMR0_CSR_TMS_Pos = 0x1
	// Bit mask of TMS field.
	LPTMR0_CSR_TMS_Msk = 0x2
	// Bit TMS.
	LPTMR0_CSR_TMS = 0x2
	// Time Counter mode.
	LPTMR0_CSR_TMS_0 = 0x0
	// Pulse Counter mode.
	LPTMR0_CSR_TMS_1 = 0x1
	// Position of TFC field.
	LPTMR0_CSR_TFC_Pos = 0x2
	// Bit mask of TFC field.
	LPTMR0_CSR_TFC_Msk = 0x4
	// Bit TFC.
	LPTMR0_CSR_TFC = 0x4
	// CNR is reset whenever TCF is set.
	LPTMR0_CSR_TFC_0 = 0x0
	// CNR is reset on overflow.
	LPTMR0_CSR_TFC_1 = 0x1
	// Position of TPP field.
	LPTMR0_CSR_TPP_Pos = 0x3
	// Bit mask of TPP field.
	LPTMR0_CSR_TPP_Msk = 0x8
	// Bit TPP.
	LPTMR0_CSR_TPP = 0x8
	// Pulse Counter input source is active-high, and the CNR will increment on the rising-edge.
	LPTMR0_CSR_TPP_0 = 0x0
	// Pulse Counter input source is active-low, and the CNR will increment on the falling-edge.
	LPTMR0_CSR_TPP_1 = 0x1
	// Position of TPS field.
	LPTMR0_CSR_TPS_Pos = 0x4
	// Bit mask of TPS field.
	LPTMR0_CSR_TPS_Msk = 0x30
	// Pulse counter input 0 is selected.
	LPTMR0_CSR_TPS_00 = 0x0
	// Pulse counter input 1 is selected.
	LPTMR0_CSR_TPS_01 = 0x1
	// Pulse counter input 2 is selected.
	LPTMR0_CSR_TPS_10 = 0x2
	// Pulse counter input 3 is selected.
	LPTMR0_CSR_TPS_11 = 0x3
	// Position of TIE field.
	LPTMR0_CSR_TIE_Pos = 0x6
	// Bit mask of TIE field.
	LPTMR0_CSR_TIE_Msk = 0x40
	// Bit TIE.
	LPTMR0_CSR_TIE = 0x40
	// Timer interrupt disabled.
	LPTMR0_CSR_TIE_0 = 0x0
	// Timer interrupt enabled.
	LPTMR0_CSR_TIE_1 = 0x1
	// Position of TCF field.
	LPTMR0_CSR_TCF_Pos = 0x7
	// Bit mask of TCF field.
	LPTMR0_CSR_TCF_Msk = 0x80
	// Bit TCF.
	LPTMR0_CSR_TCF = 0x80
	// The value of CNR is not equal to CMR and increments.
	LPTMR0_CSR_TCF_0 = 0x0
	// The value of CNR is equal to CMR and increments.
	LPTMR0_CSR_TCF_1 = 0x1

	// PSR: Low Power Timer Prescale Register
	// Position of PCS field.
	LPTMR0_PSR_PCS_Pos = 0x0
	// Bit mask of PCS field.
	LPTMR0_PSR_PCS_Msk = 0x3
	// Prescaler/glitch filter clock 0 selected.
	LPTMR0_PSR_PCS_00 = 0x0
	// Prescaler/glitch filter clock 1 selected.
	LPTMR0_PSR_PCS_01 = 0x1
	// Prescaler/glitch filter clock 2 selected.
	LPTMR0_PSR_PCS_10 = 0x2
	// Prescaler/glitch filter clock 3 selected.
	LPTMR0_PSR_PCS_11 = 0x3
	// Position of PBYP field.
	LPTMR0_PSR_PBYP_Pos = 0x2
	// Bit mask of PBYP field.
	LPTMR0_PSR_PBYP_Msk = 0x4
	// Bit PBYP.
	LPTMR0_PSR_PBYP = 0x4
	// Prescaler/glitch filter is enabled.
	LPTMR0_PSR_PBYP_0 = 0x0
	// Prescaler/glitch filter is bypassed.
	LPTMR0_PSR_PBYP_1 = 0x1
	// Position of PRESCALE field.
	LPTMR0_PSR_PRESCALE_Pos = 0x3
	// Bit mask of PRESCALE field.
	LPTMR0_PSR_PRESCALE_Msk = 0x78
	// Prescaler divides the prescaler clock by 2; glitch filter does not support this configuration.
	LPTMR0_PSR_PRESCALE_0000 = 0x0
	// Prescaler divides the prescaler clock by 4; glitch filter recognizes change on input pin after 2 rising clock edges.
	LPTMR0_PSR_PRESCALE_0001 = 0x1
	// Prescaler divides the prescaler clock by 8; glitch filter recognizes change on input pin after 4 rising clock edges.
	LPTMR0_PSR_PRESCALE_0010 = 0x2
	// Prescaler divides the prescaler clock by 16; glitch filter recognizes change on input pin after 8 rising clock edges.
	LPTMR0_PSR_PRESCALE_0011 = 0x3
	// Prescaler divides the prescaler clock by 32; glitch filter recognizes change on input pin after 16 rising clock edges.
	LPTMR0_PSR_PRESCALE_0100 = 0x4
	// Prescaler divides the prescaler clock by 64; glitch filter recognizes change on input pin after 32 rising clock edges.
	LPTMR0_PSR_PRESCALE_0101 = 0x5
	// Prescaler divides the prescaler clock by 128; glitch filter recognizes change on input pin after 64 rising clock edges.
	LPTMR0_PSR_PRESCALE_0110 = 0x6
	// Prescaler divides the prescaler clock by 256; glitch filter recognizes change on input pin after 128 rising clock edges.
	LPTMR0_PSR_PRESCALE_0111 = 0x7
	// Prescaler divides the prescaler clock by 512; glitch filter recognizes change on input pin after 256 rising clock edges.
	LPTMR0_PSR_PRESCALE_1000 = 0x8
	// Prescaler divides the prescaler clock by 1024; glitch filter recognizes change on input pin after 512 rising clock edges.
	LPTMR0_PSR_PRESCALE_1001 = 0x9
	// Prescaler divides the prescaler clock by 2048; glitch filter recognizes change on input pin after 1024 rising clock edges.
	LPTMR0_PSR_PRESCALE_1010 = 0xa
	// Prescaler divides the prescaler clock by 4096; glitch filter recognizes change on input pin after 2048 rising clock edges.
	LPTMR0_PSR_PRESCALE_1011 = 0xb
	// Prescaler divides the prescaler clock by 8192; glitch filter recognizes change on input pin after 4096 rising clock edges.
	LPTMR0_PSR_PRESCALE_1100 = 0xc
	// Prescaler divides the prescaler clock by 16,384; glitch filter recognizes change on input pin after 8192 rising clock edges.
	LPTMR0_PSR_PRESCALE_1101 = 0xd
	// Prescaler divides the prescaler clock by 32,768; glitch filter recognizes change on input pin after 16,384 rising clock edges.
	LPTMR0_PSR_PRESCALE_1110 = 0xe
	// Prescaler divides the prescaler clock by 65,536; glitch filter recognizes change on input pin after 32,768 rising clock edges.
	LPTMR0_PSR_PRESCALE_1111 = 0xf

	// CMR: Low Power Timer Compare Register
	// Position of COMPARE field.
	LPTMR0_CMR_COMPARE_Pos = 0x0
	// Bit mask of COMPARE field.
	LPTMR0_CMR_COMPARE_Msk = 0xffff

	// CNR: Low Power Timer Counter Register
	// Position of COUNTER field.
	LPTMR0_CNR_COUNTER_Pos = 0x0
	// Bit mask of COUNTER field.
	LPTMR0_CNR_COUNTER_Msk = 0xffff
)

// Constants for RFSYS: System register file
const (
	// REG0: Register file register
	// Position of LL field.
	RFSYS_REG_LL_Pos = 0x0
	// Bit mask of LL field.
	RFSYS_REG_LL_Msk = 0xff
	// Position of LH field.
	RFSYS_REG_LH_Pos = 0x8
	// Bit mask of LH field.
	RFSYS_REG_LH_Msk = 0xff00
	// Position of HL field.
	RFSYS_REG_HL_Pos = 0x10
	// Bit mask of HL field.
	RFSYS_REG_HL_Msk = 0xff0000
	// Position of HH field.
	RFSYS_REG_HH_Pos = 0x18
	// Bit mask of HH field.
	RFSYS_REG_HH_Msk = 0xff000000
)

// Constants for TSI0: Touch sense input
const (
	// GENCS: TSI General Control and Status Register
	// Position of EOSDMEO field.
	TSI0_GENCS_EOSDMEO_Pos = 0x0
	// Bit mask of EOSDMEO field.
	TSI0_GENCS_EOSDMEO_Msk = 0x1
	// Bit EOSDMEO.
	TSI0_GENCS_EOSDMEO = 0x1
	// Do not enable the End-of-Scan DMA transfer request only. Depending on ESOR state, either Out-of-Range or End-of-Scan can trigger a DMA transfer request and interrupt.
	TSI0_GENCS_EOSDMEO_0 = 0x0
	// Only the End-of-Scan event can trigger a DMA transfer request. The Out-of-Range event only and always triggers an interrupt if TSIIE is set.
	TSI0_GENCS_EOSDMEO_1 = 0x1
	// Position of CURSW field.
	TSI0_GENCS_CURSW_Pos = 0x1
	// Bit mask of CURSW field.
	TSI0_GENCS_CURSW_Msk = 0x2
	// Bit CURSW.
	TSI0_GENCS_CURSW = 0x2
	// The current source pair are not swapped.
	TSI0_GENCS_CURSW_0 = 0x0
	// The current source pair are swapped.
	TSI0_GENCS_CURSW_1 = 0x1
	// Position of EOSF field.
	TSI0_GENCS_EOSF_Pos = 0x2
	// Bit mask of EOSF field.
	TSI0_GENCS_EOSF_Msk = 0x4
	// Bit EOSF.
	TSI0_GENCS_EOSF = 0x4
	// Scan not complete.
	TSI0_GENCS_EOSF_0 = 0x0
	// Scan complete.
	TSI0_GENCS_EOSF_1 = 0x1
	// Position of SCNIP field.
	TSI0_GENCS_SCNIP_Pos = 0x3
	// Bit mask of SCNIP field.
	TSI0_GENCS_SCNIP_Msk = 0x8
	// Bit SCNIP.
	TSI0_GENCS_SCNIP = 0x8
	// No scan in progress.
	TSI0_GENCS_SCNIP_0 = 0x0
	// Scan in progress.
	TSI0_GENCS_SCNIP_1 = 0x1
	// Position of STM field.
	TSI0_GENCS_STM_Pos = 0x4
	// Bit mask of STM field.
	TSI0_GENCS_STM_Msk = 0x10
	// Bit STM.
	TSI0_GENCS_STM = 0x10
	// Software trigger scan.
	TSI0_GENCS_STM_0 = 0x0
	// Hardware trigger scan.
	TSI0_GENCS_STM_1 = 0x1
	// Position of STPE field.
	TSI0_GENCS_STPE_Pos = 0x5
	// Bit mask of STPE field.
	TSI0_GENCS_STPE_Msk = 0x20
	// Bit STPE.
	TSI0_GENCS_STPE = 0x20
	// TSI is disabled when MCU goes into low power mode.
	TSI0_GENCS_STPE_0 = 0x0
	// Allows TSI to continue running in all low power modes.
	TSI0_GENCS_STPE_1 = 0x1
	// Position of TSIIEN field.
	TSI0_GENCS_TSIIEN_Pos = 0x6
	// Bit mask of TSIIEN field.
	TSI0_GENCS_TSIIEN_Msk = 0x40
	// Bit TSIIEN.
	TSI0_GENCS_TSIIEN = 0x40
	// TSI interrupt is disabled.
	TSI0_GENCS_TSIIEN_0 = 0x0
	// TSI interrupt is enabled.
	TSI0_GENCS_TSIIEN_1 = 0x1
	// Position of TSIEN field.
	TSI0_GENCS_TSIEN_Pos = 0x7
	// Bit mask of TSIEN field.
	TSI0_GENCS_TSIEN_Msk = 0x80
	// Bit TSIEN.
	TSI0_GENCS_TSIEN = 0x80
	// TSI module disabled.
	TSI0_GENCS_TSIEN_0 = 0x0
	// TSI module enabled.
	TSI0_GENCS_TSIEN_1 = 0x1
	// Position of NSCN field.
	TSI0_GENCS_NSCN_Pos = 0x8
	// Bit mask of NSCN field.
	TSI0_GENCS_NSCN_Msk = 0x1f00
	// Once per electrode
	TSI0_GENCS_NSCN_00000 = 0x0
	// Twice per electrode
	TSI0_GENCS_NSCN_00001 = 0x1
	// 3 times per electrode
	TSI0_GENCS_NSCN_00010 = 0x2
	// 4 times per electrode
	TSI0_GENCS_NSCN_00011 = 0x3
	// 5 times per electrode
	TSI0_GENCS_NSCN_00100 = 0x4
	// 6 times per electrode
	TSI0_GENCS_NSCN_00101 = 0x5
	// 7 times per electrode
	TSI0_GENCS_NSCN_00110 = 0x6
	// 8 times per electrode
	TSI0_GENCS_NSCN_00111 = 0x7
	// 9 times per electrode
	TSI0_GENCS_NSCN_01000 = 0x8
	// 10 times per electrode
	TSI0_GENCS_NSCN_01001 = 0x9
	// 11 times per electrode
	TSI0_GENCS_NSCN_01010 = 0xa
	// 12 times per electrode
	TSI0_GENCS_NSCN_01011 = 0xb
	// 13 times per electrode
	TSI0_GENCS_NSCN_01100 = 0xc
	// 14 times per electrode
	TSI0_GENCS_NSCN_01101 = 0xd
	// 15 times per electrode
	TSI0_GENCS_NSCN_01110 = 0xe
	// 16 times per electrode
	TSI0_GENCS_NSCN_01111 = 0xf
	// 17 times per electrode
	TSI0_GENCS_NSCN_10000 = 0x10
	// 18 times per electrode
	TSI0_GENCS_NSCN_10001 = 0x11
	// 19 times per electrode
	TSI0_GENCS_NSCN_10010 = 0x12
	// 20 times per electrode
	TSI0_GENCS_NSCN_10011 = 0x13
	// 21 times per electrode
	TSI0_GENCS_NSCN_10100 = 0x14
	// 22 times per electrode
	TSI0_GENCS_NSCN_10101 = 0x15
	// 23 times per electrode
	TSI0_GENCS_NSCN_10110 = 0x16
	// 24 times per electrode
	TSI0_GENCS_NSCN_10111 = 0x17
	// 25 times per electrode
	TSI0_GENCS_NSCN_11000 = 0x18
	// 26 times per electrode
	TSI0_GENCS_NSCN_11001 = 0x19
	// 27 times per electrode
	TSI0_GENCS_NSCN_11010 = 0x1a
	// 28 times per electrode
	TSI0_GENCS_NSCN_11011 = 0x1b
	// 29 times per electrode
	TSI0_GENCS_NSCN_11100 = 0x1c
	// 30 times per electrode
	TSI0_GENCS_NSCN_11101 = 0x1d
	// 31 times per electrode
	TSI0_GENCS_NSCN_11110 = 0x1e
	// 32 times per electrode
	TSI0_GENCS_NSCN_11111 = 0x1f
	// Position of PS field.
	TSI0_GENCS_PS_Pos = 0xd
	// Bit mask of PS field.
	TSI0_GENCS_PS_Msk = 0xe000
	// Electrode Oscillator Frequency divided by 1
	TSI0_GENCS_PS_000 = 0x0
	// Electrode Oscillator Frequency divided by 2
	TSI0_GENCS_PS_001 = 0x1
	// Electrode Oscillator Frequency divided by 4
	TSI0_GENCS_PS_010 = 0x2
	// Electrode Oscillator Frequency divided by 8
	TSI0_GENCS_PS_011 = 0x3
	// Electrode Oscillator Frequency divided by 16
	TSI0_GENCS_PS_100 = 0x4
	// Electrode Oscillator Frequency divided by 32
	TSI0_GENCS_PS_101 = 0x5
	// Electrode Oscillator Frequency divided by 64
	TSI0_GENCS_PS_110 = 0x6
	// Electrode Oscillator Frequency divided by 128
	TSI0_GENCS_PS_111 = 0x7
	// Position of EXTCHRG field.
	TSI0_GENCS_EXTCHRG_Pos = 0x10
	// Bit mask of EXTCHRG field.
	TSI0_GENCS_EXTCHRG_Msk = 0x70000
	// 500 nA.
	TSI0_GENCS_EXTCHRG_000 = 0x0
	// 1 uA.
	TSI0_GENCS_EXTCHRG_001 = 0x1
	// 2 uA.
	TSI0_GENCS_EXTCHRG_010 = 0x2
	// 4 uA.
	TSI0_GENCS_EXTCHRG_011 = 0x3
	// 8 uA.
	TSI0_GENCS_EXTCHRG_100 = 0x4
	// 16 uA.
	TSI0_GENCS_EXTCHRG_101 = 0x5
	// 32 uA.
	TSI0_GENCS_EXTCHRG_110 = 0x6
	// 64 uA.
	TSI0_GENCS_EXTCHRG_111 = 0x7
	// Position of DVOLT field.
	TSI0_GENCS_DVOLT_Pos = 0x13
	// Bit mask of DVOLT field.
	TSI0_GENCS_DVOLT_Msk = 0x180000
	// DV = 1.026 V; VP = 1.328 V; Vm = 0.302 V.
	TSI0_GENCS_DVOLT_00 = 0x0
	// DV = 0.592 V; VP = 1.111 V; Vm = 0.519 V.
	TSI0_GENCS_DVOLT_01 = 0x1
	// DV = 0.342 V; VP = 0.986 V; Vm = 0.644 V.
	TSI0_GENCS_DVOLT_10 = 0x2
	// DV = 0.197 V; VP = 0.914 V; Vm = 0.716 V.
	TSI0_GENCS_DVOLT_11 = 0x3
	// Position of REFCHRG field.
	TSI0_GENCS_REFCHRG_Pos = 0x15
	// Bit mask of REFCHRG field.
	TSI0_GENCS_REFCHRG_Msk = 0xe00000
	// 500 nA.
	TSI0_GENCS_REFCHRG_000 = 0x0
	// 1 uA.
	TSI0_GENCS_REFCHRG_001 = 0x1
	// 2 uA.
	TSI0_GENCS_REFCHRG_010 = 0x2
	// 4 uA.
	TSI0_GENCS_REFCHRG_011 = 0x3
	// 8 uA.
	TSI0_GENCS_REFCHRG_100 = 0x4
	// 16 uA.
	TSI0_GENCS_REFCHRG_101 = 0x5
	// 32 uA.
	TSI0_GENCS_REFCHRG_110 = 0x6
	// 64 uA.
	TSI0_GENCS_REFCHRG_111 = 0x7
	// Position of MODE field.
	TSI0_GENCS_MODE_Pos = 0x18
	// Bit mask of MODE field.
	TSI0_GENCS_MODE_Msk = 0xf000000
	// Set TSI in capacitive sensing(non-noise detection) mode.
	TSI0_GENCS_MODE_0000 = 0x0
	// Set TSI analog to work in single threshold noise detection mode and the frequency limitation circuit is disabled.
	TSI0_GENCS_MODE_0100 = 0x4
	// Set TSI analog to work in single threshold noise detection mode and the frequency limitation circuit is enabled to work in higher frequencies operations.
	TSI0_GENCS_MODE_1000 = 0x8
	// Set TSI analog to work in automatic noise detection mode.
	TSI0_GENCS_MODE_1100 = 0xc
	// Position of ESOR field.
	TSI0_GENCS_ESOR_Pos = 0x1c
	// Bit mask of ESOR field.
	TSI0_GENCS_ESOR_Msk = 0x10000000
	// Bit ESOR.
	TSI0_GENCS_ESOR = 0x10000000
	// Out-of-range interrupt is allowed.
	TSI0_GENCS_ESOR_0 = 0x0
	// End-of-scan interrupt is allowed.
	TSI0_GENCS_ESOR_1 = 0x1
	// Position of OUTRGF field.
	TSI0_GENCS_OUTRGF_Pos = 0x1f
	// Bit mask of OUTRGF field.
	TSI0_GENCS_OUTRGF_Msk = 0x80000000
	// Bit OUTRGF.
	TSI0_GENCS_OUTRGF = 0x80000000

	// DATA: TSI DATA Register
	// Position of TSICNT field.
	TSI0_DATA_TSICNT_Pos = 0x0
	// Bit mask of TSICNT field.
	TSI0_DATA_TSICNT_Msk = 0xffff
	// Position of SWTS field.
	TSI0_DATA_SWTS_Pos = 0x16
	// Bit mask of SWTS field.
	TSI0_DATA_SWTS_Msk = 0x400000
	// Bit SWTS.
	TSI0_DATA_SWTS = 0x400000
	// No effect.
	TSI0_DATA_SWTS_0 = 0x0
	// Start a scan to determine which channel is specified by TSI_DATA[TSICH].
	TSI0_DATA_SWTS_1 = 0x1
	// Position of DMAEN field.
	TSI0_DATA_DMAEN_Pos = 0x17
	// Bit mask of DMAEN field.
	TSI0_DATA_DMAEN_Msk = 0x800000
	// Bit DMAEN.
	TSI0_DATA_DMAEN = 0x800000
	// Interrupt is selected when the interrupt enable bit is set and the corresponding TSI events assert.
	TSI0_DATA_DMAEN_0 = 0x0
	// DMA transfer request is selected when the interrupt enable bit is set and the corresponding TSI events assert.
	TSI0_DATA_DMAEN_1 = 0x1
	// Position of TSICH field.
	TSI0_DATA_TSICH_Pos = 0x1c
	// Bit mask of TSICH field.
	TSI0_DATA_TSICH_Msk = 0xf0000000
	// Channel 0.
	TSI0_DATA_TSICH_0000 = 0x0
	// Channel 1.
	TSI0_DATA_TSICH_0001 = 0x1
	// Channel 2.
	TSI0_DATA_TSICH_0010 = 0x2
	// Channel 3.
	TSI0_DATA_TSICH_0011 = 0x3
	// Channel 4.
	TSI0_DATA_TSICH_0100 = 0x4
	// Channel 5.
	TSI0_DATA_TSICH_0101 = 0x5
	// Channel 6.
	TSI0_DATA_TSICH_0110 = 0x6
	// Channel 7.
	TSI0_DATA_TSICH_0111 = 0x7
	// Channel 8.
	TSI0_DATA_TSICH_1000 = 0x8
	// Channel 9.
	TSI0_DATA_TSICH_1001 = 0x9
	// Channel 10.
	TSI0_DATA_TSICH_1010 = 0xa
	// Channel 11.
	TSI0_DATA_TSICH_1011 = 0xb
	// Channel 12.
	TSI0_DATA_TSICH_1100 = 0xc
	// Channel 13.
	TSI0_DATA_TSICH_1101 = 0xd
	// Channel 14.
	TSI0_DATA_TSICH_1110 = 0xe
	// Channel 15.
	TSI0_DATA_TSICH_1111 = 0xf

	// TSHD: TSI Threshold Register
	// Position of THRESL field.
	TSI0_TSHD_THRESL_Pos = 0x0
	// Bit mask of THRESL field.
	TSI0_TSHD_THRESL_Msk = 0xffff
	// Position of THRESH field.
	TSI0_TSHD_THRESH_Pos = 0x10
	// Bit mask of THRESH field.
	TSI0_TSHD_THRESH_Msk = 0xffff0000
)

// Constants for SIM: System Integration Module
const (
	// SOPT1: System Options Register 1
	// Position of RAMSIZE field.
	SIM_SOPT1_RAMSIZE_Pos = 0xc
	// Bit mask of RAMSIZE field.
	SIM_SOPT1_RAMSIZE_Msk = 0xf000
	// 8 KB
	SIM_SOPT1_RAMSIZE_0001 = 0x1
	// 16 KB
	SIM_SOPT1_RAMSIZE_0011 = 0x3
	// 24 KB
	SIM_SOPT1_RAMSIZE_0100 = 0x4
	// 32 KB
	SIM_SOPT1_RAMSIZE_0101 = 0x5
	// 48 KB
	SIM_SOPT1_RAMSIZE_0110 = 0x6
	// 64 KB
	SIM_SOPT1_RAMSIZE_0111 = 0x7
	// 96 KB
	SIM_SOPT1_RAMSIZE_1000 = 0x8
	// 128 KB
	SIM_SOPT1_RAMSIZE_1001 = 0x9
	// 256 KB
	SIM_SOPT1_RAMSIZE_1011 = 0xb
	// Position of OSC32KSEL field.
	SIM_SOPT1_OSC32KSEL_Pos = 0x12
	// Bit mask of OSC32KSEL field.
	SIM_SOPT1_OSC32KSEL_Msk = 0xc0000
	// System oscillator (OSC32KCLK)
	SIM_SOPT1_OSC32KSEL_00 = 0x0
	// RTC 32.768kHz oscillator
	SIM_SOPT1_OSC32KSEL_10 = 0x2
	// LPO 1 kHz
	SIM_SOPT1_OSC32KSEL_11 = 0x3
	// Position of USBVSTBY field.
	SIM_SOPT1_USBVSTBY_Pos = 0x1d
	// Bit mask of USBVSTBY field.
	SIM_SOPT1_USBVSTBY_Msk = 0x20000000
	// Bit USBVSTBY.
	SIM_SOPT1_USBVSTBY = 0x20000000
	// USB voltage regulator not in standby during VLPR and VLPW modes.
	SIM_SOPT1_USBVSTBY_0 = 0x0
	// USB voltage regulator in standby during VLPR and VLPW modes.
	SIM_SOPT1_USBVSTBY_1 = 0x1
	// Position of USBSSTBY field.
	SIM_SOPT1_USBSSTBY_Pos = 0x1e
	// Bit mask of USBSSTBY field.
	SIM_SOPT1_USBSSTBY_Msk = 0x40000000
	// Bit USBSSTBY.
	SIM_SOPT1_USBSSTBY = 0x40000000
	// USB voltage regulator not in standby during Stop, VLPS, LLS and VLLS modes.
	SIM_SOPT1_USBSSTBY_0 = 0x0
	// USB voltage regulator in standby during Stop, VLPS, LLS and VLLS modes.
	SIM_SOPT1_USBSSTBY_1 = 0x1
	// Position of USBREGEN field.
	SIM_SOPT1_USBREGEN_Pos = 0x1f
	// Bit mask of USBREGEN field.
	SIM_SOPT1_USBREGEN_Msk = 0x80000000
	// Bit USBREGEN.
	SIM_SOPT1_USBREGEN = 0x80000000
	// USB voltage regulator is disabled.
	SIM_SOPT1_USBREGEN_0 = 0x0
	// USB voltage regulator is enabled.
	SIM_SOPT1_USBREGEN_1 = 0x1

	// SOPT1CFG: SOPT1 Configuration Register
	// Position of URWE field.
	SIM_SOPT1CFG_URWE_Pos = 0x18
	// Bit mask of URWE field.
	SIM_SOPT1CFG_URWE_Msk = 0x1000000
	// Bit URWE.
	SIM_SOPT1CFG_URWE = 0x1000000
	// SOPT1 USBREGEN cannot be written.
	SIM_SOPT1CFG_URWE_0 = 0x0
	// SOPT1 USBREGEN can be written.
	SIM_SOPT1CFG_URWE_1 = 0x1
	// Position of UVSWE field.
	SIM_SOPT1CFG_UVSWE_Pos = 0x19
	// Bit mask of UVSWE field.
	SIM_SOPT1CFG_UVSWE_Msk = 0x2000000
	// Bit UVSWE.
	SIM_SOPT1CFG_UVSWE = 0x2000000
	// SOPT1 USBVSTBY cannot be written.
	SIM_SOPT1CFG_UVSWE_0 = 0x0
	// SOPT1 USBVSTBY can be written.
	SIM_SOPT1CFG_UVSWE_1 = 0x1
	// Position of USSWE field.
	SIM_SOPT1CFG_USSWE_Pos = 0x1a
	// Bit mask of USSWE field.
	SIM_SOPT1CFG_USSWE_Msk = 0x4000000
	// Bit USSWE.
	SIM_SOPT1CFG_USSWE = 0x4000000
	// SOPT1 USBSSTBY cannot be written.
	SIM_SOPT1CFG_USSWE_0 = 0x0
	// SOPT1 USBSSTBY can be written.
	SIM_SOPT1CFG_USSWE_1 = 0x1

	// USBPHYCTL: USB PHY Control Register
	// Position of USBVREGSEL field.
	SIM_USBPHYCTL_USBVREGSEL_Pos = 0x8
	// Bit mask of USBVREGSEL field.
	SIM_USBPHYCTL_USBVREGSEL_Msk = 0x100
	// Bit USBVREGSEL.
	SIM_USBPHYCTL_USBVREGSEL = 0x100
	// VREG_IN0 will be selected if both regulator inputs are powered
	SIM_USBPHYCTL_USBVREGSEL_0 = 0x0
	// VREG_IN1 will be selected if both regulator inputs are powered
	SIM_USBPHYCTL_USBVREGSEL_1 = 0x1
	// Position of USBVREGPD field.
	SIM_USBPHYCTL_USBVREGPD_Pos = 0x9
	// Bit mask of USBVREGPD field.
	SIM_USBPHYCTL_USBVREGPD_Msk = 0x200
	// Bit USBVREGPD.
	SIM_USBPHYCTL_USBVREGPD = 0x200
	// Regulator output pulldown resistor is not enabled
	SIM_USBPHYCTL_USBVREGPD_0 = 0x0
	// Regulator output pulldown resistor is enabled
	SIM_USBPHYCTL_USBVREGPD_1 = 0x1
	// Position of USB3VOUTTRG field.
	SIM_USBPHYCTL_USB3VOUTTRG_Pos = 0x14
	// Bit mask of USB3VOUTTRG field.
	SIM_USBPHYCTL_USB3VOUTTRG_Msk = 0x700000
	// 2.733V
	SIM_USBPHYCTL_USB3VOUTTRG_000 = 0x0
	// 3.020V
	SIM_USBPHYCTL_USB3VOUTTRG_001 = 0x1
	// 3.074V
	SIM_USBPHYCTL_USB3VOUTTRG_010 = 0x2
	// 3.130V
	SIM_USBPHYCTL_USB3VOUTTRG_011 = 0x3
	// 3.188V
	SIM_USBPHYCTL_USB3VOUTTRG_100 = 0x4
	// 3.248V
	SIM_USBPHYCTL_USB3VOUTTRG_101 = 0x5
	// 3.310V (default)
	SIM_USBPHYCTL_USB3VOUTTRG_110 = 0x6
	// 3.662V (For Freescale use only, not for customer use)
	SIM_USBPHYCTL_USB3VOUTTRG_111 = 0x7
	// Position of USBDISILIM field.
	SIM_USBPHYCTL_USBDISILIM_Pos = 0x17
	// Bit mask of USBDISILIM field.
	SIM_USBPHYCTL_USBDISILIM_Msk = 0x800000
	// Bit USBDISILIM.
	SIM_USBPHYCTL_USBDISILIM = 0x800000
	// The current limiter for the USB Voltage Regulator is enabled
	SIM_USBPHYCTL_USBDISILIM_0 = 0x0
	// The current limiter for the USB Voltage Regulator is disabled
	SIM_USBPHYCTL_USBDISILIM_1 = 0x1

	// SOPT2: System Options Register 2
	// Position of USBSLSRC field.
	SIM_SOPT2_USBSLSRC_Pos = 0x0
	// Bit mask of USBSLSRC field.
	SIM_SOPT2_USBSLSRC_Msk = 0x1
	// Bit USBSLSRC.
	SIM_SOPT2_USBSLSRC = 0x1
	// MCGIRCLK
	SIM_SOPT2_USBSLSRC_0 = 0x0
	// RTC 32.768kHz clock
	SIM_SOPT2_USBSLSRC_1 = 0x1
	// Position of USBREGEN field.
	SIM_SOPT2_USBREGEN_Pos = 0x1
	// Bit mask of USBREGEN field.
	SIM_SOPT2_USBREGEN_Msk = 0x2
	// Bit USBREGEN.
	SIM_SOPT2_USBREGEN = 0x2
	// USB PHY PLL Regulator disabled.
	SIM_SOPT2_USBREGEN_0 = 0x0
	// USB PHY PLL Regulator enabled.
	SIM_SOPT2_USBREGEN_1 = 0x1
	// Position of RTCCLKOUTSEL field.
	SIM_SOPT2_RTCCLKOUTSEL_Pos = 0x4
	// Bit mask of RTCCLKOUTSEL field.
	SIM_SOPT2_RTCCLKOUTSEL_Msk = 0x10
	// Bit RTCCLKOUTSEL.
	SIM_SOPT2_RTCCLKOUTSEL = 0x10
	// RTC 1 Hz clock is output on the RTC_CLKOUT pin.
	SIM_SOPT2_RTCCLKOUTSEL_0 = 0x0
	// RTC 32.768kHz clock is output on the RTC_CLKOUT pin.
	SIM_SOPT2_RTCCLKOUTSEL_1 = 0x1
	// Position of CLKOUTSEL field.
	SIM_SOPT2_CLKOUTSEL_Pos = 0x5
	// Bit mask of CLKOUTSEL field.
	SIM_SOPT2_CLKOUTSEL_Msk = 0xe0
	// FlexBus CLKOUT
	SIM_SOPT2_CLKOUTSEL_000 = 0x0
	// Flash clock
	SIM_SOPT2_CLKOUTSEL_010 = 0x2
	// LPO clock (1 kHz)
	SIM_SOPT2_CLKOUTSEL_011 = 0x3
	// MCGIRCLK
	SIM_SOPT2_CLKOUTSEL_100 = 0x4
	// RTC 32.768kHz clock
	SIM_SOPT2_CLKOUTSEL_101 = 0x5
	// OSCERCLK0
	SIM_SOPT2_CLKOUTSEL_110 = 0x6
	// IRC 48 MHz clock
	SIM_SOPT2_CLKOUTSEL_111 = 0x7
	// Position of FBSL field.
	SIM_SOPT2_FBSL_Pos = 0x8
	// Bit mask of FBSL field.
	SIM_SOPT2_FBSL_Msk = 0x300
	// All off-chip accesses (instruction and data) via the FlexBus or SDRAM are disallowed.
	SIM_SOPT2_FBSL_00 = 0x0
	// All off-chip accesses (instruction and data) via the FlexBus or SDRAM are disallowed.
	SIM_SOPT2_FBSL_01 = 0x1
	// Off-chip instruction accesses are disallowed. Data accesses are allowed.
	SIM_SOPT2_FBSL_10 = 0x2
	// Off-chip instruction accesses and data accesses are allowed.
	SIM_SOPT2_FBSL_11 = 0x3
	// Position of TRACECLKSEL field.
	SIM_SOPT2_TRACECLKSEL_Pos = 0xc
	// Bit mask of TRACECLKSEL field.
	SIM_SOPT2_TRACECLKSEL_Msk = 0x1000
	// Bit TRACECLKSEL.
	SIM_SOPT2_TRACECLKSEL = 0x1000
	// MCGOUTCLK, divided by the TRACECLK fractional divider as configured by SIM_CLKDIV4[TRACEFRAC, TRACEDIV]
	SIM_SOPT2_TRACECLKSEL_0 = 0x0
	// Core/system clock
	SIM_SOPT2_TRACECLKSEL_1 = 0x1
	// Position of PLLFLLSEL field.
	SIM_SOPT2_PLLFLLSEL_Pos = 0x10
	// Bit mask of PLLFLLSEL field.
	SIM_SOPT2_PLLFLLSEL_Msk = 0x30000
	// MCGFLLCLK clock
	SIM_SOPT2_PLLFLLSEL_00 = 0x0
	// MCGPLLCLK clock
	SIM_SOPT2_PLLFLLSEL_01 = 0x1
	// USB1 PFD clock
	SIM_SOPT2_PLLFLLSEL_10 = 0x2
	// IRC48 MHz clock
	SIM_SOPT2_PLLFLLSEL_11 = 0x3
	// Position of USBSRC field.
	SIM_SOPT2_USBSRC_Pos = 0x12
	// Bit mask of USBSRC field.
	SIM_SOPT2_USBSRC_Msk = 0x40000
	// Bit USBSRC.
	SIM_SOPT2_USBSRC = 0x40000
	// External bypass clock (USB_CLKIN).
	SIM_SOPT2_USBSRC_0 = 0x0
	// MCGFLLCLK, or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL], and then divided by the USB fractional divider as configured by SIM_CLKDIV2[USBFRAC, USBDIV].
	SIM_SOPT2_USBSRC_1 = 0x1
	// Position of RMIISRC field.
	SIM_SOPT2_RMIISRC_Pos = 0x13
	// Bit mask of RMIISRC field.
	SIM_SOPT2_RMIISRC_Msk = 0x80000
	// Bit RMIISRC.
	SIM_SOPT2_RMIISRC = 0x80000
	// EXTAL clock
	SIM_SOPT2_RMIISRC_0 = 0x0
	// External bypass clock (ENET_1588_CLKIN).
	SIM_SOPT2_RMIISRC_1 = 0x1
	// Position of TIMESRC field.
	SIM_SOPT2_TIMESRC_Pos = 0x14
	// Bit mask of TIMESRC field.
	SIM_SOPT2_TIMESRC_Msk = 0x300000
	// Core/system clock.
	SIM_SOPT2_TIMESRC_00 = 0x0
	// MCGFLLCLK , or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL].
	SIM_SOPT2_TIMESRC_01 = 0x1
	// OSCERCLK clock
	SIM_SOPT2_TIMESRC_10 = 0x2
	// External bypass clock (ENET_1588_CLKIN).
	SIM_SOPT2_TIMESRC_11 = 0x3
	// Position of TPMSRC field.
	SIM_SOPT2_TPMSRC_Pos = 0x18
	// Bit mask of TPMSRC field.
	SIM_SOPT2_TPMSRC_Msk = 0x3000000
	// Clock disabled
	SIM_SOPT2_TPMSRC_00 = 0x0
	// MCGFLLCLK , or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL], and then divided by the PLLFLLCLK fractional divider as configured by SIM_CLKDIV3[PLLFLLFRAC, PLLFLLDIV].
	SIM_SOPT2_TPMSRC_01 = 0x1
	// OSCERCLK clock
	SIM_SOPT2_TPMSRC_10 = 0x2
	// MCGIRCLK clock
	SIM_SOPT2_TPMSRC_11 = 0x3
	// Position of LPUARTSRC field.
	SIM_SOPT2_LPUARTSRC_Pos = 0x1a
	// Bit mask of LPUARTSRC field.
	SIM_SOPT2_LPUARTSRC_Msk = 0xc000000
	// Clock disabled
	SIM_SOPT2_LPUARTSRC_00 = 0x0
	// MCGFLLCLK , or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL], and then divided by the PLLFLLCLK fractional divider as configured by SIM_CLKDIV3[PLLFLLFRAC, PLLFLLDIV].
	SIM_SOPT2_LPUARTSRC_01 = 0x1
	// OSCERCLK clock
	SIM_SOPT2_LPUARTSRC_10 = 0x2
	// MCGIRCLK clock
	SIM_SOPT2_LPUARTSRC_11 = 0x3
	// Position of SDHCSRC field.
	SIM_SOPT2_SDHCSRC_Pos = 0x1c
	// Bit mask of SDHCSRC field.
	SIM_SOPT2_SDHCSRC_Msk = 0x30000000
	// Core/system clock.
	SIM_SOPT2_SDHCSRC_00 = 0x0
	// MCGFLLCLK, or MCGPLLCLK , or IRC48M , or USB1 PFD clock as selected by SOPT2[PLLFLLSEL].
	SIM_SOPT2_SDHCSRC_01 = 0x1
	// OSCERCLK clock
	SIM_SOPT2_SDHCSRC_10 = 0x2
	// External bypass clock (SDHC0_CLKIN)
	SIM_SOPT2_SDHCSRC_11 = 0x3

	// SOPT4: System Options Register 4
	// Position of FTM0FLT0 field.
	SIM_SOPT4_FTM0FLT0_Pos = 0x0
	// Bit mask of FTM0FLT0 field.
	SIM_SOPT4_FTM0FLT0_Msk = 0x1
	// Bit FTM0FLT0.
	SIM_SOPT4_FTM0FLT0 = 0x1
	// FTM0_FLT0 pin
	SIM_SOPT4_FTM0FLT0_0 = 0x0
	// CMP0 out
	SIM_SOPT4_FTM0FLT0_1 = 0x1
	// Position of FTM0FLT1 field.
	SIM_SOPT4_FTM0FLT1_Pos = 0x1
	// Bit mask of FTM0FLT1 field.
	SIM_SOPT4_FTM0FLT1_Msk = 0x2
	// Bit FTM0FLT1.
	SIM_SOPT4_FTM0FLT1 = 0x2
	// FTM0_FLT1 pin
	SIM_SOPT4_FTM0FLT1_0 = 0x0
	// CMP1 out
	SIM_SOPT4_FTM0FLT1_1 = 0x1
	// Position of FTM0FLT2 field.
	SIM_SOPT4_FTM0FLT2_Pos = 0x2
	// Bit mask of FTM0FLT2 field.
	SIM_SOPT4_FTM0FLT2_Msk = 0x4
	// Bit FTM0FLT2.
	SIM_SOPT4_FTM0FLT2 = 0x4
	// FTM0_FLT2 pin
	SIM_SOPT4_FTM0FLT2_0 = 0x0
	// CMP2 out
	SIM_SOPT4_FTM0FLT2_1 = 0x1
	// Position of FTM0FLT3 field.
	SIM_SOPT4_FTM0FLT3_Pos = 0x3
	// Bit mask of FTM0FLT3 field.
	SIM_SOPT4_FTM0FLT3_Msk = 0x8
	// Bit FTM0FLT3.
	SIM_SOPT4_FTM0FLT3 = 0x8
	// FTM0_FLT3 pin
	SIM_SOPT4_FTM0FLT3_0 = 0x0
	// CMP3 out
	SIM_SOPT4_FTM0FLT3_1 = 0x1
	// Position of FTM1FLT0 field.
	SIM_SOPT4_FTM1FLT0_Pos = 0x4
	// Bit mask of FTM1FLT0 field.
	SIM_SOPT4_FTM1FLT0_Msk = 0x10
	// Bit FTM1FLT0.
	SIM_SOPT4_FTM1FLT0 = 0x10
	// FTM1_FLT0 pin
	SIM_SOPT4_FTM1FLT0_0 = 0x0
	// CMP0 out
	SIM_SOPT4_FTM1FLT0_1 = 0x1
	// Position of FTM2FLT0 field.
	SIM_SOPT4_FTM2FLT0_Pos = 0x8
	// Bit mask of FTM2FLT0 field.
	SIM_SOPT4_FTM2FLT0_Msk = 0x100
	// Bit FTM2FLT0.
	SIM_SOPT4_FTM2FLT0 = 0x100
	// FTM2_FLT0 pin
	SIM_SOPT4_FTM2FLT0_0 = 0x0
	// CMP0 out
	SIM_SOPT4_FTM2FLT0_1 = 0x1
	// Position of FTM3FLT0 field.
	SIM_SOPT4_FTM3FLT0_Pos = 0xc
	// Bit mask of FTM3FLT0 field.
	SIM_SOPT4_FTM3FLT0_Msk = 0x1000
	// Bit FTM3FLT0.
	SIM_SOPT4_FTM3FLT0 = 0x1000
	// FTM3_FLT0 pin
	SIM_SOPT4_FTM3FLT0_0 = 0x0
	// CMP0 out
	SIM_SOPT4_FTM3FLT0_1 = 0x1
	// Position of FTM1CH0SRC field.
	SIM_SOPT4_FTM1CH0SRC_Pos = 0x12
	// Bit mask of FTM1CH0SRC field.
	SIM_SOPT4_FTM1CH0SRC_Msk = 0xc0000
	// FTM1_CH0 signal
	SIM_SOPT4_FTM1CH0SRC_00 = 0x0
	// CMP0 output
	SIM_SOPT4_FTM1CH0SRC_01 = 0x1
	// CMP1 output
	SIM_SOPT4_FTM1CH0SRC_10 = 0x2
	// USB start of frame pulse
	SIM_SOPT4_FTM1CH0SRC_11 = 0x3
	// Position of FTM2CH0SRC field.
	SIM_SOPT4_FTM2CH0SRC_Pos = 0x14
	// Bit mask of FTM2CH0SRC field.
	SIM_SOPT4_FTM2CH0SRC_Msk = 0x300000
	// FTM2_CH0 signal
	SIM_SOPT4_FTM2CH0SRC_00 = 0x0
	// CMP0 output
	SIM_SOPT4_FTM2CH0SRC_01 = 0x1
	// CMP1 output
	SIM_SOPT4_FTM2CH0SRC_10 = 0x2
	// Position of FTM2CH1SRC field.
	SIM_SOPT4_FTM2CH1SRC_Pos = 0x16
	// Bit mask of FTM2CH1SRC field.
	SIM_SOPT4_FTM2CH1SRC_Msk = 0x400000
	// Bit FTM2CH1SRC.
	SIM_SOPT4_FTM2CH1SRC = 0x400000
	// FTM2_CH1 signal
	SIM_SOPT4_FTM2CH1SRC_0 = 0x0
	// Exclusive OR of FTM2_CH1, FTM2_CH0 and FTM1_CH1.
	SIM_SOPT4_FTM2CH1SRC_1 = 0x1
	// Position of FTM0CLKSEL field.
	SIM_SOPT4_FTM0CLKSEL_Pos = 0x18
	// Bit mask of FTM0CLKSEL field.
	SIM_SOPT4_FTM0CLKSEL_Msk = 0x1000000
	// Bit FTM0CLKSEL.
	SIM_SOPT4_FTM0CLKSEL = 0x1000000
	// FTM_CLK0 pin
	SIM_SOPT4_FTM0CLKSEL_0 = 0x0
	// FTM_CLK1 pin
	SIM_SOPT4_FTM0CLKSEL_1 = 0x1
	// Position of FTM1CLKSEL field.
	SIM_SOPT4_FTM1CLKSEL_Pos = 0x19
	// Bit mask of FTM1CLKSEL field.
	SIM_SOPT4_FTM1CLKSEL_Msk = 0x2000000
	// Bit FTM1CLKSEL.
	SIM_SOPT4_FTM1CLKSEL = 0x2000000
	// FTM_CLK0 pin
	SIM_SOPT4_FTM1CLKSEL_0 = 0x0
	// FTM_CLK1 pin
	SIM_SOPT4_FTM1CLKSEL_1 = 0x1
	// Position of FTM2CLKSEL field.
	SIM_SOPT4_FTM2CLKSEL_Pos = 0x1a
	// Bit mask of FTM2CLKSEL field.
	SIM_SOPT4_FTM2CLKSEL_Msk = 0x4000000
	// Bit FTM2CLKSEL.
	SIM_SOPT4_FTM2CLKSEL = 0x4000000
	// FTM2 external clock driven by FTM_CLK0 pin.
	SIM_SOPT4_FTM2CLKSEL_0 = 0x0
	// FTM2 external clock driven by FTM_CLK1 pin.
	SIM_SOPT4_FTM2CLKSEL_1 = 0x1
	// Position of FTM3CLKSEL field.
	SIM_SOPT4_FTM3CLKSEL_Pos = 0x1b
	// Bit mask of FTM3CLKSEL field.
	SIM_SOPT4_FTM3CLKSEL_Msk = 0x8000000
	// Bit FTM3CLKSEL.
	SIM_SOPT4_FTM3CLKSEL = 0x8000000
	// FTM3 external clock driven by FTM_CLK0 pin.
	SIM_SOPT4_FTM3CLKSEL_0 = 0x0
	// FTM3 external clock driven by FTM_CLK1 pin.
	SIM_SOPT4_FTM3CLKSEL_1 = 0x1
	// Position of FTM0TRG0SRC field.
	SIM_SOPT4_FTM0TRG0SRC_Pos = 0x1c
	// Bit mask of FTM0TRG0SRC field.
	SIM_SOPT4_FTM0TRG0SRC_Msk = 0x10000000
	// Bit FTM0TRG0SRC.
	SIM_SOPT4_FTM0TRG0SRC = 0x10000000
	// HSCMP0 output drives FTM0 hardware trigger 0
	SIM_SOPT4_FTM0TRG0SRC_0 = 0x0
	// FTM1 channel match drives FTM0 hardware trigger 0
	SIM_SOPT4_FTM0TRG0SRC_1 = 0x1
	// Position of FTM0TRG1SRC field.
	SIM_SOPT4_FTM0TRG1SRC_Pos = 0x1d
	// Bit mask of FTM0TRG1SRC field.
	SIM_SOPT4_FTM0TRG1SRC_Msk = 0x20000000
	// Bit FTM0TRG1SRC.
	SIM_SOPT4_FTM0TRG1SRC = 0x20000000
	// PDB output trigger 1 drives FTM0 hardware trigger 1
	SIM_SOPT4_FTM0TRG1SRC_0 = 0x0
	// FTM2 channel match drives FTM0 hardware trigger 1
	SIM_SOPT4_FTM0TRG1SRC_1 = 0x1
	// Position of FTM3TRG0SRC field.
	SIM_SOPT4_FTM3TRG0SRC_Pos = 0x1e
	// Bit mask of FTM3TRG0SRC field.
	SIM_SOPT4_FTM3TRG0SRC_Msk = 0x40000000
	// Bit FTM3TRG0SRC.
	SIM_SOPT4_FTM3TRG0SRC = 0x40000000
	// FTM1 channel match drives FTM3 hardware trigger 0
	SIM_SOPT4_FTM3TRG0SRC_1 = 0x1
	// Position of FTM3TRG1SRC field.
	SIM_SOPT4_FTM3TRG1SRC_Pos = 0x1f
	// Bit mask of FTM3TRG1SRC field.
	SIM_SOPT4_FTM3TRG1SRC_Msk = 0x80000000
	// Bit FTM3TRG1SRC.
	SIM_SOPT4_FTM3TRG1SRC = 0x80000000
	// FTM2 channel match drives FTM3 hardware trigger 1
	SIM_SOPT4_FTM3TRG1SRC_1 = 0x1

	// SOPT5: System Options Register 5
	// Position of UART0TXSRC field.
	SIM_SOPT5_UART0TXSRC_Pos = 0x0
	// Bit mask of UART0TXSRC field.
	SIM_SOPT5_UART0TXSRC_Msk = 0x3
	// UART0_TX pin
	SIM_SOPT5_UART0TXSRC_00 = 0x0
	// UART0_TX pin modulated with FTM1 channel 0 output
	SIM_SOPT5_UART0TXSRC_01 = 0x1
	// UART0_TX pin modulated with FTM2 channel 0 output
	SIM_SOPT5_UART0TXSRC_10 = 0x2
	// Position of UART0RXSRC field.
	SIM_SOPT5_UART0RXSRC_Pos = 0x2
	// Bit mask of UART0RXSRC field.
	SIM_SOPT5_UART0RXSRC_Msk = 0xc
	// UART0_RX pin
	SIM_SOPT5_UART0RXSRC_00 = 0x0
	// CMP0
	SIM_SOPT5_UART0RXSRC_01 = 0x1
	// CMP1
	SIM_SOPT5_UART0RXSRC_10 = 0x2
	// Position of UART1TXSRC field.
	SIM_SOPT5_UART1TXSRC_Pos = 0x4
	// Bit mask of UART1TXSRC field.
	SIM_SOPT5_UART1TXSRC_Msk = 0x30
	// UART1_TX pin
	SIM_SOPT5_UART1TXSRC_00 = 0x0
	// UART1_TX pin modulated with FTM1 channel 0 output
	SIM_SOPT5_UART1TXSRC_01 = 0x1
	// UART1_TX pin modulated with FTM2 channel 0 output
	SIM_SOPT5_UART1TXSRC_10 = 0x2
	// Position of UART1RXSRC field.
	SIM_SOPT5_UART1RXSRC_Pos = 0x6
	// Bit mask of UART1RXSRC field.
	SIM_SOPT5_UART1RXSRC_Msk = 0xc0
	// UART1_RX pin
	SIM_SOPT5_UART1RXSRC_00 = 0x0
	// CMP0
	SIM_SOPT5_UART1RXSRC_01 = 0x1
	// CMP1
	SIM_SOPT5_UART1RXSRC_10 = 0x2
	// Position of LPUART0TXSRC field.
	SIM_SOPT5_LPUART0TXSRC_Pos = 0x10
	// Bit mask of LPUART0TXSRC field.
	SIM_SOPT5_LPUART0TXSRC_Msk = 0x30000
	// LPUART0_TX pin
	SIM_SOPT5_LPUART0TXSRC_00 = 0x0
	// LPUART0_TX pin modulated with TPM1 channel 0 output
	SIM_SOPT5_LPUART0TXSRC_01 = 0x1
	// LPUART0_TX pin modulated with TPM2 channel 0 output
	SIM_SOPT5_LPUART0TXSRC_10 = 0x2
	// Position of LPUART0RXSRC field.
	SIM_SOPT5_LPUART0RXSRC_Pos = 0x12
	// Bit mask of LPUART0RXSRC field.
	SIM_SOPT5_LPUART0RXSRC_Msk = 0xc0000
	// LPUART0_RX pin
	SIM_SOPT5_LPUART0RXSRC_00 = 0x0
	// CMP0 output
	SIM_SOPT5_LPUART0RXSRC_01 = 0x1
	// CMP1 output
	SIM_SOPT5_LPUART0RXSRC_10 = 0x2

	// SOPT7: System Options Register 7
	// Position of ADC0TRGSEL field.
	SIM_SOPT7_ADC0TRGSEL_Pos = 0x0
	// Bit mask of ADC0TRGSEL field.
	SIM_SOPT7_ADC0TRGSEL_Msk = 0xf
	// PDB external trigger pin input (PDB0_EXTRG)
	SIM_SOPT7_ADC0TRGSEL_0000 = 0x0
	// High speed comparator 0 output
	SIM_SOPT7_ADC0TRGSEL_0001 = 0x1
	// High speed comparator 1 output
	SIM_SOPT7_ADC0TRGSEL_0010 = 0x2
	// High speed comparator 2 output
	SIM_SOPT7_ADC0TRGSEL_0011 = 0x3
	// PIT trigger 0
	SIM_SOPT7_ADC0TRGSEL_0100 = 0x4
	// PIT trigger 1
	SIM_SOPT7_ADC0TRGSEL_0101 = 0x5
	// PIT trigger 2
	SIM_SOPT7_ADC0TRGSEL_0110 = 0x6
	// PIT trigger 3
	SIM_SOPT7_ADC0TRGSEL_0111 = 0x7
	// FTM0 trigger
	SIM_SOPT7_ADC0TRGSEL_1000 = 0x8
	// FTM1 trigger
	SIM_SOPT7_ADC0TRGSEL_1001 = 0x9
	// FTM2 trigger
	SIM_SOPT7_ADC0TRGSEL_1010 = 0xa
	// FTM3 trigger
	SIM_SOPT7_ADC0TRGSEL_1011 = 0xb
	// RTC alarm
	SIM_SOPT7_ADC0TRGSEL_1100 = 0xc
	// RTC seconds
	SIM_SOPT7_ADC0TRGSEL_1101 = 0xd
	// Low-power timer (LPTMR) trigger
	SIM_SOPT7_ADC0TRGSEL_1110 = 0xe
	// TPM1 channel 0 (A pretrigger) and channel 1 (B pretrigger)
	SIM_SOPT7_ADC0TRGSEL_1111 = 0xf
	// Position of ADC0PRETRGSEL field.
	SIM_SOPT7_ADC0PRETRGSEL_Pos = 0x4
	// Bit mask of ADC0PRETRGSEL field.
	SIM_SOPT7_ADC0PRETRGSEL_Msk = 0x10
	// Bit ADC0PRETRGSEL.
	SIM_SOPT7_ADC0PRETRGSEL = 0x10
	// Pre-trigger A
	SIM_SOPT7_ADC0PRETRGSEL_0 = 0x0
	// Pre-trigger B
	SIM_SOPT7_ADC0PRETRGSEL_1 = 0x1
	// Position of ADC0ALTTRGEN field.
	SIM_SOPT7_ADC0ALTTRGEN_Pos = 0x7
	// Bit mask of ADC0ALTTRGEN field.
	SIM_SOPT7_ADC0ALTTRGEN_Msk = 0x80
	// Bit ADC0ALTTRGEN.
	SIM_SOPT7_ADC0ALTTRGEN = 0x80
	// PDB trigger selected for ADC0.
	SIM_SOPT7_ADC0ALTTRGEN_0 = 0x0
	// Alternate trigger selected for ADC0.
	SIM_SOPT7_ADC0ALTTRGEN_1 = 0x1
	// Position of ADC1TRGSEL field.
	SIM_SOPT7_ADC1TRGSEL_Pos = 0x8
	// Bit mask of ADC1TRGSEL field.
	SIM_SOPT7_ADC1TRGSEL_Msk = 0xf00
	// PDB external trigger pin input (PDB0_EXTRG)
	SIM_SOPT7_ADC1TRGSEL_0000 = 0x0
	// High speed comparator 0 output
	SIM_SOPT7_ADC1TRGSEL_0001 = 0x1
	// High speed comparator 1 output
	SIM_SOPT7_ADC1TRGSEL_0010 = 0x2
	// High speed comparator 2 output
	SIM_SOPT7_ADC1TRGSEL_0011 = 0x3
	// PIT trigger 0
	SIM_SOPT7_ADC1TRGSEL_0100 = 0x4
	// PIT trigger 1
	SIM_SOPT7_ADC1TRGSEL_0101 = 0x5
	// PIT trigger 2
	SIM_SOPT7_ADC1TRGSEL_0110 = 0x6
	// PIT trigger 3
	SIM_SOPT7_ADC1TRGSEL_0111 = 0x7
	// FTM0 trigger
	SIM_SOPT7_ADC1TRGSEL_1000 = 0x8
	// FTM1 trigger
	SIM_SOPT7_ADC1TRGSEL_1001 = 0x9
	// FTM2 trigger
	SIM_SOPT7_ADC1TRGSEL_1010 = 0xa
	// FTM3 trigger
	SIM_SOPT7_ADC1TRGSEL_1011 = 0xb
	// RTC alarm
	SIM_SOPT7_ADC1TRGSEL_1100 = 0xc
	// RTC seconds
	SIM_SOPT7_ADC1TRGSEL_1101 = 0xd
	// Low-power timer (LPTMR) trigger
	SIM_SOPT7_ADC1TRGSEL_1110 = 0xe
	// TPM2 channel 0 (A pretrigger) and channel 1 (B pretrigger)
	SIM_SOPT7_ADC1TRGSEL_1111 = 0xf
	// Position of ADC1PRETRGSEL field.
	SIM_SOPT7_ADC1PRETRGSEL_Pos = 0xc
	// Bit mask of ADC1PRETRGSEL field.
	SIM_SOPT7_ADC1PRETRGSEL_Msk = 0x1000
	// Bit ADC1PRETRGSEL.
	SIM_SOPT7_ADC1PRETRGSEL = 0x1000
	// Pre-trigger A selected for ADC1.
	SIM_SOPT7_ADC1PRETRGSEL_0 = 0x0
	// Pre-trigger B selected for ADC1.
	SIM_SOPT7_ADC1PRETRGSEL_1 = 0x1
	// Position of ADC1ALTTRGEN field.
	SIM_SOPT7_ADC1ALTTRGEN_Pos = 0xf
	// Bit mask of ADC1ALTTRGEN field.
	SIM_SOPT7_ADC1ALTTRGEN_Msk = 0x8000
	// Bit ADC1ALTTRGEN.
	SIM_SOPT7_ADC1ALTTRGEN = 0x8000
	// PDB trigger selected for ADC1
	SIM_SOPT7_ADC1ALTTRGEN_0 = 0x0
	// Alternate trigger selected for ADC1 as defined by ADC1TRGSEL.
	SIM_SOPT7_ADC1ALTTRGEN_1 = 0x1

	// SOPT8: System Options Register 8
	// Position of FTM0SYNCBIT field.
	SIM_SOPT8_FTM0SYNCBIT_Pos = 0x0
	// Bit mask of FTM0SYNCBIT field.
	SIM_SOPT8_FTM0SYNCBIT_Msk = 0x1
	// Bit FTM0SYNCBIT.
	SIM_SOPT8_FTM0SYNCBIT = 0x1
	// No effect
	SIM_SOPT8_FTM0SYNCBIT_0 = 0x0
	// Write 1 to assert the TRIG0 input to FTM0, software must clear this bit to allow other trigger sources to assert.
	SIM_SOPT8_FTM0SYNCBIT_1 = 0x1
	// Position of FTM1SYNCBIT field.
	SIM_SOPT8_FTM1SYNCBIT_Pos = 0x1
	// Bit mask of FTM1SYNCBIT field.
	SIM_SOPT8_FTM1SYNCBIT_Msk = 0x2
	// Bit FTM1SYNCBIT.
	SIM_SOPT8_FTM1SYNCBIT = 0x2
	// No effect.
	SIM_SOPT8_FTM1SYNCBIT_0 = 0x0
	// Write 1 to assert the TRIG0 input to FTM1, software must clear this bit to allow other trigger sources to assert.
	SIM_SOPT8_FTM1SYNCBIT_1 = 0x1
	// Position of FTM2SYNCBIT field.
	SIM_SOPT8_FTM2SYNCBIT_Pos = 0x2
	// Bit mask of FTM2SYNCBIT field.
	SIM_SOPT8_FTM2SYNCBIT_Msk = 0x4
	// Bit FTM2SYNCBIT.
	SIM_SOPT8_FTM2SYNCBIT = 0x4
	// No effect.
	SIM_SOPT8_FTM2SYNCBIT_0 = 0x0
	// Write 1 to assert the TRIG0 input to FTM2, software must clear this bit to allow other trigger sources to assert.
	SIM_SOPT8_FTM2SYNCBIT_1 = 0x1
	// Position of FTM3SYNCBIT field.
	SIM_SOPT8_FTM3SYNCBIT_Pos = 0x3
	// Bit mask of FTM3SYNCBIT field.
	SIM_SOPT8_FTM3SYNCBIT_Msk = 0x8
	// Bit FTM3SYNCBIT.
	SIM_SOPT8_FTM3SYNCBIT = 0x8
	// No effect.
	SIM_SOPT8_FTM3SYNCBIT_0 = 0x0
	// Write 1 to assert the TRIG0 input to FTM3, software must clear this bit to allow other trigger sources to assert.
	SIM_SOPT8_FTM3SYNCBIT_1 = 0x1
	// Position of FTM0OCH0SRC field.
	SIM_SOPT8_FTM0OCH0SRC_Pos = 0x10
	// Bit mask of FTM0OCH0SRC field.
	SIM_SOPT8_FTM0OCH0SRC_Msk = 0x10000
	// Bit FTM0OCH0SRC.
	SIM_SOPT8_FTM0OCH0SRC = 0x10000
	// FTM0_CH0 pin is output of FTM0 channel 0 output
	SIM_SOPT8_FTM0OCH0SRC_0 = 0x0
	// FTM0_CH0 pin is output of FTM0 channel 0 output, modulated by FTM1 channel 1 output
	SIM_SOPT8_FTM0OCH0SRC_1 = 0x1
	// Position of FTM0OCH1SRC field.
	SIM_SOPT8_FTM0OCH1SRC_Pos = 0x11
	// Bit mask of FTM0OCH1SRC field.
	SIM_SOPT8_FTM0OCH1SRC_Msk = 0x20000
	// Bit FTM0OCH1SRC.
	SIM_SOPT8_FTM0OCH1SRC = 0x20000
	// FTM0_CH1 pin is output of FTM0 channel 1 output
	SIM_SOPT8_FTM0OCH1SRC_0 = 0x0
	// FTM0_CH1 pin is output of FTM0 channel 1 output, modulated by FTM1 channel 1 output
	SIM_SOPT8_FTM0OCH1SRC_1 = 0x1
	// Position of FTM0OCH2SRC field.
	SIM_SOPT8_FTM0OCH2SRC_Pos = 0x12
	// Bit mask of FTM0OCH2SRC field.
	SIM_SOPT8_FTM0OCH2SRC_Msk = 0x40000
	// Bit FTM0OCH2SRC.
	SIM_SOPT8_FTM0OCH2SRC = 0x40000
	// FTM0_CH2 pin is output of FTM0 channel 2 output
	SIM_SOPT8_FTM0OCH2SRC_0 = 0x0
	// FTM0_CH2 pin is output of FTM0 channel 2 output, modulated by FTM1 channel 1 output
	SIM_SOPT8_FTM0OCH2SRC_1 = 0x1
	// Position of FTM0OCH3SRC field.
	SIM_SOPT8_FTM0OCH3SRC_Pos = 0x13
	// Bit mask of FTM0OCH3SRC field.
	SIM_SOPT8_FTM0OCH3SRC_Msk = 0x80000
	// Bit FTM0OCH3SRC.
	SIM_SOPT8_FTM0OCH3SRC = 0x80000
	// FTM0_CH3 pin is output of FTM0 channel 3 output
	SIM_SOPT8_FTM0OCH3SRC_0 = 0x0
	// FTM0_CH3 pin is output of FTM0 channel 3 output, modulated by FTM1 channel 1 output
	SIM_SOPT8_FTM0OCH3SRC_1 = 0x1
	// Position of FTM0OCH4SRC field.
	SIM_SOPT8_FTM0OCH4SRC_Pos = 0x14
	// Bit mask of FTM0OCH4SRC field.
	SIM_SOPT8_FTM0OCH4SRC_Msk = 0x100000
	// Bit FTM0OCH4SRC.
	SIM_SOPT8_FTM0OCH4SRC = 0x100000
	// FTM0_CH4 pin is output of FTM0 channel 4 output
	SIM_SOPT8_FTM0OCH4SRC_0 = 0x0
	// FTM0_CH4 pin is output of FTM0 channel 4 output, modulated by FTM1 channel 1 output
	SIM_SOPT8_FTM0OCH4SRC_1 = 0x1
	// Position of FTM0OCH5SRC field.
	SIM_SOPT8_FTM0OCH5SRC_Pos = 0x15
	// Bit mask of FTM0OCH5SRC field.
	SIM_SOPT8_FTM0OCH5SRC_Msk = 0x200000
	// Bit FTM0OCH5SRC.
	SIM_SOPT8_FTM0OCH5SRC = 0x200000
	// FTM0_CH5 pin is output of FTM0 channel 5 output
	SIM_SOPT8_FTM0OCH5SRC_0 = 0x0
	// FTM0_CH5 pin is output of FTM0 channel 5 output, modulated by FTM1 channel 1 output
	SIM_SOPT8_FTM0OCH5SRC_1 = 0x1
	// Position of FTM0OCH6SRC field.
	SIM_SOPT8_FTM0OCH6SRC_Pos = 0x16
	// Bit mask of FTM0OCH6SRC field.
	SIM_SOPT8_FTM0OCH6SRC_Msk = 0x400000
	// Bit FTM0OCH6SRC.
	SIM_SOPT8_FTM0OCH6SRC = 0x400000
	// FTM0_CH6 pin is output of FTM0 channel 6 output
	SIM_SOPT8_FTM0OCH6SRC_0 = 0x0
	// FTM0_CH6 pin is output of FTM0 channel 6 output, modulated by FTM1 channel 1 output
	SIM_SOPT8_FTM0OCH6SRC_1 = 0x1
	// Position of FTM0OCH7SRC field.
	SIM_SOPT8_FTM0OCH7SRC_Pos = 0x17
	// Bit mask of FTM0OCH7SRC field.
	SIM_SOPT8_FTM0OCH7SRC_Msk = 0x800000
	// Bit FTM0OCH7SRC.
	SIM_SOPT8_FTM0OCH7SRC = 0x800000
	// FTM0_CH7 pin is output of FTM0 channel 7 output
	SIM_SOPT8_FTM0OCH7SRC_0 = 0x0
	// FTM0_CH7 pin is output of FTM0 channel 7 output, modulated by FTM1 channel 1 output
	SIM_SOPT8_FTM0OCH7SRC_1 = 0x1
	// Position of FTM3OCH0SRC field.
	SIM_SOPT8_FTM3OCH0SRC_Pos = 0x18
	// Bit mask of FTM3OCH0SRC field.
	SIM_SOPT8_FTM3OCH0SRC_Msk = 0x1000000
	// Bit FTM3OCH0SRC.
	SIM_SOPT8_FTM3OCH0SRC = 0x1000000
	// FTM3_CH0 pin is output of FTM3 channel 0 output
	SIM_SOPT8_FTM3OCH0SRC_0 = 0x0
	// FTM3_CH0 pin is output of FTM3 channel 0 output modulated by FTM2 channel 1 output.
	SIM_SOPT8_FTM3OCH0SRC_1 = 0x1
	// Position of FTM3OCH1SRC field.
	SIM_SOPT8_FTM3OCH1SRC_Pos = 0x19
	// Bit mask of FTM3OCH1SRC field.
	SIM_SOPT8_FTM3OCH1SRC_Msk = 0x2000000
	// Bit FTM3OCH1SRC.
	SIM_SOPT8_FTM3OCH1SRC = 0x2000000
	// FTM3_CH1 pin is output of FTM3 channel 1 output
	SIM_SOPT8_FTM3OCH1SRC_0 = 0x0
	// FTM3_CH1 pin is output of FTM3 channel 1 output modulated by FTM2 channel 1 output.
	SIM_SOPT8_FTM3OCH1SRC_1 = 0x1
	// Position of FTM3OCH2SRC field.
	SIM_SOPT8_FTM3OCH2SRC_Pos = 0x1a
	// Bit mask of FTM3OCH2SRC field.
	SIM_SOPT8_FTM3OCH2SRC_Msk = 0x4000000
	// Bit FTM3OCH2SRC.
	SIM_SOPT8_FTM3OCH2SRC = 0x4000000
	// FTM3_CH2 pin is output of FTM3 channel 2 output
	SIM_SOPT8_FTM3OCH2SRC_0 = 0x0
	// FTM3_CH2 pin is output of FTM3 channel 2 output modulated by FTM2 channel 1 output.
	SIM_SOPT8_FTM3OCH2SRC_1 = 0x1
	// Position of FTM3OCH3SRC field.
	SIM_SOPT8_FTM3OCH3SRC_Pos = 0x1b
	// Bit mask of FTM3OCH3SRC field.
	SIM_SOPT8_FTM3OCH3SRC_Msk = 0x8000000
	// Bit FTM3OCH3SRC.
	SIM_SOPT8_FTM3OCH3SRC = 0x8000000
	// FTM3_CH3 pin is output of FTM3 channel 3 output
	SIM_SOPT8_FTM3OCH3SRC_0 = 0x0
	// FTM3_CH3 pin is output of FTM3 channel 3 output modulated by FTM2 channel 1 output.
	SIM_SOPT8_FTM3OCH3SRC_1 = 0x1
	// Position of FTM3OCH4SRC field.
	SIM_SOPT8_FTM3OCH4SRC_Pos = 0x1c
	// Bit mask of FTM3OCH4SRC field.
	SIM_SOPT8_FTM3OCH4SRC_Msk = 0x10000000
	// Bit FTM3OCH4SRC.
	SIM_SOPT8_FTM3OCH4SRC = 0x10000000
	// FTM3_CH4 pin is output of FTM3 channel 4 output
	SIM_SOPT8_FTM3OCH4SRC_0 = 0x0
	// FTM3_CH4 pin is output of FTM3 channel 4 output modulated by FTM2 channel 1 output.
	SIM_SOPT8_FTM3OCH4SRC_1 = 0x1
	// Position of FTM3OCH5SRC field.
	SIM_SOPT8_FTM3OCH5SRC_Pos = 0x1d
	// Bit mask of FTM3OCH5SRC field.
	SIM_SOPT8_FTM3OCH5SRC_Msk = 0x20000000
	// Bit FTM3OCH5SRC.
	SIM_SOPT8_FTM3OCH5SRC = 0x20000000
	// FTM3_CH5 pin is output of FTM3 channel 5 output
	SIM_SOPT8_FTM3OCH5SRC_0 = 0x0
	// FTM3_CH5 pin is output of FTM3 channel 5 output modulated by FTM2 channel 1 output.
	SIM_SOPT8_FTM3OCH5SRC_1 = 0x1
	// Position of FTM3OCH6SRC field.
	SIM_SOPT8_FTM3OCH6SRC_Pos = 0x1e
	// Bit mask of FTM3OCH6SRC field.
	SIM_SOPT8_FTM3OCH6SRC_Msk = 0x40000000
	// Bit FTM3OCH6SRC.
	SIM_SOPT8_FTM3OCH6SRC = 0x40000000
	// FTM3_CH6 pin is output of FTM3 channel 6 output
	SIM_SOPT8_FTM3OCH6SRC_0 = 0x0
	// FTM3_CH6 pin is output of FTM3 channel 6 output modulated by FTM2 channel 1 output.
	SIM_SOPT8_FTM3OCH6SRC_1 = 0x1
	// Position of FTM3OCH7SRC field.
	SIM_SOPT8_FTM3OCH7SRC_Pos = 0x1f
	// Bit mask of FTM3OCH7SRC field.
	SIM_SOPT8_FTM3OCH7SRC_Msk = 0x80000000
	// Bit FTM3OCH7SRC.
	SIM_SOPT8_FTM3OCH7SRC = 0x80000000
	// FTM3_CH7 pin is output of FTM3 channel 7 output
	SIM_SOPT8_FTM3OCH7SRC_0 = 0x0
	// FTM3_CH7 pin is output of FTM3 channel 7 output modulated by FTM2 channel 1 output.
	SIM_SOPT8_FTM3OCH7SRC_1 = 0x1

	// SOPT9: System Options Register 9
	// Position of TPM1CH0SRC field.
	SIM_SOPT9_TPM1CH0SRC_Pos = 0x12
	// Bit mask of TPM1CH0SRC field.
	SIM_SOPT9_TPM1CH0SRC_Msk = 0xc0000
	// TPM1_CH0 signal
	SIM_SOPT9_TPM1CH0SRC_00 = 0x0
	// CMP0 output
	SIM_SOPT9_TPM1CH0SRC_01 = 0x1
	// CMP1 output
	SIM_SOPT9_TPM1CH0SRC_10 = 0x2
	// Position of TPM2CH0SRC field.
	SIM_SOPT9_TPM2CH0SRC_Pos = 0x14
	// Bit mask of TPM2CH0SRC field.
	SIM_SOPT9_TPM2CH0SRC_Msk = 0x300000
	// TPM2_CH0 signal
	SIM_SOPT9_TPM2CH0SRC_00 = 0x0
	// CMP0 output
	SIM_SOPT9_TPM2CH0SRC_01 = 0x1
	// CMP1 output
	SIM_SOPT9_TPM2CH0SRC_10 = 0x2
	// Position of TPM1CLKSEL field.
	SIM_SOPT9_TPM1CLKSEL_Pos = 0x19
	// Bit mask of TPM1CLKSEL field.
	SIM_SOPT9_TPM1CLKSEL_Msk = 0x2000000
	// Bit TPM1CLKSEL.
	SIM_SOPT9_TPM1CLKSEL = 0x2000000
	// TPM_CLKIN0 pin
	SIM_SOPT9_TPM1CLKSEL_0 = 0x0
	// TPM_CLKIN1 pin
	SIM_SOPT9_TPM1CLKSEL_1 = 0x1
	// Position of TPM2CLKSEL field.
	SIM_SOPT9_TPM2CLKSEL_Pos = 0x1a
	// Bit mask of TPM2CLKSEL field.
	SIM_SOPT9_TPM2CLKSEL_Msk = 0x4000000
	// Bit TPM2CLKSEL.
	SIM_SOPT9_TPM2CLKSEL = 0x4000000
	// TPM_CLKIN0 pin
	SIM_SOPT9_TPM2CLKSEL_0 = 0x0
	// TPM_CLKIN1 pin
	SIM_SOPT9_TPM2CLKSEL_1 = 0x1

	// SDID: System Device Identification Register
	// Position of PINID field.
	SIM_SDID_PINID_Pos = 0x0
	// Bit mask of PINID field.
	SIM_SDID_PINID_Msk = 0xf
	// 32-pin
	SIM_SDID_PINID_0010 = 0x2
	// 48-pin
	SIM_SDID_PINID_0100 = 0x4
	// 64-pin
	SIM_SDID_PINID_0101 = 0x5
	// 80-pin
	SIM_SDID_PINID_0110 = 0x6
	// 81-pin or 121-pin
	SIM_SDID_PINID_0111 = 0x7
	// 100-pin
	SIM_SDID_PINID_1000 = 0x8
	// 121-pin
	SIM_SDID_PINID_1001 = 0x9
	// 144-pin
	SIM_SDID_PINID_1010 = 0xa
	// Custom pinout (WLCSP)
	SIM_SDID_PINID_1011 = 0xb
	// 169-pin
	SIM_SDID_PINID_1100 = 0xc
	// 256-pin
	SIM_SDID_PINID_1110 = 0xe
	// Position of FAMID field.
	SIM_SDID_FAMID_Pos = 0x4
	// Bit mask of FAMID field.
	SIM_SDID_FAMID_Msk = 0x70
	// K1x Family (without tamper)
	SIM_SDID_FAMID_000 = 0x0
	// K2x Family (without tamper)
	SIM_SDID_FAMID_001 = 0x1
	// K3x Family or K1x/K6x Family (with tamper)
	SIM_SDID_FAMID_010 = 0x2
	// K4x Family or K2x Family (with tamper)
	SIM_SDID_FAMID_011 = 0x3
	// K6x Family (without tamper)
	SIM_SDID_FAMID_100 = 0x4
	// K7x Family
	SIM_SDID_FAMID_101 = 0x5
	// Position of DIEID field.
	SIM_SDID_DIEID_Pos = 0x7
	// Bit mask of DIEID field.
	SIM_SDID_DIEID_Msk = 0xf80
	// Position of REVID field.
	SIM_SDID_REVID_Pos = 0xc
	// Bit mask of REVID field.
	SIM_SDID_REVID_Msk = 0xf000
	// Position of SERIESID field.
	SIM_SDID_SERIESID_Pos = 0x14
	// Bit mask of SERIESID field.
	SIM_SDID_SERIESID_Msk = 0xf00000
	// Kinetis K series
	SIM_SDID_SERIESID_0000 = 0x0
	// Kinetis L series
	SIM_SDID_SERIESID_0001 = 0x1
	// Kinetis W series
	SIM_SDID_SERIESID_0101 = 0x5
	// Kinetis V series
	SIM_SDID_SERIESID_0110 = 0x6
	// Position of SUBFAMID field.
	SIM_SDID_SUBFAMID_Pos = 0x18
	// Bit mask of SUBFAMID field.
	SIM_SDID_SUBFAMID_Msk = 0xf000000
	// Kx0 Subfamily
	SIM_SDID_SUBFAMID_0000 = 0x0
	// Kx1 Subfamily (tamper detect)
	SIM_SDID_SUBFAMID_0001 = 0x1
	// Kx2 Subfamily
	SIM_SDID_SUBFAMID_0010 = 0x2
	// Kx3 Subfamily (tamper detect)
	SIM_SDID_SUBFAMID_0011 = 0x3
	// Kx4 Subfamily
	SIM_SDID_SUBFAMID_0100 = 0x4
	// Kx5 Subfamily (tamper detect)
	SIM_SDID_SUBFAMID_0101 = 0x5
	// Kx6 Subfamily
	SIM_SDID_SUBFAMID_0110 = 0x6
	// Position of FAMILYID field.
	SIM_SDID_FAMILYID_Pos = 0x1c
	// Bit mask of FAMILYID field.
	SIM_SDID_FAMILYID_Msk = 0xf0000000
	// K0x Family
	SIM_SDID_FAMILYID_0000 = 0x0
	// K1x Family
	SIM_SDID_FAMILYID_0001 = 0x1
	// K2x Family
	SIM_SDID_FAMILYID_0010 = 0x2
	// K3x Family
	SIM_SDID_FAMILYID_0011 = 0x3
	// K4x Family
	SIM_SDID_FAMILYID_0100 = 0x4
	// K6x Family
	SIM_SDID_FAMILYID_0110 = 0x6
	// K7x Family
	SIM_SDID_FAMILYID_0111 = 0x7
	// K8x Family
	SIM_SDID_FAMILYID_1000 = 0x8

	// SCGC1: System Clock Gating Control Register 1
	// Position of I2C2 field.
	SIM_SCGC1_I2C2_Pos = 0x6
	// Bit mask of I2C2 field.
	SIM_SCGC1_I2C2_Msk = 0x40
	// Bit I2C2.
	SIM_SCGC1_I2C2 = 0x40
	// Clock disabled
	SIM_SCGC1_I2C2_0 = 0x0
	// Clock enabled
	SIM_SCGC1_I2C2_1 = 0x1
	// Position of I2C3 field.
	SIM_SCGC1_I2C3_Pos = 0x7
	// Bit mask of I2C3 field.
	SIM_SCGC1_I2C3_Msk = 0x80
	// Bit I2C3.
	SIM_SCGC1_I2C3 = 0x80
	// Clock disabled
	SIM_SCGC1_I2C3_0 = 0x0
	// Clock enabled
	SIM_SCGC1_I2C3_1 = 0x1
	// Position of UART4 field.
	SIM_SCGC1_UART4_Pos = 0xa
	// Bit mask of UART4 field.
	SIM_SCGC1_UART4_Msk = 0x400
	// Bit UART4.
	SIM_SCGC1_UART4 = 0x400
	// Clock disabled
	SIM_SCGC1_UART4_0 = 0x0
	// Clock enabled
	SIM_SCGC1_UART4_1 = 0x1

	// SCGC2: System Clock Gating Control Register 2
	// Position of ENET field.
	SIM_SCGC2_ENET_Pos = 0x0
	// Bit mask of ENET field.
	SIM_SCGC2_ENET_Msk = 0x1
	// Bit ENET.
	SIM_SCGC2_ENET = 0x1
	// Clock disabled
	SIM_SCGC2_ENET_0 = 0x0
	// Clock enabled
	SIM_SCGC2_ENET_1 = 0x1
	// Position of LPUART0 field.
	SIM_SCGC2_LPUART0_Pos = 0x4
	// Bit mask of LPUART0 field.
	SIM_SCGC2_LPUART0_Msk = 0x10
	// Bit LPUART0.
	SIM_SCGC2_LPUART0 = 0x10
	// Clock disabled
	SIM_SCGC2_LPUART0_0 = 0x0
	// Clock enabled
	SIM_SCGC2_LPUART0_1 = 0x1
	// Position of TPM1 field.
	SIM_SCGC2_TPM1_Pos = 0x9
	// Bit mask of TPM1 field.
	SIM_SCGC2_TPM1_Msk = 0x200
	// Bit TPM1.
	SIM_SCGC2_TPM1 = 0x200
	// Clock disabled
	SIM_SCGC2_TPM1_0 = 0x0
	// Clock enabled
	SIM_SCGC2_TPM1_1 = 0x1
	// Position of TPM2 field.
	SIM_SCGC2_TPM2_Pos = 0xa
	// Bit mask of TPM2 field.
	SIM_SCGC2_TPM2_Msk = 0x400
	// Bit TPM2.
	SIM_SCGC2_TPM2 = 0x400
	// Clock disabled
	SIM_SCGC2_TPM2_0 = 0x0
	// Clock enabled
	SIM_SCGC2_TPM2_1 = 0x1
	// Position of DAC0 field.
	SIM_SCGC2_DAC0_Pos = 0xc
	// Bit mask of DAC0 field.
	SIM_SCGC2_DAC0_Msk = 0x1000
	// Bit DAC0.
	SIM_SCGC2_DAC0 = 0x1000
	// Clock disabled
	SIM_SCGC2_DAC0_0 = 0x0
	// Clock enabled
	SIM_SCGC2_DAC0_1 = 0x1
	// Position of DAC1 field.
	SIM_SCGC2_DAC1_Pos = 0xd
	// Bit mask of DAC1 field.
	SIM_SCGC2_DAC1_Msk = 0x2000
	// Bit DAC1.
	SIM_SCGC2_DAC1 = 0x2000
	// Clock disabled
	SIM_SCGC2_DAC1_0 = 0x0
	// Clock enabled
	SIM_SCGC2_DAC1_1 = 0x1

	// SCGC3: System Clock Gating Control Register 3
	// Position of RNGA field.
	SIM_SCGC3_RNGA_Pos = 0x0
	// Bit mask of RNGA field.
	SIM_SCGC3_RNGA_Msk = 0x1
	// Bit RNGA.
	SIM_SCGC3_RNGA = 0x1
	// Clock disabled
	SIM_SCGC3_RNGA_0 = 0x0
	// Clock enabled
	SIM_SCGC3_RNGA_1 = 0x1
	// Position of USBHS field.
	SIM_SCGC3_USBHS_Pos = 0x1
	// Bit mask of USBHS field.
	SIM_SCGC3_USBHS_Msk = 0x2
	// Bit USBHS.
	SIM_SCGC3_USBHS = 0x2
	// Clock disabled
	SIM_SCGC3_USBHS_0 = 0x0
	// Clock enabled
	SIM_SCGC3_USBHS_1 = 0x1
	// Position of USBHSPHY field.
	SIM_SCGC3_USBHSPHY_Pos = 0x2
	// Bit mask of USBHSPHY field.
	SIM_SCGC3_USBHSPHY_Msk = 0x4
	// Bit USBHSPHY.
	SIM_SCGC3_USBHSPHY = 0x4
	// Clock disabled
	SIM_SCGC3_USBHSPHY_0 = 0x0
	// Clock enabled
	SIM_SCGC3_USBHSPHY_1 = 0x1
	// Position of USBHSDCD field.
	SIM_SCGC3_USBHSDCD_Pos = 0x3
	// Bit mask of USBHSDCD field.
	SIM_SCGC3_USBHSDCD_Msk = 0x8
	// Bit USBHSDCD.
	SIM_SCGC3_USBHSDCD = 0x8
	// Clock disabled
	SIM_SCGC3_USBHSDCD_0 = 0x0
	// Clock enabled
	SIM_SCGC3_USBHSDCD_1 = 0x1
	// Position of FLEXCAN1 field.
	SIM_SCGC3_FLEXCAN1_Pos = 0x4
	// Bit mask of FLEXCAN1 field.
	SIM_SCGC3_FLEXCAN1_Msk = 0x10
	// Bit FLEXCAN1.
	SIM_SCGC3_FLEXCAN1 = 0x10
	// Clock disabled
	SIM_SCGC3_FLEXCAN1_0 = 0x0
	// Clock enabled
	SIM_SCGC3_FLEXCAN1_1 = 0x1
	// Position of SPI2 field.
	SIM_SCGC3_SPI2_Pos = 0xc
	// Bit mask of SPI2 field.
	SIM_SCGC3_SPI2_Msk = 0x1000
	// Bit SPI2.
	SIM_SCGC3_SPI2 = 0x1000
	// Clock disabled
	SIM_SCGC3_SPI2_0 = 0x0
	// Clock enabled
	SIM_SCGC3_SPI2_1 = 0x1
	// Position of SDHC field.
	SIM_SCGC3_SDHC_Pos = 0x11
	// Bit mask of SDHC field.
	SIM_SCGC3_SDHC_Msk = 0x20000
	// Bit SDHC.
	SIM_SCGC3_SDHC = 0x20000
	// Clock disabled
	SIM_SCGC3_SDHC_0 = 0x0
	// Clock enabled
	SIM_SCGC3_SDHC_1 = 0x1
	// Position of FTM2 field.
	SIM_SCGC3_FTM2_Pos = 0x18
	// Bit mask of FTM2 field.
	SIM_SCGC3_FTM2_Msk = 0x1000000
	// Bit FTM2.
	SIM_SCGC3_FTM2 = 0x1000000
	// Clock disabled
	SIM_SCGC3_FTM2_0 = 0x0
	// Clock enabled
	SIM_SCGC3_FTM2_1 = 0x1
	// Position of FTM3 field.
	SIM_SCGC3_FTM3_Pos = 0x19
	// Bit mask of FTM3 field.
	SIM_SCGC3_FTM3_Msk = 0x2000000
	// Bit FTM3.
	SIM_SCGC3_FTM3 = 0x2000000
	// Clock disabled
	SIM_SCGC3_FTM3_0 = 0x0
	// Clock enabled
	SIM_SCGC3_FTM3_1 = 0x1
	// Position of ADC1 field.
	SIM_SCGC3_ADC1_Pos = 0x1b
	// Bit mask of ADC1 field.
	SIM_SCGC3_ADC1_Msk = 0x8000000
	// Bit ADC1.
	SIM_SCGC3_ADC1 = 0x8000000
	// Clock disabled
	SIM_SCGC3_ADC1_0 = 0x0
	// Clock enabled
	SIM_SCGC3_ADC1_1 = 0x1

	// SCGC4: System Clock Gating Control Register 4
	// Position of EWM field.
	SIM_SCGC4_EWM_Pos = 0x1
	// Bit mask of EWM field.
	SIM_SCGC4_EWM_Msk = 0x2
	// Bit EWM.
	SIM_SCGC4_EWM = 0x2
	// Clock disabled
	SIM_SCGC4_EWM_0 = 0x0
	// Clock enabled
	SIM_SCGC4_EWM_1 = 0x1
	// Position of CMT field.
	SIM_SCGC4_CMT_Pos = 0x2
	// Bit mask of CMT field.
	SIM_SCGC4_CMT_Msk = 0x4
	// Bit CMT.
	SIM_SCGC4_CMT = 0x4
	// Clock disabled
	SIM_SCGC4_CMT_0 = 0x0
	// Clock enabled
	SIM_SCGC4_CMT_1 = 0x1
	// Position of I2C0 field.
	SIM_SCGC4_I2C0_Pos = 0x6
	// Bit mask of I2C0 field.
	SIM_SCGC4_I2C0_Msk = 0x40
	// Bit I2C0.
	SIM_SCGC4_I2C0 = 0x40
	// Clock disabled
	SIM_SCGC4_I2C0_0 = 0x0
	// Clock enabled
	SIM_SCGC4_I2C0_1 = 0x1
	// Position of I2C1 field.
	SIM_SCGC4_I2C1_Pos = 0x7
	// Bit mask of I2C1 field.
	SIM_SCGC4_I2C1_Msk = 0x80
	// Bit I2C1.
	SIM_SCGC4_I2C1 = 0x80
	// Clock disabled
	SIM_SCGC4_I2C1_0 = 0x0
	// Clock enabled
	SIM_SCGC4_I2C1_1 = 0x1
	// Position of UART0 field.
	SIM_SCGC4_UART0_Pos = 0xa
	// Bit mask of UART0 field.
	SIM_SCGC4_UART0_Msk = 0x400
	// Bit UART0.
	SIM_SCGC4_UART0 = 0x400
	// Clock disabled
	SIM_SCGC4_UART0_0 = 0x0
	// Clock enabled
	SIM_SCGC4_UART0_1 = 0x1
	// Position of UART1 field.
	SIM_SCGC4_UART1_Pos = 0xb
	// Bit mask of UART1 field.
	SIM_SCGC4_UART1_Msk = 0x800
	// Bit UART1.
	SIM_SCGC4_UART1 = 0x800
	// Clock disabled
	SIM_SCGC4_UART1_0 = 0x0
	// Clock enabled
	SIM_SCGC4_UART1_1 = 0x1
	// Position of UART2 field.
	SIM_SCGC4_UART2_Pos = 0xc
	// Bit mask of UART2 field.
	SIM_SCGC4_UART2_Msk = 0x1000
	// Bit UART2.
	SIM_SCGC4_UART2 = 0x1000
	// Clock disabled
	SIM_SCGC4_UART2_0 = 0x0
	// Clock enabled
	SIM_SCGC4_UART2_1 = 0x1
	// Position of UART3 field.
	SIM_SCGC4_UART3_Pos = 0xd
	// Bit mask of UART3 field.
	SIM_SCGC4_UART3_Msk = 0x2000
	// Bit UART3.
	SIM_SCGC4_UART3 = 0x2000
	// Clock disabled
	SIM_SCGC4_UART3_0 = 0x0
	// Clock enabled
	SIM_SCGC4_UART3_1 = 0x1
	// Position of USBOTG field.
	SIM_SCGC4_USBOTG_Pos = 0x12
	// Bit mask of USBOTG field.
	SIM_SCGC4_USBOTG_Msk = 0x40000
	// Bit USBOTG.
	SIM_SCGC4_USBOTG = 0x40000
	// Clock disabled
	SIM_SCGC4_USBOTG_0 = 0x0
	// Clock enabled
	SIM_SCGC4_USBOTG_1 = 0x1
	// Position of CMP field.
	SIM_SCGC4_CMP_Pos = 0x13
	// Bit mask of CMP field.
	SIM_SCGC4_CMP_Msk = 0x80000
	// Bit CMP.
	SIM_SCGC4_CMP = 0x80000
	// Clock disabled
	SIM_SCGC4_CMP_0 = 0x0
	// Clock enabled
	SIM_SCGC4_CMP_1 = 0x1
	// Position of VREF field.
	SIM_SCGC4_VREF_Pos = 0x14
	// Bit mask of VREF field.
	SIM_SCGC4_VREF_Msk = 0x100000
	// Bit VREF.
	SIM_SCGC4_VREF = 0x100000
	// Clock disabled
	SIM_SCGC4_VREF_0 = 0x0
	// Clock enabled
	SIM_SCGC4_VREF_1 = 0x1

	// SCGC5: System Clock Gating Control Register 5
	// Position of LPTMR field.
	SIM_SCGC5_LPTMR_Pos = 0x0
	// Bit mask of LPTMR field.
	SIM_SCGC5_LPTMR_Msk = 0x1
	// Bit LPTMR.
	SIM_SCGC5_LPTMR = 0x1
	// Access disabled
	SIM_SCGC5_LPTMR_0 = 0x0
	// Access enabled
	SIM_SCGC5_LPTMR_1 = 0x1
	// Position of TSI field.
	SIM_SCGC5_TSI_Pos = 0x5
	// Bit mask of TSI field.
	SIM_SCGC5_TSI_Msk = 0x20
	// Bit TSI.
	SIM_SCGC5_TSI = 0x20
	// Clock disabled
	SIM_SCGC5_TSI_0 = 0x0
	// Clock enabled
	SIM_SCGC5_TSI_1 = 0x1
	// Position of PORTA field.
	SIM_SCGC5_PORTA_Pos = 0x9
	// Bit mask of PORTA field.
	SIM_SCGC5_PORTA_Msk = 0x200
	// Bit PORTA.
	SIM_SCGC5_PORTA = 0x200
	// Clock disabled
	SIM_SCGC5_PORTA_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTA_1 = 0x1
	// Position of PORTB field.
	SIM_SCGC5_PORTB_Pos = 0xa
	// Bit mask of PORTB field.
	SIM_SCGC5_PORTB_Msk = 0x400
	// Bit PORTB.
	SIM_SCGC5_PORTB = 0x400
	// Clock disabled
	SIM_SCGC5_PORTB_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTB_1 = 0x1
	// Position of PORTC field.
	SIM_SCGC5_PORTC_Pos = 0xb
	// Bit mask of PORTC field.
	SIM_SCGC5_PORTC_Msk = 0x800
	// Bit PORTC.
	SIM_SCGC5_PORTC = 0x800
	// Clock disabled
	SIM_SCGC5_PORTC_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTC_1 = 0x1
	// Position of PORTD field.
	SIM_SCGC5_PORTD_Pos = 0xc
	// Bit mask of PORTD field.
	SIM_SCGC5_PORTD_Msk = 0x1000
	// Bit PORTD.
	SIM_SCGC5_PORTD = 0x1000
	// Clock disabled
	SIM_SCGC5_PORTD_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTD_1 = 0x1
	// Position of PORTE field.
	SIM_SCGC5_PORTE_Pos = 0xd
	// Bit mask of PORTE field.
	SIM_SCGC5_PORTE_Msk = 0x2000
	// Bit PORTE.
	SIM_SCGC5_PORTE = 0x2000
	// Clock disabled
	SIM_SCGC5_PORTE_0 = 0x0
	// Clock enabled
	SIM_SCGC5_PORTE_1 = 0x1

	// SCGC6: System Clock Gating Control Register 6
	// Position of FTF field.
	SIM_SCGC6_FTF_Pos = 0x0
	// Bit mask of FTF field.
	SIM_SCGC6_FTF_Msk = 0x1
	// Bit FTF.
	SIM_SCGC6_FTF = 0x1
	// Clock disabled
	SIM_SCGC6_FTF_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FTF_1 = 0x1
	// Position of DMAMUX field.
	SIM_SCGC6_DMAMUX_Pos = 0x1
	// Bit mask of DMAMUX field.
	SIM_SCGC6_DMAMUX_Msk = 0x2
	// Bit DMAMUX.
	SIM_SCGC6_DMAMUX = 0x2
	// Clock disabled
	SIM_SCGC6_DMAMUX_0 = 0x0
	// Clock enabled
	SIM_SCGC6_DMAMUX_1 = 0x1
	// Position of FLEXCAN0 field.
	SIM_SCGC6_FLEXCAN0_Pos = 0x4
	// Bit mask of FLEXCAN0 field.
	SIM_SCGC6_FLEXCAN0_Msk = 0x10
	// Bit FLEXCAN0.
	SIM_SCGC6_FLEXCAN0 = 0x10
	// Clock disabled
	SIM_SCGC6_FLEXCAN0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FLEXCAN0_1 = 0x1
	// Position of RNGA field.
	SIM_SCGC6_RNGA_Pos = 0x9
	// Bit mask of RNGA field.
	SIM_SCGC6_RNGA_Msk = 0x200
	// Bit RNGA.
	SIM_SCGC6_RNGA = 0x200
	// Position of SPI0 field.
	SIM_SCGC6_SPI0_Pos = 0xc
	// Bit mask of SPI0 field.
	SIM_SCGC6_SPI0_Msk = 0x1000
	// Bit SPI0.
	SIM_SCGC6_SPI0 = 0x1000
	// Clock disabled
	SIM_SCGC6_SPI0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_SPI0_1 = 0x1
	// Position of SPI1 field.
	SIM_SCGC6_SPI1_Pos = 0xd
	// Bit mask of SPI1 field.
	SIM_SCGC6_SPI1_Msk = 0x2000
	// Bit SPI1.
	SIM_SCGC6_SPI1 = 0x2000
	// Clock disabled
	SIM_SCGC6_SPI1_0 = 0x0
	// Clock enabled
	SIM_SCGC6_SPI1_1 = 0x1
	// Position of I2S field.
	SIM_SCGC6_I2S_Pos = 0xf
	// Bit mask of I2S field.
	SIM_SCGC6_I2S_Msk = 0x8000
	// Bit I2S.
	SIM_SCGC6_I2S = 0x8000
	// Clock disabled
	SIM_SCGC6_I2S_0 = 0x0
	// Clock enabled
	SIM_SCGC6_I2S_1 = 0x1
	// Position of CRC field.
	SIM_SCGC6_CRC_Pos = 0x12
	// Bit mask of CRC field.
	SIM_SCGC6_CRC_Msk = 0x40000
	// Bit CRC.
	SIM_SCGC6_CRC = 0x40000
	// Clock disabled
	SIM_SCGC6_CRC_0 = 0x0
	// Clock enabled
	SIM_SCGC6_CRC_1 = 0x1
	// Position of USBDCD field.
	SIM_SCGC6_USBDCD_Pos = 0x15
	// Bit mask of USBDCD field.
	SIM_SCGC6_USBDCD_Msk = 0x200000
	// Bit USBDCD.
	SIM_SCGC6_USBDCD = 0x200000
	// Clock disabled
	SIM_SCGC6_USBDCD_0 = 0x0
	// Clock enabled
	SIM_SCGC6_USBDCD_1 = 0x1
	// Position of PDB field.
	SIM_SCGC6_PDB_Pos = 0x16
	// Bit mask of PDB field.
	SIM_SCGC6_PDB_Msk = 0x400000
	// Bit PDB.
	SIM_SCGC6_PDB = 0x400000
	// Clock disabled
	SIM_SCGC6_PDB_0 = 0x0
	// Clock enabled
	SIM_SCGC6_PDB_1 = 0x1
	// Position of PIT field.
	SIM_SCGC6_PIT_Pos = 0x17
	// Bit mask of PIT field.
	SIM_SCGC6_PIT_Msk = 0x800000
	// Bit PIT.
	SIM_SCGC6_PIT = 0x800000
	// Clock disabled
	SIM_SCGC6_PIT_0 = 0x0
	// Clock enabled
	SIM_SCGC6_PIT_1 = 0x1
	// Position of FTM0 field.
	SIM_SCGC6_FTM0_Pos = 0x18
	// Bit mask of FTM0 field.
	SIM_SCGC6_FTM0_Msk = 0x1000000
	// Bit FTM0.
	SIM_SCGC6_FTM0 = 0x1000000
	// Clock disabled
	SIM_SCGC6_FTM0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FTM0_1 = 0x1
	// Position of FTM1 field.
	SIM_SCGC6_FTM1_Pos = 0x19
	// Bit mask of FTM1 field.
	SIM_SCGC6_FTM1_Msk = 0x2000000
	// Bit FTM1.
	SIM_SCGC6_FTM1 = 0x2000000
	// Clock disabled
	SIM_SCGC6_FTM1_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FTM1_1 = 0x1
	// Position of FTM2 field.
	SIM_SCGC6_FTM2_Pos = 0x1a
	// Bit mask of FTM2 field.
	SIM_SCGC6_FTM2_Msk = 0x4000000
	// Bit FTM2.
	SIM_SCGC6_FTM2 = 0x4000000
	// Clock disabled
	SIM_SCGC6_FTM2_0 = 0x0
	// Clock enabled
	SIM_SCGC6_FTM2_1 = 0x1
	// Position of ADC0 field.
	SIM_SCGC6_ADC0_Pos = 0x1b
	// Bit mask of ADC0 field.
	SIM_SCGC6_ADC0_Msk = 0x8000000
	// Bit ADC0.
	SIM_SCGC6_ADC0 = 0x8000000
	// Clock disabled
	SIM_SCGC6_ADC0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_ADC0_1 = 0x1
	// Position of RTC field.
	SIM_SCGC6_RTC_Pos = 0x1d
	// Bit mask of RTC field.
	SIM_SCGC6_RTC_Msk = 0x20000000
	// Bit RTC.
	SIM_SCGC6_RTC = 0x20000000
	// Access and interrupts disabled
	SIM_SCGC6_RTC_0 = 0x0
	// Access and interrupts enabled
	SIM_SCGC6_RTC_1 = 0x1
	// Position of DAC0 field.
	SIM_SCGC6_DAC0_Pos = 0x1f
	// Bit mask of DAC0 field.
	SIM_SCGC6_DAC0_Msk = 0x80000000
	// Bit DAC0.
	SIM_SCGC6_DAC0 = 0x80000000
	// Clock disabled
	SIM_SCGC6_DAC0_0 = 0x0
	// Clock enabled
	SIM_SCGC6_DAC0_1 = 0x1

	// SCGC7: System Clock Gating Control Register 7
	// Position of FLEXBUS field.
	SIM_SCGC7_FLEXBUS_Pos = 0x0
	// Bit mask of FLEXBUS field.
	SIM_SCGC7_FLEXBUS_Msk = 0x1
	// Bit FLEXBUS.
	SIM_SCGC7_FLEXBUS = 0x1
	// Clock disabled
	SIM_SCGC7_FLEXBUS_0 = 0x0
	// Clock enabled
	SIM_SCGC7_FLEXBUS_1 = 0x1
	// Position of DMA field.
	SIM_SCGC7_DMA_Pos = 0x1
	// Bit mask of DMA field.
	SIM_SCGC7_DMA_Msk = 0x2
	// Bit DMA.
	SIM_SCGC7_DMA = 0x2
	// Clock disabled
	SIM_SCGC7_DMA_0 = 0x0
	// Clock enabled
	SIM_SCGC7_DMA_1 = 0x1
	// Position of MPU field.
	SIM_SCGC7_MPU_Pos = 0x2
	// Bit mask of MPU field.
	SIM_SCGC7_MPU_Msk = 0x4
	// Bit MPU.
	SIM_SCGC7_MPU = 0x4
	// Clock disabled
	SIM_SCGC7_MPU_0 = 0x0
	// Clock enabled
	SIM_SCGC7_MPU_1 = 0x1
	// Position of SDRAMC field.
	SIM_SCGC7_SDRAMC_Pos = 0x3
	// Bit mask of SDRAMC field.
	SIM_SCGC7_SDRAMC_Msk = 0x8
	// Bit SDRAMC.
	SIM_SCGC7_SDRAMC = 0x8
	// Clock disabled
	SIM_SCGC7_SDRAMC_0 = 0x0
	// Clock enabled
	SIM_SCGC7_SDRAMC_1 = 0x1

	// CLKDIV1: System Clock Divider Register 1
	// Position of OUTDIV4 field.
	SIM_CLKDIV1_OUTDIV4_Pos = 0x10
	// Bit mask of OUTDIV4 field.
	SIM_CLKDIV1_OUTDIV4_Msk = 0xf0000
	// Divide-by-1.
	SIM_CLKDIV1_OUTDIV4_0000 = 0x0
	// Divide-by-2.
	SIM_CLKDIV1_OUTDIV4_0001 = 0x1
	// Divide-by-3.
	SIM_CLKDIV1_OUTDIV4_0010 = 0x2
	// Divide-by-4.
	SIM_CLKDIV1_OUTDIV4_0011 = 0x3
	// Divide-by-5.
	SIM_CLKDIV1_OUTDIV4_0100 = 0x4
	// Divide-by-6.
	SIM_CLKDIV1_OUTDIV4_0101 = 0x5
	// Divide-by-7.
	SIM_CLKDIV1_OUTDIV4_0110 = 0x6
	// Divide-by-8.
	SIM_CLKDIV1_OUTDIV4_0111 = 0x7
	// Divide-by-9.
	SIM_CLKDIV1_OUTDIV4_1000 = 0x8
	// Divide-by-10.
	SIM_CLKDIV1_OUTDIV4_1001 = 0x9
	// Divide-by-11.
	SIM_CLKDIV1_OUTDIV4_1010 = 0xa
	// Divide-by-12.
	SIM_CLKDIV1_OUTDIV4_1011 = 0xb
	// Divide-by-13.
	SIM_CLKDIV1_OUTDIV4_1100 = 0xc
	// Divide-by-14.
	SIM_CLKDIV1_OUTDIV4_1101 = 0xd
	// Divide-by-15.
	SIM_CLKDIV1_OUTDIV4_1110 = 0xe
	// Divide-by-16.
	SIM_CLKDIV1_OUTDIV4_1111 = 0xf
	// Position of OUTDIV3 field.
	SIM_CLKDIV1_OUTDIV3_Pos = 0x14
	// Bit mask of OUTDIV3 field.
	SIM_CLKDIV1_OUTDIV3_Msk = 0xf00000
	// Divide-by-1.
	SIM_CLKDIV1_OUTDIV3_0000 = 0x0
	// Divide-by-2.
	SIM_CLKDIV1_OUTDIV3_0001 = 0x1
	// Divide-by-3.
	SIM_CLKDIV1_OUTDIV3_0010 = 0x2
	// Divide-by-4.
	SIM_CLKDIV1_OUTDIV3_0011 = 0x3
	// Divide-by-5.
	SIM_CLKDIV1_OUTDIV3_0100 = 0x4
	// Divide-by-6.
	SIM_CLKDIV1_OUTDIV3_0101 = 0x5
	// Divide-by-7.
	SIM_CLKDIV1_OUTDIV3_0110 = 0x6
	// Divide-by-8.
	SIM_CLKDIV1_OUTDIV3_0111 = 0x7
	// Divide-by-9.
	SIM_CLKDIV1_OUTDIV3_1000 = 0x8
	// Divide-by-10.
	SIM_CLKDIV1_OUTDIV3_1001 = 0x9
	// Divide-by-11.
	SIM_CLKDIV1_OUTDIV3_1010 = 0xa
	// Divide-by-12.
	SIM_CLKDIV1_OUTDIV3_1011 = 0xb
	// Divide-by-13.
	SIM_CLKDIV1_OUTDIV3_1100 = 0xc
	// Divide-by-14.
	SIM_CLKDIV1_OUTDIV3_1101 = 0xd
	// Divide-by-15.
	SIM_CLKDIV1_OUTDIV3_1110 = 0xe
	// Divide-by-16.
	SIM_CLKDIV1_OUTDIV3_1111 = 0xf
	// Position of OUTDIV2 field.
	SIM_CLKDIV1_OUTDIV2_Pos = 0x18
	// Bit mask of OUTDIV2 field.
	SIM_CLKDIV1_OUTDIV2_Msk = 0xf000000
	// Divide-by-1.
	SIM_CLKDIV1_OUTDIV2_0000 = 0x0
	// Divide-by-2.
	SIM_CLKDIV1_OUTDIV2_0001 = 0x1
	// Divide-by-3.
	SIM_CLKDIV1_OUTDIV2_0010 = 0x2
	// Divide-by-4.
	SIM_CLKDIV1_OUTDIV2_0011 = 0x3
	// Divide-by-5.
	SIM_CLKDIV1_OUTDIV2_0100 = 0x4
	// Divide-by-6.
	SIM_CLKDIV1_OUTDIV2_0101 = 0x5
	// Divide-by-7.
	SIM_CLKDIV1_OUTDIV2_0110 = 0x6
	// Divide-by-8.
	SIM_CLKDIV1_OUTDIV2_0111 = 0x7
	// Divide-by-9.
	SIM_CLKDIV1_OUTDIV2_1000 = 0x8
	// Divide-by-10.
	SIM_CLKDIV1_OUTDIV2_1001 = 0x9
	// Divide-by-11.
	SIM_CLKDIV1_OUTDIV2_1010 = 0xa
	// Divide-by-12.
	SIM_CLKDIV1_OUTDIV2_1011 = 0xb
	// Divide-by-13.
	SIM_CLKDIV1_OUTDIV2_1100 = 0xc
	// Divide-by-14.
	SIM_CLKDIV1_OUTDIV2_1101 = 0xd
	// Divide-by-15.
	SIM_CLKDIV1_OUTDIV2_1110 = 0xe
	// Divide-by-16.
	SIM_CLKDIV1_OUTDIV2_1111 = 0xf
	// Position of OUTDIV1 field.
	SIM_CLKDIV1_OUTDIV1_Pos = 0x1c
	// Bit mask of OUTDIV1 field.
	SIM_CLKDIV1_OUTDIV1_Msk = 0xf0000000
	// Divide-by-1.
	SIM_CLKDIV1_OUTDIV1_0000 = 0x0
	// Divide-by-2.
	SIM_CLKDIV1_OUTDIV1_0001 = 0x1
	// Divide-by-3.
	SIM_CLKDIV1_OUTDIV1_0010 = 0x2
	// Divide-by-4.
	SIM_CLKDIV1_OUTDIV1_0011 = 0x3
	// Divide-by-5.
	SIM_CLKDIV1_OUTDIV1_0100 = 0x4
	// Divide-by-6.
	SIM_CLKDIV1_OUTDIV1_0101 = 0x5
	// Divide-by-7.
	SIM_CLKDIV1_OUTDIV1_0110 = 0x6
	// Divide-by-8.
	SIM_CLKDIV1_OUTDIV1_0111 = 0x7
	// Divide-by-9.
	SIM_CLKDIV1_OUTDIV1_1000 = 0x8
	// Divide-by-10.
	SIM_CLKDIV1_OUTDIV1_1001 = 0x9
	// Divide-by-11.
	SIM_CLKDIV1_OUTDIV1_1010 = 0xa
	// Divide-by-12.
	SIM_CLKDIV1_OUTDIV1_1011 = 0xb
	// Divide-by-13.
	SIM_CLKDIV1_OUTDIV1_1100 = 0xc
	// Divide-by-14.
	SIM_CLKDIV1_OUTDIV1_1101 = 0xd
	// Divide-by-15.
	SIM_CLKDIV1_OUTDIV1_1110 = 0xe
	// Divide-by-16.
	SIM_CLKDIV1_OUTDIV1_1111 = 0xf

	// CLKDIV2: System Clock Divider Register 2
	// Position of USBFRAC field.
	SIM_CLKDIV2_USBFRAC_Pos = 0x0
	// Bit mask of USBFRAC field.
	SIM_CLKDIV2_USBFRAC_Msk = 0x1
	// Bit USBFRAC.
	SIM_CLKDIV2_USBFRAC = 0x1
	// Position of USBDIV field.
	SIM_CLKDIV2_USBDIV_Pos = 0x1
	// Bit mask of USBDIV field.
	SIM_CLKDIV2_USBDIV_Msk = 0xe

	// FCFG1: Flash Configuration Register 1
	// Position of FLASHDIS field.
	SIM_FCFG1_FLASHDIS_Pos = 0x0
	// Bit mask of FLASHDIS field.
	SIM_FCFG1_FLASHDIS_Msk = 0x1
	// Bit FLASHDIS.
	SIM_FCFG1_FLASHDIS = 0x1
	// Flash is enabled
	SIM_FCFG1_FLASHDIS_0 = 0x0
	// Flash is disabled
	SIM_FCFG1_FLASHDIS_1 = 0x1
	// Position of FLASHDOZE field.
	SIM_FCFG1_FLASHDOZE_Pos = 0x1
	// Bit mask of FLASHDOZE field.
	SIM_FCFG1_FLASHDOZE_Msk = 0x2
	// Bit FLASHDOZE.
	SIM_FCFG1_FLASHDOZE = 0x2
	// Flash remains enabled during Wait mode
	SIM_FCFG1_FLASHDOZE_0 = 0x0
	// Flash is disabled for the duration of Wait mode
	SIM_FCFG1_FLASHDOZE_1 = 0x1
	// Position of DEPART field.
	SIM_FCFG1_DEPART_Pos = 0x8
	// Bit mask of DEPART field.
	SIM_FCFG1_DEPART_Msk = 0xf00
	// Position of EESIZE field.
	SIM_FCFG1_EESIZE_Pos = 0x10
	// Bit mask of EESIZE field.
	SIM_FCFG1_EESIZE_Msk = 0xf0000
	// 16 KB
	SIM_FCFG1_EESIZE_0000 = 0x0
	// 8 KB
	SIM_FCFG1_EESIZE_0001 = 0x1
	// 4 KB
	SIM_FCFG1_EESIZE_0010 = 0x2
	// 2 KB
	SIM_FCFG1_EESIZE_0011 = 0x3
	// 1 KB
	SIM_FCFG1_EESIZE_0100 = 0x4
	// 512 Bytes
	SIM_FCFG1_EESIZE_0101 = 0x5
	// 256 Bytes
	SIM_FCFG1_EESIZE_0110 = 0x6
	// 128 Bytes
	SIM_FCFG1_EESIZE_0111 = 0x7
	// 64 Bytes
	SIM_FCFG1_EESIZE_1000 = 0x8
	// 32 Bytes
	SIM_FCFG1_EESIZE_1001 = 0x9
	// 0 Bytes
	SIM_FCFG1_EESIZE_1111 = 0xf
	// Position of PFSIZE field.
	SIM_FCFG1_PFSIZE_Pos = 0x18
	// Bit mask of PFSIZE field.
	SIM_FCFG1_PFSIZE_Msk = 0xf000000
	// 32 KB of program flash memory
	SIM_FCFG1_PFSIZE_0011 = 0x3
	// 64 KB of program flash memory
	SIM_FCFG1_PFSIZE_0101 = 0x5
	// 128 KB of program flash memory
	SIM_FCFG1_PFSIZE_0111 = 0x7
	// 256 KB of program flash memory
	SIM_FCFG1_PFSIZE_1001 = 0x9
	// 512 KB of program flash memory
	SIM_FCFG1_PFSIZE_1011 = 0xb
	// 1024 KB of program flash memory
	SIM_FCFG1_PFSIZE_1101 = 0xd
	// 2048 KB of program flash memory
	SIM_FCFG1_PFSIZE_1111 = 0xf
	// Position of NVMSIZE field.
	SIM_FCFG1_NVMSIZE_Pos = 0x1c
	// Bit mask of NVMSIZE field.
	SIM_FCFG1_NVMSIZE_Msk = 0xf0000000
	// 0 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_0000 = 0x0
	// 32 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_0011 = 0x3
	// 64 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_0101 = 0x5
	// 128 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_0111 = 0x7
	// 256 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_1001 = 0x9
	// 512 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_1011 = 0xb
	// 256 KB of FlexNVM
	SIM_FCFG1_NVMSIZE_1111 = 0xf

	// FCFG2: Flash Configuration Register 2
	// Position of MAXADDR1 field.
	SIM_FCFG2_MAXADDR1_Pos = 0x10
	// Bit mask of MAXADDR1 field.
	SIM_FCFG2_MAXADDR1_Msk = 0x7f0000
	// Position of PFLSH field.
	SIM_FCFG2_PFLSH_Pos = 0x17
	// Bit mask of PFLSH field.
	SIM_FCFG2_PFLSH_Msk = 0x800000
	// Bit PFLSH.
	SIM_FCFG2_PFLSH = 0x800000
	// Device supports FlexNVM
	SIM_FCFG2_PFLSH_0 = 0x0
	// Program Flash only, device does not support FlexNVM
	SIM_FCFG2_PFLSH_1 = 0x1
	// Position of MAXADDR0 field.
	SIM_FCFG2_MAXADDR0_Pos = 0x18
	// Bit mask of MAXADDR0 field.
	SIM_FCFG2_MAXADDR0_Msk = 0x7f000000
	// Position of SWAPPFLSH field.
	SIM_FCFG2_SWAPPFLSH_Pos = 0x1f
	// Bit mask of SWAPPFLSH field.
	SIM_FCFG2_SWAPPFLSH_Msk = 0x80000000
	// Bit SWAPPFLSH.
	SIM_FCFG2_SWAPPFLSH = 0x80000000
	// Swap is not active.
	SIM_FCFG2_SWAPPFLSH_0 = 0x0
	// Swap is active.
	SIM_FCFG2_SWAPPFLSH_1 = 0x1

	// UIDH: Unique Identification Register High
	// Position of UID field.
	SIM_UIDH_UID_Pos = 0x0
	// Bit mask of UID field.
	SIM_UIDH_UID_Msk = 0xffffffff

	// UIDMH: Unique Identification Register Mid-High
	// Position of UID field.
	SIM_UIDMH_UID_Pos = 0x0
	// Bit mask of UID field.
	SIM_UIDMH_UID_Msk = 0xffffffff

	// UIDML: Unique Identification Register Mid Low
	// Position of UID field.
	SIM_UIDML_UID_Pos = 0x0
	// Bit mask of UID field.
	SIM_UIDML_UID_Msk = 0xffffffff

	// UIDL: Unique Identification Register Low
	// Position of UID field.
	SIM_UIDL_UID_Pos = 0x0
	// Bit mask of UID field.
	SIM_UIDL_UID_Msk = 0xffffffff

	// CLKDIV3: System Clock Divider Register 3
	// Position of PLLFLLFRAC field.
	SIM_CLKDIV3_PLLFLLFRAC_Pos = 0x0
	// Bit mask of PLLFLLFRAC field.
	SIM_CLKDIV3_PLLFLLFRAC_Msk = 0x1
	// Bit PLLFLLFRAC.
	SIM_CLKDIV3_PLLFLLFRAC = 0x1
	// Position of PLLFLLDIV field.
	SIM_CLKDIV3_PLLFLLDIV_Pos = 0x1
	// Bit mask of PLLFLLDIV field.
	SIM_CLKDIV3_PLLFLLDIV_Msk = 0xe

	// CLKDIV4: System Clock Divider Register 4
	// Position of TRACEFRAC field.
	SIM_CLKDIV4_TRACEFRAC_Pos = 0x0
	// Bit mask of TRACEFRAC field.
	SIM_CLKDIV4_TRACEFRAC_Msk = 0x1
	// Bit TRACEFRAC.
	SIM_CLKDIV4_TRACEFRAC = 0x1
	// Position of TRACEDIV field.
	SIM_CLKDIV4_TRACEDIV_Pos = 0x1
	// Bit mask of TRACEDIV field.
	SIM_CLKDIV4_TRACEDIV_Msk = 0xe
)

// Constants for PORTA: Pin Control and Interrupts
const (
	// PCR0: Pin Control Register n
	// Position of PS field.
	PORT_PCR0_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR0_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR0_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR0_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR0_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR0_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR0_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR0_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR0_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR0_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR0_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR0_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR0_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR0_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR0_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR0_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR0_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR0_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR0_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR0_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR0_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR0_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR0_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR0_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR0_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR0_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR0_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR0_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR0_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR0_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR0_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR0_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR0_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR0_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR0_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR0_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR0_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR0_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR0_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR0_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR0_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR0_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR0_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR0_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR0_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR0_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR0_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR0_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR0_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR0_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR0_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR0_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR0_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR0_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR0_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR0_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR0_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR0_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR0_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR0_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR0_ISF_1 = 0x1

	// PCR1: Pin Control Register n
	// Position of PS field.
	PORT_PCR1_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR1_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR1_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR1_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR1_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR1_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR1_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR1_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR1_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR1_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR1_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR1_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR1_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR1_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR1_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR1_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR1_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR1_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR1_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR1_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR1_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR1_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR1_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR1_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR1_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR1_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR1_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR1_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR1_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR1_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR1_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR1_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR1_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR1_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR1_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR1_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR1_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR1_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR1_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR1_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR1_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR1_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR1_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR1_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR1_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR1_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR1_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR1_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR1_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR1_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR1_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR1_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR1_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR1_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR1_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR1_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR1_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR1_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR1_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR1_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR1_ISF_1 = 0x1

	// PCR2: Pin Control Register n
	// Position of PS field.
	PORT_PCR2_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR2_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR2_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR2_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR2_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR2_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR2_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR2_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR2_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR2_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR2_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR2_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR2_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR2_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR2_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR2_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR2_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR2_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR2_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR2_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR2_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR2_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR2_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR2_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR2_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR2_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR2_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR2_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR2_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR2_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR2_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR2_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR2_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR2_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR2_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR2_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR2_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR2_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR2_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR2_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR2_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR2_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR2_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR2_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR2_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR2_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR2_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR2_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR2_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR2_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR2_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR2_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR2_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR2_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR2_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR2_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR2_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR2_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR2_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR2_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR2_ISF_1 = 0x1

	// PCR3: Pin Control Register n
	// Position of PS field.
	PORT_PCR3_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR3_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR3_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR3_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR3_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR3_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR3_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR3_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR3_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR3_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR3_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR3_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR3_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR3_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR3_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR3_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR3_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR3_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR3_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR3_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR3_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR3_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR3_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR3_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR3_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR3_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR3_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR3_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR3_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR3_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR3_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR3_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR3_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR3_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR3_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR3_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR3_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR3_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR3_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR3_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR3_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR3_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR3_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR3_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR3_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR3_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR3_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR3_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR3_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR3_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR3_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR3_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR3_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR3_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR3_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR3_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR3_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR3_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR3_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR3_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR3_ISF_1 = 0x1

	// PCR4: Pin Control Register n
	// Position of PS field.
	PORT_PCR4_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR4_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR4_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR4_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR4_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR4_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR4_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR4_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR4_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR4_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR4_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR4_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR4_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR4_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR4_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR4_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR4_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR4_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR4_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR4_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR4_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR4_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR4_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR4_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR4_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR4_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR4_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR4_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR4_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR4_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR4_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR4_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR4_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR4_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR4_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR4_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR4_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR4_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR4_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR4_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR4_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR4_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR4_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR4_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR4_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR4_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR4_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR4_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR4_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR4_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR4_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR4_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR4_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR4_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR4_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR4_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR4_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR4_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR4_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR4_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR4_ISF_1 = 0x1

	// PCR5: Pin Control Register n
	// Position of PS field.
	PORT_PCR5_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR5_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR5_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR5_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR5_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR5_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR5_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR5_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR5_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR5_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR5_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR5_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR5_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR5_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR5_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR5_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR5_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR5_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR5_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR5_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR5_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR5_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR5_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR5_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR5_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR5_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR5_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR5_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR5_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR5_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR5_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR5_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR5_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR5_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR5_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR5_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR5_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR5_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR5_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR5_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR5_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR5_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR5_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR5_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR5_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR5_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR5_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR5_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR5_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR5_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR5_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR5_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR5_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR5_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR5_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR5_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR5_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR5_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR5_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR5_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR5_ISF_1 = 0x1

	// PCR6: Pin Control Register n
	// Position of PS field.
	PORT_PCR6_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR6_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR6_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR6_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR6_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR6_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR6_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR6_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR6_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR6_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR6_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR6_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR6_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR6_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR6_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR6_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR6_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR6_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR6_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR6_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR6_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR6_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR6_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR6_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR6_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR6_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR6_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR6_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR6_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR6_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR6_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR6_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR6_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR6_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR6_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR6_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR6_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR6_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR6_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR6_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR6_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR6_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR6_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR6_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR6_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR6_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR6_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR6_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR6_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR6_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR6_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR6_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR6_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR6_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR6_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR6_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR6_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR6_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR6_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR6_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR6_ISF_1 = 0x1

	// PCR7: Pin Control Register n
	// Position of PS field.
	PORT_PCR7_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR7_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR7_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR7_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR7_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR7_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR7_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR7_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR7_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR7_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR7_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR7_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR7_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR7_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR7_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR7_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR7_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR7_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR7_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR7_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR7_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR7_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR7_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR7_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR7_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR7_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR7_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR7_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR7_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR7_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR7_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR7_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR7_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR7_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR7_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR7_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR7_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR7_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR7_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR7_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR7_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR7_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR7_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR7_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR7_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR7_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR7_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR7_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR7_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR7_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR7_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR7_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR7_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR7_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR7_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR7_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR7_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR7_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR7_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR7_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR7_ISF_1 = 0x1

	// PCR8: Pin Control Register n
	// Position of PS field.
	PORT_PCR8_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR8_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR8_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR8_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR8_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR8_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR8_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR8_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR8_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR8_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR8_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR8_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR8_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR8_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR8_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR8_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR8_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR8_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR8_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR8_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR8_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR8_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR8_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR8_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR8_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR8_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR8_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR8_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR8_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR8_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR8_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR8_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR8_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR8_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR8_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR8_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR8_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR8_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR8_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR8_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR8_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR8_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR8_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR8_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR8_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR8_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR8_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR8_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR8_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR8_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR8_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR8_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR8_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR8_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR8_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR8_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR8_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR8_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR8_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR8_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR8_ISF_1 = 0x1

	// PCR9: Pin Control Register n
	// Position of PS field.
	PORT_PCR9_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR9_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR9_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR9_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR9_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR9_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR9_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR9_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR9_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR9_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR9_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR9_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR9_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR9_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR9_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR9_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR9_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR9_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR9_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR9_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR9_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR9_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR9_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR9_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR9_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR9_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR9_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR9_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR9_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR9_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR9_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR9_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR9_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR9_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR9_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR9_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR9_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR9_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR9_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR9_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR9_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR9_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR9_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR9_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR9_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR9_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR9_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR9_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR9_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR9_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR9_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR9_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR9_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR9_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR9_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR9_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR9_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR9_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR9_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR9_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR9_ISF_1 = 0x1

	// PCR10: Pin Control Register n
	// Position of PS field.
	PORT_PCR10_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR10_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR10_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR10_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR10_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR10_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR10_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR10_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR10_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR10_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR10_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR10_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR10_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR10_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR10_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR10_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR10_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR10_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR10_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR10_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR10_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR10_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR10_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR10_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR10_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR10_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR10_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR10_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR10_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR10_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR10_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR10_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR10_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR10_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR10_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR10_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR10_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR10_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR10_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR10_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR10_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR10_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR10_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR10_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR10_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR10_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR10_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR10_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR10_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR10_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR10_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR10_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR10_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR10_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR10_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR10_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR10_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR10_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR10_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR10_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR10_ISF_1 = 0x1

	// PCR11: Pin Control Register n
	// Position of PS field.
	PORT_PCR11_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR11_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR11_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR11_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR11_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR11_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR11_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR11_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR11_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR11_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR11_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR11_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR11_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR11_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR11_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR11_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR11_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR11_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR11_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR11_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR11_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR11_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR11_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR11_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR11_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR11_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR11_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR11_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR11_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR11_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR11_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR11_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR11_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR11_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR11_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR11_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR11_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR11_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR11_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR11_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR11_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR11_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR11_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR11_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR11_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR11_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR11_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR11_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR11_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR11_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR11_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR11_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR11_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR11_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR11_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR11_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR11_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR11_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR11_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR11_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR11_ISF_1 = 0x1

	// PCR12: Pin Control Register n
	// Position of PS field.
	PORT_PCR12_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR12_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR12_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR12_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR12_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR12_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR12_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR12_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR12_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR12_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR12_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR12_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR12_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR12_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR12_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR12_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR12_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR12_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR12_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR12_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR12_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR12_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR12_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR12_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR12_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR12_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR12_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR12_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR12_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR12_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR12_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR12_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR12_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR12_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR12_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR12_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR12_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR12_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR12_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR12_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR12_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR12_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR12_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR12_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR12_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR12_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR12_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR12_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR12_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR12_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR12_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR12_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR12_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR12_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR12_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR12_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR12_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR12_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR12_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR12_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR12_ISF_1 = 0x1

	// PCR13: Pin Control Register n
	// Position of PS field.
	PORT_PCR13_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR13_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR13_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR13_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR13_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR13_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR13_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR13_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR13_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR13_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR13_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR13_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR13_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR13_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR13_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR13_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR13_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR13_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR13_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR13_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR13_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR13_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR13_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR13_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR13_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR13_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR13_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR13_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR13_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR13_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR13_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR13_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR13_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR13_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR13_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR13_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR13_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR13_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR13_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR13_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR13_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR13_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR13_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR13_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR13_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR13_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR13_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR13_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR13_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR13_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR13_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR13_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR13_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR13_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR13_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR13_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR13_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR13_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR13_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR13_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR13_ISF_1 = 0x1

	// PCR14: Pin Control Register n
	// Position of PS field.
	PORT_PCR14_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR14_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR14_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR14_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR14_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR14_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR14_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR14_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR14_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR14_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR14_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR14_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR14_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR14_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR14_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR14_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR14_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR14_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR14_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR14_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR14_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR14_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR14_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR14_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR14_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR14_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR14_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR14_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR14_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR14_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR14_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR14_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR14_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR14_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR14_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR14_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR14_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR14_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR14_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR14_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR14_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR14_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR14_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR14_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR14_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR14_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR14_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR14_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR14_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR14_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR14_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR14_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR14_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR14_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR14_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR14_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR14_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR14_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR14_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR14_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR14_ISF_1 = 0x1

	// PCR15: Pin Control Register n
	// Position of PS field.
	PORT_PCR15_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR15_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR15_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR15_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR15_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR15_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR15_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR15_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR15_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR15_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR15_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR15_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR15_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR15_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR15_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR15_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR15_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR15_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR15_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR15_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR15_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR15_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR15_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR15_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR15_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR15_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR15_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR15_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR15_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR15_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR15_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR15_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR15_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR15_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR15_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR15_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR15_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR15_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR15_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR15_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR15_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR15_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR15_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR15_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR15_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR15_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR15_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR15_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR15_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR15_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR15_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR15_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR15_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR15_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR15_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR15_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR15_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR15_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR15_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR15_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR15_ISF_1 = 0x1

	// PCR16: Pin Control Register n
	// Position of PS field.
	PORT_PCR16_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR16_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR16_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR16_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR16_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR16_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR16_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR16_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR16_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR16_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR16_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR16_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR16_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR16_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR16_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR16_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR16_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR16_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR16_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR16_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR16_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR16_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR16_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR16_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR16_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR16_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR16_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR16_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR16_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR16_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR16_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR16_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR16_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR16_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR16_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR16_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR16_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR16_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR16_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR16_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR16_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR16_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR16_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR16_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR16_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR16_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR16_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR16_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR16_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR16_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR16_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR16_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR16_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR16_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR16_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR16_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR16_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR16_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR16_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR16_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR16_ISF_1 = 0x1

	// PCR17: Pin Control Register n
	// Position of PS field.
	PORT_PCR17_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR17_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR17_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR17_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR17_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR17_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR17_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR17_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR17_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR17_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR17_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR17_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR17_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR17_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR17_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR17_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR17_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR17_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR17_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR17_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR17_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR17_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR17_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR17_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR17_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR17_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR17_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR17_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR17_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR17_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR17_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR17_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR17_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR17_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR17_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR17_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR17_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR17_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR17_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR17_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR17_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR17_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR17_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR17_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR17_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR17_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR17_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR17_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR17_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR17_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR17_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR17_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR17_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR17_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR17_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR17_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR17_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR17_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR17_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR17_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR17_ISF_1 = 0x1

	// PCR18: Pin Control Register n
	// Position of PS field.
	PORT_PCR18_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR18_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR18_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR18_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR18_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR18_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR18_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR18_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR18_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR18_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR18_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR18_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR18_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR18_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR18_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR18_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR18_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR18_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR18_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR18_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR18_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR18_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR18_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR18_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR18_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR18_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR18_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR18_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR18_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR18_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR18_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR18_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR18_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR18_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR18_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR18_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR18_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR18_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR18_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR18_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR18_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR18_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR18_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR18_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR18_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR18_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR18_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR18_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR18_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR18_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR18_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR18_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR18_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR18_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR18_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR18_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR18_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR18_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR18_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR18_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR18_ISF_1 = 0x1

	// PCR19: Pin Control Register n
	// Position of PS field.
	PORT_PCR19_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR19_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR19_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR19_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR19_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR19_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR19_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR19_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR19_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR19_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR19_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR19_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR19_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR19_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR19_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR19_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR19_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR19_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR19_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR19_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR19_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR19_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR19_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR19_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR19_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR19_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR19_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR19_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR19_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR19_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR19_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR19_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR19_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR19_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR19_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR19_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR19_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR19_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR19_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR19_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR19_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR19_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR19_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR19_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR19_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR19_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR19_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR19_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR19_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR19_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR19_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR19_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR19_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR19_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR19_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR19_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR19_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR19_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR19_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR19_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR19_ISF_1 = 0x1

	// PCR20: Pin Control Register n
	// Position of PS field.
	PORT_PCR20_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR20_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR20_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR20_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR20_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR20_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR20_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR20_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR20_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR20_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR20_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR20_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR20_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR20_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR20_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR20_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR20_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR20_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR20_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR20_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR20_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR20_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR20_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR20_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR20_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR20_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR20_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR20_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR20_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR20_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR20_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR20_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR20_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR20_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR20_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR20_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR20_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR20_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR20_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR20_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR20_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR20_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR20_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR20_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR20_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR20_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR20_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR20_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR20_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR20_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR20_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR20_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR20_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR20_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR20_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR20_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR20_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR20_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR20_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR20_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR20_ISF_1 = 0x1

	// PCR21: Pin Control Register n
	// Position of PS field.
	PORT_PCR21_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR21_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR21_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR21_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR21_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR21_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR21_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR21_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR21_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR21_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR21_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR21_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR21_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR21_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR21_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR21_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR21_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR21_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR21_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR21_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR21_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR21_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR21_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR21_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR21_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR21_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR21_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR21_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR21_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR21_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR21_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR21_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR21_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR21_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR21_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR21_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR21_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR21_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR21_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR21_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR21_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR21_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR21_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR21_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR21_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR21_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR21_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR21_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR21_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR21_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR21_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR21_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR21_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR21_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR21_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR21_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR21_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR21_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR21_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR21_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR21_ISF_1 = 0x1

	// PCR22: Pin Control Register n
	// Position of PS field.
	PORT_PCR22_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR22_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR22_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR22_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR22_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR22_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR22_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR22_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR22_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR22_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR22_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR22_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR22_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR22_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR22_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR22_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR22_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR22_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR22_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR22_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR22_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR22_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR22_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR22_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR22_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR22_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR22_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR22_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR22_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR22_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR22_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR22_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR22_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR22_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR22_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR22_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR22_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR22_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR22_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR22_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR22_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR22_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR22_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR22_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR22_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR22_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR22_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR22_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR22_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR22_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR22_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR22_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR22_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR22_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR22_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR22_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR22_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR22_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR22_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR22_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR22_ISF_1 = 0x1

	// PCR23: Pin Control Register n
	// Position of PS field.
	PORT_PCR23_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR23_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR23_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR23_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR23_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR23_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR23_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR23_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR23_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR23_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR23_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR23_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR23_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR23_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR23_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR23_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR23_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR23_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR23_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR23_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR23_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR23_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR23_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR23_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR23_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR23_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR23_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR23_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR23_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR23_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR23_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR23_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR23_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR23_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR23_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR23_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR23_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR23_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR23_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR23_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR23_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR23_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR23_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR23_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR23_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR23_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR23_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR23_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR23_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR23_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR23_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR23_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR23_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR23_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR23_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR23_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR23_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR23_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR23_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR23_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR23_ISF_1 = 0x1

	// PCR24: Pin Control Register n
	// Position of PS field.
	PORT_PCR24_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR24_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR24_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR24_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR24_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR24_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR24_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR24_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR24_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR24_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR24_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR24_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR24_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR24_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR24_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR24_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR24_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR24_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR24_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR24_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR24_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR24_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR24_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR24_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR24_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR24_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR24_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR24_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR24_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR24_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR24_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR24_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR24_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR24_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR24_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR24_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR24_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR24_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR24_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR24_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR24_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR24_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR24_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR24_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR24_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR24_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR24_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR24_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR24_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR24_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR24_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR24_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR24_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR24_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR24_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR24_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR24_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR24_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR24_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR24_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR24_ISF_1 = 0x1

	// PCR25: Pin Control Register n
	// Position of PS field.
	PORT_PCR25_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR25_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR25_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR25_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR25_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR25_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR25_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR25_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR25_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR25_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR25_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR25_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR25_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR25_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR25_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR25_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR25_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR25_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR25_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR25_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR25_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR25_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR25_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR25_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR25_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR25_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR25_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR25_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR25_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR25_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR25_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR25_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR25_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR25_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR25_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR25_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR25_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR25_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR25_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR25_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR25_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR25_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR25_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR25_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR25_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR25_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR25_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR25_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR25_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR25_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR25_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR25_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR25_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR25_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR25_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR25_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR25_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR25_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR25_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR25_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR25_ISF_1 = 0x1

	// PCR26: Pin Control Register n
	// Position of PS field.
	PORT_PCR26_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR26_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR26_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR26_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR26_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR26_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR26_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR26_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR26_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR26_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR26_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR26_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR26_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR26_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR26_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR26_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR26_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR26_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR26_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR26_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR26_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR26_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR26_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR26_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR26_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR26_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR26_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR26_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR26_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR26_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR26_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR26_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR26_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR26_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR26_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR26_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR26_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR26_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR26_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR26_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR26_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR26_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR26_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR26_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR26_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR26_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR26_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR26_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR26_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR26_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR26_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR26_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR26_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR26_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR26_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR26_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR26_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR26_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR26_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR26_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR26_ISF_1 = 0x1

	// PCR27: Pin Control Register n
	// Position of PS field.
	PORT_PCR27_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR27_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR27_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR27_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR27_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR27_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR27_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR27_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR27_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR27_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR27_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR27_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR27_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR27_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR27_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR27_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR27_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR27_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR27_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR27_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR27_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR27_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR27_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR27_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR27_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR27_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR27_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR27_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR27_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR27_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR27_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR27_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR27_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR27_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR27_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR27_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR27_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR27_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR27_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR27_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR27_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR27_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR27_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR27_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR27_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR27_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR27_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR27_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR27_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR27_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR27_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR27_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR27_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR27_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR27_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR27_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR27_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR27_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR27_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR27_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR27_ISF_1 = 0x1

	// PCR28: Pin Control Register n
	// Position of PS field.
	PORT_PCR28_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR28_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR28_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR28_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR28_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR28_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR28_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR28_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR28_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR28_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR28_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR28_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR28_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR28_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR28_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR28_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR28_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR28_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR28_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR28_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR28_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR28_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR28_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR28_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR28_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR28_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR28_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR28_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR28_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR28_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR28_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR28_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR28_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR28_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR28_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR28_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR28_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR28_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR28_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR28_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR28_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR28_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR28_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR28_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR28_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR28_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR28_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR28_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR28_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR28_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR28_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR28_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR28_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR28_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR28_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR28_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR28_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR28_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR28_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR28_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR28_ISF_1 = 0x1

	// PCR29: Pin Control Register n
	// Position of PS field.
	PORT_PCR29_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR29_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR29_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR29_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR29_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR29_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR29_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR29_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR29_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR29_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR29_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR29_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR29_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR29_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR29_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR29_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR29_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR29_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR29_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR29_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR29_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR29_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR29_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR29_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR29_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR29_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR29_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR29_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR29_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR29_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR29_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR29_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR29_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR29_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR29_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR29_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR29_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR29_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR29_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR29_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR29_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR29_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR29_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR29_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR29_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR29_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR29_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR29_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR29_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR29_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR29_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR29_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR29_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR29_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR29_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR29_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR29_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR29_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR29_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR29_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR29_ISF_1 = 0x1

	// PCR30: Pin Control Register n
	// Position of PS field.
	PORT_PCR30_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR30_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR30_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR30_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR30_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR30_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR30_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR30_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR30_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR30_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR30_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR30_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR30_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR30_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR30_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR30_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR30_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR30_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR30_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR30_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR30_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR30_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR30_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR30_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR30_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR30_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR30_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR30_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR30_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR30_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR30_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR30_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR30_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR30_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR30_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR30_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR30_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR30_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR30_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR30_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR30_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR30_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR30_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR30_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR30_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR30_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR30_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR30_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR30_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR30_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR30_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR30_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR30_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR30_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR30_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR30_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR30_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR30_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR30_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR30_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR30_ISF_1 = 0x1

	// PCR31: Pin Control Register n
	// Position of PS field.
	PORT_PCR31_PS_Pos = 0x0
	// Bit mask of PS field.
	PORT_PCR31_PS_Msk = 0x1
	// Bit PS.
	PORT_PCR31_PS = 0x1
	// Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR31_PS_0 = 0x0
	// Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
	PORT_PCR31_PS_1 = 0x1
	// Position of PE field.
	PORT_PCR31_PE_Pos = 0x1
	// Bit mask of PE field.
	PORT_PCR31_PE_Msk = 0x2
	// Bit PE.
	PORT_PCR31_PE = 0x2
	// Internal pullup or pulldown resistor is not enabled on the corresponding pin.
	PORT_PCR31_PE_0 = 0x0
	// Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
	PORT_PCR31_PE_1 = 0x1
	// Position of SRE field.
	PORT_PCR31_SRE_Pos = 0x2
	// Bit mask of SRE field.
	PORT_PCR31_SRE_Msk = 0x4
	// Bit SRE.
	PORT_PCR31_SRE = 0x4
	// Fast slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR31_SRE_0 = 0x0
	// Slow slew rate is configured on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR31_SRE_1 = 0x1
	// Position of PFE field.
	PORT_PCR31_PFE_Pos = 0x4
	// Bit mask of PFE field.
	PORT_PCR31_PFE_Msk = 0x10
	// Bit PFE.
	PORT_PCR31_PFE = 0x10
	// Passive input filter is disabled on the corresponding pin.
	PORT_PCR31_PFE_0 = 0x0
	// Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
	PORT_PCR31_PFE_1 = 0x1
	// Position of ODE field.
	PORT_PCR31_ODE_Pos = 0x5
	// Bit mask of ODE field.
	PORT_PCR31_ODE_Msk = 0x20
	// Bit ODE.
	PORT_PCR31_ODE = 0x20
	// Open drain output is disabled on the corresponding pin.
	PORT_PCR31_ODE_0 = 0x0
	// Open drain output is enabled on the corresponding pin, if the pin is configured as a digital output.
	PORT_PCR31_ODE_1 = 0x1
	// Position of DSE field.
	PORT_PCR31_DSE_Pos = 0x6
	// Bit mask of DSE field.
	PORT_PCR31_DSE_Msk = 0x40
	// Bit DSE.
	PORT_PCR31_DSE = 0x40
	// Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR31_DSE_0 = 0x0
	// High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
	PORT_PCR31_DSE_1 = 0x1
	// Position of MUX field.
	PORT_PCR31_MUX_Pos = 0x8
	// Bit mask of MUX field.
	PORT_PCR31_MUX_Msk = 0x700
	// Pin disabled (analog).
	PORT_PCR31_MUX_000 = 0x0
	// Alternative 1 (GPIO).
	PORT_PCR31_MUX_001 = 0x1
	// Alternative 2 (chip-specific).
	PORT_PCR31_MUX_010 = 0x2
	// Alternative 3 (chip-specific).
	PORT_PCR31_MUX_011 = 0x3
	// Alternative 4 (chip-specific).
	PORT_PCR31_MUX_100 = 0x4
	// Alternative 5 (chip-specific).
	PORT_PCR31_MUX_101 = 0x5
	// Alternative 6 (chip-specific).
	PORT_PCR31_MUX_110 = 0x6
	// Alternative 7 (chip-specific).
	PORT_PCR31_MUX_111 = 0x7
	// Position of LK field.
	PORT_PCR31_LK_Pos = 0xf
	// Bit mask of LK field.
	PORT_PCR31_LK_Msk = 0x8000
	// Bit LK.
	PORT_PCR31_LK = 0x8000
	// Pin Control Register fields [15:0] are not locked.
	PORT_PCR31_LK_0 = 0x0
	// Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
	PORT_PCR31_LK_1 = 0x1
	// Position of IRQC field.
	PORT_PCR31_IRQC_Pos = 0x10
	// Bit mask of IRQC field.
	PORT_PCR31_IRQC_Msk = 0xf0000
	// Interrupt Status Flag (ISF) is disabled.
	PORT_PCR31_IRQC_0000 = 0x0
	// ISF flag and DMA request on rising edge.
	PORT_PCR31_IRQC_0001 = 0x1
	// ISF flag and DMA request on falling edge.
	PORT_PCR31_IRQC_0010 = 0x2
	// ISF flag and DMA request on either edge.
	PORT_PCR31_IRQC_0011 = 0x3
	// ISF flag and Interrupt when logic 0.
	PORT_PCR31_IRQC_1000 = 0x8
	// ISF flag and Interrupt on rising-edge.
	PORT_PCR31_IRQC_1001 = 0x9
	// ISF flag and Interrupt on falling-edge.
	PORT_PCR31_IRQC_1010 = 0xa
	// ISF flag and Interrupt on either edge.
	PORT_PCR31_IRQC_1011 = 0xb
	// ISF flag and Interrupt when logic 1.
	PORT_PCR31_IRQC_1100 = 0xc
	// Position of ISF field.
	PORT_PCR31_ISF_Pos = 0x18
	// Bit mask of ISF field.
	PORT_PCR31_ISF_Msk = 0x1000000
	// Bit ISF.
	PORT_PCR31_ISF = 0x1000000
	// Configured interrupt is not detected.
	PORT_PCR31_ISF_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_PCR31_ISF_1 = 0x1

	// GPCLR: Global Pin Control Low Register
	// Position of GPWD field.
	PORT_GPCLR_GPWD_Pos = 0x0
	// Bit mask of GPWD field.
	PORT_GPCLR_GPWD_Msk = 0xffff
	// Position of GPWE0 field.
	PORT_GPCLR_GPWE0_Pos = 0x10
	// Bit mask of GPWE0 field.
	PORT_GPCLR_GPWE0_Msk = 0x10000
	// Bit GPWE0.
	PORT_GPCLR_GPWE0 = 0x10000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE0_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE0_1 = 0x1
	// Position of GPWE1 field.
	PORT_GPCLR_GPWE1_Pos = 0x11
	// Bit mask of GPWE1 field.
	PORT_GPCLR_GPWE1_Msk = 0x20000
	// Bit GPWE1.
	PORT_GPCLR_GPWE1 = 0x20000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE1_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE1_1 = 0x1
	// Position of GPWE2 field.
	PORT_GPCLR_GPWE2_Pos = 0x12
	// Bit mask of GPWE2 field.
	PORT_GPCLR_GPWE2_Msk = 0x40000
	// Bit GPWE2.
	PORT_GPCLR_GPWE2 = 0x40000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE2_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE2_1 = 0x1
	// Position of GPWE3 field.
	PORT_GPCLR_GPWE3_Pos = 0x13
	// Bit mask of GPWE3 field.
	PORT_GPCLR_GPWE3_Msk = 0x80000
	// Bit GPWE3.
	PORT_GPCLR_GPWE3 = 0x80000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE3_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE3_1 = 0x1
	// Position of GPWE4 field.
	PORT_GPCLR_GPWE4_Pos = 0x14
	// Bit mask of GPWE4 field.
	PORT_GPCLR_GPWE4_Msk = 0x100000
	// Bit GPWE4.
	PORT_GPCLR_GPWE4 = 0x100000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE4_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE4_1 = 0x1
	// Position of GPWE5 field.
	PORT_GPCLR_GPWE5_Pos = 0x15
	// Bit mask of GPWE5 field.
	PORT_GPCLR_GPWE5_Msk = 0x200000
	// Bit GPWE5.
	PORT_GPCLR_GPWE5 = 0x200000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE5_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE5_1 = 0x1
	// Position of GPWE6 field.
	PORT_GPCLR_GPWE6_Pos = 0x16
	// Bit mask of GPWE6 field.
	PORT_GPCLR_GPWE6_Msk = 0x400000
	// Bit GPWE6.
	PORT_GPCLR_GPWE6 = 0x400000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE6_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE6_1 = 0x1
	// Position of GPWE7 field.
	PORT_GPCLR_GPWE7_Pos = 0x17
	// Bit mask of GPWE7 field.
	PORT_GPCLR_GPWE7_Msk = 0x800000
	// Bit GPWE7.
	PORT_GPCLR_GPWE7 = 0x800000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE7_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE7_1 = 0x1
	// Position of GPWE8 field.
	PORT_GPCLR_GPWE8_Pos = 0x18
	// Bit mask of GPWE8 field.
	PORT_GPCLR_GPWE8_Msk = 0x1000000
	// Bit GPWE8.
	PORT_GPCLR_GPWE8 = 0x1000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE8_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE8_1 = 0x1
	// Position of GPWE9 field.
	PORT_GPCLR_GPWE9_Pos = 0x19
	// Bit mask of GPWE9 field.
	PORT_GPCLR_GPWE9_Msk = 0x2000000
	// Bit GPWE9.
	PORT_GPCLR_GPWE9 = 0x2000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE9_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE9_1 = 0x1
	// Position of GPWE10 field.
	PORT_GPCLR_GPWE10_Pos = 0x1a
	// Bit mask of GPWE10 field.
	PORT_GPCLR_GPWE10_Msk = 0x4000000
	// Bit GPWE10.
	PORT_GPCLR_GPWE10 = 0x4000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE10_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE10_1 = 0x1
	// Position of GPWE11 field.
	PORT_GPCLR_GPWE11_Pos = 0x1b
	// Bit mask of GPWE11 field.
	PORT_GPCLR_GPWE11_Msk = 0x8000000
	// Bit GPWE11.
	PORT_GPCLR_GPWE11 = 0x8000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE11_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE11_1 = 0x1
	// Position of GPWE12 field.
	PORT_GPCLR_GPWE12_Pos = 0x1c
	// Bit mask of GPWE12 field.
	PORT_GPCLR_GPWE12_Msk = 0x10000000
	// Bit GPWE12.
	PORT_GPCLR_GPWE12 = 0x10000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE12_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE12_1 = 0x1
	// Position of GPWE13 field.
	PORT_GPCLR_GPWE13_Pos = 0x1d
	// Bit mask of GPWE13 field.
	PORT_GPCLR_GPWE13_Msk = 0x20000000
	// Bit GPWE13.
	PORT_GPCLR_GPWE13 = 0x20000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE13_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE13_1 = 0x1
	// Position of GPWE14 field.
	PORT_GPCLR_GPWE14_Pos = 0x1e
	// Bit mask of GPWE14 field.
	PORT_GPCLR_GPWE14_Msk = 0x40000000
	// Bit GPWE14.
	PORT_GPCLR_GPWE14 = 0x40000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE14_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE14_1 = 0x1
	// Position of GPWE15 field.
	PORT_GPCLR_GPWE15_Pos = 0x1f
	// Bit mask of GPWE15 field.
	PORT_GPCLR_GPWE15_Msk = 0x80000000
	// Bit GPWE15.
	PORT_GPCLR_GPWE15 = 0x80000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCLR_GPWE15_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCLR_GPWE15_1 = 0x1

	// GPCHR: Global Pin Control High Register
	// Position of GPWD field.
	PORT_GPCHR_GPWD_Pos = 0x0
	// Bit mask of GPWD field.
	PORT_GPCHR_GPWD_Msk = 0xffff
	// Position of GPWE0 field.
	PORT_GPCHR_GPWE0_Pos = 0x10
	// Bit mask of GPWE0 field.
	PORT_GPCHR_GPWE0_Msk = 0x10000
	// Bit GPWE0.
	PORT_GPCHR_GPWE0 = 0x10000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE0_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE0_1 = 0x1
	// Position of GPWE1 field.
	PORT_GPCHR_GPWE1_Pos = 0x11
	// Bit mask of GPWE1 field.
	PORT_GPCHR_GPWE1_Msk = 0x20000
	// Bit GPWE1.
	PORT_GPCHR_GPWE1 = 0x20000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE1_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE1_1 = 0x1
	// Position of GPWE2 field.
	PORT_GPCHR_GPWE2_Pos = 0x12
	// Bit mask of GPWE2 field.
	PORT_GPCHR_GPWE2_Msk = 0x40000
	// Bit GPWE2.
	PORT_GPCHR_GPWE2 = 0x40000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE2_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE2_1 = 0x1
	// Position of GPWE3 field.
	PORT_GPCHR_GPWE3_Pos = 0x13
	// Bit mask of GPWE3 field.
	PORT_GPCHR_GPWE3_Msk = 0x80000
	// Bit GPWE3.
	PORT_GPCHR_GPWE3 = 0x80000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE3_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE3_1 = 0x1
	// Position of GPWE4 field.
	PORT_GPCHR_GPWE4_Pos = 0x14
	// Bit mask of GPWE4 field.
	PORT_GPCHR_GPWE4_Msk = 0x100000
	// Bit GPWE4.
	PORT_GPCHR_GPWE4 = 0x100000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE4_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE4_1 = 0x1
	// Position of GPWE5 field.
	PORT_GPCHR_GPWE5_Pos = 0x15
	// Bit mask of GPWE5 field.
	PORT_GPCHR_GPWE5_Msk = 0x200000
	// Bit GPWE5.
	PORT_GPCHR_GPWE5 = 0x200000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE5_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE5_1 = 0x1
	// Position of GPWE6 field.
	PORT_GPCHR_GPWE6_Pos = 0x16
	// Bit mask of GPWE6 field.
	PORT_GPCHR_GPWE6_Msk = 0x400000
	// Bit GPWE6.
	PORT_GPCHR_GPWE6 = 0x400000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE6_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE6_1 = 0x1
	// Position of GPWE7 field.
	PORT_GPCHR_GPWE7_Pos = 0x17
	// Bit mask of GPWE7 field.
	PORT_GPCHR_GPWE7_Msk = 0x800000
	// Bit GPWE7.
	PORT_GPCHR_GPWE7 = 0x800000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE7_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE7_1 = 0x1
	// Position of GPWE8 field.
	PORT_GPCHR_GPWE8_Pos = 0x18
	// Bit mask of GPWE8 field.
	PORT_GPCHR_GPWE8_Msk = 0x1000000
	// Bit GPWE8.
	PORT_GPCHR_GPWE8 = 0x1000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE8_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE8_1 = 0x1
	// Position of GPWE9 field.
	PORT_GPCHR_GPWE9_Pos = 0x19
	// Bit mask of GPWE9 field.
	PORT_GPCHR_GPWE9_Msk = 0x2000000
	// Bit GPWE9.
	PORT_GPCHR_GPWE9 = 0x2000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE9_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE9_1 = 0x1
	// Position of GPWE10 field.
	PORT_GPCHR_GPWE10_Pos = 0x1a
	// Bit mask of GPWE10 field.
	PORT_GPCHR_GPWE10_Msk = 0x4000000
	// Bit GPWE10.
	PORT_GPCHR_GPWE10 = 0x4000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE10_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE10_1 = 0x1
	// Position of GPWE11 field.
	PORT_GPCHR_GPWE11_Pos = 0x1b
	// Bit mask of GPWE11 field.
	PORT_GPCHR_GPWE11_Msk = 0x8000000
	// Bit GPWE11.
	PORT_GPCHR_GPWE11 = 0x8000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE11_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE11_1 = 0x1
	// Position of GPWE12 field.
	PORT_GPCHR_GPWE12_Pos = 0x1c
	// Bit mask of GPWE12 field.
	PORT_GPCHR_GPWE12_Msk = 0x10000000
	// Bit GPWE12.
	PORT_GPCHR_GPWE12 = 0x10000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE12_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE12_1 = 0x1
	// Position of GPWE13 field.
	PORT_GPCHR_GPWE13_Pos = 0x1d
	// Bit mask of GPWE13 field.
	PORT_GPCHR_GPWE13_Msk = 0x20000000
	// Bit GPWE13.
	PORT_GPCHR_GPWE13 = 0x20000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE13_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE13_1 = 0x1
	// Position of GPWE14 field.
	PORT_GPCHR_GPWE14_Pos = 0x1e
	// Bit mask of GPWE14 field.
	PORT_GPCHR_GPWE14_Msk = 0x40000000
	// Bit GPWE14.
	PORT_GPCHR_GPWE14 = 0x40000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE14_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE14_1 = 0x1
	// Position of GPWE15 field.
	PORT_GPCHR_GPWE15_Pos = 0x1f
	// Bit mask of GPWE15 field.
	PORT_GPCHR_GPWE15_Msk = 0x80000000
	// Bit GPWE15.
	PORT_GPCHR_GPWE15 = 0x80000000
	// Corresponding Pin Control Register is not updated with the value in GPWD.
	PORT_GPCHR_GPWE15_0 = 0x0
	// Corresponding Pin Control Register is updated with the value in GPWD.
	PORT_GPCHR_GPWE15_1 = 0x1

	// ISFR: Interrupt Status Flag Register
	// Position of ISF0 field.
	PORT_ISFR_ISF0_Pos = 0x0
	// Bit mask of ISF0 field.
	PORT_ISFR_ISF0_Msk = 0x1
	// Bit ISF0.
	PORT_ISFR_ISF0 = 0x1
	// Configured interrupt is not detected.
	PORT_ISFR_ISF0_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF0_1 = 0x1
	// Position of ISF1 field.
	PORT_ISFR_ISF1_Pos = 0x1
	// Bit mask of ISF1 field.
	PORT_ISFR_ISF1_Msk = 0x2
	// Bit ISF1.
	PORT_ISFR_ISF1 = 0x2
	// Configured interrupt is not detected.
	PORT_ISFR_ISF1_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF1_1 = 0x1
	// Position of ISF2 field.
	PORT_ISFR_ISF2_Pos = 0x2
	// Bit mask of ISF2 field.
	PORT_ISFR_ISF2_Msk = 0x4
	// Bit ISF2.
	PORT_ISFR_ISF2 = 0x4
	// Configured interrupt is not detected.
	PORT_ISFR_ISF2_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF2_1 = 0x1
	// Position of ISF3 field.
	PORT_ISFR_ISF3_Pos = 0x3
	// Bit mask of ISF3 field.
	PORT_ISFR_ISF3_Msk = 0x8
	// Bit ISF3.
	PORT_ISFR_ISF3 = 0x8
	// Configured interrupt is not detected.
	PORT_ISFR_ISF3_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF3_1 = 0x1
	// Position of ISF4 field.
	PORT_ISFR_ISF4_Pos = 0x4
	// Bit mask of ISF4 field.
	PORT_ISFR_ISF4_Msk = 0x10
	// Bit ISF4.
	PORT_ISFR_ISF4 = 0x10
	// Configured interrupt is not detected.
	PORT_ISFR_ISF4_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF4_1 = 0x1
	// Position of ISF5 field.
	PORT_ISFR_ISF5_Pos = 0x5
	// Bit mask of ISF5 field.
	PORT_ISFR_ISF5_Msk = 0x20
	// Bit ISF5.
	PORT_ISFR_ISF5 = 0x20
	// Configured interrupt is not detected.
	PORT_ISFR_ISF5_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF5_1 = 0x1
	// Position of ISF6 field.
	PORT_ISFR_ISF6_Pos = 0x6
	// Bit mask of ISF6 field.
	PORT_ISFR_ISF6_Msk = 0x40
	// Bit ISF6.
	PORT_ISFR_ISF6 = 0x40
	// Configured interrupt is not detected.
	PORT_ISFR_ISF6_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF6_1 = 0x1
	// Position of ISF7 field.
	PORT_ISFR_ISF7_Pos = 0x7
	// Bit mask of ISF7 field.
	PORT_ISFR_ISF7_Msk = 0x80
	// Bit ISF7.
	PORT_ISFR_ISF7 = 0x80
	// Configured interrupt is not detected.
	PORT_ISFR_ISF7_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF7_1 = 0x1
	// Position of ISF8 field.
	PORT_ISFR_ISF8_Pos = 0x8
	// Bit mask of ISF8 field.
	PORT_ISFR_ISF8_Msk = 0x100
	// Bit ISF8.
	PORT_ISFR_ISF8 = 0x100
	// Configured interrupt is not detected.
	PORT_ISFR_ISF8_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF8_1 = 0x1
	// Position of ISF9 field.
	PORT_ISFR_ISF9_Pos = 0x9
	// Bit mask of ISF9 field.
	PORT_ISFR_ISF9_Msk = 0x200
	// Bit ISF9.
	PORT_ISFR_ISF9 = 0x200
	// Configured interrupt is not detected.
	PORT_ISFR_ISF9_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF9_1 = 0x1
	// Position of ISF10 field.
	PORT_ISFR_ISF10_Pos = 0xa
	// Bit mask of ISF10 field.
	PORT_ISFR_ISF10_Msk = 0x400
	// Bit ISF10.
	PORT_ISFR_ISF10 = 0x400
	// Configured interrupt is not detected.
	PORT_ISFR_ISF10_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF10_1 = 0x1
	// Position of ISF11 field.
	PORT_ISFR_ISF11_Pos = 0xb
	// Bit mask of ISF11 field.
	PORT_ISFR_ISF11_Msk = 0x800
	// Bit ISF11.
	PORT_ISFR_ISF11 = 0x800
	// Configured interrupt is not detected.
	PORT_ISFR_ISF11_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF11_1 = 0x1
	// Position of ISF12 field.
	PORT_ISFR_ISF12_Pos = 0xc
	// Bit mask of ISF12 field.
	PORT_ISFR_ISF12_Msk = 0x1000
	// Bit ISF12.
	PORT_ISFR_ISF12 = 0x1000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF12_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF12_1 = 0x1
	// Position of ISF13 field.
	PORT_ISFR_ISF13_Pos = 0xd
	// Bit mask of ISF13 field.
	PORT_ISFR_ISF13_Msk = 0x2000
	// Bit ISF13.
	PORT_ISFR_ISF13 = 0x2000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF13_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF13_1 = 0x1
	// Position of ISF14 field.
	PORT_ISFR_ISF14_Pos = 0xe
	// Bit mask of ISF14 field.
	PORT_ISFR_ISF14_Msk = 0x4000
	// Bit ISF14.
	PORT_ISFR_ISF14 = 0x4000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF14_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF14_1 = 0x1
	// Position of ISF15 field.
	PORT_ISFR_ISF15_Pos = 0xf
	// Bit mask of ISF15 field.
	PORT_ISFR_ISF15_Msk = 0x8000
	// Bit ISF15.
	PORT_ISFR_ISF15 = 0x8000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF15_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF15_1 = 0x1
	// Position of ISF16 field.
	PORT_ISFR_ISF16_Pos = 0x10
	// Bit mask of ISF16 field.
	PORT_ISFR_ISF16_Msk = 0x10000
	// Bit ISF16.
	PORT_ISFR_ISF16 = 0x10000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF16_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF16_1 = 0x1
	// Position of ISF17 field.
	PORT_ISFR_ISF17_Pos = 0x11
	// Bit mask of ISF17 field.
	PORT_ISFR_ISF17_Msk = 0x20000
	// Bit ISF17.
	PORT_ISFR_ISF17 = 0x20000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF17_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF17_1 = 0x1
	// Position of ISF18 field.
	PORT_ISFR_ISF18_Pos = 0x12
	// Bit mask of ISF18 field.
	PORT_ISFR_ISF18_Msk = 0x40000
	// Bit ISF18.
	PORT_ISFR_ISF18 = 0x40000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF18_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF18_1 = 0x1
	// Position of ISF19 field.
	PORT_ISFR_ISF19_Pos = 0x13
	// Bit mask of ISF19 field.
	PORT_ISFR_ISF19_Msk = 0x80000
	// Bit ISF19.
	PORT_ISFR_ISF19 = 0x80000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF19_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF19_1 = 0x1
	// Position of ISF20 field.
	PORT_ISFR_ISF20_Pos = 0x14
	// Bit mask of ISF20 field.
	PORT_ISFR_ISF20_Msk = 0x100000
	// Bit ISF20.
	PORT_ISFR_ISF20 = 0x100000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF20_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF20_1 = 0x1
	// Position of ISF21 field.
	PORT_ISFR_ISF21_Pos = 0x15
	// Bit mask of ISF21 field.
	PORT_ISFR_ISF21_Msk = 0x200000
	// Bit ISF21.
	PORT_ISFR_ISF21 = 0x200000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF21_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF21_1 = 0x1
	// Position of ISF22 field.
	PORT_ISFR_ISF22_Pos = 0x16
	// Bit mask of ISF22 field.
	PORT_ISFR_ISF22_Msk = 0x400000
	// Bit ISF22.
	PORT_ISFR_ISF22 = 0x400000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF22_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF22_1 = 0x1
	// Position of ISF23 field.
	PORT_ISFR_ISF23_Pos = 0x17
	// Bit mask of ISF23 field.
	PORT_ISFR_ISF23_Msk = 0x800000
	// Bit ISF23.
	PORT_ISFR_ISF23 = 0x800000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF23_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF23_1 = 0x1
	// Position of ISF24 field.
	PORT_ISFR_ISF24_Pos = 0x18
	// Bit mask of ISF24 field.
	PORT_ISFR_ISF24_Msk = 0x1000000
	// Bit ISF24.
	PORT_ISFR_ISF24 = 0x1000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF24_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF24_1 = 0x1
	// Position of ISF25 field.
	PORT_ISFR_ISF25_Pos = 0x19
	// Bit mask of ISF25 field.
	PORT_ISFR_ISF25_Msk = 0x2000000
	// Bit ISF25.
	PORT_ISFR_ISF25 = 0x2000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF25_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF25_1 = 0x1
	// Position of ISF26 field.
	PORT_ISFR_ISF26_Pos = 0x1a
	// Bit mask of ISF26 field.
	PORT_ISFR_ISF26_Msk = 0x4000000
	// Bit ISF26.
	PORT_ISFR_ISF26 = 0x4000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF26_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF26_1 = 0x1
	// Position of ISF27 field.
	PORT_ISFR_ISF27_Pos = 0x1b
	// Bit mask of ISF27 field.
	PORT_ISFR_ISF27_Msk = 0x8000000
	// Bit ISF27.
	PORT_ISFR_ISF27 = 0x8000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF27_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF27_1 = 0x1
	// Position of ISF28 field.
	PORT_ISFR_ISF28_Pos = 0x1c
	// Bit mask of ISF28 field.
	PORT_ISFR_ISF28_Msk = 0x10000000
	// Bit ISF28.
	PORT_ISFR_ISF28 = 0x10000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF28_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF28_1 = 0x1
	// Position of ISF29 field.
	PORT_ISFR_ISF29_Pos = 0x1d
	// Bit mask of ISF29 field.
	PORT_ISFR_ISF29_Msk = 0x20000000
	// Bit ISF29.
	PORT_ISFR_ISF29 = 0x20000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF29_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF29_1 = 0x1
	// Position of ISF30 field.
	PORT_ISFR_ISF30_Pos = 0x1e
	// Bit mask of ISF30 field.
	PORT_ISFR_ISF30_Msk = 0x40000000
	// Bit ISF30.
	PORT_ISFR_ISF30 = 0x40000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF30_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF30_1 = 0x1
	// Position of ISF31 field.
	PORT_ISFR_ISF31_Pos = 0x1f
	// Bit mask of ISF31 field.
	PORT_ISFR_ISF31_Msk = 0x80000000
	// Bit ISF31.
	PORT_ISFR_ISF31 = 0x80000000
	// Configured interrupt is not detected.
	PORT_ISFR_ISF31_0 = 0x0
	// Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.
	PORT_ISFR_ISF31_1 = 0x1
)

// Constants for WDOG: Generation 2008 Watchdog Timer
const (
	// STCTRLH: Watchdog Status and Control Register High
	// Position of WDOGEN field.
	WDOG_STCTRLH_WDOGEN_Pos = 0x0
	// Bit mask of WDOGEN field.
	WDOG_STCTRLH_WDOGEN_Msk = 0x1
	// Bit WDOGEN.
	WDOG_STCTRLH_WDOGEN = 0x1
	// WDOG is disabled.
	WDOG_STCTRLH_WDOGEN_0 = 0x0
	// WDOG is enabled.
	WDOG_STCTRLH_WDOGEN_1 = 0x1
	// Position of CLKSRC field.
	WDOG_STCTRLH_CLKSRC_Pos = 0x1
	// Bit mask of CLKSRC field.
	WDOG_STCTRLH_CLKSRC_Msk = 0x2
	// Bit CLKSRC.
	WDOG_STCTRLH_CLKSRC = 0x2
	// WDOG clock sourced from LPO .
	WDOG_STCTRLH_CLKSRC_0 = 0x0
	// WDOG clock sourced from alternate clock source.
	WDOG_STCTRLH_CLKSRC_1 = 0x1
	// Position of IRQRSTEN field.
	WDOG_STCTRLH_IRQRSTEN_Pos = 0x2
	// Bit mask of IRQRSTEN field.
	WDOG_STCTRLH_IRQRSTEN_Msk = 0x4
	// Bit IRQRSTEN.
	WDOG_STCTRLH_IRQRSTEN = 0x4
	// WDOG time-out generates reset only.
	WDOG_STCTRLH_IRQRSTEN_0 = 0x0
	// WDOG time-out initially generates an interrupt. After WCT, it generates a reset.
	WDOG_STCTRLH_IRQRSTEN_1 = 0x1
	// Position of WINEN field.
	WDOG_STCTRLH_WINEN_Pos = 0x3
	// Bit mask of WINEN field.
	WDOG_STCTRLH_WINEN_Msk = 0x8
	// Bit WINEN.
	WDOG_STCTRLH_WINEN = 0x8
	// Windowing mode is disabled.
	WDOG_STCTRLH_WINEN_0 = 0x0
	// Windowing mode is enabled.
	WDOG_STCTRLH_WINEN_1 = 0x1
	// Position of ALLOWUPDATE field.
	WDOG_STCTRLH_ALLOWUPDATE_Pos = 0x4
	// Bit mask of ALLOWUPDATE field.
	WDOG_STCTRLH_ALLOWUPDATE_Msk = 0x10
	// Bit ALLOWUPDATE.
	WDOG_STCTRLH_ALLOWUPDATE = 0x10
	// No further updates allowed to WDOG write-once registers.
	WDOG_STCTRLH_ALLOWUPDATE_0 = 0x0
	// WDOG write-once registers can be unlocked for updating.
	WDOG_STCTRLH_ALLOWUPDATE_1 = 0x1
	// Position of DBGEN field.
	WDOG_STCTRLH_DBGEN_Pos = 0x5
	// Bit mask of DBGEN field.
	WDOG_STCTRLH_DBGEN_Msk = 0x20
	// Bit DBGEN.
	WDOG_STCTRLH_DBGEN = 0x20
	// WDOG is disabled in CPU Debug mode.
	WDOG_STCTRLH_DBGEN_0 = 0x0
	// WDOG is enabled in CPU Debug mode.
	WDOG_STCTRLH_DBGEN_1 = 0x1
	// Position of STOPEN field.
	WDOG_STCTRLH_STOPEN_Pos = 0x6
	// Bit mask of STOPEN field.
	WDOG_STCTRLH_STOPEN_Msk = 0x40
	// Bit STOPEN.
	WDOG_STCTRLH_STOPEN = 0x40
	// WDOG is disabled in CPU Stop mode.
	WDOG_STCTRLH_STOPEN_0 = 0x0
	// WDOG is enabled in CPU Stop mode.
	WDOG_STCTRLH_STOPEN_1 = 0x1
	// Position of WAITEN field.
	WDOG_STCTRLH_WAITEN_Pos = 0x7
	// Bit mask of WAITEN field.
	WDOG_STCTRLH_WAITEN_Msk = 0x80
	// Bit WAITEN.
	WDOG_STCTRLH_WAITEN = 0x80
	// WDOG is disabled in CPU Wait mode.
	WDOG_STCTRLH_WAITEN_0 = 0x0
	// WDOG is enabled in CPU Wait mode.
	WDOG_STCTRLH_WAITEN_1 = 0x1
	// Position of TESTWDOG field.
	WDOG_STCTRLH_TESTWDOG_Pos = 0xa
	// Bit mask of TESTWDOG field.
	WDOG_STCTRLH_TESTWDOG_Msk = 0x400
	// Bit TESTWDOG.
	WDOG_STCTRLH_TESTWDOG = 0x400
	// Position of TESTSEL field.
	WDOG_STCTRLH_TESTSEL_Pos = 0xb
	// Bit mask of TESTSEL field.
	WDOG_STCTRLH_TESTSEL_Msk = 0x800
	// Bit TESTSEL.
	WDOG_STCTRLH_TESTSEL = 0x800
	// Quick test. The timer runs in normal operation. You can load a small time-out value to do a quick test.
	WDOG_STCTRLH_TESTSEL_0 = 0x0
	// Byte test. Puts the timer in the byte test mode where individual bytes of the timer are enabled for operation and are compared for time-out against the corresponding byte of the programmed time-out value. Select the byte through BYTESEL[1:0] for testing.
	WDOG_STCTRLH_TESTSEL_1 = 0x1
	// Position of BYTESEL field.
	WDOG_STCTRLH_BYTESEL_Pos = 0xc
	// Bit mask of BYTESEL field.
	WDOG_STCTRLH_BYTESEL_Msk = 0x3000
	// Byte 0 selected
	WDOG_STCTRLH_BYTESEL_00 = 0x0
	// Byte 1 selected
	WDOG_STCTRLH_BYTESEL_01 = 0x1
	// Byte 2 selected
	WDOG_STCTRLH_BYTESEL_10 = 0x2
	// Byte 3 selected
	WDOG_STCTRLH_BYTESEL_11 = 0x3
	// Position of DISTESTWDOG field.
	WDOG_STCTRLH_DISTESTWDOG_Pos = 0xe
	// Bit mask of DISTESTWDOG field.
	WDOG_STCTRLH_DISTESTWDOG_Msk = 0x4000
	// Bit DISTESTWDOG.
	WDOG_STCTRLH_DISTESTWDOG = 0x4000
	// WDOG functional test mode is not disabled.
	WDOG_STCTRLH_DISTESTWDOG_0 = 0x0
	// WDOG functional test mode is disabled permanently until reset.
	WDOG_STCTRLH_DISTESTWDOG_1 = 0x1

	// STCTRLL: Watchdog Status and Control Register Low
	// Position of INTFLG field.
	WDOG_STCTRLL_INTFLG_Pos = 0xf
	// Bit mask of INTFLG field.
	WDOG_STCTRLL_INTFLG_Msk = 0x8000
	// Bit INTFLG.
	WDOG_STCTRLL_INTFLG = 0x8000

	// TOVALH: Watchdog Time-out Value Register High
	// Position of TOVALHIGH field.
	WDOG_TOVALH_TOVALHIGH_Pos = 0x0
	// Bit mask of TOVALHIGH field.
	WDOG_TOVALH_TOVALHIGH_Msk = 0xffff

	// TOVALL: Watchdog Time-out Value Register Low
	// Position of TOVALLOW field.
	WDOG_TOVALL_TOVALLOW_Pos = 0x0
	// Bit mask of TOVALLOW field.
	WDOG_TOVALL_TOVALLOW_Msk = 0xffff

	// WINH: Watchdog Window Register High
	// Position of WINHIGH field.
	WDOG_WINH_WINHIGH_Pos = 0x0
	// Bit mask of WINHIGH field.
	WDOG_WINH_WINHIGH_Msk = 0xffff

	// WINL: Watchdog Window Register Low
	// Position of WINLOW field.
	WDOG_WINL_WINLOW_Pos = 0x0
	// Bit mask of WINLOW field.
	WDOG_WINL_WINLOW_Msk = 0xffff

	// REFRESH: Watchdog Refresh register
	// Position of WDOGREFRESH field.
	WDOG_REFRESH_WDOGREFRESH_Pos = 0x0
	// Bit mask of WDOGREFRESH field.
	WDOG_REFRESH_WDOGREFRESH_Msk = 0xffff

	// UNLOCK: Watchdog Unlock register
	// Position of WDOGUNLOCK field.
	WDOG_UNLOCK_WDOGUNLOCK_Pos = 0x0
	// Bit mask of WDOGUNLOCK field.
	WDOG_UNLOCK_WDOGUNLOCK_Msk = 0xffff

	// TMROUTH: Watchdog Timer Output Register High
	// Position of TIMEROUTHIGH field.
	WDOG_TMROUTH_TIMEROUTHIGH_Pos = 0x0
	// Bit mask of TIMEROUTHIGH field.
	WDOG_TMROUTH_TIMEROUTHIGH_Msk = 0xffff

	// TMROUTL: Watchdog Timer Output Register Low
	// Position of TIMEROUTLOW field.
	WDOG_TMROUTL_TIMEROUTLOW_Pos = 0x0
	// Bit mask of TIMEROUTLOW field.
	WDOG_TMROUTL_TIMEROUTLOW_Msk = 0xffff

	// RSTCNT: Watchdog Reset Count register
	// Position of RSTCNT field.
	WDOG_RSTCNT_RSTCNT_Pos = 0x0
	// Bit mask of RSTCNT field.
	WDOG_RSTCNT_RSTCNT_Msk = 0xffff

	// PRESC: Watchdog Prescaler register
	// Position of PRESCVAL field.
	WDOG_PRESC_PRESCVAL_Pos = 0x8
	// Bit mask of PRESCVAL field.
	WDOG_PRESC_PRESCVAL_Msk = 0x700
)

// Constants for EWM: External Watchdog Monitor
const (
	// CTRL: Control Register
	// Position of EWMEN field.
	EWM_CTRL_EWMEN_Pos = 0x0
	// Bit mask of EWMEN field.
	EWM_CTRL_EWMEN_Msk = 0x1
	// Bit EWMEN.
	EWM_CTRL_EWMEN = 0x1
	// Position of ASSIN field.
	EWM_CTRL_ASSIN_Pos = 0x1
	// Bit mask of ASSIN field.
	EWM_CTRL_ASSIN_Msk = 0x2
	// Bit ASSIN.
	EWM_CTRL_ASSIN = 0x2
	// Position of INEN field.
	EWM_CTRL_INEN_Pos = 0x2
	// Bit mask of INEN field.
	EWM_CTRL_INEN_Msk = 0x4
	// Bit INEN.
	EWM_CTRL_INEN = 0x4
	// Position of INTEN field.
	EWM_CTRL_INTEN_Pos = 0x3
	// Bit mask of INTEN field.
	EWM_CTRL_INTEN_Msk = 0x8
	// Bit INTEN.
	EWM_CTRL_INTEN = 0x8

	// SERV: Service Register
	// Position of SERVICE field.
	EWM_SERV_SERVICE_Pos = 0x0
	// Bit mask of SERVICE field.
	EWM_SERV_SERVICE_Msk = 0xff

	// CMPL: Compare Low Register
	// Position of COMPAREL field.
	EWM_CMPL_COMPAREL_Pos = 0x0
	// Bit mask of COMPAREL field.
	EWM_CMPL_COMPAREL_Msk = 0xff

	// CMPH: Compare High Register
	// Position of COMPAREH field.
	EWM_CMPH_COMPAREH_Pos = 0x0
	// Bit mask of COMPAREH field.
	EWM_CMPH_COMPAREH_Msk = 0xff
)

// Constants for CMT: Carrier Modulator Transmitter
const (
	// CGH1: CMT Carrier Generator High Data Register 1
	// Position of PH field.
	CMT_CGH1_PH_Pos = 0x0
	// Bit mask of PH field.
	CMT_CGH1_PH_Msk = 0xff

	// CGL1: CMT Carrier Generator Low Data Register 1
	// Position of PL field.
	CMT_CGL1_PL_Pos = 0x0
	// Bit mask of PL field.
	CMT_CGL1_PL_Msk = 0xff

	// CGH2: CMT Carrier Generator High Data Register 2
	// Position of SH field.
	CMT_CGH2_SH_Pos = 0x0
	// Bit mask of SH field.
	CMT_CGH2_SH_Msk = 0xff

	// CGL2: CMT Carrier Generator Low Data Register 2
	// Position of SL field.
	CMT_CGL2_SL_Pos = 0x0
	// Bit mask of SL field.
	CMT_CGL2_SL_Msk = 0xff

	// OC: CMT Output Control Register
	// Position of IROPEN field.
	CMT_OC_IROPEN_Pos = 0x5
	// Bit mask of IROPEN field.
	CMT_OC_IROPEN_Msk = 0x20
	// Bit IROPEN.
	CMT_OC_IROPEN = 0x20
	// The IRO signal is disabled.
	CMT_OC_IROPEN_0 = 0x0
	// The IRO signal is enabled as output.
	CMT_OC_IROPEN_1 = 0x1
	// Position of CMTPOL field.
	CMT_OC_CMTPOL_Pos = 0x6
	// Bit mask of CMTPOL field.
	CMT_OC_CMTPOL_Msk = 0x40
	// Bit CMTPOL.
	CMT_OC_CMTPOL = 0x40
	// The IRO signal is active-low.
	CMT_OC_CMTPOL_0 = 0x0
	// The IRO signal is active-high.
	CMT_OC_CMTPOL_1 = 0x1
	// Position of IROL field.
	CMT_OC_IROL_Pos = 0x7
	// Bit mask of IROL field.
	CMT_OC_IROL_Msk = 0x80
	// Bit IROL.
	CMT_OC_IROL = 0x80

	// MSC: CMT Modulator Status and Control Register
	// Position of MCGEN field.
	CMT_MSC_MCGEN_Pos = 0x0
	// Bit mask of MCGEN field.
	CMT_MSC_MCGEN_Msk = 0x1
	// Bit MCGEN.
	CMT_MSC_MCGEN = 0x1
	// Modulator and carrier generator disabled
	CMT_MSC_MCGEN_0 = 0x0
	// Modulator and carrier generator enabled
	CMT_MSC_MCGEN_1 = 0x1
	// Position of EOCIE field.
	CMT_MSC_EOCIE_Pos = 0x1
	// Bit mask of EOCIE field.
	CMT_MSC_EOCIE_Msk = 0x2
	// Bit EOCIE.
	CMT_MSC_EOCIE = 0x2
	// CPU interrupt is disabled.
	CMT_MSC_EOCIE_0 = 0x0
	// CPU interrupt is enabled.
	CMT_MSC_EOCIE_1 = 0x1
	// Position of FSK field.
	CMT_MSC_FSK_Pos = 0x2
	// Bit mask of FSK field.
	CMT_MSC_FSK_Msk = 0x4
	// Bit FSK.
	CMT_MSC_FSK = 0x4
	// The CMT operates in Time or Baseband mode.
	CMT_MSC_FSK_0 = 0x0
	// The CMT operates in FSK mode.
	CMT_MSC_FSK_1 = 0x1
	// Position of BASE field.
	CMT_MSC_BASE_Pos = 0x3
	// Bit mask of BASE field.
	CMT_MSC_BASE_Msk = 0x8
	// Bit BASE.
	CMT_MSC_BASE = 0x8
	// Baseband mode is disabled.
	CMT_MSC_BASE_0 = 0x0
	// Baseband mode is enabled.
	CMT_MSC_BASE_1 = 0x1
	// Position of EXSPC field.
	CMT_MSC_EXSPC_Pos = 0x4
	// Bit mask of EXSPC field.
	CMT_MSC_EXSPC_Msk = 0x10
	// Bit EXSPC.
	CMT_MSC_EXSPC = 0x10
	// Extended space is disabled.
	CMT_MSC_EXSPC_0 = 0x0
	// Extended space is enabled.
	CMT_MSC_EXSPC_1 = 0x1
	// Position of CMTDIV field.
	CMT_MSC_CMTDIV_Pos = 0x5
	// Bit mask of CMTDIV field.
	CMT_MSC_CMTDIV_Msk = 0x60
	// IF * 1
	CMT_MSC_CMTDIV_00 = 0x0
	// IF * 2
	CMT_MSC_CMTDIV_01 = 0x1
	// IF * 4
	CMT_MSC_CMTDIV_10 = 0x2
	// IF * 8
	CMT_MSC_CMTDIV_11 = 0x3
	// Position of EOCF field.
	CMT_MSC_EOCF_Pos = 0x7
	// Bit mask of EOCF field.
	CMT_MSC_EOCF_Msk = 0x80
	// Bit EOCF.
	CMT_MSC_EOCF = 0x80
	// End of modulation cycle has not occurred since the flag last cleared.
	CMT_MSC_EOCF_0 = 0x0
	// End of modulator cycle has occurred.
	CMT_MSC_EOCF_1 = 0x1

	// CMD1: CMT Modulator Data Register Mark High
	// Position of MB field.
	CMT_CMD1_MB_Pos = 0x0
	// Bit mask of MB field.
	CMT_CMD1_MB_Msk = 0xff

	// CMD2: CMT Modulator Data Register Mark Low
	// Position of MB field.
	CMT_CMD2_MB_Pos = 0x0
	// Bit mask of MB field.
	CMT_CMD2_MB_Msk = 0xff

	// CMD3: CMT Modulator Data Register Space High
	// Position of SB field.
	CMT_CMD3_SB_Pos = 0x0
	// Bit mask of SB field.
	CMT_CMD3_SB_Msk = 0xff

	// CMD4: CMT Modulator Data Register Space Low
	// Position of SB field.
	CMT_CMD4_SB_Pos = 0x0
	// Bit mask of SB field.
	CMT_CMD4_SB_Msk = 0xff

	// PPS: CMT Primary Prescaler Register
	// Position of PPSDIV field.
	CMT_PPS_PPSDIV_Pos = 0x0
	// Bit mask of PPSDIV field.
	CMT_PPS_PPSDIV_Msk = 0xf
	// Bus clock * 1
	CMT_PPS_PPSDIV_0000 = 0x0
	// Bus clock * 2
	CMT_PPS_PPSDIV_0001 = 0x1
	// Bus clock * 3
	CMT_PPS_PPSDIV_0010 = 0x2
	// Bus clock * 4
	CMT_PPS_PPSDIV_0011 = 0x3
	// Bus clock * 5
	CMT_PPS_PPSDIV_0100 = 0x4
	// Bus clock * 6
	CMT_PPS_PPSDIV_0101 = 0x5
	// Bus clock * 7
	CMT_PPS_PPSDIV_0110 = 0x6
	// Bus clock * 8
	CMT_PPS_PPSDIV_0111 = 0x7
	// Bus clock * 9
	CMT_PPS_PPSDIV_1000 = 0x8
	// Bus clock * 10
	CMT_PPS_PPSDIV_1001 = 0x9
	// Bus clock * 11
	CMT_PPS_PPSDIV_1010 = 0xa
	// Bus clock * 12
	CMT_PPS_PPSDIV_1011 = 0xb
	// Bus clock * 13
	CMT_PPS_PPSDIV_1100 = 0xc
	// Bus clock * 14
	CMT_PPS_PPSDIV_1101 = 0xd
	// Bus clock * 15
	CMT_PPS_PPSDIV_1110 = 0xe
	// Bus clock * 16
	CMT_PPS_PPSDIV_1111 = 0xf

	// DMA: CMT Direct Memory Access Register
	// Position of DMA field.
	CMT_DMA_DMA_Pos = 0x0
	// Bit mask of DMA field.
	CMT_DMA_DMA_Msk = 0x1
	// Bit DMA.
	CMT_DMA_DMA = 0x1
	// DMA transfer request and done are disabled.
	CMT_DMA_DMA_0 = 0x0
	// DMA transfer request and done are enabled.
	CMT_DMA_DMA_1 = 0x1
)

// Constants for MCG: Multipurpose Clock Generator module
const (
	// C1: MCG Control 1 Register
	// Position of IREFSTEN field.
	MCG_C1_IREFSTEN_Pos = 0x0
	// Bit mask of IREFSTEN field.
	MCG_C1_IREFSTEN_Msk = 0x1
	// Bit IREFSTEN.
	MCG_C1_IREFSTEN = 0x1
	// Internal reference clock is disabled in Stop mode.
	MCG_C1_IREFSTEN_0 = 0x0
	// Internal reference clock is enabled in Stop mode if IRCLKEN is set or if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
	MCG_C1_IREFSTEN_1 = 0x1
	// Position of IRCLKEN field.
	MCG_C1_IRCLKEN_Pos = 0x1
	// Bit mask of IRCLKEN field.
	MCG_C1_IRCLKEN_Msk = 0x2
	// Bit IRCLKEN.
	MCG_C1_IRCLKEN = 0x2
	// MCGIRCLK inactive.
	MCG_C1_IRCLKEN_0 = 0x0
	// MCGIRCLK active.
	MCG_C1_IRCLKEN_1 = 0x1
	// Position of IREFS field.
	MCG_C1_IREFS_Pos = 0x2
	// Bit mask of IREFS field.
	MCG_C1_IREFS_Msk = 0x4
	// Bit IREFS.
	MCG_C1_IREFS = 0x4
	// External reference clock is selected.
	MCG_C1_IREFS_0 = 0x0
	// The slow internal reference clock is selected.
	MCG_C1_IREFS_1 = 0x1
	// Position of FRDIV field.
	MCG_C1_FRDIV_Pos = 0x3
	// Bit mask of FRDIV field.
	MCG_C1_FRDIV_Msk = 0x38
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 1; for all other RANGE values, Divide Factor is 32.
	MCG_C1_FRDIV_000 = 0x0
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 2; for all other RANGE values, Divide Factor is 64.
	MCG_C1_FRDIV_001 = 0x1
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 4; for all other RANGE values, Divide Factor is 128.
	MCG_C1_FRDIV_010 = 0x2
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 8; for all other RANGE values, Divide Factor is 256.
	MCG_C1_FRDIV_011 = 0x3
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 16; for all other RANGE values, Divide Factor is 512.
	MCG_C1_FRDIV_100 = 0x4
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 32; for all other RANGE values, Divide Factor is 1024.
	MCG_C1_FRDIV_101 = 0x5
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 64; for all other RANGE values, Divide Factor is 1280 .
	MCG_C1_FRDIV_110 = 0x6
	// If RANGE = 0 or OSCSEL=1 , Divide Factor is 128; for all other RANGE values, Divide Factor is 1536 .
	MCG_C1_FRDIV_111 = 0x7
	// Position of CLKS field.
	MCG_C1_CLKS_Pos = 0x6
	// Bit mask of CLKS field.
	MCG_C1_CLKS_Msk = 0xc0
	// Encoding 0 - Output of FLL or PLLCS is selected (depends on PLLS control bit).
	MCG_C1_CLKS_00 = 0x0
	// Encoding 1 - Internal reference clock is selected.
	MCG_C1_CLKS_01 = 0x1
	// Encoding 2 - External reference clock is selected.
	MCG_C1_CLKS_10 = 0x2
	// Encoding 3 - Reserved.
	MCG_C1_CLKS_11 = 0x3

	// C2: MCG Control 2 Register
	// Position of IRCS field.
	MCG_C2_IRCS_Pos = 0x0
	// Bit mask of IRCS field.
	MCG_C2_IRCS_Msk = 0x1
	// Bit IRCS.
	MCG_C2_IRCS = 0x1
	// Slow internal reference clock selected.
	MCG_C2_IRCS_0 = 0x0
	// Fast internal reference clock selected.
	MCG_C2_IRCS_1 = 0x1
	// Position of LP field.
	MCG_C2_LP_Pos = 0x1
	// Bit mask of LP field.
	MCG_C2_LP_Msk = 0x2
	// Bit LP.
	MCG_C2_LP = 0x2
	// FLL or PLL is not disabled in bypass modes.
	MCG_C2_LP_0 = 0x0
	// FLL or PLL is disabled in bypass modes (lower power)
	MCG_C2_LP_1 = 0x1
	// Position of EREFS field.
	MCG_C2_EREFS_Pos = 0x2
	// Bit mask of EREFS field.
	MCG_C2_EREFS_Msk = 0x4
	// Bit EREFS.
	MCG_C2_EREFS = 0x4
	// External reference clock requested.
	MCG_C2_EREFS_0 = 0x0
	// Oscillator requested.
	MCG_C2_EREFS_1 = 0x1
	// Position of HGO field.
	MCG_C2_HGO_Pos = 0x3
	// Bit mask of HGO field.
	MCG_C2_HGO_Msk = 0x8
	// Bit HGO.
	MCG_C2_HGO = 0x8
	// Configure crystal oscillator for low-power operation.
	MCG_C2_HGO_0 = 0x0
	// Configure crystal oscillator for high-gain operation.
	MCG_C2_HGO_1 = 0x1
	// Position of RANGE field.
	MCG_C2_RANGE_Pos = 0x4
	// Bit mask of RANGE field.
	MCG_C2_RANGE_Msk = 0x30
	// Encoding 0 - Low frequency range selected for the crystal oscillator .
	MCG_C2_RANGE_00 = 0x0
	// Encoding 1 - High frequency range selected for the crystal oscillator .
	MCG_C2_RANGE_01 = 0x1
	// Position of FCFTRIM field.
	MCG_C2_FCFTRIM_Pos = 0x6
	// Bit mask of FCFTRIM field.
	MCG_C2_FCFTRIM_Msk = 0x40
	// Bit FCFTRIM.
	MCG_C2_FCFTRIM = 0x40
	// Position of LOCRE0 field.
	MCG_C2_LOCRE0_Pos = 0x7
	// Bit mask of LOCRE0 field.
	MCG_C2_LOCRE0_Msk = 0x80
	// Bit LOCRE0.
	MCG_C2_LOCRE0 = 0x80
	// Interrupt request is generated on a loss of OSC0 external reference clock.
	MCG_C2_LOCRE0_0 = 0x0
	// Generate a reset request on a loss of OSC0 external reference clock.
	MCG_C2_LOCRE0_1 = 0x1

	// C3: MCG Control 3 Register
	// Position of SCTRIM field.
	MCG_C3_SCTRIM_Pos = 0x0
	// Bit mask of SCTRIM field.
	MCG_C3_SCTRIM_Msk = 0xff

	// C4: MCG Control 4 Register
	// Position of SCFTRIM field.
	MCG_C4_SCFTRIM_Pos = 0x0
	// Bit mask of SCFTRIM field.
	MCG_C4_SCFTRIM_Msk = 0x1
	// Bit SCFTRIM.
	MCG_C4_SCFTRIM = 0x1
	// Position of FCTRIM field.
	MCG_C4_FCTRIM_Pos = 0x1
	// Bit mask of FCTRIM field.
	MCG_C4_FCTRIM_Msk = 0x1e
	// Position of DRST_DRS field.
	MCG_C4_DRST_DRS_Pos = 0x5
	// Bit mask of DRST_DRS field.
	MCG_C4_DRST_DRS_Msk = 0x60
	// Encoding 0 - Low range (reset default).
	MCG_C4_DRST_DRS_00 = 0x0
	// Encoding 1 - Mid range.
	MCG_C4_DRST_DRS_01 = 0x1
	// Encoding 2 - Mid-high range.
	MCG_C4_DRST_DRS_10 = 0x2
	// Encoding 3 - High range.
	MCG_C4_DRST_DRS_11 = 0x3
	// Position of DMX32 field.
	MCG_C4_DMX32_Pos = 0x7
	// Bit mask of DMX32 field.
	MCG_C4_DMX32_Msk = 0x80
	// Bit DMX32.
	MCG_C4_DMX32 = 0x80
	// DCO has a default range of 25%.
	MCG_C4_DMX32_0 = 0x0
	// DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
	MCG_C4_DMX32_1 = 0x1

	// C5: MCG Control 5 Register
	// Position of PRDIV field.
	MCG_C5_PRDIV_Pos = 0x0
	// Bit mask of PRDIV field.
	MCG_C5_PRDIV_Msk = 0x7
	// Divide Factor is 1
	MCG_C5_PRDIV_0 = 0x0
	// Divide Factor is 2
	MCG_C5_PRDIV_1 = 0x1
	// Divide Factor is 3
	MCG_C5_PRDIV_2 = 0x2
	// Divide Factor is 4
	MCG_C5_PRDIV_3 = 0x3
	// Divide Factor is 5
	MCG_C5_PRDIV_4 = 0x4
	// Divide Factor is 6
	MCG_C5_PRDIV_5 = 0x5
	// Divide Factor is 7
	MCG_C5_PRDIV_6 = 0x6
	// Divide Factor is 8
	MCG_C5_PRDIV_7 = 0x7
	// Position of PLLSTEN field.
	MCG_C5_PLLSTEN_Pos = 0x5
	// Bit mask of PLLSTEN field.
	MCG_C5_PLLSTEN_Msk = 0x20
	// Bit PLLSTEN.
	MCG_C5_PLLSTEN = 0x20
	// MCGPLLCLK and MCGPLLCLK2X are disabled in any of the Stop modes.
	MCG_C5_PLLSTEN_0 = 0x0
	// MCGPLLCLK and MCGPLLCLK2X are enabled if system is in Normal Stop mode.
	MCG_C5_PLLSTEN_1 = 0x1
	// Position of PLLCLKEN field.
	MCG_C5_PLLCLKEN_Pos = 0x6
	// Bit mask of PLLCLKEN field.
	MCG_C5_PLLCLKEN_Msk = 0x40
	// Bit PLLCLKEN.
	MCG_C5_PLLCLKEN = 0x40
	// MCGPLLCLK is inactive.
	MCG_C5_PLLCLKEN_0 = 0x0
	// MCGPLLCLK is active.
	MCG_C5_PLLCLKEN_1 = 0x1

	// C6: MCG Control 6 Register
	// Position of VDIV field.
	MCG_C6_VDIV_Pos = 0x0
	// Bit mask of VDIV field.
	MCG_C6_VDIV_Msk = 0x1f
	// Multiply Factor is 16
	MCG_C6_VDIV_0 = 0x0
	// Multiply Factor is 17
	MCG_C6_VDIV_1 = 0x1
	// Multiply Factor is 18
	MCG_C6_VDIV_2 = 0x2
	// Multiply Factor is 19
	MCG_C6_VDIV_3 = 0x3
	// Multiply Factor is 20
	MCG_C6_VDIV_4 = 0x4
	// Multiply Factor is 21
	MCG_C6_VDIV_5 = 0x5
	// Multiply Factor is 22
	MCG_C6_VDIV_6 = 0x6
	// Multiply Factor is 23
	MCG_C6_VDIV_7 = 0x7
	// Multiply Factor is 24
	MCG_C6_VDIV_8 = 0x8
	// Multiply Factor is 25
	MCG_C6_VDIV_9 = 0x9
	// Multiply Factor is 26
	MCG_C6_VDIV_10 = 0xa
	// Multiply Factor is 27
	MCG_C6_VDIV_11 = 0xb
	// Multiply Factor is 28
	MCG_C6_VDIV_12 = 0xc
	// Multiply Factor is 29
	MCG_C6_VDIV_13 = 0xd
	// Multiply Factor is 30
	MCG_C6_VDIV_14 = 0xe
	// Multiply Factor is 31
	MCG_C6_VDIV_15 = 0xf
	// Multiply Factor is 32
	MCG_C6_VDIV_16 = 0x10
	// Multiply Factor is 33
	MCG_C6_VDIV_17 = 0x11
	// Multiply Factor is 34
	MCG_C6_VDIV_18 = 0x12
	// Multiply Factor is 35
	MCG_C6_VDIV_19 = 0x13
	// Multiply Factor is 36
	MCG_C6_VDIV_20 = 0x14
	// Multiply Factor is 37
	MCG_C6_VDIV_21 = 0x15
	// Multiply Factor is 38
	MCG_C6_VDIV_22 = 0x16
	// Multiply Factor is 39
	MCG_C6_VDIV_23 = 0x17
	// Multiply Factor is 40
	MCG_C6_VDIV_24 = 0x18
	// Multiply Factor is 41
	MCG_C6_VDIV_25 = 0x19
	// Multiply Factor is 42
	MCG_C6_VDIV_26 = 0x1a
	// Multiply Factor is 43
	MCG_C6_VDIV_27 = 0x1b
	// Multiply Factor is 44
	MCG_C6_VDIV_28 = 0x1c
	// Multiply Factor is 45
	MCG_C6_VDIV_29 = 0x1d
	// Multiply Factor is 46
	MCG_C6_VDIV_30 = 0x1e
	// Multiply Factor is 47
	MCG_C6_VDIV_31 = 0x1f
	// Position of CME0 field.
	MCG_C6_CME0_Pos = 0x5
	// Bit mask of CME0 field.
	MCG_C6_CME0_Msk = 0x20
	// Bit CME0.
	MCG_C6_CME0 = 0x20
	// External clock monitor is disabled for OSC0.
	MCG_C6_CME0_0 = 0x0
	// External clock monitor is enabled for OSC0.
	MCG_C6_CME0_1 = 0x1
	// Position of PLLS field.
	MCG_C6_PLLS_Pos = 0x6
	// Bit mask of PLLS field.
	MCG_C6_PLLS_Msk = 0x40
	// Bit PLLS.
	MCG_C6_PLLS = 0x40
	// FLL is selected.
	MCG_C6_PLLS_0 = 0x0
	// PLLCS output clock is selected (PRDIV0 bits of PLL in the C5 register need to be programmed to the correct divider to generate a PLL reference clock in the range specified in the data sheet (fpll_ref) prior to setting the PLLS bit).
	MCG_C6_PLLS_1 = 0x1
	// Position of LOLIE0 field.
	MCG_C6_LOLIE0_Pos = 0x7
	// Bit mask of LOLIE0 field.
	MCG_C6_LOLIE0_Msk = 0x80
	// Bit LOLIE0.
	MCG_C6_LOLIE0 = 0x80
	// No interrupt request is generated on loss of lock.
	MCG_C6_LOLIE0_0 = 0x0
	// Generate an interrupt request on loss of lock.
	MCG_C6_LOLIE0_1 = 0x1

	// S: MCG Status Register
	// Position of IRCST field.
	MCG_S_IRCST_Pos = 0x0
	// Bit mask of IRCST field.
	MCG_S_IRCST_Msk = 0x1
	// Bit IRCST.
	MCG_S_IRCST = 0x1
	// Source of internal reference clock is the slow clock (32 kHz IRC).
	MCG_S_IRCST_0 = 0x0
	// Source of internal reference clock is the fast clock (4 MHz IRC).
	MCG_S_IRCST_1 = 0x1
	// Position of OSCINIT0 field.
	MCG_S_OSCINIT0_Pos = 0x1
	// Bit mask of OSCINIT0 field.
	MCG_S_OSCINIT0_Msk = 0x2
	// Bit OSCINIT0.
	MCG_S_OSCINIT0 = 0x2
	// Position of CLKST field.
	MCG_S_CLKST_Pos = 0x2
	// Bit mask of CLKST field.
	MCG_S_CLKST_Msk = 0xc
	// Encoding 0 - Output of the FLL is selected (reset default).
	MCG_S_CLKST_00 = 0x0
	// Encoding 1 - Internal reference clock is selected.
	MCG_S_CLKST_01 = 0x1
	// Encoding 2 - External reference clock is selected.
	MCG_S_CLKST_10 = 0x2
	// Encoding 3 - Output of the PLL is selected.
	MCG_S_CLKST_11 = 0x3
	// Position of IREFST field.
	MCG_S_IREFST_Pos = 0x4
	// Bit mask of IREFST field.
	MCG_S_IREFST_Msk = 0x10
	// Bit IREFST.
	MCG_S_IREFST = 0x10
	// Source of FLL reference clock is the external reference clock.
	MCG_S_IREFST_0 = 0x0
	// Source of FLL reference clock is the internal reference clock.
	MCG_S_IREFST_1 = 0x1
	// Position of PLLST field.
	MCG_S_PLLST_Pos = 0x5
	// Bit mask of PLLST field.
	MCG_S_PLLST_Msk = 0x20
	// Bit PLLST.
	MCG_S_PLLST = 0x20
	// Source of PLLS clock is FLL clock.
	MCG_S_PLLST_0 = 0x0
	// Source of PLLS clock is PLLCS output clock.
	MCG_S_PLLST_1 = 0x1
	// Position of LOCK0 field.
	MCG_S_LOCK0_Pos = 0x6
	// Bit mask of LOCK0 field.
	MCG_S_LOCK0_Msk = 0x40
	// Bit LOCK0.
	MCG_S_LOCK0 = 0x40
	// PLL is currently unlocked.
	MCG_S_LOCK0_0 = 0x0
	// PLL is currently locked.
	MCG_S_LOCK0_1 = 0x1
	// Position of LOLS0 field.
	MCG_S_LOLS0_Pos = 0x7
	// Bit mask of LOLS0 field.
	MCG_S_LOLS0_Msk = 0x80
	// Bit LOLS0.
	MCG_S_LOLS0 = 0x80
	// PLL has not lost lock since LOLS 0 was last cleared.
	MCG_S_LOLS0_0 = 0x0
	// PLL has lost lock since LOLS 0 was last cleared.
	MCG_S_LOLS0_1 = 0x1

	// SC: MCG Status and Control Register
	// Position of LOCS0 field.
	MCG_SC_LOCS0_Pos = 0x0
	// Bit mask of LOCS0 field.
	MCG_SC_LOCS0_Msk = 0x1
	// Bit LOCS0.
	MCG_SC_LOCS0 = 0x1
	// Loss of OSC0 has not occurred.
	MCG_SC_LOCS0_0 = 0x0
	// Loss of OSC0 has occurred.
	MCG_SC_LOCS0_1 = 0x1
	// Position of FCRDIV field.
	MCG_SC_FCRDIV_Pos = 0x1
	// Bit mask of FCRDIV field.
	MCG_SC_FCRDIV_Msk = 0xe
	// Divide Factor is 1
	MCG_SC_FCRDIV_000 = 0x0
	// Divide Factor is 2.
	MCG_SC_FCRDIV_001 = 0x1
	// Divide Factor is 4.
	MCG_SC_FCRDIV_010 = 0x2
	// Divide Factor is 8.
	MCG_SC_FCRDIV_011 = 0x3
	// Divide Factor is 16
	MCG_SC_FCRDIV_100 = 0x4
	// Divide Factor is 32
	MCG_SC_FCRDIV_101 = 0x5
	// Divide Factor is 64
	MCG_SC_FCRDIV_110 = 0x6
	// Divide Factor is 128.
	MCG_SC_FCRDIV_111 = 0x7
	// Position of FLTPRSRV field.
	MCG_SC_FLTPRSRV_Pos = 0x4
	// Bit mask of FLTPRSRV field.
	MCG_SC_FLTPRSRV_Msk = 0x10
	// Bit FLTPRSRV.
	MCG_SC_FLTPRSRV = 0x10
	// FLL filter and FLL frequency will reset on changes to currect clock mode.
	MCG_SC_FLTPRSRV_0 = 0x0
	// Fll filter and FLL frequency retain their previous values during new clock mode change.
	MCG_SC_FLTPRSRV_1 = 0x1
	// Position of ATMF field.
	MCG_SC_ATMF_Pos = 0x5
	// Bit mask of ATMF field.
	MCG_SC_ATMF_Msk = 0x20
	// Bit ATMF.
	MCG_SC_ATMF = 0x20
	// Automatic Trim Machine completed normally.
	MCG_SC_ATMF_0 = 0x0
	// Automatic Trim Machine failed.
	MCG_SC_ATMF_1 = 0x1
	// Position of ATMS field.
	MCG_SC_ATMS_Pos = 0x6
	// Bit mask of ATMS field.
	MCG_SC_ATMS_Msk = 0x40
	// Bit ATMS.
	MCG_SC_ATMS = 0x40
	// 32 kHz Internal Reference Clock selected.
	MCG_SC_ATMS_0 = 0x0
	// 4 MHz Internal Reference Clock selected.
	MCG_SC_ATMS_1 = 0x1
	// Position of ATME field.
	MCG_SC_ATME_Pos = 0x7
	// Bit mask of ATME field.
	MCG_SC_ATME_Msk = 0x80
	// Bit ATME.
	MCG_SC_ATME = 0x80
	// Auto Trim Machine disabled.
	MCG_SC_ATME_0 = 0x0
	// Auto Trim Machine enabled.
	MCG_SC_ATME_1 = 0x1

	// ATCVH: MCG Auto Trim Compare Value High Register
	// Position of ATCVH field.
	MCG_ATCVH_ATCVH_Pos = 0x0
	// Bit mask of ATCVH field.
	MCG_ATCVH_ATCVH_Msk = 0xff

	// ATCVL: MCG Auto Trim Compare Value Low Register
	// Position of ATCVL field.
	MCG_ATCVL_ATCVL_Pos = 0x0
	// Bit mask of ATCVL field.
	MCG_ATCVL_ATCVL_Msk = 0xff

	// C7: MCG Control 7 Register
	// Position of OSCSEL field.
	MCG_C7_OSCSEL_Pos = 0x0
	// Bit mask of OSCSEL field.
	MCG_C7_OSCSEL_Msk = 0x3
	// Selects Oscillator (OSCCLK0).
	MCG_C7_OSCSEL_00 = 0x0
	// Selects 32 kHz RTC Oscillator.
	MCG_C7_OSCSEL_01 = 0x1
	// Selects Oscillator (OSCCLK1).
	MCG_C7_OSCSEL_10 = 0x2

	// C8: MCG Control 8 Register
	// Position of LOCS1 field.
	MCG_C8_LOCS1_Pos = 0x0
	// Bit mask of LOCS1 field.
	MCG_C8_LOCS1_Msk = 0x1
	// Bit LOCS1.
	MCG_C8_LOCS1 = 0x1
	// Loss of RTC has not occur.
	MCG_C8_LOCS1_0 = 0x0
	// Loss of RTC has occur
	MCG_C8_LOCS1_1 = 0x1
	// Position of CME1 field.
	MCG_C8_CME1_Pos = 0x5
	// Bit mask of CME1 field.
	MCG_C8_CME1_Msk = 0x20
	// Bit CME1.
	MCG_C8_CME1 = 0x20
	// External clock monitor is disabled for RTC clock.
	MCG_C8_CME1_0 = 0x0
	// External clock monitor is enabled for RTC clock.
	MCG_C8_CME1_1 = 0x1
	// Position of LOLRE field.
	MCG_C8_LOLRE_Pos = 0x6
	// Bit mask of LOLRE field.
	MCG_C8_LOLRE_Msk = 0x40
	// Bit LOLRE.
	MCG_C8_LOLRE = 0x40
	// Interrupt request is generated on a PLL loss of lock indication. The PLL loss of lock interrupt enable bit must also be set to generate the interrupt request.
	MCG_C8_LOLRE_0 = 0x0
	// Generate a reset request on a PLL loss of lock indication.
	MCG_C8_LOLRE_1 = 0x1
	// Position of LOCRE1 field.
	MCG_C8_LOCRE1_Pos = 0x7
	// Bit mask of LOCRE1 field.
	MCG_C8_LOCRE1_Msk = 0x80
	// Bit LOCRE1.
	MCG_C8_LOCRE1 = 0x80
	// Interrupt request is generated on a loss of RTC external reference clock.
	MCG_C8_LOCRE1_0 = 0x0
	// Generate a reset request on a loss of RTC external reference clock
	MCG_C8_LOCRE1_1 = 0x1

	// C9: MCG Control 9 Register
	// Position of EXT_PLL_LOCS field.
	MCG_C9_EXT_PLL_LOCS_Pos = 0x0
	// Bit mask of EXT_PLL_LOCS field.
	MCG_C9_EXT_PLL_LOCS_Msk = 0x1
	// Bit EXT_PLL_LOCS.
	MCG_C9_EXT_PLL_LOCS = 0x1
	// Loss of MCG EXT_PLL has not occurred.
	MCG_C9_EXT_PLL_LOCS_0 = 0x0
	// Loss of MCG EXT_PLL has occurred.
	MCG_C9_EXT_PLL_LOCS_1 = 0x1
	// Position of PLL_LOCRE field.
	MCG_C9_PLL_LOCRE_Pos = 0x4
	// Bit mask of PLL_LOCRE field.
	MCG_C9_PLL_LOCRE_Msk = 0x10
	// Bit PLL_LOCRE.
	MCG_C9_PLL_LOCRE = 0x10
	// Interrupt request is generated on a invalid or loss of the MCG external PLL clock.
	MCG_C9_PLL_LOCRE_0 = 0x0
	// Generates a system reset request on a invalid or loss of the MCG external PLL clock.
	MCG_C9_PLL_LOCRE_1 = 0x1
	// Position of PLL_CME field.
	MCG_C9_PLL_CME_Pos = 0x5
	// Bit mask of PLL_CME field.
	MCG_C9_PLL_CME_Msk = 0x20
	// Bit PLL_CME.
	MCG_C9_PLL_CME = 0x20
	// External clock monitor is disabled for EXT_PLL clock.
	MCG_C9_PLL_CME_0 = 0x0
	// External clock monitor is enabled for EXT_PLL clock.
	MCG_C9_PLL_CME_1 = 0x1

	// C11: MCG Control 11 Register
	// Position of PLLCS field.
	MCG_C11_PLLCS_Pos = 0x4
	// Bit mask of PLLCS field.
	MCG_C11_PLLCS_Msk = 0x10
	// Bit PLLCS.
	MCG_C11_PLLCS = 0x10
	// PLL0 output clock is selected.
	MCG_C11_PLLCS_0 = 0x0
	// External PLL clock is selected.
	MCG_C11_PLLCS_1 = 0x1

	// S2: MCG Status 2 Register
	// Position of PLLCST field.
	MCG_S2_PLLCST_Pos = 0x4
	// Bit mask of PLLCST field.
	MCG_S2_PLLCST_Msk = 0x10
	// Bit PLLCST.
	MCG_S2_PLLCST = 0x10
	// Source of PLLCS is PLL clock.
	MCG_S2_PLLCST_0 = 0x0
	// Source of PLLCS is EXT_PLL clock.
	MCG_S2_PLLCST_1 = 0x1
)

// Constants for OSC: Oscillator
const (
	// CR: OSC Control Register
	// Position of SC16P field.
	OSC_CR_SC16P_Pos = 0x0
	// Bit mask of SC16P field.
	OSC_CR_SC16P_Msk = 0x1
	// Bit SC16P.
	OSC_CR_SC16P = 0x1
	// Disable the selection.
	OSC_CR_SC16P_0 = 0x0
	// Add 16 pF capacitor to the oscillator load.
	OSC_CR_SC16P_1 = 0x1
	// Position of SC8P field.
	OSC_CR_SC8P_Pos = 0x1
	// Bit mask of SC8P field.
	OSC_CR_SC8P_Msk = 0x2
	// Bit SC8P.
	OSC_CR_SC8P = 0x2
	// Disable the selection.
	OSC_CR_SC8P_0 = 0x0
	// Add 8 pF capacitor to the oscillator load.
	OSC_CR_SC8P_1 = 0x1
	// Position of SC4P field.
	OSC_CR_SC4P_Pos = 0x2
	// Bit mask of SC4P field.
	OSC_CR_SC4P_Msk = 0x4
	// Bit SC4P.
	OSC_CR_SC4P = 0x4
	// Disable the selection.
	OSC_CR_SC4P_0 = 0x0
	// Add 4 pF capacitor to the oscillator load.
	OSC_CR_SC4P_1 = 0x1
	// Position of SC2P field.
	OSC_CR_SC2P_Pos = 0x3
	// Bit mask of SC2P field.
	OSC_CR_SC2P_Msk = 0x8
	// Bit SC2P.
	OSC_CR_SC2P = 0x8
	// Disable the selection.
	OSC_CR_SC2P_0 = 0x0
	// Add 2 pF capacitor to the oscillator load.
	OSC_CR_SC2P_1 = 0x1
	// Position of EREFSTEN field.
	OSC_CR_EREFSTEN_Pos = 0x5
	// Bit mask of EREFSTEN field.
	OSC_CR_EREFSTEN_Msk = 0x20
	// Bit EREFSTEN.
	OSC_CR_EREFSTEN = 0x20
	// External reference clock is disabled in Stop mode.
	OSC_CR_EREFSTEN_0 = 0x0
	// External reference clock stays enabled in Stop mode if ERCLKEN is set before entering Stop mode.
	OSC_CR_EREFSTEN_1 = 0x1
	// Position of ERCLKEN field.
	OSC_CR_ERCLKEN_Pos = 0x7
	// Bit mask of ERCLKEN field.
	OSC_CR_ERCLKEN_Msk = 0x80
	// Bit ERCLKEN.
	OSC_CR_ERCLKEN = 0x80
	// External reference clock is inactive.
	OSC_CR_ERCLKEN_0 = 0x0
	// External reference clock is enabled.
	OSC_CR_ERCLKEN_1 = 0x1

	// DIV: OSC_DIV
	// Position of ERPS field.
	OSC_DIV_ERPS_Pos = 0x6
	// Bit mask of ERPS field.
	OSC_DIV_ERPS_Msk = 0xc0
	// The divisor ratio is 1.
	OSC_DIV_ERPS_00 = 0x0
	// The divisor ratio is 2.
	OSC_DIV_ERPS_01 = 0x1
	// The divisor ratio is 4.
	OSC_DIV_ERPS_10 = 0x2
	// The divisor ratio is 8.
	OSC_DIV_ERPS_11 = 0x3
)

// Constants for I2C0: Inter-Integrated Circuit
const (
	// A1: I2C Address Register 1
	// Position of AD field.
	I2C_A1_AD_Pos = 0x1
	// Bit mask of AD field.
	I2C_A1_AD_Msk = 0xfe

	// F: I2C Frequency Divider register
	// Position of ICR field.
	I2C_F_ICR_Pos = 0x0
	// Bit mask of ICR field.
	I2C_F_ICR_Msk = 0x3f
	// Position of MULT field.
	I2C_F_MULT_Pos = 0x6
	// Bit mask of MULT field.
	I2C_F_MULT_Msk = 0xc0
	// mul = 1
	I2C_F_MULT_00 = 0x0
	// mul = 2
	I2C_F_MULT_01 = 0x1
	// mul = 4
	I2C_F_MULT_10 = 0x2

	// C1: I2C Control Register 1
	// Position of DMAEN field.
	I2C_C1_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	I2C_C1_DMAEN_Msk = 0x1
	// Bit DMAEN.
	I2C_C1_DMAEN = 0x1
	// All DMA signalling disabled.
	I2C_C1_DMAEN_0 = 0x0
	// DMA transfer is enabled. While SMB[FACK] = 0, the following conditions trigger the DMA request: a data byte is received, and either address or data is transmitted. (ACK/NACK is automatic) the first byte received matches the A1 register or is a general call address. If any address matching occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known from master to slave, then it is not required to check S[SRW]. With this assumption, DMA can also be used in this case. In other cases, if the master reads data from the slave, then it is required to rewrite the C1 register operation. With this assumption, DMA cannot be used. When FACK = 1, an address or a data byte is transmitted.
	I2C_C1_DMAEN_1 = 0x1
	// Position of WUEN field.
	I2C_C1_WUEN_Pos = 0x1
	// Bit mask of WUEN field.
	I2C_C1_WUEN_Msk = 0x2
	// Bit WUEN.
	I2C_C1_WUEN = 0x2
	// Normal operation. No interrupt generated when address matching in low power mode.
	I2C_C1_WUEN_0 = 0x0
	// Enables the wakeup function in low power mode.
	I2C_C1_WUEN_1 = 0x1
	// Position of RSTA field.
	I2C_C1_RSTA_Pos = 0x2
	// Bit mask of RSTA field.
	I2C_C1_RSTA_Msk = 0x4
	// Bit RSTA.
	I2C_C1_RSTA = 0x4
	// Position of TXAK field.
	I2C_C1_TXAK_Pos = 0x3
	// Bit mask of TXAK field.
	I2C_C1_TXAK_Msk = 0x8
	// Bit TXAK.
	I2C_C1_TXAK = 0x8
	// An acknowledge signal is sent to the bus on the following receiving byte (if FACK is cleared) or the current receiving byte (if FACK is set).
	I2C_C1_TXAK_0 = 0x0
	// No acknowledge signal is sent to the bus on the following receiving data byte (if FACK is cleared) or the current receiving data byte (if FACK is set).
	I2C_C1_TXAK_1 = 0x1
	// Position of TX field.
	I2C_C1_TX_Pos = 0x4
	// Bit mask of TX field.
	I2C_C1_TX_Msk = 0x10
	// Bit TX.
	I2C_C1_TX = 0x10
	// Receive
	I2C_C1_TX_0 = 0x0
	// Transmit
	I2C_C1_TX_1 = 0x1
	// Position of MST field.
	I2C_C1_MST_Pos = 0x5
	// Bit mask of MST field.
	I2C_C1_MST_Msk = 0x20
	// Bit MST.
	I2C_C1_MST = 0x20
	// Slave mode
	I2C_C1_MST_0 = 0x0
	// Master mode
	I2C_C1_MST_1 = 0x1
	// Position of IICIE field.
	I2C_C1_IICIE_Pos = 0x6
	// Bit mask of IICIE field.
	I2C_C1_IICIE_Msk = 0x40
	// Bit IICIE.
	I2C_C1_IICIE = 0x40
	// Disabled
	I2C_C1_IICIE_0 = 0x0
	// Enabled
	I2C_C1_IICIE_1 = 0x1
	// Position of IICEN field.
	I2C_C1_IICEN_Pos = 0x7
	// Bit mask of IICEN field.
	I2C_C1_IICEN_Msk = 0x80
	// Bit IICEN.
	I2C_C1_IICEN = 0x80
	// Disabled
	I2C_C1_IICEN_0 = 0x0
	// Enabled
	I2C_C1_IICEN_1 = 0x1

	// S: I2C Status register
	// Position of RXAK field.
	I2C_S_RXAK_Pos = 0x0
	// Bit mask of RXAK field.
	I2C_S_RXAK_Msk = 0x1
	// Bit RXAK.
	I2C_S_RXAK = 0x1
	// Acknowledge signal was received after the completion of one byte of data transmission on the bus
	I2C_S_RXAK_0 = 0x0
	// No acknowledge signal detected
	I2C_S_RXAK_1 = 0x1
	// Position of IICIF field.
	I2C_S_IICIF_Pos = 0x1
	// Bit mask of IICIF field.
	I2C_S_IICIF_Msk = 0x2
	// Bit IICIF.
	I2C_S_IICIF = 0x2
	// No interrupt pending
	I2C_S_IICIF_0 = 0x0
	// Interrupt pending
	I2C_S_IICIF_1 = 0x1
	// Position of SRW field.
	I2C_S_SRW_Pos = 0x2
	// Bit mask of SRW field.
	I2C_S_SRW_Msk = 0x4
	// Bit SRW.
	I2C_S_SRW = 0x4
	// Slave receive, master writing to slave
	I2C_S_SRW_0 = 0x0
	// Slave transmit, master reading from slave
	I2C_S_SRW_1 = 0x1
	// Position of RAM field.
	I2C_S_RAM_Pos = 0x3
	// Bit mask of RAM field.
	I2C_S_RAM_Msk = 0x8
	// Bit RAM.
	I2C_S_RAM = 0x8
	// Not addressed
	I2C_S_RAM_0 = 0x0
	// Addressed as a slave
	I2C_S_RAM_1 = 0x1
	// Position of ARBL field.
	I2C_S_ARBL_Pos = 0x4
	// Bit mask of ARBL field.
	I2C_S_ARBL_Msk = 0x10
	// Bit ARBL.
	I2C_S_ARBL = 0x10
	// Standard bus operation.
	I2C_S_ARBL_0 = 0x0
	// Loss of arbitration.
	I2C_S_ARBL_1 = 0x1
	// Position of BUSY field.
	I2C_S_BUSY_Pos = 0x5
	// Bit mask of BUSY field.
	I2C_S_BUSY_Msk = 0x20
	// Bit BUSY.
	I2C_S_BUSY = 0x20
	// Bus is idle
	I2C_S_BUSY_0 = 0x0
	// Bus is busy
	I2C_S_BUSY_1 = 0x1
	// Position of IAAS field.
	I2C_S_IAAS_Pos = 0x6
	// Bit mask of IAAS field.
	I2C_S_IAAS_Msk = 0x40
	// Bit IAAS.
	I2C_S_IAAS = 0x40
	// Not addressed
	I2C_S_IAAS_0 = 0x0
	// Addressed as a slave
	I2C_S_IAAS_1 = 0x1
	// Position of TCF field.
	I2C_S_TCF_Pos = 0x7
	// Bit mask of TCF field.
	I2C_S_TCF_Msk = 0x80
	// Bit TCF.
	I2C_S_TCF = 0x80
	// Transfer in progress
	I2C_S_TCF_0 = 0x0
	// Transfer complete
	I2C_S_TCF_1 = 0x1

	// D: I2C Data I/O register
	// Position of DATA field.
	I2C_D_DATA_Pos = 0x0
	// Bit mask of DATA field.
	I2C_D_DATA_Msk = 0xff

	// C2: I2C Control Register 2
	// Position of AD field.
	I2C_C2_AD_Pos = 0x0
	// Bit mask of AD field.
	I2C_C2_AD_Msk = 0x7
	// Position of RMEN field.
	I2C_C2_RMEN_Pos = 0x3
	// Bit mask of RMEN field.
	I2C_C2_RMEN_Msk = 0x8
	// Bit RMEN.
	I2C_C2_RMEN = 0x8
	// Range mode disabled. No address matching occurs for an address within the range of values of the A1 and RA registers.
	I2C_C2_RMEN_0 = 0x0
	// Range mode enabled. Address matching occurs when a slave receives an address within the range of values of the A1 and RA registers.
	I2C_C2_RMEN_1 = 0x1
	// Position of SBRC field.
	I2C_C2_SBRC_Pos = 0x4
	// Bit mask of SBRC field.
	I2C_C2_SBRC_Msk = 0x10
	// Bit SBRC.
	I2C_C2_SBRC = 0x10
	// The slave baud rate follows the master baud rate and clock stretching may occur
	I2C_C2_SBRC_0 = 0x0
	// Slave baud rate is independent of the master baud rate
	I2C_C2_SBRC_1 = 0x1
	// Position of HDRS field.
	I2C_C2_HDRS_Pos = 0x5
	// Bit mask of HDRS field.
	I2C_C2_HDRS_Msk = 0x20
	// Bit HDRS.
	I2C_C2_HDRS = 0x20
	// Normal drive mode
	I2C_C2_HDRS_0 = 0x0
	// High drive mode
	I2C_C2_HDRS_1 = 0x1
	// Position of ADEXT field.
	I2C_C2_ADEXT_Pos = 0x6
	// Bit mask of ADEXT field.
	I2C_C2_ADEXT_Msk = 0x40
	// Bit ADEXT.
	I2C_C2_ADEXT = 0x40
	// 7-bit address scheme
	I2C_C2_ADEXT_0 = 0x0
	// 10-bit address scheme
	I2C_C2_ADEXT_1 = 0x1
	// Position of GCAEN field.
	I2C_C2_GCAEN_Pos = 0x7
	// Bit mask of GCAEN field.
	I2C_C2_GCAEN_Msk = 0x80
	// Bit GCAEN.
	I2C_C2_GCAEN = 0x80
	// Disabled
	I2C_C2_GCAEN_0 = 0x0
	// Enabled
	I2C_C2_GCAEN_1 = 0x1

	// FLT: I2C Programmable Input Glitch Filter Register
	// Position of FLT field.
	I2C_FLT_FLT_Pos = 0x0
	// Bit mask of FLT field.
	I2C_FLT_FLT_Msk = 0xf
	// No filter/bypass
	I2C_FLT_FLT_0 = 0x0
	// Position of STARTF field.
	I2C_FLT_STARTF_Pos = 0x4
	// Bit mask of STARTF field.
	I2C_FLT_STARTF_Msk = 0x10
	// Bit STARTF.
	I2C_FLT_STARTF = 0x10
	// No start happens on I2C bus
	I2C_FLT_STARTF_0 = 0x0
	// Start detected on I2C bus
	I2C_FLT_STARTF_1 = 0x1
	// Position of SSIE field.
	I2C_FLT_SSIE_Pos = 0x5
	// Bit mask of SSIE field.
	I2C_FLT_SSIE_Msk = 0x20
	// Bit SSIE.
	I2C_FLT_SSIE = 0x20
	// Stop or start detection interrupt is disabled
	I2C_FLT_SSIE_0 = 0x0
	// Stop or start detection interrupt is enabled
	I2C_FLT_SSIE_1 = 0x1
	// Position of STOPF field.
	I2C_FLT_STOPF_Pos = 0x6
	// Bit mask of STOPF field.
	I2C_FLT_STOPF_Msk = 0x40
	// Bit STOPF.
	I2C_FLT_STOPF = 0x40
	// No stop happens on I2C bus
	I2C_FLT_STOPF_0 = 0x0
	// Stop detected on I2C bus
	I2C_FLT_STOPF_1 = 0x1
	// Position of SHEN field.
	I2C_FLT_SHEN_Pos = 0x7
	// Bit mask of SHEN field.
	I2C_FLT_SHEN_Msk = 0x80
	// Bit SHEN.
	I2C_FLT_SHEN = 0x80
	// Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
	I2C_FLT_SHEN_0 = 0x0
	// Stop holdoff is enabled.
	I2C_FLT_SHEN_1 = 0x1

	// RA: I2C Range Address register
	// Position of RAD field.
	I2C_RA_RAD_Pos = 0x1
	// Bit mask of RAD field.
	I2C_RA_RAD_Msk = 0xfe

	// SMB: I2C SMBus Control and Status register
	// Position of SHTF2IE field.
	I2C_SMB_SHTF2IE_Pos = 0x0
	// Bit mask of SHTF2IE field.
	I2C_SMB_SHTF2IE_Msk = 0x1
	// Bit SHTF2IE.
	I2C_SMB_SHTF2IE = 0x1
	// SHTF2 interrupt is disabled
	I2C_SMB_SHTF2IE_0 = 0x0
	// SHTF2 interrupt is enabled
	I2C_SMB_SHTF2IE_1 = 0x1
	// Position of SHTF2 field.
	I2C_SMB_SHTF2_Pos = 0x1
	// Bit mask of SHTF2 field.
	I2C_SMB_SHTF2_Msk = 0x2
	// Bit SHTF2.
	I2C_SMB_SHTF2 = 0x2
	// No SCL high and SDA low timeout occurs
	I2C_SMB_SHTF2_0 = 0x0
	// SCL high and SDA low timeout occurs
	I2C_SMB_SHTF2_1 = 0x1
	// Position of SHTF1 field.
	I2C_SMB_SHTF1_Pos = 0x2
	// Bit mask of SHTF1 field.
	I2C_SMB_SHTF1_Msk = 0x4
	// Bit SHTF1.
	I2C_SMB_SHTF1 = 0x4
	// No SCL high and SDA high timeout occurs
	I2C_SMB_SHTF1_0 = 0x0
	// SCL high and SDA high timeout occurs
	I2C_SMB_SHTF1_1 = 0x1
	// Position of SLTF field.
	I2C_SMB_SLTF_Pos = 0x3
	// Bit mask of SLTF field.
	I2C_SMB_SLTF_Msk = 0x8
	// Bit SLTF.
	I2C_SMB_SLTF = 0x8
	// No low timeout occurs
	I2C_SMB_SLTF_0 = 0x0
	// Low timeout occurs
	I2C_SMB_SLTF_1 = 0x1
	// Position of TCKSEL field.
	I2C_SMB_TCKSEL_Pos = 0x4
	// Bit mask of TCKSEL field.
	I2C_SMB_TCKSEL_Msk = 0x10
	// Bit TCKSEL.
	I2C_SMB_TCKSEL = 0x10
	// Timeout counter counts at the frequency of the I2C module clock / 64
	I2C_SMB_TCKSEL_0 = 0x0
	// Timeout counter counts at the frequency of the I2C module clock
	I2C_SMB_TCKSEL_1 = 0x1
	// Position of SIICAEN field.
	I2C_SMB_SIICAEN_Pos = 0x5
	// Bit mask of SIICAEN field.
	I2C_SMB_SIICAEN_Msk = 0x20
	// Bit SIICAEN.
	I2C_SMB_SIICAEN = 0x20
	// I2C address register 2 matching is disabled
	I2C_SMB_SIICAEN_0 = 0x0
	// I2C address register 2 matching is enabled
	I2C_SMB_SIICAEN_1 = 0x1
	// Position of ALERTEN field.
	I2C_SMB_ALERTEN_Pos = 0x6
	// Bit mask of ALERTEN field.
	I2C_SMB_ALERTEN_Msk = 0x40
	// Bit ALERTEN.
	I2C_SMB_ALERTEN = 0x40
	// SMBus alert response address matching is disabled
	I2C_SMB_ALERTEN_0 = 0x0
	// SMBus alert response address matching is enabled
	I2C_SMB_ALERTEN_1 = 0x1
	// Position of FACK field.
	I2C_SMB_FACK_Pos = 0x7
	// Bit mask of FACK field.
	I2C_SMB_FACK_Msk = 0x80
	// Bit FACK.
	I2C_SMB_FACK = 0x80
	// An ACK or NACK is sent on the following receiving data byte
	I2C_SMB_FACK_0 = 0x0
	// Writing 0 to TXAK after receiving a data byte generates an ACK. Writing 1 to TXAK after receiving a data byte generates a NACK.
	I2C_SMB_FACK_1 = 0x1

	// A2: I2C Address Register 2
	// Position of SAD field.
	I2C_A2_SAD_Pos = 0x1
	// Bit mask of SAD field.
	I2C_A2_SAD_Msk = 0xfe

	// SLTH: I2C SCL Low Timeout Register High
	// Position of SSLT field.
	I2C_SLTH_SSLT_Pos = 0x0
	// Bit mask of SSLT field.
	I2C_SLTH_SSLT_Msk = 0xff

	// SLTL: I2C SCL Low Timeout Register Low
	// Position of SSLT field.
	I2C_SLTL_SSLT_Pos = 0x0
	// Bit mask of SSLT field.
	I2C_SLTL_SSLT_Msk = 0xff
)

// Constants for UART0: Serial Communication Interface
const (
	// BDH: UART Baud Rate Registers: High
	// Position of SBR field.
	UART_BDH_SBR_Pos = 0x0
	// Bit mask of SBR field.
	UART_BDH_SBR_Msk = 0x1f
	// Position of SBNS field.
	UART_BDH_SBNS_Pos = 0x5
	// Bit mask of SBNS field.
	UART_BDH_SBNS_Msk = 0x20
	// Bit SBNS.
	UART_BDH_SBNS = 0x20
	// Data frame consists of a single stop bit.
	UART_BDH_SBNS_0 = 0x0
	// Data frame consists of two stop bits.
	UART_BDH_SBNS_1 = 0x1
	// Position of RXEDGIE field.
	UART_BDH_RXEDGIE_Pos = 0x6
	// Bit mask of RXEDGIE field.
	UART_BDH_RXEDGIE_Msk = 0x40
	// Bit RXEDGIE.
	UART_BDH_RXEDGIE = 0x40
	// Hardware interrupts from RXEDGIF disabled using polling.
	UART_BDH_RXEDGIE_0 = 0x0
	// RXEDGIF interrupt request enabled.
	UART_BDH_RXEDGIE_1 = 0x1
	// Position of LBKDIE field.
	UART_BDH_LBKDIE_Pos = 0x7
	// Bit mask of LBKDIE field.
	UART_BDH_LBKDIE_Msk = 0x80
	// Bit LBKDIE.
	UART_BDH_LBKDIE = 0x80
	// LBKDIF interrupt requests disabled.
	UART_BDH_LBKDIE_0 = 0x0
	// LBKDIF interrupt requests enabled.
	UART_BDH_LBKDIE_1 = 0x1

	// BDL: UART Baud Rate Registers: Low
	// Position of SBR field.
	UART_BDL_SBR_Pos = 0x0
	// Bit mask of SBR field.
	UART_BDL_SBR_Msk = 0xff

	// C1: UART Control Register 1
	// Position of PT field.
	UART_C1_PT_Pos = 0x0
	// Bit mask of PT field.
	UART_C1_PT_Msk = 0x1
	// Bit PT.
	UART_C1_PT = 0x1
	// Even parity.
	UART_C1_PT_0 = 0x0
	// Odd parity.
	UART_C1_PT_1 = 0x1
	// Position of PE field.
	UART_C1_PE_Pos = 0x1
	// Bit mask of PE field.
	UART_C1_PE_Msk = 0x2
	// Bit PE.
	UART_C1_PE = 0x2
	// Parity function disabled.
	UART_C1_PE_0 = 0x0
	// Parity function enabled.
	UART_C1_PE_1 = 0x1
	// Position of ILT field.
	UART_C1_ILT_Pos = 0x2
	// Bit mask of ILT field.
	UART_C1_ILT_Msk = 0x4
	// Bit ILT.
	UART_C1_ILT = 0x4
	// Idle character bit count starts after start bit.
	UART_C1_ILT_0 = 0x0
	// Idle character bit count starts after stop bit.
	UART_C1_ILT_1 = 0x1
	// Position of WAKE field.
	UART_C1_WAKE_Pos = 0x3
	// Bit mask of WAKE field.
	UART_C1_WAKE_Msk = 0x8
	// Bit WAKE.
	UART_C1_WAKE = 0x8
	// Idle line wakeup.
	UART_C1_WAKE_0 = 0x0
	// Address mark wakeup.
	UART_C1_WAKE_1 = 0x1
	// Position of M field.
	UART_C1_M_Pos = 0x4
	// Bit mask of M field.
	UART_C1_M_Msk = 0x10
	// Bit M.
	UART_C1_M = 0x10
	// Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
	UART_C1_M_0 = 0x0
	// Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
	UART_C1_M_1 = 0x1
	// Position of RSRC field.
	UART_C1_RSRC_Pos = 0x5
	// Bit mask of RSRC field.
	UART_C1_RSRC_Msk = 0x20
	// Bit RSRC.
	UART_C1_RSRC = 0x20
	// Selects internal loop back mode. The receiver input is internally connected to transmitter output.
	UART_C1_RSRC_0 = 0x0
	// Single wire UART mode where the receiver input is connected to the transmit pin input signal.
	UART_C1_RSRC_1 = 0x1
	// Position of UARTSWAI field.
	UART_C1_UARTSWAI_Pos = 0x6
	// Bit mask of UARTSWAI field.
	UART_C1_UARTSWAI_Msk = 0x40
	// Bit UARTSWAI.
	UART_C1_UARTSWAI = 0x40
	// UART clock continues to run in Wait mode.
	UART_C1_UARTSWAI_0 = 0x0
	// UART clock freezes while CPU is in Wait mode.
	UART_C1_UARTSWAI_1 = 0x1
	// Position of LOOPS field.
	UART_C1_LOOPS_Pos = 0x7
	// Bit mask of LOOPS field.
	UART_C1_LOOPS_Msk = 0x80
	// Bit LOOPS.
	UART_C1_LOOPS = 0x80
	// Normal operation.
	UART_C1_LOOPS_0 = 0x0
	// Loop mode where transmitter output is internally connected to receiver input. The receiver input is determined by RSRC.
	UART_C1_LOOPS_1 = 0x1

	// C2: UART Control Register 2
	// Position of SBK field.
	UART_C2_SBK_Pos = 0x0
	// Bit mask of SBK field.
	UART_C2_SBK_Msk = 0x1
	// Bit SBK.
	UART_C2_SBK = 0x1
	// Normal transmitter operation.
	UART_C2_SBK_0 = 0x0
	// Queue break characters to be sent.
	UART_C2_SBK_1 = 0x1
	// Position of RWU field.
	UART_C2_RWU_Pos = 0x1
	// Bit mask of RWU field.
	UART_C2_RWU_Msk = 0x2
	// Bit RWU.
	UART_C2_RWU = 0x2
	// Normal operation.
	UART_C2_RWU_0 = 0x0
	// RWU enables the wakeup function and inhibits further receiver interrupt requests. Normally, hardware wakes the receiver by automatically clearing RWU.
	UART_C2_RWU_1 = 0x1
	// Position of RE field.
	UART_C2_RE_Pos = 0x2
	// Bit mask of RE field.
	UART_C2_RE_Msk = 0x4
	// Bit RE.
	UART_C2_RE = 0x4
	// Receiver off.
	UART_C2_RE_0 = 0x0
	// Receiver on.
	UART_C2_RE_1 = 0x1
	// Position of TE field.
	UART_C2_TE_Pos = 0x3
	// Bit mask of TE field.
	UART_C2_TE_Msk = 0x8
	// Bit TE.
	UART_C2_TE = 0x8
	// Transmitter off.
	UART_C2_TE_0 = 0x0
	// Transmitter on.
	UART_C2_TE_1 = 0x1
	// Position of ILIE field.
	UART_C2_ILIE_Pos = 0x4
	// Bit mask of ILIE field.
	UART_C2_ILIE_Msk = 0x10
	// Bit ILIE.
	UART_C2_ILIE = 0x10
	// IDLE interrupt requests disabled.
	UART_C2_ILIE_0 = 0x0
	// IDLE interrupt requests enabled.
	UART_C2_ILIE_1 = 0x1
	// Position of RIE field.
	UART_C2_RIE_Pos = 0x5
	// Bit mask of RIE field.
	UART_C2_RIE_Msk = 0x20
	// Bit RIE.
	UART_C2_RIE = 0x20
	// RDRF interrupt and DMA transfer requests disabled.
	UART_C2_RIE_0 = 0x0
	// RDRF interrupt or DMA transfer requests enabled.
	UART_C2_RIE_1 = 0x1
	// Position of TCIE field.
	UART_C2_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	UART_C2_TCIE_Msk = 0x40
	// Bit TCIE.
	UART_C2_TCIE = 0x40
	// TC interrupt requests disabled.
	UART_C2_TCIE_0 = 0x0
	// TC interrupt requests enabled.
	UART_C2_TCIE_1 = 0x1
	// Position of TIE field.
	UART_C2_TIE_Pos = 0x7
	// Bit mask of TIE field.
	UART_C2_TIE_Msk = 0x80
	// Bit TIE.
	UART_C2_TIE = 0x80
	// TDRE interrupt and DMA transfer requests disabled.
	UART_C2_TIE_0 = 0x0
	// TDRE interrupt or DMA transfer requests enabled.
	UART_C2_TIE_1 = 0x1

	// S1: UART Status Register 1
	// Position of PF field.
	UART_S1_PF_Pos = 0x0
	// Bit mask of PF field.
	UART_S1_PF_Msk = 0x1
	// Bit PF.
	UART_S1_PF = 0x1
	// No parity error detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1, then there may be data in the receive buffer what was received with a parity error.
	UART_S1_PF_0 = 0x0
	// At least one dataword was received with a parity error since the last time this flag was cleared.
	UART_S1_PF_1 = 0x1
	// Position of FE field.
	UART_S1_FE_Pos = 0x1
	// Bit mask of FE field.
	UART_S1_FE_Msk = 0x2
	// Bit FE.
	UART_S1_FE = 0x2
	// No framing error detected.
	UART_S1_FE_0 = 0x0
	// Framing error.
	UART_S1_FE_1 = 0x1
	// Position of NF field.
	UART_S1_NF_Pos = 0x2
	// Bit mask of NF field.
	UART_S1_NF_Msk = 0x4
	// Bit NF.
	UART_S1_NF = 0x4
	// No noise detected since the last time this flag was cleared. If the receive buffer has a depth greater than 1 then there may be data in the receiver buffer that was received with noise.
	UART_S1_NF_0 = 0x0
	// At least one dataword was received with noise detected since the last time the flag was cleared.
	UART_S1_NF_1 = 0x1
	// Position of OR field.
	UART_S1_OR_Pos = 0x3
	// Bit mask of OR field.
	UART_S1_OR_Msk = 0x8
	// Bit OR.
	UART_S1_OR = 0x8
	// No overrun has occurred since the last time the flag was cleared.
	UART_S1_OR_0 = 0x0
	// Overrun has occurred or the overrun flag has not been cleared since the last overrun occurred.
	UART_S1_OR_1 = 0x1
	// Position of IDLE field.
	UART_S1_IDLE_Pos = 0x4
	// Bit mask of IDLE field.
	UART_S1_IDLE_Msk = 0x10
	// Bit IDLE.
	UART_S1_IDLE = 0x10
	// Receiver input is either active now or has never become active since the IDLE flag was last cleared.
	UART_S1_IDLE_0 = 0x0
	// Receiver input has become idle or the flag has not been cleared since it last asserted.
	UART_S1_IDLE_1 = 0x1
	// Position of RDRF field.
	UART_S1_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	UART_S1_RDRF_Msk = 0x20
	// Bit RDRF.
	UART_S1_RDRF = 0x20
	// The number of datawords in the receive buffer is less than the number indicated by RXWATER.
	UART_S1_RDRF_0 = 0x0
	// The number of datawords in the receive buffer is equal to or greater than the number indicated by RXWATER at some point in time since this flag was last cleared.
	UART_S1_RDRF_1 = 0x1
	// Position of TC field.
	UART_S1_TC_Pos = 0x6
	// Bit mask of TC field.
	UART_S1_TC_Msk = 0x40
	// Bit TC.
	UART_S1_TC = 0x40
	// Transmitter active (sending data, a preamble, or a break).
	UART_S1_TC_0 = 0x0
	// Transmitter idle (transmission activity complete).
	UART_S1_TC_1 = 0x1
	// Position of TDRE field.
	UART_S1_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	UART_S1_TDRE_Msk = 0x80
	// Bit TDRE.
	UART_S1_TDRE = 0x80
	// The amount of data in the transmit buffer is greater than the value indicated by TWFIFO[TXWATER].
	UART_S1_TDRE_0 = 0x0
	// The amount of data in the transmit buffer is less than or equal to the value indicated by TWFIFO[TXWATER] at some point in time since the flag has been cleared.
	UART_S1_TDRE_1 = 0x1

	// S2: UART Status Register 2
	// Position of RAF field.
	UART_S2_RAF_Pos = 0x0
	// Bit mask of RAF field.
	UART_S2_RAF_Msk = 0x1
	// Bit RAF.
	UART_S2_RAF = 0x1
	// UART receiver idle/inactive waiting for a start bit.
	UART_S2_RAF_0 = 0x0
	// UART receiver active, RxD input not idle.
	UART_S2_RAF_1 = 0x1
	// Position of LBKDE field.
	UART_S2_LBKDE_Pos = 0x1
	// Bit mask of LBKDE field.
	UART_S2_LBKDE_Msk = 0x2
	// Bit LBKDE.
	UART_S2_LBKDE = 0x2
	// Break character detection is disabled.
	UART_S2_LBKDE_0 = 0x0
	// Break character is detected at length of 11 bit times if C1[M] = 0 or 12 bits time if C1[M] = 1.
	UART_S2_LBKDE_1 = 0x1
	// Position of BRK13 field.
	UART_S2_BRK13_Pos = 0x2
	// Bit mask of BRK13 field.
	UART_S2_BRK13_Msk = 0x4
	// Bit BRK13.
	UART_S2_BRK13 = 0x4
	// Break character is 10, 11, or 12 bits long.
	UART_S2_BRK13_0 = 0x0
	// Break character is 13 or 14 bits long.
	UART_S2_BRK13_1 = 0x1
	// Position of RWUID field.
	UART_S2_RWUID_Pos = 0x3
	// Bit mask of RWUID field.
	UART_S2_RWUID_Msk = 0x8
	// Bit RWUID.
	UART_S2_RWUID = 0x8
	// S1[IDLE] is not set upon detection of an idle character.
	UART_S2_RWUID_0 = 0x0
	// S1[IDLE] is set upon detection of an idle character.
	UART_S2_RWUID_1 = 0x1
	// Position of RXINV field.
	UART_S2_RXINV_Pos = 0x4
	// Bit mask of RXINV field.
	UART_S2_RXINV_Msk = 0x10
	// Bit RXINV.
	UART_S2_RXINV = 0x10
	// Receive data is not inverted.
	UART_S2_RXINV_0 = 0x0
	// Receive data is inverted.
	UART_S2_RXINV_1 = 0x1
	// Position of MSBF field.
	UART_S2_MSBF_Pos = 0x5
	// Bit mask of MSBF field.
	UART_S2_MSBF_Msk = 0x20
	// Bit MSBF.
	UART_S2_MSBF = 0x20
	// LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
	UART_S2_MSBF_0 = 0x0
	// MSB (bit8, bit7 or bit6) is the first bit that is transmitted following the start bit, depending on the setting of C1[M] and C1[PE]. Further, the first bit received after the start bit is identified as bit8, bit7, or bit6, depending on the setting of C1[M] and C1[PE].
	UART_S2_MSBF_1 = 0x1
	// Position of RXEDGIF field.
	UART_S2_RXEDGIF_Pos = 0x6
	// Bit mask of RXEDGIF field.
	UART_S2_RXEDGIF_Msk = 0x40
	// Bit RXEDGIF.
	UART_S2_RXEDGIF = 0x40
	// No active edge on the receive pin has occurred.
	UART_S2_RXEDGIF_0 = 0x0
	// An active edge on the receive pin has occurred.
	UART_S2_RXEDGIF_1 = 0x1
	// Position of LBKDIF field.
	UART_S2_LBKDIF_Pos = 0x7
	// Bit mask of LBKDIF field.
	UART_S2_LBKDIF_Msk = 0x80
	// Bit LBKDIF.
	UART_S2_LBKDIF = 0x80
	// No LIN break character detected.
	UART_S2_LBKDIF_0 = 0x0
	// LIN break character detected.
	UART_S2_LBKDIF_1 = 0x1

	// C3: UART Control Register 3
	// Position of PEIE field.
	UART_C3_PEIE_Pos = 0x0
	// Bit mask of PEIE field.
	UART_C3_PEIE_Msk = 0x1
	// Bit PEIE.
	UART_C3_PEIE = 0x1
	// PF interrupt requests are disabled.
	UART_C3_PEIE_0 = 0x0
	// PF interrupt requests are enabled.
	UART_C3_PEIE_1 = 0x1
	// Position of FEIE field.
	UART_C3_FEIE_Pos = 0x1
	// Bit mask of FEIE field.
	UART_C3_FEIE_Msk = 0x2
	// Bit FEIE.
	UART_C3_FEIE = 0x2
	// FE interrupt requests are disabled.
	UART_C3_FEIE_0 = 0x0
	// FE interrupt requests are enabled.
	UART_C3_FEIE_1 = 0x1
	// Position of NEIE field.
	UART_C3_NEIE_Pos = 0x2
	// Bit mask of NEIE field.
	UART_C3_NEIE_Msk = 0x4
	// Bit NEIE.
	UART_C3_NEIE = 0x4
	// NF interrupt requests are disabled.
	UART_C3_NEIE_0 = 0x0
	// NF interrupt requests are enabled.
	UART_C3_NEIE_1 = 0x1
	// Position of ORIE field.
	UART_C3_ORIE_Pos = 0x3
	// Bit mask of ORIE field.
	UART_C3_ORIE_Msk = 0x8
	// Bit ORIE.
	UART_C3_ORIE = 0x8
	// OR interrupts are disabled.
	UART_C3_ORIE_0 = 0x0
	// OR interrupt requests are enabled.
	UART_C3_ORIE_1 = 0x1
	// Position of TXINV field.
	UART_C3_TXINV_Pos = 0x4
	// Bit mask of TXINV field.
	UART_C3_TXINV_Msk = 0x10
	// Bit TXINV.
	UART_C3_TXINV = 0x10
	// Transmit data is not inverted.
	UART_C3_TXINV_0 = 0x0
	// Transmit data is inverted.
	UART_C3_TXINV_1 = 0x1
	// Position of TXDIR field.
	UART_C3_TXDIR_Pos = 0x5
	// Bit mask of TXDIR field.
	UART_C3_TXDIR_Msk = 0x20
	// Bit TXDIR.
	UART_C3_TXDIR = 0x20
	// TXD pin is an input in single wire mode.
	UART_C3_TXDIR_0 = 0x0
	// TXD pin is an output in single wire mode.
	UART_C3_TXDIR_1 = 0x1
	// Position of T8 field.
	UART_C3_T8_Pos = 0x6
	// Bit mask of T8 field.
	UART_C3_T8_Msk = 0x40
	// Bit T8.
	UART_C3_T8 = 0x40
	// Position of R8 field.
	UART_C3_R8_Pos = 0x7
	// Bit mask of R8 field.
	UART_C3_R8_Msk = 0x80
	// Bit R8.
	UART_C3_R8 = 0x80

	// D: UART Data Register
	// Position of RT field.
	UART_D_RT_Pos = 0x0
	// Bit mask of RT field.
	UART_D_RT_Msk = 0xff

	// MA1: UART Match Address Registers 1
	// Position of MA field.
	UART_MA1_MA_Pos = 0x0
	// Bit mask of MA field.
	UART_MA1_MA_Msk = 0xff

	// MA2: UART Match Address Registers 2
	// Position of MA field.
	UART_MA2_MA_Pos = 0x0
	// Bit mask of MA field.
	UART_MA2_MA_Msk = 0xff

	// C4: UART Control Register 4
	// Position of BRFA field.
	UART_C4_BRFA_Pos = 0x0
	// Bit mask of BRFA field.
	UART_C4_BRFA_Msk = 0x1f
	// Position of M10 field.
	UART_C4_M10_Pos = 0x5
	// Bit mask of M10 field.
	UART_C4_M10_Msk = 0x20
	// Bit M10.
	UART_C4_M10 = 0x20
	// The parity bit is the ninth bit in the serial transmission.
	UART_C4_M10_0 = 0x0
	// The parity bit is the tenth bit in the serial transmission.
	UART_C4_M10_1 = 0x1
	// Position of MAEN2 field.
	UART_C4_MAEN2_Pos = 0x6
	// Bit mask of MAEN2 field.
	UART_C4_MAEN2_Msk = 0x40
	// Bit MAEN2.
	UART_C4_MAEN2 = 0x40
	// All data received is transferred to the data buffer if MAEN1 is cleared.
	UART_C4_MAEN2_0 = 0x0
	// All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA2 register. If no match occurs, the data is discarded. If a match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.
	UART_C4_MAEN2_1 = 0x1
	// Position of MAEN1 field.
	UART_C4_MAEN1_Pos = 0x7
	// Bit mask of MAEN1 field.
	UART_C4_MAEN1_Msk = 0x80
	// Bit MAEN1.
	UART_C4_MAEN1 = 0x80
	// All data received is transferred to the data buffer if MAEN2 is cleared.
	UART_C4_MAEN1_0 = 0x0
	// All data received with the most significant bit cleared, is discarded. All data received with the most significant bit set, is compared with contents of MA1 register. If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer. This field must be cleared when C7816[ISO7816E] is set/enabled.
	UART_C4_MAEN1_1 = 0x1

	// C5: UART Control Register 5
	// Position of RDMAS field.
	UART_C5_RDMAS_Pos = 0x5
	// Bit mask of RDMAS field.
	UART_C5_RDMAS_Msk = 0x20
	// Bit RDMAS.
	UART_C5_RDMAS = 0x20
	// If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is asserted to request an interrupt service.
	UART_C5_RDMAS_0 = 0x0
	// If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is asserted to request a DMA transfer.
	UART_C5_RDMAS_1 = 0x1
	// Position of TDMAS field.
	UART_C5_TDMAS_Pos = 0x7
	// Bit mask of TDMAS field.
	UART_C5_TDMAS_Msk = 0x80
	// Bit TDMAS.
	UART_C5_TDMAS = 0x80
	// If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt request signal is asserted to request interrupt service.
	UART_C5_TDMAS_0 = 0x0
	// If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request signal is asserted to request a DMA transfer.
	UART_C5_TDMAS_1 = 0x1

	// ED: UART Extended Data Register
	// Position of PARITYE field.
	UART_ED_PARITYE_Pos = 0x6
	// Bit mask of PARITYE field.
	UART_ED_PARITYE_Msk = 0x40
	// Bit PARITYE.
	UART_ED_PARITYE = 0x40
	// The dataword was received without a parity error.
	UART_ED_PARITYE_0 = 0x0
	// The dataword was received with a parity error.
	UART_ED_PARITYE_1 = 0x1
	// Position of NOISY field.
	UART_ED_NOISY_Pos = 0x7
	// Bit mask of NOISY field.
	UART_ED_NOISY_Msk = 0x80
	// Bit NOISY.
	UART_ED_NOISY = 0x80
	// The dataword was received without noise.
	UART_ED_NOISY_0 = 0x0
	// The data was received with noise.
	UART_ED_NOISY_1 = 0x1

	// MODEM: UART Modem Register
	// Position of TXCTSE field.
	UART_MODEM_TXCTSE_Pos = 0x0
	// Bit mask of TXCTSE field.
	UART_MODEM_TXCTSE_Msk = 0x1
	// Bit TXCTSE.
	UART_MODEM_TXCTSE = 0x1
	// CTS has no effect on the transmitter.
	UART_MODEM_TXCTSE_0 = 0x0
	// Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.
	UART_MODEM_TXCTSE_1 = 0x1
	// Position of TXRTSE field.
	UART_MODEM_TXRTSE_Pos = 0x1
	// Bit mask of TXRTSE field.
	UART_MODEM_TXRTSE_Msk = 0x2
	// Bit TXRTSE.
	UART_MODEM_TXRTSE = 0x2
	// The transmitter has no effect on RTS.
	UART_MODEM_TXRTSE_0 = 0x0
	// When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit. (FIFO) (FIFO)
	UART_MODEM_TXRTSE_1 = 0x1
	// Position of TXRTSPOL field.
	UART_MODEM_TXRTSPOL_Pos = 0x2
	// Bit mask of TXRTSPOL field.
	UART_MODEM_TXRTSPOL_Msk = 0x4
	// Bit TXRTSPOL.
	UART_MODEM_TXRTSPOL = 0x4
	// Transmitter RTS is active low.
	UART_MODEM_TXRTSPOL_0 = 0x0
	// Transmitter RTS is active high.
	UART_MODEM_TXRTSPOL_1 = 0x1
	// Position of RXRTSE field.
	UART_MODEM_RXRTSE_Pos = 0x3
	// Bit mask of RXRTSE field.
	UART_MODEM_RXRTSE_Msk = 0x8
	// Bit RXRTSE.
	UART_MODEM_RXRTSE = 0x8
	// The receiver has no effect on RTS.
	UART_MODEM_RXRTSE_0 = 0x0
	// RTS is deasserted if the number of characters in the receiver data register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted when the number of characters in the receiver data register (FIFO) is less than RWFIFO[RXWATER]. See Hardware flow control
	UART_MODEM_RXRTSE_1 = 0x1

	// IR: UART Infrared Register
	// Position of TNP field.
	UART_IR_TNP_Pos = 0x0
	// Bit mask of TNP field.
	UART_IR_TNP_Msk = 0x3
	// 3/16.
	UART_IR_TNP_00 = 0x0
	// 1/16.
	UART_IR_TNP_01 = 0x1
	// 1/32.
	UART_IR_TNP_10 = 0x2
	// 1/4.
	UART_IR_TNP_11 = 0x3
	// Position of IREN field.
	UART_IR_IREN_Pos = 0x2
	// Bit mask of IREN field.
	UART_IR_IREN_Msk = 0x4
	// Bit IREN.
	UART_IR_IREN = 0x4
	// IR disabled.
	UART_IR_IREN_0 = 0x0
	// IR enabled.
	UART_IR_IREN_1 = 0x1

	// PFIFO: UART FIFO Parameters
	// Position of RXFIFOSIZE field.
	UART_PFIFO_RXFIFOSIZE_Pos = 0x0
	// Bit mask of RXFIFOSIZE field.
	UART_PFIFO_RXFIFOSIZE_Msk = 0x7
	// Receive FIFO/Buffer depth = 1 dataword.
	UART_PFIFO_RXFIFOSIZE_000 = 0x0
	// Receive FIFO/Buffer depth = 4 datawords.
	UART_PFIFO_RXFIFOSIZE_001 = 0x1
	// Receive FIFO/Buffer depth = 8 datawords.
	UART_PFIFO_RXFIFOSIZE_010 = 0x2
	// Receive FIFO/Buffer depth = 16 datawords.
	UART_PFIFO_RXFIFOSIZE_011 = 0x3
	// Receive FIFO/Buffer depth = 32 datawords.
	UART_PFIFO_RXFIFOSIZE_100 = 0x4
	// Receive FIFO/Buffer depth = 64 datawords.
	UART_PFIFO_RXFIFOSIZE_101 = 0x5
	// Receive FIFO/Buffer depth = 128 datawords.
	UART_PFIFO_RXFIFOSIZE_110 = 0x6
	// Position of RXFE field.
	UART_PFIFO_RXFE_Pos = 0x3
	// Bit mask of RXFE field.
	UART_PFIFO_RXFE_Msk = 0x8
	// Bit RXFE.
	UART_PFIFO_RXFE = 0x8
	// Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
	UART_PFIFO_RXFE_0 = 0x0
	// Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
	UART_PFIFO_RXFE_1 = 0x1
	// Position of TXFIFOSIZE field.
	UART_PFIFO_TXFIFOSIZE_Pos = 0x4
	// Bit mask of TXFIFOSIZE field.
	UART_PFIFO_TXFIFOSIZE_Msk = 0x70
	// Transmit FIFO/Buffer depth = 1 dataword.
	UART_PFIFO_TXFIFOSIZE_000 = 0x0
	// Transmit FIFO/Buffer depth = 4 datawords.
	UART_PFIFO_TXFIFOSIZE_001 = 0x1
	// Transmit FIFO/Buffer depth = 8 datawords.
	UART_PFIFO_TXFIFOSIZE_010 = 0x2
	// Transmit FIFO/Buffer depth = 16 datawords.
	UART_PFIFO_TXFIFOSIZE_011 = 0x3
	// Transmit FIFO/Buffer depth = 32 datawords.
	UART_PFIFO_TXFIFOSIZE_100 = 0x4
	// Transmit FIFO/Buffer depth = 64 datawords.
	UART_PFIFO_TXFIFOSIZE_101 = 0x5
	// Transmit FIFO/Buffer depth = 128 datawords.
	UART_PFIFO_TXFIFOSIZE_110 = 0x6
	// Position of TXFE field.
	UART_PFIFO_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	UART_PFIFO_TXFE_Msk = 0x80
	// Bit TXFE.
	UART_PFIFO_TXFE = 0x80
	// Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
	UART_PFIFO_TXFE_0 = 0x0
	// Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
	UART_PFIFO_TXFE_1 = 0x1

	// CFIFO: UART FIFO Control Register
	// Position of RXUFE field.
	UART_CFIFO_RXUFE_Pos = 0x0
	// Bit mask of RXUFE field.
	UART_CFIFO_RXUFE_Msk = 0x1
	// Bit RXUFE.
	UART_CFIFO_RXUFE = 0x1
	// RXUF flag does not generate an interrupt to the host.
	UART_CFIFO_RXUFE_0 = 0x0
	// RXUF flag generates an interrupt to the host.
	UART_CFIFO_RXUFE_1 = 0x1
	// Position of TXOFE field.
	UART_CFIFO_TXOFE_Pos = 0x1
	// Bit mask of TXOFE field.
	UART_CFIFO_TXOFE_Msk = 0x2
	// Bit TXOFE.
	UART_CFIFO_TXOFE = 0x2
	// TXOF flag does not generate an interrupt to the host.
	UART_CFIFO_TXOFE_0 = 0x0
	// TXOF flag generates an interrupt to the host.
	UART_CFIFO_TXOFE_1 = 0x1
	// Position of RXOFE field.
	UART_CFIFO_RXOFE_Pos = 0x2
	// Bit mask of RXOFE field.
	UART_CFIFO_RXOFE_Msk = 0x4
	// Bit RXOFE.
	UART_CFIFO_RXOFE = 0x4
	// RXOF flag does not generate an interrupt to the host.
	UART_CFIFO_RXOFE_0 = 0x0
	// RXOF flag generates an interrupt to the host.
	UART_CFIFO_RXOFE_1 = 0x1
	// Position of RXFLUSH field.
	UART_CFIFO_RXFLUSH_Pos = 0x6
	// Bit mask of RXFLUSH field.
	UART_CFIFO_RXFLUSH_Msk = 0x40
	// Bit RXFLUSH.
	UART_CFIFO_RXFLUSH = 0x40
	// No flush operation occurs.
	UART_CFIFO_RXFLUSH_0 = 0x0
	// All data in the receive FIFO/buffer is cleared out.
	UART_CFIFO_RXFLUSH_1 = 0x1
	// Position of TXFLUSH field.
	UART_CFIFO_TXFLUSH_Pos = 0x7
	// Bit mask of TXFLUSH field.
	UART_CFIFO_TXFLUSH_Msk = 0x80
	// Bit TXFLUSH.
	UART_CFIFO_TXFLUSH = 0x80
	// No flush operation occurs.
	UART_CFIFO_TXFLUSH_0 = 0x0
	// All data in the transmit FIFO/Buffer is cleared out.
	UART_CFIFO_TXFLUSH_1 = 0x1

	// SFIFO: UART FIFO Status Register
	// Position of RXUF field.
	UART_SFIFO_RXUF_Pos = 0x0
	// Bit mask of RXUF field.
	UART_SFIFO_RXUF_Msk = 0x1
	// Bit RXUF.
	UART_SFIFO_RXUF = 0x1
	// No receive buffer underflow has occurred since the last time the flag was cleared.
	UART_SFIFO_RXUF_0 = 0x0
	// At least one receive buffer underflow has occurred since the last time the flag was cleared.
	UART_SFIFO_RXUF_1 = 0x1
	// Position of TXOF field.
	UART_SFIFO_TXOF_Pos = 0x1
	// Bit mask of TXOF field.
	UART_SFIFO_TXOF_Msk = 0x2
	// Bit TXOF.
	UART_SFIFO_TXOF = 0x2
	// No transmit buffer overflow has occurred since the last time the flag was cleared.
	UART_SFIFO_TXOF_0 = 0x0
	// At least one transmit buffer overflow has occurred since the last time the flag was cleared.
	UART_SFIFO_TXOF_1 = 0x1
	// Position of RXOF field.
	UART_SFIFO_RXOF_Pos = 0x2
	// Bit mask of RXOF field.
	UART_SFIFO_RXOF_Msk = 0x4
	// Bit RXOF.
	UART_SFIFO_RXOF = 0x4
	// No receive buffer overflow has occurred since the last time the flag was cleared.
	UART_SFIFO_RXOF_0 = 0x0
	// At least one receive buffer overflow has occurred since the last time the flag was cleared.
	UART_SFIFO_RXOF_1 = 0x1
	// Position of RXEMPT field.
	UART_SFIFO_RXEMPT_Pos = 0x6
	// Bit mask of RXEMPT field.
	UART_SFIFO_RXEMPT_Msk = 0x40
	// Bit RXEMPT.
	UART_SFIFO_RXEMPT = 0x40
	// Receive buffer is not empty.
	UART_SFIFO_RXEMPT_0 = 0x0
	// Receive buffer is empty.
	UART_SFIFO_RXEMPT_1 = 0x1
	// Position of TXEMPT field.
	UART_SFIFO_TXEMPT_Pos = 0x7
	// Bit mask of TXEMPT field.
	UART_SFIFO_TXEMPT_Msk = 0x80
	// Bit TXEMPT.
	UART_SFIFO_TXEMPT = 0x80
	// Transmit buffer is not empty.
	UART_SFIFO_TXEMPT_0 = 0x0
	// Transmit buffer is empty.
	UART_SFIFO_TXEMPT_1 = 0x1

	// TWFIFO: UART FIFO Transmit Watermark
	// Position of TXWATER field.
	UART_TWFIFO_TXWATER_Pos = 0x0
	// Bit mask of TXWATER field.
	UART_TWFIFO_TXWATER_Msk = 0xff

	// TCFIFO: UART FIFO Transmit Count
	// Position of TXCOUNT field.
	UART_TCFIFO_TXCOUNT_Pos = 0x0
	// Bit mask of TXCOUNT field.
	UART_TCFIFO_TXCOUNT_Msk = 0xff

	// RWFIFO: UART FIFO Receive Watermark
	// Position of RXWATER field.
	UART_RWFIFO_RXWATER_Pos = 0x0
	// Bit mask of RXWATER field.
	UART_RWFIFO_RXWATER_Msk = 0xff

	// RCFIFO: UART FIFO Receive Count
	// Position of RXCOUNT field.
	UART_RCFIFO_RXCOUNT_Pos = 0x0
	// Bit mask of RXCOUNT field.
	UART_RCFIFO_RXCOUNT_Msk = 0xff

	// C7816: UART 7816 Control Register
	// Position of ISO_7816E field.
	UART_C7816_ISO_7816E_Pos = 0x0
	// Bit mask of ISO_7816E field.
	UART_C7816_ISO_7816E_Msk = 0x1
	// Bit ISO_7816E.
	UART_C7816_ISO_7816E = 0x1
	// ISO-7816 functionality is turned off/not enabled.
	UART_C7816_ISO_7816E_0 = 0x0
	// ISO-7816 functionality is turned on/enabled.
	UART_C7816_ISO_7816E_1 = 0x1
	// Position of TTYPE field.
	UART_C7816_TTYPE_Pos = 0x1
	// Bit mask of TTYPE field.
	UART_C7816_TTYPE_Msk = 0x2
	// Bit TTYPE.
	UART_C7816_TTYPE = 0x2
	// T = 0 per the ISO-7816 specification.
	UART_C7816_TTYPE_0 = 0x0
	// T = 1 per the ISO-7816 specification.
	UART_C7816_TTYPE_1 = 0x1
	// Position of INIT field.
	UART_C7816_INIT_Pos = 0x2
	// Bit mask of INIT field.
	UART_C7816_INIT_Msk = 0x4
	// Bit INIT.
	UART_C7816_INIT = 0x4
	// Normal operating mode. Receiver does not seek to identify initial character.
	UART_C7816_INIT_0 = 0x0
	// Receiver searches for initial character.
	UART_C7816_INIT_1 = 0x1
	// Position of ANACK field.
	UART_C7816_ANACK_Pos = 0x3
	// Bit mask of ANACK field.
	UART_C7816_ANACK_Msk = 0x8
	// Bit ANACK.
	UART_C7816_ANACK = 0x8
	// No NACK is automatically generated.
	UART_C7816_ANACK_0 = 0x0
	// A NACK is automatically generated if a parity error is detected or if an invalid initial character is detected.
	UART_C7816_ANACK_1 = 0x1
	// Position of ONACK field.
	UART_C7816_ONACK_Pos = 0x4
	// Bit mask of ONACK field.
	UART_C7816_ONACK_Msk = 0x10
	// Bit ONACK.
	UART_C7816_ONACK = 0x10
	// The received data does not generate a NACK when the receipt of the data results in an overflow event.
	UART_C7816_ONACK_0 = 0x0
	// If the receiver buffer overflows, a NACK is automatically sent on a received character.
	UART_C7816_ONACK_1 = 0x1

	// IE7816: UART 7816 Interrupt Enable Register
	// Position of RXTE field.
	UART_IE7816_RXTE_Pos = 0x0
	// Bit mask of RXTE field.
	UART_IE7816_RXTE_Msk = 0x1
	// Bit RXTE.
	UART_IE7816_RXTE = 0x1
	// The assertion of IS7816[RXT] does not result in the generation of an interrupt.
	UART_IE7816_RXTE_0 = 0x0
	// The assertion of IS7816[RXT] results in the generation of an interrupt.
	UART_IE7816_RXTE_1 = 0x1
	// Position of TXTE field.
	UART_IE7816_TXTE_Pos = 0x1
	// Bit mask of TXTE field.
	UART_IE7816_TXTE_Msk = 0x2
	// Bit TXTE.
	UART_IE7816_TXTE = 0x2
	// The assertion of IS7816[TXT] does not result in the generation of an interrupt.
	UART_IE7816_TXTE_0 = 0x0
	// The assertion of IS7816[TXT] results in the generation of an interrupt.
	UART_IE7816_TXTE_1 = 0x1
	// Position of GTVE field.
	UART_IE7816_GTVE_Pos = 0x2
	// Bit mask of GTVE field.
	UART_IE7816_GTVE_Msk = 0x4
	// Bit GTVE.
	UART_IE7816_GTVE = 0x4
	// The assertion of IS7816[GTV] does not result in the generation of an interrupt.
	UART_IE7816_GTVE_0 = 0x0
	// The assertion of IS7816[GTV] results in the generation of an interrupt.
	UART_IE7816_GTVE_1 = 0x1
	// Position of ADTE field.
	UART_IE7816_ADTE_Pos = 0x3
	// Bit mask of ADTE field.
	UART_IE7816_ADTE_Msk = 0x8
	// Bit ADTE.
	UART_IE7816_ADTE = 0x8
	// The assertion of IS7816[ADT] does not result in the generation of an interrupt.
	UART_IE7816_ADTE_0 = 0x0
	// The assertion of IS7816[ADT] results in the generation of an interrupt.
	UART_IE7816_ADTE_1 = 0x1
	// Position of INITDE field.
	UART_IE7816_INITDE_Pos = 0x4
	// Bit mask of INITDE field.
	UART_IE7816_INITDE_Msk = 0x10
	// Bit INITDE.
	UART_IE7816_INITDE = 0x10
	// The assertion of IS7816[INITD] does not result in the generation of an interrupt.
	UART_IE7816_INITDE_0 = 0x0
	// The assertion of IS7816[INITD] results in the generation of an interrupt.
	UART_IE7816_INITDE_1 = 0x1
	// Position of BWTE field.
	UART_IE7816_BWTE_Pos = 0x5
	// Bit mask of BWTE field.
	UART_IE7816_BWTE_Msk = 0x20
	// Bit BWTE.
	UART_IE7816_BWTE = 0x20
	// The assertion of IS7816[BWT] does not result in the generation of an interrupt.
	UART_IE7816_BWTE_0 = 0x0
	// The assertion of IS7816[BWT] results in the generation of an interrupt.
	UART_IE7816_BWTE_1 = 0x1
	// Position of CWTE field.
	UART_IE7816_CWTE_Pos = 0x6
	// Bit mask of CWTE field.
	UART_IE7816_CWTE_Msk = 0x40
	// Bit CWTE.
	UART_IE7816_CWTE = 0x40
	// The assertion of IS7816[CWT] does not result in the generation of an interrupt.
	UART_IE7816_CWTE_0 = 0x0
	// The assertion of IS7816[CWT] results in the generation of an interrupt.
	UART_IE7816_CWTE_1 = 0x1
	// Position of WTE field.
	UART_IE7816_WTE_Pos = 0x7
	// Bit mask of WTE field.
	UART_IE7816_WTE_Msk = 0x80
	// Bit WTE.
	UART_IE7816_WTE = 0x80
	// The assertion of IS7816[WT] does not result in the generation of an interrupt.
	UART_IE7816_WTE_0 = 0x0
	// The assertion of IS7816[WT] results in the generation of an interrupt.
	UART_IE7816_WTE_1 = 0x1

	// IS7816: UART 7816 Interrupt Status Register
	// Position of RXT field.
	UART_IS7816_RXT_Pos = 0x0
	// Bit mask of RXT field.
	UART_IS7816_RXT_Msk = 0x1
	// Bit RXT.
	UART_IS7816_RXT = 0x1
	// The number of consecutive NACKS generated as a result of parity errors and buffer overruns is less than or equal to the value in ET7816[RXTHRESHOLD].
	UART_IS7816_RXT_0 = 0x0
	// The number of consecutive NACKS generated as a result of parity errors and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
	UART_IS7816_RXT_1 = 0x1
	// Position of TXT field.
	UART_IS7816_TXT_Pos = 0x1
	// Bit mask of TXT field.
	UART_IS7816_TXT_Msk = 0x2
	// Bit TXT.
	UART_IS7816_TXT = 0x2
	// The number of retries and corresponding NACKS does not exceed the value in ET7816[TXTHRESHOLD].
	UART_IS7816_TXT_0 = 0x0
	// The number of retries and corresponding NACKS exceeds the value in ET7816[TXTHRESHOLD].
	UART_IS7816_TXT_1 = 0x1
	// Position of GTV field.
	UART_IS7816_GTV_Pos = 0x2
	// Bit mask of GTV field.
	UART_IS7816_GTV_Msk = 0x4
	// Bit GTV.
	UART_IS7816_GTV = 0x4
	// A guard time (GT, CGT, or BGT) has not been violated.
	UART_IS7816_GTV_0 = 0x0
	// A guard time (GT, CGT, or BGT) has been violated.
	UART_IS7816_GTV_1 = 0x1
	// Position of ADT field.
	UART_IS7816_ADT_Pos = 0x3
	// Bit mask of ADT field.
	UART_IS7816_ADT_Msk = 0x8
	// Bit ADT.
	UART_IS7816_ADT = 0x8
	// ATR Duration time (ADT) has not been violated.
	UART_IS7816_ADT_0 = 0x0
	// ATR Duration time (ADT) has been violated.
	UART_IS7816_ADT_1 = 0x1
	// Position of INITD field.
	UART_IS7816_INITD_Pos = 0x4
	// Bit mask of INITD field.
	UART_IS7816_INITD_Msk = 0x10
	// Bit INITD.
	UART_IS7816_INITD = 0x10
	// A valid initial character has not been received.
	UART_IS7816_INITD_0 = 0x0
	// A valid initial character has been received.
	UART_IS7816_INITD_1 = 0x1
	// Position of BWT field.
	UART_IS7816_BWT_Pos = 0x5
	// Bit mask of BWT field.
	UART_IS7816_BWT_Msk = 0x20
	// Bit BWT.
	UART_IS7816_BWT = 0x20
	// Block wait time (BWT) has not been violated.
	UART_IS7816_BWT_0 = 0x0
	// Block wait time (BWT) has been violated.
	UART_IS7816_BWT_1 = 0x1
	// Position of CWT field.
	UART_IS7816_CWT_Pos = 0x6
	// Bit mask of CWT field.
	UART_IS7816_CWT_Msk = 0x40
	// Bit CWT.
	UART_IS7816_CWT = 0x40
	// Character wait time (CWT) has not been violated.
	UART_IS7816_CWT_0 = 0x0
	// Character wait time (CWT) has been violated.
	UART_IS7816_CWT_1 = 0x1
	// Position of WT field.
	UART_IS7816_WT_Pos = 0x7
	// Bit mask of WT field.
	UART_IS7816_WT_Msk = 0x80
	// Bit WT.
	UART_IS7816_WT = 0x80
	// Wait time (WT) has not been violated.
	UART_IS7816_WT_0 = 0x0
	// Wait time (WT) has been violated.
	UART_IS7816_WT_1 = 0x1

	// WP7816: UART 7816 Wait Parameter Register
	// Position of WTX field.
	UART_WP7816_WTX_Pos = 0x0
	// Bit mask of WTX field.
	UART_WP7816_WTX_Msk = 0xff

	// WN7816: UART 7816 Wait N Register
	// Position of GTN field.
	UART_WN7816_GTN_Pos = 0x0
	// Bit mask of GTN field.
	UART_WN7816_GTN_Msk = 0xff

	// WF7816: UART 7816 Wait FD Register
	// Position of GTFD field.
	UART_WF7816_GTFD_Pos = 0x0
	// Bit mask of GTFD field.
	UART_WF7816_GTFD_Msk = 0xff

	// ET7816: UART 7816 Error Threshold Register
	// Position of RXTHRESHOLD field.
	UART_ET7816_RXTHRESHOLD_Pos = 0x0
	// Bit mask of RXTHRESHOLD field.
	UART_ET7816_RXTHRESHOLD_Msk = 0xf
	// Position of TXTHRESHOLD field.
	UART_ET7816_TXTHRESHOLD_Pos = 0x4
	// Bit mask of TXTHRESHOLD field.
	UART_ET7816_TXTHRESHOLD_Msk = 0xf0
	// TXT asserts on the first NACK that is received.
	UART_ET7816_TXTHRESHOLD_0 = 0x0
	// TXT asserts on the second NACK that is received.
	UART_ET7816_TXTHRESHOLD_1 = 0x1

	// TL7816: UART 7816 Transmit Length Register
	// Position of TLEN field.
	UART_TL7816_TLEN_Pos = 0x0
	// Bit mask of TLEN field.
	UART_TL7816_TLEN_Msk = 0xff

	// AP7816A_T0: UART 7816 ATR Duration Timer Register A
	// Position of ADTI_H field.
	UART_AP7816A_T0_ADTI_H_Pos = 0x0
	// Bit mask of ADTI_H field.
	UART_AP7816A_T0_ADTI_H_Msk = 0xff

	// AP7816B_T0: UART 7816 ATR Duration Timer Register B
	// Position of ADTI_L field.
	UART_AP7816B_T0_ADTI_L_Pos = 0x0
	// Bit mask of ADTI_L field.
	UART_AP7816B_T0_ADTI_L_Msk = 0xff

	// WP7816A_T0: UART 7816 Wait Parameter Register A
	// Position of WI_H field.
	UART_WP7816A_T0_WI_H_Pos = 0x0
	// Bit mask of WI_H field.
	UART_WP7816A_T0_WI_H_Msk = 0xff

	// WP7816A_T1: UART 7816 Wait Parameter Register A
	// Position of BWI_H field.
	UART_WP7816A_T1_BWI_H_Pos = 0x0
	// Bit mask of BWI_H field.
	UART_WP7816A_T1_BWI_H_Msk = 0xff

	// WP7816B_T0: UART 7816 Wait Parameter Register B
	// Position of WI_L field.
	UART_WP7816B_T0_WI_L_Pos = 0x0
	// Bit mask of WI_L field.
	UART_WP7816B_T0_WI_L_Msk = 0xff

	// WP7816B_T1: UART 7816 Wait Parameter Register B
	// Position of BWI_L field.
	UART_WP7816B_T1_BWI_L_Pos = 0x0
	// Bit mask of BWI_L field.
	UART_WP7816B_T1_BWI_L_Msk = 0xff

	// WGP7816_T1: UART 7816 Wait and Guard Parameter Register
	// Position of BGI field.
	UART_WGP7816_T1_BGI_Pos = 0x0
	// Bit mask of BGI field.
	UART_WGP7816_T1_BGI_Msk = 0xf
	// Position of CWI1 field.
	UART_WGP7816_T1_CWI1_Pos = 0x4
	// Bit mask of CWI1 field.
	UART_WGP7816_T1_CWI1_Msk = 0xf0

	// WP7816C_T1: UART 7816 Wait Parameter Register C
	// Position of CWI2 field.
	UART_WP7816C_T1_CWI2_Pos = 0x0
	// Bit mask of CWI2 field.
	UART_WP7816C_T1_CWI2_Msk = 0x1f
)

// Constants for USB0: Universal Serial Bus, OTG Capable Controller
const (
	// PERID: Peripheral ID register
	// Position of ID field.
	USB0_PERID_ID_Pos = 0x0
	// Bit mask of ID field.
	USB0_PERID_ID_Msk = 0x3f

	// IDCOMP: Peripheral ID Complement register
	// Position of NID field.
	USB0_IDCOMP_NID_Pos = 0x0
	// Bit mask of NID field.
	USB0_IDCOMP_NID_Msk = 0x3f

	// REV: Peripheral Revision register
	// Position of REV field.
	USB0_REV_REV_Pos = 0x0
	// Bit mask of REV field.
	USB0_REV_REV_Msk = 0xff

	// ADDINFO: Peripheral Additional Info register
	// Position of IEHOST field.
	USB0_ADDINFO_IEHOST_Pos = 0x0
	// Bit mask of IEHOST field.
	USB0_ADDINFO_IEHOST_Msk = 0x1
	// Bit IEHOST.
	USB0_ADDINFO_IEHOST = 0x1

	// OTGISTAT: OTG Interrupt Status register
	// Position of AVBUSCHG field.
	USB0_OTGISTAT_AVBUSCHG_Pos = 0x0
	// Bit mask of AVBUSCHG field.
	USB0_OTGISTAT_AVBUSCHG_Msk = 0x1
	// Bit AVBUSCHG.
	USB0_OTGISTAT_AVBUSCHG = 0x1
	// Position of B_SESS_CHG field.
	USB0_OTGISTAT_B_SESS_CHG_Pos = 0x2
	// Bit mask of B_SESS_CHG field.
	USB0_OTGISTAT_B_SESS_CHG_Msk = 0x4
	// Bit B_SESS_CHG.
	USB0_OTGISTAT_B_SESS_CHG = 0x4
	// Position of SESSVLDCHG field.
	USB0_OTGISTAT_SESSVLDCHG_Pos = 0x3
	// Bit mask of SESSVLDCHG field.
	USB0_OTGISTAT_SESSVLDCHG_Msk = 0x8
	// Bit SESSVLDCHG.
	USB0_OTGISTAT_SESSVLDCHG = 0x8
	// Position of LINE_STATE_CHG field.
	USB0_OTGISTAT_LINE_STATE_CHG_Pos = 0x5
	// Bit mask of LINE_STATE_CHG field.
	USB0_OTGISTAT_LINE_STATE_CHG_Msk = 0x20
	// Bit LINE_STATE_CHG.
	USB0_OTGISTAT_LINE_STATE_CHG = 0x20
	// Position of ONEMSEC field.
	USB0_OTGISTAT_ONEMSEC_Pos = 0x6
	// Bit mask of ONEMSEC field.
	USB0_OTGISTAT_ONEMSEC_Msk = 0x40
	// Bit ONEMSEC.
	USB0_OTGISTAT_ONEMSEC = 0x40
	// Position of IDCHG field.
	USB0_OTGISTAT_IDCHG_Pos = 0x7
	// Bit mask of IDCHG field.
	USB0_OTGISTAT_IDCHG_Msk = 0x80
	// Bit IDCHG.
	USB0_OTGISTAT_IDCHG = 0x80

	// OTGICR: OTG Interrupt Control register
	// Position of AVBUSEN field.
	USB0_OTGICR_AVBUSEN_Pos = 0x0
	// Bit mask of AVBUSEN field.
	USB0_OTGICR_AVBUSEN_Msk = 0x1
	// Bit AVBUSEN.
	USB0_OTGICR_AVBUSEN = 0x1
	// Disables the AVBUSCHG interrupt.
	USB0_OTGICR_AVBUSEN_0 = 0x0
	// Enables the AVBUSCHG interrupt.
	USB0_OTGICR_AVBUSEN_1 = 0x1
	// Position of BSESSEN field.
	USB0_OTGICR_BSESSEN_Pos = 0x2
	// Bit mask of BSESSEN field.
	USB0_OTGICR_BSESSEN_Msk = 0x4
	// Bit BSESSEN.
	USB0_OTGICR_BSESSEN = 0x4
	// Disables the B_SESS_CHG interrupt.
	USB0_OTGICR_BSESSEN_0 = 0x0
	// Enables the B_SESS_CHG interrupt.
	USB0_OTGICR_BSESSEN_1 = 0x1
	// Position of SESSVLDEN field.
	USB0_OTGICR_SESSVLDEN_Pos = 0x3
	// Bit mask of SESSVLDEN field.
	USB0_OTGICR_SESSVLDEN_Msk = 0x8
	// Bit SESSVLDEN.
	USB0_OTGICR_SESSVLDEN = 0x8
	// Disables the SESSVLDCHG interrupt.
	USB0_OTGICR_SESSVLDEN_0 = 0x0
	// Enables the SESSVLDCHG interrupt.
	USB0_OTGICR_SESSVLDEN_1 = 0x1
	// Position of LINESTATEEN field.
	USB0_OTGICR_LINESTATEEN_Pos = 0x5
	// Bit mask of LINESTATEEN field.
	USB0_OTGICR_LINESTATEEN_Msk = 0x20
	// Bit LINESTATEEN.
	USB0_OTGICR_LINESTATEEN = 0x20
	// Disables the LINE_STAT_CHG interrupt.
	USB0_OTGICR_LINESTATEEN_0 = 0x0
	// Enables the LINE_STAT_CHG interrupt.
	USB0_OTGICR_LINESTATEEN_1 = 0x1
	// Position of ONEMSECEN field.
	USB0_OTGICR_ONEMSECEN_Pos = 0x6
	// Bit mask of ONEMSECEN field.
	USB0_OTGICR_ONEMSECEN_Msk = 0x40
	// Bit ONEMSECEN.
	USB0_OTGICR_ONEMSECEN = 0x40
	// Diables the 1ms timer interrupt.
	USB0_OTGICR_ONEMSECEN_0 = 0x0
	// Enables the 1ms timer interrupt.
	USB0_OTGICR_ONEMSECEN_1 = 0x1
	// Position of IDEN field.
	USB0_OTGICR_IDEN_Pos = 0x7
	// Bit mask of IDEN field.
	USB0_OTGICR_IDEN_Msk = 0x80
	// Bit IDEN.
	USB0_OTGICR_IDEN = 0x80
	// The ID interrupt is disabled
	USB0_OTGICR_IDEN_0 = 0x0
	// The ID interrupt is enabled
	USB0_OTGICR_IDEN_1 = 0x1

	// OTGSTAT: OTG Status register
	// Position of AVBUSVLD field.
	USB0_OTGSTAT_AVBUSVLD_Pos = 0x0
	// Bit mask of AVBUSVLD field.
	USB0_OTGSTAT_AVBUSVLD_Msk = 0x1
	// Bit AVBUSVLD.
	USB0_OTGSTAT_AVBUSVLD = 0x1
	// The VBUS voltage is below the A VBUS Valid threshold.
	USB0_OTGSTAT_AVBUSVLD_0 = 0x0
	// The VBUS voltage is above the A VBUS Valid threshold.
	USB0_OTGSTAT_AVBUSVLD_1 = 0x1
	// Position of BSESSEND field.
	USB0_OTGSTAT_BSESSEND_Pos = 0x2
	// Bit mask of BSESSEND field.
	USB0_OTGSTAT_BSESSEND_Msk = 0x4
	// Bit BSESSEND.
	USB0_OTGSTAT_BSESSEND = 0x4
	// The VBUS voltage is above the B session end threshold.
	USB0_OTGSTAT_BSESSEND_0 = 0x0
	// The VBUS voltage is below the B session end threshold.
	USB0_OTGSTAT_BSESSEND_1 = 0x1
	// Position of SESS_VLD field.
	USB0_OTGSTAT_SESS_VLD_Pos = 0x3
	// Bit mask of SESS_VLD field.
	USB0_OTGSTAT_SESS_VLD_Msk = 0x8
	// Bit SESS_VLD.
	USB0_OTGSTAT_SESS_VLD = 0x8
	// The VBUS voltage is below the B session valid threshold
	USB0_OTGSTAT_SESS_VLD_0 = 0x0
	// The VBUS voltage is above the B session valid threshold.
	USB0_OTGSTAT_SESS_VLD_1 = 0x1
	// Position of LINESTATESTABLE field.
	USB0_OTGSTAT_LINESTATESTABLE_Pos = 0x5
	// Bit mask of LINESTATESTABLE field.
	USB0_OTGSTAT_LINESTATESTABLE_Msk = 0x20
	// Bit LINESTATESTABLE.
	USB0_OTGSTAT_LINESTATESTABLE = 0x20
	// The LINE_STAT_CHG bit is not yet stable.
	USB0_OTGSTAT_LINESTATESTABLE_0 = 0x0
	// The LINE_STAT_CHG bit has been debounced and is stable.
	USB0_OTGSTAT_LINESTATESTABLE_1 = 0x1
	// Position of ONEMSECEN field.
	USB0_OTGSTAT_ONEMSECEN_Pos = 0x6
	// Bit mask of ONEMSECEN field.
	USB0_OTGSTAT_ONEMSECEN_Msk = 0x40
	// Bit ONEMSECEN.
	USB0_OTGSTAT_ONEMSECEN = 0x40
	// Position of ID field.
	USB0_OTGSTAT_ID_Pos = 0x7
	// Bit mask of ID field.
	USB0_OTGSTAT_ID_Msk = 0x80
	// Bit ID.
	USB0_OTGSTAT_ID = 0x80
	// Indicates a Type A cable is plugged into the USB connector.
	USB0_OTGSTAT_ID_0 = 0x0
	// Indicates no cable is attached or a Type B cable is plugged into the USB connector.
	USB0_OTGSTAT_ID_1 = 0x1

	// OTGCTL: OTG Control register
	// Position of OTGEN field.
	USB0_OTGCTL_OTGEN_Pos = 0x2
	// Bit mask of OTGEN field.
	USB0_OTGCTL_OTGEN_Msk = 0x4
	// Bit OTGEN.
	USB0_OTGCTL_OTGEN = 0x4
	// If USB_EN is 1 and HOST_MODE is 0 in the Control Register (CTL), then the D+ Data Line pull-up resistors are enabled. If HOST_MODE is 1 the D+ and D- Data Line pull-down resistors are engaged.
	USB0_OTGCTL_OTGEN_0 = 0x0
	// The pull-up and pull-down controls in this register are used.
	USB0_OTGCTL_OTGEN_1 = 0x1
	// Position of DMLOW field.
	USB0_OTGCTL_DMLOW_Pos = 0x4
	// Bit mask of DMLOW field.
	USB0_OTGCTL_DMLOW_Msk = 0x10
	// Bit DMLOW.
	USB0_OTGCTL_DMLOW = 0x10
	// D- pulldown resistor is not enabled.
	USB0_OTGCTL_DMLOW_0 = 0x0
	// D- pulldown resistor is enabled.
	USB0_OTGCTL_DMLOW_1 = 0x1
	// Position of DPLOW field.
	USB0_OTGCTL_DPLOW_Pos = 0x5
	// Bit mask of DPLOW field.
	USB0_OTGCTL_DPLOW_Msk = 0x20
	// Bit DPLOW.
	USB0_OTGCTL_DPLOW = 0x20
	// D+ pulldown resistor is not enabled.
	USB0_OTGCTL_DPLOW_0 = 0x0
	// D+ pulldown resistor is enabled.
	USB0_OTGCTL_DPLOW_1 = 0x1
	// Position of DPHIGH field.
	USB0_OTGCTL_DPHIGH_Pos = 0x7
	// Bit mask of DPHIGH field.
	USB0_OTGCTL_DPHIGH_Msk = 0x80
	// Bit DPHIGH.
	USB0_OTGCTL_DPHIGH = 0x80
	// D+ pullup resistor is not enabled
	USB0_OTGCTL_DPHIGH_0 = 0x0
	// D+ pullup resistor is enabled
	USB0_OTGCTL_DPHIGH_1 = 0x1

	// ISTAT: Interrupt Status register
	// Position of USBRST field.
	USB0_ISTAT_USBRST_Pos = 0x0
	// Bit mask of USBRST field.
	USB0_ISTAT_USBRST_Msk = 0x1
	// Bit USBRST.
	USB0_ISTAT_USBRST = 0x1
	// Position of ERROR field.
	USB0_ISTAT_ERROR_Pos = 0x1
	// Bit mask of ERROR field.
	USB0_ISTAT_ERROR_Msk = 0x2
	// Bit ERROR.
	USB0_ISTAT_ERROR = 0x2
	// Position of SOFTOK field.
	USB0_ISTAT_SOFTOK_Pos = 0x2
	// Bit mask of SOFTOK field.
	USB0_ISTAT_SOFTOK_Msk = 0x4
	// Bit SOFTOK.
	USB0_ISTAT_SOFTOK = 0x4
	// Position of TOKDNE field.
	USB0_ISTAT_TOKDNE_Pos = 0x3
	// Bit mask of TOKDNE field.
	USB0_ISTAT_TOKDNE_Msk = 0x8
	// Bit TOKDNE.
	USB0_ISTAT_TOKDNE = 0x8
	// Position of SLEEP field.
	USB0_ISTAT_SLEEP_Pos = 0x4
	// Bit mask of SLEEP field.
	USB0_ISTAT_SLEEP_Msk = 0x10
	// Bit SLEEP.
	USB0_ISTAT_SLEEP = 0x10
	// Position of RESUME field.
	USB0_ISTAT_RESUME_Pos = 0x5
	// Bit mask of RESUME field.
	USB0_ISTAT_RESUME_Msk = 0x20
	// Bit RESUME.
	USB0_ISTAT_RESUME = 0x20
	// Position of ATTACH field.
	USB0_ISTAT_ATTACH_Pos = 0x6
	// Bit mask of ATTACH field.
	USB0_ISTAT_ATTACH_Msk = 0x40
	// Bit ATTACH.
	USB0_ISTAT_ATTACH = 0x40
	// No Attach is detected since the last time the ATTACH bit was cleared.
	USB0_ISTAT_ATTACH_0 = 0x0
	// A peripheral is now present and must be configured (a stable non-SE0 state is detected for more than 2.5 us).
	USB0_ISTAT_ATTACH_1 = 0x1
	// Position of STALL field.
	USB0_ISTAT_STALL_Pos = 0x7
	// Bit mask of STALL field.
	USB0_ISTAT_STALL_Msk = 0x80
	// Bit STALL.
	USB0_ISTAT_STALL = 0x80

	// INTEN: Interrupt Enable register
	// Position of USBRSTEN field.
	USB0_INTEN_USBRSTEN_Pos = 0x0
	// Bit mask of USBRSTEN field.
	USB0_INTEN_USBRSTEN_Msk = 0x1
	// Bit USBRSTEN.
	USB0_INTEN_USBRSTEN = 0x1
	// Disables the USBRST interrupt.
	USB0_INTEN_USBRSTEN_0 = 0x0
	// Enables the USBRST interrupt.
	USB0_INTEN_USBRSTEN_1 = 0x1
	// Position of ERROREN field.
	USB0_INTEN_ERROREN_Pos = 0x1
	// Bit mask of ERROREN field.
	USB0_INTEN_ERROREN_Msk = 0x2
	// Bit ERROREN.
	USB0_INTEN_ERROREN = 0x2
	// Disables the ERROR interrupt.
	USB0_INTEN_ERROREN_0 = 0x0
	// Enables the ERROR interrupt.
	USB0_INTEN_ERROREN_1 = 0x1
	// Position of SOFTOKEN field.
	USB0_INTEN_SOFTOKEN_Pos = 0x2
	// Bit mask of SOFTOKEN field.
	USB0_INTEN_SOFTOKEN_Msk = 0x4
	// Bit SOFTOKEN.
	USB0_INTEN_SOFTOKEN = 0x4
	// Disbles the SOFTOK interrupt.
	USB0_INTEN_SOFTOKEN_0 = 0x0
	// Enables the SOFTOK interrupt.
	USB0_INTEN_SOFTOKEN_1 = 0x1
	// Position of TOKDNEEN field.
	USB0_INTEN_TOKDNEEN_Pos = 0x3
	// Bit mask of TOKDNEEN field.
	USB0_INTEN_TOKDNEEN_Msk = 0x8
	// Bit TOKDNEEN.
	USB0_INTEN_TOKDNEEN = 0x8
	// Disables the TOKDNE interrupt.
	USB0_INTEN_TOKDNEEN_0 = 0x0
	// Enables the TOKDNE interrupt.
	USB0_INTEN_TOKDNEEN_1 = 0x1
	// Position of SLEEPEN field.
	USB0_INTEN_SLEEPEN_Pos = 0x4
	// Bit mask of SLEEPEN field.
	USB0_INTEN_SLEEPEN_Msk = 0x10
	// Bit SLEEPEN.
	USB0_INTEN_SLEEPEN = 0x10
	// Disables the SLEEP interrupt.
	USB0_INTEN_SLEEPEN_0 = 0x0
	// Enables the SLEEP interrupt.
	USB0_INTEN_SLEEPEN_1 = 0x1
	// Position of RESUMEEN field.
	USB0_INTEN_RESUMEEN_Pos = 0x5
	// Bit mask of RESUMEEN field.
	USB0_INTEN_RESUMEEN_Msk = 0x20
	// Bit RESUMEEN.
	USB0_INTEN_RESUMEEN = 0x20
	// Disables the RESUME interrupt.
	USB0_INTEN_RESUMEEN_0 = 0x0
	// Enables the RESUME interrupt.
	USB0_INTEN_RESUMEEN_1 = 0x1
	// Position of ATTACHEN field.
	USB0_INTEN_ATTACHEN_Pos = 0x6
	// Bit mask of ATTACHEN field.
	USB0_INTEN_ATTACHEN_Msk = 0x40
	// Bit ATTACHEN.
	USB0_INTEN_ATTACHEN = 0x40
	// Disables the ATTACH interrupt.
	USB0_INTEN_ATTACHEN_0 = 0x0
	// Enables the ATTACH interrupt.
	USB0_INTEN_ATTACHEN_1 = 0x1
	// Position of STALLEN field.
	USB0_INTEN_STALLEN_Pos = 0x7
	// Bit mask of STALLEN field.
	USB0_INTEN_STALLEN_Msk = 0x80
	// Bit STALLEN.
	USB0_INTEN_STALLEN = 0x80
	// Diasbles the STALL interrupt.
	USB0_INTEN_STALLEN_0 = 0x0
	// Enables the STALL interrupt.
	USB0_INTEN_STALLEN_1 = 0x1

	// ERRSTAT: Error Interrupt Status register
	// Position of PIDERR field.
	USB0_ERRSTAT_PIDERR_Pos = 0x0
	// Bit mask of PIDERR field.
	USB0_ERRSTAT_PIDERR_Msk = 0x1
	// Bit PIDERR.
	USB0_ERRSTAT_PIDERR = 0x1
	// Position of CRC5EOF field.
	USB0_ERRSTAT_CRC5EOF_Pos = 0x1
	// Bit mask of CRC5EOF field.
	USB0_ERRSTAT_CRC5EOF_Msk = 0x2
	// Bit CRC5EOF.
	USB0_ERRSTAT_CRC5EOF = 0x2
	// Position of CRC16 field.
	USB0_ERRSTAT_CRC16_Pos = 0x2
	// Bit mask of CRC16 field.
	USB0_ERRSTAT_CRC16_Msk = 0x4
	// Bit CRC16.
	USB0_ERRSTAT_CRC16 = 0x4
	// Position of DFN8 field.
	USB0_ERRSTAT_DFN8_Pos = 0x3
	// Bit mask of DFN8 field.
	USB0_ERRSTAT_DFN8_Msk = 0x8
	// Bit DFN8.
	USB0_ERRSTAT_DFN8 = 0x8
	// Position of BTOERR field.
	USB0_ERRSTAT_BTOERR_Pos = 0x4
	// Bit mask of BTOERR field.
	USB0_ERRSTAT_BTOERR_Msk = 0x10
	// Bit BTOERR.
	USB0_ERRSTAT_BTOERR = 0x10
	// Position of DMAERR field.
	USB0_ERRSTAT_DMAERR_Pos = 0x5
	// Bit mask of DMAERR field.
	USB0_ERRSTAT_DMAERR_Msk = 0x20
	// Bit DMAERR.
	USB0_ERRSTAT_DMAERR = 0x20
	// Position of BTSERR field.
	USB0_ERRSTAT_BTSERR_Pos = 0x7
	// Bit mask of BTSERR field.
	USB0_ERRSTAT_BTSERR_Msk = 0x80
	// Bit BTSERR.
	USB0_ERRSTAT_BTSERR = 0x80

	// ERREN: Error Interrupt Enable register
	// Position of PIDERREN field.
	USB0_ERREN_PIDERREN_Pos = 0x0
	// Bit mask of PIDERREN field.
	USB0_ERREN_PIDERREN_Msk = 0x1
	// Bit PIDERREN.
	USB0_ERREN_PIDERREN = 0x1
	// Disables the PIDERR interrupt.
	USB0_ERREN_PIDERREN_0 = 0x0
	// Enters the PIDERR interrupt.
	USB0_ERREN_PIDERREN_1 = 0x1
	// Position of CRC5EOFEN field.
	USB0_ERREN_CRC5EOFEN_Pos = 0x1
	// Bit mask of CRC5EOFEN field.
	USB0_ERREN_CRC5EOFEN_Msk = 0x2
	// Bit CRC5EOFEN.
	USB0_ERREN_CRC5EOFEN = 0x2
	// Disables the CRC5/EOF interrupt.
	USB0_ERREN_CRC5EOFEN_0 = 0x0
	// Enables the CRC5/EOF interrupt.
	USB0_ERREN_CRC5EOFEN_1 = 0x1
	// Position of CRC16EN field.
	USB0_ERREN_CRC16EN_Pos = 0x2
	// Bit mask of CRC16EN field.
	USB0_ERREN_CRC16EN_Msk = 0x4
	// Bit CRC16EN.
	USB0_ERREN_CRC16EN = 0x4
	// Disables the CRC16 interrupt.
	USB0_ERREN_CRC16EN_0 = 0x0
	// Enables the CRC16 interrupt.
	USB0_ERREN_CRC16EN_1 = 0x1
	// Position of DFN8EN field.
	USB0_ERREN_DFN8EN_Pos = 0x3
	// Bit mask of DFN8EN field.
	USB0_ERREN_DFN8EN_Msk = 0x8
	// Bit DFN8EN.
	USB0_ERREN_DFN8EN = 0x8
	// Disables the DFN8 interrupt.
	USB0_ERREN_DFN8EN_0 = 0x0
	// Enables the DFN8 interrupt.
	USB0_ERREN_DFN8EN_1 = 0x1
	// Position of BTOERREN field.
	USB0_ERREN_BTOERREN_Pos = 0x4
	// Bit mask of BTOERREN field.
	USB0_ERREN_BTOERREN_Msk = 0x10
	// Bit BTOERREN.
	USB0_ERREN_BTOERREN = 0x10
	// Disables the BTOERR interrupt.
	USB0_ERREN_BTOERREN_0 = 0x0
	// Enables the BTOERR interrupt.
	USB0_ERREN_BTOERREN_1 = 0x1
	// Position of DMAERREN field.
	USB0_ERREN_DMAERREN_Pos = 0x5
	// Bit mask of DMAERREN field.
	USB0_ERREN_DMAERREN_Msk = 0x20
	// Bit DMAERREN.
	USB0_ERREN_DMAERREN = 0x20
	// Disables the DMAERR interrupt.
	USB0_ERREN_DMAERREN_0 = 0x0
	// Enables the DMAERR interrupt.
	USB0_ERREN_DMAERREN_1 = 0x1
	// Position of BTSERREN field.
	USB0_ERREN_BTSERREN_Pos = 0x7
	// Bit mask of BTSERREN field.
	USB0_ERREN_BTSERREN_Msk = 0x80
	// Bit BTSERREN.
	USB0_ERREN_BTSERREN = 0x80
	// Disables the BTSERR interrupt.
	USB0_ERREN_BTSERREN_0 = 0x0
	// Enables the BTSERR interrupt.
	USB0_ERREN_BTSERREN_1 = 0x1

	// STAT: Status register
	// Position of ODD field.
	USB0_STAT_ODD_Pos = 0x2
	// Bit mask of ODD field.
	USB0_STAT_ODD_Msk = 0x4
	// Bit ODD.
	USB0_STAT_ODD = 0x4
	// Position of TX field.
	USB0_STAT_TX_Pos = 0x3
	// Bit mask of TX field.
	USB0_STAT_TX_Msk = 0x8
	// Bit TX.
	USB0_STAT_TX = 0x8
	// The most recent transaction was a receive operation.
	USB0_STAT_TX_0 = 0x0
	// The most recent transaction was a transmit operation.
	USB0_STAT_TX_1 = 0x1
	// Position of ENDP field.
	USB0_STAT_ENDP_Pos = 0x4
	// Bit mask of ENDP field.
	USB0_STAT_ENDP_Msk = 0xf0

	// CTL: Control register
	// Position of USBENSOFEN field.
	USB0_CTL_USBENSOFEN_Pos = 0x0
	// Bit mask of USBENSOFEN field.
	USB0_CTL_USBENSOFEN_Msk = 0x1
	// Bit USBENSOFEN.
	USB0_CTL_USBENSOFEN = 0x1
	// Disables the USB Module.
	USB0_CTL_USBENSOFEN_0 = 0x0
	// Enables the USB Module.
	USB0_CTL_USBENSOFEN_1 = 0x1
	// Position of ODDRST field.
	USB0_CTL_ODDRST_Pos = 0x1
	// Bit mask of ODDRST field.
	USB0_CTL_ODDRST_Msk = 0x2
	// Bit ODDRST.
	USB0_CTL_ODDRST = 0x2
	// Position of RESUME field.
	USB0_CTL_RESUME_Pos = 0x2
	// Bit mask of RESUME field.
	USB0_CTL_RESUME_Msk = 0x4
	// Bit RESUME.
	USB0_CTL_RESUME = 0x4
	// Position of HOSTMODEEN field.
	USB0_CTL_HOSTMODEEN_Pos = 0x3
	// Bit mask of HOSTMODEEN field.
	USB0_CTL_HOSTMODEEN_Msk = 0x8
	// Bit HOSTMODEEN.
	USB0_CTL_HOSTMODEEN = 0x8
	// Position of RESET field.
	USB0_CTL_RESET_Pos = 0x4
	// Bit mask of RESET field.
	USB0_CTL_RESET_Msk = 0x10
	// Bit RESET.
	USB0_CTL_RESET = 0x10
	// Position of TXSUSPENDTOKENBUSY field.
	USB0_CTL_TXSUSPENDTOKENBUSY_Pos = 0x5
	// Bit mask of TXSUSPENDTOKENBUSY field.
	USB0_CTL_TXSUSPENDTOKENBUSY_Msk = 0x20
	// Bit TXSUSPENDTOKENBUSY.
	USB0_CTL_TXSUSPENDTOKENBUSY = 0x20
	// Position of SE0 field.
	USB0_CTL_SE0_Pos = 0x6
	// Bit mask of SE0 field.
	USB0_CTL_SE0_Msk = 0x40
	// Bit SE0.
	USB0_CTL_SE0 = 0x40
	// Position of JSTATE field.
	USB0_CTL_JSTATE_Pos = 0x7
	// Bit mask of JSTATE field.
	USB0_CTL_JSTATE_Msk = 0x80
	// Bit JSTATE.
	USB0_CTL_JSTATE = 0x80

	// ADDR: Address register
	// Position of ADDR field.
	USB0_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	USB0_ADDR_ADDR_Msk = 0x7f
	// Position of LSEN field.
	USB0_ADDR_LSEN_Pos = 0x7
	// Bit mask of LSEN field.
	USB0_ADDR_LSEN_Msk = 0x80
	// Bit LSEN.
	USB0_ADDR_LSEN = 0x80

	// BDTPAGE1: BDT Page register 1
	// Position of BDTBA field.
	USB0_BDTPAGE1_BDTBA_Pos = 0x1
	// Bit mask of BDTBA field.
	USB0_BDTPAGE1_BDTBA_Msk = 0xfe

	// FRMNUML: Frame Number register Low
	// Position of FRM field.
	USB0_FRMNUML_FRM_Pos = 0x0
	// Bit mask of FRM field.
	USB0_FRMNUML_FRM_Msk = 0xff

	// FRMNUMH: Frame Number register High
	// Position of FRM field.
	USB0_FRMNUMH_FRM_Pos = 0x0
	// Bit mask of FRM field.
	USB0_FRMNUMH_FRM_Msk = 0x7

	// TOKEN: Token register
	// Position of TOKENENDPT field.
	USB0_TOKEN_TOKENENDPT_Pos = 0x0
	// Bit mask of TOKENENDPT field.
	USB0_TOKEN_TOKENENDPT_Msk = 0xf
	// Position of TOKENPID field.
	USB0_TOKEN_TOKENPID_Pos = 0x4
	// Bit mask of TOKENPID field.
	USB0_TOKEN_TOKENPID_Msk = 0xf0
	// OUT Token. USB Module performs an OUT (TX) transaction.
	USB0_TOKEN_TOKENPID_0001 = 0x1
	// IN Token. USB Module performs an In (RX) transaction.
	USB0_TOKEN_TOKENPID_1001 = 0x9
	// SETUP Token. USB Module performs a SETUP (TX) transaction
	USB0_TOKEN_TOKENPID_1101 = 0xd

	// SOFTHLD: SOF Threshold register
	// Position of CNT field.
	USB0_SOFTHLD_CNT_Pos = 0x0
	// Bit mask of CNT field.
	USB0_SOFTHLD_CNT_Msk = 0xff

	// BDTPAGE2: BDT Page Register 2
	// Position of BDTBA field.
	USB0_BDTPAGE2_BDTBA_Pos = 0x0
	// Bit mask of BDTBA field.
	USB0_BDTPAGE2_BDTBA_Msk = 0xff

	// BDTPAGE3: BDT Page Register 3
	// Position of BDTBA field.
	USB0_BDTPAGE3_BDTBA_Pos = 0x0
	// Bit mask of BDTBA field.
	USB0_BDTPAGE3_BDTBA_Msk = 0xff

	// ENDPT0: Endpoint Control register
	// Position of EPHSHK field.
	USB0_ENDPT_EPHSHK_Pos = 0x0
	// Bit mask of EPHSHK field.
	USB0_ENDPT_EPHSHK_Msk = 0x1
	// Bit EPHSHK.
	USB0_ENDPT_EPHSHK = 0x1
	// Position of EPSTALL field.
	USB0_ENDPT_EPSTALL_Pos = 0x1
	// Bit mask of EPSTALL field.
	USB0_ENDPT_EPSTALL_Msk = 0x2
	// Bit EPSTALL.
	USB0_ENDPT_EPSTALL = 0x2
	// Position of EPTXEN field.
	USB0_ENDPT_EPTXEN_Pos = 0x2
	// Bit mask of EPTXEN field.
	USB0_ENDPT_EPTXEN_Msk = 0x4
	// Bit EPTXEN.
	USB0_ENDPT_EPTXEN = 0x4
	// Position of EPRXEN field.
	USB0_ENDPT_EPRXEN_Pos = 0x3
	// Bit mask of EPRXEN field.
	USB0_ENDPT_EPRXEN_Msk = 0x8
	// Bit EPRXEN.
	USB0_ENDPT_EPRXEN = 0x8
	// Position of EPCTLDIS field.
	USB0_ENDPT_EPCTLDIS_Pos = 0x4
	// Bit mask of EPCTLDIS field.
	USB0_ENDPT_EPCTLDIS_Msk = 0x10
	// Bit EPCTLDIS.
	USB0_ENDPT_EPCTLDIS = 0x10
	// Position of RETRYDIS field.
	USB0_ENDPT_RETRYDIS_Pos = 0x6
	// Bit mask of RETRYDIS field.
	USB0_ENDPT_RETRYDIS_Msk = 0x40
	// Bit RETRYDIS.
	USB0_ENDPT_RETRYDIS = 0x40
	// Position of HOSTWOHUB field.
	USB0_ENDPT_HOSTWOHUB_Pos = 0x7
	// Bit mask of HOSTWOHUB field.
	USB0_ENDPT_HOSTWOHUB_Msk = 0x80
	// Bit HOSTWOHUB.
	USB0_ENDPT_HOSTWOHUB = 0x80
	// Low-speed device connected to Host through a hub. PRE_PID will be generated as required.
	USB0_ENDPT_HOSTWOHUB_0 = 0x0
	// Low-speed device directly connected. No hub, or no low-speed device attached.
	USB0_ENDPT_HOSTWOHUB_1 = 0x1

	// USBCTRL: USB Control register
	// Position of PDE field.
	USB0_USBCTRL_PDE_Pos = 0x6
	// Bit mask of PDE field.
	USB0_USBCTRL_PDE_Msk = 0x40
	// Bit PDE.
	USB0_USBCTRL_PDE = 0x40
	// Weak pulldowns are disabled on D+ and D-.
	USB0_USBCTRL_PDE_0 = 0x0
	// Weak pulldowns are enabled on D+ and D-.
	USB0_USBCTRL_PDE_1 = 0x1
	// Position of SUSP field.
	USB0_USBCTRL_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	USB0_USBCTRL_SUSP_Msk = 0x80
	// Bit SUSP.
	USB0_USBCTRL_SUSP = 0x80
	// USB transceiver is not in suspend state.
	USB0_USBCTRL_SUSP_0 = 0x0
	// USB transceiver is in suspend state.
	USB0_USBCTRL_SUSP_1 = 0x1

	// OBSERVE: USB OTG Observe register
	// Position of DMPD field.
	USB0_OBSERVE_DMPD_Pos = 0x4
	// Bit mask of DMPD field.
	USB0_OBSERVE_DMPD_Msk = 0x10
	// Bit DMPD.
	USB0_OBSERVE_DMPD = 0x10
	// D- pulldown disabled.
	USB0_OBSERVE_DMPD_0 = 0x0
	// D- pulldown enabled.
	USB0_OBSERVE_DMPD_1 = 0x1
	// Position of DPPD field.
	USB0_OBSERVE_DPPD_Pos = 0x6
	// Bit mask of DPPD field.
	USB0_OBSERVE_DPPD_Msk = 0x40
	// Bit DPPD.
	USB0_OBSERVE_DPPD = 0x40
	// D+ pulldown disabled.
	USB0_OBSERVE_DPPD_0 = 0x0
	// D+ pulldown enabled.
	USB0_OBSERVE_DPPD_1 = 0x1
	// Position of DPPU field.
	USB0_OBSERVE_DPPU_Pos = 0x7
	// Bit mask of DPPU field.
	USB0_OBSERVE_DPPU_Msk = 0x80
	// Bit DPPU.
	USB0_OBSERVE_DPPU = 0x80
	// D+ pullup disabled.
	USB0_OBSERVE_DPPU_0 = 0x0
	// D+ pullup enabled.
	USB0_OBSERVE_DPPU_1 = 0x1

	// CONTROL: USB OTG Control register
	// Position of DPPULLUPNONOTG field.
	USB0_CONTROL_DPPULLUPNONOTG_Pos = 0x4
	// Bit mask of DPPULLUPNONOTG field.
	USB0_CONTROL_DPPULLUPNONOTG_Msk = 0x10
	// Bit DPPULLUPNONOTG.
	USB0_CONTROL_DPPULLUPNONOTG = 0x10
	// DP Pullup in non-OTG device mode is not enabled.
	USB0_CONTROL_DPPULLUPNONOTG_0 = 0x0
	// DP Pullup in non-OTG device mode is enabled.
	USB0_CONTROL_DPPULLUPNONOTG_1 = 0x1

	// USBTRC0: USB Transceiver Control register 0
	// Position of USB_RESUME_INT field.
	USB0_USBTRC0_USB_RESUME_INT_Pos = 0x0
	// Bit mask of USB_RESUME_INT field.
	USB0_USBTRC0_USB_RESUME_INT_Msk = 0x1
	// Bit USB_RESUME_INT.
	USB0_USBTRC0_USB_RESUME_INT = 0x1
	// No interrupt was generated.
	USB0_USBTRC0_USB_RESUME_INT_0 = 0x0
	// Interrupt was generated because of the USB asynchronous interrupt.
	USB0_USBTRC0_USB_RESUME_INT_1 = 0x1
	// Position of SYNC_DET field.
	USB0_USBTRC0_SYNC_DET_Pos = 0x1
	// Bit mask of SYNC_DET field.
	USB0_USBTRC0_SYNC_DET_Msk = 0x2
	// Bit SYNC_DET.
	USB0_USBTRC0_SYNC_DET = 0x2
	// Synchronous interrupt has not been detected.
	USB0_USBTRC0_SYNC_DET_0 = 0x0
	// Synchronous interrupt has been detected.
	USB0_USBTRC0_SYNC_DET_1 = 0x1
	// Position of USB_CLK_RECOVERY_INT field.
	USB0_USBTRC0_USB_CLK_RECOVERY_INT_Pos = 0x2
	// Bit mask of USB_CLK_RECOVERY_INT field.
	USB0_USBTRC0_USB_CLK_RECOVERY_INT_Msk = 0x4
	// Bit USB_CLK_RECOVERY_INT.
	USB0_USBTRC0_USB_CLK_RECOVERY_INT = 0x4
	// Position of USBRESMEN field.
	USB0_USBTRC0_USBRESMEN_Pos = 0x5
	// Bit mask of USBRESMEN field.
	USB0_USBTRC0_USBRESMEN_Msk = 0x20
	// Bit USBRESMEN.
	USB0_USBTRC0_USBRESMEN = 0x20
	// USB asynchronous wakeup from suspend mode disabled.
	USB0_USBTRC0_USBRESMEN_0 = 0x0
	// USB asynchronous wakeup from suspend mode enabled. The asynchronous resume interrupt differs from the synchronous resume interrupt in that it asynchronously detects K-state using the unfiltered state of the D+ and D- pins. This interrupt should only be enabled when the Transceiver is suspended.
	USB0_USBTRC0_USBRESMEN_1 = 0x1
	// Position of USBRESET field.
	USB0_USBTRC0_USBRESET_Pos = 0x7
	// Bit mask of USBRESET field.
	USB0_USBTRC0_USBRESET_Msk = 0x80
	// Bit USBRESET.
	USB0_USBTRC0_USBRESET = 0x80
	// Normal USB module operation.
	USB0_USBTRC0_USBRESET_0 = 0x0
	// Returns the USB module to its reset state.
	USB0_USBTRC0_USBRESET_1 = 0x1

	// USBFRMADJUST: Frame Adjust Register
	// Position of ADJ field.
	USB0_USBFRMADJUST_ADJ_Pos = 0x0
	// Bit mask of ADJ field.
	USB0_USBFRMADJUST_ADJ_Msk = 0xff

	// CLK_RECOVER_CTRL: USB Clock recovery control
	// Position of RESTART_IFRTRIM_EN field.
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_Pos = 0x5
	// Bit mask of RESTART_IFRTRIM_EN field.
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_Msk = 0x20
	// Bit RESTART_IFRTRIM_EN.
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN = 0x20
	// Trim fine adjustment always works based on the previous updated trim fine value (default)
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_0 = 0x0
	// Trim fine restarts from the IFR trim value whenever bus_reset/bus_resume is detected or module enable is desasserted
	USB0_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_1 = 0x1
	// Position of RESET_RESUME_ROUGH_EN field.
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_Pos = 0x6
	// Bit mask of RESET_RESUME_ROUGH_EN field.
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_Msk = 0x40
	// Bit RESET_RESUME_ROUGH_EN.
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN = 0x40
	// Always works in tracking phase after the 1st time rough to track transition (default)
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_0 = 0x0
	// Go back to rough stage whenever bus reset or bus resume occurs
	USB0_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_1 = 0x1
	// Position of CLOCK_RECOVER_EN field.
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_Pos = 0x7
	// Bit mask of CLOCK_RECOVER_EN field.
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_Msk = 0x80
	// Bit CLOCK_RECOVER_EN.
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN = 0x80
	// Disable clock recovery block (default)
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_0 = 0x0
	// Enable clock recovery block
	USB0_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_1 = 0x1

	// CLK_RECOVER_IRC_EN: IRC48M oscillator enable register
	// Position of REG_EN field.
	USB0_CLK_RECOVER_IRC_EN_REG_EN_Pos = 0x0
	// Bit mask of REG_EN field.
	USB0_CLK_RECOVER_IRC_EN_REG_EN_Msk = 0x1
	// Bit REG_EN.
	USB0_CLK_RECOVER_IRC_EN_REG_EN = 0x1
	// IRC48M local regulator is disabled
	USB0_CLK_RECOVER_IRC_EN_REG_EN_0 = 0x0
	// IRC48M local regulator is enabled (default)
	USB0_CLK_RECOVER_IRC_EN_REG_EN_1 = 0x1
	// Position of IRC_EN field.
	USB0_CLK_RECOVER_IRC_EN_IRC_EN_Pos = 0x1
	// Bit mask of IRC_EN field.
	USB0_CLK_RECOVER_IRC_EN_IRC_EN_Msk = 0x2
	// Bit IRC_EN.
	USB0_CLK_RECOVER_IRC_EN_IRC_EN = 0x2
	// Disable the IRC48M module (default)
	USB0_CLK_RECOVER_IRC_EN_IRC_EN_0 = 0x0
	// Enable the IRC48M module
	USB0_CLK_RECOVER_IRC_EN_IRC_EN_1 = 0x1

	// CLK_RECOVER_INT_EN: Clock recovery combined interrupt enable
	// Position of OVF_ERROR_EN field.
	USB0_CLK_RECOVER_INT_EN_OVF_ERROR_EN_Pos = 0x4
	// Bit mask of OVF_ERROR_EN field.
	USB0_CLK_RECOVER_INT_EN_OVF_ERROR_EN_Msk = 0x10
	// Bit OVF_ERROR_EN.
	USB0_CLK_RECOVER_INT_EN_OVF_ERROR_EN = 0x10
	// The interrupt will be masked
	USB0_CLK_RECOVER_INT_EN_OVF_ERROR_EN_0 = 0x0
	// The interrupt will be enabled (default)
	USB0_CLK_RECOVER_INT_EN_OVF_ERROR_EN_1 = 0x1

	// CLK_RECOVER_INT_STATUS: Clock recovery separated interrupt status
	// Position of OVF_ERROR field.
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_Pos = 0x4
	// Bit mask of OVF_ERROR field.
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_Msk = 0x10
	// Bit OVF_ERROR.
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR = 0x10
	// No interrupt is reported
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_0 = 0x0
	// Unmasked interrupt has been generated
	USB0_CLK_RECOVER_INT_STATUS_OVF_ERROR_1 = 0x1
)

// Constants for CMP0: High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
const (
	// CR0: CMP Control Register 0
	// Position of HYSTCTR field.
	CMP_CR0_HYSTCTR_Pos = 0x0
	// Bit mask of HYSTCTR field.
	CMP_CR0_HYSTCTR_Msk = 0x3
	// Level 0
	CMP_CR0_HYSTCTR_00 = 0x0
	// Level 1
	CMP_CR0_HYSTCTR_01 = 0x1
	// Level 2
	CMP_CR0_HYSTCTR_10 = 0x2
	// Level 3
	CMP_CR0_HYSTCTR_11 = 0x3
	// Position of FILTER_CNT field.
	CMP_CR0_FILTER_CNT_Pos = 0x4
	// Bit mask of FILTER_CNT field.
	CMP_CR0_FILTER_CNT_Msk = 0x70
	// Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a legal state, and is not recommended. If SE = 0, COUT = COUTA.
	CMP_CR0_FILTER_CNT_000 = 0x0
	// One sample must agree. The comparator output is simply sampled.
	CMP_CR0_FILTER_CNT_001 = 0x1
	// 2 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_010 = 0x2
	// 3 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_011 = 0x3
	// 4 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_100 = 0x4
	// 5 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_101 = 0x5
	// 6 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_110 = 0x6
	// 7 consecutive samples must agree.
	CMP_CR0_FILTER_CNT_111 = 0x7

	// CR1: CMP Control Register 1
	// Position of EN field.
	CMP_CR1_EN_Pos = 0x0
	// Bit mask of EN field.
	CMP_CR1_EN_Msk = 0x1
	// Bit EN.
	CMP_CR1_EN = 0x1
	// Analog Comparator is disabled.
	CMP_CR1_EN_0 = 0x0
	// Analog Comparator is enabled.
	CMP_CR1_EN_1 = 0x1
	// Position of OPE field.
	CMP_CR1_OPE_Pos = 0x1
	// Bit mask of OPE field.
	CMP_CR1_OPE_Msk = 0x2
	// Bit OPE.
	CMP_CR1_OPE = 0x2
	// CMPO is not available on the associated CMPO output pin. If the comparator does not own the pin, this field has no effect.
	CMP_CR1_OPE_0 = 0x0
	// CMPO is available on the associated CMPO output pin. The comparator output (CMPO) is driven out on the associated CMPO output pin if the comparator owns the pin. If the comparator does not own the field, this bit has no effect.
	CMP_CR1_OPE_1 = 0x1
	// Position of COS field.
	CMP_CR1_COS_Pos = 0x2
	// Bit mask of COS field.
	CMP_CR1_COS_Msk = 0x4
	// Bit COS.
	CMP_CR1_COS = 0x4
	// Set the filtered comparator output (CMPO) to equal COUT.
	CMP_CR1_COS_0 = 0x0
	// Set the unfiltered comparator output (CMPO) to equal COUTA.
	CMP_CR1_COS_1 = 0x1
	// Position of INV field.
	CMP_CR1_INV_Pos = 0x3
	// Bit mask of INV field.
	CMP_CR1_INV_Msk = 0x8
	// Bit INV.
	CMP_CR1_INV = 0x8
	// Does not invert the comparator output.
	CMP_CR1_INV_0 = 0x0
	// Inverts the comparator output.
	CMP_CR1_INV_1 = 0x1
	// Position of PMODE field.
	CMP_CR1_PMODE_Pos = 0x4
	// Bit mask of PMODE field.
	CMP_CR1_PMODE_Msk = 0x10
	// Bit PMODE.
	CMP_CR1_PMODE = 0x10
	// Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower output propagation delay and lower current consumption.
	CMP_CR1_PMODE_0 = 0x0
	// High-Speed (HS) Comparison mode selected. In this mode, CMP has faster output propagation delay and higher current consumption.
	CMP_CR1_PMODE_1 = 0x1
	// Position of TRIGM field.
	CMP_CR1_TRIGM_Pos = 0x5
	// Bit mask of TRIGM field.
	CMP_CR1_TRIGM_Msk = 0x20
	// Bit TRIGM.
	CMP_CR1_TRIGM = 0x20
	// Trigger mode is disabled.
	CMP_CR1_TRIGM_0 = 0x0
	// Trigger mode is enabled.
	CMP_CR1_TRIGM_1 = 0x1
	// Position of WE field.
	CMP_CR1_WE_Pos = 0x6
	// Bit mask of WE field.
	CMP_CR1_WE_Msk = 0x40
	// Bit WE.
	CMP_CR1_WE = 0x40
	// Windowing mode is not selected.
	CMP_CR1_WE_0 = 0x0
	// Windowing mode is selected.
	CMP_CR1_WE_1 = 0x1
	// Position of SE field.
	CMP_CR1_SE_Pos = 0x7
	// Bit mask of SE field.
	CMP_CR1_SE_Msk = 0x80
	// Bit SE.
	CMP_CR1_SE = 0x80
	// Sampling mode is not selected.
	CMP_CR1_SE_0 = 0x0
	// Sampling mode is selected.
	CMP_CR1_SE_1 = 0x1

	// FPR: CMP Filter Period Register
	// Position of FILT_PER field.
	CMP_FPR_FILT_PER_Pos = 0x0
	// Bit mask of FILT_PER field.
	CMP_FPR_FILT_PER_Msk = 0xff

	// SCR: CMP Status and Control Register
	// Position of COUT field.
	CMP_SCR_COUT_Pos = 0x0
	// Bit mask of COUT field.
	CMP_SCR_COUT_Msk = 0x1
	// Bit COUT.
	CMP_SCR_COUT = 0x1
	// Position of CFF field.
	CMP_SCR_CFF_Pos = 0x1
	// Bit mask of CFF field.
	CMP_SCR_CFF_Msk = 0x2
	// Bit CFF.
	CMP_SCR_CFF = 0x2
	// Falling-edge on COUT has not been detected.
	CMP_SCR_CFF_0 = 0x0
	// Falling-edge on COUT has occurred.
	CMP_SCR_CFF_1 = 0x1
	// Position of CFR field.
	CMP_SCR_CFR_Pos = 0x2
	// Bit mask of CFR field.
	CMP_SCR_CFR_Msk = 0x4
	// Bit CFR.
	CMP_SCR_CFR = 0x4
	// Rising-edge on COUT has not been detected.
	CMP_SCR_CFR_0 = 0x0
	// Rising-edge on COUT has occurred.
	CMP_SCR_CFR_1 = 0x1
	// Position of IEF field.
	CMP_SCR_IEF_Pos = 0x3
	// Bit mask of IEF field.
	CMP_SCR_IEF_Msk = 0x8
	// Bit IEF.
	CMP_SCR_IEF = 0x8
	// Interrupt is disabled.
	CMP_SCR_IEF_0 = 0x0
	// Interrupt is enabled.
	CMP_SCR_IEF_1 = 0x1
	// Position of IER field.
	CMP_SCR_IER_Pos = 0x4
	// Bit mask of IER field.
	CMP_SCR_IER_Msk = 0x10
	// Bit IER.
	CMP_SCR_IER = 0x10
	// Interrupt is disabled.
	CMP_SCR_IER_0 = 0x0
	// Interrupt is enabled.
	CMP_SCR_IER_1 = 0x1
	// Position of DMAEN field.
	CMP_SCR_DMAEN_Pos = 0x6
	// Bit mask of DMAEN field.
	CMP_SCR_DMAEN_Msk = 0x40
	// Bit DMAEN.
	CMP_SCR_DMAEN = 0x40
	// DMA is disabled.
	CMP_SCR_DMAEN_0 = 0x0
	// DMA is enabled.
	CMP_SCR_DMAEN_1 = 0x1

	// DACCR: DAC Control Register
	// Position of VOSEL field.
	CMP_DACCR_VOSEL_Pos = 0x0
	// Bit mask of VOSEL field.
	CMP_DACCR_VOSEL_Msk = 0x3f
	// Position of VRSEL field.
	CMP_DACCR_VRSEL_Pos = 0x6
	// Bit mask of VRSEL field.
	CMP_DACCR_VRSEL_Msk = 0x40
	// Bit VRSEL.
	CMP_DACCR_VRSEL = 0x40
	// Vin1 is selected as resistor ladder network supply reference.
	CMP_DACCR_VRSEL_0 = 0x0
	// Vin2 is selected as resistor ladder network supply reference.
	CMP_DACCR_VRSEL_1 = 0x1
	// Position of DACEN field.
	CMP_DACCR_DACEN_Pos = 0x7
	// Bit mask of DACEN field.
	CMP_DACCR_DACEN_Msk = 0x80
	// Bit DACEN.
	CMP_DACCR_DACEN = 0x80
	// DAC is disabled.
	CMP_DACCR_DACEN_0 = 0x0
	// DAC is enabled.
	CMP_DACCR_DACEN_1 = 0x1

	// MUXCR: MUX Control Register
	// Position of MSEL field.
	CMP_MUXCR_MSEL_Pos = 0x0
	// Bit mask of MSEL field.
	CMP_MUXCR_MSEL_Msk = 0x7
	// IN0
	CMP_MUXCR_MSEL_000 = 0x0
	// IN1
	CMP_MUXCR_MSEL_001 = 0x1
	// IN2
	CMP_MUXCR_MSEL_010 = 0x2
	// IN3
	CMP_MUXCR_MSEL_011 = 0x3
	// IN4
	CMP_MUXCR_MSEL_100 = 0x4
	// IN5
	CMP_MUXCR_MSEL_101 = 0x5
	// IN6
	CMP_MUXCR_MSEL_110 = 0x6
	// IN7
	CMP_MUXCR_MSEL_111 = 0x7
	// Position of PSEL field.
	CMP_MUXCR_PSEL_Pos = 0x3
	// Bit mask of PSEL field.
	CMP_MUXCR_PSEL_Msk = 0x38
	// IN0
	CMP_MUXCR_PSEL_000 = 0x0
	// IN1
	CMP_MUXCR_PSEL_001 = 0x1
	// IN2
	CMP_MUXCR_PSEL_010 = 0x2
	// IN3
	CMP_MUXCR_PSEL_011 = 0x3
	// IN4
	CMP_MUXCR_PSEL_100 = 0x4
	// IN5
	CMP_MUXCR_PSEL_101 = 0x5
	// IN6
	CMP_MUXCR_PSEL_110 = 0x6
	// IN7
	CMP_MUXCR_PSEL_111 = 0x7
	// Position of PSTM field.
	CMP_MUXCR_PSTM_Pos = 0x7
	// Bit mask of PSTM field.
	CMP_MUXCR_PSTM_Msk = 0x80
	// Bit PSTM.
	CMP_MUXCR_PSTM = 0x80
	// Pass Through Mode is disabled.
	CMP_MUXCR_PSTM_0 = 0x0
	// Pass Through Mode is enabled.
	CMP_MUXCR_PSTM_1 = 0x1
)

// Constants for VREF: Voltage Reference
const (
	// TRM: VREF Trim Register
	// Position of TRIM field.
	VREF_TRM_TRIM_Pos = 0x0
	// Bit mask of TRIM field.
	VREF_TRM_TRIM_Msk = 0x3f
	// Min
	VREF_TRM_TRIM_000000 = 0x0
	// Max
	VREF_TRM_TRIM_111111 = 0x3f
	// Position of CHOPEN field.
	VREF_TRM_CHOPEN_Pos = 0x6
	// Bit mask of CHOPEN field.
	VREF_TRM_CHOPEN_Msk = 0x40
	// Bit CHOPEN.
	VREF_TRM_CHOPEN = 0x40
	// Chop oscillator is disabled.
	VREF_TRM_CHOPEN_0 = 0x0
	// Chop oscillator is enabled.
	VREF_TRM_CHOPEN_1 = 0x1

	// SC: VREF Status and Control Register
	// Position of MODE_LV field.
	VREF_SC_MODE_LV_Pos = 0x0
	// Bit mask of MODE_LV field.
	VREF_SC_MODE_LV_Msk = 0x3
	// Bandgap on only, for stabilization and startup
	VREF_SC_MODE_LV_00 = 0x0
	// High power buffer mode enabled
	VREF_SC_MODE_LV_01 = 0x1
	// Low-power buffer mode enabled
	VREF_SC_MODE_LV_10 = 0x2
	// Position of VREFST field.
	VREF_SC_VREFST_Pos = 0x2
	// Bit mask of VREFST field.
	VREF_SC_VREFST_Msk = 0x4
	// Bit VREFST.
	VREF_SC_VREFST = 0x4
	// The module is disabled or not stable.
	VREF_SC_VREFST_0 = 0x0
	// The module is stable.
	VREF_SC_VREFST_1 = 0x1
	// Position of ICOMPEN field.
	VREF_SC_ICOMPEN_Pos = 0x5
	// Bit mask of ICOMPEN field.
	VREF_SC_ICOMPEN_Msk = 0x20
	// Bit ICOMPEN.
	VREF_SC_ICOMPEN = 0x20
	// Disabled
	VREF_SC_ICOMPEN_0 = 0x0
	// Enabled
	VREF_SC_ICOMPEN_1 = 0x1
	// Position of REGEN field.
	VREF_SC_REGEN_Pos = 0x6
	// Bit mask of REGEN field.
	VREF_SC_REGEN_Msk = 0x40
	// Bit REGEN.
	VREF_SC_REGEN = 0x40
	// Internal 1.75 V regulator is disabled.
	VREF_SC_REGEN_0 = 0x0
	// Internal 1.75 V regulator is enabled.
	VREF_SC_REGEN_1 = 0x1
	// Position of VREFEN field.
	VREF_SC_VREFEN_Pos = 0x7
	// Bit mask of VREFEN field.
	VREF_SC_VREFEN_Msk = 0x80
	// Bit VREFEN.
	VREF_SC_VREFEN = 0x80
	// The module is disabled.
	VREF_SC_VREFEN_0 = 0x0
	// The module is enabled.
	VREF_SC_VREFEN_1 = 0x1
)

// Constants for LLWU: Low leakage wakeup unit
const (
	// PE1: LLWU Pin Enable 1 register
	// Position of WUPE0 field.
	LLWU_PE1_WUPE0_Pos = 0x0
	// Bit mask of WUPE0 field.
	LLWU_PE1_WUPE0_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE1_WUPE0_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE1_WUPE0_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE1_WUPE0_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE1_WUPE0_11 = 0x3
	// Position of WUPE1 field.
	LLWU_PE1_WUPE1_Pos = 0x2
	// Bit mask of WUPE1 field.
	LLWU_PE1_WUPE1_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE1_WUPE1_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE1_WUPE1_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE1_WUPE1_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE1_WUPE1_11 = 0x3
	// Position of WUPE2 field.
	LLWU_PE1_WUPE2_Pos = 0x4
	// Bit mask of WUPE2 field.
	LLWU_PE1_WUPE2_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE1_WUPE2_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE1_WUPE2_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE1_WUPE2_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE1_WUPE2_11 = 0x3
	// Position of WUPE3 field.
	LLWU_PE1_WUPE3_Pos = 0x6
	// Bit mask of WUPE3 field.
	LLWU_PE1_WUPE3_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE1_WUPE3_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE1_WUPE3_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE1_WUPE3_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE1_WUPE3_11 = 0x3

	// PE2: LLWU Pin Enable 2 register
	// Position of WUPE4 field.
	LLWU_PE2_WUPE4_Pos = 0x0
	// Bit mask of WUPE4 field.
	LLWU_PE2_WUPE4_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE2_WUPE4_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE2_WUPE4_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE2_WUPE4_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE2_WUPE4_11 = 0x3
	// Position of WUPE5 field.
	LLWU_PE2_WUPE5_Pos = 0x2
	// Bit mask of WUPE5 field.
	LLWU_PE2_WUPE5_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE2_WUPE5_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE2_WUPE5_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE2_WUPE5_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE2_WUPE5_11 = 0x3
	// Position of WUPE6 field.
	LLWU_PE2_WUPE6_Pos = 0x4
	// Bit mask of WUPE6 field.
	LLWU_PE2_WUPE6_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE2_WUPE6_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE2_WUPE6_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE2_WUPE6_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE2_WUPE6_11 = 0x3
	// Position of WUPE7 field.
	LLWU_PE2_WUPE7_Pos = 0x6
	// Bit mask of WUPE7 field.
	LLWU_PE2_WUPE7_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE2_WUPE7_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE2_WUPE7_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE2_WUPE7_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE2_WUPE7_11 = 0x3

	// PE3: LLWU Pin Enable 3 register
	// Position of WUPE8 field.
	LLWU_PE3_WUPE8_Pos = 0x0
	// Bit mask of WUPE8 field.
	LLWU_PE3_WUPE8_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE3_WUPE8_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE3_WUPE8_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE3_WUPE8_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE3_WUPE8_11 = 0x3
	// Position of WUPE9 field.
	LLWU_PE3_WUPE9_Pos = 0x2
	// Bit mask of WUPE9 field.
	LLWU_PE3_WUPE9_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE3_WUPE9_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE3_WUPE9_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE3_WUPE9_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE3_WUPE9_11 = 0x3
	// Position of WUPE10 field.
	LLWU_PE3_WUPE10_Pos = 0x4
	// Bit mask of WUPE10 field.
	LLWU_PE3_WUPE10_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE3_WUPE10_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE3_WUPE10_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE3_WUPE10_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE3_WUPE10_11 = 0x3
	// Position of WUPE11 field.
	LLWU_PE3_WUPE11_Pos = 0x6
	// Bit mask of WUPE11 field.
	LLWU_PE3_WUPE11_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE3_WUPE11_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE3_WUPE11_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE3_WUPE11_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE3_WUPE11_11 = 0x3

	// PE4: LLWU Pin Enable 4 register
	// Position of WUPE12 field.
	LLWU_PE4_WUPE12_Pos = 0x0
	// Bit mask of WUPE12 field.
	LLWU_PE4_WUPE12_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE4_WUPE12_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE4_WUPE12_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE4_WUPE12_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE4_WUPE12_11 = 0x3
	// Position of WUPE13 field.
	LLWU_PE4_WUPE13_Pos = 0x2
	// Bit mask of WUPE13 field.
	LLWU_PE4_WUPE13_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE4_WUPE13_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE4_WUPE13_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE4_WUPE13_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE4_WUPE13_11 = 0x3
	// Position of WUPE14 field.
	LLWU_PE4_WUPE14_Pos = 0x4
	// Bit mask of WUPE14 field.
	LLWU_PE4_WUPE14_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE4_WUPE14_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE4_WUPE14_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE4_WUPE14_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE4_WUPE14_11 = 0x3
	// Position of WUPE15 field.
	LLWU_PE4_WUPE15_Pos = 0x6
	// Bit mask of WUPE15 field.
	LLWU_PE4_WUPE15_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE4_WUPE15_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE4_WUPE15_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE4_WUPE15_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE4_WUPE15_11 = 0x3

	// PE5: LLWU Pin Enable 5 register
	// Position of WUPE16 field.
	LLWU_PE5_WUPE16_Pos = 0x0
	// Bit mask of WUPE16 field.
	LLWU_PE5_WUPE16_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE5_WUPE16_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE5_WUPE16_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE5_WUPE16_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE5_WUPE16_11 = 0x3
	// Position of WUPE17 field.
	LLWU_PE5_WUPE17_Pos = 0x2
	// Bit mask of WUPE17 field.
	LLWU_PE5_WUPE17_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE5_WUPE17_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE5_WUPE17_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE5_WUPE17_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE5_WUPE17_11 = 0x3
	// Position of WUPE18 field.
	LLWU_PE5_WUPE18_Pos = 0x4
	// Bit mask of WUPE18 field.
	LLWU_PE5_WUPE18_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE5_WUPE18_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE5_WUPE18_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE5_WUPE18_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE5_WUPE18_11 = 0x3
	// Position of WUPE19 field.
	LLWU_PE5_WUPE19_Pos = 0x6
	// Bit mask of WUPE19 field.
	LLWU_PE5_WUPE19_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE5_WUPE19_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE5_WUPE19_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE5_WUPE19_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE5_WUPE19_11 = 0x3

	// PE6: LLWU Pin Enable 6 register
	// Position of WUPE20 field.
	LLWU_PE6_WUPE20_Pos = 0x0
	// Bit mask of WUPE20 field.
	LLWU_PE6_WUPE20_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE6_WUPE20_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE6_WUPE20_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE6_WUPE20_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE6_WUPE20_11 = 0x3
	// Position of WUPE21 field.
	LLWU_PE6_WUPE21_Pos = 0x2
	// Bit mask of WUPE21 field.
	LLWU_PE6_WUPE21_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE6_WUPE21_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE6_WUPE21_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE6_WUPE21_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE6_WUPE21_11 = 0x3
	// Position of WUPE22 field.
	LLWU_PE6_WUPE22_Pos = 0x4
	// Bit mask of WUPE22 field.
	LLWU_PE6_WUPE22_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE6_WUPE22_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE6_WUPE22_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE6_WUPE22_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE6_WUPE22_11 = 0x3
	// Position of WUPE23 field.
	LLWU_PE6_WUPE23_Pos = 0x6
	// Bit mask of WUPE23 field.
	LLWU_PE6_WUPE23_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE6_WUPE23_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE6_WUPE23_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE6_WUPE23_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE6_WUPE23_11 = 0x3

	// PE7: LLWU Pin Enable 7 register
	// Position of WUPE24 field.
	LLWU_PE7_WUPE24_Pos = 0x0
	// Bit mask of WUPE24 field.
	LLWU_PE7_WUPE24_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE7_WUPE24_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE7_WUPE24_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE7_WUPE24_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE7_WUPE24_11 = 0x3
	// Position of WUPE25 field.
	LLWU_PE7_WUPE25_Pos = 0x2
	// Bit mask of WUPE25 field.
	LLWU_PE7_WUPE25_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE7_WUPE25_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE7_WUPE25_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE7_WUPE25_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE7_WUPE25_11 = 0x3
	// Position of WUPE26 field.
	LLWU_PE7_WUPE26_Pos = 0x4
	// Bit mask of WUPE26 field.
	LLWU_PE7_WUPE26_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE7_WUPE26_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE7_WUPE26_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE7_WUPE26_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE7_WUPE26_11 = 0x3
	// Position of WUPE27 field.
	LLWU_PE7_WUPE27_Pos = 0x6
	// Bit mask of WUPE27 field.
	LLWU_PE7_WUPE27_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE7_WUPE27_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE7_WUPE27_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE7_WUPE27_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE7_WUPE27_11 = 0x3

	// PE8: LLWU Pin Enable 8 register
	// Position of WUPE28 field.
	LLWU_PE8_WUPE28_Pos = 0x0
	// Bit mask of WUPE28 field.
	LLWU_PE8_WUPE28_Msk = 0x3
	// External input pin disabled as wakeup input
	LLWU_PE8_WUPE28_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE8_WUPE28_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE8_WUPE28_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE8_WUPE28_11 = 0x3
	// Position of WUPE29 field.
	LLWU_PE8_WUPE29_Pos = 0x2
	// Bit mask of WUPE29 field.
	LLWU_PE8_WUPE29_Msk = 0xc
	// External input pin disabled as wakeup input
	LLWU_PE8_WUPE29_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE8_WUPE29_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE8_WUPE29_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE8_WUPE29_11 = 0x3
	// Position of WUPE30 field.
	LLWU_PE8_WUPE30_Pos = 0x4
	// Bit mask of WUPE30 field.
	LLWU_PE8_WUPE30_Msk = 0x30
	// External input pin disabled as wakeup input
	LLWU_PE8_WUPE30_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE8_WUPE30_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE8_WUPE30_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE8_WUPE30_11 = 0x3
	// Position of WUPE31 field.
	LLWU_PE8_WUPE31_Pos = 0x6
	// Bit mask of WUPE31 field.
	LLWU_PE8_WUPE31_Msk = 0xc0
	// External input pin disabled as wakeup input
	LLWU_PE8_WUPE31_00 = 0x0
	// External input pin enabled with rising edge detection
	LLWU_PE8_WUPE31_01 = 0x1
	// External input pin enabled with falling edge detection
	LLWU_PE8_WUPE31_10 = 0x2
	// External input pin enabled with any change detection
	LLWU_PE8_WUPE31_11 = 0x3

	// ME: LLWU Module Enable register
	// Position of WUME0 field.
	LLWU_ME_WUME0_Pos = 0x0
	// Bit mask of WUME0 field.
	LLWU_ME_WUME0_Msk = 0x1
	// Bit WUME0.
	LLWU_ME_WUME0 = 0x1
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME0_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME0_1 = 0x1
	// Position of WUME1 field.
	LLWU_ME_WUME1_Pos = 0x1
	// Bit mask of WUME1 field.
	LLWU_ME_WUME1_Msk = 0x2
	// Bit WUME1.
	LLWU_ME_WUME1 = 0x2
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME1_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME1_1 = 0x1
	// Position of WUME2 field.
	LLWU_ME_WUME2_Pos = 0x2
	// Bit mask of WUME2 field.
	LLWU_ME_WUME2_Msk = 0x4
	// Bit WUME2.
	LLWU_ME_WUME2 = 0x4
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME2_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME2_1 = 0x1
	// Position of WUME3 field.
	LLWU_ME_WUME3_Pos = 0x3
	// Bit mask of WUME3 field.
	LLWU_ME_WUME3_Msk = 0x8
	// Bit WUME3.
	LLWU_ME_WUME3 = 0x8
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME3_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME3_1 = 0x1
	// Position of WUME4 field.
	LLWU_ME_WUME4_Pos = 0x4
	// Bit mask of WUME4 field.
	LLWU_ME_WUME4_Msk = 0x10
	// Bit WUME4.
	LLWU_ME_WUME4 = 0x10
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME4_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME4_1 = 0x1
	// Position of WUME5 field.
	LLWU_ME_WUME5_Pos = 0x5
	// Bit mask of WUME5 field.
	LLWU_ME_WUME5_Msk = 0x20
	// Bit WUME5.
	LLWU_ME_WUME5 = 0x20
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME5_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME5_1 = 0x1
	// Position of WUME6 field.
	LLWU_ME_WUME6_Pos = 0x6
	// Bit mask of WUME6 field.
	LLWU_ME_WUME6_Msk = 0x40
	// Bit WUME6.
	LLWU_ME_WUME6 = 0x40
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME6_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME6_1 = 0x1
	// Position of WUME7 field.
	LLWU_ME_WUME7_Pos = 0x7
	// Bit mask of WUME7 field.
	LLWU_ME_WUME7_Msk = 0x80
	// Bit WUME7.
	LLWU_ME_WUME7 = 0x80
	// Internal module flag not used as wakeup source
	LLWU_ME_WUME7_0 = 0x0
	// Internal module flag used as wakeup source
	LLWU_ME_WUME7_1 = 0x1

	// PF1: LLWU Pin Flag 1 register
	// Position of WUF0 field.
	LLWU_PF1_WUF0_Pos = 0x0
	// Bit mask of WUF0 field.
	LLWU_PF1_WUF0_Msk = 0x1
	// Bit WUF0.
	LLWU_PF1_WUF0 = 0x1
	// LLWU_P0 input was not a wakeup source
	LLWU_PF1_WUF0_0 = 0x0
	// LLWU_P0 input was a wakeup source
	LLWU_PF1_WUF0_1 = 0x1
	// Position of WUF1 field.
	LLWU_PF1_WUF1_Pos = 0x1
	// Bit mask of WUF1 field.
	LLWU_PF1_WUF1_Msk = 0x2
	// Bit WUF1.
	LLWU_PF1_WUF1 = 0x2
	// LLWU_P1 input was not a wakeup source
	LLWU_PF1_WUF1_0 = 0x0
	// LLWU_P1 input was a wakeup source
	LLWU_PF1_WUF1_1 = 0x1
	// Position of WUF2 field.
	LLWU_PF1_WUF2_Pos = 0x2
	// Bit mask of WUF2 field.
	LLWU_PF1_WUF2_Msk = 0x4
	// Bit WUF2.
	LLWU_PF1_WUF2 = 0x4
	// LLWU_P2 input was not a wakeup source
	LLWU_PF1_WUF2_0 = 0x0
	// LLWU_P2 input was a wakeup source
	LLWU_PF1_WUF2_1 = 0x1
	// Position of WUF3 field.
	LLWU_PF1_WUF3_Pos = 0x3
	// Bit mask of WUF3 field.
	LLWU_PF1_WUF3_Msk = 0x8
	// Bit WUF3.
	LLWU_PF1_WUF3 = 0x8
	// LLWU_P3 input was not a wakeup source
	LLWU_PF1_WUF3_0 = 0x0
	// LLWU_P3 input was a wakeup source
	LLWU_PF1_WUF3_1 = 0x1
	// Position of WUF4 field.
	LLWU_PF1_WUF4_Pos = 0x4
	// Bit mask of WUF4 field.
	LLWU_PF1_WUF4_Msk = 0x10
	// Bit WUF4.
	LLWU_PF1_WUF4 = 0x10
	// LLWU_P4 input was not a wakeup source
	LLWU_PF1_WUF4_0 = 0x0
	// LLWU_P4 input was a wakeup source
	LLWU_PF1_WUF4_1 = 0x1
	// Position of WUF5 field.
	LLWU_PF1_WUF5_Pos = 0x5
	// Bit mask of WUF5 field.
	LLWU_PF1_WUF5_Msk = 0x20
	// Bit WUF5.
	LLWU_PF1_WUF5 = 0x20
	// LLWU_P5 input was not a wakeup source
	LLWU_PF1_WUF5_0 = 0x0
	// LLWU_P5 input was a wakeup source
	LLWU_PF1_WUF5_1 = 0x1
	// Position of WUF6 field.
	LLWU_PF1_WUF6_Pos = 0x6
	// Bit mask of WUF6 field.
	LLWU_PF1_WUF6_Msk = 0x40
	// Bit WUF6.
	LLWU_PF1_WUF6 = 0x40
	// LLWU_P6 input was not a wakeup source
	LLWU_PF1_WUF6_0 = 0x0
	// LLWU_P6 input was a wakeup source
	LLWU_PF1_WUF6_1 = 0x1
	// Position of WUF7 field.
	LLWU_PF1_WUF7_Pos = 0x7
	// Bit mask of WUF7 field.
	LLWU_PF1_WUF7_Msk = 0x80
	// Bit WUF7.
	LLWU_PF1_WUF7 = 0x80
	// LLWU_P7 input was not a wakeup source
	LLWU_PF1_WUF7_0 = 0x0
	// LLWU_P7 input was a wakeup source
	LLWU_PF1_WUF7_1 = 0x1

	// PF2: LLWU Pin Flag 2 register
	// Position of WUF8 field.
	LLWU_PF2_WUF8_Pos = 0x0
	// Bit mask of WUF8 field.
	LLWU_PF2_WUF8_Msk = 0x1
	// Bit WUF8.
	LLWU_PF2_WUF8 = 0x1
	// LLWU_P8 input was not a wakeup source
	LLWU_PF2_WUF8_0 = 0x0
	// LLWU_P8 input was a wakeup source
	LLWU_PF2_WUF8_1 = 0x1
	// Position of WUF9 field.
	LLWU_PF2_WUF9_Pos = 0x1
	// Bit mask of WUF9 field.
	LLWU_PF2_WUF9_Msk = 0x2
	// Bit WUF9.
	LLWU_PF2_WUF9 = 0x2
	// LLWU_P9 input was not a wakeup source
	LLWU_PF2_WUF9_0 = 0x0
	// LLWU_P9 input was a wakeup source
	LLWU_PF2_WUF9_1 = 0x1
	// Position of WUF10 field.
	LLWU_PF2_WUF10_Pos = 0x2
	// Bit mask of WUF10 field.
	LLWU_PF2_WUF10_Msk = 0x4
	// Bit WUF10.
	LLWU_PF2_WUF10 = 0x4
	// LLWU_P10 input was not a wakeup source
	LLWU_PF2_WUF10_0 = 0x0
	// LLWU_P10 input was a wakeup source
	LLWU_PF2_WUF10_1 = 0x1
	// Position of WUF11 field.
	LLWU_PF2_WUF11_Pos = 0x3
	// Bit mask of WUF11 field.
	LLWU_PF2_WUF11_Msk = 0x8
	// Bit WUF11.
	LLWU_PF2_WUF11 = 0x8
	// LLWU_P11 input was not a wakeup source
	LLWU_PF2_WUF11_0 = 0x0
	// LLWU_P11 input was a wakeup source
	LLWU_PF2_WUF11_1 = 0x1
	// Position of WUF12 field.
	LLWU_PF2_WUF12_Pos = 0x4
	// Bit mask of WUF12 field.
	LLWU_PF2_WUF12_Msk = 0x10
	// Bit WUF12.
	LLWU_PF2_WUF12 = 0x10
	// LLWU_P12 input was not a wakeup source
	LLWU_PF2_WUF12_0 = 0x0
	// LLWU_P12 input was a wakeup source
	LLWU_PF2_WUF12_1 = 0x1
	// Position of WUF13 field.
	LLWU_PF2_WUF13_Pos = 0x5
	// Bit mask of WUF13 field.
	LLWU_PF2_WUF13_Msk = 0x20
	// Bit WUF13.
	LLWU_PF2_WUF13 = 0x20
	// LLWU_P13 input was not a wakeup source
	LLWU_PF2_WUF13_0 = 0x0
	// LLWU_P13 input was a wakeup source
	LLWU_PF2_WUF13_1 = 0x1
	// Position of WUF14 field.
	LLWU_PF2_WUF14_Pos = 0x6
	// Bit mask of WUF14 field.
	LLWU_PF2_WUF14_Msk = 0x40
	// Bit WUF14.
	LLWU_PF2_WUF14 = 0x40
	// LLWU_P14 input was not a wakeup source
	LLWU_PF2_WUF14_0 = 0x0
	// LLWU_P14 input was a wakeup source
	LLWU_PF2_WUF14_1 = 0x1
	// Position of WUF15 field.
	LLWU_PF2_WUF15_Pos = 0x7
	// Bit mask of WUF15 field.
	LLWU_PF2_WUF15_Msk = 0x80
	// Bit WUF15.
	LLWU_PF2_WUF15 = 0x80
	// LLWU_P15 input was not a wakeup source
	LLWU_PF2_WUF15_0 = 0x0
	// LLWU_P15 input was a wakeup source
	LLWU_PF2_WUF15_1 = 0x1

	// PF3: LLWU Pin Flag 3 register
	// Position of WUF16 field.
	LLWU_PF3_WUF16_Pos = 0x0
	// Bit mask of WUF16 field.
	LLWU_PF3_WUF16_Msk = 0x1
	// Bit WUF16.
	LLWU_PF3_WUF16 = 0x1
	// LLWU_P16 input was not a wakeup source
	LLWU_PF3_WUF16_0 = 0x0
	// LLWU_P16 input was a wakeup source
	LLWU_PF3_WUF16_1 = 0x1
	// Position of WUF17 field.
	LLWU_PF3_WUF17_Pos = 0x1
	// Bit mask of WUF17 field.
	LLWU_PF3_WUF17_Msk = 0x2
	// Bit WUF17.
	LLWU_PF3_WUF17 = 0x2
	// LLWU_P17 input was not a wakeup source
	LLWU_PF3_WUF17_0 = 0x0
	// LLWU_P17 input was a wakeup source
	LLWU_PF3_WUF17_1 = 0x1
	// Position of WUF18 field.
	LLWU_PF3_WUF18_Pos = 0x2
	// Bit mask of WUF18 field.
	LLWU_PF3_WUF18_Msk = 0x4
	// Bit WUF18.
	LLWU_PF3_WUF18 = 0x4
	// LLWU_P18 input was not a wakeup source
	LLWU_PF3_WUF18_0 = 0x0
	// LLWU_P18 input was a wakeup source
	LLWU_PF3_WUF18_1 = 0x1
	// Position of WUF19 field.
	LLWU_PF3_WUF19_Pos = 0x3
	// Bit mask of WUF19 field.
	LLWU_PF3_WUF19_Msk = 0x8
	// Bit WUF19.
	LLWU_PF3_WUF19 = 0x8
	// LLWU_P19 input was not a wakeup source
	LLWU_PF3_WUF19_0 = 0x0
	// LLWU_P19 input was a wakeup source
	LLWU_PF3_WUF19_1 = 0x1
	// Position of WUF20 field.
	LLWU_PF3_WUF20_Pos = 0x4
	// Bit mask of WUF20 field.
	LLWU_PF3_WUF20_Msk = 0x10
	// Bit WUF20.
	LLWU_PF3_WUF20 = 0x10
	// LLWU_P20 input was not a wakeup source
	LLWU_PF3_WUF20_0 = 0x0
	// LLWU_P20 input was a wakeup source
	LLWU_PF3_WUF20_1 = 0x1
	// Position of WUF21 field.
	LLWU_PF3_WUF21_Pos = 0x5
	// Bit mask of WUF21 field.
	LLWU_PF3_WUF21_Msk = 0x20
	// Bit WUF21.
	LLWU_PF3_WUF21 = 0x20
	// LLWU_P21 input was not a wakeup source
	LLWU_PF3_WUF21_0 = 0x0
	// LLWU_P21 input was a wakeup source
	LLWU_PF3_WUF21_1 = 0x1
	// Position of WUF22 field.
	LLWU_PF3_WUF22_Pos = 0x6
	// Bit mask of WUF22 field.
	LLWU_PF3_WUF22_Msk = 0x40
	// Bit WUF22.
	LLWU_PF3_WUF22 = 0x40
	// LLWU_P22 input was not a wakeup source
	LLWU_PF3_WUF22_0 = 0x0
	// LLWU_P22 input was a wakeup source
	LLWU_PF3_WUF22_1 = 0x1
	// Position of WUF23 field.
	LLWU_PF3_WUF23_Pos = 0x7
	// Bit mask of WUF23 field.
	LLWU_PF3_WUF23_Msk = 0x80
	// Bit WUF23.
	LLWU_PF3_WUF23 = 0x80
	// LLWU_P23 input was not a wakeup source
	LLWU_PF3_WUF23_0 = 0x0
	// LLWU_P23 input was a wakeup source
	LLWU_PF3_WUF23_1 = 0x1

	// PF4: LLWU Pin Flag 4 register
	// Position of WUF24 field.
	LLWU_PF4_WUF24_Pos = 0x0
	// Bit mask of WUF24 field.
	LLWU_PF4_WUF24_Msk = 0x1
	// Bit WUF24.
	LLWU_PF4_WUF24 = 0x1
	// LLWU_P24 input was not a wakeup source
	LLWU_PF4_WUF24_0 = 0x0
	// LLWU_P24 input was a wakeup source
	LLWU_PF4_WUF24_1 = 0x1
	// Position of WUF25 field.
	LLWU_PF4_WUF25_Pos = 0x1
	// Bit mask of WUF25 field.
	LLWU_PF4_WUF25_Msk = 0x2
	// Bit WUF25.
	LLWU_PF4_WUF25 = 0x2
	// LLWU_P25 input was not a wakeup source
	LLWU_PF4_WUF25_0 = 0x0
	// LLWU_P25 input was a wakeup source
	LLWU_PF4_WUF25_1 = 0x1
	// Position of WUF26 field.
	LLWU_PF4_WUF26_Pos = 0x2
	// Bit mask of WUF26 field.
	LLWU_PF4_WUF26_Msk = 0x4
	// Bit WUF26.
	LLWU_PF4_WUF26 = 0x4
	// LLWU_P26 input was not a wakeup source
	LLWU_PF4_WUF26_0 = 0x0
	// LLWU_P26 input was a wakeup source
	LLWU_PF4_WUF26_1 = 0x1
	// Position of WUF27 field.
	LLWU_PF4_WUF27_Pos = 0x3
	// Bit mask of WUF27 field.
	LLWU_PF4_WUF27_Msk = 0x8
	// Bit WUF27.
	LLWU_PF4_WUF27 = 0x8
	// LLWU_P27 input was not a wakeup source
	LLWU_PF4_WUF27_0 = 0x0
	// LLWU_P27 input was a wakeup source
	LLWU_PF4_WUF27_1 = 0x1
	// Position of WUF28 field.
	LLWU_PF4_WUF28_Pos = 0x4
	// Bit mask of WUF28 field.
	LLWU_PF4_WUF28_Msk = 0x10
	// Bit WUF28.
	LLWU_PF4_WUF28 = 0x10
	// LLWU_P28 input was not a wakeup source
	LLWU_PF4_WUF28_0 = 0x0
	// LLWU_P28 input was a wakeup source
	LLWU_PF4_WUF28_1 = 0x1
	// Position of WUF29 field.
	LLWU_PF4_WUF29_Pos = 0x5
	// Bit mask of WUF29 field.
	LLWU_PF4_WUF29_Msk = 0x20
	// Bit WUF29.
	LLWU_PF4_WUF29 = 0x20
	// LLWU_P29 input was not a wakeup source
	LLWU_PF4_WUF29_0 = 0x0
	// LLWU_P29 input was a wakeup source
	LLWU_PF4_WUF29_1 = 0x1
	// Position of WUF30 field.
	LLWU_PF4_WUF30_Pos = 0x6
	// Bit mask of WUF30 field.
	LLWU_PF4_WUF30_Msk = 0x40
	// Bit WUF30.
	LLWU_PF4_WUF30 = 0x40
	// LLWU_P30 input was not a wakeup source
	LLWU_PF4_WUF30_0 = 0x0
	// LLWU_P30 input was a wakeup source
	LLWU_PF4_WUF30_1 = 0x1
	// Position of WUF31 field.
	LLWU_PF4_WUF31_Pos = 0x7
	// Bit mask of WUF31 field.
	LLWU_PF4_WUF31_Msk = 0x80
	// Bit WUF31.
	LLWU_PF4_WUF31 = 0x80
	// LLWU_P31 input was not a wakeup source
	LLWU_PF4_WUF31_0 = 0x0
	// LLWU_P31 input was a wakeup source
	LLWU_PF4_WUF31_1 = 0x1

	// MF5: LLWU Module Flag 5 register
	// Position of MWUF0 field.
	LLWU_MF5_MWUF0_Pos = 0x0
	// Bit mask of MWUF0 field.
	LLWU_MF5_MWUF0_Msk = 0x1
	// Bit MWUF0.
	LLWU_MF5_MWUF0 = 0x1
	// Module 0 input was not a wakeup source
	LLWU_MF5_MWUF0_0 = 0x0
	// Module 0 input was a wakeup source
	LLWU_MF5_MWUF0_1 = 0x1
	// Position of MWUF1 field.
	LLWU_MF5_MWUF1_Pos = 0x1
	// Bit mask of MWUF1 field.
	LLWU_MF5_MWUF1_Msk = 0x2
	// Bit MWUF1.
	LLWU_MF5_MWUF1 = 0x2
	// Module 1 input was not a wakeup source
	LLWU_MF5_MWUF1_0 = 0x0
	// Module 1 input was a wakeup source
	LLWU_MF5_MWUF1_1 = 0x1
	// Position of MWUF2 field.
	LLWU_MF5_MWUF2_Pos = 0x2
	// Bit mask of MWUF2 field.
	LLWU_MF5_MWUF2_Msk = 0x4
	// Bit MWUF2.
	LLWU_MF5_MWUF2 = 0x4
	// Module 2 input was not a wakeup source
	LLWU_MF5_MWUF2_0 = 0x0
	// Module 2 input was a wakeup source
	LLWU_MF5_MWUF2_1 = 0x1
	// Position of MWUF3 field.
	LLWU_MF5_MWUF3_Pos = 0x3
	// Bit mask of MWUF3 field.
	LLWU_MF5_MWUF3_Msk = 0x8
	// Bit MWUF3.
	LLWU_MF5_MWUF3 = 0x8
	// Module 3 input was not a wakeup source
	LLWU_MF5_MWUF3_0 = 0x0
	// Module 3 input was a wakeup source
	LLWU_MF5_MWUF3_1 = 0x1
	// Position of MWUF4 field.
	LLWU_MF5_MWUF4_Pos = 0x4
	// Bit mask of MWUF4 field.
	LLWU_MF5_MWUF4_Msk = 0x10
	// Bit MWUF4.
	LLWU_MF5_MWUF4 = 0x10
	// Module 4 input was not a wakeup source
	LLWU_MF5_MWUF4_0 = 0x0
	// Module 4 input was a wakeup source
	LLWU_MF5_MWUF4_1 = 0x1
	// Position of MWUF5 field.
	LLWU_MF5_MWUF5_Pos = 0x5
	// Bit mask of MWUF5 field.
	LLWU_MF5_MWUF5_Msk = 0x20
	// Bit MWUF5.
	LLWU_MF5_MWUF5 = 0x20
	// Module 5 input was not a wakeup source
	LLWU_MF5_MWUF5_0 = 0x0
	// Module 5 input was a wakeup source
	LLWU_MF5_MWUF5_1 = 0x1
	// Position of MWUF6 field.
	LLWU_MF5_MWUF6_Pos = 0x6
	// Bit mask of MWUF6 field.
	LLWU_MF5_MWUF6_Msk = 0x40
	// Bit MWUF6.
	LLWU_MF5_MWUF6 = 0x40
	// Module 6 input was not a wakeup source
	LLWU_MF5_MWUF6_0 = 0x0
	// Module 6 input was a wakeup source
	LLWU_MF5_MWUF6_1 = 0x1
	// Position of MWUF7 field.
	LLWU_MF5_MWUF7_Pos = 0x7
	// Bit mask of MWUF7 field.
	LLWU_MF5_MWUF7_Msk = 0x80
	// Bit MWUF7.
	LLWU_MF5_MWUF7 = 0x80
	// Module 7 input was not a wakeup source
	LLWU_MF5_MWUF7_0 = 0x0
	// Module 7 input was a wakeup source
	LLWU_MF5_MWUF7_1 = 0x1

	// FILT1: LLWU Pin Filter 1 register
	// Position of FILTSEL field.
	LLWU_FILT1_FILTSEL_Pos = 0x0
	// Bit mask of FILTSEL field.
	LLWU_FILT1_FILTSEL_Msk = 0x1f
	// Select LLWU_P0 for filter
	LLWU_FILT1_FILTSEL_00000 = 0x0
	// Select LLWU_P31 for filter
	LLWU_FILT1_FILTSEL_11111 = 0x1f
	// Position of FILTE field.
	LLWU_FILT1_FILTE_Pos = 0x5
	// Bit mask of FILTE field.
	LLWU_FILT1_FILTE_Msk = 0x60
	// Filter disabled
	LLWU_FILT1_FILTE_00 = 0x0
	// Filter posedge detect enabled
	LLWU_FILT1_FILTE_01 = 0x1
	// Filter negedge detect enabled
	LLWU_FILT1_FILTE_10 = 0x2
	// Filter any edge detect enabled
	LLWU_FILT1_FILTE_11 = 0x3
	// Position of FILTF field.
	LLWU_FILT1_FILTF_Pos = 0x7
	// Bit mask of FILTF field.
	LLWU_FILT1_FILTF_Msk = 0x80
	// Bit FILTF.
	LLWU_FILT1_FILTF = 0x80
	// Pin Filter 1 was not a wakeup source
	LLWU_FILT1_FILTF_0 = 0x0
	// Pin Filter 1 was a wakeup source
	LLWU_FILT1_FILTF_1 = 0x1

	// FILT2: LLWU Pin Filter 2 register
	// Position of FILTSEL field.
	LLWU_FILT2_FILTSEL_Pos = 0x0
	// Bit mask of FILTSEL field.
	LLWU_FILT2_FILTSEL_Msk = 0x1f
	// Select LLWU_P0 for filter
	LLWU_FILT2_FILTSEL_00000 = 0x0
	// Select LLWU_P31 for filter
	LLWU_FILT2_FILTSEL_11111 = 0x1f
	// Position of FILTE field.
	LLWU_FILT2_FILTE_Pos = 0x5
	// Bit mask of FILTE field.
	LLWU_FILT2_FILTE_Msk = 0x60
	// Filter disabled
	LLWU_FILT2_FILTE_00 = 0x0
	// Filter posedge detect enabled
	LLWU_FILT2_FILTE_01 = 0x1
	// Filter negedge detect enabled
	LLWU_FILT2_FILTE_10 = 0x2
	// Filter any edge detect enabled
	LLWU_FILT2_FILTE_11 = 0x3
	// Position of FILTF field.
	LLWU_FILT2_FILTF_Pos = 0x7
	// Bit mask of FILTF field.
	LLWU_FILT2_FILTF_Msk = 0x80
	// Bit FILTF.
	LLWU_FILT2_FILTF = 0x80
	// Pin Filter 2 was not a wakeup source
	LLWU_FILT2_FILTF_0 = 0x0
	// Pin Filter 2 was a wakeup source
	LLWU_FILT2_FILTF_1 = 0x1

	// FILT3: LLWU Pin Filter 3 register
	// Position of FILTSEL field.
	LLWU_FILT3_FILTSEL_Pos = 0x0
	// Bit mask of FILTSEL field.
	LLWU_FILT3_FILTSEL_Msk = 0x1f
	// Select LLWU_P0 for filter
	LLWU_FILT3_FILTSEL_00000 = 0x0
	// Select LLWU_P31 for filter
	LLWU_FILT3_FILTSEL_11111 = 0x1f
	// Position of FILTE field.
	LLWU_FILT3_FILTE_Pos = 0x5
	// Bit mask of FILTE field.
	LLWU_FILT3_FILTE_Msk = 0x60
	// Filter disabled
	LLWU_FILT3_FILTE_00 = 0x0
	// Filter posedge detect enabled
	LLWU_FILT3_FILTE_01 = 0x1
	// Filter negedge detect enabled
	LLWU_FILT3_FILTE_10 = 0x2
	// Filter any edge detect enabled
	LLWU_FILT3_FILTE_11 = 0x3
	// Position of FILTF field.
	LLWU_FILT3_FILTF_Pos = 0x7
	// Bit mask of FILTF field.
	LLWU_FILT3_FILTF_Msk = 0x80
	// Bit FILTF.
	LLWU_FILT3_FILTF = 0x80
	// Pin Filter 3 was not a wakeup source
	LLWU_FILT3_FILTF_0 = 0x0
	// Pin Filter 3 was a wakeup source
	LLWU_FILT3_FILTF_1 = 0x1

	// FILT4: LLWU Pin Filter 4 register
	// Position of FILTSEL field.
	LLWU_FILT4_FILTSEL_Pos = 0x0
	// Bit mask of FILTSEL field.
	LLWU_FILT4_FILTSEL_Msk = 0x1f
	// Select LLWU_P0 for filter
	LLWU_FILT4_FILTSEL_00000 = 0x0
	// Select LLWU_P31 for filter
	LLWU_FILT4_FILTSEL_11111 = 0x1f
	// Position of FILTE field.
	LLWU_FILT4_FILTE_Pos = 0x5
	// Bit mask of FILTE field.
	LLWU_FILT4_FILTE_Msk = 0x60
	// Filter disabled
	LLWU_FILT4_FILTE_00 = 0x0
	// Filter posedge detect enabled
	LLWU_FILT4_FILTE_01 = 0x1
	// Filter negedge detect enabled
	LLWU_FILT4_FILTE_10 = 0x2
	// Filter any edge detect enabled
	LLWU_FILT4_FILTE_11 = 0x3
	// Position of FILTF field.
	LLWU_FILT4_FILTF_Pos = 0x7
	// Bit mask of FILTF field.
	LLWU_FILT4_FILTF_Msk = 0x80
	// Bit FILTF.
	LLWU_FILT4_FILTF = 0x80
	// Pin Filter 4 was not a wakeup source
	LLWU_FILT4_FILTF_0 = 0x0
	// Pin Filter 4 was a wakeup source
	LLWU_FILT4_FILTF_1 = 0x1
)

// Constants for PMC: Power Management Controller
const (
	// LVDSC1: Low Voltage Detect Status And Control 1 register
	// Position of LVDV field.
	PMC_LVDSC1_LVDV_Pos = 0x0
	// Bit mask of LVDV field.
	PMC_LVDSC1_LVDV_Msk = 0x3
	// Low trip point selected (V LVD = V LVDL )
	PMC_LVDSC1_LVDV_00 = 0x0
	// High trip point selected (V LVD = V LVDH )
	PMC_LVDSC1_LVDV_01 = 0x1
	// Position of LVDRE field.
	PMC_LVDSC1_LVDRE_Pos = 0x4
	// Bit mask of LVDRE field.
	PMC_LVDSC1_LVDRE_Msk = 0x10
	// Bit LVDRE.
	PMC_LVDSC1_LVDRE = 0x10
	// LVDF does not generate hardware resets
	PMC_LVDSC1_LVDRE_0 = 0x0
	// Force an MCU reset when LVDF = 1
	PMC_LVDSC1_LVDRE_1 = 0x1
	// Position of LVDIE field.
	PMC_LVDSC1_LVDIE_Pos = 0x5
	// Bit mask of LVDIE field.
	PMC_LVDSC1_LVDIE_Msk = 0x20
	// Bit LVDIE.
	PMC_LVDSC1_LVDIE = 0x20
	// Hardware interrupt disabled (use polling)
	PMC_LVDSC1_LVDIE_0 = 0x0
	// Request a hardware interrupt when LVDF = 1
	PMC_LVDSC1_LVDIE_1 = 0x1
	// Position of LVDACK field.
	PMC_LVDSC1_LVDACK_Pos = 0x6
	// Bit mask of LVDACK field.
	PMC_LVDSC1_LVDACK_Msk = 0x40
	// Bit LVDACK.
	PMC_LVDSC1_LVDACK = 0x40
	// Position of LVDF field.
	PMC_LVDSC1_LVDF_Pos = 0x7
	// Bit mask of LVDF field.
	PMC_LVDSC1_LVDF_Msk = 0x80
	// Bit LVDF.
	PMC_LVDSC1_LVDF = 0x80
	// Low-voltage event not detected
	PMC_LVDSC1_LVDF_0 = 0x0
	// Low-voltage event detected
	PMC_LVDSC1_LVDF_1 = 0x1

	// LVDSC2: Low Voltage Detect Status And Control 2 register
	// Position of LVWV field.
	PMC_LVDSC2_LVWV_Pos = 0x0
	// Bit mask of LVWV field.
	PMC_LVDSC2_LVWV_Msk = 0x3
	// Low trip point selected (VLVW = VLVW1)
	PMC_LVDSC2_LVWV_00 = 0x0
	// Mid 1 trip point selected (VLVW = VLVW2)
	PMC_LVDSC2_LVWV_01 = 0x1
	// Mid 2 trip point selected (VLVW = VLVW3)
	PMC_LVDSC2_LVWV_10 = 0x2
	// High trip point selected (VLVW = VLVW4)
	PMC_LVDSC2_LVWV_11 = 0x3
	// Position of LVWIE field.
	PMC_LVDSC2_LVWIE_Pos = 0x5
	// Bit mask of LVWIE field.
	PMC_LVDSC2_LVWIE_Msk = 0x20
	// Bit LVWIE.
	PMC_LVDSC2_LVWIE = 0x20
	// Hardware interrupt disabled (use polling)
	PMC_LVDSC2_LVWIE_0 = 0x0
	// Request a hardware interrupt when LVWF = 1
	PMC_LVDSC2_LVWIE_1 = 0x1
	// Position of LVWACK field.
	PMC_LVDSC2_LVWACK_Pos = 0x6
	// Bit mask of LVWACK field.
	PMC_LVDSC2_LVWACK_Msk = 0x40
	// Bit LVWACK.
	PMC_LVDSC2_LVWACK = 0x40
	// Position of LVWF field.
	PMC_LVDSC2_LVWF_Pos = 0x7
	// Bit mask of LVWF field.
	PMC_LVDSC2_LVWF_Msk = 0x80
	// Bit LVWF.
	PMC_LVDSC2_LVWF = 0x80
	// Low-voltage warning event not detected
	PMC_LVDSC2_LVWF_0 = 0x0
	// Low-voltage warning event detected
	PMC_LVDSC2_LVWF_1 = 0x1

	// REGSC: Regulator Status And Control register
	// Position of BGBE field.
	PMC_REGSC_BGBE_Pos = 0x0
	// Bit mask of BGBE field.
	PMC_REGSC_BGBE_Msk = 0x1
	// Bit BGBE.
	PMC_REGSC_BGBE = 0x1
	// Bandgap buffer not enabled
	PMC_REGSC_BGBE_0 = 0x0
	// Bandgap buffer enabled
	PMC_REGSC_BGBE_1 = 0x1
	// Position of REGONS field.
	PMC_REGSC_REGONS_Pos = 0x2
	// Bit mask of REGONS field.
	PMC_REGSC_REGONS_Msk = 0x4
	// Bit REGONS.
	PMC_REGSC_REGONS = 0x4
	// Regulator is in stop regulation or in transition to/from it
	PMC_REGSC_REGONS_0 = 0x0
	// Regulator is in run regulation
	PMC_REGSC_REGONS_1 = 0x1
	// Position of ACKISO field.
	PMC_REGSC_ACKISO_Pos = 0x3
	// Bit mask of ACKISO field.
	PMC_REGSC_ACKISO_Msk = 0x8
	// Bit ACKISO.
	PMC_REGSC_ACKISO = 0x8
	// Peripherals and I/O pads are in normal run state.
	PMC_REGSC_ACKISO_0 = 0x0
	// Certain peripherals and I/O pads are in an isolated and latched state.
	PMC_REGSC_ACKISO_1 = 0x1
	// Position of BGEN field.
	PMC_REGSC_BGEN_Pos = 0x4
	// Bit mask of BGEN field.
	PMC_REGSC_BGEN_Msk = 0x10
	// Bit BGEN.
	PMC_REGSC_BGEN = 0x10
	// Bandgap voltage reference is disabled in VLPx , LLS , and VLLSx modes.
	PMC_REGSC_BGEN_0 = 0x0
	// Bandgap voltage reference is enabled in VLPx , LLS , and VLLSx modes.
	PMC_REGSC_BGEN_1 = 0x1
)

// Constants for SMC: System Mode Controller
const (
	// PMPROT: Power Mode Protection register
	// Position of AVLLS field.
	SMC_PMPROT_AVLLS_Pos = 0x1
	// Bit mask of AVLLS field.
	SMC_PMPROT_AVLLS_Msk = 0x2
	// Bit AVLLS.
	SMC_PMPROT_AVLLS = 0x2
	// Any VLLSx mode is not allowed
	SMC_PMPROT_AVLLS_0 = 0x0
	// Any VLLSx mode is allowed
	SMC_PMPROT_AVLLS_1 = 0x1
	// Position of ALLS field.
	SMC_PMPROT_ALLS_Pos = 0x3
	// Bit mask of ALLS field.
	SMC_PMPROT_ALLS_Msk = 0x8
	// Bit ALLS.
	SMC_PMPROT_ALLS = 0x8
	// Any LLSx mode is not allowed
	SMC_PMPROT_ALLS_0 = 0x0
	// Any LLSx mode is allowed
	SMC_PMPROT_ALLS_1 = 0x1
	// Position of AVLP field.
	SMC_PMPROT_AVLP_Pos = 0x5
	// Bit mask of AVLP field.
	SMC_PMPROT_AVLP_Msk = 0x20
	// Bit AVLP.
	SMC_PMPROT_AVLP = 0x20
	// VLPR, VLPW, and VLPS are not allowed.
	SMC_PMPROT_AVLP_0 = 0x0
	// VLPR, VLPW, and VLPS are allowed.
	SMC_PMPROT_AVLP_1 = 0x1
	// Position of AHSRUN field.
	SMC_PMPROT_AHSRUN_Pos = 0x7
	// Bit mask of AHSRUN field.
	SMC_PMPROT_AHSRUN_Msk = 0x80
	// Bit AHSRUN.
	SMC_PMPROT_AHSRUN = 0x80
	// HSRUN is not allowed
	SMC_PMPROT_AHSRUN_0 = 0x0
	// HSRUN is allowed
	SMC_PMPROT_AHSRUN_1 = 0x1

	// PMCTRL: Power Mode Control register
	// Position of STOPM field.
	SMC_PMCTRL_STOPM_Pos = 0x0
	// Bit mask of STOPM field.
	SMC_PMCTRL_STOPM_Msk = 0x7
	// Normal Stop (STOP)
	SMC_PMCTRL_STOPM_000 = 0x0
	// Very-Low-Power Stop (VLPS)
	SMC_PMCTRL_STOPM_010 = 0x2
	// Low-Leakage Stop (LLSx)
	SMC_PMCTRL_STOPM_011 = 0x3
	// Very-Low-Leakage Stop (VLLSx)
	SMC_PMCTRL_STOPM_100 = 0x4
	// Reseved
	SMC_PMCTRL_STOPM_110 = 0x6
	// Position of STOPA field.
	SMC_PMCTRL_STOPA_Pos = 0x3
	// Bit mask of STOPA field.
	SMC_PMCTRL_STOPA_Msk = 0x8
	// Bit STOPA.
	SMC_PMCTRL_STOPA = 0x8
	// The previous stop mode entry was successsful.
	SMC_PMCTRL_STOPA_0 = 0x0
	// The previous stop mode entry was aborted.
	SMC_PMCTRL_STOPA_1 = 0x1
	// Position of RUNM field.
	SMC_PMCTRL_RUNM_Pos = 0x5
	// Bit mask of RUNM field.
	SMC_PMCTRL_RUNM_Msk = 0x60
	// Normal Run mode (RUN)
	SMC_PMCTRL_RUNM_00 = 0x0
	// Very-Low-Power Run mode (VLPR)
	SMC_PMCTRL_RUNM_10 = 0x2
	// High Speed Run mode (HSRUN)
	SMC_PMCTRL_RUNM_11 = 0x3

	// STOPCTRL: Stop Control Register
	// Position of LLSM field.
	SMC_STOPCTRL_LLSM_Pos = 0x0
	// Bit mask of LLSM field.
	SMC_STOPCTRL_LLSM_Msk = 0x7
	// VLLS0 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
	SMC_STOPCTRL_LLSM_000 = 0x0
	// VLLS1 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
	SMC_STOPCTRL_LLSM_001 = 0x1
	// VLLS2 if PMCTRL[STOPM]=VLLSx, LLS2 if PMCTRL[STOPM]=LLSx
	SMC_STOPCTRL_LLSM_010 = 0x2
	// VLLS3 if PMCTRL[STOPM]=VLLSx, LLS3 if PMCTRL[STOPM]=LLSx
	SMC_STOPCTRL_LLSM_011 = 0x3
	// Position of RAM2PO field.
	SMC_STOPCTRL_RAM2PO_Pos = 0x4
	// Bit mask of RAM2PO field.
	SMC_STOPCTRL_RAM2PO_Msk = 0x10
	// Bit RAM2PO.
	SMC_STOPCTRL_RAM2PO = 0x10
	// RAM2 not powered in LLS2/VLLS2
	SMC_STOPCTRL_RAM2PO_0 = 0x0
	// RAM2 powered in LLS2/VLLS2
	SMC_STOPCTRL_RAM2PO_1 = 0x1
	// Position of PORPO field.
	SMC_STOPCTRL_PORPO_Pos = 0x5
	// Bit mask of PORPO field.
	SMC_STOPCTRL_PORPO_Msk = 0x20
	// Bit PORPO.
	SMC_STOPCTRL_PORPO = 0x20
	// POR detect circuit is enabled in VLLS0
	SMC_STOPCTRL_PORPO_0 = 0x0
	// POR detect circuit is disabled in VLLS0
	SMC_STOPCTRL_PORPO_1 = 0x1
	// Position of PSTOPO field.
	SMC_STOPCTRL_PSTOPO_Pos = 0x6
	// Bit mask of PSTOPO field.
	SMC_STOPCTRL_PSTOPO_Msk = 0xc0
	// STOP - Normal Stop mode
	SMC_STOPCTRL_PSTOPO_00 = 0x0
	// PSTOP1 - Partial Stop with both system and bus clocks disabled
	SMC_STOPCTRL_PSTOPO_01 = 0x1
	// PSTOP2 - Partial Stop with system clock disabled and bus clock enabled
	SMC_STOPCTRL_PSTOPO_10 = 0x2

	// PMSTAT: Power Mode Status register
	// Position of PMSTAT field.
	SMC_PMSTAT_PMSTAT_Pos = 0x0
	// Bit mask of PMSTAT field.
	SMC_PMSTAT_PMSTAT_Msk = 0xff
)

// Constants for RCM: Reset Control Module
const (
	// SRS0: System Reset Status Register 0
	// Position of WAKEUP field.
	RCM_SRS0_WAKEUP_Pos = 0x0
	// Bit mask of WAKEUP field.
	RCM_SRS0_WAKEUP_Msk = 0x1
	// Bit WAKEUP.
	RCM_SRS0_WAKEUP = 0x1
	// Reset not caused by LLWU module wakeup source
	RCM_SRS0_WAKEUP_0 = 0x0
	// Reset caused by LLWU module wakeup source
	RCM_SRS0_WAKEUP_1 = 0x1
	// Position of LVD field.
	RCM_SRS0_LVD_Pos = 0x1
	// Bit mask of LVD field.
	RCM_SRS0_LVD_Msk = 0x2
	// Bit LVD.
	RCM_SRS0_LVD = 0x2
	// Reset not caused by LVD trip or POR
	RCM_SRS0_LVD_0 = 0x0
	// Reset caused by LVD trip or POR
	RCM_SRS0_LVD_1 = 0x1
	// Position of LOC field.
	RCM_SRS0_LOC_Pos = 0x2
	// Bit mask of LOC field.
	RCM_SRS0_LOC_Msk = 0x4
	// Bit LOC.
	RCM_SRS0_LOC = 0x4
	// Reset not caused by a loss of external clock.
	RCM_SRS0_LOC_0 = 0x0
	// Reset caused by a loss of external clock.
	RCM_SRS0_LOC_1 = 0x1
	// Position of LOL field.
	RCM_SRS0_LOL_Pos = 0x3
	// Bit mask of LOL field.
	RCM_SRS0_LOL_Msk = 0x8
	// Bit LOL.
	RCM_SRS0_LOL = 0x8
	// Reset not caused by a loss of lock in the PLL
	RCM_SRS0_LOL_0 = 0x0
	// Reset caused by a loss of lock in the PLL
	RCM_SRS0_LOL_1 = 0x1
	// Position of WDOG field.
	RCM_SRS0_WDOG_Pos = 0x5
	// Bit mask of WDOG field.
	RCM_SRS0_WDOG_Msk = 0x20
	// Bit WDOG.
	RCM_SRS0_WDOG = 0x20
	// Reset not caused by watchdog timeout
	RCM_SRS0_WDOG_0 = 0x0
	// Reset caused by watchdog timeout
	RCM_SRS0_WDOG_1 = 0x1
	// Position of PIN field.
	RCM_SRS0_PIN_Pos = 0x6
	// Bit mask of PIN field.
	RCM_SRS0_PIN_Msk = 0x40
	// Bit PIN.
	RCM_SRS0_PIN = 0x40
	// Reset not caused by external reset pin
	RCM_SRS0_PIN_0 = 0x0
	// Reset caused by external reset pin
	RCM_SRS0_PIN_1 = 0x1
	// Position of POR field.
	RCM_SRS0_POR_Pos = 0x7
	// Bit mask of POR field.
	RCM_SRS0_POR_Msk = 0x80
	// Bit POR.
	RCM_SRS0_POR = 0x80
	// Reset not caused by POR
	RCM_SRS0_POR_0 = 0x0
	// Reset caused by POR
	RCM_SRS0_POR_1 = 0x1

	// SRS1: System Reset Status Register 1
	// Position of JTAG field.
	RCM_SRS1_JTAG_Pos = 0x0
	// Bit mask of JTAG field.
	RCM_SRS1_JTAG_Msk = 0x1
	// Bit JTAG.
	RCM_SRS1_JTAG = 0x1
	// Reset not caused by JTAG
	RCM_SRS1_JTAG_0 = 0x0
	// Reset caused by JTAG
	RCM_SRS1_JTAG_1 = 0x1
	// Position of LOCKUP field.
	RCM_SRS1_LOCKUP_Pos = 0x1
	// Bit mask of LOCKUP field.
	RCM_SRS1_LOCKUP_Msk = 0x2
	// Bit LOCKUP.
	RCM_SRS1_LOCKUP = 0x2
	// Reset not caused by core LOCKUP event
	RCM_SRS1_LOCKUP_0 = 0x0
	// Reset caused by core LOCKUP event
	RCM_SRS1_LOCKUP_1 = 0x1
	// Position of SW field.
	RCM_SRS1_SW_Pos = 0x2
	// Bit mask of SW field.
	RCM_SRS1_SW_Msk = 0x4
	// Bit SW.
	RCM_SRS1_SW = 0x4
	// Reset not caused by software setting of SYSRESETREQ bit
	RCM_SRS1_SW_0 = 0x0
	// Reset caused by software setting of SYSRESETREQ bit
	RCM_SRS1_SW_1 = 0x1
	// Position of MDM_AP field.
	RCM_SRS1_MDM_AP_Pos = 0x3
	// Bit mask of MDM_AP field.
	RCM_SRS1_MDM_AP_Msk = 0x8
	// Bit MDM_AP.
	RCM_SRS1_MDM_AP = 0x8
	// Reset not caused by host debugger system setting of the System Reset Request bit
	RCM_SRS1_MDM_AP_0 = 0x0
	// Reset caused by host debugger system setting of the System Reset Request bit
	RCM_SRS1_MDM_AP_1 = 0x1
	// Position of EZPT field.
	RCM_SRS1_EZPT_Pos = 0x4
	// Bit mask of EZPT field.
	RCM_SRS1_EZPT_Msk = 0x10
	// Bit EZPT.
	RCM_SRS1_EZPT = 0x10
	// Reset not caused by EzPort receiving the RESET command while the device is in EzPort mode
	RCM_SRS1_EZPT_0 = 0x0
	// Reset caused by EzPort receiving the RESET command while the device is in EzPort mode
	RCM_SRS1_EZPT_1 = 0x1
	// Position of SACKERR field.
	RCM_SRS1_SACKERR_Pos = 0x5
	// Bit mask of SACKERR field.
	RCM_SRS1_SACKERR_Msk = 0x20
	// Bit SACKERR.
	RCM_SRS1_SACKERR = 0x20
	// Reset not caused by peripheral failure to acknowledge attempt to enter stop mode
	RCM_SRS1_SACKERR_0 = 0x0
	// Reset caused by peripheral failure to acknowledge attempt to enter stop mode
	RCM_SRS1_SACKERR_1 = 0x1

	// RPFC: Reset Pin Filter Control register
	// Position of RSTFLTSRW field.
	RCM_RPFC_RSTFLTSRW_Pos = 0x0
	// Bit mask of RSTFLTSRW field.
	RCM_RPFC_RSTFLTSRW_Msk = 0x3
	// All filtering disabled
	RCM_RPFC_RSTFLTSRW_00 = 0x0
	// Bus clock filter enabled for normal operation
	RCM_RPFC_RSTFLTSRW_01 = 0x1
	// LPO clock filter enabled for normal operation
	RCM_RPFC_RSTFLTSRW_10 = 0x2
	// Position of RSTFLTSS field.
	RCM_RPFC_RSTFLTSS_Pos = 0x2
	// Bit mask of RSTFLTSS field.
	RCM_RPFC_RSTFLTSS_Msk = 0x4
	// Bit RSTFLTSS.
	RCM_RPFC_RSTFLTSS = 0x4
	// All filtering disabled
	RCM_RPFC_RSTFLTSS_0 = 0x0
	// LPO clock filter enabled
	RCM_RPFC_RSTFLTSS_1 = 0x1

	// RPFW: Reset Pin Filter Width register
	// Position of RSTFLTSEL field.
	RCM_RPFW_RSTFLTSEL_Pos = 0x0
	// Bit mask of RSTFLTSEL field.
	RCM_RPFW_RSTFLTSEL_Msk = 0x1f
	// Bus clock filter count is 1
	RCM_RPFW_RSTFLTSEL_00000 = 0x0
	// Bus clock filter count is 2
	RCM_RPFW_RSTFLTSEL_00001 = 0x1
	// Bus clock filter count is 3
	RCM_RPFW_RSTFLTSEL_00010 = 0x2
	// Bus clock filter count is 4
	RCM_RPFW_RSTFLTSEL_00011 = 0x3
	// Bus clock filter count is 5
	RCM_RPFW_RSTFLTSEL_00100 = 0x4
	// Bus clock filter count is 6
	RCM_RPFW_RSTFLTSEL_00101 = 0x5
	// Bus clock filter count is 7
	RCM_RPFW_RSTFLTSEL_00110 = 0x6
	// Bus clock filter count is 8
	RCM_RPFW_RSTFLTSEL_00111 = 0x7
	// Bus clock filter count is 9
	RCM_RPFW_RSTFLTSEL_01000 = 0x8
	// Bus clock filter count is 10
	RCM_RPFW_RSTFLTSEL_01001 = 0x9
	// Bus clock filter count is 11
	RCM_RPFW_RSTFLTSEL_01010 = 0xa
	// Bus clock filter count is 12
	RCM_RPFW_RSTFLTSEL_01011 = 0xb
	// Bus clock filter count is 13
	RCM_RPFW_RSTFLTSEL_01100 = 0xc
	// Bus clock filter count is 14
	RCM_RPFW_RSTFLTSEL_01101 = 0xd
	// Bus clock filter count is 15
	RCM_RPFW_RSTFLTSEL_01110 = 0xe
	// Bus clock filter count is 16
	RCM_RPFW_RSTFLTSEL_01111 = 0xf
	// Bus clock filter count is 17
	RCM_RPFW_RSTFLTSEL_10000 = 0x10
	// Bus clock filter count is 18
	RCM_RPFW_RSTFLTSEL_10001 = 0x11
	// Bus clock filter count is 19
	RCM_RPFW_RSTFLTSEL_10010 = 0x12
	// Bus clock filter count is 20
	RCM_RPFW_RSTFLTSEL_10011 = 0x13
	// Bus clock filter count is 21
	RCM_RPFW_RSTFLTSEL_10100 = 0x14
	// Bus clock filter count is 22
	RCM_RPFW_RSTFLTSEL_10101 = 0x15
	// Bus clock filter count is 23
	RCM_RPFW_RSTFLTSEL_10110 = 0x16
	// Bus clock filter count is 24
	RCM_RPFW_RSTFLTSEL_10111 = 0x17
	// Bus clock filter count is 25
	RCM_RPFW_RSTFLTSEL_11000 = 0x18
	// Bus clock filter count is 26
	RCM_RPFW_RSTFLTSEL_11001 = 0x19
	// Bus clock filter count is 27
	RCM_RPFW_RSTFLTSEL_11010 = 0x1a
	// Bus clock filter count is 28
	RCM_RPFW_RSTFLTSEL_11011 = 0x1b
	// Bus clock filter count is 29
	RCM_RPFW_RSTFLTSEL_11100 = 0x1c
	// Bus clock filter count is 30
	RCM_RPFW_RSTFLTSEL_11101 = 0x1d
	// Bus clock filter count is 31
	RCM_RPFW_RSTFLTSEL_11110 = 0x1e
	// Bus clock filter count is 32
	RCM_RPFW_RSTFLTSEL_11111 = 0x1f

	// MR: Mode Register
	// Position of EZP_MS field.
	RCM_MR_EZP_MS_Pos = 0x1
	// Bit mask of EZP_MS field.
	RCM_MR_EZP_MS_Msk = 0x2
	// Bit EZP_MS.
	RCM_MR_EZP_MS = 0x2
	// Pin deasserted (logic 1)
	RCM_MR_EZP_MS_0 = 0x0
	// Pin asserted (logic 0)
	RCM_MR_EZP_MS_1 = 0x1

	// SSRS0: Sticky System Reset Status Register 0
	// Position of SWAKEUP field.
	RCM_SSRS0_SWAKEUP_Pos = 0x0
	// Bit mask of SWAKEUP field.
	RCM_SSRS0_SWAKEUP_Msk = 0x1
	// Bit SWAKEUP.
	RCM_SSRS0_SWAKEUP = 0x1
	// Reset not caused by LLWU module wakeup source
	RCM_SSRS0_SWAKEUP_0 = 0x0
	// Reset caused by LLWU module wakeup source
	RCM_SSRS0_SWAKEUP_1 = 0x1
	// Position of SLVD field.
	RCM_SSRS0_SLVD_Pos = 0x1
	// Bit mask of SLVD field.
	RCM_SSRS0_SLVD_Msk = 0x2
	// Bit SLVD.
	RCM_SSRS0_SLVD = 0x2
	// Reset not caused by LVD trip or POR
	RCM_SSRS0_SLVD_0 = 0x0
	// Reset caused by LVD trip or POR
	RCM_SSRS0_SLVD_1 = 0x1
	// Position of SLOC field.
	RCM_SSRS0_SLOC_Pos = 0x2
	// Bit mask of SLOC field.
	RCM_SSRS0_SLOC_Msk = 0x4
	// Bit SLOC.
	RCM_SSRS0_SLOC = 0x4
	// Reset not caused by a loss of external clock.
	RCM_SSRS0_SLOC_0 = 0x0
	// Reset caused by a loss of external clock.
	RCM_SSRS0_SLOC_1 = 0x1
	// Position of SLOL field.
	RCM_SSRS0_SLOL_Pos = 0x3
	// Bit mask of SLOL field.
	RCM_SSRS0_SLOL_Msk = 0x8
	// Bit SLOL.
	RCM_SSRS0_SLOL = 0x8
	// Reset not caused by a loss of lock in the PLL
	RCM_SSRS0_SLOL_0 = 0x0
	// Reset caused by a loss of lock in the PLL
	RCM_SSRS0_SLOL_1 = 0x1
	// Position of SWDOG field.
	RCM_SSRS0_SWDOG_Pos = 0x5
	// Bit mask of SWDOG field.
	RCM_SSRS0_SWDOG_Msk = 0x20
	// Bit SWDOG.
	RCM_SSRS0_SWDOG = 0x20
	// Reset not caused by watchdog timeout
	RCM_SSRS0_SWDOG_0 = 0x0
	// Reset caused by watchdog timeout
	RCM_SSRS0_SWDOG_1 = 0x1
	// Position of SPIN field.
	RCM_SSRS0_SPIN_Pos = 0x6
	// Bit mask of SPIN field.
	RCM_SSRS0_SPIN_Msk = 0x40
	// Bit SPIN.
	RCM_SSRS0_SPIN = 0x40
	// Reset not caused by external reset pin
	RCM_SSRS0_SPIN_0 = 0x0
	// Reset caused by external reset pin
	RCM_SSRS0_SPIN_1 = 0x1
	// Position of SPOR field.
	RCM_SSRS0_SPOR_Pos = 0x7
	// Bit mask of SPOR field.
	RCM_SSRS0_SPOR_Msk = 0x80
	// Bit SPOR.
	RCM_SSRS0_SPOR = 0x80
	// Reset not caused by POR
	RCM_SSRS0_SPOR_0 = 0x0
	// Reset caused by POR
	RCM_SSRS0_SPOR_1 = 0x1

	// SSRS1: Sticky System Reset Status Register 1
	// Position of SJTAG field.
	RCM_SSRS1_SJTAG_Pos = 0x0
	// Bit mask of SJTAG field.
	RCM_SSRS1_SJTAG_Msk = 0x1
	// Bit SJTAG.
	RCM_SSRS1_SJTAG = 0x1
	// Reset not caused by JTAG
	RCM_SSRS1_SJTAG_0 = 0x0
	// Reset caused by JTAG
	RCM_SSRS1_SJTAG_1 = 0x1
	// Position of SLOCKUP field.
	RCM_SSRS1_SLOCKUP_Pos = 0x1
	// Bit mask of SLOCKUP field.
	RCM_SSRS1_SLOCKUP_Msk = 0x2
	// Bit SLOCKUP.
	RCM_SSRS1_SLOCKUP = 0x2
	// Reset not caused by core LOCKUP event
	RCM_SSRS1_SLOCKUP_0 = 0x0
	// Reset caused by core LOCKUP event
	RCM_SSRS1_SLOCKUP_1 = 0x1
	// Position of SSW field.
	RCM_SSRS1_SSW_Pos = 0x2
	// Bit mask of SSW field.
	RCM_SSRS1_SSW_Msk = 0x4
	// Bit SSW.
	RCM_SSRS1_SSW = 0x4
	// Reset not caused by software setting of SYSRESETREQ bit
	RCM_SSRS1_SSW_0 = 0x0
	// Reset caused by software setting of SYSRESETREQ bit
	RCM_SSRS1_SSW_1 = 0x1
	// Position of SMDM_AP field.
	RCM_SSRS1_SMDM_AP_Pos = 0x3
	// Bit mask of SMDM_AP field.
	RCM_SSRS1_SMDM_AP_Msk = 0x8
	// Bit SMDM_AP.
	RCM_SSRS1_SMDM_AP = 0x8
	// Reset not caused by host debugger system setting of the System Reset Request bit
	RCM_SSRS1_SMDM_AP_0 = 0x0
	// Reset caused by host debugger system setting of the System Reset Request bit
	RCM_SSRS1_SMDM_AP_1 = 0x1
	// Position of SEZPT field.
	RCM_SSRS1_SEZPT_Pos = 0x4
	// Bit mask of SEZPT field.
	RCM_SSRS1_SEZPT_Msk = 0x10
	// Bit SEZPT.
	RCM_SSRS1_SEZPT = 0x10
	// Reset not caused by EzPort receiving the RESET command while the device is in EzPort mode
	RCM_SSRS1_SEZPT_0 = 0x0
	// Reset caused by EzPort receiving the RESET command while the device is in EzPort mode
	RCM_SSRS1_SEZPT_1 = 0x1
	// Position of SSACKERR field.
	RCM_SSRS1_SSACKERR_Pos = 0x5
	// Bit mask of SSACKERR field.
	RCM_SSRS1_SSACKERR_Msk = 0x20
	// Bit SSACKERR.
	RCM_SSRS1_SSACKERR = 0x20
	// Reset not caused by peripheral failure to acknowledge attempt to enter stop mode
	RCM_SSRS1_SSACKERR_0 = 0x0
	// Reset caused by peripheral failure to acknowledge attempt to enter stop mode
	RCM_SSRS1_SSACKERR_1 = 0x1
)

// Constants for RNG: Random Number Generator Accelerator
const (
	// CR: RNGA Control Register
	// Position of GO field.
	RNG_CR_GO_Pos = 0x0
	// Bit mask of GO field.
	RNG_CR_GO_Msk = 0x1
	// Bit GO.
	RNG_CR_GO = 0x1
	// Disabled
	RNG_CR_GO_0 = 0x0
	// Enabled
	RNG_CR_GO_1 = 0x1
	// Position of HA field.
	RNG_CR_HA_Pos = 0x1
	// Bit mask of HA field.
	RNG_CR_HA_Msk = 0x2
	// Bit HA.
	RNG_CR_HA = 0x2
	// Disabled
	RNG_CR_HA_0 = 0x0
	// Enabled
	RNG_CR_HA_1 = 0x1
	// Position of INTM field.
	RNG_CR_INTM_Pos = 0x2
	// Bit mask of INTM field.
	RNG_CR_INTM_Msk = 0x4
	// Bit INTM.
	RNG_CR_INTM = 0x4
	// Not masked
	RNG_CR_INTM_0 = 0x0
	// Masked
	RNG_CR_INTM_1 = 0x1
	// Position of CLRI field.
	RNG_CR_CLRI_Pos = 0x3
	// Bit mask of CLRI field.
	RNG_CR_CLRI_Msk = 0x8
	// Bit CLRI.
	RNG_CR_CLRI = 0x8
	// Do not clear the interrupt.
	RNG_CR_CLRI_0 = 0x0
	// Clear the interrupt. When you write 1 to this field, RNGA then resets the error-interrupt indicator (SR[ERRI]). This bit always reads as 0.
	RNG_CR_CLRI_1 = 0x1
	// Position of SLP field.
	RNG_CR_SLP_Pos = 0x4
	// Bit mask of SLP field.
	RNG_CR_SLP_Msk = 0x10
	// Bit SLP.
	RNG_CR_SLP = 0x10
	// Normal mode
	RNG_CR_SLP_0 = 0x0
	// Sleep (low-power) mode
	RNG_CR_SLP_1 = 0x1

	// SR: RNGA Status Register
	// Position of SECV field.
	RNG_SR_SECV_Pos = 0x0
	// Bit mask of SECV field.
	RNG_SR_SECV_Msk = 0x1
	// Bit SECV.
	RNG_SR_SECV = 0x1
	// No security violation
	RNG_SR_SECV_0 = 0x0
	// Security violation
	RNG_SR_SECV_1 = 0x1
	// Position of LRS field.
	RNG_SR_LRS_Pos = 0x1
	// Bit mask of LRS field.
	RNG_SR_LRS_Msk = 0x2
	// Bit LRS.
	RNG_SR_LRS = 0x2
	// No underflow
	RNG_SR_LRS_0 = 0x0
	// Underflow
	RNG_SR_LRS_1 = 0x1
	// Position of ORU field.
	RNG_SR_ORU_Pos = 0x2
	// Bit mask of ORU field.
	RNG_SR_ORU_Msk = 0x4
	// Bit ORU.
	RNG_SR_ORU = 0x4
	// No underflow
	RNG_SR_ORU_0 = 0x0
	// Underflow
	RNG_SR_ORU_1 = 0x1
	// Position of ERRI field.
	RNG_SR_ERRI_Pos = 0x3
	// Bit mask of ERRI field.
	RNG_SR_ERRI_Msk = 0x8
	// Bit ERRI.
	RNG_SR_ERRI = 0x8
	// No underflow
	RNG_SR_ERRI_0 = 0x0
	// Underflow
	RNG_SR_ERRI_1 = 0x1
	// Position of SLP field.
	RNG_SR_SLP_Pos = 0x4
	// Bit mask of SLP field.
	RNG_SR_SLP_Msk = 0x10
	// Bit SLP.
	RNG_SR_SLP = 0x10
	// Normal mode
	RNG_SR_SLP_0 = 0x0
	// Sleep (low-power) mode
	RNG_SR_SLP_1 = 0x1
	// Position of OREG_LVL field.
	RNG_SR_OREG_LVL_Pos = 0x8
	// Bit mask of OREG_LVL field.
	RNG_SR_OREG_LVL_Msk = 0xff00
	// No words (empty)
	RNG_SR_OREG_LVL_0 = 0x0
	// One word (valid)
	RNG_SR_OREG_LVL_1 = 0x1
	// Position of OREG_SIZE field.
	RNG_SR_OREG_SIZE_Pos = 0x10
	// Bit mask of OREG_SIZE field.
	RNG_SR_OREG_SIZE_Msk = 0xff0000
	// One word (this value is fixed)
	RNG_SR_OREG_SIZE_1 = 0x1

	// ER: RNGA Entropy Register
	// Position of EXT_ENT field.
	RNG_ER_EXT_ENT_Pos = 0x0
	// Bit mask of EXT_ENT field.
	RNG_ER_EXT_ENT_Msk = 0xffffffff

	// OR: RNGA Output Register
	// Position of RANDOUT field.
	RNG_OR_RANDOUT_Pos = 0x0
	// Bit mask of RANDOUT field.
	RNG_OR_RANDOUT_Msk = 0xffffffff
	// Invalid data (if you read this field when it is 0 and SR[OREG_LVL] is 0, RNGA then writes 1 to SR[ERRI], SR[ORU], and SR[LRS]; when the error interrupt is not masked (CR[INTM]=0), RNGA also asserts an error interrupt request to the interrupt controller).
	RNG_OR_RANDOUT_0 = 0x0
)

// Constants for USBHS: USB HS/FS/LS OTG Controller
const (
	// ID: Identification Register
	// Position of ID field.
	USBHS_ID_ID_Pos = 0x0
	// Bit mask of ID field.
	USBHS_ID_ID_Msk = 0x3f
	// Position of NID field.
	USBHS_ID_NID_Pos = 0x8
	// Bit mask of NID field.
	USBHS_ID_NID_Msk = 0x3f00
	// Position of TAG field.
	USBHS_ID_TAG_Pos = 0x10
	// Bit mask of TAG field.
	USBHS_ID_TAG_Msk = 0x1f0000
	// Position of REVISION field.
	USBHS_ID_REVISION_Pos = 0x15
	// Bit mask of REVISION field.
	USBHS_ID_REVISION_Msk = 0x1e00000
	// Position of VERSION field.
	USBHS_ID_VERSION_Pos = 0x19
	// Bit mask of VERSION field.
	USBHS_ID_VERSION_Msk = 0x1e000000
	// Position of VERSIONID field.
	USBHS_ID_VERSIONID_Pos = 0x1d
	// Bit mask of VERSIONID field.
	USBHS_ID_VERSIONID_Msk = 0xe0000000

	// HWGENERAL: General Hardware Parameters Register
	// Position of PHYW field.
	USBHS_HWGENERAL_PHYW_Pos = 0x4
	// Bit mask of PHYW field.
	USBHS_HWGENERAL_PHYW_Msk = 0x30
	// 16 bit wide data bus
	USBHS_HWGENERAL_PHYW_01 = 0x1
	// Position of PHYM field.
	USBHS_HWGENERAL_PHYM_Pos = 0x6
	// Bit mask of PHYM field.
	USBHS_HWGENERAL_PHYM_Msk = 0x1c0
	// Controller configured for UTMI/UTMI+ interface.
	USBHS_HWGENERAL_PHYM_000 = 0x0
	// Position of SM field.
	USBHS_HWGENERAL_SM_Pos = 0x9
	// Bit mask of SM field.
	USBHS_HWGENERAL_SM_Msk = 0x600
	// No Serial Engine, always use parallel signaling.
	USBHS_HWGENERAL_SM_00 = 0x0

	// HWHOST: Host Hardware Parameters Register
	// Position of HC field.
	USBHS_HWHOST_HC_Pos = 0x0
	// Bit mask of HC field.
	USBHS_HWHOST_HC_Msk = 0x1
	// Bit HC.
	USBHS_HWHOST_HC = 0x1
	// Position of NPORT field.
	USBHS_HWHOST_NPORT_Pos = 0x1
	// Bit mask of NPORT field.
	USBHS_HWHOST_NPORT_Msk = 0xe
	// Position of TTASY field.
	USBHS_HWHOST_TTASY_Pos = 0x10
	// Bit mask of TTASY field.
	USBHS_HWHOST_TTASY_Msk = 0xff0000
	// Position of TTPER field.
	USBHS_HWHOST_TTPER_Pos = 0x18
	// Bit mask of TTPER field.
	USBHS_HWHOST_TTPER_Msk = 0xff000000

	// HWDEVICE: Device Hardware Parameters Register
	// Position of DC field.
	USBHS_HWDEVICE_DC_Pos = 0x0
	// Bit mask of DC field.
	USBHS_HWDEVICE_DC_Msk = 0x1
	// Bit DC.
	USBHS_HWDEVICE_DC = 0x1
	// Position of DEVEP field.
	USBHS_HWDEVICE_DEVEP_Pos = 0x1
	// Bit mask of DEVEP field.
	USBHS_HWDEVICE_DEVEP_Msk = 0x3e

	// HWTXBUF: Transmit Buffer Hardware Parameters Register
	// Position of TXBURST field.
	USBHS_HWTXBUF_TXBURST_Pos = 0x0
	// Bit mask of TXBURST field.
	USBHS_HWTXBUF_TXBURST_Msk = 0xff
	// Position of TXADD field.
	USBHS_HWTXBUF_TXADD_Pos = 0x8
	// Bit mask of TXADD field.
	USBHS_HWTXBUF_TXADD_Msk = 0xff00
	// Position of TXCHANADD field.
	USBHS_HWTXBUF_TXCHANADD_Pos = 0x10
	// Bit mask of TXCHANADD field.
	USBHS_HWTXBUF_TXCHANADD_Msk = 0xff0000
	// Position of TXLC field.
	USBHS_HWTXBUF_TXLC_Pos = 0x1f
	// Bit mask of TXLC field.
	USBHS_HWTXBUF_TXLC_Msk = 0x80000000
	// Bit TXLC.
	USBHS_HWTXBUF_TXLC = 0x80000000
	// Store device transmit contexts in the TX FIFO
	USBHS_HWTXBUF_TXLC_0 = 0x0
	// Store device transmit contexts in a register file
	USBHS_HWTXBUF_TXLC_1 = 0x1

	// HWRXBUF: Receive Buffer Hardware Parameters Register
	// Position of RXBURST field.
	USBHS_HWRXBUF_RXBURST_Pos = 0x0
	// Bit mask of RXBURST field.
	USBHS_HWRXBUF_RXBURST_Msk = 0xff
	// Position of RXADD field.
	USBHS_HWRXBUF_RXADD_Pos = 0x8
	// Bit mask of RXADD field.
	USBHS_HWRXBUF_RXADD_Msk = 0xff00

	// GPTIMER0LD: General Purpose Timer n Load Register
	// Position of GPTLD field.
	USBHS_GPTIMERLD_GPTLD_Pos = 0x0
	// Bit mask of GPTLD field.
	USBHS_GPTIMERLD_GPTLD_Msk = 0xffffff

	// GPTIMER0CTL: General Purpose Timer n Control Register
	// Position of GPTCNT field.
	USBHS_GPTIMERCTL_GPTCNT_Pos = 0x0
	// Bit mask of GPTCNT field.
	USBHS_GPTIMERCTL_GPTCNT_Msk = 0xffffff
	// Position of MODE field.
	USBHS_GPTIMERCTL_MODE_Pos = 0x18
	// Bit mask of MODE field.
	USBHS_GPTIMERCTL_MODE_Msk = 0x1000000
	// Bit MODE.
	USBHS_GPTIMERCTL_MODE = 0x1000000
	// One shot
	USBHS_GPTIMERCTL_MODE_0 = 0x0
	// Repeat
	USBHS_GPTIMERCTL_MODE_1 = 0x1
	// Position of RST field.
	USBHS_GPTIMERCTL_RST_Pos = 0x1e
	// Bit mask of RST field.
	USBHS_GPTIMERCTL_RST_Msk = 0x40000000
	// Bit RST.
	USBHS_GPTIMERCTL_RST = 0x40000000
	// No action
	USBHS_GPTIMERCTL_RST_0 = 0x0
	// Load counter value
	USBHS_GPTIMERCTL_RST_1 = 0x1
	// Position of RUN field.
	USBHS_GPTIMERCTL_RUN_Pos = 0x1f
	// Bit mask of RUN field.
	USBHS_GPTIMERCTL_RUN_Msk = 0x80000000
	// Bit RUN.
	USBHS_GPTIMERCTL_RUN = 0x80000000
	// Timer stop
	USBHS_GPTIMERCTL_RUN_0 = 0x0
	// Timer run
	USBHS_GPTIMERCTL_RUN_1 = 0x1

	// USB_SBUSCFG: System Bus Interface Configuration Register
	// Position of BURSTMODE field.
	USBHS_USB_SBUSCFG_BURSTMODE_Pos = 0x0
	// Bit mask of BURSTMODE field.
	USBHS_USB_SBUSCFG_BURSTMODE_Msk = 0x7
	// INCR burst of unspecified length
	USBHS_USB_SBUSCFG_BURSTMODE_000 = 0x0
	// INCR4, non-multiple transfers of INCR4 is decomposed into singles.
	USBHS_USB_SBUSCFG_BURSTMODE_001 = 0x1
	// INCR8, non-multiple transfers of INCR8, is decomposed into INCR4 or singles.
	USBHS_USB_SBUSCFG_BURSTMODE_010 = 0x2
	// INCR16, non-multiple transfers of INCR16, is decomposed into INCR8, INCR4 or singles.
	USBHS_USB_SBUSCFG_BURSTMODE_011 = 0x3
	// Reserved, do not use.
	USBHS_USB_SBUSCFG_BURSTMODE_100 = 0x4
	// INCR4, non-multiple transfers of INCR4 is decomposed into smaller unspecified length bursts.
	USBHS_USB_SBUSCFG_BURSTMODE_101 = 0x5
	// INCR8, non-multiple transfers of INCR8 is decomposed into smaller unspecified length bursts.
	USBHS_USB_SBUSCFG_BURSTMODE_110 = 0x6
	// INCR16, non-multiple transfers of INCR16 is decomposed into smaller unspecified length bursts.
	USBHS_USB_SBUSCFG_BURSTMODE_111 = 0x7

	// HCIVERSION: Host Controller Interface Version and Capability Registers Length Register
	// Position of CAPLENGTH field.
	USBHS_HCIVERSION_CAPLENGTH_Pos = 0x0
	// Bit mask of CAPLENGTH field.
	USBHS_HCIVERSION_CAPLENGTH_Msk = 0xff
	// Position of HCIVERSION field.
	USBHS_HCIVERSION_HCIVERSION_Pos = 0x10
	// Bit mask of HCIVERSION field.
	USBHS_HCIVERSION_HCIVERSION_Msk = 0xffff0000

	// HCSPARAMS: Host Controller Structural Parameters Register
	// Position of N_PORTS field.
	USBHS_HCSPARAMS_N_PORTS_Pos = 0x0
	// Bit mask of N_PORTS field.
	USBHS_HCSPARAMS_N_PORTS_Msk = 0xf
	// Position of PPC field.
	USBHS_HCSPARAMS_PPC_Pos = 0x4
	// Bit mask of PPC field.
	USBHS_HCSPARAMS_PPC_Msk = 0x10
	// Bit PPC.
	USBHS_HCSPARAMS_PPC = 0x10
	// Ports have power port switches
	USBHS_HCSPARAMS_PPC_1 = 0x1
	// Position of N_PCC field.
	USBHS_HCSPARAMS_N_PCC_Pos = 0x8
	// Bit mask of N_PCC field.
	USBHS_HCSPARAMS_N_PCC_Msk = 0xf00
	// Position of N_CC field.
	USBHS_HCSPARAMS_N_CC_Pos = 0xc
	// Bit mask of N_CC field.
	USBHS_HCSPARAMS_N_CC_Msk = 0xf000
	// Position of PI field.
	USBHS_HCSPARAMS_PI_Pos = 0x10
	// Bit mask of PI field.
	USBHS_HCSPARAMS_PI_Msk = 0x10000
	// Bit PI.
	USBHS_HCSPARAMS_PI = 0x10000
	// No port indicator fields
	USBHS_HCSPARAMS_PI_0 = 0x0
	// The port status and control registers include a R/W field for controlling the state of the port indicator
	USBHS_HCSPARAMS_PI_1 = 0x1
	// Position of N_PTT field.
	USBHS_HCSPARAMS_N_PTT_Pos = 0x14
	// Bit mask of N_PTT field.
	USBHS_HCSPARAMS_N_PTT_Msk = 0xf00000
	// Position of N_TT field.
	USBHS_HCSPARAMS_N_TT_Pos = 0x18
	// Bit mask of N_TT field.
	USBHS_HCSPARAMS_N_TT_Msk = 0xf000000

	// HCCPARAMS: Host Controller Capability Parameters Register
	// Position of ADC field.
	USBHS_HCCPARAMS_ADC_Pos = 0x0
	// Bit mask of ADC field.
	USBHS_HCCPARAMS_ADC_Msk = 0x1
	// Bit ADC.
	USBHS_HCCPARAMS_ADC = 0x1
	// Position of PFL field.
	USBHS_HCCPARAMS_PFL_Pos = 0x1
	// Bit mask of PFL field.
	USBHS_HCCPARAMS_PFL_Msk = 0x2
	// Bit PFL.
	USBHS_HCCPARAMS_PFL = 0x2
	// Position of ASP field.
	USBHS_HCCPARAMS_ASP_Pos = 0x2
	// Bit mask of ASP field.
	USBHS_HCCPARAMS_ASP_Msk = 0x4
	// Bit ASP.
	USBHS_HCCPARAMS_ASP = 0x4
	// Park not supported.
	USBHS_HCCPARAMS_ASP_0 = 0x0
	// Park supported.
	USBHS_HCCPARAMS_ASP_1 = 0x1
	// Position of IST field.
	USBHS_HCCPARAMS_IST_Pos = 0x4
	// Bit mask of IST field.
	USBHS_HCCPARAMS_IST_Msk = 0xf0
	// The value of the least significant 3 bits indicates the number of microframes a host controller can hold a set of isochronous data structures (one or more) before flushing the state
	USBHS_HCCPARAMS_IST_0 = 0x0
	// Position of EECP field.
	USBHS_HCCPARAMS_EECP_Pos = 0x8
	// Bit mask of EECP field.
	USBHS_HCCPARAMS_EECP_Msk = 0xff00
	// No extended capabilities are implemented
	USBHS_HCCPARAMS_EECP_0 = 0x0

	// DCIVERSION: Device Controller Interface Version
	// Position of DCIVERSION field.
	USBHS_DCIVERSION_DCIVERSION_Pos = 0x0
	// Bit mask of DCIVERSION field.
	USBHS_DCIVERSION_DCIVERSION_Msk = 0xffff

	// DCCPARAMS: Device Controller Capability Parameters
	// Position of DEN field.
	USBHS_DCCPARAMS_DEN_Pos = 0x0
	// Bit mask of DEN field.
	USBHS_DCCPARAMS_DEN_Msk = 0x1f
	// Position of DC field.
	USBHS_DCCPARAMS_DC_Pos = 0x7
	// Bit mask of DC field.
	USBHS_DCCPARAMS_DC_Msk = 0x80
	// Bit DC.
	USBHS_DCCPARAMS_DC = 0x80
	// Position of HC field.
	USBHS_DCCPARAMS_HC_Pos = 0x8
	// Bit mask of HC field.
	USBHS_DCCPARAMS_HC_Msk = 0x100
	// Bit HC.
	USBHS_DCCPARAMS_HC = 0x100

	// USBCMD: USB Command Register
	// Position of RS field.
	USBHS_USBCMD_RS_Pos = 0x0
	// Bit mask of RS field.
	USBHS_USBCMD_RS_Msk = 0x1
	// Bit RS.
	USBHS_USBCMD_RS = 0x1
	// Position of RST field.
	USBHS_USBCMD_RST_Pos = 0x1
	// Bit mask of RST field.
	USBHS_USBCMD_RST_Msk = 0x2
	// Bit RST.
	USBHS_USBCMD_RST = 0x2
	// Position of FS field.
	USBHS_USBCMD_FS_Pos = 0x2
	// Bit mask of FS field.
	USBHS_USBCMD_FS_Msk = 0xc
	// When FS2 = 0, the size is 1024 elements (4096 bytes). When FS2 = 1, the size is 64 elements (256 bytes).
	USBHS_USBCMD_FS_00 = 0x0
	// When FS2 = 0, the size is 512 elements (2048 bytes). When FS2 = 1, the size is 32 elements (128 bytes).
	USBHS_USBCMD_FS_01 = 0x1
	// When FS2 = 0, the size is 256 elements (1024 bytes). When FS2 = 1, the size is 16 elements (64 bytes).
	USBHS_USBCMD_FS_10 = 0x2
	// When FS2 = 0, the size is 128 elements (512 bytes). When FS2 = 1, the size is 8 elements (32 bytes).
	USBHS_USBCMD_FS_11 = 0x3
	// Position of PSE field.
	USBHS_USBCMD_PSE_Pos = 0x4
	// Bit mask of PSE field.
	USBHS_USBCMD_PSE_Msk = 0x10
	// Bit PSE.
	USBHS_USBCMD_PSE = 0x10
	// Do not process periodic schedule.
	USBHS_USBCMD_PSE_0 = 0x0
	// Use the PERIODICLISTBASE register to access the periodic schedule.
	USBHS_USBCMD_PSE_1 = 0x1
	// Position of ASE field.
	USBHS_USBCMD_ASE_Pos = 0x5
	// Bit mask of ASE field.
	USBHS_USBCMD_ASE_Msk = 0x20
	// Bit ASE.
	USBHS_USBCMD_ASE = 0x20
	// Do not process asynchronous schedule.
	USBHS_USBCMD_ASE_0 = 0x0
	// Use the ASYNCLISTADDR register to access asynchronous schedule.
	USBHS_USBCMD_ASE_1 = 0x1
	// Position of IAA field.
	USBHS_USBCMD_IAA_Pos = 0x6
	// Bit mask of IAA field.
	USBHS_USBCMD_IAA_Msk = 0x40
	// Bit IAA.
	USBHS_USBCMD_IAA = 0x40
	// Position of ASP field.
	USBHS_USBCMD_ASP_Pos = 0x8
	// Bit mask of ASP field.
	USBHS_USBCMD_ASP_Msk = 0x300
	// Position of ASPE field.
	USBHS_USBCMD_ASPE_Pos = 0xb
	// Bit mask of ASPE field.
	USBHS_USBCMD_ASPE_Msk = 0x800
	// Bit ASPE.
	USBHS_USBCMD_ASPE = 0x800
	// Park mode disabled
	USBHS_USBCMD_ASPE_0 = 0x0
	// Park mode enabled
	USBHS_USBCMD_ASPE_1 = 0x1
	// Position of SUTW field.
	USBHS_USBCMD_SUTW_Pos = 0xd
	// Bit mask of SUTW field.
	USBHS_USBCMD_SUTW_Msk = 0x2000
	// Bit SUTW.
	USBHS_USBCMD_SUTW = 0x2000
	// Position of ATDTW field.
	USBHS_USBCMD_ATDTW_Pos = 0xe
	// Bit mask of ATDTW field.
	USBHS_USBCMD_ATDTW_Msk = 0x4000
	// Bit ATDTW.
	USBHS_USBCMD_ATDTW = 0x4000
	// Position of FS2 field.
	USBHS_USBCMD_FS2_Pos = 0xf
	// Bit mask of FS2 field.
	USBHS_USBCMD_FS2_Msk = 0x8000
	// Bit FS2.
	USBHS_USBCMD_FS2 = 0x8000
	// Position of ITC field.
	USBHS_USBCMD_ITC_Pos = 0x10
	// Bit mask of ITC field.
	USBHS_USBCMD_ITC_Msk = 0xff0000
	// Immediate (no threshold)
	USBHS_USBCMD_ITC_0 = 0x0
	// 1 microframe
	USBHS_USBCMD_ITC_1 = 0x1
	// 2 microframes
	USBHS_USBCMD_ITC_10 = 0x2
	// 4 microframes
	USBHS_USBCMD_ITC_100 = 0x4
	// 8 microframes
	USBHS_USBCMD_ITC_1000 = 0x8
	// 16 microframes
	USBHS_USBCMD_ITC_10000 = 0x10
	// 32 microframes
	USBHS_USBCMD_ITC_100000 = 0x20
	// 64 microframes
	USBHS_USBCMD_ITC_1000000 = 0x40

	// USBSTS: USB Status Register
	// Position of UI field.
	USBHS_USBSTS_UI_Pos = 0x0
	// Bit mask of UI field.
	USBHS_USBSTS_UI_Msk = 0x1
	// Bit UI.
	USBHS_USBSTS_UI = 0x1
	// Position of UEI field.
	USBHS_USBSTS_UEI_Pos = 0x1
	// Bit mask of UEI field.
	USBHS_USBSTS_UEI_Msk = 0x2
	// Bit UEI.
	USBHS_USBSTS_UEI = 0x2
	// No error
	USBHS_USBSTS_UEI_0 = 0x0
	// Error detected
	USBHS_USBSTS_UEI_1 = 0x1
	// Position of PCI field.
	USBHS_USBSTS_PCI_Pos = 0x2
	// Bit mask of PCI field.
	USBHS_USBSTS_PCI_Msk = 0x4
	// Bit PCI.
	USBHS_USBSTS_PCI = 0x4
	// Position of FRI field.
	USBHS_USBSTS_FRI_Pos = 0x3
	// Bit mask of FRI field.
	USBHS_USBSTS_FRI_Msk = 0x8
	// Bit FRI.
	USBHS_USBSTS_FRI = 0x8
	// Position of SEI field.
	USBHS_USBSTS_SEI_Pos = 0x4
	// Bit mask of SEI field.
	USBHS_USBSTS_SEI_Msk = 0x10
	// Bit SEI.
	USBHS_USBSTS_SEI = 0x10
	// Normal operation
	USBHS_USBSTS_SEI_0 = 0x0
	// Error
	USBHS_USBSTS_SEI_1 = 0x1
	// Position of AAI field.
	USBHS_USBSTS_AAI_Pos = 0x5
	// Bit mask of AAI field.
	USBHS_USBSTS_AAI_Msk = 0x20
	// Bit AAI.
	USBHS_USBSTS_AAI = 0x20
	// No async advance interrupt
	USBHS_USBSTS_AAI_0 = 0x0
	// Async advance interrupt
	USBHS_USBSTS_AAI_1 = 0x1
	// Position of URI field.
	USBHS_USBSTS_URI_Pos = 0x6
	// Bit mask of URI field.
	USBHS_USBSTS_URI_Msk = 0x40
	// Bit URI.
	USBHS_USBSTS_URI = 0x40
	// No reset received
	USBHS_USBSTS_URI_0 = 0x0
	// Reset received
	USBHS_USBSTS_URI_1 = 0x1
	// Position of SRI field.
	USBHS_USBSTS_SRI_Pos = 0x7
	// Bit mask of SRI field.
	USBHS_USBSTS_SRI_Msk = 0x80
	// Bit SRI.
	USBHS_USBSTS_SRI = 0x80
	// Position of SLI field.
	USBHS_USBSTS_SLI_Pos = 0x8
	// Bit mask of SLI field.
	USBHS_USBSTS_SLI_Msk = 0x100
	// Bit SLI.
	USBHS_USBSTS_SLI = 0x100
	// Active
	USBHS_USBSTS_SLI_0 = 0x0
	// Suspended
	USBHS_USBSTS_SLI_1 = 0x1
	// Position of HCH field.
	USBHS_USBSTS_HCH_Pos = 0xc
	// Bit mask of HCH field.
	USBHS_USBSTS_HCH_Msk = 0x1000
	// Bit HCH.
	USBHS_USBSTS_HCH = 0x1000
	// Running
	USBHS_USBSTS_HCH_0 = 0x0
	// Halted
	USBHS_USBSTS_HCH_1 = 0x1
	// Position of RCL field.
	USBHS_USBSTS_RCL_Pos = 0xd
	// Bit mask of RCL field.
	USBHS_USBSTS_RCL_Msk = 0x2000
	// Bit RCL.
	USBHS_USBSTS_RCL = 0x2000
	// Non-empty asynchronous schedule
	USBHS_USBSTS_RCL_0 = 0x0
	// Empty asynchronous schedule
	USBHS_USBSTS_RCL_1 = 0x1
	// Position of PS field.
	USBHS_USBSTS_PS_Pos = 0xe
	// Bit mask of PS field.
	USBHS_USBSTS_PS_Msk = 0x4000
	// Bit PS.
	USBHS_USBSTS_PS = 0x4000
	// Disabled
	USBHS_USBSTS_PS_0 = 0x0
	// Enabled
	USBHS_USBSTS_PS_1 = 0x1
	// Position of AS field.
	USBHS_USBSTS_AS_Pos = 0xf
	// Bit mask of AS field.
	USBHS_USBSTS_AS_Msk = 0x8000
	// Bit AS.
	USBHS_USBSTS_AS = 0x8000
	// Disabled
	USBHS_USBSTS_AS_0 = 0x0
	// Enabled
	USBHS_USBSTS_AS_1 = 0x1
	// Position of NAKI field.
	USBHS_USBSTS_NAKI_Pos = 0x10
	// Bit mask of NAKI field.
	USBHS_USBSTS_NAKI_Msk = 0x10000
	// Bit NAKI.
	USBHS_USBSTS_NAKI = 0x10000
	// Position of UAI field.
	USBHS_USBSTS_UAI_Pos = 0x12
	// Bit mask of UAI field.
	USBHS_USBSTS_UAI_Msk = 0x40000
	// Bit UAI.
	USBHS_USBSTS_UAI = 0x40000
	// Position of UPI field.
	USBHS_USBSTS_UPI_Pos = 0x13
	// Bit mask of UPI field.
	USBHS_USBSTS_UPI_Msk = 0x80000
	// Bit UPI.
	USBHS_USBSTS_UPI = 0x80000
	// Position of TI0 field.
	USBHS_USBSTS_TI0_Pos = 0x18
	// Bit mask of TI0 field.
	USBHS_USBSTS_TI0_Msk = 0x1000000
	// Bit TI0.
	USBHS_USBSTS_TI0 = 0x1000000
	// No interrupt
	USBHS_USBSTS_TI0_0 = 0x0
	// Interrupt occurred
	USBHS_USBSTS_TI0_1 = 0x1
	// Position of TI1 field.
	USBHS_USBSTS_TI1_Pos = 0x19
	// Bit mask of TI1 field.
	USBHS_USBSTS_TI1_Msk = 0x2000000
	// Bit TI1.
	USBHS_USBSTS_TI1 = 0x2000000
	// No interrupt
	USBHS_USBSTS_TI1_0 = 0x0
	// Interrupt occurred
	USBHS_USBSTS_TI1_1 = 0x1

	// USBINTR: USB Interrupt Enable Register
	// Position of UE field.
	USBHS_USBINTR_UE_Pos = 0x0
	// Bit mask of UE field.
	USBHS_USBINTR_UE_Msk = 0x1
	// Bit UE.
	USBHS_USBINTR_UE = 0x1
	// Disabled
	USBHS_USBINTR_UE_0 = 0x0
	// Enabled
	USBHS_USBINTR_UE_1 = 0x1
	// Position of UEE field.
	USBHS_USBINTR_UEE_Pos = 0x1
	// Bit mask of UEE field.
	USBHS_USBINTR_UEE_Msk = 0x2
	// Bit UEE.
	USBHS_USBINTR_UEE = 0x2
	// Disabled
	USBHS_USBINTR_UEE_0 = 0x0
	// Enabled
	USBHS_USBINTR_UEE_1 = 0x1
	// Position of PCE field.
	USBHS_USBINTR_PCE_Pos = 0x2
	// Bit mask of PCE field.
	USBHS_USBINTR_PCE_Msk = 0x4
	// Bit PCE.
	USBHS_USBINTR_PCE = 0x4
	// Disabled
	USBHS_USBINTR_PCE_0 = 0x0
	// Enabled
	USBHS_USBINTR_PCE_1 = 0x1
	// Position of FRE field.
	USBHS_USBINTR_FRE_Pos = 0x3
	// Bit mask of FRE field.
	USBHS_USBINTR_FRE_Msk = 0x8
	// Bit FRE.
	USBHS_USBINTR_FRE = 0x8
	// Disabled
	USBHS_USBINTR_FRE_0 = 0x0
	// Enabled
	USBHS_USBINTR_FRE_1 = 0x1
	// Position of SEE field.
	USBHS_USBINTR_SEE_Pos = 0x4
	// Bit mask of SEE field.
	USBHS_USBINTR_SEE_Msk = 0x10
	// Bit SEE.
	USBHS_USBINTR_SEE = 0x10
	// Disabled
	USBHS_USBINTR_SEE_0 = 0x0
	// Enabled
	USBHS_USBINTR_SEE_1 = 0x1
	// Position of AAE field.
	USBHS_USBINTR_AAE_Pos = 0x5
	// Bit mask of AAE field.
	USBHS_USBINTR_AAE_Msk = 0x20
	// Bit AAE.
	USBHS_USBINTR_AAE = 0x20
	// Disabled
	USBHS_USBINTR_AAE_0 = 0x0
	// Enabled
	USBHS_USBINTR_AAE_1 = 0x1
	// Position of URE field.
	USBHS_USBINTR_URE_Pos = 0x6
	// Bit mask of URE field.
	USBHS_USBINTR_URE_Msk = 0x40
	// Bit URE.
	USBHS_USBINTR_URE = 0x40
	// Disabled
	USBHS_USBINTR_URE_0 = 0x0
	// Enabled
	USBHS_USBINTR_URE_1 = 0x1
	// Position of SRE field.
	USBHS_USBINTR_SRE_Pos = 0x7
	// Bit mask of SRE field.
	USBHS_USBINTR_SRE_Msk = 0x80
	// Bit SRE.
	USBHS_USBINTR_SRE = 0x80
	// Disabled
	USBHS_USBINTR_SRE_0 = 0x0
	// Enabled
	USBHS_USBINTR_SRE_1 = 0x1
	// Position of SLE field.
	USBHS_USBINTR_SLE_Pos = 0x8
	// Bit mask of SLE field.
	USBHS_USBINTR_SLE_Msk = 0x100
	// Bit SLE.
	USBHS_USBINTR_SLE = 0x100
	// Disabled
	USBHS_USBINTR_SLE_0 = 0x0
	// Enabled
	USBHS_USBINTR_SLE_1 = 0x1
	// Position of NAKE field.
	USBHS_USBINTR_NAKE_Pos = 0x10
	// Bit mask of NAKE field.
	USBHS_USBINTR_NAKE_Msk = 0x10000
	// Bit NAKE.
	USBHS_USBINTR_NAKE = 0x10000
	// Disabled
	USBHS_USBINTR_NAKE_0 = 0x0
	// Enabled
	USBHS_USBINTR_NAKE_1 = 0x1
	// Position of UAIE field.
	USBHS_USBINTR_UAIE_Pos = 0x12
	// Bit mask of UAIE field.
	USBHS_USBINTR_UAIE_Msk = 0x40000
	// Bit UAIE.
	USBHS_USBINTR_UAIE = 0x40000
	// Position of UPIE field.
	USBHS_USBINTR_UPIE_Pos = 0x13
	// Bit mask of UPIE field.
	USBHS_USBINTR_UPIE_Msk = 0x80000
	// Bit UPIE.
	USBHS_USBINTR_UPIE = 0x80000
	// Position of TIE0 field.
	USBHS_USBINTR_TIE0_Pos = 0x18
	// Bit mask of TIE0 field.
	USBHS_USBINTR_TIE0_Msk = 0x1000000
	// Bit TIE0.
	USBHS_USBINTR_TIE0 = 0x1000000
	// Disabled
	USBHS_USBINTR_TIE0_0 = 0x0
	// Enabled
	USBHS_USBINTR_TIE0_1 = 0x1
	// Position of TIE1 field.
	USBHS_USBINTR_TIE1_Pos = 0x19
	// Bit mask of TIE1 field.
	USBHS_USBINTR_TIE1_Msk = 0x2000000
	// Bit TIE1.
	USBHS_USBINTR_TIE1 = 0x2000000
	// Disabled
	USBHS_USBINTR_TIE1_0 = 0x0
	// Enabled
	USBHS_USBINTR_TIE1_1 = 0x1

	// FRINDEX: Frame Index Register
	// Position of FRINDEX field.
	USBHS_FRINDEX_FRINDEX_Pos = 0x0
	// Bit mask of FRINDEX field.
	USBHS_FRINDEX_FRINDEX_Msk = 0x3fff
	// Position of Reerved field.
	USBHS_FRINDEX_Reerved_Pos = 0xe
	// Bit mask of Reerved field.
	USBHS_FRINDEX_Reerved_Msk = 0xffffc000

	// DEVICEADDR: Device Address Register
	// Position of USBADRA field.
	USBHS_DEVICEADDR_USBADRA_Pos = 0x18
	// Bit mask of USBADRA field.
	USBHS_DEVICEADDR_USBADRA_Msk = 0x1000000
	// Bit USBADRA.
	USBHS_DEVICEADDR_USBADRA = 0x1000000
	// Writes to USBADR are instantaneous.
	USBHS_DEVICEADDR_USBADRA_0 = 0x0
	// When this bit is written to a 1 at the same time or before USBADR is written, the write to the USBADR field is staged and held in a hidden register. After an IN occurs on endpoint 0 and is ACKed, USBADR is loaded from the holding register.
	USBHS_DEVICEADDR_USBADRA_1 = 0x1
	// Position of USBADR field.
	USBHS_DEVICEADDR_USBADR_Pos = 0x19
	// Bit mask of USBADR field.
	USBHS_DEVICEADDR_USBADR_Msk = 0xfe000000

	// PERIODICLISTBASE: Periodic Frame List Base Address Register
	// Position of PERBASE field.
	USBHS_PERIODICLISTBASE_PERBASE_Pos = 0xc
	// Bit mask of PERBASE field.
	USBHS_PERIODICLISTBASE_PERBASE_Msk = 0xfffff000

	// ASYNCLISTADDR: Current Asynchronous List Address Register
	// Position of ASYBASE field.
	USBHS_ASYNCLISTADDR_ASYBASE_Pos = 0x5
	// Bit mask of ASYBASE field.
	USBHS_ASYNCLISTADDR_ASYBASE_Msk = 0xffffffe0

	// EPLISTADDR: Endpoint List Address Register
	// Position of EPBASE field.
	USBHS_EPLISTADDR_EPBASE_Pos = 0xb
	// Bit mask of EPBASE field.
	USBHS_EPLISTADDR_EPBASE_Msk = 0xfffff800

	// TTCTRL: Host TT Asynchronous Buffer Control
	// Position of TTHA field.
	USBHS_TTCTRL_TTHA_Pos = 0x18
	// Bit mask of TTHA field.
	USBHS_TTCTRL_TTHA_Msk = 0x7f000000
	// Position of Reerved field.
	USBHS_TTCTRL_Reerved_Pos = 0x1f
	// Bit mask of Reerved field.
	USBHS_TTCTRL_Reerved_Msk = 0x80000000
	// Bit Reerved.
	USBHS_TTCTRL_Reerved = 0x80000000

	// BURSTSIZE: Master Interface Data Burst Size Register
	// Position of RXPBURST field.
	USBHS_BURSTSIZE_RXPBURST_Pos = 0x0
	// Bit mask of RXPBURST field.
	USBHS_BURSTSIZE_RXPBURST_Msk = 0xff
	// Position of TXPBURST field.
	USBHS_BURSTSIZE_TXPBURST_Pos = 0x8
	// Bit mask of TXPBURST field.
	USBHS_BURSTSIZE_TXPBURST_Msk = 0xff00

	// TXFILLTUNING: Transmit FIFO Tuning Control Register
	// Position of TXSCHOH field.
	USBHS_TXFILLTUNING_TXSCHOH_Pos = 0x0
	// Bit mask of TXSCHOH field.
	USBHS_TXFILLTUNING_TXSCHOH_Msk = 0x7f
	// Position of TXSCHHEALTH field.
	USBHS_TXFILLTUNING_TXSCHHEALTH_Pos = 0x8
	// Bit mask of TXSCHHEALTH field.
	USBHS_TXFILLTUNING_TXSCHHEALTH_Msk = 0x1f00
	// Position of TXFIFOTHRES field.
	USBHS_TXFILLTUNING_TXFIFOTHRES_Pos = 0x10
	// Bit mask of TXFIFOTHRES field.
	USBHS_TXFILLTUNING_TXFIFOTHRES_Msk = 0x3f0000

	// ENDPTNAK: Endpoint NAK Register
	// Position of EPRN field.
	USBHS_ENDPTNAK_EPRN_Pos = 0x0
	// Bit mask of EPRN field.
	USBHS_ENDPTNAK_EPRN_Msk = 0xf
	// Position of EPTN field.
	USBHS_ENDPTNAK_EPTN_Pos = 0x10
	// Bit mask of EPTN field.
	USBHS_ENDPTNAK_EPTN_Msk = 0xf0000

	// ENDPTNAKEN: Endpoint NAK Enable Register
	// Position of EPRNE field.
	USBHS_ENDPTNAKEN_EPRNE_Pos = 0x0
	// Bit mask of EPRNE field.
	USBHS_ENDPTNAKEN_EPRNE_Msk = 0xf
	// Position of EPTNE field.
	USBHS_ENDPTNAKEN_EPTNE_Pos = 0x10
	// Bit mask of EPTNE field.
	USBHS_ENDPTNAKEN_EPTNE_Msk = 0xf0000

	// PORTSC1: Port Status and Control Registers
	// Position of CCS field.
	USBHS_PORTSC1_CCS_Pos = 0x0
	// Bit mask of CCS field.
	USBHS_PORTSC1_CCS_Msk = 0x1
	// Bit CCS.
	USBHS_PORTSC1_CCS = 0x1
	// No device present (host mode) or attached (device mode)
	USBHS_PORTSC1_CCS_0 = 0x0
	// Device is present (host mode) or attached (device mode)
	USBHS_PORTSC1_CCS_1 = 0x1
	// Position of CSC field.
	USBHS_PORTSC1_CSC_Pos = 0x1
	// Bit mask of CSC field.
	USBHS_PORTSC1_CSC_Msk = 0x2
	// Bit CSC.
	USBHS_PORTSC1_CSC = 0x2
	// No change
	USBHS_PORTSC1_CSC_0 = 0x0
	// Connect status has changed
	USBHS_PORTSC1_CSC_1 = 0x1
	// Position of PE field.
	USBHS_PORTSC1_PE_Pos = 0x2
	// Bit mask of PE field.
	USBHS_PORTSC1_PE_Msk = 0x4
	// Bit PE.
	USBHS_PORTSC1_PE = 0x4
	// Position of PEC field.
	USBHS_PORTSC1_PEC_Pos = 0x3
	// Bit mask of PEC field.
	USBHS_PORTSC1_PEC_Msk = 0x8
	// Bit PEC.
	USBHS_PORTSC1_PEC = 0x8
	// No change
	USBHS_PORTSC1_PEC_0 = 0x0
	// Port disabled
	USBHS_PORTSC1_PEC_1 = 0x1
	// Position of OCA field.
	USBHS_PORTSC1_OCA_Pos = 0x4
	// Bit mask of OCA field.
	USBHS_PORTSC1_OCA_Msk = 0x10
	// Bit OCA.
	USBHS_PORTSC1_OCA = 0x10
	// Port not in over-current condition
	USBHS_PORTSC1_OCA_0 = 0x0
	// Port currently in over-current condition
	USBHS_PORTSC1_OCA_1 = 0x1
	// Position of OCC field.
	USBHS_PORTSC1_OCC_Pos = 0x5
	// Bit mask of OCC field.
	USBHS_PORTSC1_OCC_Msk = 0x20
	// Bit OCC.
	USBHS_PORTSC1_OCC = 0x20
	// No over-current
	USBHS_PORTSC1_OCC_0 = 0x0
	// Over-current detect
	USBHS_PORTSC1_OCC_1 = 0x1
	// Position of FPR field.
	USBHS_PORTSC1_FPR_Pos = 0x6
	// Bit mask of FPR field.
	USBHS_PORTSC1_FPR_Msk = 0x40
	// Bit FPR.
	USBHS_PORTSC1_FPR = 0x40
	// No resume (K-state) detected/driven on port
	USBHS_PORTSC1_FPR_0 = 0x0
	// Resume detected/driven on port
	USBHS_PORTSC1_FPR_1 = 0x1
	// Position of SUSP field.
	USBHS_PORTSC1_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	USBHS_PORTSC1_SUSP_Msk = 0x80
	// Bit SUSP.
	USBHS_PORTSC1_SUSP = 0x80
	// Port not in suspend state
	USBHS_PORTSC1_SUSP_0 = 0x0
	// Port in suspend state
	USBHS_PORTSC1_SUSP_1 = 0x1
	// Position of PR field.
	USBHS_PORTSC1_PR_Pos = 0x8
	// Bit mask of PR field.
	USBHS_PORTSC1_PR_Msk = 0x100
	// Bit PR.
	USBHS_PORTSC1_PR = 0x100
	// Port is not in reset
	USBHS_PORTSC1_PR_0 = 0x0
	// Port is in reset
	USBHS_PORTSC1_PR_1 = 0x1
	// Position of HSP field.
	USBHS_PORTSC1_HSP_Pos = 0x9
	// Bit mask of HSP field.
	USBHS_PORTSC1_HSP_Msk = 0x200
	// Bit HSP.
	USBHS_PORTSC1_HSP = 0x200
	// FS or LS
	USBHS_PORTSC1_HSP_0 = 0x0
	// HS
	USBHS_PORTSC1_HSP_1 = 0x1
	// Position of LS field.
	USBHS_PORTSC1_LS_Pos = 0xa
	// Bit mask of LS field.
	USBHS_PORTSC1_LS_Msk = 0xc00
	// SE0
	USBHS_PORTSC1_LS_00 = 0x0
	// J-state
	USBHS_PORTSC1_LS_01 = 0x1
	// K-state
	USBHS_PORTSC1_LS_10 = 0x2
	// Undefined
	USBHS_PORTSC1_LS_11 = 0x3
	// Position of PP field.
	USBHS_PORTSC1_PP_Pos = 0xc
	// Bit mask of PP field.
	USBHS_PORTSC1_PP_Msk = 0x1000
	// Bit PP.
	USBHS_PORTSC1_PP = 0x1000
	// Position of PO field.
	USBHS_PORTSC1_PO_Pos = 0xd
	// Bit mask of PO field.
	USBHS_PORTSC1_PO_Msk = 0x2000
	// Bit PO.
	USBHS_PORTSC1_PO = 0x2000
	// Position of PIC field.
	USBHS_PORTSC1_PIC_Pos = 0xe
	// Bit mask of PIC field.
	USBHS_PORTSC1_PIC_Msk = 0xc000
	// Position of PTC field.
	USBHS_PORTSC1_PTC_Pos = 0x10
	// Bit mask of PTC field.
	USBHS_PORTSC1_PTC_Msk = 0xf0000
	// Not enabled
	USBHS_PORTSC1_PTC_0000 = 0x0
	// J_STATE
	USBHS_PORTSC1_PTC_0001 = 0x1
	// K_STATE
	USBHS_PORTSC1_PTC_0010 = 0x2
	// SE0_NAK
	USBHS_PORTSC1_PTC_0011 = 0x3
	// Packet
	USBHS_PORTSC1_PTC_0100 = 0x4
	// FORCE_ENABLE_HS
	USBHS_PORTSC1_PTC_0101 = 0x5
	// FORCE_ENABLE_FS
	USBHS_PORTSC1_PTC_0110 = 0x6
	// FORCE_ENABLE_LS
	USBHS_PORTSC1_PTC_0111 = 0x7
	// Position of WKCN field.
	USBHS_PORTSC1_WKCN_Pos = 0x14
	// Bit mask of WKCN field.
	USBHS_PORTSC1_WKCN_Msk = 0x100000
	// Bit WKCN.
	USBHS_PORTSC1_WKCN = 0x100000
	// Position of WKDS field.
	USBHS_PORTSC1_WKDS_Pos = 0x15
	// Bit mask of WKDS field.
	USBHS_PORTSC1_WKDS_Msk = 0x200000
	// Bit WKDS.
	USBHS_PORTSC1_WKDS = 0x200000
	// Position of WKOC field.
	USBHS_PORTSC1_WKOC_Pos = 0x16
	// Bit mask of WKOC field.
	USBHS_PORTSC1_WKOC_Msk = 0x400000
	// Bit WKOC.
	USBHS_PORTSC1_WKOC = 0x400000
	// Position of PHCD field.
	USBHS_PORTSC1_PHCD_Pos = 0x17
	// Bit mask of PHCD field.
	USBHS_PORTSC1_PHCD_Msk = 0x800000
	// Bit PHCD.
	USBHS_PORTSC1_PHCD = 0x800000
	// Position of PFSC field.
	USBHS_PORTSC1_PFSC_Pos = 0x18
	// Bit mask of PFSC field.
	USBHS_PORTSC1_PFSC_Msk = 0x1000000
	// Bit PFSC.
	USBHS_PORTSC1_PFSC = 0x1000000
	// Allow the port to identify itself as high speed
	USBHS_PORTSC1_PFSC_0 = 0x0
	// Force the port to only connect at full speed
	USBHS_PORTSC1_PFSC_1 = 0x1
	// Position of PTS2 field.
	USBHS_PORTSC1_PTS2_Pos = 0x19
	// Bit mask of PTS2 field.
	USBHS_PORTSC1_PTS2_Msk = 0x2000000
	// Bit PTS2.
	USBHS_PORTSC1_PTS2 = 0x2000000
	// Position of PSPD field.
	USBHS_PORTSC1_PSPD_Pos = 0x1a
	// Bit mask of PSPD field.
	USBHS_PORTSC1_PSPD_Msk = 0xc000000
	// Full speed
	USBHS_PORTSC1_PSPD_00 = 0x0
	// Low speed
	USBHS_PORTSC1_PSPD_01 = 0x1
	// High speed
	USBHS_PORTSC1_PSPD_10 = 0x2
	// Undefined
	USBHS_PORTSC1_PSPD_11 = 0x3
	// Position of PTS field.
	USBHS_PORTSC1_PTS_Pos = 0x1e
	// Bit mask of PTS field.
	USBHS_PORTSC1_PTS_Msk = 0xc0000000
	// Use UTMI transceiver interface.
	USBHS_PORTSC1_PTS_000 = 0x0

	// OTGSC: On-the-Go Status and Control Register
	// Position of VD field.
	USBHS_OTGSC_VD_Pos = 0x0
	// Bit mask of VD field.
	USBHS_OTGSC_VD_Msk = 0x1
	// Bit VD.
	USBHS_OTGSC_VD = 0x1
	// Position of VC field.
	USBHS_OTGSC_VC_Pos = 0x1
	// Bit mask of VC field.
	USBHS_OTGSC_VC_Msk = 0x2
	// Bit VC.
	USBHS_OTGSC_VC = 0x2
	// Position of HAAR field.
	USBHS_OTGSC_HAAR_Pos = 0x2
	// Bit mask of HAAR field.
	USBHS_OTGSC_HAAR_Msk = 0x4
	// Bit HAAR.
	USBHS_OTGSC_HAAR = 0x4
	// Disabled.
	USBHS_OTGSC_HAAR_0 = 0x0
	// Enable automatic reset after connect on host port.
	USBHS_OTGSC_HAAR_1 = 0x1
	// Position of OT field.
	USBHS_OTGSC_OT_Pos = 0x3
	// Bit mask of OT field.
	USBHS_OTGSC_OT_Msk = 0x8
	// Bit OT.
	USBHS_OTGSC_OT = 0x8
	// Disable pull-down on DM
	USBHS_OTGSC_OT_0 = 0x0
	// Enable pull-down on DM
	USBHS_OTGSC_OT_1 = 0x1
	// Position of DP field.
	USBHS_OTGSC_DP_Pos = 0x4
	// Bit mask of DP field.
	USBHS_OTGSC_DP_Msk = 0x10
	// Bit DP.
	USBHS_OTGSC_DP = 0x10
	// The pull-up on DP is not asserted
	USBHS_OTGSC_DP_0 = 0x0
	// The pull-up on DP is asserted for data pulsing during SRP
	USBHS_OTGSC_DP_1 = 0x1
	// Position of IDPU field.
	USBHS_OTGSC_IDPU_Pos = 0x5
	// Bit mask of IDPU field.
	USBHS_OTGSC_IDPU_Msk = 0x20
	// Bit IDPU.
	USBHS_OTGSC_IDPU = 0x20
	// Disable pull-up. ID input not sampled.
	USBHS_OTGSC_IDPU_0 = 0x0
	// Enable pull-up
	USBHS_OTGSC_IDPU_1 = 0x1
	// Position of HABA field.
	USBHS_OTGSC_HABA_Pos = 0x7
	// Bit mask of HABA field.
	USBHS_OTGSC_HABA_Msk = 0x80
	// Bit HABA.
	USBHS_OTGSC_HABA = 0x80
	// Disabled.
	USBHS_OTGSC_HABA_0 = 0x0
	// Enable automatic B-disconnect to A-connect sequence.
	USBHS_OTGSC_HABA_1 = 0x1
	// Position of ID field.
	USBHS_OTGSC_ID_Pos = 0x8
	// Bit mask of ID field.
	USBHS_OTGSC_ID_Msk = 0x100
	// Bit ID.
	USBHS_OTGSC_ID = 0x100
	// A device
	USBHS_OTGSC_ID_0 = 0x0
	// B device
	USBHS_OTGSC_ID_1 = 0x1
	// Position of AVV field.
	USBHS_OTGSC_AVV_Pos = 0x9
	// Bit mask of AVV field.
	USBHS_OTGSC_AVV_Msk = 0x200
	// Bit AVV.
	USBHS_OTGSC_AVV = 0x200
	// VBus is below A VBus valid threshold
	USBHS_OTGSC_AVV_0 = 0x0
	// VBus is above A VBus valid threshold
	USBHS_OTGSC_AVV_1 = 0x1
	// Position of ASV field.
	USBHS_OTGSC_ASV_Pos = 0xa
	// Bit mask of ASV field.
	USBHS_OTGSC_ASV_Msk = 0x400
	// Bit ASV.
	USBHS_OTGSC_ASV = 0x400
	// VBus is below A session valid threshold
	USBHS_OTGSC_ASV_0 = 0x0
	// VBus is above A session valid threshold
	USBHS_OTGSC_ASV_1 = 0x1
	// Position of BSV field.
	USBHS_OTGSC_BSV_Pos = 0xb
	// Bit mask of BSV field.
	USBHS_OTGSC_BSV_Msk = 0x800
	// Bit BSV.
	USBHS_OTGSC_BSV = 0x800
	// VBus is below B session valid threshold
	USBHS_OTGSC_BSV_0 = 0x0
	// VBus is above B session valid threshold
	USBHS_OTGSC_BSV_1 = 0x1
	// Position of BSE field.
	USBHS_OTGSC_BSE_Pos = 0xc
	// Bit mask of BSE field.
	USBHS_OTGSC_BSE_Msk = 0x1000
	// Bit BSE.
	USBHS_OTGSC_BSE = 0x1000
	// VBus is above B session end threshold
	USBHS_OTGSC_BSE_0 = 0x0
	// VBus is below B session end threshold
	USBHS_OTGSC_BSE_1 = 0x1
	// Position of MST field.
	USBHS_OTGSC_MST_Pos = 0xd
	// Bit mask of MST field.
	USBHS_OTGSC_MST_Msk = 0x2000
	// Bit MST.
	USBHS_OTGSC_MST = 0x2000
	// Position of DPS field.
	USBHS_OTGSC_DPS_Pos = 0xe
	// Bit mask of DPS field.
	USBHS_OTGSC_DPS_Msk = 0x4000
	// Bit DPS.
	USBHS_OTGSC_DPS = 0x4000
	// No pulsing on port
	USBHS_OTGSC_DPS_0 = 0x0
	// Pulsing detected on port
	USBHS_OTGSC_DPS_1 = 0x1
	// Position of IDIS field.
	USBHS_OTGSC_IDIS_Pos = 0x10
	// Bit mask of IDIS field.
	USBHS_OTGSC_IDIS_Msk = 0x10000
	// Bit IDIS.
	USBHS_OTGSC_IDIS = 0x10000
	// Position of AVVIS field.
	USBHS_OTGSC_AVVIS_Pos = 0x11
	// Bit mask of AVVIS field.
	USBHS_OTGSC_AVVIS_Msk = 0x20000
	// Bit AVVIS.
	USBHS_OTGSC_AVVIS = 0x20000
	// Position of ASVIS field.
	USBHS_OTGSC_ASVIS_Pos = 0x12
	// Bit mask of ASVIS field.
	USBHS_OTGSC_ASVIS_Msk = 0x40000
	// Bit ASVIS.
	USBHS_OTGSC_ASVIS = 0x40000
	// Position of BSVIS field.
	USBHS_OTGSC_BSVIS_Pos = 0x13
	// Bit mask of BSVIS field.
	USBHS_OTGSC_BSVIS_Msk = 0x80000
	// Bit BSVIS.
	USBHS_OTGSC_BSVIS = 0x80000
	// Position of BSEIS field.
	USBHS_OTGSC_BSEIS_Pos = 0x14
	// Bit mask of BSEIS field.
	USBHS_OTGSC_BSEIS_Msk = 0x100000
	// Bit BSEIS.
	USBHS_OTGSC_BSEIS = 0x100000
	// Position of MSS field.
	USBHS_OTGSC_MSS_Pos = 0x15
	// Bit mask of MSS field.
	USBHS_OTGSC_MSS_Msk = 0x200000
	// Bit MSS.
	USBHS_OTGSC_MSS = 0x200000
	// Position of DPIS field.
	USBHS_OTGSC_DPIS_Pos = 0x16
	// Bit mask of DPIS field.
	USBHS_OTGSC_DPIS_Msk = 0x400000
	// Bit DPIS.
	USBHS_OTGSC_DPIS = 0x400000
	// Position of IDIE field.
	USBHS_OTGSC_IDIE_Pos = 0x18
	// Bit mask of IDIE field.
	USBHS_OTGSC_IDIE_Msk = 0x1000000
	// Bit IDIE.
	USBHS_OTGSC_IDIE = 0x1000000
	// Disable
	USBHS_OTGSC_IDIE_0 = 0x0
	// Enable
	USBHS_OTGSC_IDIE_1 = 0x1
	// Position of AVVIE field.
	USBHS_OTGSC_AVVIE_Pos = 0x19
	// Bit mask of AVVIE field.
	USBHS_OTGSC_AVVIE_Msk = 0x2000000
	// Bit AVVIE.
	USBHS_OTGSC_AVVIE = 0x2000000
	// Disable
	USBHS_OTGSC_AVVIE_0 = 0x0
	// Enable
	USBHS_OTGSC_AVVIE_1 = 0x1
	// Position of ASVIE field.
	USBHS_OTGSC_ASVIE_Pos = 0x1a
	// Bit mask of ASVIE field.
	USBHS_OTGSC_ASVIE_Msk = 0x4000000
	// Bit ASVIE.
	USBHS_OTGSC_ASVIE = 0x4000000
	// Disable
	USBHS_OTGSC_ASVIE_0 = 0x0
	// Enable
	USBHS_OTGSC_ASVIE_1 = 0x1
	// Position of BSVIE field.
	USBHS_OTGSC_BSVIE_Pos = 0x1b
	// Bit mask of BSVIE field.
	USBHS_OTGSC_BSVIE_Msk = 0x8000000
	// Bit BSVIE.
	USBHS_OTGSC_BSVIE = 0x8000000
	// Disable
	USBHS_OTGSC_BSVIE_0 = 0x0
	// Enable
	USBHS_OTGSC_BSVIE_1 = 0x1
	// Position of BSEIE field.
	USBHS_OTGSC_BSEIE_Pos = 0x1c
	// Bit mask of BSEIE field.
	USBHS_OTGSC_BSEIE_Msk = 0x10000000
	// Bit BSEIE.
	USBHS_OTGSC_BSEIE = 0x10000000
	// Disable
	USBHS_OTGSC_BSEIE_0 = 0x0
	// Enable
	USBHS_OTGSC_BSEIE_1 = 0x1
	// Position of MSE field.
	USBHS_OTGSC_MSE_Pos = 0x1d
	// Bit mask of MSE field.
	USBHS_OTGSC_MSE_Msk = 0x20000000
	// Bit MSE.
	USBHS_OTGSC_MSE = 0x20000000
	// Disable
	USBHS_OTGSC_MSE_0 = 0x0
	// Enable
	USBHS_OTGSC_MSE_1 = 0x1
	// Position of DPIE field.
	USBHS_OTGSC_DPIE_Pos = 0x1e
	// Bit mask of DPIE field.
	USBHS_OTGSC_DPIE_Msk = 0x40000000
	// Bit DPIE.
	USBHS_OTGSC_DPIE = 0x40000000
	// Disable
	USBHS_OTGSC_DPIE_0 = 0x0
	// Enable
	USBHS_OTGSC_DPIE_1 = 0x1

	// USBMODE: USB Mode Register
	// Position of CM field.
	USBHS_USBMODE_CM_Pos = 0x0
	// Bit mask of CM field.
	USBHS_USBMODE_CM_Msk = 0x3
	// Idle (default for the USBHS module)
	USBHS_USBMODE_CM_00 = 0x0
	// Device controller
	USBHS_USBMODE_CM_10 = 0x2
	// Host controller
	USBHS_USBMODE_CM_11 = 0x3
	// Position of ES field.
	USBHS_USBMODE_ES_Pos = 0x2
	// Bit mask of ES field.
	USBHS_USBMODE_ES_Msk = 0x4
	// Bit ES.
	USBHS_USBMODE_ES = 0x4
	// Little endian. First byte referenced in least significant byte of 32-bit word.
	USBHS_USBMODE_ES_0 = 0x0
	// Big endian. First byte referenced in most significant byte of 32-bit word.
	USBHS_USBMODE_ES_1 = 0x1
	// Position of SLOM field.
	USBHS_USBMODE_SLOM_Pos = 0x3
	// Bit mask of SLOM field.
	USBHS_USBMODE_SLOM_Msk = 0x8
	// Bit SLOM.
	USBHS_USBMODE_SLOM = 0x8
	// Position of SDIS field.
	USBHS_USBMODE_SDIS_Pos = 0x4
	// Bit mask of SDIS field.
	USBHS_USBMODE_SDIS_Msk = 0x10
	// Bit SDIS.
	USBHS_USBMODE_SDIS = 0x10
	// Inactive
	USBHS_USBMODE_SDIS_0 = 0x0
	// Active
	USBHS_USBMODE_SDIS_1 = 0x1
	// Position of TXHSD field.
	USBHS_USBMODE_TXHSD_Pos = 0xc
	// Bit mask of TXHSD field.
	USBHS_USBMODE_TXHSD_Msk = 0x7000
	// 10
	USBHS_USBMODE_TXHSD_000 = 0x0
	// 11
	USBHS_USBMODE_TXHSD_001 = 0x1
	// 12
	USBHS_USBMODE_TXHSD_010 = 0x2
	// 13
	USBHS_USBMODE_TXHSD_011 = 0x3
	// 14
	USBHS_USBMODE_TXHSD_100 = 0x4
	// 15
	USBHS_USBMODE_TXHSD_101 = 0x5
	// 16
	USBHS_USBMODE_TXHSD_110 = 0x6
	// 17
	USBHS_USBMODE_TXHSD_111 = 0x7

	// EPSETUPSR: Endpoint Setup Status Register
	// Position of EPSETUPSTAT field.
	USBHS_EPSETUPSR_EPSETUPSTAT_Pos = 0x0
	// Bit mask of EPSETUPSTAT field.
	USBHS_EPSETUPSR_EPSETUPSTAT_Msk = 0xf

	// EPPRIME: Endpoint Initialization Register
	// Position of PERB field.
	USBHS_EPPRIME_PERB_Pos = 0x0
	// Bit mask of PERB field.
	USBHS_EPPRIME_PERB_Msk = 0xf
	// Position of PETB field.
	USBHS_EPPRIME_PETB_Pos = 0x10
	// Bit mask of PETB field.
	USBHS_EPPRIME_PETB_Msk = 0xf0000

	// EPFLUSH: Endpoint Flush Register
	// Position of FERB field.
	USBHS_EPFLUSH_FERB_Pos = 0x0
	// Bit mask of FERB field.
	USBHS_EPFLUSH_FERB_Msk = 0xf
	// Position of FETB field.
	USBHS_EPFLUSH_FETB_Pos = 0x10
	// Bit mask of FETB field.
	USBHS_EPFLUSH_FETB_Msk = 0xf0000

	// EPSR: Endpoint Status Register
	// Position of ERBR field.
	USBHS_EPSR_ERBR_Pos = 0x0
	// Bit mask of ERBR field.
	USBHS_EPSR_ERBR_Msk = 0xf
	// Position of ETBR field.
	USBHS_EPSR_ETBR_Pos = 0x10
	// Bit mask of ETBR field.
	USBHS_EPSR_ETBR_Msk = 0xf0000

	// EPCOMPLETE: Endpoint Complete Register
	// Position of ERCE field.
	USBHS_EPCOMPLETE_ERCE_Pos = 0x0
	// Bit mask of ERCE field.
	USBHS_EPCOMPLETE_ERCE_Msk = 0xf
	// Position of ETCE field.
	USBHS_EPCOMPLETE_ETCE_Pos = 0x10
	// Bit mask of ETCE field.
	USBHS_EPCOMPLETE_ETCE_Msk = 0xf0000

	// EPCR0: Endpoint Control Register 0
	// Position of RXS field.
	USBHS_EPCR0_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USBHS_EPCR0_RXS_Msk = 0x1
	// Bit RXS.
	USBHS_EPCR0_RXS = 0x1
	// Endpoint OK
	USBHS_EPCR0_RXS_0 = 0x0
	// Endpoint stalled
	USBHS_EPCR0_RXS_1 = 0x1
	// Position of RXT field.
	USBHS_EPCR0_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USBHS_EPCR0_RXT_Msk = 0xc
	// Control
	USBHS_EPCR0_RXT_00 = 0x0
	// Position of RXE field.
	USBHS_EPCR0_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USBHS_EPCR0_RXE_Msk = 0x80
	// Bit RXE.
	USBHS_EPCR0_RXE = 0x80
	// Enabled
	USBHS_EPCR0_RXE_1 = 0x1
	// Position of TXS field.
	USBHS_EPCR0_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USBHS_EPCR0_TXS_Msk = 0x10000
	// Bit TXS.
	USBHS_EPCR0_TXS = 0x10000
	// Endpoint OK
	USBHS_EPCR0_TXS_0 = 0x0
	// Endpoint stalled
	USBHS_EPCR0_TXS_1 = 0x1
	// Position of TXT field.
	USBHS_EPCR0_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USBHS_EPCR0_TXT_Msk = 0xc0000
	// Control
	USBHS_EPCR0_TXT_00 = 0x0
	// Position of TXE field.
	USBHS_EPCR0_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USBHS_EPCR0_TXE_Msk = 0x800000
	// Bit TXE.
	USBHS_EPCR0_TXE = 0x800000
	// Enable
	USBHS_EPCR0_TXE_1 = 0x1

	// EPCR1: Endpoint Control Register n
	// Position of RXS field.
	USBHS_EPCR_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USBHS_EPCR_RXS_Msk = 0x1
	// Bit RXS.
	USBHS_EPCR_RXS = 0x1
	// Endpoint OK
	USBHS_EPCR_RXS_0 = 0x0
	// Endpoint stalled
	USBHS_EPCR_RXS_1 = 0x1
	// Position of RXD field.
	USBHS_EPCR_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USBHS_EPCR_RXD_Msk = 0x2
	// Bit RXD.
	USBHS_EPCR_RXD = 0x2
	// Position of RXT field.
	USBHS_EPCR_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USBHS_EPCR_RXT_Msk = 0xc
	// Control
	USBHS_EPCR_RXT_00 = 0x0
	// Isochronous
	USBHS_EPCR_RXT_01 = 0x1
	// Bulk
	USBHS_EPCR_RXT_10 = 0x2
	// Interrupt
	USBHS_EPCR_RXT_11 = 0x3
	// Position of RXI field.
	USBHS_EPCR_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USBHS_EPCR_RXI_Msk = 0x20
	// Bit RXI.
	USBHS_EPCR_RXI = 0x20
	// PID sequencing enabled
	USBHS_EPCR_RXI_0 = 0x0
	// PID sequencing disabled
	USBHS_EPCR_RXI_1 = 0x1
	// Position of RXR field.
	USBHS_EPCR_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USBHS_EPCR_RXR_Msk = 0x40
	// Bit RXR.
	USBHS_EPCR_RXR = 0x40
	// Position of RXE field.
	USBHS_EPCR_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USBHS_EPCR_RXE_Msk = 0x80
	// Bit RXE.
	USBHS_EPCR_RXE = 0x80
	// Disabled
	USBHS_EPCR_RXE_0 = 0x0
	// Enabled
	USBHS_EPCR_RXE_1 = 0x1
	// Position of TXS field.
	USBHS_EPCR_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USBHS_EPCR_TXS_Msk = 0x10000
	// Bit TXS.
	USBHS_EPCR_TXS = 0x10000
	// Endpoint OK
	USBHS_EPCR_TXS_0 = 0x0
	// Endpoint stalled
	USBHS_EPCR_TXS_1 = 0x1
	// Position of TXD field.
	USBHS_EPCR_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USBHS_EPCR_TXD_Msk = 0x20000
	// Bit TXD.
	USBHS_EPCR_TXD = 0x20000
	// Position of TXT field.
	USBHS_EPCR_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USBHS_EPCR_TXT_Msk = 0xc0000
	// Control
	USBHS_EPCR_TXT_00 = 0x0
	// Isochronous
	USBHS_EPCR_TXT_01 = 0x1
	// Bulk
	USBHS_EPCR_TXT_10 = 0x2
	// Interrupt
	USBHS_EPCR_TXT_11 = 0x3
	// Position of TXI field.
	USBHS_EPCR_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USBHS_EPCR_TXI_Msk = 0x200000
	// Bit TXI.
	USBHS_EPCR_TXI = 0x200000
	// PID sequencing enabled
	USBHS_EPCR_TXI_0 = 0x0
	// PID sequencing disabled
	USBHS_EPCR_TXI_1 = 0x1
	// Position of TXR field.
	USBHS_EPCR_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USBHS_EPCR_TXR_Msk = 0x400000
	// Bit TXR.
	USBHS_EPCR_TXR = 0x400000
	// Position of TXE field.
	USBHS_EPCR_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USBHS_EPCR_TXE_Msk = 0x800000
	// Bit TXE.
	USBHS_EPCR_TXE = 0x800000
	// Disabled
	USBHS_EPCR_TXE_0 = 0x0
	// Enabled
	USBHS_EPCR_TXE_1 = 0x1

	// USBGENCTRL: USB General Control Register
	// Position of WU_IE field.
	USBHS_USBGENCTRL_WU_IE_Pos = 0x0
	// Bit mask of WU_IE field.
	USBHS_USBGENCTRL_WU_IE_Msk = 0x1
	// Bit WU_IE.
	USBHS_USBGENCTRL_WU_IE = 0x1
	// Disabled
	USBHS_USBGENCTRL_WU_IE_0 = 0x0
	// Enabled
	USBHS_USBGENCTRL_WU_IE_1 = 0x1
	// Position of WU_INT_CLR field.
	USBHS_USBGENCTRL_WU_INT_CLR_Pos = 0x5
	// Bit mask of WU_INT_CLR field.
	USBHS_USBGENCTRL_WU_INT_CLR_Msk = 0x20
	// Bit WU_INT_CLR.
	USBHS_USBGENCTRL_WU_INT_CLR = 0x20
	// Default, no action.
	USBHS_USBGENCTRL_WU_INT_CLR_0 = 0x0
	// Clear the wake-up interrupt.
	USBHS_USBGENCTRL_WU_INT_CLR_1 = 0x1
)

// Constants for USBPHY: USBPHY Register Reference Index
const (
	// PWD: USB PHY Power-Down Register
	// Position of TXPWDFS field.
	USBPHY_PWD_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_TXPWDFS = 0x400
	// Normal operation.
	USBPHY_PWD_TXPWDFS_0 = 0x0
	// Power-down the USB full-speed drivers. This turns off the current starvation sources and puts the drivers into high-impedance output
	USBPHY_PWD_TXPWDFS_1 = 0x1
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_TXPWDIBIAS = 0x800
	// Normal operation
	USBPHY_PWD_TXPWDIBIAS_0 = 0x0
	// Power-down the USB PHY current bias block for the transmitter. This bit should be set only when the USB is in suspend mode. This effectively powers down the entire USB transmit path
	USBPHY_PWD_TXPWDIBIAS_1 = 0x1
	// Position of TXPWDV2I field.
	USBPHY_PWD_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_TXPWDV2I = 0x1000
	// Normal operation.
	USBPHY_PWD_TXPWDV2I_0 = 0x0
	// Power-down the USB PHY transmit V-to-I converter and the current mirror
	USBPHY_PWD_TXPWDV2I_1 = 0x1
	// Position of RXPWDENV field.
	USBPHY_PWD_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_RXPWDENV = 0x20000
	// Normal operation.
	USBPHY_PWD_RXPWDENV_0 = 0x0
	// Power-down the USB high-speed receiver envelope detector (squelch signal)
	USBPHY_PWD_RXPWDENV_1 = 0x1
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_RXPWD1PT1 = 0x40000
	// Normal operation
	USBPHY_PWD_RXPWD1PT1_0 = 0x0
	// Power-down the USB full-speed differential receiver.
	USBPHY_PWD_RXPWD1PT1_1 = 0x1
	// Position of RXPWDDIFF field.
	USBPHY_PWD_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_RXPWDDIFF = 0x80000
	// Normal operation.
	USBPHY_PWD_RXPWDDIFF_0 = 0x0
	// Power-down the USB high-speed differential receiver
	USBPHY_PWD_RXPWDDIFF_1 = 0x1
	// Position of RXPWDRX field.
	USBPHY_PWD_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_RXPWDRX = 0x100000
	// Normal operation
	USBPHY_PWD_RXPWDRX_0 = 0x0
	// Power-down the entire USB PHY receiver block except for the full-speed differential receiver
	USBPHY_PWD_RXPWDRX_1 = 0x1

	// PWD_SET: USB PHY Power-Down Register
	// Position of TXPWDFS field.
	USBPHY_PWD_SET_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_SET_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_SET_TXPWDFS = 0x400
	// Normal operation.
	USBPHY_PWD_SET_TXPWDFS_0 = 0x0
	// Power-down the USB full-speed drivers. This turns off the current starvation sources and puts the drivers into high-impedance output
	USBPHY_PWD_SET_TXPWDFS_1 = 0x1
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_SET_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_SET_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_SET_TXPWDIBIAS = 0x800
	// Normal operation
	USBPHY_PWD_SET_TXPWDIBIAS_0 = 0x0
	// Power-down the USB PHY current bias block for the transmitter. This bit should be set only when the USB is in suspend mode. This effectively powers down the entire USB transmit path
	USBPHY_PWD_SET_TXPWDIBIAS_1 = 0x1
	// Position of TXPWDV2I field.
	USBPHY_PWD_SET_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_SET_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_SET_TXPWDV2I = 0x1000
	// Normal operation.
	USBPHY_PWD_SET_TXPWDV2I_0 = 0x0
	// Power-down the USB PHY transmit V-to-I converter and the current mirror
	USBPHY_PWD_SET_TXPWDV2I_1 = 0x1
	// Position of RXPWDENV field.
	USBPHY_PWD_SET_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_SET_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_SET_RXPWDENV = 0x20000
	// Normal operation.
	USBPHY_PWD_SET_RXPWDENV_0 = 0x0
	// Power-down the USB high-speed receiver envelope detector (squelch signal)
	USBPHY_PWD_SET_RXPWDENV_1 = 0x1
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_SET_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_SET_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_SET_RXPWD1PT1 = 0x40000
	// Normal operation
	USBPHY_PWD_SET_RXPWD1PT1_0 = 0x0
	// Power-down the USB full-speed differential receiver.
	USBPHY_PWD_SET_RXPWD1PT1_1 = 0x1
	// Position of RXPWDDIFF field.
	USBPHY_PWD_SET_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_SET_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_SET_RXPWDDIFF = 0x80000
	// Normal operation.
	USBPHY_PWD_SET_RXPWDDIFF_0 = 0x0
	// Power-down the USB high-speed differential receiver
	USBPHY_PWD_SET_RXPWDDIFF_1 = 0x1
	// Position of RXPWDRX field.
	USBPHY_PWD_SET_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_SET_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_SET_RXPWDRX = 0x100000
	// Normal operation
	USBPHY_PWD_SET_RXPWDRX_0 = 0x0
	// Power-down the entire USB PHY receiver block except for the full-speed differential receiver
	USBPHY_PWD_SET_RXPWDRX_1 = 0x1

	// PWD_CLR: USB PHY Power-Down Register
	// Position of TXPWDFS field.
	USBPHY_PWD_CLR_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_CLR_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_CLR_TXPWDFS = 0x400
	// Normal operation.
	USBPHY_PWD_CLR_TXPWDFS_0 = 0x0
	// Power-down the USB full-speed drivers. This turns off the current starvation sources and puts the drivers into high-impedance output
	USBPHY_PWD_CLR_TXPWDFS_1 = 0x1
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_CLR_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_CLR_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_CLR_TXPWDIBIAS = 0x800
	// Normal operation
	USBPHY_PWD_CLR_TXPWDIBIAS_0 = 0x0
	// Power-down the USB PHY current bias block for the transmitter. This bit should be set only when the USB is in suspend mode. This effectively powers down the entire USB transmit path
	USBPHY_PWD_CLR_TXPWDIBIAS_1 = 0x1
	// Position of TXPWDV2I field.
	USBPHY_PWD_CLR_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_CLR_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_CLR_TXPWDV2I = 0x1000
	// Normal operation.
	USBPHY_PWD_CLR_TXPWDV2I_0 = 0x0
	// Power-down the USB PHY transmit V-to-I converter and the current mirror
	USBPHY_PWD_CLR_TXPWDV2I_1 = 0x1
	// Position of RXPWDENV field.
	USBPHY_PWD_CLR_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_CLR_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_CLR_RXPWDENV = 0x20000
	// Normal operation.
	USBPHY_PWD_CLR_RXPWDENV_0 = 0x0
	// Power-down the USB high-speed receiver envelope detector (squelch signal)
	USBPHY_PWD_CLR_RXPWDENV_1 = 0x1
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_CLR_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_CLR_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_CLR_RXPWD1PT1 = 0x40000
	// Normal operation
	USBPHY_PWD_CLR_RXPWD1PT1_0 = 0x0
	// Power-down the USB full-speed differential receiver.
	USBPHY_PWD_CLR_RXPWD1PT1_1 = 0x1
	// Position of RXPWDDIFF field.
	USBPHY_PWD_CLR_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_CLR_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_CLR_RXPWDDIFF = 0x80000
	// Normal operation.
	USBPHY_PWD_CLR_RXPWDDIFF_0 = 0x0
	// Power-down the USB high-speed differential receiver
	USBPHY_PWD_CLR_RXPWDDIFF_1 = 0x1
	// Position of RXPWDRX field.
	USBPHY_PWD_CLR_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_CLR_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_CLR_RXPWDRX = 0x100000
	// Normal operation
	USBPHY_PWD_CLR_RXPWDRX_0 = 0x0
	// Power-down the entire USB PHY receiver block except for the full-speed differential receiver
	USBPHY_PWD_CLR_RXPWDRX_1 = 0x1

	// PWD_TOG: USB PHY Power-Down Register
	// Position of TXPWDFS field.
	USBPHY_PWD_TOG_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_TOG_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_TOG_TXPWDFS = 0x400
	// Normal operation.
	USBPHY_PWD_TOG_TXPWDFS_0 = 0x0
	// Power-down the USB full-speed drivers. This turns off the current starvation sources and puts the drivers into high-impedance output
	USBPHY_PWD_TOG_TXPWDFS_1 = 0x1
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_TOG_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_TOG_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_TOG_TXPWDIBIAS = 0x800
	// Normal operation
	USBPHY_PWD_TOG_TXPWDIBIAS_0 = 0x0
	// Power-down the USB PHY current bias block for the transmitter. This bit should be set only when the USB is in suspend mode. This effectively powers down the entire USB transmit path
	USBPHY_PWD_TOG_TXPWDIBIAS_1 = 0x1
	// Position of TXPWDV2I field.
	USBPHY_PWD_TOG_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_TOG_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_TOG_TXPWDV2I = 0x1000
	// Normal operation.
	USBPHY_PWD_TOG_TXPWDV2I_0 = 0x0
	// Power-down the USB PHY transmit V-to-I converter and the current mirror
	USBPHY_PWD_TOG_TXPWDV2I_1 = 0x1
	// Position of RXPWDENV field.
	USBPHY_PWD_TOG_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_TOG_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_TOG_RXPWDENV = 0x20000
	// Normal operation.
	USBPHY_PWD_TOG_RXPWDENV_0 = 0x0
	// Power-down the USB high-speed receiver envelope detector (squelch signal)
	USBPHY_PWD_TOG_RXPWDENV_1 = 0x1
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_TOG_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_TOG_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_TOG_RXPWD1PT1 = 0x40000
	// Normal operation
	USBPHY_PWD_TOG_RXPWD1PT1_0 = 0x0
	// Power-down the USB full-speed differential receiver.
	USBPHY_PWD_TOG_RXPWD1PT1_1 = 0x1
	// Position of RXPWDDIFF field.
	USBPHY_PWD_TOG_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_TOG_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_TOG_RXPWDDIFF = 0x80000
	// Normal operation.
	USBPHY_PWD_TOG_RXPWDDIFF_0 = 0x0
	// Power-down the USB high-speed differential receiver
	USBPHY_PWD_TOG_RXPWDDIFF_1 = 0x1
	// Position of RXPWDRX field.
	USBPHY_PWD_TOG_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_TOG_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_TOG_RXPWDRX = 0x100000
	// Normal operation
	USBPHY_PWD_TOG_RXPWDRX_0 = 0x0
	// Power-down the entire USB PHY receiver block except for the full-speed differential receiver
	USBPHY_PWD_TOG_RXPWDRX_1 = 0x1

	// TX: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_D_CAL_Msk = 0xf
	// Maximum current, approximately 19% above nominal.
	USBPHY_TX_D_CAL_0000 = 0x0
	// Nominal
	USBPHY_TX_D_CAL_0111 = 0x7
	// Minimum current, approximately 19% below nominal.
	USBPHY_TX_D_CAL_1111 = 0xf
	// Position of TXCAL45DM field.
	USBPHY_TX_TXCAL45DM_Pos = 0x8
	// Bit mask of TXCAL45DM field.
	USBPHY_TX_TXCAL45DM_Msk = 0xf00
	// Position of TXCAL45DP field.
	USBPHY_TX_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_TXCAL45DP_Msk = 0xf0000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_USBPHY_TX_EDGECTRL_Msk = 0x1c000000

	// TX_SET: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_SET_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_SET_D_CAL_Msk = 0xf
	// Maximum current, approximately 19% above nominal.
	USBPHY_TX_SET_D_CAL_0000 = 0x0
	// Nominal
	USBPHY_TX_SET_D_CAL_0111 = 0x7
	// Minimum current, approximately 19% below nominal.
	USBPHY_TX_SET_D_CAL_1111 = 0xf
	// Position of TXCAL45DM field.
	USBPHY_TX_SET_TXCAL45DM_Pos = 0x8
	// Bit mask of TXCAL45DM field.
	USBPHY_TX_SET_TXCAL45DM_Msk = 0xf00
	// Position of TXCAL45DP field.
	USBPHY_TX_SET_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_SET_TXCAL45DP_Msk = 0xf0000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_SET_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_SET_USBPHY_TX_EDGECTRL_Msk = 0x1c000000

	// TX_CLR: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_CLR_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_CLR_D_CAL_Msk = 0xf
	// Maximum current, approximately 19% above nominal.
	USBPHY_TX_CLR_D_CAL_0000 = 0x0
	// Nominal
	USBPHY_TX_CLR_D_CAL_0111 = 0x7
	// Minimum current, approximately 19% below nominal.
	USBPHY_TX_CLR_D_CAL_1111 = 0xf
	// Position of TXCAL45DM field.
	USBPHY_TX_CLR_TXCAL45DM_Pos = 0x8
	// Bit mask of TXCAL45DM field.
	USBPHY_TX_CLR_TXCAL45DM_Msk = 0xf00
	// Position of TXCAL45DP field.
	USBPHY_TX_CLR_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_CLR_TXCAL45DP_Msk = 0xf0000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_CLR_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_CLR_USBPHY_TX_EDGECTRL_Msk = 0x1c000000

	// TX_TOG: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_TOG_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_TOG_D_CAL_Msk = 0xf
	// Maximum current, approximately 19% above nominal.
	USBPHY_TX_TOG_D_CAL_0000 = 0x0
	// Nominal
	USBPHY_TX_TOG_D_CAL_0111 = 0x7
	// Minimum current, approximately 19% below nominal.
	USBPHY_TX_TOG_D_CAL_1111 = 0xf
	// Position of TXCAL45DM field.
	USBPHY_TX_TOG_TXCAL45DM_Pos = 0x8
	// Bit mask of TXCAL45DM field.
	USBPHY_TX_TOG_TXCAL45DM_Msk = 0xf00
	// Position of TXCAL45DP field.
	USBPHY_TX_TOG_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_TOG_TXCAL45DP_Msk = 0xf0000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_TOG_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_TOG_USBPHY_TX_EDGECTRL_Msk = 0x1c000000

	// RX: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_ENVADJ_Msk = 0x7
	// Trip-Level Voltage is 0.1000 V
	USBPHY_RX_ENVADJ_000 = 0x0
	// Trip-Level Voltage is 0.1125 V
	USBPHY_RX_ENVADJ_001 = 0x1
	// Trip-Level Voltage is 0.1250 V
	USBPHY_RX_ENVADJ_010 = 0x2
	// Trip-Level Voltage is 0.0875 V
	USBPHY_RX_ENVADJ_011 = 0x3
	// Position of DISCONADJ field.
	USBPHY_RX_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_DISCONADJ_Msk = 0x70
	// Trip-Level Voltage is 0.56875 V
	USBPHY_RX_DISCONADJ_000 = 0x0
	// Trip-Level Voltage is 0.55000 V
	USBPHY_RX_DISCONADJ_001 = 0x1
	// Trip-Level Voltage is 0.58125 V
	USBPHY_RX_DISCONADJ_010 = 0x2
	// Trip-Level Voltage is 0.60000 V
	USBPHY_RX_DISCONADJ_011 = 0x3
	// Position of RXDBYPASS field.
	USBPHY_RX_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_RXDBYPASS = 0x400000
	// Normal operation.
	USBPHY_RX_RXDBYPASS_0 = 0x0
	// Use the output of the USB_DP single-ended receiver in place of the full-speed differential receiver
	USBPHY_RX_RXDBYPASS_1 = 0x1

	// RX_SET: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_SET_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_SET_ENVADJ_Msk = 0x7
	// Trip-Level Voltage is 0.1000 V
	USBPHY_RX_SET_ENVADJ_000 = 0x0
	// Trip-Level Voltage is 0.1125 V
	USBPHY_RX_SET_ENVADJ_001 = 0x1
	// Trip-Level Voltage is 0.1250 V
	USBPHY_RX_SET_ENVADJ_010 = 0x2
	// Trip-Level Voltage is 0.0875 V
	USBPHY_RX_SET_ENVADJ_011 = 0x3
	// Position of DISCONADJ field.
	USBPHY_RX_SET_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_SET_DISCONADJ_Msk = 0x70
	// Trip-Level Voltage is 0.56875 V
	USBPHY_RX_SET_DISCONADJ_000 = 0x0
	// Trip-Level Voltage is 0.55000 V
	USBPHY_RX_SET_DISCONADJ_001 = 0x1
	// Trip-Level Voltage is 0.58125 V
	USBPHY_RX_SET_DISCONADJ_010 = 0x2
	// Trip-Level Voltage is 0.60000 V
	USBPHY_RX_SET_DISCONADJ_011 = 0x3
	// Position of RXDBYPASS field.
	USBPHY_RX_SET_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_SET_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_SET_RXDBYPASS = 0x400000
	// Normal operation.
	USBPHY_RX_SET_RXDBYPASS_0 = 0x0
	// Use the output of the USB_DP single-ended receiver in place of the full-speed differential receiver
	USBPHY_RX_SET_RXDBYPASS_1 = 0x1

	// RX_CLR: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_CLR_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_CLR_ENVADJ_Msk = 0x7
	// Trip-Level Voltage is 0.1000 V
	USBPHY_RX_CLR_ENVADJ_000 = 0x0
	// Trip-Level Voltage is 0.1125 V
	USBPHY_RX_CLR_ENVADJ_001 = 0x1
	// Trip-Level Voltage is 0.1250 V
	USBPHY_RX_CLR_ENVADJ_010 = 0x2
	// Trip-Level Voltage is 0.0875 V
	USBPHY_RX_CLR_ENVADJ_011 = 0x3
	// Position of DISCONADJ field.
	USBPHY_RX_CLR_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_CLR_DISCONADJ_Msk = 0x70
	// Trip-Level Voltage is 0.56875 V
	USBPHY_RX_CLR_DISCONADJ_000 = 0x0
	// Trip-Level Voltage is 0.55000 V
	USBPHY_RX_CLR_DISCONADJ_001 = 0x1
	// Trip-Level Voltage is 0.58125 V
	USBPHY_RX_CLR_DISCONADJ_010 = 0x2
	// Trip-Level Voltage is 0.60000 V
	USBPHY_RX_CLR_DISCONADJ_011 = 0x3
	// Position of RXDBYPASS field.
	USBPHY_RX_CLR_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_CLR_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_CLR_RXDBYPASS = 0x400000
	// Normal operation.
	USBPHY_RX_CLR_RXDBYPASS_0 = 0x0
	// Use the output of the USB_DP single-ended receiver in place of the full-speed differential receiver
	USBPHY_RX_CLR_RXDBYPASS_1 = 0x1

	// RX_TOG: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_TOG_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_TOG_ENVADJ_Msk = 0x7
	// Trip-Level Voltage is 0.1000 V
	USBPHY_RX_TOG_ENVADJ_000 = 0x0
	// Trip-Level Voltage is 0.1125 V
	USBPHY_RX_TOG_ENVADJ_001 = 0x1
	// Trip-Level Voltage is 0.1250 V
	USBPHY_RX_TOG_ENVADJ_010 = 0x2
	// Trip-Level Voltage is 0.0875 V
	USBPHY_RX_TOG_ENVADJ_011 = 0x3
	// Position of DISCONADJ field.
	USBPHY_RX_TOG_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_TOG_DISCONADJ_Msk = 0x70
	// Trip-Level Voltage is 0.56875 V
	USBPHY_RX_TOG_DISCONADJ_000 = 0x0
	// Trip-Level Voltage is 0.55000 V
	USBPHY_RX_TOG_DISCONADJ_001 = 0x1
	// Trip-Level Voltage is 0.58125 V
	USBPHY_RX_TOG_DISCONADJ_010 = 0x2
	// Trip-Level Voltage is 0.60000 V
	USBPHY_RX_TOG_DISCONADJ_011 = 0x3
	// Position of RXDBYPASS field.
	USBPHY_RX_TOG_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_TOG_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_TOG_RXDBYPASS = 0x400000
	// Normal operation.
	USBPHY_RX_TOG_RXDBYPASS_0 = 0x0
	// Use the output of the USB_DP single-ended receiver in place of the full-speed differential receiver
	USBPHY_RX_TOG_RXDBYPASS_1 = 0x1

	// CTRL: USB PHY General Control Register
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_ENHOSTDISCONDETECT = 0x2
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDET field.
	USBPHY_CTRL_ENDEVPLUGINDET_Pos = 0x4
	// Bit mask of ENDEVPLUGINDET field.
	USBPHY_CTRL_ENDEVPLUGINDET_Msk = 0x10
	// Bit ENDEVPLUGINDET.
	USBPHY_CTRL_ENDEVPLUGINDET = 0x10
	// Disables 200kohm pullup resistors on USB_DP and USB_DM pins (Default)
	USBPHY_CTRL_ENDEVPLUGINDET_0 = 0x0
	// Enables 200kohm pullup resistors on USB_DP and USB_DM pins
	USBPHY_CTRL_ENDEVPLUGINDET_1 = 0x1
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_DEVPLUGIN_IRQ = 0x1000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_ENUTMILEVEL3 = 0x8000
	// Position of AUTORESUME_EN field.
	USBPHY_CTRL_AUTORESUME_EN_Pos = 0x12
	// Bit mask of AUTORESUME_EN field.
	USBPHY_CTRL_AUTORESUME_EN_Msk = 0x40000
	// Bit AUTORESUME_EN.
	USBPHY_CTRL_AUTORESUME_EN = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_FSDLL_RST_EN = 0x1000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_SFTRST = 0x80000000

	// CTRL_SET: USB PHY General Control Register
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_SET_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_SET_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_SET_ENHOSTDISCONDETECT = 0x2
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_SET_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_SET_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_SET_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDET field.
	USBPHY_CTRL_SET_ENDEVPLUGINDET_Pos = 0x4
	// Bit mask of ENDEVPLUGINDET field.
	USBPHY_CTRL_SET_ENDEVPLUGINDET_Msk = 0x10
	// Bit ENDEVPLUGINDET.
	USBPHY_CTRL_SET_ENDEVPLUGINDET = 0x10
	// Disables 200kohm pullup resistors on USB_DP and USB_DM pins (Default)
	USBPHY_CTRL_SET_ENDEVPLUGINDET_0 = 0x0
	// Enables 200kohm pullup resistors on USB_DP and USB_DM pins
	USBPHY_CTRL_SET_ENDEVPLUGINDET_1 = 0x1
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_SET_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_SET_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_SET_DEVPLUGIN_IRQ = 0x1000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_SET_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_SET_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_SET_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_SET_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_SET_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_SET_ENUTMILEVEL3 = 0x8000
	// Position of AUTORESUME_EN field.
	USBPHY_CTRL_SET_AUTORESUME_EN_Pos = 0x12
	// Bit mask of AUTORESUME_EN field.
	USBPHY_CTRL_SET_AUTORESUME_EN_Msk = 0x40000
	// Bit AUTORESUME_EN.
	USBPHY_CTRL_SET_AUTORESUME_EN = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_SET_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_SET_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_SET_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_SET_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_SET_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_SET_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_SET_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_SET_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_SET_FSDLL_RST_EN = 0x1000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_SET_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_SET_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_SET_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_SET_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_SET_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_SET_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_SET_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_SET_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_SET_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_SET_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_SET_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_SET_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_SET_SFTRST = 0x80000000

	// CTRL_CLR: USB PHY General Control Register
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_CLR_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_CLR_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_CLR_ENHOSTDISCONDETECT = 0x2
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_CLR_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_CLR_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_CLR_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDET field.
	USBPHY_CTRL_CLR_ENDEVPLUGINDET_Pos = 0x4
	// Bit mask of ENDEVPLUGINDET field.
	USBPHY_CTRL_CLR_ENDEVPLUGINDET_Msk = 0x10
	// Bit ENDEVPLUGINDET.
	USBPHY_CTRL_CLR_ENDEVPLUGINDET = 0x10
	// Disables 200kohm pullup resistors on USB_DP and USB_DM pins (Default)
	USBPHY_CTRL_CLR_ENDEVPLUGINDET_0 = 0x0
	// Enables 200kohm pullup resistors on USB_DP and USB_DM pins
	USBPHY_CTRL_CLR_ENDEVPLUGINDET_1 = 0x1
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_CLR_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_CLR_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_CLR_DEVPLUGIN_IRQ = 0x1000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_CLR_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_CLR_ENUTMILEVEL3 = 0x8000
	// Position of AUTORESUME_EN field.
	USBPHY_CTRL_CLR_AUTORESUME_EN_Pos = 0x12
	// Bit mask of AUTORESUME_EN field.
	USBPHY_CTRL_CLR_AUTORESUME_EN_Msk = 0x40000
	// Bit AUTORESUME_EN.
	USBPHY_CTRL_CLR_AUTORESUME_EN = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_CLR_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_CLR_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_CLR_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_CLR_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_CLR_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_CLR_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_CLR_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_CLR_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_CLR_FSDLL_RST_EN = 0x1000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_CLR_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_CLR_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_CLR_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_CLR_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_CLR_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_CLR_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_CLR_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_CLR_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_CLR_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_CLR_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_CLR_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_CLR_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_CLR_SFTRST = 0x80000000

	// CTRL_TOG: USB PHY General Control Register
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_TOG_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_TOG_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_TOG_ENHOSTDISCONDETECT = 0x2
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_TOG_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_TOG_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_TOG_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDET field.
	USBPHY_CTRL_TOG_ENDEVPLUGINDET_Pos = 0x4
	// Bit mask of ENDEVPLUGINDET field.
	USBPHY_CTRL_TOG_ENDEVPLUGINDET_Msk = 0x10
	// Bit ENDEVPLUGINDET.
	USBPHY_CTRL_TOG_ENDEVPLUGINDET = 0x10
	// Disables 200kohm pullup resistors on USB_DP and USB_DM pins (Default)
	USBPHY_CTRL_TOG_ENDEVPLUGINDET_0 = 0x0
	// Enables 200kohm pullup resistors on USB_DP and USB_DM pins
	USBPHY_CTRL_TOG_ENDEVPLUGINDET_1 = 0x1
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_TOG_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_TOG_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_TOG_DEVPLUGIN_IRQ = 0x1000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_TOG_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_TOG_ENUTMILEVEL3 = 0x8000
	// Position of AUTORESUME_EN field.
	USBPHY_CTRL_TOG_AUTORESUME_EN_Pos = 0x12
	// Bit mask of AUTORESUME_EN field.
	USBPHY_CTRL_TOG_AUTORESUME_EN_Msk = 0x40000
	// Bit AUTORESUME_EN.
	USBPHY_CTRL_TOG_AUTORESUME_EN = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_TOG_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_TOG_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_TOG_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_TOG_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_TOG_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_TOG_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_TOG_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_TOG_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_TOG_FSDLL_RST_EN = 0x1000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_TOG_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_TOG_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_TOG_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_TOG_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_TOG_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_TOG_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_TOG_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_TOG_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_TOG_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_TOG_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_TOG_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_TOG_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_TOG_SFTRST = 0x80000000

	// STATUS: USB PHY Status Register
	// Position of HOSTDISCONDETECT_STATUS field.
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_STATUS field.
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS_Msk = 0x8
	// Bit HOSTDISCONDETECT_STATUS.
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS = 0x8
	// USB cable disconnect has not been detected at the local host
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS_0 = 0x0
	// USB cable disconnect has been detected at the local host
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS_1 = 0x1
	// Position of DEVPLUGIN_STATUS field.
	USBPHY_STATUS_DEVPLUGIN_STATUS_Pos = 0x6
	// Bit mask of DEVPLUGIN_STATUS field.
	USBPHY_STATUS_DEVPLUGIN_STATUS_Msk = 0x40
	// Bit DEVPLUGIN_STATUS.
	USBPHY_STATUS_DEVPLUGIN_STATUS = 0x40
	// No attachment to a USB host is detected
	USBPHY_STATUS_DEVPLUGIN_STATUS_0 = 0x0
	// Cable attachment to a USB host is detected
	USBPHY_STATUS_DEVPLUGIN_STATUS_1 = 0x1
	// Position of OTGID_STATUS field.
	USBPHY_STATUS_OTGID_STATUS_Pos = 0x8
	// Bit mask of OTGID_STATUS field.
	USBPHY_STATUS_OTGID_STATUS_Msk = 0x100
	// Bit OTGID_STATUS.
	USBPHY_STATUS_OTGID_STATUS = 0x100
	// Position of RESUME_STATUS field.
	USBPHY_STATUS_RESUME_STATUS_Pos = 0xa
	// Bit mask of RESUME_STATUS field.
	USBPHY_STATUS_RESUME_STATUS_Msk = 0x400
	// Bit RESUME_STATUS.
	USBPHY_STATUS_RESUME_STATUS = 0x400

	// DEBUG: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_ENHSTPULLDOWN_Msk = 0x30
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_ENTX2RXCOUNT = 0x1000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_CLKGATE = 0x40000000

	// DEBUG_SET: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_SET_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_SET_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_SET_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_SET_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_SET_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_SET_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_SET_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_SET_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_SET_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_SET_ENHSTPULLDOWN_Msk = 0x30
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_SET_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_SET_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_SET_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_SET_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_SET_ENTX2RXCOUNT = 0x1000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SET_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SET_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_SET_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_SET_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_SET_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SET_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SET_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_SET_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_SET_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_SET_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_SET_CLKGATE = 0x40000000

	// DEBUG_CLR: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_CLR_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_CLR_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_CLR_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_CLR_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_CLR_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_CLR_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_CLR_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_CLR_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_CLR_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_CLR_ENHSTPULLDOWN_Msk = 0x30
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_CLR_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_CLR_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_CLR_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_CLR_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_CLR_ENTX2RXCOUNT = 0x1000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_CLR_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_CLR_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_CLR_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_CLR_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_CLR_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_CLR_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_CLR_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_CLR_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_CLR_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_CLR_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_CLR_CLKGATE = 0x40000000

	// DEBUG_TOG: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_TOG_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_TOG_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_TOG_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_TOG_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_TOG_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_TOG_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_TOG_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_TOG_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_TOG_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_TOG_ENHSTPULLDOWN_Msk = 0x30
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_TOG_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_TOG_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_TOG_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_TOG_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_TOG_ENTX2RXCOUNT = 0x1000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_TOG_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_TOG_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_TOG_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_TOG_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_TOG_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_TOG_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_TOG_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_TOG_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_TOG_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_TOG_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_TOG_CLKGATE = 0x40000000

	// DEBUG0_STATUS: UTMI Debug Status Register 0
	// Position of LOOP_BACK_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT_Pos = 0x0
	// Bit mask of LOOP_BACK_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT_Msk = 0xffff
	// Position of UTMI_RXERROR_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT_Pos = 0x10
	// Bit mask of UTMI_RXERROR_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT_Msk = 0x3ff0000
	// Position of SQUELCH_COUNT field.
	USBPHY_DEBUG0_STATUS_SQUELCH_COUNT_Pos = 0x1a
	// Bit mask of SQUELCH_COUNT field.
	USBPHY_DEBUG0_STATUS_SQUELCH_COUNT_Msk = 0xfc000000

	// DEBUG1: UTMI Debug Status Register 1
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_ENTAILADJVD_Msk = 0x6000
	// Delay is nominal
	USBPHY_DEBUG1_ENTAILADJVD_00 = 0x0
	// Delay is +20%
	USBPHY_DEBUG1_ENTAILADJVD_01 = 0x1
	// Delay is -20%
	USBPHY_DEBUG1_ENTAILADJVD_10 = 0x2
	// Delay is -40%
	USBPHY_DEBUG1_ENTAILADJVD_11 = 0x3

	// DEBUG1_SET: UTMI Debug Status Register 1
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_SET_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_SET_ENTAILADJVD_Msk = 0x6000
	// Delay is nominal
	USBPHY_DEBUG1_SET_ENTAILADJVD_00 = 0x0
	// Delay is +20%
	USBPHY_DEBUG1_SET_ENTAILADJVD_01 = 0x1
	// Delay is -20%
	USBPHY_DEBUG1_SET_ENTAILADJVD_10 = 0x2
	// Delay is -40%
	USBPHY_DEBUG1_SET_ENTAILADJVD_11 = 0x3

	// DEBUG1_CLR: UTMI Debug Status Register 1
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_CLR_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_CLR_ENTAILADJVD_Msk = 0x6000
	// Delay is nominal
	USBPHY_DEBUG1_CLR_ENTAILADJVD_00 = 0x0
	// Delay is +20%
	USBPHY_DEBUG1_CLR_ENTAILADJVD_01 = 0x1
	// Delay is -20%
	USBPHY_DEBUG1_CLR_ENTAILADJVD_10 = 0x2
	// Delay is -40%
	USBPHY_DEBUG1_CLR_ENTAILADJVD_11 = 0x3

	// DEBUG1_TOG: UTMI Debug Status Register 1
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_TOG_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_TOG_ENTAILADJVD_Msk = 0x6000
	// Delay is nominal
	USBPHY_DEBUG1_TOG_ENTAILADJVD_00 = 0x0
	// Delay is +20%
	USBPHY_DEBUG1_TOG_ENTAILADJVD_01 = 0x1
	// Delay is -20%
	USBPHY_DEBUG1_TOG_ENTAILADJVD_10 = 0x2
	// Delay is -40%
	USBPHY_DEBUG1_TOG_ENTAILADJVD_11 = 0x3

	// VERSION: UTMI RTL Version
	// Position of STEP field.
	USBPHY_VERSION_STEP_Pos = 0x0
	// Bit mask of STEP field.
	USBPHY_VERSION_STEP_Msk = 0xffff
	// Position of MINOR field.
	USBPHY_VERSION_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	USBPHY_VERSION_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	USBPHY_VERSION_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	USBPHY_VERSION_MAJOR_Msk = 0xff000000

	// PLL_SIC: USB PHY PLL Control/Status Register
	// Position of PLL_DIV_SEL field.
	USBPHY_PLL_SIC_PLL_DIV_SEL_Pos = 0x0
	// Bit mask of PLL_DIV_SEL field.
	USBPHY_PLL_SIC_PLL_DIV_SEL_Msk = 0x3
	// PLL reference frequency = 24MHz
	USBPHY_PLL_SIC_PLL_DIV_SEL_00 = 0x0
	// PLL reference frequency = 16MHz
	USBPHY_PLL_SIC_PLL_DIV_SEL_01 = 0x1
	// Position of PLL_EN_USB_CLKS field.
	USBPHY_PLL_SIC_PLL_EN_USB_CLKS_Pos = 0x6
	// Bit mask of PLL_EN_USB_CLKS field.
	USBPHY_PLL_SIC_PLL_EN_USB_CLKS_Msk = 0x40
	// Bit PLL_EN_USB_CLKS.
	USBPHY_PLL_SIC_PLL_EN_USB_CLKS = 0x40
	// Position of PLL_HOLD_RING_OFF field.
	USBPHY_PLL_SIC_PLL_HOLD_RING_OFF_Pos = 0xb
	// Bit mask of PLL_HOLD_RING_OFF field.
	USBPHY_PLL_SIC_PLL_HOLD_RING_OFF_Msk = 0x800
	// Bit PLL_HOLD_RING_OFF.
	USBPHY_PLL_SIC_PLL_HOLD_RING_OFF = 0x800
	// Position of PLL_POWER field.
	USBPHY_PLL_SIC_PLL_POWER_Pos = 0xc
	// Bit mask of PLL_POWER field.
	USBPHY_PLL_SIC_PLL_POWER_Msk = 0x1000
	// Bit PLL_POWER.
	USBPHY_PLL_SIC_PLL_POWER = 0x1000
	// Position of PLL_ENABLE field.
	USBPHY_PLL_SIC_PLL_ENABLE_Pos = 0xd
	// Bit mask of PLL_ENABLE field.
	USBPHY_PLL_SIC_PLL_ENABLE_Msk = 0x2000
	// Bit PLL_ENABLE.
	USBPHY_PLL_SIC_PLL_ENABLE = 0x2000
	// Position of PLL_BYPASS field.
	USBPHY_PLL_SIC_PLL_BYPASS_Pos = 0x10
	// Bit mask of PLL_BYPASS field.
	USBPHY_PLL_SIC_PLL_BYPASS_Msk = 0x10000
	// Bit PLL_BYPASS.
	USBPHY_PLL_SIC_PLL_BYPASS = 0x10000
	// Position of PLL_LOCK field.
	USBPHY_PLL_SIC_PLL_LOCK_Pos = 0x1f
	// Bit mask of PLL_LOCK field.
	USBPHY_PLL_SIC_PLL_LOCK_Msk = 0x80000000
	// Bit PLL_LOCK.
	USBPHY_PLL_SIC_PLL_LOCK = 0x80000000
	// PLL is not currently locked
	USBPHY_PLL_SIC_PLL_LOCK_0 = 0x0
	// PLL is currently locked
	USBPHY_PLL_SIC_PLL_LOCK_1 = 0x1

	// PLL_SIC_SET: USB PHY PLL Control/Status Register
	// Position of PLL_DIV_SEL field.
	USBPHY_PLL_SIC_SET_PLL_DIV_SEL_Pos = 0x0
	// Bit mask of PLL_DIV_SEL field.
	USBPHY_PLL_SIC_SET_PLL_DIV_SEL_Msk = 0x3
	// PLL reference frequency = 24MHz
	USBPHY_PLL_SIC_SET_PLL_DIV_SEL_00 = 0x0
	// PLL reference frequency = 16MHz
	USBPHY_PLL_SIC_SET_PLL_DIV_SEL_01 = 0x1
	// Position of PLL_EN_USB_CLKS field.
	USBPHY_PLL_SIC_SET_PLL_EN_USB_CLKS_Pos = 0x6
	// Bit mask of PLL_EN_USB_CLKS field.
	USBPHY_PLL_SIC_SET_PLL_EN_USB_CLKS_Msk = 0x40
	// Bit PLL_EN_USB_CLKS.
	USBPHY_PLL_SIC_SET_PLL_EN_USB_CLKS = 0x40
	// Position of PLL_HOLD_RING_OFF field.
	USBPHY_PLL_SIC_SET_PLL_HOLD_RING_OFF_Pos = 0xb
	// Bit mask of PLL_HOLD_RING_OFF field.
	USBPHY_PLL_SIC_SET_PLL_HOLD_RING_OFF_Msk = 0x800
	// Bit PLL_HOLD_RING_OFF.
	USBPHY_PLL_SIC_SET_PLL_HOLD_RING_OFF = 0x800
	// Position of PLL_POWER field.
	USBPHY_PLL_SIC_SET_PLL_POWER_Pos = 0xc
	// Bit mask of PLL_POWER field.
	USBPHY_PLL_SIC_SET_PLL_POWER_Msk = 0x1000
	// Bit PLL_POWER.
	USBPHY_PLL_SIC_SET_PLL_POWER = 0x1000
	// Position of PLL_ENABLE field.
	USBPHY_PLL_SIC_SET_PLL_ENABLE_Pos = 0xd
	// Bit mask of PLL_ENABLE field.
	USBPHY_PLL_SIC_SET_PLL_ENABLE_Msk = 0x2000
	// Bit PLL_ENABLE.
	USBPHY_PLL_SIC_SET_PLL_ENABLE = 0x2000
	// Position of PLL_BYPASS field.
	USBPHY_PLL_SIC_SET_PLL_BYPASS_Pos = 0x10
	// Bit mask of PLL_BYPASS field.
	USBPHY_PLL_SIC_SET_PLL_BYPASS_Msk = 0x10000
	// Bit PLL_BYPASS.
	USBPHY_PLL_SIC_SET_PLL_BYPASS = 0x10000
	// Position of PLL_LOCK field.
	USBPHY_PLL_SIC_SET_PLL_LOCK_Pos = 0x1f
	// Bit mask of PLL_LOCK field.
	USBPHY_PLL_SIC_SET_PLL_LOCK_Msk = 0x80000000
	// Bit PLL_LOCK.
	USBPHY_PLL_SIC_SET_PLL_LOCK = 0x80000000
	// PLL is not currently locked
	USBPHY_PLL_SIC_SET_PLL_LOCK_0 = 0x0
	// PLL is currently locked
	USBPHY_PLL_SIC_SET_PLL_LOCK_1 = 0x1

	// PLL_SIC_CLR: USB PHY PLL Control/Status Register
	// Position of PLL_DIV_SEL field.
	USBPHY_PLL_SIC_CLR_PLL_DIV_SEL_Pos = 0x0
	// Bit mask of PLL_DIV_SEL field.
	USBPHY_PLL_SIC_CLR_PLL_DIV_SEL_Msk = 0x3
	// PLL reference frequency = 24MHz
	USBPHY_PLL_SIC_CLR_PLL_DIV_SEL_00 = 0x0
	// PLL reference frequency = 16MHz
	USBPHY_PLL_SIC_CLR_PLL_DIV_SEL_01 = 0x1
	// Position of PLL_EN_USB_CLKS field.
	USBPHY_PLL_SIC_CLR_PLL_EN_USB_CLKS_Pos = 0x6
	// Bit mask of PLL_EN_USB_CLKS field.
	USBPHY_PLL_SIC_CLR_PLL_EN_USB_CLKS_Msk = 0x40
	// Bit PLL_EN_USB_CLKS.
	USBPHY_PLL_SIC_CLR_PLL_EN_USB_CLKS = 0x40
	// Position of PLL_HOLD_RING_OFF field.
	USBPHY_PLL_SIC_CLR_PLL_HOLD_RING_OFF_Pos = 0xb
	// Bit mask of PLL_HOLD_RING_OFF field.
	USBPHY_PLL_SIC_CLR_PLL_HOLD_RING_OFF_Msk = 0x800
	// Bit PLL_HOLD_RING_OFF.
	USBPHY_PLL_SIC_CLR_PLL_HOLD_RING_OFF = 0x800
	// Position of PLL_POWER field.
	USBPHY_PLL_SIC_CLR_PLL_POWER_Pos = 0xc
	// Bit mask of PLL_POWER field.
	USBPHY_PLL_SIC_CLR_PLL_POWER_Msk = 0x1000
	// Bit PLL_POWER.
	USBPHY_PLL_SIC_CLR_PLL_POWER = 0x1000
	// Position of PLL_ENABLE field.
	USBPHY_PLL_SIC_CLR_PLL_ENABLE_Pos = 0xd
	// Bit mask of PLL_ENABLE field.
	USBPHY_PLL_SIC_CLR_PLL_ENABLE_Msk = 0x2000
	// Bit PLL_ENABLE.
	USBPHY_PLL_SIC_CLR_PLL_ENABLE = 0x2000
	// Position of PLL_BYPASS field.
	USBPHY_PLL_SIC_CLR_PLL_BYPASS_Pos = 0x10
	// Bit mask of PLL_BYPASS field.
	USBPHY_PLL_SIC_CLR_PLL_BYPASS_Msk = 0x10000
	// Bit PLL_BYPASS.
	USBPHY_PLL_SIC_CLR_PLL_BYPASS = 0x10000
	// Position of PLL_LOCK field.
	USBPHY_PLL_SIC_CLR_PLL_LOCK_Pos = 0x1f
	// Bit mask of PLL_LOCK field.
	USBPHY_PLL_SIC_CLR_PLL_LOCK_Msk = 0x80000000
	// Bit PLL_LOCK.
	USBPHY_PLL_SIC_CLR_PLL_LOCK = 0x80000000
	// PLL is not currently locked
	USBPHY_PLL_SIC_CLR_PLL_LOCK_0 = 0x0
	// PLL is currently locked
	USBPHY_PLL_SIC_CLR_PLL_LOCK_1 = 0x1

	// PLL_SIC_TOG: USB PHY PLL Control/Status Register
	// Position of PLL_DIV_SEL field.
	USBPHY_PLL_SIC_TOG_PLL_DIV_SEL_Pos = 0x0
	// Bit mask of PLL_DIV_SEL field.
	USBPHY_PLL_SIC_TOG_PLL_DIV_SEL_Msk = 0x3
	// PLL reference frequency = 24MHz
	USBPHY_PLL_SIC_TOG_PLL_DIV_SEL_00 = 0x0
	// PLL reference frequency = 16MHz
	USBPHY_PLL_SIC_TOG_PLL_DIV_SEL_01 = 0x1
	// Position of PLL_EN_USB_CLKS field.
	USBPHY_PLL_SIC_TOG_PLL_EN_USB_CLKS_Pos = 0x6
	// Bit mask of PLL_EN_USB_CLKS field.
	USBPHY_PLL_SIC_TOG_PLL_EN_USB_CLKS_Msk = 0x40
	// Bit PLL_EN_USB_CLKS.
	USBPHY_PLL_SIC_TOG_PLL_EN_USB_CLKS = 0x40
	// Position of PLL_HOLD_RING_OFF field.
	USBPHY_PLL_SIC_TOG_PLL_HOLD_RING_OFF_Pos = 0xb
	// Bit mask of PLL_HOLD_RING_OFF field.
	USBPHY_PLL_SIC_TOG_PLL_HOLD_RING_OFF_Msk = 0x800
	// Bit PLL_HOLD_RING_OFF.
	USBPHY_PLL_SIC_TOG_PLL_HOLD_RING_OFF = 0x800
	// Position of PLL_POWER field.
	USBPHY_PLL_SIC_TOG_PLL_POWER_Pos = 0xc
	// Bit mask of PLL_POWER field.
	USBPHY_PLL_SIC_TOG_PLL_POWER_Msk = 0x1000
	// Bit PLL_POWER.
	USBPHY_PLL_SIC_TOG_PLL_POWER = 0x1000
	// Position of PLL_ENABLE field.
	USBPHY_PLL_SIC_TOG_PLL_ENABLE_Pos = 0xd
	// Bit mask of PLL_ENABLE field.
	USBPHY_PLL_SIC_TOG_PLL_ENABLE_Msk = 0x2000
	// Bit PLL_ENABLE.
	USBPHY_PLL_SIC_TOG_PLL_ENABLE = 0x2000
	// Position of PLL_BYPASS field.
	USBPHY_PLL_SIC_TOG_PLL_BYPASS_Pos = 0x10
	// Bit mask of PLL_BYPASS field.
	USBPHY_PLL_SIC_TOG_PLL_BYPASS_Msk = 0x10000
	// Bit PLL_BYPASS.
	USBPHY_PLL_SIC_TOG_PLL_BYPASS = 0x10000
	// Position of PLL_LOCK field.
	USBPHY_PLL_SIC_TOG_PLL_LOCK_Pos = 0x1f
	// Bit mask of PLL_LOCK field.
	USBPHY_PLL_SIC_TOG_PLL_LOCK_Msk = 0x80000000
	// Bit PLL_LOCK.
	USBPHY_PLL_SIC_TOG_PLL_LOCK = 0x80000000
	// PLL is not currently locked
	USBPHY_PLL_SIC_TOG_PLL_LOCK_0 = 0x0
	// PLL is currently locked
	USBPHY_PLL_SIC_TOG_PLL_LOCK_1 = 0x1

	// USB1_VBUS_DETECT: USB PHY VBUS Detect Control Register
	// Position of VBUSVALID_THRESH field.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_Msk = 0x7
	// 4.0 V
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_000 = 0x0
	// 4.1 V
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_001 = 0x1
	// 4.2 V
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_010 = 0x2
	// 4.3 V
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_011 = 0x3
	// 4.4 V (Default)
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_100 = 0x4
	// 4.5 V
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_101 = 0x5
	// 4.6 V
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_110 = 0x6
	// 4.7 V
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_THRESH_111 = 0x7
	// Position of VBUS_OVERRIDE_EN field.
	USBPHY_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN_Pos = 0x3
	// Bit mask of VBUS_OVERRIDE_EN field.
	USBPHY_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN_Msk = 0x8
	// Bit VBUS_OVERRIDE_EN.
	USBPHY_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN = 0x8
	// Use the results of the internal VBUS_VALID and Session Valid comparators for VBUS_VALID, AVALID, BVALID, and SESSEND (Default)
	USBPHY_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN_0 = 0x0
	// Use the override values for VBUS_VALID, AVALID, BVALID, and SESSEND
	USBPHY_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN_1 = 0x1
	// Position of SESSEND_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SESSEND_OVERRIDE_Pos = 0x4
	// Bit mask of SESSEND_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SESSEND_OVERRIDE_Msk = 0x10
	// Bit SESSEND_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_SESSEND_OVERRIDE = 0x10
	// Position of BVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_BVALID_OVERRIDE_Pos = 0x5
	// Bit mask of BVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_BVALID_OVERRIDE_Msk = 0x20
	// Bit BVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_BVALID_OVERRIDE = 0x20
	// Position of AVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_AVALID_OVERRIDE_Pos = 0x6
	// Bit mask of AVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_AVALID_OVERRIDE_Msk = 0x40
	// Bit AVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_AVALID_OVERRIDE = 0x40
	// Position of VBUSVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_OVERRIDE_Pos = 0x7
	// Bit mask of VBUSVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_OVERRIDE_Msk = 0x80
	// Bit VBUSVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_OVERRIDE = 0x80
	// Position of VBUSVALID_SEL field.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_SEL_Pos = 0x8
	// Bit mask of VBUSVALID_SEL field.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_SEL_Msk = 0x100
	// Bit VBUSVALID_SEL.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_SEL = 0x100
	// Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_SEL_0 = 0x0
	// Use the VBUS_VALID_3V detector results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_SEL_1 = 0x1
	// Position of VBUS_SOURCE_SEL field.
	USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_Pos = 0x9
	// Bit mask of VBUS_SOURCE_SEL field.
	USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_Msk = 0x600
	// Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
	USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_00 = 0x0
	// Use the Session Valid comparator results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_01 = 0x1
	// Use the Session Valid comparator results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_10 = 0x2
	// Reserved, do not use
	USBPHY_USB1_VBUS_DETECT_VBUS_SOURCE_SEL_11 = 0x3
	// Position of VBUSVALID_TO_SESSVALID field.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID_Pos = 0x12
	// Bit mask of VBUSVALID_TO_SESSVALID field.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID_Msk = 0x40000
	// Bit VBUSVALID_TO_SESSVALID.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID = 0x40000
	// Use the VBUS_VALID comparator for VBUS_VALID results
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID_0 = 0x0
	// Use the Session End comparator for VBUS_VALID results. The Session End threshold is >0.8V and <4.0V.
	USBPHY_USB1_VBUS_DETECT_VBUSVALID_TO_SESSVALID_1 = 0x1
	// Position of PWRUP_CMPS field.
	USBPHY_USB1_VBUS_DETECT_PWRUP_CMPS_Pos = 0x14
	// Bit mask of PWRUP_CMPS field.
	USBPHY_USB1_VBUS_DETECT_PWRUP_CMPS_Msk = 0x100000
	// Bit PWRUP_CMPS.
	USBPHY_USB1_VBUS_DETECT_PWRUP_CMPS = 0x100000
	// Powers down the VBUS_VALID comparator
	USBPHY_USB1_VBUS_DETECT_PWRUP_CMPS_0 = 0x0
	// Enables the VBUS_VALID comparator (default)
	USBPHY_USB1_VBUS_DETECT_PWRUP_CMPS_1 = 0x1
	// Position of DISCHARGE_VBUS field.
	USBPHY_USB1_VBUS_DETECT_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USBPHY_USB1_VBUS_DETECT_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USBPHY_USB1_VBUS_DETECT_DISCHARGE_VBUS = 0x4000000
	// VBUS discharge resistor is disabled (Default)
	USBPHY_USB1_VBUS_DETECT_DISCHARGE_VBUS_0 = 0x0
	// VBUS discharge resistor is enabled
	USBPHY_USB1_VBUS_DETECT_DISCHARGE_VBUS_1 = 0x1
	// Position of EN_CHARGER_RESISTOR field.
	USBPHY_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR_Pos = 0x1f
	// Bit mask of EN_CHARGER_RESISTOR field.
	USBPHY_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR_Msk = 0x80000000
	// Bit EN_CHARGER_RESISTOR.
	USBPHY_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR = 0x80000000
	// Disable resistive charger detection resistors on USB_DP and USB_DP
	USBPHY_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR_0 = 0x0
	// Enable resistive charger detection resistors on USB_DP and USB_DP
	USBPHY_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR_1 = 0x1

	// USB1_VBUS_DETECT_SET: USB PHY VBUS Detect Control Register
	// Position of VBUSVALID_THRESH field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_Msk = 0x7
	// 4.0 V
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_000 = 0x0
	// 4.1 V
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_001 = 0x1
	// 4.2 V
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_010 = 0x2
	// 4.3 V
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_011 = 0x3
	// 4.4 V (Default)
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_100 = 0x4
	// 4.5 V
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_101 = 0x5
	// 4.6 V
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_110 = 0x6
	// 4.7 V
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_111 = 0x7
	// Position of VBUS_OVERRIDE_EN field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN_Pos = 0x3
	// Bit mask of VBUS_OVERRIDE_EN field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN_Msk = 0x8
	// Bit VBUS_OVERRIDE_EN.
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN = 0x8
	// Use the results of the internal VBUS_VALID and Session Valid comparators for VBUS_VALID, AVALID, BVALID, and SESSEND (Default)
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN_0 = 0x0
	// Use the override values for VBUS_VALID, AVALID, BVALID, and SESSEND
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_OVERRIDE_EN_1 = 0x1
	// Position of SESSEND_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SET_SESSEND_OVERRIDE_Pos = 0x4
	// Bit mask of SESSEND_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SET_SESSEND_OVERRIDE_Msk = 0x10
	// Bit SESSEND_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_SET_SESSEND_OVERRIDE = 0x10
	// Position of BVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SET_BVALID_OVERRIDE_Pos = 0x5
	// Bit mask of BVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SET_BVALID_OVERRIDE_Msk = 0x20
	// Bit BVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_SET_BVALID_OVERRIDE = 0x20
	// Position of AVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SET_AVALID_OVERRIDE_Pos = 0x6
	// Bit mask of AVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SET_AVALID_OVERRIDE_Msk = 0x40
	// Bit AVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_SET_AVALID_OVERRIDE = 0x40
	// Position of VBUSVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_OVERRIDE_Pos = 0x7
	// Bit mask of VBUSVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_OVERRIDE_Msk = 0x80
	// Bit VBUSVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_OVERRIDE = 0x80
	// Position of VBUSVALID_SEL field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_SEL_Pos = 0x8
	// Bit mask of VBUSVALID_SEL field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_SEL_Msk = 0x100
	// Bit VBUSVALID_SEL.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_SEL = 0x100
	// Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_SEL_0 = 0x0
	// Use the VBUS_VALID_3V detector results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_SEL_1 = 0x1
	// Position of VBUS_SOURCE_SEL field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_Pos = 0x9
	// Bit mask of VBUS_SOURCE_SEL field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_Msk = 0x600
	// Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_00 = 0x0
	// Use the Session Valid comparator results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_01 = 0x1
	// Use the Session Valid comparator results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_10 = 0x2
	// Reserved, do not use
	USBPHY_USB1_VBUS_DETECT_SET_VBUS_SOURCE_SEL_11 = 0x3
	// Position of VBUSVALID_TO_SESSVALID field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID_Pos = 0x12
	// Bit mask of VBUSVALID_TO_SESSVALID field.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID_Msk = 0x40000
	// Bit VBUSVALID_TO_SESSVALID.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID = 0x40000
	// Use the VBUS_VALID comparator for VBUS_VALID results
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID_0 = 0x0
	// Use the Session End comparator for VBUS_VALID results. The Session End threshold is >0.8V and <4.0V.
	USBPHY_USB1_VBUS_DETECT_SET_VBUSVALID_TO_SESSVALID_1 = 0x1
	// Position of PWRUP_CMPS field.
	USBPHY_USB1_VBUS_DETECT_SET_PWRUP_CMPS_Pos = 0x14
	// Bit mask of PWRUP_CMPS field.
	USBPHY_USB1_VBUS_DETECT_SET_PWRUP_CMPS_Msk = 0x100000
	// Bit PWRUP_CMPS.
	USBPHY_USB1_VBUS_DETECT_SET_PWRUP_CMPS = 0x100000
	// Powers down the VBUS_VALID comparator
	USBPHY_USB1_VBUS_DETECT_SET_PWRUP_CMPS_0 = 0x0
	// Enables the VBUS_VALID comparator (default)
	USBPHY_USB1_VBUS_DETECT_SET_PWRUP_CMPS_1 = 0x1
	// Position of DISCHARGE_VBUS field.
	USBPHY_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USBPHY_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USBPHY_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS = 0x4000000
	// VBUS discharge resistor is disabled (Default)
	USBPHY_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_0 = 0x0
	// VBUS discharge resistor is enabled
	USBPHY_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_1 = 0x1
	// Position of EN_CHARGER_RESISTOR field.
	USBPHY_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR_Pos = 0x1f
	// Bit mask of EN_CHARGER_RESISTOR field.
	USBPHY_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR_Msk = 0x80000000
	// Bit EN_CHARGER_RESISTOR.
	USBPHY_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR = 0x80000000
	// Disable resistive charger detection resistors on USB_DP and USB_DP
	USBPHY_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR_0 = 0x0
	// Enable resistive charger detection resistors on USB_DP and USB_DP
	USBPHY_USB1_VBUS_DETECT_SET_EN_CHARGER_RESISTOR_1 = 0x1

	// USB1_VBUS_DETECT_CLR: USB PHY VBUS Detect Control Register
	// Position of VBUSVALID_THRESH field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_Msk = 0x7
	// 4.0 V
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_000 = 0x0
	// 4.1 V
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_001 = 0x1
	// 4.2 V
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_010 = 0x2
	// 4.3 V
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_011 = 0x3
	// 4.4 V (Default)
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_100 = 0x4
	// 4.5 V
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_101 = 0x5
	// 4.6 V
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_110 = 0x6
	// 4.7 V
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_111 = 0x7
	// Position of VBUS_OVERRIDE_EN field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN_Pos = 0x3
	// Bit mask of VBUS_OVERRIDE_EN field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN_Msk = 0x8
	// Bit VBUS_OVERRIDE_EN.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN = 0x8
	// Use the results of the internal VBUS_VALID and Session Valid comparators for VBUS_VALID, AVALID, BVALID, and SESSEND (Default)
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN_0 = 0x0
	// Use the override values for VBUS_VALID, AVALID, BVALID, and SESSEND
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_OVERRIDE_EN_1 = 0x1
	// Position of SESSEND_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_CLR_SESSEND_OVERRIDE_Pos = 0x4
	// Bit mask of SESSEND_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_CLR_SESSEND_OVERRIDE_Msk = 0x10
	// Bit SESSEND_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_CLR_SESSEND_OVERRIDE = 0x10
	// Position of BVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_CLR_BVALID_OVERRIDE_Pos = 0x5
	// Bit mask of BVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_CLR_BVALID_OVERRIDE_Msk = 0x20
	// Bit BVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_CLR_BVALID_OVERRIDE = 0x20
	// Position of AVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_CLR_AVALID_OVERRIDE_Pos = 0x6
	// Bit mask of AVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_CLR_AVALID_OVERRIDE_Msk = 0x40
	// Bit AVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_CLR_AVALID_OVERRIDE = 0x40
	// Position of VBUSVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_OVERRIDE_Pos = 0x7
	// Bit mask of VBUSVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_OVERRIDE_Msk = 0x80
	// Bit VBUSVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_OVERRIDE = 0x80
	// Position of VBUSVALID_SEL field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL_Pos = 0x8
	// Bit mask of VBUSVALID_SEL field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL_Msk = 0x100
	// Bit VBUSVALID_SEL.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL = 0x100
	// Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL_0 = 0x0
	// Use the VBUS_VALID_3V detector results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_SEL_1 = 0x1
	// Position of VBUS_SOURCE_SEL field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_Pos = 0x9
	// Bit mask of VBUS_SOURCE_SEL field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_Msk = 0x600
	// Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_00 = 0x0
	// Use the Session Valid comparator results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_01 = 0x1
	// Use the Session Valid comparator results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_10 = 0x2
	// Reserved, do not use
	USBPHY_USB1_VBUS_DETECT_CLR_VBUS_SOURCE_SEL_11 = 0x3
	// Position of VBUSVALID_TO_SESSVALID field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID_Pos = 0x12
	// Bit mask of VBUSVALID_TO_SESSVALID field.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID_Msk = 0x40000
	// Bit VBUSVALID_TO_SESSVALID.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID = 0x40000
	// Use the VBUS_VALID comparator for VBUS_VALID results
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID_0 = 0x0
	// Use the Session End comparator for VBUS_VALID results. The Session End threshold is >0.8V and <4.0V.
	USBPHY_USB1_VBUS_DETECT_CLR_VBUSVALID_TO_SESSVALID_1 = 0x1
	// Position of PWRUP_CMPS field.
	USBPHY_USB1_VBUS_DETECT_CLR_PWRUP_CMPS_Pos = 0x14
	// Bit mask of PWRUP_CMPS field.
	USBPHY_USB1_VBUS_DETECT_CLR_PWRUP_CMPS_Msk = 0x100000
	// Bit PWRUP_CMPS.
	USBPHY_USB1_VBUS_DETECT_CLR_PWRUP_CMPS = 0x100000
	// Powers down the VBUS_VALID comparator
	USBPHY_USB1_VBUS_DETECT_CLR_PWRUP_CMPS_0 = 0x0
	// Enables the VBUS_VALID comparator (default)
	USBPHY_USB1_VBUS_DETECT_CLR_PWRUP_CMPS_1 = 0x1
	// Position of DISCHARGE_VBUS field.
	USBPHY_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USBPHY_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USBPHY_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS = 0x4000000
	// VBUS discharge resistor is disabled (Default)
	USBPHY_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_0 = 0x0
	// VBUS discharge resistor is enabled
	USBPHY_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_1 = 0x1
	// Position of EN_CHARGER_RESISTOR field.
	USBPHY_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR_Pos = 0x1f
	// Bit mask of EN_CHARGER_RESISTOR field.
	USBPHY_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR_Msk = 0x80000000
	// Bit EN_CHARGER_RESISTOR.
	USBPHY_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR = 0x80000000
	// Disable resistive charger detection resistors on USB_DP and USB_DP
	USBPHY_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR_0 = 0x0
	// Enable resistive charger detection resistors on USB_DP and USB_DP
	USBPHY_USB1_VBUS_DETECT_CLR_EN_CHARGER_RESISTOR_1 = 0x1

	// USB1_VBUS_DETECT_TOG: USB PHY VBUS Detect Control Register
	// Position of VBUSVALID_THRESH field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_Msk = 0x7
	// 4.0 V
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_000 = 0x0
	// 4.1 V
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_001 = 0x1
	// 4.2 V
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_010 = 0x2
	// 4.3 V
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_011 = 0x3
	// 4.4 V (Default)
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_100 = 0x4
	// 4.5 V
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_101 = 0x5
	// 4.6 V
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_110 = 0x6
	// 4.7 V
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_111 = 0x7
	// Position of VBUS_OVERRIDE_EN field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN_Pos = 0x3
	// Bit mask of VBUS_OVERRIDE_EN field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN_Msk = 0x8
	// Bit VBUS_OVERRIDE_EN.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN = 0x8
	// Use the results of the internal VBUS_VALID and Session Valid comparators for VBUS_VALID, AVALID, BVALID, and SESSEND (Default)
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN_0 = 0x0
	// Use the override values for VBUS_VALID, AVALID, BVALID, and SESSEND
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_OVERRIDE_EN_1 = 0x1
	// Position of SESSEND_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_TOG_SESSEND_OVERRIDE_Pos = 0x4
	// Bit mask of SESSEND_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_TOG_SESSEND_OVERRIDE_Msk = 0x10
	// Bit SESSEND_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_TOG_SESSEND_OVERRIDE = 0x10
	// Position of BVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_TOG_BVALID_OVERRIDE_Pos = 0x5
	// Bit mask of BVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_TOG_BVALID_OVERRIDE_Msk = 0x20
	// Bit BVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_TOG_BVALID_OVERRIDE = 0x20
	// Position of AVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_TOG_AVALID_OVERRIDE_Pos = 0x6
	// Bit mask of AVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_TOG_AVALID_OVERRIDE_Msk = 0x40
	// Bit AVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_TOG_AVALID_OVERRIDE = 0x40
	// Position of VBUSVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_OVERRIDE_Pos = 0x7
	// Bit mask of VBUSVALID_OVERRIDE field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_OVERRIDE_Msk = 0x80
	// Bit VBUSVALID_OVERRIDE.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_OVERRIDE = 0x80
	// Position of VBUSVALID_SEL field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL_Pos = 0x8
	// Bit mask of VBUSVALID_SEL field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL_Msk = 0x100
	// Bit VBUSVALID_SEL.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL = 0x100
	// Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL_0 = 0x0
	// Use the VBUS_VALID_3V detector results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_SEL_1 = 0x1
	// Position of VBUS_SOURCE_SEL field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_Pos = 0x9
	// Bit mask of VBUS_SOURCE_SEL field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_Msk = 0x600
	// Use the VBUS_VALID comparator results for signal reported to the USB controller (Default)
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_00 = 0x0
	// Use the Session Valid comparator results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_01 = 0x1
	// Use the Session Valid comparator results for signal reported to the USB controller
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_10 = 0x2
	// Reserved, do not use
	USBPHY_USB1_VBUS_DETECT_TOG_VBUS_SOURCE_SEL_11 = 0x3
	// Position of VBUSVALID_TO_SESSVALID field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID_Pos = 0x12
	// Bit mask of VBUSVALID_TO_SESSVALID field.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID_Msk = 0x40000
	// Bit VBUSVALID_TO_SESSVALID.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID = 0x40000
	// Use the VBUS_VALID comparator for VBUS_VALID results
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID_0 = 0x0
	// Use the Session End comparator for VBUS_VALID results. The Session End threshold is >0.8V and <4.0V.
	USBPHY_USB1_VBUS_DETECT_TOG_VBUSVALID_TO_SESSVALID_1 = 0x1
	// Position of PWRUP_CMPS field.
	USBPHY_USB1_VBUS_DETECT_TOG_PWRUP_CMPS_Pos = 0x14
	// Bit mask of PWRUP_CMPS field.
	USBPHY_USB1_VBUS_DETECT_TOG_PWRUP_CMPS_Msk = 0x100000
	// Bit PWRUP_CMPS.
	USBPHY_USB1_VBUS_DETECT_TOG_PWRUP_CMPS = 0x100000
	// Powers down the VBUS_VALID comparator
	USBPHY_USB1_VBUS_DETECT_TOG_PWRUP_CMPS_0 = 0x0
	// Enables the VBUS_VALID comparator (default)
	USBPHY_USB1_VBUS_DETECT_TOG_PWRUP_CMPS_1 = 0x1
	// Position of DISCHARGE_VBUS field.
	USBPHY_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USBPHY_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USBPHY_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS = 0x4000000
	// VBUS discharge resistor is disabled (Default)
	USBPHY_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_0 = 0x0
	// VBUS discharge resistor is enabled
	USBPHY_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_1 = 0x1
	// Position of EN_CHARGER_RESISTOR field.
	USBPHY_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR_Pos = 0x1f
	// Bit mask of EN_CHARGER_RESISTOR field.
	USBPHY_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR_Msk = 0x80000000
	// Bit EN_CHARGER_RESISTOR.
	USBPHY_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR = 0x80000000
	// Disable resistive charger detection resistors on USB_DP and USB_DP
	USBPHY_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR_0 = 0x0
	// Enable resistive charger detection resistors on USB_DP and USB_DP
	USBPHY_USB1_VBUS_DETECT_TOG_EN_CHARGER_RESISTOR_1 = 0x1

	// USB1_VBUS_DET_STAT: USB PHY VBUS Detector Status Register
	// Position of SESSEND field.
	USBPHY_USB1_VBUS_DET_STAT_SESSEND_Pos = 0x0
	// Bit mask of SESSEND field.
	USBPHY_USB1_VBUS_DET_STAT_SESSEND_Msk = 0x1
	// Bit SESSEND.
	USBPHY_USB1_VBUS_DET_STAT_SESSEND = 0x1
	// The VBUS voltage is above the Session Valid threshold
	USBPHY_USB1_VBUS_DET_STAT_SESSEND_0 = 0x0
	// The VBUS voltage is below the Session Valid threshold
	USBPHY_USB1_VBUS_DET_STAT_SESSEND_1 = 0x1
	// Position of BVALID field.
	USBPHY_USB1_VBUS_DET_STAT_BVALID_Pos = 0x1
	// Bit mask of BVALID field.
	USBPHY_USB1_VBUS_DET_STAT_BVALID_Msk = 0x2
	// Bit BVALID.
	USBPHY_USB1_VBUS_DET_STAT_BVALID = 0x2
	// The VBUS voltage is below the Session Valid threshold
	USBPHY_USB1_VBUS_DET_STAT_BVALID_0 = 0x0
	// The VBUS voltage is above the Session Valid threshold
	USBPHY_USB1_VBUS_DET_STAT_BVALID_1 = 0x1
	// Position of AVALID field.
	USBPHY_USB1_VBUS_DET_STAT_AVALID_Pos = 0x2
	// Bit mask of AVALID field.
	USBPHY_USB1_VBUS_DET_STAT_AVALID_Msk = 0x4
	// Bit AVALID.
	USBPHY_USB1_VBUS_DET_STAT_AVALID = 0x4
	// The VBUS voltage is below the Session Valid threshold
	USBPHY_USB1_VBUS_DET_STAT_AVALID_0 = 0x0
	// The VBUS voltage is above the Session Valid threshold
	USBPHY_USB1_VBUS_DET_STAT_AVALID_1 = 0x1
	// Position of VBUS_VALID field.
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_Pos = 0x3
	// Bit mask of VBUS_VALID field.
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_Msk = 0x8
	// Bit VBUS_VALID.
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID = 0x8
	// VBUS is below the comparator threshold
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_0 = 0x0
	// VBUS is above the comparator threshold
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_1 = 0x1
	// Position of VBUS_VALID_3V field.
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_3V_Pos = 0x4
	// Bit mask of VBUS_VALID_3V field.
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_3V_Msk = 0x10
	// Bit VBUS_VALID_3V.
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_3V = 0x10
	// VBUS voltage is below VBUS_VALID_3V threshold
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_3V_0 = 0x0
	// VBUS voltage is above VBUS_VALID_3V threshold
	USBPHY_USB1_VBUS_DET_STAT_VBUS_VALID_3V_1 = 0x1

	// USB1_CHRG_DET_STAT: USB PHY Charger Detect Status Register
	// Position of PLUG_CONTACT field.
	USBPHY_USB1_CHRG_DET_STAT_PLUG_CONTACT_Pos = 0x0
	// Bit mask of PLUG_CONTACT field.
	USBPHY_USB1_CHRG_DET_STAT_PLUG_CONTACT_Msk = 0x1
	// Bit PLUG_CONTACT.
	USBPHY_USB1_CHRG_DET_STAT_PLUG_CONTACT = 0x1
	// No USB cable attachment has been detected
	USBPHY_USB1_CHRG_DET_STAT_PLUG_CONTACT_0 = 0x0
	// A USB cable attachment between the device and host has been detected
	USBPHY_USB1_CHRG_DET_STAT_PLUG_CONTACT_1 = 0x1
	// Position of CHRG_DETECTED field.
	USBPHY_USB1_CHRG_DET_STAT_CHRG_DETECTED_Pos = 0x1
	// Bit mask of CHRG_DETECTED field.
	USBPHY_USB1_CHRG_DET_STAT_CHRG_DETECTED_Msk = 0x2
	// Bit CHRG_DETECTED.
	USBPHY_USB1_CHRG_DET_STAT_CHRG_DETECTED = 0x2
	// Standard Downstream Port (SDP) has been detected
	USBPHY_USB1_CHRG_DET_STAT_CHRG_DETECTED_0 = 0x0
	// Charging Port has been detected
	USBPHY_USB1_CHRG_DET_STAT_CHRG_DETECTED_1 = 0x1
	// Position of DM_STATE field.
	USBPHY_USB1_CHRG_DET_STAT_DM_STATE_Pos = 0x2
	// Bit mask of DM_STATE field.
	USBPHY_USB1_CHRG_DET_STAT_DM_STATE_Msk = 0x4
	// Bit DM_STATE.
	USBPHY_USB1_CHRG_DET_STAT_DM_STATE = 0x4
	// USB_DM pin voltage is < 0.8V
	USBPHY_USB1_CHRG_DET_STAT_DM_STATE_0 = 0x0
	// USB_DM pin voltage is > 2.0V
	USBPHY_USB1_CHRG_DET_STAT_DM_STATE_1 = 0x1
	// Position of DP_STATE field.
	USBPHY_USB1_CHRG_DET_STAT_DP_STATE_Pos = 0x3
	// Bit mask of DP_STATE field.
	USBPHY_USB1_CHRG_DET_STAT_DP_STATE_Msk = 0x8
	// Bit DP_STATE.
	USBPHY_USB1_CHRG_DET_STAT_DP_STATE = 0x8
	// USB_DP pin voltage is < 0.8V
	USBPHY_USB1_CHRG_DET_STAT_DP_STATE_0 = 0x0
	// USB_DP pin voltage is > 2.0V
	USBPHY_USB1_CHRG_DET_STAT_DP_STATE_1 = 0x1
	// Position of SECDET_DCP field.
	USBPHY_USB1_CHRG_DET_STAT_SECDET_DCP_Pos = 0x4
	// Bit mask of SECDET_DCP field.
	USBPHY_USB1_CHRG_DET_STAT_SECDET_DCP_Msk = 0x10
	// Bit SECDET_DCP.
	USBPHY_USB1_CHRG_DET_STAT_SECDET_DCP = 0x10
	// Charging Downstream Port (CDP) has been detected
	USBPHY_USB1_CHRG_DET_STAT_SECDET_DCP_0 = 0x0
	// Downstream Charging Port (DCP) has been detected
	USBPHY_USB1_CHRG_DET_STAT_SECDET_DCP_1 = 0x1

	// ANACTRL: USB PHY Analog Control Register
	// Position of TESTCLK_SEL field.
	USBPHY_ANACTRL_TESTCLK_SEL_Pos = 0x0
	// Bit mask of TESTCLK_SEL field.
	USBPHY_ANACTRL_TESTCLK_SEL_Msk = 0x1
	// Bit TESTCLK_SEL.
	USBPHY_ANACTRL_TESTCLK_SEL = 0x1
	// Position of PFD_CLKGATE field.
	USBPHY_ANACTRL_PFD_CLKGATE_Pos = 0x1
	// Bit mask of PFD_CLKGATE field.
	USBPHY_ANACTRL_PFD_CLKGATE_Msk = 0x2
	// Bit PFD_CLKGATE.
	USBPHY_ANACTRL_PFD_CLKGATE = 0x2
	// PFD clock output is enabled
	USBPHY_ANACTRL_PFD_CLKGATE_0 = 0x0
	// PFD clock output is gated (Default)
	USBPHY_ANACTRL_PFD_CLKGATE_1 = 0x1
	// Position of PFD_CLK_SEL field.
	USBPHY_ANACTRL_PFD_CLK_SEL_Pos = 0x2
	// Bit mask of PFD_CLK_SEL field.
	USBPHY_ANACTRL_PFD_CLK_SEL_Msk = 0xc
	// USB1PFDCLK is the same frequency as the xtal clock (Default)
	USBPHY_ANACTRL_PFD_CLK_SEL_00 = 0x0
	// USB1PFDCLK frequency is pfd_clk divided by 4
	USBPHY_ANACTRL_PFD_CLK_SEL_01 = 0x1
	// USB1PFDCLK frequency is pfd_clk divided by 2
	USBPHY_ANACTRL_PFD_CLK_SEL_10 = 0x2
	// USB1PFDCLK frequency is the same as pfd_clk frequency
	USBPHY_ANACTRL_PFD_CLK_SEL_11 = 0x3
	// Position of PFD_FRAC field.
	USBPHY_ANACTRL_PFD_FRAC_Pos = 0x4
	// Bit mask of PFD_FRAC field.
	USBPHY_ANACTRL_PFD_FRAC_Msk = 0x3f0
	// Position of DEV_PULLDOWN field.
	USBPHY_ANACTRL_DEV_PULLDOWN_Pos = 0xa
	// Bit mask of DEV_PULLDOWN field.
	USBPHY_ANACTRL_DEV_PULLDOWN_Msk = 0x400
	// Bit DEV_PULLDOWN.
	USBPHY_ANACTRL_DEV_PULLDOWN = 0x400
	// The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare disabled in device mode.
	USBPHY_ANACTRL_DEV_PULLDOWN_0 = 0x0
	// The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare enabled in device mode.
	USBPHY_ANACTRL_DEV_PULLDOWN_1 = 0x1
	// Position of EMPH_PULSE_CTRL field.
	USBPHY_ANACTRL_EMPH_PULSE_CTRL_Pos = 0xb
	// Bit mask of EMPH_PULSE_CTRL field.
	USBPHY_ANACTRL_EMPH_PULSE_CTRL_Msk = 0x1800
	// Minimum duration of pre-emphasis current after each data transition
	USBPHY_ANACTRL_EMPH_PULSE_CTRL_00 = 0x0
	// Maximum duration of pre-emphasis current after each data transition
	USBPHY_ANACTRL_EMPH_PULSE_CTRL_11 = 0x3
	// Position of EMPH_EN field.
	USBPHY_ANACTRL_EMPH_EN_Pos = 0xd
	// Bit mask of EMPH_EN field.
	USBPHY_ANACTRL_EMPH_EN_Msk = 0x2000
	// Bit EMPH_EN.
	USBPHY_ANACTRL_EMPH_EN = 0x2000
	// No pre-emphasis is used on HS TX output drivers
	USBPHY_ANACTRL_EMPH_EN_0 = 0x0
	// Enables pre-emphasis for HS TX output drivers
	USBPHY_ANACTRL_EMPH_EN_1 = 0x1
	// Position of EMPH_CUR_CTRL field.
	USBPHY_ANACTRL_EMPH_CUR_CTRL_Pos = 0xe
	// Bit mask of EMPH_CUR_CTRL field.
	USBPHY_ANACTRL_EMPH_CUR_CTRL_Msk = 0xc000
	// No pre-emphasis current is enabled for the HS TX drivers
	USBPHY_ANACTRL_EMPH_CUR_CTRL_00 = 0x0
	// One unit of pre-emphasis current is enabled for the HS TX drivers
	USBPHY_ANACTRL_EMPH_CUR_CTRL_01 = 0x1
	// Two units of pre-emphasis current are enabled for the HS TX drivers
	USBPHY_ANACTRL_EMPH_CUR_CTRL_10 = 0x2
	// Three units of pre-emphasis current are enabled for the HS TX drivers
	USBPHY_ANACTRL_EMPH_CUR_CTRL_11 = 0x3
	// Position of PFD_STABLE field.
	USBPHY_ANACTRL_PFD_STABLE_Pos = 0x1f
	// Bit mask of PFD_STABLE field.
	USBPHY_ANACTRL_PFD_STABLE_Msk = 0x80000000
	// Bit PFD_STABLE.
	USBPHY_ANACTRL_PFD_STABLE = 0x80000000

	// ANACTRL_SET: USB PHY Analog Control Register
	// Position of TESTCLK_SEL field.
	USBPHY_ANACTRL_SET_TESTCLK_SEL_Pos = 0x0
	// Bit mask of TESTCLK_SEL field.
	USBPHY_ANACTRL_SET_TESTCLK_SEL_Msk = 0x1
	// Bit TESTCLK_SEL.
	USBPHY_ANACTRL_SET_TESTCLK_SEL = 0x1
	// Position of PFD_CLKGATE field.
	USBPHY_ANACTRL_SET_PFD_CLKGATE_Pos = 0x1
	// Bit mask of PFD_CLKGATE field.
	USBPHY_ANACTRL_SET_PFD_CLKGATE_Msk = 0x2
	// Bit PFD_CLKGATE.
	USBPHY_ANACTRL_SET_PFD_CLKGATE = 0x2
	// PFD clock output is enabled
	USBPHY_ANACTRL_SET_PFD_CLKGATE_0 = 0x0
	// PFD clock output is gated (Default)
	USBPHY_ANACTRL_SET_PFD_CLKGATE_1 = 0x1
	// Position of PFD_CLK_SEL field.
	USBPHY_ANACTRL_SET_PFD_CLK_SEL_Pos = 0x2
	// Bit mask of PFD_CLK_SEL field.
	USBPHY_ANACTRL_SET_PFD_CLK_SEL_Msk = 0xc
	// USB1PFDCLK is the same frequency as the xtal clock (Default)
	USBPHY_ANACTRL_SET_PFD_CLK_SEL_00 = 0x0
	// USB1PFDCLK frequency is pfd_clk divided by 4
	USBPHY_ANACTRL_SET_PFD_CLK_SEL_01 = 0x1
	// USB1PFDCLK frequency is pfd_clk divided by 2
	USBPHY_ANACTRL_SET_PFD_CLK_SEL_10 = 0x2
	// USB1PFDCLK frequency is the same as pfd_clk frequency
	USBPHY_ANACTRL_SET_PFD_CLK_SEL_11 = 0x3
	// Position of PFD_FRAC field.
	USBPHY_ANACTRL_SET_PFD_FRAC_Pos = 0x4
	// Bit mask of PFD_FRAC field.
	USBPHY_ANACTRL_SET_PFD_FRAC_Msk = 0x3f0
	// Position of DEV_PULLDOWN field.
	USBPHY_ANACTRL_SET_DEV_PULLDOWN_Pos = 0xa
	// Bit mask of DEV_PULLDOWN field.
	USBPHY_ANACTRL_SET_DEV_PULLDOWN_Msk = 0x400
	// Bit DEV_PULLDOWN.
	USBPHY_ANACTRL_SET_DEV_PULLDOWN = 0x400
	// The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare disabled in device mode.
	USBPHY_ANACTRL_SET_DEV_PULLDOWN_0 = 0x0
	// The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare enabled in device mode.
	USBPHY_ANACTRL_SET_DEV_PULLDOWN_1 = 0x1
	// Position of EMPH_PULSE_CTRL field.
	USBPHY_ANACTRL_SET_EMPH_PULSE_CTRL_Pos = 0xb
	// Bit mask of EMPH_PULSE_CTRL field.
	USBPHY_ANACTRL_SET_EMPH_PULSE_CTRL_Msk = 0x1800
	// Minimum duration of pre-emphasis current after each data transition
	USBPHY_ANACTRL_SET_EMPH_PULSE_CTRL_00 = 0x0
	// Maximum duration of pre-emphasis current after each data transition
	USBPHY_ANACTRL_SET_EMPH_PULSE_CTRL_11 = 0x3
	// Position of EMPH_EN field.
	USBPHY_ANACTRL_SET_EMPH_EN_Pos = 0xd
	// Bit mask of EMPH_EN field.
	USBPHY_ANACTRL_SET_EMPH_EN_Msk = 0x2000
	// Bit EMPH_EN.
	USBPHY_ANACTRL_SET_EMPH_EN = 0x2000
	// No pre-emphasis is used on HS TX output drivers
	USBPHY_ANACTRL_SET_EMPH_EN_0 = 0x0
	// Enables pre-emphasis for HS TX output drivers
	USBPHY_ANACTRL_SET_EMPH_EN_1 = 0x1
	// Position of EMPH_CUR_CTRL field.
	USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_Pos = 0xe
	// Bit mask of EMPH_CUR_CTRL field.
	USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_Msk = 0xc000
	// No pre-emphasis current is enabled for the HS TX drivers
	USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_00 = 0x0
	// One unit of pre-emphasis current is enabled for the HS TX drivers
	USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_01 = 0x1
	// Two units of pre-emphasis current are enabled for the HS TX drivers
	USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_10 = 0x2
	// Three units of pre-emphasis current are enabled for the HS TX drivers
	USBPHY_ANACTRL_SET_EMPH_CUR_CTRL_11 = 0x3
	// Position of PFD_STABLE field.
	USBPHY_ANACTRL_SET_PFD_STABLE_Pos = 0x1f
	// Bit mask of PFD_STABLE field.
	USBPHY_ANACTRL_SET_PFD_STABLE_Msk = 0x80000000
	// Bit PFD_STABLE.
	USBPHY_ANACTRL_SET_PFD_STABLE = 0x80000000

	// ANACTRL_CLR: USB PHY Analog Control Register
	// Position of TESTCLK_SEL field.
	USBPHY_ANACTRL_CLR_TESTCLK_SEL_Pos = 0x0
	// Bit mask of TESTCLK_SEL field.
	USBPHY_ANACTRL_CLR_TESTCLK_SEL_Msk = 0x1
	// Bit TESTCLK_SEL.
	USBPHY_ANACTRL_CLR_TESTCLK_SEL = 0x1
	// Position of PFD_CLKGATE field.
	USBPHY_ANACTRL_CLR_PFD_CLKGATE_Pos = 0x1
	// Bit mask of PFD_CLKGATE field.
	USBPHY_ANACTRL_CLR_PFD_CLKGATE_Msk = 0x2
	// Bit PFD_CLKGATE.
	USBPHY_ANACTRL_CLR_PFD_CLKGATE = 0x2
	// PFD clock output is enabled
	USBPHY_ANACTRL_CLR_PFD_CLKGATE_0 = 0x0
	// PFD clock output is gated (Default)
	USBPHY_ANACTRL_CLR_PFD_CLKGATE_1 = 0x1
	// Position of PFD_CLK_SEL field.
	USBPHY_ANACTRL_CLR_PFD_CLK_SEL_Pos = 0x2
	// Bit mask of PFD_CLK_SEL field.
	USBPHY_ANACTRL_CLR_PFD_CLK_SEL_Msk = 0xc
	// USB1PFDCLK is the same frequency as the xtal clock (Default)
	USBPHY_ANACTRL_CLR_PFD_CLK_SEL_00 = 0x0
	// USB1PFDCLK frequency is pfd_clk divided by 4
	USBPHY_ANACTRL_CLR_PFD_CLK_SEL_01 = 0x1
	// USB1PFDCLK frequency is pfd_clk divided by 2
	USBPHY_ANACTRL_CLR_PFD_CLK_SEL_10 = 0x2
	// USB1PFDCLK frequency is the same as pfd_clk frequency
	USBPHY_ANACTRL_CLR_PFD_CLK_SEL_11 = 0x3
	// Position of PFD_FRAC field.
	USBPHY_ANACTRL_CLR_PFD_FRAC_Pos = 0x4
	// Bit mask of PFD_FRAC field.
	USBPHY_ANACTRL_CLR_PFD_FRAC_Msk = 0x3f0
	// Position of DEV_PULLDOWN field.
	USBPHY_ANACTRL_CLR_DEV_PULLDOWN_Pos = 0xa
	// Bit mask of DEV_PULLDOWN field.
	USBPHY_ANACTRL_CLR_DEV_PULLDOWN_Msk = 0x400
	// Bit DEV_PULLDOWN.
	USBPHY_ANACTRL_CLR_DEV_PULLDOWN = 0x400
	// The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare disabled in device mode.
	USBPHY_ANACTRL_CLR_DEV_PULLDOWN_0 = 0x0
	// The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare enabled in device mode.
	USBPHY_ANACTRL_CLR_DEV_PULLDOWN_1 = 0x1
	// Position of EMPH_PULSE_CTRL field.
	USBPHY_ANACTRL_CLR_EMPH_PULSE_CTRL_Pos = 0xb
	// Bit mask of EMPH_PULSE_CTRL field.
	USBPHY_ANACTRL_CLR_EMPH_PULSE_CTRL_Msk = 0x1800
	// Minimum duration of pre-emphasis current after each data transition
	USBPHY_ANACTRL_CLR_EMPH_PULSE_CTRL_00 = 0x0
	// Maximum duration of pre-emphasis current after each data transition
	USBPHY_ANACTRL_CLR_EMPH_PULSE_CTRL_11 = 0x3
	// Position of EMPH_EN field.
	USBPHY_ANACTRL_CLR_EMPH_EN_Pos = 0xd
	// Bit mask of EMPH_EN field.
	USBPHY_ANACTRL_CLR_EMPH_EN_Msk = 0x2000
	// Bit EMPH_EN.
	USBPHY_ANACTRL_CLR_EMPH_EN = 0x2000
	// No pre-emphasis is used on HS TX output drivers
	USBPHY_ANACTRL_CLR_EMPH_EN_0 = 0x0
	// Enables pre-emphasis for HS TX output drivers
	USBPHY_ANACTRL_CLR_EMPH_EN_1 = 0x1
	// Position of EMPH_CUR_CTRL field.
	USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_Pos = 0xe
	// Bit mask of EMPH_CUR_CTRL field.
	USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_Msk = 0xc000
	// No pre-emphasis current is enabled for the HS TX drivers
	USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_00 = 0x0
	// One unit of pre-emphasis current is enabled for the HS TX drivers
	USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_01 = 0x1
	// Two units of pre-emphasis current are enabled for the HS TX drivers
	USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_10 = 0x2
	// Three units of pre-emphasis current are enabled for the HS TX drivers
	USBPHY_ANACTRL_CLR_EMPH_CUR_CTRL_11 = 0x3
	// Position of PFD_STABLE field.
	USBPHY_ANACTRL_CLR_PFD_STABLE_Pos = 0x1f
	// Bit mask of PFD_STABLE field.
	USBPHY_ANACTRL_CLR_PFD_STABLE_Msk = 0x80000000
	// Bit PFD_STABLE.
	USBPHY_ANACTRL_CLR_PFD_STABLE = 0x80000000

	// ANACTRL_TOG: USB PHY Analog Control Register
	// Position of TESTCLK_SEL field.
	USBPHY_ANACTRL_TOG_TESTCLK_SEL_Pos = 0x0
	// Bit mask of TESTCLK_SEL field.
	USBPHY_ANACTRL_TOG_TESTCLK_SEL_Msk = 0x1
	// Bit TESTCLK_SEL.
	USBPHY_ANACTRL_TOG_TESTCLK_SEL = 0x1
	// Position of PFD_CLKGATE field.
	USBPHY_ANACTRL_TOG_PFD_CLKGATE_Pos = 0x1
	// Bit mask of PFD_CLKGATE field.
	USBPHY_ANACTRL_TOG_PFD_CLKGATE_Msk = 0x2
	// Bit PFD_CLKGATE.
	USBPHY_ANACTRL_TOG_PFD_CLKGATE = 0x2
	// PFD clock output is enabled
	USBPHY_ANACTRL_TOG_PFD_CLKGATE_0 = 0x0
	// PFD clock output is gated (Default)
	USBPHY_ANACTRL_TOG_PFD_CLKGATE_1 = 0x1
	// Position of PFD_CLK_SEL field.
	USBPHY_ANACTRL_TOG_PFD_CLK_SEL_Pos = 0x2
	// Bit mask of PFD_CLK_SEL field.
	USBPHY_ANACTRL_TOG_PFD_CLK_SEL_Msk = 0xc
	// USB1PFDCLK is the same frequency as the xtal clock (Default)
	USBPHY_ANACTRL_TOG_PFD_CLK_SEL_00 = 0x0
	// USB1PFDCLK frequency is pfd_clk divided by 4
	USBPHY_ANACTRL_TOG_PFD_CLK_SEL_01 = 0x1
	// USB1PFDCLK frequency is pfd_clk divided by 2
	USBPHY_ANACTRL_TOG_PFD_CLK_SEL_10 = 0x2
	// USB1PFDCLK frequency is the same as pfd_clk frequency
	USBPHY_ANACTRL_TOG_PFD_CLK_SEL_11 = 0x3
	// Position of PFD_FRAC field.
	USBPHY_ANACTRL_TOG_PFD_FRAC_Pos = 0x4
	// Bit mask of PFD_FRAC field.
	USBPHY_ANACTRL_TOG_PFD_FRAC_Msk = 0x3f0
	// Position of DEV_PULLDOWN field.
	USBPHY_ANACTRL_TOG_DEV_PULLDOWN_Pos = 0xa
	// Bit mask of DEV_PULLDOWN field.
	USBPHY_ANACTRL_TOG_DEV_PULLDOWN_Msk = 0x400
	// Bit DEV_PULLDOWN.
	USBPHY_ANACTRL_TOG_DEV_PULLDOWN = 0x400
	// The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare disabled in device mode.
	USBPHY_ANACTRL_TOG_DEV_PULLDOWN_0 = 0x0
	// The 15kohm nominal pulldowns on the USB_DP and USB_DM pinsare enabled in device mode.
	USBPHY_ANACTRL_TOG_DEV_PULLDOWN_1 = 0x1
	// Position of EMPH_PULSE_CTRL field.
	USBPHY_ANACTRL_TOG_EMPH_PULSE_CTRL_Pos = 0xb
	// Bit mask of EMPH_PULSE_CTRL field.
	USBPHY_ANACTRL_TOG_EMPH_PULSE_CTRL_Msk = 0x1800
	// Minimum duration of pre-emphasis current after each data transition
	USBPHY_ANACTRL_TOG_EMPH_PULSE_CTRL_00 = 0x0
	// Maximum duration of pre-emphasis current after each data transition
	USBPHY_ANACTRL_TOG_EMPH_PULSE_CTRL_11 = 0x3
	// Position of EMPH_EN field.
	USBPHY_ANACTRL_TOG_EMPH_EN_Pos = 0xd
	// Bit mask of EMPH_EN field.
	USBPHY_ANACTRL_TOG_EMPH_EN_Msk = 0x2000
	// Bit EMPH_EN.
	USBPHY_ANACTRL_TOG_EMPH_EN = 0x2000
	// No pre-emphasis is used on HS TX output drivers
	USBPHY_ANACTRL_TOG_EMPH_EN_0 = 0x0
	// Enables pre-emphasis for HS TX output drivers
	USBPHY_ANACTRL_TOG_EMPH_EN_1 = 0x1
	// Position of EMPH_CUR_CTRL field.
	USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_Pos = 0xe
	// Bit mask of EMPH_CUR_CTRL field.
	USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_Msk = 0xc000
	// No pre-emphasis current is enabled for the HS TX drivers
	USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_00 = 0x0
	// One unit of pre-emphasis current is enabled for the HS TX drivers
	USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_01 = 0x1
	// Two units of pre-emphasis current are enabled for the HS TX drivers
	USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_10 = 0x2
	// Three units of pre-emphasis current are enabled for the HS TX drivers
	USBPHY_ANACTRL_TOG_EMPH_CUR_CTRL_11 = 0x3
	// Position of PFD_STABLE field.
	USBPHY_ANACTRL_TOG_PFD_STABLE_Pos = 0x1f
	// Bit mask of PFD_STABLE field.
	USBPHY_ANACTRL_TOG_PFD_STABLE_Msk = 0x80000000
	// Bit PFD_STABLE.
	USBPHY_ANACTRL_TOG_PFD_STABLE = 0x80000000

	// USB1_LOOPBACK: USB PHY Loopback Control/Status Register
	// Position of UTMI_TESTSTART field.
	USBPHY_USB1_LOOPBACK_UTMI_TESTSTART_Pos = 0x0
	// Bit mask of UTMI_TESTSTART field.
	USBPHY_USB1_LOOPBACK_UTMI_TESTSTART_Msk = 0x1
	// Bit UTMI_TESTSTART.
	USBPHY_USB1_LOOPBACK_UTMI_TESTSTART = 0x1
	// Position of UTMI_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_UTMI_DIG_TST0_Pos = 0x1
	// Bit mask of UTMI_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_UTMI_DIG_TST0_Msk = 0x2
	// Bit UTMI_DIG_TST0.
	USBPHY_USB1_LOOPBACK_UTMI_DIG_TST0 = 0x2
	// Position of UTMI_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_UTMI_DIG_TST1_Pos = 0x2
	// Bit mask of UTMI_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_UTMI_DIG_TST1_Msk = 0x4
	// Bit UTMI_DIG_TST1.
	USBPHY_USB1_LOOPBACK_UTMI_DIG_TST1 = 0x4
	// Position of TSTI_TX_HS_MODE field.
	USBPHY_USB1_LOOPBACK_TSTI_TX_HS_MODE_Pos = 0x3
	// Bit mask of TSTI_TX_HS_MODE field.
	USBPHY_USB1_LOOPBACK_TSTI_TX_HS_MODE_Msk = 0x8
	// Bit TSTI_TX_HS_MODE.
	USBPHY_USB1_LOOPBACK_TSTI_TX_HS_MODE = 0x8
	// Position of TSTI_TX_LS_MODE field.
	USBPHY_USB1_LOOPBACK_TSTI_TX_LS_MODE_Pos = 0x4
	// Bit mask of TSTI_TX_LS_MODE field.
	USBPHY_USB1_LOOPBACK_TSTI_TX_LS_MODE_Msk = 0x10
	// Bit TSTI_TX_LS_MODE.
	USBPHY_USB1_LOOPBACK_TSTI_TX_LS_MODE = 0x10
	// Position of TSTI_TX_EN field.
	USBPHY_USB1_LOOPBACK_TSTI_TX_EN_Pos = 0x5
	// Bit mask of TSTI_TX_EN field.
	USBPHY_USB1_LOOPBACK_TSTI_TX_EN_Msk = 0x20
	// Bit TSTI_TX_EN.
	USBPHY_USB1_LOOPBACK_TSTI_TX_EN = 0x20
	// Position of TSTI_TX_HIZ field.
	USBPHY_USB1_LOOPBACK_TSTI_TX_HIZ_Pos = 0x6
	// Bit mask of TSTI_TX_HIZ field.
	USBPHY_USB1_LOOPBACK_TSTI_TX_HIZ_Msk = 0x40
	// Bit TSTI_TX_HIZ.
	USBPHY_USB1_LOOPBACK_TSTI_TX_HIZ = 0x40
	// Position of UTMO_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_UTMO_DIG_TST0_Pos = 0x7
	// Bit mask of UTMO_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_UTMO_DIG_TST0_Msk = 0x80
	// Bit UTMO_DIG_TST0.
	USBPHY_USB1_LOOPBACK_UTMO_DIG_TST0 = 0x80
	// Position of UTMO_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_UTMO_DIG_TST1_Pos = 0x8
	// Bit mask of UTMO_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_UTMO_DIG_TST1_Msk = 0x100
	// Bit UTMO_DIG_TST1.
	USBPHY_USB1_LOOPBACK_UTMO_DIG_TST1 = 0x100
	// Position of TSTI_HSFS_MODE_EN field.
	USBPHY_USB1_LOOPBACK_TSTI_HSFS_MODE_EN_Pos = 0xf
	// Bit mask of TSTI_HSFS_MODE_EN field.
	USBPHY_USB1_LOOPBACK_TSTI_HSFS_MODE_EN_Msk = 0x8000
	// Bit TSTI_HSFS_MODE_EN.
	USBPHY_USB1_LOOPBACK_TSTI_HSFS_MODE_EN = 0x8000
	// Position of TSTPKT field.
	USBPHY_USB1_LOOPBACK_TSTPKT_Pos = 0x10
	// Bit mask of TSTPKT field.
	USBPHY_USB1_LOOPBACK_TSTPKT_Msk = 0xff0000

	// USB1_LOOPBACK_SET: USB PHY Loopback Control/Status Register
	// Position of UTMI_TESTSTART field.
	USBPHY_USB1_LOOPBACK_SET_UTMI_TESTSTART_Pos = 0x0
	// Bit mask of UTMI_TESTSTART field.
	USBPHY_USB1_LOOPBACK_SET_UTMI_TESTSTART_Msk = 0x1
	// Bit UTMI_TESTSTART.
	USBPHY_USB1_LOOPBACK_SET_UTMI_TESTSTART = 0x1
	// Position of UTMI_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_SET_UTMI_DIG_TST0_Pos = 0x1
	// Bit mask of UTMI_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_SET_UTMI_DIG_TST0_Msk = 0x2
	// Bit UTMI_DIG_TST0.
	USBPHY_USB1_LOOPBACK_SET_UTMI_DIG_TST0 = 0x2
	// Position of UTMI_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_SET_UTMI_DIG_TST1_Pos = 0x2
	// Bit mask of UTMI_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_SET_UTMI_DIG_TST1_Msk = 0x4
	// Bit UTMI_DIG_TST1.
	USBPHY_USB1_LOOPBACK_SET_UTMI_DIG_TST1 = 0x4
	// Position of TSTI_TX_HS_MODE field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_HS_MODE_Pos = 0x3
	// Bit mask of TSTI_TX_HS_MODE field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_HS_MODE_Msk = 0x8
	// Bit TSTI_TX_HS_MODE.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_HS_MODE = 0x8
	// Position of TSTI_TX_LS_MODE field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_LS_MODE_Pos = 0x4
	// Bit mask of TSTI_TX_LS_MODE field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_LS_MODE_Msk = 0x10
	// Bit TSTI_TX_LS_MODE.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_LS_MODE = 0x10
	// Position of TSTI_TX_EN field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_EN_Pos = 0x5
	// Bit mask of TSTI_TX_EN field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_EN_Msk = 0x20
	// Bit TSTI_TX_EN.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_EN = 0x20
	// Position of TSTI_TX_HIZ field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_HIZ_Pos = 0x6
	// Bit mask of TSTI_TX_HIZ field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_HIZ_Msk = 0x40
	// Bit TSTI_TX_HIZ.
	USBPHY_USB1_LOOPBACK_SET_TSTI_TX_HIZ = 0x40
	// Position of UTMO_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_SET_UTMO_DIG_TST0_Pos = 0x7
	// Bit mask of UTMO_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_SET_UTMO_DIG_TST0_Msk = 0x80
	// Bit UTMO_DIG_TST0.
	USBPHY_USB1_LOOPBACK_SET_UTMO_DIG_TST0 = 0x80
	// Position of UTMO_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_SET_UTMO_DIG_TST1_Pos = 0x8
	// Bit mask of UTMO_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_SET_UTMO_DIG_TST1_Msk = 0x100
	// Bit UTMO_DIG_TST1.
	USBPHY_USB1_LOOPBACK_SET_UTMO_DIG_TST1 = 0x100
	// Position of TSTI_HSFS_MODE_EN field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_HSFS_MODE_EN_Pos = 0xf
	// Bit mask of TSTI_HSFS_MODE_EN field.
	USBPHY_USB1_LOOPBACK_SET_TSTI_HSFS_MODE_EN_Msk = 0x8000
	// Bit TSTI_HSFS_MODE_EN.
	USBPHY_USB1_LOOPBACK_SET_TSTI_HSFS_MODE_EN = 0x8000
	// Position of TSTPKT field.
	USBPHY_USB1_LOOPBACK_SET_TSTPKT_Pos = 0x10
	// Bit mask of TSTPKT field.
	USBPHY_USB1_LOOPBACK_SET_TSTPKT_Msk = 0xff0000

	// USB1_LOOPBACK_CLR: USB PHY Loopback Control/Status Register
	// Position of UTMI_TESTSTART field.
	USBPHY_USB1_LOOPBACK_CLR_UTMI_TESTSTART_Pos = 0x0
	// Bit mask of UTMI_TESTSTART field.
	USBPHY_USB1_LOOPBACK_CLR_UTMI_TESTSTART_Msk = 0x1
	// Bit UTMI_TESTSTART.
	USBPHY_USB1_LOOPBACK_CLR_UTMI_TESTSTART = 0x1
	// Position of UTMI_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_CLR_UTMI_DIG_TST0_Pos = 0x1
	// Bit mask of UTMI_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_CLR_UTMI_DIG_TST0_Msk = 0x2
	// Bit UTMI_DIG_TST0.
	USBPHY_USB1_LOOPBACK_CLR_UTMI_DIG_TST0 = 0x2
	// Position of UTMI_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_CLR_UTMI_DIG_TST1_Pos = 0x2
	// Bit mask of UTMI_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_CLR_UTMI_DIG_TST1_Msk = 0x4
	// Bit UTMI_DIG_TST1.
	USBPHY_USB1_LOOPBACK_CLR_UTMI_DIG_TST1 = 0x4
	// Position of TSTI_TX_HS_MODE field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_HS_MODE_Pos = 0x3
	// Bit mask of TSTI_TX_HS_MODE field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_HS_MODE_Msk = 0x8
	// Bit TSTI_TX_HS_MODE.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_HS_MODE = 0x8
	// Position of TSTI_TX_LS_MODE field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_LS_MODE_Pos = 0x4
	// Bit mask of TSTI_TX_LS_MODE field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_LS_MODE_Msk = 0x10
	// Bit TSTI_TX_LS_MODE.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_LS_MODE = 0x10
	// Position of TSTI_TX_EN field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_EN_Pos = 0x5
	// Bit mask of TSTI_TX_EN field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_EN_Msk = 0x20
	// Bit TSTI_TX_EN.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_EN = 0x20
	// Position of TSTI_TX_HIZ field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_HIZ_Pos = 0x6
	// Bit mask of TSTI_TX_HIZ field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_HIZ_Msk = 0x40
	// Bit TSTI_TX_HIZ.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_TX_HIZ = 0x40
	// Position of UTMO_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_CLR_UTMO_DIG_TST0_Pos = 0x7
	// Bit mask of UTMO_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_CLR_UTMO_DIG_TST0_Msk = 0x80
	// Bit UTMO_DIG_TST0.
	USBPHY_USB1_LOOPBACK_CLR_UTMO_DIG_TST0 = 0x80
	// Position of UTMO_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_CLR_UTMO_DIG_TST1_Pos = 0x8
	// Bit mask of UTMO_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_CLR_UTMO_DIG_TST1_Msk = 0x100
	// Bit UTMO_DIG_TST1.
	USBPHY_USB1_LOOPBACK_CLR_UTMO_DIG_TST1 = 0x100
	// Position of TSTI_HSFS_MODE_EN field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_HSFS_MODE_EN_Pos = 0xf
	// Bit mask of TSTI_HSFS_MODE_EN field.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_HSFS_MODE_EN_Msk = 0x8000
	// Bit TSTI_HSFS_MODE_EN.
	USBPHY_USB1_LOOPBACK_CLR_TSTI_HSFS_MODE_EN = 0x8000
	// Position of TSTPKT field.
	USBPHY_USB1_LOOPBACK_CLR_TSTPKT_Pos = 0x10
	// Bit mask of TSTPKT field.
	USBPHY_USB1_LOOPBACK_CLR_TSTPKT_Msk = 0xff0000

	// USB1_LOOPBACK_TOG: USB PHY Loopback Control/Status Register
	// Position of UTMI_TESTSTART field.
	USBPHY_USB1_LOOPBACK_TOG_UTMI_TESTSTART_Pos = 0x0
	// Bit mask of UTMI_TESTSTART field.
	USBPHY_USB1_LOOPBACK_TOG_UTMI_TESTSTART_Msk = 0x1
	// Bit UTMI_TESTSTART.
	USBPHY_USB1_LOOPBACK_TOG_UTMI_TESTSTART = 0x1
	// Position of UTMI_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_TOG_UTMI_DIG_TST0_Pos = 0x1
	// Bit mask of UTMI_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_TOG_UTMI_DIG_TST0_Msk = 0x2
	// Bit UTMI_DIG_TST0.
	USBPHY_USB1_LOOPBACK_TOG_UTMI_DIG_TST0 = 0x2
	// Position of UTMI_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_TOG_UTMI_DIG_TST1_Pos = 0x2
	// Bit mask of UTMI_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_TOG_UTMI_DIG_TST1_Msk = 0x4
	// Bit UTMI_DIG_TST1.
	USBPHY_USB1_LOOPBACK_TOG_UTMI_DIG_TST1 = 0x4
	// Position of TSTI_TX_HS_MODE field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_HS_MODE_Pos = 0x3
	// Bit mask of TSTI_TX_HS_MODE field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_HS_MODE_Msk = 0x8
	// Bit TSTI_TX_HS_MODE.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_HS_MODE = 0x8
	// Position of TSTI_TX_LS_MODE field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_LS_MODE_Pos = 0x4
	// Bit mask of TSTI_TX_LS_MODE field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_LS_MODE_Msk = 0x10
	// Bit TSTI_TX_LS_MODE.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_LS_MODE = 0x10
	// Position of TSTI_TX_EN field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_EN_Pos = 0x5
	// Bit mask of TSTI_TX_EN field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_EN_Msk = 0x20
	// Bit TSTI_TX_EN.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_EN = 0x20
	// Position of TSTI_TX_HIZ field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_HIZ_Pos = 0x6
	// Bit mask of TSTI_TX_HIZ field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_HIZ_Msk = 0x40
	// Bit TSTI_TX_HIZ.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_TX_HIZ = 0x40
	// Position of UTMO_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_TOG_UTMO_DIG_TST0_Pos = 0x7
	// Bit mask of UTMO_DIG_TST0 field.
	USBPHY_USB1_LOOPBACK_TOG_UTMO_DIG_TST0_Msk = 0x80
	// Bit UTMO_DIG_TST0.
	USBPHY_USB1_LOOPBACK_TOG_UTMO_DIG_TST0 = 0x80
	// Position of UTMO_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_TOG_UTMO_DIG_TST1_Pos = 0x8
	// Bit mask of UTMO_DIG_TST1 field.
	USBPHY_USB1_LOOPBACK_TOG_UTMO_DIG_TST1_Msk = 0x100
	// Bit UTMO_DIG_TST1.
	USBPHY_USB1_LOOPBACK_TOG_UTMO_DIG_TST1 = 0x100
	// Position of TSTI_HSFS_MODE_EN field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_HSFS_MODE_EN_Pos = 0xf
	// Bit mask of TSTI_HSFS_MODE_EN field.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_HSFS_MODE_EN_Msk = 0x8000
	// Bit TSTI_HSFS_MODE_EN.
	USBPHY_USB1_LOOPBACK_TOG_TSTI_HSFS_MODE_EN = 0x8000
	// Position of TSTPKT field.
	USBPHY_USB1_LOOPBACK_TOG_TSTPKT_Pos = 0x10
	// Bit mask of TSTPKT field.
	USBPHY_USB1_LOOPBACK_TOG_TSTPKT_Msk = 0xff0000

	// USB1_LOOPBACK_HSFSCNT: USB PHY Loopback Packet Number Select Register
	// Position of TSTI_HS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_TSTI_HS_NUMBER_Pos = 0x0
	// Bit mask of TSTI_HS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_TSTI_HS_NUMBER_Msk = 0xffff
	// Position of TSTI_FS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_TSTI_FS_NUMBER_Pos = 0x10
	// Bit mask of TSTI_FS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_TSTI_FS_NUMBER_Msk = 0xffff0000

	// USB1_LOOPBACK_HSFSCNT_SET: USB PHY Loopback Packet Number Select Register
	// Position of TSTI_HS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_SET_TSTI_HS_NUMBER_Pos = 0x0
	// Bit mask of TSTI_HS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_SET_TSTI_HS_NUMBER_Msk = 0xffff
	// Position of TSTI_FS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_SET_TSTI_FS_NUMBER_Pos = 0x10
	// Bit mask of TSTI_FS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_SET_TSTI_FS_NUMBER_Msk = 0xffff0000

	// USB1_LOOPBACK_HSFSCNT_CLR: USB PHY Loopback Packet Number Select Register
	// Position of TSTI_HS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_CLR_TSTI_HS_NUMBER_Pos = 0x0
	// Bit mask of TSTI_HS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_CLR_TSTI_HS_NUMBER_Msk = 0xffff
	// Position of TSTI_FS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_CLR_TSTI_FS_NUMBER_Pos = 0x10
	// Bit mask of TSTI_FS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_CLR_TSTI_FS_NUMBER_Msk = 0xffff0000

	// USB1_LOOPBACK_HSFSCNT_TOG: USB PHY Loopback Packet Number Select Register
	// Position of TSTI_HS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_TOG_TSTI_HS_NUMBER_Pos = 0x0
	// Bit mask of TSTI_HS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_TOG_TSTI_HS_NUMBER_Msk = 0xffff
	// Position of TSTI_FS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_TOG_TSTI_FS_NUMBER_Pos = 0x10
	// Bit mask of TSTI_FS_NUMBER field.
	USBPHY_USB1_LOOPBACK_HSFSCNT_TOG_TSTI_FS_NUMBER_Msk = 0xffff0000

	// TRIM_OVERRIDE_EN: USB PHY Trim Override Enable Register
	// Position of TRIM_DIV_SEL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_DIV_SEL_OVERRIDE_Pos = 0x0
	// Bit mask of TRIM_DIV_SEL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_DIV_SEL_OVERRIDE_Msk = 0x1
	// Bit TRIM_DIV_SEL_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_DIV_SEL_OVERRIDE = 0x1
	// Position of TRIM_ENV_TAIL_ADJ_VD_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE_Pos = 0x1
	// Bit mask of TRIM_ENV_TAIL_ADJ_VD_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE_Msk = 0x2
	// Bit TRIM_ENV_TAIL_ADJ_VD_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE = 0x2
	// Position of TRIM_TX_D_CAL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_TX_D_CAL_OVERRIDE_Pos = 0x2
	// Bit mask of TRIM_TX_D_CAL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_TX_D_CAL_OVERRIDE_Msk = 0x4
	// Bit TRIM_TX_D_CAL_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_TX_D_CAL_OVERRIDE = 0x4
	// Position of TRIM_TX_CAL45DP_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DP_OVERRIDE_Pos = 0x3
	// Bit mask of TRIM_TX_CAL45DP_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DP_OVERRIDE_Msk = 0x8
	// Bit TRIM_TX_CAL45DP_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DP_OVERRIDE = 0x8
	// Position of TRIM_TX_CAL45DM_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DM_OVERRIDE_Pos = 0x4
	// Bit mask of TRIM_TX_CAL45DM_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DM_OVERRIDE_Msk = 0x10
	// Bit TRIM_TX_CAL45DM_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_TX_CAL45DM_OVERRIDE = 0x10
	// Position of TRIM_PLL_CTRL0_DIV_SEL field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_PLL_CTRL0_DIV_SEL_Pos = 0x10
	// Bit mask of TRIM_PLL_CTRL0_DIV_SEL field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_PLL_CTRL0_DIV_SEL_Msk = 0x30000
	// Position of TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_USB_REG_ENV_TAIL_ADJ_VD_Pos = 0x12
	// Bit mask of TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_USB_REG_ENV_TAIL_ADJ_VD_Msk = 0xc0000
	// Position of TRIM_USBPHY_TX_D_CAL field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_USBPHY_TX_D_CAL_Pos = 0x14
	// Bit mask of TRIM_USBPHY_TX_D_CAL field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_USBPHY_TX_D_CAL_Msk = 0xf00000
	// Position of TRIM_USBPHY_TX_CAL45DP field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DP_Pos = 0x18
	// Bit mask of TRIM_USBPHY_TX_CAL45DP field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DP_Msk = 0xf000000
	// Position of TRIM_USBPHY_TX_CAL45DM field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DM_Pos = 0x1c
	// Bit mask of TRIM_USBPHY_TX_CAL45DM field.
	USBPHY_TRIM_OVERRIDE_EN_TRIM_USBPHY_TX_CAL45DM_Msk = 0xf0000000

	// TRIM_OVERRIDE_EN_SET: USB PHY Trim Override Enable Register
	// Position of TRIM_DIV_SEL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_DIV_SEL_OVERRIDE_Pos = 0x0
	// Bit mask of TRIM_DIV_SEL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_DIV_SEL_OVERRIDE_Msk = 0x1
	// Bit TRIM_DIV_SEL_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_DIV_SEL_OVERRIDE = 0x1
	// Position of TRIM_ENV_TAIL_ADJ_VD_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE_Pos = 0x1
	// Bit mask of TRIM_ENV_TAIL_ADJ_VD_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE_Msk = 0x2
	// Bit TRIM_ENV_TAIL_ADJ_VD_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE = 0x2
	// Position of TRIM_TX_D_CAL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_TX_D_CAL_OVERRIDE_Pos = 0x2
	// Bit mask of TRIM_TX_D_CAL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_TX_D_CAL_OVERRIDE_Msk = 0x4
	// Bit TRIM_TX_D_CAL_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_TX_D_CAL_OVERRIDE = 0x4
	// Position of TRIM_TX_CAL45DP_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DP_OVERRIDE_Pos = 0x3
	// Bit mask of TRIM_TX_CAL45DP_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DP_OVERRIDE_Msk = 0x8
	// Bit TRIM_TX_CAL45DP_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DP_OVERRIDE = 0x8
	// Position of TRIM_TX_CAL45DM_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DM_OVERRIDE_Pos = 0x4
	// Bit mask of TRIM_TX_CAL45DM_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DM_OVERRIDE_Msk = 0x10
	// Bit TRIM_TX_CAL45DM_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_TX_CAL45DM_OVERRIDE = 0x10
	// Position of TRIM_PLL_CTRL0_DIV_SEL field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_PLL_CTRL0_DIV_SEL_Pos = 0x10
	// Bit mask of TRIM_PLL_CTRL0_DIV_SEL field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_PLL_CTRL0_DIV_SEL_Msk = 0x30000
	// Position of TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_USB_REG_ENV_TAIL_ADJ_VD_Pos = 0x12
	// Bit mask of TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_USB_REG_ENV_TAIL_ADJ_VD_Msk = 0xc0000
	// Position of TRIM_USBPHY_TX_D_CAL field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_D_CAL_Pos = 0x14
	// Bit mask of TRIM_USBPHY_TX_D_CAL field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_D_CAL_Msk = 0xf00000
	// Position of TRIM_USBPHY_TX_CAL45DP field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DP_Pos = 0x18
	// Bit mask of TRIM_USBPHY_TX_CAL45DP field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DP_Msk = 0xf000000
	// Position of TRIM_USBPHY_TX_CAL45DM field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DM_Pos = 0x1c
	// Bit mask of TRIM_USBPHY_TX_CAL45DM field.
	USBPHY_TRIM_OVERRIDE_EN_SET_TRIM_USBPHY_TX_CAL45DM_Msk = 0xf0000000

	// TRIM_OVERRIDE_EN_CLR: USB PHY Trim Override Enable Register
	// Position of TRIM_DIV_SEL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_DIV_SEL_OVERRIDE_Pos = 0x0
	// Bit mask of TRIM_DIV_SEL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_DIV_SEL_OVERRIDE_Msk = 0x1
	// Bit TRIM_DIV_SEL_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_DIV_SEL_OVERRIDE = 0x1
	// Position of TRIM_ENV_TAIL_ADJ_VD_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE_Pos = 0x1
	// Bit mask of TRIM_ENV_TAIL_ADJ_VD_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE_Msk = 0x2
	// Bit TRIM_ENV_TAIL_ADJ_VD_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE = 0x2
	// Position of TRIM_TX_D_CAL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_TX_D_CAL_OVERRIDE_Pos = 0x2
	// Bit mask of TRIM_TX_D_CAL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_TX_D_CAL_OVERRIDE_Msk = 0x4
	// Bit TRIM_TX_D_CAL_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_TX_D_CAL_OVERRIDE = 0x4
	// Position of TRIM_TX_CAL45DP_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DP_OVERRIDE_Pos = 0x3
	// Bit mask of TRIM_TX_CAL45DP_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DP_OVERRIDE_Msk = 0x8
	// Bit TRIM_TX_CAL45DP_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DP_OVERRIDE = 0x8
	// Position of TRIM_TX_CAL45DM_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DM_OVERRIDE_Pos = 0x4
	// Bit mask of TRIM_TX_CAL45DM_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DM_OVERRIDE_Msk = 0x10
	// Bit TRIM_TX_CAL45DM_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_TX_CAL45DM_OVERRIDE = 0x10
	// Position of TRIM_PLL_CTRL0_DIV_SEL field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_PLL_CTRL0_DIV_SEL_Pos = 0x10
	// Bit mask of TRIM_PLL_CTRL0_DIV_SEL field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_PLL_CTRL0_DIV_SEL_Msk = 0x30000
	// Position of TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_USB_REG_ENV_TAIL_ADJ_VD_Pos = 0x12
	// Bit mask of TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_USB_REG_ENV_TAIL_ADJ_VD_Msk = 0xc0000
	// Position of TRIM_USBPHY_TX_D_CAL field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_D_CAL_Pos = 0x14
	// Bit mask of TRIM_USBPHY_TX_D_CAL field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_D_CAL_Msk = 0xf00000
	// Position of TRIM_USBPHY_TX_CAL45DP field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DP_Pos = 0x18
	// Bit mask of TRIM_USBPHY_TX_CAL45DP field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DP_Msk = 0xf000000
	// Position of TRIM_USBPHY_TX_CAL45DM field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DM_Pos = 0x1c
	// Bit mask of TRIM_USBPHY_TX_CAL45DM field.
	USBPHY_TRIM_OVERRIDE_EN_CLR_TRIM_USBPHY_TX_CAL45DM_Msk = 0xf0000000

	// TRIM_OVERRIDE_EN_TOG: USB PHY Trim Override Enable Register
	// Position of TRIM_DIV_SEL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_DIV_SEL_OVERRIDE_Pos = 0x0
	// Bit mask of TRIM_DIV_SEL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_DIV_SEL_OVERRIDE_Msk = 0x1
	// Bit TRIM_DIV_SEL_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_DIV_SEL_OVERRIDE = 0x1
	// Position of TRIM_ENV_TAIL_ADJ_VD_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE_Pos = 0x1
	// Bit mask of TRIM_ENV_TAIL_ADJ_VD_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE_Msk = 0x2
	// Bit TRIM_ENV_TAIL_ADJ_VD_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_ENV_TAIL_ADJ_VD_OVERRIDE = 0x2
	// Position of TRIM_TX_D_CAL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_TX_D_CAL_OVERRIDE_Pos = 0x2
	// Bit mask of TRIM_TX_D_CAL_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_TX_D_CAL_OVERRIDE_Msk = 0x4
	// Bit TRIM_TX_D_CAL_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_TX_D_CAL_OVERRIDE = 0x4
	// Position of TRIM_TX_CAL45DP_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DP_OVERRIDE_Pos = 0x3
	// Bit mask of TRIM_TX_CAL45DP_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DP_OVERRIDE_Msk = 0x8
	// Bit TRIM_TX_CAL45DP_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DP_OVERRIDE = 0x8
	// Position of TRIM_TX_CAL45DM_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DM_OVERRIDE_Pos = 0x4
	// Bit mask of TRIM_TX_CAL45DM_OVERRIDE field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DM_OVERRIDE_Msk = 0x10
	// Bit TRIM_TX_CAL45DM_OVERRIDE.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_TX_CAL45DM_OVERRIDE = 0x10
	// Position of TRIM_PLL_CTRL0_DIV_SEL field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_PLL_CTRL0_DIV_SEL_Pos = 0x10
	// Bit mask of TRIM_PLL_CTRL0_DIV_SEL field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_PLL_CTRL0_DIV_SEL_Msk = 0x30000
	// Position of TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_USB_REG_ENV_TAIL_ADJ_VD_Pos = 0x12
	// Bit mask of TRIM_USB_REG_ENV_TAIL_ADJ_VD field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_USB_REG_ENV_TAIL_ADJ_VD_Msk = 0xc0000
	// Position of TRIM_USBPHY_TX_D_CAL field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_D_CAL_Pos = 0x14
	// Bit mask of TRIM_USBPHY_TX_D_CAL field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_D_CAL_Msk = 0xf00000
	// Position of TRIM_USBPHY_TX_CAL45DP field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DP_Pos = 0x18
	// Bit mask of TRIM_USBPHY_TX_CAL45DP field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DP_Msk = 0xf000000
	// Position of TRIM_USBPHY_TX_CAL45DM field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DM_Pos = 0x1c
	// Bit mask of TRIM_USBPHY_TX_CAL45DM field.
	USBPHY_TRIM_OVERRIDE_EN_TOG_TRIM_USBPHY_TX_CAL45DM_Msk = 0xf0000000
)

// Constants for USBHSDCD: USB Device Charger Detection module
const (
	// CONTROL: Control register
	// Position of IACK field.
	USBHSDCD_CONTROL_IACK_Pos = 0x0
	// Bit mask of IACK field.
	USBHSDCD_CONTROL_IACK_Msk = 0x1
	// Bit IACK.
	USBHSDCD_CONTROL_IACK = 0x1
	// Do not clear the interrupt.
	USBHSDCD_CONTROL_IACK_0 = 0x0
	// Clear the IF bit (interrupt flag).
	USBHSDCD_CONTROL_IACK_1 = 0x1
	// Position of IF field.
	USBHSDCD_CONTROL_IF_Pos = 0x8
	// Bit mask of IF field.
	USBHSDCD_CONTROL_IF_Msk = 0x100
	// Bit IF.
	USBHSDCD_CONTROL_IF = 0x100
	// No interrupt is pending.
	USBHSDCD_CONTROL_IF_0 = 0x0
	// An interrupt is pending.
	USBHSDCD_CONTROL_IF_1 = 0x1
	// Position of IE field.
	USBHSDCD_CONTROL_IE_Pos = 0x10
	// Bit mask of IE field.
	USBHSDCD_CONTROL_IE_Msk = 0x10000
	// Bit IE.
	USBHSDCD_CONTROL_IE = 0x10000
	// Disable interrupts to the system.
	USBHSDCD_CONTROL_IE_0 = 0x0
	// Enable interrupts to the system.
	USBHSDCD_CONTROL_IE_1 = 0x1
	// Position of BC12 field.
	USBHSDCD_CONTROL_BC12_Pos = 0x11
	// Bit mask of BC12 field.
	USBHSDCD_CONTROL_BC12_Msk = 0x20000
	// Bit BC12.
	USBHSDCD_CONTROL_BC12 = 0x20000
	// Compatible with BC1.1 (default)
	USBHSDCD_CONTROL_BC12_0 = 0x0
	// Compatible with BC1.2
	USBHSDCD_CONTROL_BC12_1 = 0x1
	// Position of START field.
	USBHSDCD_CONTROL_START_Pos = 0x18
	// Bit mask of START field.
	USBHSDCD_CONTROL_START_Msk = 0x1000000
	// Bit START.
	USBHSDCD_CONTROL_START = 0x1000000
	// Do not start the sequence. Writes of this value have no effect.
	USBHSDCD_CONTROL_START_0 = 0x0
	// Initiate the charger detection sequence. If the sequence is already running, writes of this value have no effect.
	USBHSDCD_CONTROL_START_1 = 0x1
	// Position of SR field.
	USBHSDCD_CONTROL_SR_Pos = 0x19
	// Bit mask of SR field.
	USBHSDCD_CONTROL_SR_Msk = 0x2000000
	// Bit SR.
	USBHSDCD_CONTROL_SR = 0x2000000
	// Do not perform a software reset.
	USBHSDCD_CONTROL_SR_0 = 0x0
	// Perform a software reset.
	USBHSDCD_CONTROL_SR_1 = 0x1

	// CLOCK: Clock register
	// Position of CLOCK_UNIT field.
	USBHSDCD_CLOCK_CLOCK_UNIT_Pos = 0x0
	// Bit mask of CLOCK_UNIT field.
	USBHSDCD_CLOCK_CLOCK_UNIT_Msk = 0x1
	// Bit CLOCK_UNIT.
	USBHSDCD_CLOCK_CLOCK_UNIT = 0x1
	// kHz Speed (between 1 kHz and 1023 kHz)
	USBHSDCD_CLOCK_CLOCK_UNIT_0 = 0x0
	// MHz Speed (between 1 MHz and 1023 MHz)
	USBHSDCD_CLOCK_CLOCK_UNIT_1 = 0x1
	// Position of CLOCK_SPEED field.
	USBHSDCD_CLOCK_CLOCK_SPEED_Pos = 0x2
	// Bit mask of CLOCK_SPEED field.
	USBHSDCD_CLOCK_CLOCK_SPEED_Msk = 0xffc

	// STATUS: Status register
	// Position of SEQ_RES field.
	USBHSDCD_STATUS_SEQ_RES_Pos = 0x10
	// Bit mask of SEQ_RES field.
	USBHSDCD_STATUS_SEQ_RES_Msk = 0x30000
	// No results to report.
	USBHSDCD_STATUS_SEQ_RES_00 = 0x0
	// Attached to an SDP. Must comply with USB 2.0 by drawing only 2.5 mA (max) until connected.
	USBHSDCD_STATUS_SEQ_RES_01 = 0x1
	// Attached to a charging port. The exact meaning depends on bit 18: 0: Attached to either a CDP or a DCP. The charger type detection has not completed. 1: Attached to a CDP. The charger type detection has completed.
	USBHSDCD_STATUS_SEQ_RES_10 = 0x2
	// Attached to a DCP.
	USBHSDCD_STATUS_SEQ_RES_11 = 0x3
	// Position of SEQ_STAT field.
	USBHSDCD_STATUS_SEQ_STAT_Pos = 0x12
	// Bit mask of SEQ_STAT field.
	USBHSDCD_STATUS_SEQ_STAT_Msk = 0xc0000
	// The module is either not enabled, or the module is enabled but the data pins have not yet been detected.
	USBHSDCD_STATUS_SEQ_STAT_00 = 0x0
	// Data pin contact detection is complete.
	USBHSDCD_STATUS_SEQ_STAT_01 = 0x1
	// Charging port detection is complete.
	USBHSDCD_STATUS_SEQ_STAT_10 = 0x2
	// Charger type detection is complete.
	USBHSDCD_STATUS_SEQ_STAT_11 = 0x3
	// Position of ERR field.
	USBHSDCD_STATUS_ERR_Pos = 0x14
	// Bit mask of ERR field.
	USBHSDCD_STATUS_ERR_Msk = 0x100000
	// Bit ERR.
	USBHSDCD_STATUS_ERR = 0x100000
	// No sequence errors.
	USBHSDCD_STATUS_ERR_0 = 0x0
	// Error in the detection sequence. See the SEQ_STAT field to determine the phase in which the error occurred.
	USBHSDCD_STATUS_ERR_1 = 0x1
	// Position of TO field.
	USBHSDCD_STATUS_TO_Pos = 0x15
	// Bit mask of TO field.
	USBHSDCD_STATUS_TO_Msk = 0x200000
	// Bit TO.
	USBHSDCD_STATUS_TO = 0x200000
	// The detection sequence has not been running for over 1 s.
	USBHSDCD_STATUS_TO_0 = 0x0
	// It has been over 1 s since the data pin contact was detected and debounced.
	USBHSDCD_STATUS_TO_1 = 0x1
	// Position of ACTIVE field.
	USBHSDCD_STATUS_ACTIVE_Pos = 0x16
	// Bit mask of ACTIVE field.
	USBHSDCD_STATUS_ACTIVE_Msk = 0x400000
	// Bit ACTIVE.
	USBHSDCD_STATUS_ACTIVE = 0x400000
	// The sequence is not running.
	USBHSDCD_STATUS_ACTIVE_0 = 0x0
	// The sequence is running.
	USBHSDCD_STATUS_ACTIVE_1 = 0x1

	// SIGNAL_OVERRIDE: Signal Override Register
	// Position of PS field.
	USBHSDCD_SIGNAL_OVERRIDE_PS_Pos = 0x0
	// Bit mask of PS field.
	USBHSDCD_SIGNAL_OVERRIDE_PS_Msk = 0x3
	// No overrides. Bit field must remain at this value during normal USB data communication to prevent unexpected conditions on USB_DP and USB_DM pins. (Default)
	USBHSDCD_SIGNAL_OVERRIDE_PS_00 = 0x0
	// Reserved, not for customer use.
	USBHSDCD_SIGNAL_OVERRIDE_PS_01 = 0x1
	// Enables VDP_SRC voltage source for the USB_DP pin and IDM_SINK current source for the USB_DM pin.
	USBHSDCD_SIGNAL_OVERRIDE_PS_10 = 0x2
	// Reserved, not for customer use.
	USBHSDCD_SIGNAL_OVERRIDE_PS_11 = 0x3

	// TIMER0: TIMER0 register
	// Position of TUNITCON field.
	USBHSDCD_TIMER0_TUNITCON_Pos = 0x0
	// Bit mask of TUNITCON field.
	USBHSDCD_TIMER0_TUNITCON_Msk = 0xfff
	// Position of TSEQ_INIT field.
	USBHSDCD_TIMER0_TSEQ_INIT_Pos = 0x10
	// Bit mask of TSEQ_INIT field.
	USBHSDCD_TIMER0_TSEQ_INIT_Msk = 0x3ff0000

	// TIMER1: TIMER1 register
	// Position of TVDPSRC_ON field.
	USBHSDCD_TIMER1_TVDPSRC_ON_Pos = 0x0
	// Bit mask of TVDPSRC_ON field.
	USBHSDCD_TIMER1_TVDPSRC_ON_Msk = 0x3ff
	// Position of TDCD_DBNC field.
	USBHSDCD_TIMER1_TDCD_DBNC_Pos = 0x10
	// Bit mask of TDCD_DBNC field.
	USBHSDCD_TIMER1_TDCD_DBNC_Msk = 0x3ff0000

	// TIMER2_BC11: TIMER2_BC11 register
	// Position of CHECK_DM field.
	USBHSDCD_TIMER2_BC11_CHECK_DM_Pos = 0x0
	// Bit mask of CHECK_DM field.
	USBHSDCD_TIMER2_BC11_CHECK_DM_Msk = 0xf
	// Position of TVDPSRC_CON field.
	USBHSDCD_TIMER2_BC11_TVDPSRC_CON_Pos = 0x10
	// Bit mask of TVDPSRC_CON field.
	USBHSDCD_TIMER2_BC11_TVDPSRC_CON_Msk = 0x3ff0000

	// TIMER2_BC12: TIMER2_BC12 register
	// Position of TVDMSRC_ON field.
	USBHSDCD_TIMER2_BC12_TVDMSRC_ON_Pos = 0x0
	// Bit mask of TVDMSRC_ON field.
	USBHSDCD_TIMER2_BC12_TVDMSRC_ON_Msk = 0x3ff
	// Position of TWAIT_AFTER_PRD field.
	USBHSDCD_TIMER2_BC12_TWAIT_AFTER_PRD_Pos = 0x10
	// Bit mask of TWAIT_AFTER_PRD field.
	USBHSDCD_TIMER2_BC12_TWAIT_AFTER_PRD_Msk = 0x3ff0000
)

// Constants for SDHC: Secured Digital Host Controller
const (
	// DSADDR: DMA System Address register
	// Position of DSADDR field.
	SDHC_DSADDR_DSADDR_Pos = 0x2
	// Bit mask of DSADDR field.
	SDHC_DSADDR_DSADDR_Msk = 0xfffffffc

	// BLKATTR: Block Attributes register
	// Position of BLKSIZE field.
	SDHC_BLKATTR_BLKSIZE_Pos = 0x0
	// Bit mask of BLKSIZE field.
	SDHC_BLKATTR_BLKSIZE_Msk = 0x1fff
	// No data transfer.
	SDHC_BLKATTR_BLKSIZE_0 = 0x0
	// 1 Byte
	SDHC_BLKATTR_BLKSIZE_1 = 0x1
	// 2 Bytes
	SDHC_BLKATTR_BLKSIZE_10 = 0x2
	// 3 Bytes
	SDHC_BLKATTR_BLKSIZE_11 = 0x3
	// 4 Bytes
	SDHC_BLKATTR_BLKSIZE_100 = 0x4
	// 511 Bytes
	SDHC_BLKATTR_BLKSIZE_111111111 = 0x1ff
	// 512 Bytes
	SDHC_BLKATTR_BLKSIZE_1000000000 = 0x200
	// 2048 Bytes
	SDHC_BLKATTR_BLKSIZE_100000000000 = 0x800
	// 4096 Bytes
	SDHC_BLKATTR_BLKSIZE_1000000000000 = 0x1000
	// Position of BLKCNT field.
	SDHC_BLKATTR_BLKCNT_Pos = 0x10
	// Bit mask of BLKCNT field.
	SDHC_BLKATTR_BLKCNT_Msk = 0xffff0000
	// Stop count.
	SDHC_BLKATTR_BLKCNT_0 = 0x0
	// 1 block
	SDHC_BLKATTR_BLKCNT_1 = 0x1
	// 2 blocks
	SDHC_BLKATTR_BLKCNT_10 = 0x2
	// 65535 blocks
	SDHC_BLKATTR_BLKCNT_1111111111111111 = 0xffff

	// CMDARG: Command Argument register
	// Position of CMDARG field.
	SDHC_CMDARG_CMDARG_Pos = 0x0
	// Bit mask of CMDARG field.
	SDHC_CMDARG_CMDARG_Msk = 0xffffffff

	// XFERTYP: Transfer Type register
	// Position of DMAEN field.
	SDHC_XFERTYP_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	SDHC_XFERTYP_DMAEN_Msk = 0x1
	// Bit DMAEN.
	SDHC_XFERTYP_DMAEN = 0x1
	// Disable
	SDHC_XFERTYP_DMAEN_0 = 0x0
	// Enable
	SDHC_XFERTYP_DMAEN_1 = 0x1
	// Position of BCEN field.
	SDHC_XFERTYP_BCEN_Pos = 0x1
	// Bit mask of BCEN field.
	SDHC_XFERTYP_BCEN_Msk = 0x2
	// Bit BCEN.
	SDHC_XFERTYP_BCEN = 0x2
	// Disable
	SDHC_XFERTYP_BCEN_0 = 0x0
	// Enable
	SDHC_XFERTYP_BCEN_1 = 0x1
	// Position of AC12EN field.
	SDHC_XFERTYP_AC12EN_Pos = 0x2
	// Bit mask of AC12EN field.
	SDHC_XFERTYP_AC12EN_Msk = 0x4
	// Bit AC12EN.
	SDHC_XFERTYP_AC12EN = 0x4
	// Disable
	SDHC_XFERTYP_AC12EN_0 = 0x0
	// Enable
	SDHC_XFERTYP_AC12EN_1 = 0x1
	// Position of DTDSEL field.
	SDHC_XFERTYP_DTDSEL_Pos = 0x4
	// Bit mask of DTDSEL field.
	SDHC_XFERTYP_DTDSEL_Msk = 0x10
	// Bit DTDSEL.
	SDHC_XFERTYP_DTDSEL = 0x10
	// Write host to card.
	SDHC_XFERTYP_DTDSEL_0 = 0x0
	// Read card to host.
	SDHC_XFERTYP_DTDSEL_1 = 0x1
	// Position of MSBSEL field.
	SDHC_XFERTYP_MSBSEL_Pos = 0x5
	// Bit mask of MSBSEL field.
	SDHC_XFERTYP_MSBSEL_Msk = 0x20
	// Bit MSBSEL.
	SDHC_XFERTYP_MSBSEL = 0x20
	// Single block.
	SDHC_XFERTYP_MSBSEL_0 = 0x0
	// Multiple blocks.
	SDHC_XFERTYP_MSBSEL_1 = 0x1
	// Position of RSPTYP field.
	SDHC_XFERTYP_RSPTYP_Pos = 0x10
	// Bit mask of RSPTYP field.
	SDHC_XFERTYP_RSPTYP_Msk = 0x30000
	// No response.
	SDHC_XFERTYP_RSPTYP_00 = 0x0
	// Response length 136.
	SDHC_XFERTYP_RSPTYP_01 = 0x1
	// Response length 48.
	SDHC_XFERTYP_RSPTYP_10 = 0x2
	// Response length 48, check busy after response.
	SDHC_XFERTYP_RSPTYP_11 = 0x3
	// Position of CCCEN field.
	SDHC_XFERTYP_CCCEN_Pos = 0x13
	// Bit mask of CCCEN field.
	SDHC_XFERTYP_CCCEN_Msk = 0x80000
	// Bit CCCEN.
	SDHC_XFERTYP_CCCEN = 0x80000
	// Disable
	SDHC_XFERTYP_CCCEN_0 = 0x0
	// Enable
	SDHC_XFERTYP_CCCEN_1 = 0x1
	// Position of CICEN field.
	SDHC_XFERTYP_CICEN_Pos = 0x14
	// Bit mask of CICEN field.
	SDHC_XFERTYP_CICEN_Msk = 0x100000
	// Bit CICEN.
	SDHC_XFERTYP_CICEN = 0x100000
	// Disable
	SDHC_XFERTYP_CICEN_0 = 0x0
	// Enable
	SDHC_XFERTYP_CICEN_1 = 0x1
	// Position of DPSEL field.
	SDHC_XFERTYP_DPSEL_Pos = 0x15
	// Bit mask of DPSEL field.
	SDHC_XFERTYP_DPSEL_Msk = 0x200000
	// Bit DPSEL.
	SDHC_XFERTYP_DPSEL = 0x200000
	// No data present.
	SDHC_XFERTYP_DPSEL_0 = 0x0
	// Data present.
	SDHC_XFERTYP_DPSEL_1 = 0x1
	// Position of CMDTYP field.
	SDHC_XFERTYP_CMDTYP_Pos = 0x16
	// Bit mask of CMDTYP field.
	SDHC_XFERTYP_CMDTYP_Msk = 0xc00000
	// Normal other commands.
	SDHC_XFERTYP_CMDTYP_00 = 0x0
	// Suspend CMD52 for writing bus suspend in CCCR.
	SDHC_XFERTYP_CMDTYP_01 = 0x1
	// Resume CMD52 for writing function select in CCCR.
	SDHC_XFERTYP_CMDTYP_10 = 0x2
	// Abort CMD12, CMD52 for writing I/O abort in CCCR.
	SDHC_XFERTYP_CMDTYP_11 = 0x3
	// Position of CMDINX field.
	SDHC_XFERTYP_CMDINX_Pos = 0x18
	// Bit mask of CMDINX field.
	SDHC_XFERTYP_CMDINX_Msk = 0x3f000000

	// CMDRSP0: Command Response 0
	// Position of CMDRSP0 field.
	SDHC_CMDRSP0_CMDRSP0_Pos = 0x0
	// Bit mask of CMDRSP0 field.
	SDHC_CMDRSP0_CMDRSP0_Msk = 0xffffffff

	// CMDRSP1: Command Response 1
	// Position of CMDRSP1 field.
	SDHC_CMDRSP1_CMDRSP1_Pos = 0x0
	// Bit mask of CMDRSP1 field.
	SDHC_CMDRSP1_CMDRSP1_Msk = 0xffffffff

	// CMDRSP2: Command Response 2
	// Position of CMDRSP2 field.
	SDHC_CMDRSP2_CMDRSP2_Pos = 0x0
	// Bit mask of CMDRSP2 field.
	SDHC_CMDRSP2_CMDRSP2_Msk = 0xffffffff

	// CMDRSP3: Command Response 3
	// Position of CMDRSP3 field.
	SDHC_CMDRSP3_CMDRSP3_Pos = 0x0
	// Bit mask of CMDRSP3 field.
	SDHC_CMDRSP3_CMDRSP3_Msk = 0xffffffff

	// DATPORT: Buffer Data Port register
	// Position of DATCONT field.
	SDHC_DATPORT_DATCONT_Pos = 0x0
	// Bit mask of DATCONT field.
	SDHC_DATPORT_DATCONT_Msk = 0xffffffff

	// PRSSTAT: Present State register
	// Position of CIHB field.
	SDHC_PRSSTAT_CIHB_Pos = 0x0
	// Bit mask of CIHB field.
	SDHC_PRSSTAT_CIHB_Msk = 0x1
	// Bit CIHB.
	SDHC_PRSSTAT_CIHB = 0x1
	// Can issue command using only CMD line.
	SDHC_PRSSTAT_CIHB_0 = 0x0
	// Cannot issue command.
	SDHC_PRSSTAT_CIHB_1 = 0x1
	// Position of CDIHB field.
	SDHC_PRSSTAT_CDIHB_Pos = 0x1
	// Bit mask of CDIHB field.
	SDHC_PRSSTAT_CDIHB_Msk = 0x2
	// Bit CDIHB.
	SDHC_PRSSTAT_CDIHB = 0x2
	// Can issue command which uses the DAT line.
	SDHC_PRSSTAT_CDIHB_0 = 0x0
	// Cannot issue command which uses the DAT line.
	SDHC_PRSSTAT_CDIHB_1 = 0x1
	// Position of DLA field.
	SDHC_PRSSTAT_DLA_Pos = 0x2
	// Bit mask of DLA field.
	SDHC_PRSSTAT_DLA_Msk = 0x4
	// Bit DLA.
	SDHC_PRSSTAT_DLA = 0x4
	// DAT line inactive.
	SDHC_PRSSTAT_DLA_0 = 0x0
	// DAT line active.
	SDHC_PRSSTAT_DLA_1 = 0x1
	// Position of SDSTB field.
	SDHC_PRSSTAT_SDSTB_Pos = 0x3
	// Bit mask of SDSTB field.
	SDHC_PRSSTAT_SDSTB_Msk = 0x8
	// Bit SDSTB.
	SDHC_PRSSTAT_SDSTB = 0x8
	// Clock is changing frequency and not stable.
	SDHC_PRSSTAT_SDSTB_0 = 0x0
	// Clock is stable.
	SDHC_PRSSTAT_SDSTB_1 = 0x1
	// Position of IPGOFF field.
	SDHC_PRSSTAT_IPGOFF_Pos = 0x4
	// Bit mask of IPGOFF field.
	SDHC_PRSSTAT_IPGOFF_Msk = 0x10
	// Bit IPGOFF.
	SDHC_PRSSTAT_IPGOFF = 0x10
	// Bus clock is active.
	SDHC_PRSSTAT_IPGOFF_0 = 0x0
	// Bus clock is gated off.
	SDHC_PRSSTAT_IPGOFF_1 = 0x1
	// Position of HCKOFF field.
	SDHC_PRSSTAT_HCKOFF_Pos = 0x5
	// Bit mask of HCKOFF field.
	SDHC_PRSSTAT_HCKOFF_Msk = 0x20
	// Bit HCKOFF.
	SDHC_PRSSTAT_HCKOFF = 0x20
	// System clock is active.
	SDHC_PRSSTAT_HCKOFF_0 = 0x0
	// System clock is gated off.
	SDHC_PRSSTAT_HCKOFF_1 = 0x1
	// Position of PEROFF field.
	SDHC_PRSSTAT_PEROFF_Pos = 0x6
	// Bit mask of PEROFF field.
	SDHC_PRSSTAT_PEROFF_Msk = 0x40
	// Bit PEROFF.
	SDHC_PRSSTAT_PEROFF = 0x40
	// SDHC clock is active.
	SDHC_PRSSTAT_PEROFF_0 = 0x0
	// SDHC clock is gated off.
	SDHC_PRSSTAT_PEROFF_1 = 0x1
	// Position of SDOFF field.
	SDHC_PRSSTAT_SDOFF_Pos = 0x7
	// Bit mask of SDOFF field.
	SDHC_PRSSTAT_SDOFF_Msk = 0x80
	// Bit SDOFF.
	SDHC_PRSSTAT_SDOFF = 0x80
	// SD clock is active.
	SDHC_PRSSTAT_SDOFF_0 = 0x0
	// SD clock is gated off.
	SDHC_PRSSTAT_SDOFF_1 = 0x1
	// Position of WTA field.
	SDHC_PRSSTAT_WTA_Pos = 0x8
	// Bit mask of WTA field.
	SDHC_PRSSTAT_WTA_Msk = 0x100
	// Bit WTA.
	SDHC_PRSSTAT_WTA = 0x100
	// No valid data.
	SDHC_PRSSTAT_WTA_0 = 0x0
	// Transferring data.
	SDHC_PRSSTAT_WTA_1 = 0x1
	// Position of RTA field.
	SDHC_PRSSTAT_RTA_Pos = 0x9
	// Bit mask of RTA field.
	SDHC_PRSSTAT_RTA_Msk = 0x200
	// Bit RTA.
	SDHC_PRSSTAT_RTA = 0x200
	// No valid data.
	SDHC_PRSSTAT_RTA_0 = 0x0
	// Transferring data.
	SDHC_PRSSTAT_RTA_1 = 0x1
	// Position of BWEN field.
	SDHC_PRSSTAT_BWEN_Pos = 0xa
	// Bit mask of BWEN field.
	SDHC_PRSSTAT_BWEN_Msk = 0x400
	// Bit BWEN.
	SDHC_PRSSTAT_BWEN = 0x400
	// Write disable, the buffer can hold valid data less than the write watermark level.
	SDHC_PRSSTAT_BWEN_0 = 0x0
	// Write enable, the buffer can hold valid data greater than the write watermark level.
	SDHC_PRSSTAT_BWEN_1 = 0x1
	// Position of BREN field.
	SDHC_PRSSTAT_BREN_Pos = 0xb
	// Bit mask of BREN field.
	SDHC_PRSSTAT_BREN_Msk = 0x800
	// Bit BREN.
	SDHC_PRSSTAT_BREN = 0x800
	// Read disable, valid data less than the watermark level exist in the buffer.
	SDHC_PRSSTAT_BREN_0 = 0x0
	// Read enable, valid data greater than the watermark level exist in the buffer.
	SDHC_PRSSTAT_BREN_1 = 0x1
	// Position of CINS field.
	SDHC_PRSSTAT_CINS_Pos = 0x10
	// Bit mask of CINS field.
	SDHC_PRSSTAT_CINS_Msk = 0x10000
	// Bit CINS.
	SDHC_PRSSTAT_CINS = 0x10000
	// Power on reset or no card.
	SDHC_PRSSTAT_CINS_0 = 0x0
	// Card inserted.
	SDHC_PRSSTAT_CINS_1 = 0x1
	// Position of CLSL field.
	SDHC_PRSSTAT_CLSL_Pos = 0x17
	// Bit mask of CLSL field.
	SDHC_PRSSTAT_CLSL_Msk = 0x800000
	// Bit CLSL.
	SDHC_PRSSTAT_CLSL = 0x800000
	// Position of DLSL field.
	SDHC_PRSSTAT_DLSL_Pos = 0x18
	// Bit mask of DLSL field.
	SDHC_PRSSTAT_DLSL_Msk = 0xff000000

	// PROCTL: Protocol Control register
	// Position of LCTL field.
	SDHC_PROCTL_LCTL_Pos = 0x0
	// Bit mask of LCTL field.
	SDHC_PROCTL_LCTL_Msk = 0x1
	// Bit LCTL.
	SDHC_PROCTL_LCTL = 0x1
	// LED off.
	SDHC_PROCTL_LCTL_0 = 0x0
	// LED on.
	SDHC_PROCTL_LCTL_1 = 0x1
	// Position of DTW field.
	SDHC_PROCTL_DTW_Pos = 0x1
	// Bit mask of DTW field.
	SDHC_PROCTL_DTW_Msk = 0x6
	// 1-bit mode
	SDHC_PROCTL_DTW_00 = 0x0
	// 4-bit mode
	SDHC_PROCTL_DTW_01 = 0x1
	// 8-bit mode
	SDHC_PROCTL_DTW_10 = 0x2
	// Position of D3CD field.
	SDHC_PROCTL_D3CD_Pos = 0x3
	// Bit mask of D3CD field.
	SDHC_PROCTL_D3CD_Msk = 0x8
	// Bit D3CD.
	SDHC_PROCTL_D3CD = 0x8
	// DAT3 does not monitor card Insertion.
	SDHC_PROCTL_D3CD_0 = 0x0
	// DAT3 as card detection pin.
	SDHC_PROCTL_D3CD_1 = 0x1
	// Position of EMODE field.
	SDHC_PROCTL_EMODE_Pos = 0x4
	// Bit mask of EMODE field.
	SDHC_PROCTL_EMODE_Msk = 0x30
	// Big endian mode
	SDHC_PROCTL_EMODE_00 = 0x0
	// Half word big endian mode
	SDHC_PROCTL_EMODE_01 = 0x1
	// Little endian mode
	SDHC_PROCTL_EMODE_10 = 0x2
	// Position of CDTL field.
	SDHC_PROCTL_CDTL_Pos = 0x6
	// Bit mask of CDTL field.
	SDHC_PROCTL_CDTL_Msk = 0x40
	// Bit CDTL.
	SDHC_PROCTL_CDTL = 0x40
	// Card detect test level is 0, no card inserted.
	SDHC_PROCTL_CDTL_0 = 0x0
	// Card detect test level is 1, card inserted.
	SDHC_PROCTL_CDTL_1 = 0x1
	// Position of CDSS field.
	SDHC_PROCTL_CDSS_Pos = 0x7
	// Bit mask of CDSS field.
	SDHC_PROCTL_CDSS_Msk = 0x80
	// Bit CDSS.
	SDHC_PROCTL_CDSS = 0x80
	// Card detection level is selected for normal purpose.
	SDHC_PROCTL_CDSS_0 = 0x0
	// Card detection test level is selected for test purpose.
	SDHC_PROCTL_CDSS_1 = 0x1
	// Position of DMAS field.
	SDHC_PROCTL_DMAS_Pos = 0x8
	// Bit mask of DMAS field.
	SDHC_PROCTL_DMAS_Msk = 0x300
	// No DMA or simple DMA is selected.
	SDHC_PROCTL_DMAS_00 = 0x0
	// ADMA1 is selected.
	SDHC_PROCTL_DMAS_01 = 0x1
	// ADMA2 is selected.
	SDHC_PROCTL_DMAS_10 = 0x2
	// Position of SABGREQ field.
	SDHC_PROCTL_SABGREQ_Pos = 0x10
	// Bit mask of SABGREQ field.
	SDHC_PROCTL_SABGREQ_Msk = 0x10000
	// Bit SABGREQ.
	SDHC_PROCTL_SABGREQ = 0x10000
	// Transfer
	SDHC_PROCTL_SABGREQ_0 = 0x0
	// Stop
	SDHC_PROCTL_SABGREQ_1 = 0x1
	// Position of CREQ field.
	SDHC_PROCTL_CREQ_Pos = 0x11
	// Bit mask of CREQ field.
	SDHC_PROCTL_CREQ_Msk = 0x20000
	// Bit CREQ.
	SDHC_PROCTL_CREQ = 0x20000
	// No effect.
	SDHC_PROCTL_CREQ_0 = 0x0
	// Restart
	SDHC_PROCTL_CREQ_1 = 0x1
	// Position of RWCTL field.
	SDHC_PROCTL_RWCTL_Pos = 0x12
	// Bit mask of RWCTL field.
	SDHC_PROCTL_RWCTL_Msk = 0x40000
	// Bit RWCTL.
	SDHC_PROCTL_RWCTL = 0x40000
	// Disable read wait control, and stop SD clock at block gap when SABGREQ is set.
	SDHC_PROCTL_RWCTL_0 = 0x0
	// Enable read wait control, and assert read wait without stopping SD clock at block gap when SABGREQ bit is set.
	SDHC_PROCTL_RWCTL_1 = 0x1
	// Position of IABG field.
	SDHC_PROCTL_IABG_Pos = 0x13
	// Bit mask of IABG field.
	SDHC_PROCTL_IABG_Msk = 0x80000
	// Bit IABG.
	SDHC_PROCTL_IABG = 0x80000
	// Disabled
	SDHC_PROCTL_IABG_0 = 0x0
	// Enabled
	SDHC_PROCTL_IABG_1 = 0x1
	// Position of WECINT field.
	SDHC_PROCTL_WECINT_Pos = 0x18
	// Bit mask of WECINT field.
	SDHC_PROCTL_WECINT_Msk = 0x1000000
	// Bit WECINT.
	SDHC_PROCTL_WECINT = 0x1000000
	// Disabled
	SDHC_PROCTL_WECINT_0 = 0x0
	// Enabled
	SDHC_PROCTL_WECINT_1 = 0x1
	// Position of WECINS field.
	SDHC_PROCTL_WECINS_Pos = 0x19
	// Bit mask of WECINS field.
	SDHC_PROCTL_WECINS_Msk = 0x2000000
	// Bit WECINS.
	SDHC_PROCTL_WECINS = 0x2000000
	// Disabled
	SDHC_PROCTL_WECINS_0 = 0x0
	// Enabled
	SDHC_PROCTL_WECINS_1 = 0x1
	// Position of WECRM field.
	SDHC_PROCTL_WECRM_Pos = 0x1a
	// Bit mask of WECRM field.
	SDHC_PROCTL_WECRM_Msk = 0x4000000
	// Bit WECRM.
	SDHC_PROCTL_WECRM = 0x4000000
	// Disabled
	SDHC_PROCTL_WECRM_0 = 0x0
	// Enabled
	SDHC_PROCTL_WECRM_1 = 0x1

	// SYSCTL: System Control register
	// Position of IPGEN field.
	SDHC_SYSCTL_IPGEN_Pos = 0x0
	// Bit mask of IPGEN field.
	SDHC_SYSCTL_IPGEN_Msk = 0x1
	// Bit IPGEN.
	SDHC_SYSCTL_IPGEN = 0x1
	// Bus clock will be internally gated off.
	SDHC_SYSCTL_IPGEN_0 = 0x0
	// Bus clock will not be automatically gated off.
	SDHC_SYSCTL_IPGEN_1 = 0x1
	// Position of HCKEN field.
	SDHC_SYSCTL_HCKEN_Pos = 0x1
	// Bit mask of HCKEN field.
	SDHC_SYSCTL_HCKEN_Msk = 0x2
	// Bit HCKEN.
	SDHC_SYSCTL_HCKEN = 0x2
	// System clock will be internally gated off.
	SDHC_SYSCTL_HCKEN_0 = 0x0
	// System clock will not be automatically gated off.
	SDHC_SYSCTL_HCKEN_1 = 0x1
	// Position of PEREN field.
	SDHC_SYSCTL_PEREN_Pos = 0x2
	// Bit mask of PEREN field.
	SDHC_SYSCTL_PEREN_Msk = 0x4
	// Bit PEREN.
	SDHC_SYSCTL_PEREN = 0x4
	// SDHC clock will be internally gated off.
	SDHC_SYSCTL_PEREN_0 = 0x0
	// SDHC clock will not be automatically gated off.
	SDHC_SYSCTL_PEREN_1 = 0x1
	// Position of SDCLKEN field.
	SDHC_SYSCTL_SDCLKEN_Pos = 0x3
	// Bit mask of SDCLKEN field.
	SDHC_SYSCTL_SDCLKEN_Msk = 0x8
	// Bit SDCLKEN.
	SDHC_SYSCTL_SDCLKEN = 0x8
	// Position of DVS field.
	SDHC_SYSCTL_DVS_Pos = 0x4
	// Bit mask of DVS field.
	SDHC_SYSCTL_DVS_Msk = 0xf0
	// Divisor by 1.
	SDHC_SYSCTL_DVS_0 = 0x0
	// Divisor by 2.
	SDHC_SYSCTL_DVS_1 = 0x1
	// Divisor by 15.
	SDHC_SYSCTL_DVS_1110 = 0xe
	// Divisor by 16.
	SDHC_SYSCTL_DVS_1111 = 0xf
	// Position of SDCLKFS field.
	SDHC_SYSCTL_SDCLKFS_Pos = 0x8
	// Bit mask of SDCLKFS field.
	SDHC_SYSCTL_SDCLKFS_Msk = 0xff00
	// Base clock divided by 2.
	SDHC_SYSCTL_SDCLKFS_1 = 0x1
	// Base clock divided by 4.
	SDHC_SYSCTL_SDCLKFS_10 = 0x2
	// Base clock divided by 8.
	SDHC_SYSCTL_SDCLKFS_100 = 0x4
	// Base clock divided by 16.
	SDHC_SYSCTL_SDCLKFS_1000 = 0x8
	// Base clock divided by 32.
	SDHC_SYSCTL_SDCLKFS_10000 = 0x10
	// Base clock divided by 64.
	SDHC_SYSCTL_SDCLKFS_100000 = 0x20
	// Base clock divided by 128.
	SDHC_SYSCTL_SDCLKFS_1000000 = 0x40
	// Base clock divided by 256.
	SDHC_SYSCTL_SDCLKFS_10000000 = 0x80
	// Position of DTOCV field.
	SDHC_SYSCTL_DTOCV_Pos = 0x10
	// Bit mask of DTOCV field.
	SDHC_SYSCTL_DTOCV_Msk = 0xf0000
	// SDCLK x 2 13
	SDHC_SYSCTL_DTOCV_0000 = 0x0
	// SDCLK x 2 14
	SDHC_SYSCTL_DTOCV_0001 = 0x1
	// SDCLK x 2 27
	SDHC_SYSCTL_DTOCV_1110 = 0xe
	// Position of RSTA field.
	SDHC_SYSCTL_RSTA_Pos = 0x18
	// Bit mask of RSTA field.
	SDHC_SYSCTL_RSTA_Msk = 0x1000000
	// Bit RSTA.
	SDHC_SYSCTL_RSTA = 0x1000000
	// No reset.
	SDHC_SYSCTL_RSTA_0 = 0x0
	// Reset.
	SDHC_SYSCTL_RSTA_1 = 0x1
	// Position of RSTC field.
	SDHC_SYSCTL_RSTC_Pos = 0x19
	// Bit mask of RSTC field.
	SDHC_SYSCTL_RSTC_Msk = 0x2000000
	// Bit RSTC.
	SDHC_SYSCTL_RSTC = 0x2000000
	// No reset.
	SDHC_SYSCTL_RSTC_0 = 0x0
	// Reset.
	SDHC_SYSCTL_RSTC_1 = 0x1
	// Position of RSTD field.
	SDHC_SYSCTL_RSTD_Pos = 0x1a
	// Bit mask of RSTD field.
	SDHC_SYSCTL_RSTD_Msk = 0x4000000
	// Bit RSTD.
	SDHC_SYSCTL_RSTD = 0x4000000
	// No reset.
	SDHC_SYSCTL_RSTD_0 = 0x0
	// Reset.
	SDHC_SYSCTL_RSTD_1 = 0x1
	// Position of INITA field.
	SDHC_SYSCTL_INITA_Pos = 0x1b
	// Bit mask of INITA field.
	SDHC_SYSCTL_INITA_Msk = 0x8000000
	// Bit INITA.
	SDHC_SYSCTL_INITA = 0x8000000

	// IRQSTAT: Interrupt Status register
	// Position of CC field.
	SDHC_IRQSTAT_CC_Pos = 0x0
	// Bit mask of CC field.
	SDHC_IRQSTAT_CC_Msk = 0x1
	// Bit CC.
	SDHC_IRQSTAT_CC = 0x1
	// Command not complete.
	SDHC_IRQSTAT_CC_0 = 0x0
	// Command complete.
	SDHC_IRQSTAT_CC_1 = 0x1
	// Position of TC field.
	SDHC_IRQSTAT_TC_Pos = 0x1
	// Bit mask of TC field.
	SDHC_IRQSTAT_TC_Msk = 0x2
	// Bit TC.
	SDHC_IRQSTAT_TC = 0x2
	// Transfer not complete.
	SDHC_IRQSTAT_TC_0 = 0x0
	// Transfer complete.
	SDHC_IRQSTAT_TC_1 = 0x1
	// Position of BGE field.
	SDHC_IRQSTAT_BGE_Pos = 0x2
	// Bit mask of BGE field.
	SDHC_IRQSTAT_BGE_Msk = 0x4
	// Bit BGE.
	SDHC_IRQSTAT_BGE = 0x4
	// No block gap event.
	SDHC_IRQSTAT_BGE_0 = 0x0
	// Transaction stopped at block gap.
	SDHC_IRQSTAT_BGE_1 = 0x1
	// Position of DINT field.
	SDHC_IRQSTAT_DINT_Pos = 0x3
	// Bit mask of DINT field.
	SDHC_IRQSTAT_DINT_Msk = 0x8
	// Bit DINT.
	SDHC_IRQSTAT_DINT = 0x8
	// No DMA Interrupt.
	SDHC_IRQSTAT_DINT_0 = 0x0
	// DMA Interrupt is generated.
	SDHC_IRQSTAT_DINT_1 = 0x1
	// Position of BWR field.
	SDHC_IRQSTAT_BWR_Pos = 0x4
	// Bit mask of BWR field.
	SDHC_IRQSTAT_BWR_Msk = 0x10
	// Bit BWR.
	SDHC_IRQSTAT_BWR = 0x10
	// Not ready to write buffer.
	SDHC_IRQSTAT_BWR_0 = 0x0
	// Ready to write buffer.
	SDHC_IRQSTAT_BWR_1 = 0x1
	// Position of BRR field.
	SDHC_IRQSTAT_BRR_Pos = 0x5
	// Bit mask of BRR field.
	SDHC_IRQSTAT_BRR_Msk = 0x20
	// Bit BRR.
	SDHC_IRQSTAT_BRR = 0x20
	// Not ready to read buffer.
	SDHC_IRQSTAT_BRR_0 = 0x0
	// Ready to read buffer.
	SDHC_IRQSTAT_BRR_1 = 0x1
	// Position of CINS field.
	SDHC_IRQSTAT_CINS_Pos = 0x6
	// Bit mask of CINS field.
	SDHC_IRQSTAT_CINS_Msk = 0x40
	// Bit CINS.
	SDHC_IRQSTAT_CINS = 0x40
	// Card state unstable or removed.
	SDHC_IRQSTAT_CINS_0 = 0x0
	// Card inserted.
	SDHC_IRQSTAT_CINS_1 = 0x1
	// Position of CRM field.
	SDHC_IRQSTAT_CRM_Pos = 0x7
	// Bit mask of CRM field.
	SDHC_IRQSTAT_CRM_Msk = 0x80
	// Bit CRM.
	SDHC_IRQSTAT_CRM = 0x80
	// Card state unstable or inserted.
	SDHC_IRQSTAT_CRM_0 = 0x0
	// Card removed.
	SDHC_IRQSTAT_CRM_1 = 0x1
	// Position of CINT field.
	SDHC_IRQSTAT_CINT_Pos = 0x8
	// Bit mask of CINT field.
	SDHC_IRQSTAT_CINT_Msk = 0x100
	// Bit CINT.
	SDHC_IRQSTAT_CINT = 0x100
	// No Card Interrupt.
	SDHC_IRQSTAT_CINT_0 = 0x0
	// Generate Card Interrupt.
	SDHC_IRQSTAT_CINT_1 = 0x1
	// Position of CTOE field.
	SDHC_IRQSTAT_CTOE_Pos = 0x10
	// Bit mask of CTOE field.
	SDHC_IRQSTAT_CTOE_Msk = 0x10000
	// Bit CTOE.
	SDHC_IRQSTAT_CTOE = 0x10000
	// No error.
	SDHC_IRQSTAT_CTOE_0 = 0x0
	// Time out.
	SDHC_IRQSTAT_CTOE_1 = 0x1
	// Position of CCE field.
	SDHC_IRQSTAT_CCE_Pos = 0x11
	// Bit mask of CCE field.
	SDHC_IRQSTAT_CCE_Msk = 0x20000
	// Bit CCE.
	SDHC_IRQSTAT_CCE = 0x20000
	// No error.
	SDHC_IRQSTAT_CCE_0 = 0x0
	// CRC Error generated.
	SDHC_IRQSTAT_CCE_1 = 0x1
	// Position of CEBE field.
	SDHC_IRQSTAT_CEBE_Pos = 0x12
	// Bit mask of CEBE field.
	SDHC_IRQSTAT_CEBE_Msk = 0x40000
	// Bit CEBE.
	SDHC_IRQSTAT_CEBE = 0x40000
	// No error.
	SDHC_IRQSTAT_CEBE_0 = 0x0
	// End Bit Error generated.
	SDHC_IRQSTAT_CEBE_1 = 0x1
	// Position of CIE field.
	SDHC_IRQSTAT_CIE_Pos = 0x13
	// Bit mask of CIE field.
	SDHC_IRQSTAT_CIE_Msk = 0x80000
	// Bit CIE.
	SDHC_IRQSTAT_CIE = 0x80000
	// No error.
	SDHC_IRQSTAT_CIE_0 = 0x0
	// Error.
	SDHC_IRQSTAT_CIE_1 = 0x1
	// Position of DTOE field.
	SDHC_IRQSTAT_DTOE_Pos = 0x14
	// Bit mask of DTOE field.
	SDHC_IRQSTAT_DTOE_Msk = 0x100000
	// Bit DTOE.
	SDHC_IRQSTAT_DTOE = 0x100000
	// No error.
	SDHC_IRQSTAT_DTOE_0 = 0x0
	// Time out.
	SDHC_IRQSTAT_DTOE_1 = 0x1
	// Position of DCE field.
	SDHC_IRQSTAT_DCE_Pos = 0x15
	// Bit mask of DCE field.
	SDHC_IRQSTAT_DCE_Msk = 0x200000
	// Bit DCE.
	SDHC_IRQSTAT_DCE = 0x200000
	// No error.
	SDHC_IRQSTAT_DCE_0 = 0x0
	// Error.
	SDHC_IRQSTAT_DCE_1 = 0x1
	// Position of DEBE field.
	SDHC_IRQSTAT_DEBE_Pos = 0x16
	// Bit mask of DEBE field.
	SDHC_IRQSTAT_DEBE_Msk = 0x400000
	// Bit DEBE.
	SDHC_IRQSTAT_DEBE = 0x400000
	// No error.
	SDHC_IRQSTAT_DEBE_0 = 0x0
	// Error.
	SDHC_IRQSTAT_DEBE_1 = 0x1
	// Position of AC12E field.
	SDHC_IRQSTAT_AC12E_Pos = 0x18
	// Bit mask of AC12E field.
	SDHC_IRQSTAT_AC12E_Msk = 0x1000000
	// Bit AC12E.
	SDHC_IRQSTAT_AC12E = 0x1000000
	// No error.
	SDHC_IRQSTAT_AC12E_0 = 0x0
	// Error.
	SDHC_IRQSTAT_AC12E_1 = 0x1
	// Position of DMAE field.
	SDHC_IRQSTAT_DMAE_Pos = 0x1c
	// Bit mask of DMAE field.
	SDHC_IRQSTAT_DMAE_Msk = 0x10000000
	// Bit DMAE.
	SDHC_IRQSTAT_DMAE = 0x10000000
	// No error.
	SDHC_IRQSTAT_DMAE_0 = 0x0
	// Error.
	SDHC_IRQSTAT_DMAE_1 = 0x1

	// IRQSTATEN: Interrupt Status Enable register
	// Position of CCSEN field.
	SDHC_IRQSTATEN_CCSEN_Pos = 0x0
	// Bit mask of CCSEN field.
	SDHC_IRQSTATEN_CCSEN_Msk = 0x1
	// Bit CCSEN.
	SDHC_IRQSTATEN_CCSEN = 0x1
	// Masked
	SDHC_IRQSTATEN_CCSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CCSEN_1 = 0x1
	// Position of TCSEN field.
	SDHC_IRQSTATEN_TCSEN_Pos = 0x1
	// Bit mask of TCSEN field.
	SDHC_IRQSTATEN_TCSEN_Msk = 0x2
	// Bit TCSEN.
	SDHC_IRQSTATEN_TCSEN = 0x2
	// Masked
	SDHC_IRQSTATEN_TCSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_TCSEN_1 = 0x1
	// Position of BGESEN field.
	SDHC_IRQSTATEN_BGESEN_Pos = 0x2
	// Bit mask of BGESEN field.
	SDHC_IRQSTATEN_BGESEN_Msk = 0x4
	// Bit BGESEN.
	SDHC_IRQSTATEN_BGESEN = 0x4
	// Masked
	SDHC_IRQSTATEN_BGESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_BGESEN_1 = 0x1
	// Position of DINTSEN field.
	SDHC_IRQSTATEN_DINTSEN_Pos = 0x3
	// Bit mask of DINTSEN field.
	SDHC_IRQSTATEN_DINTSEN_Msk = 0x8
	// Bit DINTSEN.
	SDHC_IRQSTATEN_DINTSEN = 0x8
	// Masked
	SDHC_IRQSTATEN_DINTSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DINTSEN_1 = 0x1
	// Position of BWRSEN field.
	SDHC_IRQSTATEN_BWRSEN_Pos = 0x4
	// Bit mask of BWRSEN field.
	SDHC_IRQSTATEN_BWRSEN_Msk = 0x10
	// Bit BWRSEN.
	SDHC_IRQSTATEN_BWRSEN = 0x10
	// Masked
	SDHC_IRQSTATEN_BWRSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_BWRSEN_1 = 0x1
	// Position of BRRSEN field.
	SDHC_IRQSTATEN_BRRSEN_Pos = 0x5
	// Bit mask of BRRSEN field.
	SDHC_IRQSTATEN_BRRSEN_Msk = 0x20
	// Bit BRRSEN.
	SDHC_IRQSTATEN_BRRSEN = 0x20
	// Masked
	SDHC_IRQSTATEN_BRRSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_BRRSEN_1 = 0x1
	// Position of CINSEN field.
	SDHC_IRQSTATEN_CINSEN_Pos = 0x6
	// Bit mask of CINSEN field.
	SDHC_IRQSTATEN_CINSEN_Msk = 0x40
	// Bit CINSEN.
	SDHC_IRQSTATEN_CINSEN = 0x40
	// Masked
	SDHC_IRQSTATEN_CINSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CINSEN_1 = 0x1
	// Position of CRMSEN field.
	SDHC_IRQSTATEN_CRMSEN_Pos = 0x7
	// Bit mask of CRMSEN field.
	SDHC_IRQSTATEN_CRMSEN_Msk = 0x80
	// Bit CRMSEN.
	SDHC_IRQSTATEN_CRMSEN = 0x80
	// Masked
	SDHC_IRQSTATEN_CRMSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CRMSEN_1 = 0x1
	// Position of CINTSEN field.
	SDHC_IRQSTATEN_CINTSEN_Pos = 0x8
	// Bit mask of CINTSEN field.
	SDHC_IRQSTATEN_CINTSEN_Msk = 0x100
	// Bit CINTSEN.
	SDHC_IRQSTATEN_CINTSEN = 0x100
	// Masked
	SDHC_IRQSTATEN_CINTSEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CINTSEN_1 = 0x1
	// Position of CTOESEN field.
	SDHC_IRQSTATEN_CTOESEN_Pos = 0x10
	// Bit mask of CTOESEN field.
	SDHC_IRQSTATEN_CTOESEN_Msk = 0x10000
	// Bit CTOESEN.
	SDHC_IRQSTATEN_CTOESEN = 0x10000
	// Masked
	SDHC_IRQSTATEN_CTOESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CTOESEN_1 = 0x1
	// Position of CCESEN field.
	SDHC_IRQSTATEN_CCESEN_Pos = 0x11
	// Bit mask of CCESEN field.
	SDHC_IRQSTATEN_CCESEN_Msk = 0x20000
	// Bit CCESEN.
	SDHC_IRQSTATEN_CCESEN = 0x20000
	// Masked
	SDHC_IRQSTATEN_CCESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CCESEN_1 = 0x1
	// Position of CEBESEN field.
	SDHC_IRQSTATEN_CEBESEN_Pos = 0x12
	// Bit mask of CEBESEN field.
	SDHC_IRQSTATEN_CEBESEN_Msk = 0x40000
	// Bit CEBESEN.
	SDHC_IRQSTATEN_CEBESEN = 0x40000
	// Masked
	SDHC_IRQSTATEN_CEBESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CEBESEN_1 = 0x1
	// Position of CIESEN field.
	SDHC_IRQSTATEN_CIESEN_Pos = 0x13
	// Bit mask of CIESEN field.
	SDHC_IRQSTATEN_CIESEN_Msk = 0x80000
	// Bit CIESEN.
	SDHC_IRQSTATEN_CIESEN = 0x80000
	// Masked
	SDHC_IRQSTATEN_CIESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_CIESEN_1 = 0x1
	// Position of DTOESEN field.
	SDHC_IRQSTATEN_DTOESEN_Pos = 0x14
	// Bit mask of DTOESEN field.
	SDHC_IRQSTATEN_DTOESEN_Msk = 0x100000
	// Bit DTOESEN.
	SDHC_IRQSTATEN_DTOESEN = 0x100000
	// Masked
	SDHC_IRQSTATEN_DTOESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DTOESEN_1 = 0x1
	// Position of DCESEN field.
	SDHC_IRQSTATEN_DCESEN_Pos = 0x15
	// Bit mask of DCESEN field.
	SDHC_IRQSTATEN_DCESEN_Msk = 0x200000
	// Bit DCESEN.
	SDHC_IRQSTATEN_DCESEN = 0x200000
	// Masked
	SDHC_IRQSTATEN_DCESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DCESEN_1 = 0x1
	// Position of DEBESEN field.
	SDHC_IRQSTATEN_DEBESEN_Pos = 0x16
	// Bit mask of DEBESEN field.
	SDHC_IRQSTATEN_DEBESEN_Msk = 0x400000
	// Bit DEBESEN.
	SDHC_IRQSTATEN_DEBESEN = 0x400000
	// Masked
	SDHC_IRQSTATEN_DEBESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DEBESEN_1 = 0x1
	// Position of AC12ESEN field.
	SDHC_IRQSTATEN_AC12ESEN_Pos = 0x18
	// Bit mask of AC12ESEN field.
	SDHC_IRQSTATEN_AC12ESEN_Msk = 0x1000000
	// Bit AC12ESEN.
	SDHC_IRQSTATEN_AC12ESEN = 0x1000000
	// Masked
	SDHC_IRQSTATEN_AC12ESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_AC12ESEN_1 = 0x1
	// Position of DMAESEN field.
	SDHC_IRQSTATEN_DMAESEN_Pos = 0x1c
	// Bit mask of DMAESEN field.
	SDHC_IRQSTATEN_DMAESEN_Msk = 0x10000000
	// Bit DMAESEN.
	SDHC_IRQSTATEN_DMAESEN = 0x10000000
	// Masked
	SDHC_IRQSTATEN_DMAESEN_0 = 0x0
	// Enabled
	SDHC_IRQSTATEN_DMAESEN_1 = 0x1

	// IRQSIGEN: Interrupt Signal Enable register
	// Position of CCIEN field.
	SDHC_IRQSIGEN_CCIEN_Pos = 0x0
	// Bit mask of CCIEN field.
	SDHC_IRQSIGEN_CCIEN_Msk = 0x1
	// Bit CCIEN.
	SDHC_IRQSIGEN_CCIEN = 0x1
	// Masked
	SDHC_IRQSIGEN_CCIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CCIEN_1 = 0x1
	// Position of TCIEN field.
	SDHC_IRQSIGEN_TCIEN_Pos = 0x1
	// Bit mask of TCIEN field.
	SDHC_IRQSIGEN_TCIEN_Msk = 0x2
	// Bit TCIEN.
	SDHC_IRQSIGEN_TCIEN = 0x2
	// Masked
	SDHC_IRQSIGEN_TCIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_TCIEN_1 = 0x1
	// Position of BGEIEN field.
	SDHC_IRQSIGEN_BGEIEN_Pos = 0x2
	// Bit mask of BGEIEN field.
	SDHC_IRQSIGEN_BGEIEN_Msk = 0x4
	// Bit BGEIEN.
	SDHC_IRQSIGEN_BGEIEN = 0x4
	// Masked
	SDHC_IRQSIGEN_BGEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_BGEIEN_1 = 0x1
	// Position of DINTIEN field.
	SDHC_IRQSIGEN_DINTIEN_Pos = 0x3
	// Bit mask of DINTIEN field.
	SDHC_IRQSIGEN_DINTIEN_Msk = 0x8
	// Bit DINTIEN.
	SDHC_IRQSIGEN_DINTIEN = 0x8
	// Masked
	SDHC_IRQSIGEN_DINTIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DINTIEN_1 = 0x1
	// Position of BWRIEN field.
	SDHC_IRQSIGEN_BWRIEN_Pos = 0x4
	// Bit mask of BWRIEN field.
	SDHC_IRQSIGEN_BWRIEN_Msk = 0x10
	// Bit BWRIEN.
	SDHC_IRQSIGEN_BWRIEN = 0x10
	// Masked
	SDHC_IRQSIGEN_BWRIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_BWRIEN_1 = 0x1
	// Position of BRRIEN field.
	SDHC_IRQSIGEN_BRRIEN_Pos = 0x5
	// Bit mask of BRRIEN field.
	SDHC_IRQSIGEN_BRRIEN_Msk = 0x20
	// Bit BRRIEN.
	SDHC_IRQSIGEN_BRRIEN = 0x20
	// Masked
	SDHC_IRQSIGEN_BRRIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_BRRIEN_1 = 0x1
	// Position of CINSIEN field.
	SDHC_IRQSIGEN_CINSIEN_Pos = 0x6
	// Bit mask of CINSIEN field.
	SDHC_IRQSIGEN_CINSIEN_Msk = 0x40
	// Bit CINSIEN.
	SDHC_IRQSIGEN_CINSIEN = 0x40
	// Masked
	SDHC_IRQSIGEN_CINSIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CINSIEN_1 = 0x1
	// Position of CRMIEN field.
	SDHC_IRQSIGEN_CRMIEN_Pos = 0x7
	// Bit mask of CRMIEN field.
	SDHC_IRQSIGEN_CRMIEN_Msk = 0x80
	// Bit CRMIEN.
	SDHC_IRQSIGEN_CRMIEN = 0x80
	// Masked
	SDHC_IRQSIGEN_CRMIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CRMIEN_1 = 0x1
	// Position of CINTIEN field.
	SDHC_IRQSIGEN_CINTIEN_Pos = 0x8
	// Bit mask of CINTIEN field.
	SDHC_IRQSIGEN_CINTIEN_Msk = 0x100
	// Bit CINTIEN.
	SDHC_IRQSIGEN_CINTIEN = 0x100
	// Masked
	SDHC_IRQSIGEN_CINTIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CINTIEN_1 = 0x1
	// Position of CTOEIEN field.
	SDHC_IRQSIGEN_CTOEIEN_Pos = 0x10
	// Bit mask of CTOEIEN field.
	SDHC_IRQSIGEN_CTOEIEN_Msk = 0x10000
	// Bit CTOEIEN.
	SDHC_IRQSIGEN_CTOEIEN = 0x10000
	// Masked
	SDHC_IRQSIGEN_CTOEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CTOEIEN_1 = 0x1
	// Position of CCEIEN field.
	SDHC_IRQSIGEN_CCEIEN_Pos = 0x11
	// Bit mask of CCEIEN field.
	SDHC_IRQSIGEN_CCEIEN_Msk = 0x20000
	// Bit CCEIEN.
	SDHC_IRQSIGEN_CCEIEN = 0x20000
	// Masked
	SDHC_IRQSIGEN_CCEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CCEIEN_1 = 0x1
	// Position of CEBEIEN field.
	SDHC_IRQSIGEN_CEBEIEN_Pos = 0x12
	// Bit mask of CEBEIEN field.
	SDHC_IRQSIGEN_CEBEIEN_Msk = 0x40000
	// Bit CEBEIEN.
	SDHC_IRQSIGEN_CEBEIEN = 0x40000
	// Masked
	SDHC_IRQSIGEN_CEBEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CEBEIEN_1 = 0x1
	// Position of CIEIEN field.
	SDHC_IRQSIGEN_CIEIEN_Pos = 0x13
	// Bit mask of CIEIEN field.
	SDHC_IRQSIGEN_CIEIEN_Msk = 0x80000
	// Bit CIEIEN.
	SDHC_IRQSIGEN_CIEIEN = 0x80000
	// Masked
	SDHC_IRQSIGEN_CIEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_CIEIEN_1 = 0x1
	// Position of DTOEIEN field.
	SDHC_IRQSIGEN_DTOEIEN_Pos = 0x14
	// Bit mask of DTOEIEN field.
	SDHC_IRQSIGEN_DTOEIEN_Msk = 0x100000
	// Bit DTOEIEN.
	SDHC_IRQSIGEN_DTOEIEN = 0x100000
	// Masked
	SDHC_IRQSIGEN_DTOEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DTOEIEN_1 = 0x1
	// Position of DCEIEN field.
	SDHC_IRQSIGEN_DCEIEN_Pos = 0x15
	// Bit mask of DCEIEN field.
	SDHC_IRQSIGEN_DCEIEN_Msk = 0x200000
	// Bit DCEIEN.
	SDHC_IRQSIGEN_DCEIEN = 0x200000
	// Masked
	SDHC_IRQSIGEN_DCEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DCEIEN_1 = 0x1
	// Position of DEBEIEN field.
	SDHC_IRQSIGEN_DEBEIEN_Pos = 0x16
	// Bit mask of DEBEIEN field.
	SDHC_IRQSIGEN_DEBEIEN_Msk = 0x400000
	// Bit DEBEIEN.
	SDHC_IRQSIGEN_DEBEIEN = 0x400000
	// Masked
	SDHC_IRQSIGEN_DEBEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DEBEIEN_1 = 0x1
	// Position of AC12EIEN field.
	SDHC_IRQSIGEN_AC12EIEN_Pos = 0x18
	// Bit mask of AC12EIEN field.
	SDHC_IRQSIGEN_AC12EIEN_Msk = 0x1000000
	// Bit AC12EIEN.
	SDHC_IRQSIGEN_AC12EIEN = 0x1000000
	// Masked
	SDHC_IRQSIGEN_AC12EIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_AC12EIEN_1 = 0x1
	// Position of DMAEIEN field.
	SDHC_IRQSIGEN_DMAEIEN_Pos = 0x1c
	// Bit mask of DMAEIEN field.
	SDHC_IRQSIGEN_DMAEIEN_Msk = 0x10000000
	// Bit DMAEIEN.
	SDHC_IRQSIGEN_DMAEIEN = 0x10000000
	// Masked
	SDHC_IRQSIGEN_DMAEIEN_0 = 0x0
	// Enabled
	SDHC_IRQSIGEN_DMAEIEN_1 = 0x1

	// AC12ERR: Auto CMD12 Error Status Register
	// Position of AC12NE field.
	SDHC_AC12ERR_AC12NE_Pos = 0x0
	// Bit mask of AC12NE field.
	SDHC_AC12ERR_AC12NE_Msk = 0x1
	// Bit AC12NE.
	SDHC_AC12ERR_AC12NE = 0x1
	// Executed.
	SDHC_AC12ERR_AC12NE_0 = 0x0
	// Not executed.
	SDHC_AC12ERR_AC12NE_1 = 0x1
	// Position of AC12TOE field.
	SDHC_AC12ERR_AC12TOE_Pos = 0x1
	// Bit mask of AC12TOE field.
	SDHC_AC12ERR_AC12TOE_Msk = 0x2
	// Bit AC12TOE.
	SDHC_AC12ERR_AC12TOE = 0x2
	// No error.
	SDHC_AC12ERR_AC12TOE_0 = 0x0
	// Time out.
	SDHC_AC12ERR_AC12TOE_1 = 0x1
	// Position of AC12EBE field.
	SDHC_AC12ERR_AC12EBE_Pos = 0x2
	// Bit mask of AC12EBE field.
	SDHC_AC12ERR_AC12EBE_Msk = 0x4
	// Bit AC12EBE.
	SDHC_AC12ERR_AC12EBE = 0x4
	// No error.
	SDHC_AC12ERR_AC12EBE_0 = 0x0
	// End bit error generated.
	SDHC_AC12ERR_AC12EBE_1 = 0x1
	// Position of AC12CE field.
	SDHC_AC12ERR_AC12CE_Pos = 0x3
	// Bit mask of AC12CE field.
	SDHC_AC12ERR_AC12CE_Msk = 0x8
	// Bit AC12CE.
	SDHC_AC12ERR_AC12CE = 0x8
	// No CRC error.
	SDHC_AC12ERR_AC12CE_0 = 0x0
	// CRC error met in Auto CMD12 response.
	SDHC_AC12ERR_AC12CE_1 = 0x1
	// Position of AC12IE field.
	SDHC_AC12ERR_AC12IE_Pos = 0x4
	// Bit mask of AC12IE field.
	SDHC_AC12ERR_AC12IE_Msk = 0x10
	// Bit AC12IE.
	SDHC_AC12ERR_AC12IE = 0x10
	// No error.
	SDHC_AC12ERR_AC12IE_0 = 0x0
	// Error, the CMD index in response is not CMD12.
	SDHC_AC12ERR_AC12IE_1 = 0x1
	// Position of CNIBAC12E field.
	SDHC_AC12ERR_CNIBAC12E_Pos = 0x7
	// Bit mask of CNIBAC12E field.
	SDHC_AC12ERR_CNIBAC12E_Msk = 0x80
	// Bit CNIBAC12E.
	SDHC_AC12ERR_CNIBAC12E = 0x80
	// No error.
	SDHC_AC12ERR_CNIBAC12E_0 = 0x0
	// Not issued.
	SDHC_AC12ERR_CNIBAC12E_1 = 0x1

	// HTCAPBLT: Host Controller Capabilities
	// Position of MBL field.
	SDHC_HTCAPBLT_MBL_Pos = 0x10
	// Bit mask of MBL field.
	SDHC_HTCAPBLT_MBL_Msk = 0x70000
	// 512 bytes
	SDHC_HTCAPBLT_MBL_000 = 0x0
	// 1024 bytes
	SDHC_HTCAPBLT_MBL_001 = 0x1
	// 2048 bytes
	SDHC_HTCAPBLT_MBL_010 = 0x2
	// 4096 bytes
	SDHC_HTCAPBLT_MBL_011 = 0x3
	// Position of ADMAS field.
	SDHC_HTCAPBLT_ADMAS_Pos = 0x14
	// Bit mask of ADMAS field.
	SDHC_HTCAPBLT_ADMAS_Msk = 0x100000
	// Bit ADMAS.
	SDHC_HTCAPBLT_ADMAS = 0x100000
	// Advanced DMA not supported.
	SDHC_HTCAPBLT_ADMAS_0 = 0x0
	// Advanced DMA supported.
	SDHC_HTCAPBLT_ADMAS_1 = 0x1
	// Position of HSS field.
	SDHC_HTCAPBLT_HSS_Pos = 0x15
	// Bit mask of HSS field.
	SDHC_HTCAPBLT_HSS_Msk = 0x200000
	// Bit HSS.
	SDHC_HTCAPBLT_HSS = 0x200000
	// High speed not supported.
	SDHC_HTCAPBLT_HSS_0 = 0x0
	// High speed supported.
	SDHC_HTCAPBLT_HSS_1 = 0x1
	// Position of DMAS field.
	SDHC_HTCAPBLT_DMAS_Pos = 0x16
	// Bit mask of DMAS field.
	SDHC_HTCAPBLT_DMAS_Msk = 0x400000
	// Bit DMAS.
	SDHC_HTCAPBLT_DMAS = 0x400000
	// DMA not supported.
	SDHC_HTCAPBLT_DMAS_0 = 0x0
	// DMA supported.
	SDHC_HTCAPBLT_DMAS_1 = 0x1
	// Position of SRS field.
	SDHC_HTCAPBLT_SRS_Pos = 0x17
	// Bit mask of SRS field.
	SDHC_HTCAPBLT_SRS_Msk = 0x800000
	// Bit SRS.
	SDHC_HTCAPBLT_SRS = 0x800000
	// Not supported.
	SDHC_HTCAPBLT_SRS_0 = 0x0
	// Supported.
	SDHC_HTCAPBLT_SRS_1 = 0x1
	// Position of VS33 field.
	SDHC_HTCAPBLT_VS33_Pos = 0x18
	// Bit mask of VS33 field.
	SDHC_HTCAPBLT_VS33_Msk = 0x1000000
	// Bit VS33.
	SDHC_HTCAPBLT_VS33 = 0x1000000
	// 3.3 V not supported.
	SDHC_HTCAPBLT_VS33_0 = 0x0
	// 3.3 V supported.
	SDHC_HTCAPBLT_VS33_1 = 0x1

	// WML: Watermark Level Register
	// Position of RDWML field.
	SDHC_WML_RDWML_Pos = 0x0
	// Bit mask of RDWML field.
	SDHC_WML_RDWML_Msk = 0xff
	// Position of WRWML field.
	SDHC_WML_WRWML_Pos = 0x10
	// Bit mask of WRWML field.
	SDHC_WML_WRWML_Msk = 0xff0000

	// FEVT: Force Event register
	// Position of AC12NE field.
	SDHC_FEVT_AC12NE_Pos = 0x0
	// Bit mask of AC12NE field.
	SDHC_FEVT_AC12NE_Msk = 0x1
	// Bit AC12NE.
	SDHC_FEVT_AC12NE = 0x1
	// Position of AC12TOE field.
	SDHC_FEVT_AC12TOE_Pos = 0x1
	// Bit mask of AC12TOE field.
	SDHC_FEVT_AC12TOE_Msk = 0x2
	// Bit AC12TOE.
	SDHC_FEVT_AC12TOE = 0x2
	// Position of AC12CE field.
	SDHC_FEVT_AC12CE_Pos = 0x2
	// Bit mask of AC12CE field.
	SDHC_FEVT_AC12CE_Msk = 0x4
	// Bit AC12CE.
	SDHC_FEVT_AC12CE = 0x4
	// Position of AC12EBE field.
	SDHC_FEVT_AC12EBE_Pos = 0x3
	// Bit mask of AC12EBE field.
	SDHC_FEVT_AC12EBE_Msk = 0x8
	// Bit AC12EBE.
	SDHC_FEVT_AC12EBE = 0x8
	// Position of AC12IE field.
	SDHC_FEVT_AC12IE_Pos = 0x4
	// Bit mask of AC12IE field.
	SDHC_FEVT_AC12IE_Msk = 0x10
	// Bit AC12IE.
	SDHC_FEVT_AC12IE = 0x10
	// Position of CNIBAC12E field.
	SDHC_FEVT_CNIBAC12E_Pos = 0x7
	// Bit mask of CNIBAC12E field.
	SDHC_FEVT_CNIBAC12E_Msk = 0x80
	// Bit CNIBAC12E.
	SDHC_FEVT_CNIBAC12E = 0x80
	// Position of CTOE field.
	SDHC_FEVT_CTOE_Pos = 0x10
	// Bit mask of CTOE field.
	SDHC_FEVT_CTOE_Msk = 0x10000
	// Bit CTOE.
	SDHC_FEVT_CTOE = 0x10000
	// Position of CCE field.
	SDHC_FEVT_CCE_Pos = 0x11
	// Bit mask of CCE field.
	SDHC_FEVT_CCE_Msk = 0x20000
	// Bit CCE.
	SDHC_FEVT_CCE = 0x20000
	// Position of CEBE field.
	SDHC_FEVT_CEBE_Pos = 0x12
	// Bit mask of CEBE field.
	SDHC_FEVT_CEBE_Msk = 0x40000
	// Bit CEBE.
	SDHC_FEVT_CEBE = 0x40000
	// Position of CIE field.
	SDHC_FEVT_CIE_Pos = 0x13
	// Bit mask of CIE field.
	SDHC_FEVT_CIE_Msk = 0x80000
	// Bit CIE.
	SDHC_FEVT_CIE = 0x80000
	// Position of DTOE field.
	SDHC_FEVT_DTOE_Pos = 0x14
	// Bit mask of DTOE field.
	SDHC_FEVT_DTOE_Msk = 0x100000
	// Bit DTOE.
	SDHC_FEVT_DTOE = 0x100000
	// Position of DCE field.
	SDHC_FEVT_DCE_Pos = 0x15
	// Bit mask of DCE field.
	SDHC_FEVT_DCE_Msk = 0x200000
	// Bit DCE.
	SDHC_FEVT_DCE = 0x200000
	// Position of DEBE field.
	SDHC_FEVT_DEBE_Pos = 0x16
	// Bit mask of DEBE field.
	SDHC_FEVT_DEBE_Msk = 0x400000
	// Bit DEBE.
	SDHC_FEVT_DEBE = 0x400000
	// Position of AC12E field.
	SDHC_FEVT_AC12E_Pos = 0x18
	// Bit mask of AC12E field.
	SDHC_FEVT_AC12E_Msk = 0x1000000
	// Bit AC12E.
	SDHC_FEVT_AC12E = 0x1000000
	// Position of DMAE field.
	SDHC_FEVT_DMAE_Pos = 0x1c
	// Bit mask of DMAE field.
	SDHC_FEVT_DMAE_Msk = 0x10000000
	// Bit DMAE.
	SDHC_FEVT_DMAE = 0x10000000
	// Position of CINT field.
	SDHC_FEVT_CINT_Pos = 0x1f
	// Bit mask of CINT field.
	SDHC_FEVT_CINT_Msk = 0x80000000
	// Bit CINT.
	SDHC_FEVT_CINT = 0x80000000

	// ADMAES: ADMA Error Status register
	// Position of ADMAES field.
	SDHC_ADMAES_ADMAES_Pos = 0x0
	// Bit mask of ADMAES field.
	SDHC_ADMAES_ADMAES_Msk = 0x3
	// Position of ADMALME field.
	SDHC_ADMAES_ADMALME_Pos = 0x2
	// Bit mask of ADMALME field.
	SDHC_ADMAES_ADMALME_Msk = 0x4
	// Bit ADMALME.
	SDHC_ADMAES_ADMALME = 0x4
	// No error.
	SDHC_ADMAES_ADMALME_0 = 0x0
	// Error.
	SDHC_ADMAES_ADMALME_1 = 0x1
	// Position of ADMADCE field.
	SDHC_ADMAES_ADMADCE_Pos = 0x3
	// Bit mask of ADMADCE field.
	SDHC_ADMAES_ADMADCE_Msk = 0x8
	// Bit ADMADCE.
	SDHC_ADMAES_ADMADCE = 0x8
	// No error.
	SDHC_ADMAES_ADMADCE_0 = 0x0
	// Error.
	SDHC_ADMAES_ADMADCE_1 = 0x1

	// ADSADDR: ADMA System Addressregister
	// Position of ADSADDR field.
	SDHC_ADSADDR_ADSADDR_Pos = 0x2
	// Bit mask of ADSADDR field.
	SDHC_ADSADDR_ADSADDR_Msk = 0xfffffffc

	// VENDOR: Vendor Specific register
	// Position of EXBLKNU field.
	SDHC_VENDOR_EXBLKNU_Pos = 0x1
	// Bit mask of EXBLKNU field.
	SDHC_VENDOR_EXBLKNU_Msk = 0x2
	// Bit EXBLKNU.
	SDHC_VENDOR_EXBLKNU = 0x2
	// None exact block read.
	SDHC_VENDOR_EXBLKNU_0 = 0x0
	// Exact block read for SDIO CMD53.
	SDHC_VENDOR_EXBLKNU_1 = 0x1
	// Position of INTSTVAL field.
	SDHC_VENDOR_INTSTVAL_Pos = 0x10
	// Bit mask of INTSTVAL field.
	SDHC_VENDOR_INTSTVAL_Msk = 0xff0000

	// MMCBOOT: MMC Boot register
	// Position of DTOCVACK field.
	SDHC_MMCBOOT_DTOCVACK_Pos = 0x0
	// Bit mask of DTOCVACK field.
	SDHC_MMCBOOT_DTOCVACK_Msk = 0xf
	// SDCLK x 2^8
	SDHC_MMCBOOT_DTOCVACK_0000 = 0x0
	// SDCLK x 2^9
	SDHC_MMCBOOT_DTOCVACK_0001 = 0x1
	// SDCLK x 2^10
	SDHC_MMCBOOT_DTOCVACK_0010 = 0x2
	// SDCLK x 2^11
	SDHC_MMCBOOT_DTOCVACK_0011 = 0x3
	// SDCLK x 2^12
	SDHC_MMCBOOT_DTOCVACK_0100 = 0x4
	// SDCLK x 2^13
	SDHC_MMCBOOT_DTOCVACK_0101 = 0x5
	// SDCLK x 2^14
	SDHC_MMCBOOT_DTOCVACK_0110 = 0x6
	// SDCLK x 2^15
	SDHC_MMCBOOT_DTOCVACK_0111 = 0x7
	// SDCLK x 2^22
	SDHC_MMCBOOT_DTOCVACK_1110 = 0xe
	// Position of BOOTACK field.
	SDHC_MMCBOOT_BOOTACK_Pos = 0x4
	// Bit mask of BOOTACK field.
	SDHC_MMCBOOT_BOOTACK_Msk = 0x10
	// Bit BOOTACK.
	SDHC_MMCBOOT_BOOTACK = 0x10
	// No ack.
	SDHC_MMCBOOT_BOOTACK_0 = 0x0
	// Ack.
	SDHC_MMCBOOT_BOOTACK_1 = 0x1
	// Position of BOOTMODE field.
	SDHC_MMCBOOT_BOOTMODE_Pos = 0x5
	// Bit mask of BOOTMODE field.
	SDHC_MMCBOOT_BOOTMODE_Msk = 0x20
	// Bit BOOTMODE.
	SDHC_MMCBOOT_BOOTMODE = 0x20
	// Normal boot.
	SDHC_MMCBOOT_BOOTMODE_0 = 0x0
	// Alternative boot.
	SDHC_MMCBOOT_BOOTMODE_1 = 0x1
	// Position of BOOTEN field.
	SDHC_MMCBOOT_BOOTEN_Pos = 0x6
	// Bit mask of BOOTEN field.
	SDHC_MMCBOOT_BOOTEN_Msk = 0x40
	// Bit BOOTEN.
	SDHC_MMCBOOT_BOOTEN = 0x40
	// Fast boot disable.
	SDHC_MMCBOOT_BOOTEN_0 = 0x0
	// Fast boot enable.
	SDHC_MMCBOOT_BOOTEN_1 = 0x1
	// Position of AUTOSABGEN field.
	SDHC_MMCBOOT_AUTOSABGEN_Pos = 0x7
	// Bit mask of AUTOSABGEN field.
	SDHC_MMCBOOT_AUTOSABGEN_Msk = 0x80
	// Bit AUTOSABGEN.
	SDHC_MMCBOOT_AUTOSABGEN = 0x80
	// Position of BOOTBLKCNT field.
	SDHC_MMCBOOT_BOOTBLKCNT_Pos = 0x10
	// Bit mask of BOOTBLKCNT field.
	SDHC_MMCBOOT_BOOTBLKCNT_Msk = 0xffff0000

	// HOSTVER: Host Controller Version
	// Position of SVN field.
	SDHC_HOSTVER_SVN_Pos = 0x0
	// Bit mask of SVN field.
	SDHC_HOSTVER_SVN_Msk = 0xff
	// SD host specification version 2.0, supports test event register and ADMA.
	SDHC_HOSTVER_SVN_1 = 0x1
	// Position of VVN field.
	SDHC_HOSTVER_VVN_Pos = 0x8
	// Bit mask of VVN field.
	SDHC_HOSTVER_VVN_Msk = 0xff00
	// Freescale SDHC version 1.0
	SDHC_HOSTVER_VVN_0 = 0x0
	// Freescale SDHC version 2.0
	SDHC_HOSTVER_VVN_10000 = 0x10
	// Freescale SDHC version 2.1
	SDHC_HOSTVER_VVN_10001 = 0x11
	// Freescale SDHC version 2.2
	SDHC_HOSTVER_VVN_10010 = 0x12
)

// Constants for ENET: Ethernet MAC-NET Core
const (
	// EIR: Interrupt Event Register
	// Position of TS_TIMER field.
	ENET_EIR_TS_TIMER_Pos = 0xf
	// Bit mask of TS_TIMER field.
	ENET_EIR_TS_TIMER_Msk = 0x8000
	// Bit TS_TIMER.
	ENET_EIR_TS_TIMER = 0x8000
	// Position of TS_AVAIL field.
	ENET_EIR_TS_AVAIL_Pos = 0x10
	// Bit mask of TS_AVAIL field.
	ENET_EIR_TS_AVAIL_Msk = 0x10000
	// Bit TS_AVAIL.
	ENET_EIR_TS_AVAIL = 0x10000
	// Position of WAKEUP field.
	ENET_EIR_WAKEUP_Pos = 0x11
	// Bit mask of WAKEUP field.
	ENET_EIR_WAKEUP_Msk = 0x20000
	// Bit WAKEUP.
	ENET_EIR_WAKEUP = 0x20000
	// Position of PLR field.
	ENET_EIR_PLR_Pos = 0x12
	// Bit mask of PLR field.
	ENET_EIR_PLR_Msk = 0x40000
	// Bit PLR.
	ENET_EIR_PLR = 0x40000
	// Position of UN field.
	ENET_EIR_UN_Pos = 0x13
	// Bit mask of UN field.
	ENET_EIR_UN_Msk = 0x80000
	// Bit UN.
	ENET_EIR_UN = 0x80000
	// Position of RL field.
	ENET_EIR_RL_Pos = 0x14
	// Bit mask of RL field.
	ENET_EIR_RL_Msk = 0x100000
	// Bit RL.
	ENET_EIR_RL = 0x100000
	// Position of LC field.
	ENET_EIR_LC_Pos = 0x15
	// Bit mask of LC field.
	ENET_EIR_LC_Msk = 0x200000
	// Bit LC.
	ENET_EIR_LC = 0x200000
	// Position of EBERR field.
	ENET_EIR_EBERR_Pos = 0x16
	// Bit mask of EBERR field.
	ENET_EIR_EBERR_Msk = 0x400000
	// Bit EBERR.
	ENET_EIR_EBERR = 0x400000
	// Position of MII field.
	ENET_EIR_MII_Pos = 0x17
	// Bit mask of MII field.
	ENET_EIR_MII_Msk = 0x800000
	// Bit MII.
	ENET_EIR_MII = 0x800000
	// Position of RXB field.
	ENET_EIR_RXB_Pos = 0x18
	// Bit mask of RXB field.
	ENET_EIR_RXB_Msk = 0x1000000
	// Bit RXB.
	ENET_EIR_RXB = 0x1000000
	// Position of RXF field.
	ENET_EIR_RXF_Pos = 0x19
	// Bit mask of RXF field.
	ENET_EIR_RXF_Msk = 0x2000000
	// Bit RXF.
	ENET_EIR_RXF = 0x2000000
	// Position of TXB field.
	ENET_EIR_TXB_Pos = 0x1a
	// Bit mask of TXB field.
	ENET_EIR_TXB_Msk = 0x4000000
	// Bit TXB.
	ENET_EIR_TXB = 0x4000000
	// Position of TXF field.
	ENET_EIR_TXF_Pos = 0x1b
	// Bit mask of TXF field.
	ENET_EIR_TXF_Msk = 0x8000000
	// Bit TXF.
	ENET_EIR_TXF = 0x8000000
	// Position of GRA field.
	ENET_EIR_GRA_Pos = 0x1c
	// Bit mask of GRA field.
	ENET_EIR_GRA_Msk = 0x10000000
	// Bit GRA.
	ENET_EIR_GRA = 0x10000000
	// Position of BABT field.
	ENET_EIR_BABT_Pos = 0x1d
	// Bit mask of BABT field.
	ENET_EIR_BABT_Msk = 0x20000000
	// Bit BABT.
	ENET_EIR_BABT = 0x20000000
	// Position of BABR field.
	ENET_EIR_BABR_Pos = 0x1e
	// Bit mask of BABR field.
	ENET_EIR_BABR_Msk = 0x40000000
	// Bit BABR.
	ENET_EIR_BABR = 0x40000000

	// EIMR: Interrupt Mask Register
	// Position of TS_TIMER field.
	ENET_EIMR_TS_TIMER_Pos = 0xf
	// Bit mask of TS_TIMER field.
	ENET_EIMR_TS_TIMER_Msk = 0x8000
	// Bit TS_TIMER.
	ENET_EIMR_TS_TIMER = 0x8000
	// Position of TS_AVAIL field.
	ENET_EIMR_TS_AVAIL_Pos = 0x10
	// Bit mask of TS_AVAIL field.
	ENET_EIMR_TS_AVAIL_Msk = 0x10000
	// Bit TS_AVAIL.
	ENET_EIMR_TS_AVAIL = 0x10000
	// Position of WAKEUP field.
	ENET_EIMR_WAKEUP_Pos = 0x11
	// Bit mask of WAKEUP field.
	ENET_EIMR_WAKEUP_Msk = 0x20000
	// Bit WAKEUP.
	ENET_EIMR_WAKEUP = 0x20000
	// Position of PLR field.
	ENET_EIMR_PLR_Pos = 0x12
	// Bit mask of PLR field.
	ENET_EIMR_PLR_Msk = 0x40000
	// Bit PLR.
	ENET_EIMR_PLR = 0x40000
	// Position of UN field.
	ENET_EIMR_UN_Pos = 0x13
	// Bit mask of UN field.
	ENET_EIMR_UN_Msk = 0x80000
	// Bit UN.
	ENET_EIMR_UN = 0x80000
	// Position of RL field.
	ENET_EIMR_RL_Pos = 0x14
	// Bit mask of RL field.
	ENET_EIMR_RL_Msk = 0x100000
	// Bit RL.
	ENET_EIMR_RL = 0x100000
	// Position of LC field.
	ENET_EIMR_LC_Pos = 0x15
	// Bit mask of LC field.
	ENET_EIMR_LC_Msk = 0x200000
	// Bit LC.
	ENET_EIMR_LC = 0x200000
	// Position of EBERR field.
	ENET_EIMR_EBERR_Pos = 0x16
	// Bit mask of EBERR field.
	ENET_EIMR_EBERR_Msk = 0x400000
	// Bit EBERR.
	ENET_EIMR_EBERR = 0x400000
	// Position of MII field.
	ENET_EIMR_MII_Pos = 0x17
	// Bit mask of MII field.
	ENET_EIMR_MII_Msk = 0x800000
	// Bit MII.
	ENET_EIMR_MII = 0x800000
	// Position of RXB field.
	ENET_EIMR_RXB_Pos = 0x18
	// Bit mask of RXB field.
	ENET_EIMR_RXB_Msk = 0x1000000
	// Bit RXB.
	ENET_EIMR_RXB = 0x1000000
	// Position of RXF field.
	ENET_EIMR_RXF_Pos = 0x19
	// Bit mask of RXF field.
	ENET_EIMR_RXF_Msk = 0x2000000
	// Bit RXF.
	ENET_EIMR_RXF = 0x2000000
	// Position of TXB field.
	ENET_EIMR_TXB_Pos = 0x1a
	// Bit mask of TXB field.
	ENET_EIMR_TXB_Msk = 0x4000000
	// Bit TXB.
	ENET_EIMR_TXB = 0x4000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_TXB_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_TXB_1 = 0x1
	// Position of TXF field.
	ENET_EIMR_TXF_Pos = 0x1b
	// Bit mask of TXF field.
	ENET_EIMR_TXF_Msk = 0x8000000
	// Bit TXF.
	ENET_EIMR_TXF = 0x8000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_TXF_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_TXF_1 = 0x1
	// Position of GRA field.
	ENET_EIMR_GRA_Pos = 0x1c
	// Bit mask of GRA field.
	ENET_EIMR_GRA_Msk = 0x10000000
	// Bit GRA.
	ENET_EIMR_GRA = 0x10000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_GRA_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_GRA_1 = 0x1
	// Position of BABT field.
	ENET_EIMR_BABT_Pos = 0x1d
	// Bit mask of BABT field.
	ENET_EIMR_BABT_Msk = 0x20000000
	// Bit BABT.
	ENET_EIMR_BABT = 0x20000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_BABT_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_BABT_1 = 0x1
	// Position of BABR field.
	ENET_EIMR_BABR_Pos = 0x1e
	// Bit mask of BABR field.
	ENET_EIMR_BABR_Msk = 0x40000000
	// Bit BABR.
	ENET_EIMR_BABR = 0x40000000
	// The corresponding interrupt source is masked.
	ENET_EIMR_BABR_0 = 0x0
	// The corresponding interrupt source is not masked.
	ENET_EIMR_BABR_1 = 0x1

	// RDAR: Receive Descriptor Active Register
	// Position of RDAR field.
	ENET_RDAR_RDAR_Pos = 0x18
	// Bit mask of RDAR field.
	ENET_RDAR_RDAR_Msk = 0x1000000
	// Bit RDAR.
	ENET_RDAR_RDAR = 0x1000000

	// TDAR: Transmit Descriptor Active Register
	// Position of TDAR field.
	ENET_TDAR_TDAR_Pos = 0x18
	// Bit mask of TDAR field.
	ENET_TDAR_TDAR_Msk = 0x1000000
	// Bit TDAR.
	ENET_TDAR_TDAR = 0x1000000

	// ECR: Ethernet Control Register
	// Position of RESET field.
	ENET_ECR_RESET_Pos = 0x0
	// Bit mask of RESET field.
	ENET_ECR_RESET_Msk = 0x1
	// Bit RESET.
	ENET_ECR_RESET = 0x1
	// Position of ETHEREN field.
	ENET_ECR_ETHEREN_Pos = 0x1
	// Bit mask of ETHEREN field.
	ENET_ECR_ETHEREN_Msk = 0x2
	// Bit ETHEREN.
	ENET_ECR_ETHEREN = 0x2
	// Reception immediately stops and transmission stops after a bad CRC is appended to any currently transmitted frame.
	ENET_ECR_ETHEREN_0 = 0x0
	// MAC is enabled, and reception and transmission are possible.
	ENET_ECR_ETHEREN_1 = 0x1
	// Position of MAGICEN field.
	ENET_ECR_MAGICEN_Pos = 0x2
	// Bit mask of MAGICEN field.
	ENET_ECR_MAGICEN_Msk = 0x4
	// Bit MAGICEN.
	ENET_ECR_MAGICEN = 0x4
	// Magic detection logic disabled.
	ENET_ECR_MAGICEN_0 = 0x0
	// The MAC core detects magic packets and asserts EIR[WAKEUP] when a frame is detected.
	ENET_ECR_MAGICEN_1 = 0x1
	// Position of SLEEP field.
	ENET_ECR_SLEEP_Pos = 0x3
	// Bit mask of SLEEP field.
	ENET_ECR_SLEEP_Msk = 0x8
	// Bit SLEEP.
	ENET_ECR_SLEEP = 0x8
	// Normal operating mode.
	ENET_ECR_SLEEP_0 = 0x0
	// Sleep mode.
	ENET_ECR_SLEEP_1 = 0x1
	// Position of EN1588 field.
	ENET_ECR_EN1588_Pos = 0x4
	// Bit mask of EN1588 field.
	ENET_ECR_EN1588_Msk = 0x10
	// Bit EN1588.
	ENET_ECR_EN1588 = 0x10
	// Legacy FEC buffer descriptors and functions enabled.
	ENET_ECR_EN1588_0 = 0x0
	// Enhanced frame time-stamping functions enabled.
	ENET_ECR_EN1588_1 = 0x1
	// Position of DBGEN field.
	ENET_ECR_DBGEN_Pos = 0x6
	// Bit mask of DBGEN field.
	ENET_ECR_DBGEN_Msk = 0x40
	// Bit DBGEN.
	ENET_ECR_DBGEN = 0x40
	// MAC continues operation in debug mode.
	ENET_ECR_DBGEN_0 = 0x0
	// MAC enters hardware freeze mode when the processor is in debug mode.
	ENET_ECR_DBGEN_1 = 0x1
	// Position of STOPEN field.
	ENET_ECR_STOPEN_Pos = 0x7
	// Bit mask of STOPEN field.
	ENET_ECR_STOPEN_Msk = 0x80
	// Bit STOPEN.
	ENET_ECR_STOPEN = 0x80
	// Position of DBSWP field.
	ENET_ECR_DBSWP_Pos = 0x8
	// Bit mask of DBSWP field.
	ENET_ECR_DBSWP_Msk = 0x100
	// Bit DBSWP.
	ENET_ECR_DBSWP = 0x100
	// The buffer descriptor bytes are not swapped to support big-endian devices.
	ENET_ECR_DBSWP_0 = 0x0
	// The buffer descriptor bytes are swapped to support little-endian devices.
	ENET_ECR_DBSWP_1 = 0x1

	// MMFR: MII Management Frame Register
	// Position of DATA field.
	ENET_MMFR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ENET_MMFR_DATA_Msk = 0xffff
	// Position of TA field.
	ENET_MMFR_TA_Pos = 0x10
	// Bit mask of TA field.
	ENET_MMFR_TA_Msk = 0x30000
	// Position of RA field.
	ENET_MMFR_RA_Pos = 0x12
	// Bit mask of RA field.
	ENET_MMFR_RA_Msk = 0x7c0000
	// Position of PA field.
	ENET_MMFR_PA_Pos = 0x17
	// Bit mask of PA field.
	ENET_MMFR_PA_Msk = 0xf800000
	// Position of OP field.
	ENET_MMFR_OP_Pos = 0x1c
	// Bit mask of OP field.
	ENET_MMFR_OP_Msk = 0x30000000
	// Position of ST field.
	ENET_MMFR_ST_Pos = 0x1e
	// Bit mask of ST field.
	ENET_MMFR_ST_Msk = 0xc0000000

	// MSCR: MII Speed Control Register
	// Position of MII_SPEED field.
	ENET_MSCR_MII_SPEED_Pos = 0x1
	// Bit mask of MII_SPEED field.
	ENET_MSCR_MII_SPEED_Msk = 0x7e
	// Position of DIS_PRE field.
	ENET_MSCR_DIS_PRE_Pos = 0x7
	// Bit mask of DIS_PRE field.
	ENET_MSCR_DIS_PRE_Msk = 0x80
	// Bit DIS_PRE.
	ENET_MSCR_DIS_PRE = 0x80
	// Preamble enabled.
	ENET_MSCR_DIS_PRE_0 = 0x0
	// Preamble (32 ones) is not prepended to the MII management frame.
	ENET_MSCR_DIS_PRE_1 = 0x1
	// Position of HOLDTIME field.
	ENET_MSCR_HOLDTIME_Pos = 0x8
	// Bit mask of HOLDTIME field.
	ENET_MSCR_HOLDTIME_Msk = 0x700
	// 1 internal module clock cycle
	ENET_MSCR_HOLDTIME_000 = 0x0
	// 2 internal module clock cycles
	ENET_MSCR_HOLDTIME_001 = 0x1
	// 3 internal module clock cycles
	ENET_MSCR_HOLDTIME_010 = 0x2
	// 8 internal module clock cycles
	ENET_MSCR_HOLDTIME_111 = 0x7

	// MIBC: MIB Control Register
	// Position of MIB_CLEAR field.
	ENET_MIBC_MIB_CLEAR_Pos = 0x1d
	// Bit mask of MIB_CLEAR field.
	ENET_MIBC_MIB_CLEAR_Msk = 0x20000000
	// Bit MIB_CLEAR.
	ENET_MIBC_MIB_CLEAR = 0x20000000
	// See note above.
	ENET_MIBC_MIB_CLEAR_0 = 0x0
	// All statistics counters are reset to 0.
	ENET_MIBC_MIB_CLEAR_1 = 0x1
	// Position of MIB_IDLE field.
	ENET_MIBC_MIB_IDLE_Pos = 0x1e
	// Bit mask of MIB_IDLE field.
	ENET_MIBC_MIB_IDLE_Msk = 0x40000000
	// Bit MIB_IDLE.
	ENET_MIBC_MIB_IDLE = 0x40000000
	// The MIB block is updating MIB counters.
	ENET_MIBC_MIB_IDLE_0 = 0x0
	// The MIB block is not currently updating any MIB counters.
	ENET_MIBC_MIB_IDLE_1 = 0x1
	// Position of MIB_DIS field.
	ENET_MIBC_MIB_DIS_Pos = 0x1f
	// Bit mask of MIB_DIS field.
	ENET_MIBC_MIB_DIS_Msk = 0x80000000
	// Bit MIB_DIS.
	ENET_MIBC_MIB_DIS = 0x80000000
	// MIB logic is enabled.
	ENET_MIBC_MIB_DIS_0 = 0x0
	// MIB logic is disabled. The MIB logic halts and does not update any MIB counters.
	ENET_MIBC_MIB_DIS_1 = 0x1

	// RCR: Receive Control Register
	// Position of LOOP field.
	ENET_RCR_LOOP_Pos = 0x0
	// Bit mask of LOOP field.
	ENET_RCR_LOOP_Msk = 0x1
	// Bit LOOP.
	ENET_RCR_LOOP = 0x1
	// Loopback disabled.
	ENET_RCR_LOOP_0 = 0x0
	// Transmitted frames are looped back internal to the device and transmit MII output signals are not asserted. DRT must be cleared.
	ENET_RCR_LOOP_1 = 0x1
	// Position of DRT field.
	ENET_RCR_DRT_Pos = 0x1
	// Bit mask of DRT field.
	ENET_RCR_DRT_Msk = 0x2
	// Bit DRT.
	ENET_RCR_DRT = 0x2
	// Receive path operates independently of transmit. Used for full-duplex or to monitor transmit activity in half-duplex mode.
	ENET_RCR_DRT_0 = 0x0
	// Disable reception of frames while transmitting. Normally used for half-duplex mode.
	ENET_RCR_DRT_1 = 0x1
	// Position of MII_MODE field.
	ENET_RCR_MII_MODE_Pos = 0x2
	// Bit mask of MII_MODE field.
	ENET_RCR_MII_MODE_Msk = 0x4
	// Bit MII_MODE.
	ENET_RCR_MII_MODE = 0x4
	// MII or RMII mode, as indicated by the RMII_MODE field.
	ENET_RCR_MII_MODE_1 = 0x1
	// Position of PROM field.
	ENET_RCR_PROM_Pos = 0x3
	// Bit mask of PROM field.
	ENET_RCR_PROM_Msk = 0x8
	// Bit PROM.
	ENET_RCR_PROM = 0x8
	// Disabled.
	ENET_RCR_PROM_0 = 0x0
	// Enabled.
	ENET_RCR_PROM_1 = 0x1
	// Position of BC_REJ field.
	ENET_RCR_BC_REJ_Pos = 0x4
	// Bit mask of BC_REJ field.
	ENET_RCR_BC_REJ_Msk = 0x10
	// Bit BC_REJ.
	ENET_RCR_BC_REJ = 0x10
	// Position of FCE field.
	ENET_RCR_FCE_Pos = 0x5
	// Bit mask of FCE field.
	ENET_RCR_FCE_Msk = 0x20
	// Bit FCE.
	ENET_RCR_FCE = 0x20
	// Position of RMII_MODE field.
	ENET_RCR_RMII_MODE_Pos = 0x8
	// Bit mask of RMII_MODE field.
	ENET_RCR_RMII_MODE_Msk = 0x100
	// Bit RMII_MODE.
	ENET_RCR_RMII_MODE = 0x100
	// MAC configured for MII mode.
	ENET_RCR_RMII_MODE_0 = 0x0
	// MAC configured for RMII operation.
	ENET_RCR_RMII_MODE_1 = 0x1
	// Position of RMII_10T field.
	ENET_RCR_RMII_10T_Pos = 0x9
	// Bit mask of RMII_10T field.
	ENET_RCR_RMII_10T_Msk = 0x200
	// Bit RMII_10T.
	ENET_RCR_RMII_10T = 0x200
	// 100 Mbps operation.
	ENET_RCR_RMII_10T_0 = 0x0
	// 10 Mbps operation.
	ENET_RCR_RMII_10T_1 = 0x1
	// Position of PADEN field.
	ENET_RCR_PADEN_Pos = 0xc
	// Bit mask of PADEN field.
	ENET_RCR_PADEN_Msk = 0x1000
	// Bit PADEN.
	ENET_RCR_PADEN = 0x1000
	// No padding is removed on receive by the MAC.
	ENET_RCR_PADEN_0 = 0x0
	// Padding is removed from received frames.
	ENET_RCR_PADEN_1 = 0x1
	// Position of PAUFWD field.
	ENET_RCR_PAUFWD_Pos = 0xd
	// Bit mask of PAUFWD field.
	ENET_RCR_PAUFWD_Msk = 0x2000
	// Bit PAUFWD.
	ENET_RCR_PAUFWD = 0x2000
	// Pause frames are terminated and discarded in the MAC.
	ENET_RCR_PAUFWD_0 = 0x0
	// Pause frames are forwarded to the user application.
	ENET_RCR_PAUFWD_1 = 0x1
	// Position of CRCFWD field.
	ENET_RCR_CRCFWD_Pos = 0xe
	// Bit mask of CRCFWD field.
	ENET_RCR_CRCFWD_Msk = 0x4000
	// Bit CRCFWD.
	ENET_RCR_CRCFWD = 0x4000
	// The CRC field of received frames is transmitted to the user application.
	ENET_RCR_CRCFWD_0 = 0x0
	// The CRC field is stripped from the frame.
	ENET_RCR_CRCFWD_1 = 0x1
	// Position of CFEN field.
	ENET_RCR_CFEN_Pos = 0xf
	// Bit mask of CFEN field.
	ENET_RCR_CFEN_Msk = 0x8000
	// Bit CFEN.
	ENET_RCR_CFEN = 0x8000
	// MAC control frames with any opcode other than 0x0001 (pause frame) are accepted and forwarded to the client interface.
	ENET_RCR_CFEN_0 = 0x0
	// MAC control frames with any opcode other than 0x0001 (pause frame) are silently discarded.
	ENET_RCR_CFEN_1 = 0x1
	// Position of MAX_FL field.
	ENET_RCR_MAX_FL_Pos = 0x10
	// Bit mask of MAX_FL field.
	ENET_RCR_MAX_FL_Msk = 0x3fff0000
	// Position of NLC field.
	ENET_RCR_NLC_Pos = 0x1e
	// Bit mask of NLC field.
	ENET_RCR_NLC_Msk = 0x40000000
	// Bit NLC.
	ENET_RCR_NLC = 0x40000000
	// The payload length check is disabled.
	ENET_RCR_NLC_0 = 0x0
	// The core checks the frame's payload length with the frame length/type field. Errors are indicated in the EIR[PLC] field.
	ENET_RCR_NLC_1 = 0x1
	// Position of GRS field.
	ENET_RCR_GRS_Pos = 0x1f
	// Bit mask of GRS field.
	ENET_RCR_GRS_Msk = 0x80000000
	// Bit GRS.
	ENET_RCR_GRS = 0x80000000

	// TCR: Transmit Control Register
	// Position of GTS field.
	ENET_TCR_GTS_Pos = 0x0
	// Bit mask of GTS field.
	ENET_TCR_GTS_Msk = 0x1
	// Bit GTS.
	ENET_TCR_GTS = 0x1
	// Position of FDEN field.
	ENET_TCR_FDEN_Pos = 0x2
	// Bit mask of FDEN field.
	ENET_TCR_FDEN_Msk = 0x4
	// Bit FDEN.
	ENET_TCR_FDEN = 0x4
	// Position of TFC_PAUSE field.
	ENET_TCR_TFC_PAUSE_Pos = 0x3
	// Bit mask of TFC_PAUSE field.
	ENET_TCR_TFC_PAUSE_Msk = 0x8
	// Bit TFC_PAUSE.
	ENET_TCR_TFC_PAUSE = 0x8
	// No PAUSE frame transmitted.
	ENET_TCR_TFC_PAUSE_0 = 0x0
	// The MAC stops transmission of data frames after the current transmission is complete.
	ENET_TCR_TFC_PAUSE_1 = 0x1
	// Position of RFC_PAUSE field.
	ENET_TCR_RFC_PAUSE_Pos = 0x4
	// Bit mask of RFC_PAUSE field.
	ENET_TCR_RFC_PAUSE_Msk = 0x10
	// Bit RFC_PAUSE.
	ENET_TCR_RFC_PAUSE = 0x10
	// Position of ADDSEL field.
	ENET_TCR_ADDSEL_Pos = 0x5
	// Bit mask of ADDSEL field.
	ENET_TCR_ADDSEL_Msk = 0xe0
	// Node MAC address programmed on PADDR1/2 registers.
	ENET_TCR_ADDSEL_000 = 0x0
	// Position of ADDINS field.
	ENET_TCR_ADDINS_Pos = 0x8
	// Bit mask of ADDINS field.
	ENET_TCR_ADDINS_Msk = 0x100
	// Bit ADDINS.
	ENET_TCR_ADDINS = 0x100
	// The source MAC address is not modified by the MAC.
	ENET_TCR_ADDINS_0 = 0x0
	// The MAC overwrites the source MAC address with the programmed MAC address according to ADDSEL.
	ENET_TCR_ADDINS_1 = 0x1
	// Position of CRCFWD field.
	ENET_TCR_CRCFWD_Pos = 0x9
	// Bit mask of CRCFWD field.
	ENET_TCR_CRCFWD_Msk = 0x200
	// Bit CRCFWD.
	ENET_TCR_CRCFWD = 0x200
	// TxBD[TC] controls whether the frame has a CRC from the application.
	ENET_TCR_CRCFWD_0 = 0x0
	// The transmitter does not append any CRC to transmitted frames, as it is expecting a frame with CRC from the application.
	ENET_TCR_CRCFWD_1 = 0x1

	// PALR: Physical Address Lower Register
	// Position of PADDR1 field.
	ENET_PALR_PADDR1_Pos = 0x0
	// Bit mask of PADDR1 field.
	ENET_PALR_PADDR1_Msk = 0xffffffff

	// PAUR: Physical Address Upper Register
	// Position of TYPE field.
	ENET_PAUR_TYPE_Pos = 0x0
	// Bit mask of TYPE field.
	ENET_PAUR_TYPE_Msk = 0xffff
	// Position of PADDR2 field.
	ENET_PAUR_PADDR2_Pos = 0x10
	// Bit mask of PADDR2 field.
	ENET_PAUR_PADDR2_Msk = 0xffff0000

	// OPD: Opcode/Pause Duration Register
	// Position of PAUSE_DUR field.
	ENET_OPD_PAUSE_DUR_Pos = 0x0
	// Bit mask of PAUSE_DUR field.
	ENET_OPD_PAUSE_DUR_Msk = 0xffff
	// Position of OPCODE field.
	ENET_OPD_OPCODE_Pos = 0x10
	// Bit mask of OPCODE field.
	ENET_OPD_OPCODE_Msk = 0xffff0000

	// IAUR: Descriptor Individual Upper Address Register
	// Position of IADDR1 field.
	ENET_IAUR_IADDR1_Pos = 0x0
	// Bit mask of IADDR1 field.
	ENET_IAUR_IADDR1_Msk = 0xffffffff

	// IALR: Descriptor Individual Lower Address Register
	// Position of IADDR2 field.
	ENET_IALR_IADDR2_Pos = 0x0
	// Bit mask of IADDR2 field.
	ENET_IALR_IADDR2_Msk = 0xffffffff

	// GAUR: Descriptor Group Upper Address Register
	// Position of GADDR1 field.
	ENET_GAUR_GADDR1_Pos = 0x0
	// Bit mask of GADDR1 field.
	ENET_GAUR_GADDR1_Msk = 0xffffffff

	// GALR: Descriptor Group Lower Address Register
	// Position of GADDR2 field.
	ENET_GALR_GADDR2_Pos = 0x0
	// Bit mask of GADDR2 field.
	ENET_GALR_GADDR2_Msk = 0xffffffff

	// TFWR: Transmit FIFO Watermark Register
	// Position of TFWR field.
	ENET_TFWR_TFWR_Pos = 0x0
	// Bit mask of TFWR field.
	ENET_TFWR_TFWR_Msk = 0x3f
	// 64 bytes written.
	ENET_TFWR_TFWR_000000 = 0x0
	// 64 bytes written.
	ENET_TFWR_TFWR_000001 = 0x1
	// 128 bytes written.
	ENET_TFWR_TFWR_000010 = 0x2
	// 192 bytes written.
	ENET_TFWR_TFWR_000011 = 0x3
	// 1984 bytes written.
	ENET_TFWR_TFWR_011111 = 0x1f
	// Position of STRFWD field.
	ENET_TFWR_STRFWD_Pos = 0x8
	// Bit mask of STRFWD field.
	ENET_TFWR_STRFWD_Msk = 0x100
	// Bit STRFWD.
	ENET_TFWR_STRFWD = 0x100
	// Reset. The transmission start threshold is programmed in TFWR[TFWR].
	ENET_TFWR_STRFWD_0 = 0x0
	// Enabled.
	ENET_TFWR_STRFWD_1 = 0x1

	// RDSR: Receive Descriptor Ring Start Register
	// Position of R_DES_START field.
	ENET_RDSR_R_DES_START_Pos = 0x3
	// Bit mask of R_DES_START field.
	ENET_RDSR_R_DES_START_Msk = 0xfffffff8

	// TDSR: Transmit Buffer Descriptor Ring Start Register
	// Position of X_DES_START field.
	ENET_TDSR_X_DES_START_Pos = 0x3
	// Bit mask of X_DES_START field.
	ENET_TDSR_X_DES_START_Msk = 0xfffffff8

	// MRBR: Maximum Receive Buffer Size Register
	// Position of R_BUF_SIZE field.
	ENET_MRBR_R_BUF_SIZE_Pos = 0x4
	// Bit mask of R_BUF_SIZE field.
	ENET_MRBR_R_BUF_SIZE_Msk = 0x7f0

	// RSFL: Receive FIFO Section Full Threshold
	// Position of RX_SECTION_FULL field.
	ENET_RSFL_RX_SECTION_FULL_Pos = 0x0
	// Bit mask of RX_SECTION_FULL field.
	ENET_RSFL_RX_SECTION_FULL_Msk = 0xff

	// RSEM: Receive FIFO Section Empty Threshold
	// Position of RX_SECTION_EMPTY field.
	ENET_RSEM_RX_SECTION_EMPTY_Pos = 0x0
	// Bit mask of RX_SECTION_EMPTY field.
	ENET_RSEM_RX_SECTION_EMPTY_Msk = 0xff
	// Position of STAT_SECTION_EMPTY field.
	ENET_RSEM_STAT_SECTION_EMPTY_Pos = 0x10
	// Bit mask of STAT_SECTION_EMPTY field.
	ENET_RSEM_STAT_SECTION_EMPTY_Msk = 0x1f0000

	// RAEM: Receive FIFO Almost Empty Threshold
	// Position of RX_ALMOST_EMPTY field.
	ENET_RAEM_RX_ALMOST_EMPTY_Pos = 0x0
	// Bit mask of RX_ALMOST_EMPTY field.
	ENET_RAEM_RX_ALMOST_EMPTY_Msk = 0xff

	// RAFL: Receive FIFO Almost Full Threshold
	// Position of RX_ALMOST_FULL field.
	ENET_RAFL_RX_ALMOST_FULL_Pos = 0x0
	// Bit mask of RX_ALMOST_FULL field.
	ENET_RAFL_RX_ALMOST_FULL_Msk = 0xff

	// TSEM: Transmit FIFO Section Empty Threshold
	// Position of TX_SECTION_EMPTY field.
	ENET_TSEM_TX_SECTION_EMPTY_Pos = 0x0
	// Bit mask of TX_SECTION_EMPTY field.
	ENET_TSEM_TX_SECTION_EMPTY_Msk = 0xff

	// TAEM: Transmit FIFO Almost Empty Threshold
	// Position of TX_ALMOST_EMPTY field.
	ENET_TAEM_TX_ALMOST_EMPTY_Pos = 0x0
	// Bit mask of TX_ALMOST_EMPTY field.
	ENET_TAEM_TX_ALMOST_EMPTY_Msk = 0xff

	// TAFL: Transmit FIFO Almost Full Threshold
	// Position of TX_ALMOST_FULL field.
	ENET_TAFL_TX_ALMOST_FULL_Pos = 0x0
	// Bit mask of TX_ALMOST_FULL field.
	ENET_TAFL_TX_ALMOST_FULL_Msk = 0xff

	// TIPG: Transmit Inter-Packet Gap
	// Position of IPG field.
	ENET_TIPG_IPG_Pos = 0x0
	// Bit mask of IPG field.
	ENET_TIPG_IPG_Msk = 0x1f

	// FTRL: Frame Truncation Length
	// Position of TRUNC_FL field.
	ENET_FTRL_TRUNC_FL_Pos = 0x0
	// Bit mask of TRUNC_FL field.
	ENET_FTRL_TRUNC_FL_Msk = 0x3fff

	// TACC: Transmit Accelerator Function Configuration
	// Position of SHIFT16 field.
	ENET_TACC_SHIFT16_Pos = 0x0
	// Bit mask of SHIFT16 field.
	ENET_TACC_SHIFT16_Msk = 0x1
	// Bit SHIFT16.
	ENET_TACC_SHIFT16 = 0x1
	// Disabled.
	ENET_TACC_SHIFT16_0 = 0x0
	// Indicates to the transmit data FIFO that the written frames contain two additional octets before the frame data. This means the actual frame begins at bit 16 of the first word written into the FIFO. This function allows putting the frame payload on a 32-bit boundary in memory, as the 14-byte Ethernet header is extended to a 16-byte header.
	ENET_TACC_SHIFT16_1 = 0x1
	// Position of IPCHK field.
	ENET_TACC_IPCHK_Pos = 0x3
	// Bit mask of IPCHK field.
	ENET_TACC_IPCHK_Msk = 0x8
	// Bit IPCHK.
	ENET_TACC_IPCHK = 0x8
	// Checksum is not inserted.
	ENET_TACC_IPCHK_0 = 0x0
	// If an IP frame is transmitted, the checksum is inserted automatically. The IP header checksum field must be cleared. If a non-IP frame is transmitted the frame is not modified.
	ENET_TACC_IPCHK_1 = 0x1
	// Position of PROCHK field.
	ENET_TACC_PROCHK_Pos = 0x4
	// Bit mask of PROCHK field.
	ENET_TACC_PROCHK_Msk = 0x10
	// Bit PROCHK.
	ENET_TACC_PROCHK = 0x10
	// Checksum not inserted.
	ENET_TACC_PROCHK_0 = 0x0
	// If an IP frame with a known protocol is transmitted, the checksum is inserted automatically into the frame. The checksum field must be cleared. The other frames are not modified.
	ENET_TACC_PROCHK_1 = 0x1

	// RACC: Receive Accelerator Function Configuration
	// Position of PADREM field.
	ENET_RACC_PADREM_Pos = 0x0
	// Bit mask of PADREM field.
	ENET_RACC_PADREM_Msk = 0x1
	// Bit PADREM.
	ENET_RACC_PADREM = 0x1
	// Padding not removed.
	ENET_RACC_PADREM_0 = 0x0
	// Any bytes following the IP payload section of the frame are removed from the frame.
	ENET_RACC_PADREM_1 = 0x1
	// Position of IPDIS field.
	ENET_RACC_IPDIS_Pos = 0x1
	// Bit mask of IPDIS field.
	ENET_RACC_IPDIS_Msk = 0x2
	// Bit IPDIS.
	ENET_RACC_IPDIS = 0x2
	// Frames with wrong IPv4 header checksum are not discarded.
	ENET_RACC_IPDIS_0 = 0x0
	// If an IPv4 frame is received with a mismatching header checksum, the frame is discarded. IPv6 has no header checksum and is not affected by this setting. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).
	ENET_RACC_IPDIS_1 = 0x1
	// Position of PRODIS field.
	ENET_RACC_PRODIS_Pos = 0x2
	// Bit mask of PRODIS field.
	ENET_RACC_PRODIS_Msk = 0x4
	// Bit PRODIS.
	ENET_RACC_PRODIS = 0x4
	// Frames with wrong checksum are not discarded.
	ENET_RACC_PRODIS_0 = 0x0
	// If a TCP/IP, UDP/IP, or ICMP/IP frame is received that has a wrong TCP, UDP, or ICMP checksum, the frame is discarded. Discarding is only available when the RX FIFO operates in store and forward mode (RSFL cleared).
	ENET_RACC_PRODIS_1 = 0x1
	// Position of LINEDIS field.
	ENET_RACC_LINEDIS_Pos = 0x6
	// Bit mask of LINEDIS field.
	ENET_RACC_LINEDIS_Msk = 0x40
	// Bit LINEDIS.
	ENET_RACC_LINEDIS = 0x40
	// Frames with errors are not discarded.
	ENET_RACC_LINEDIS_0 = 0x0
	// Any frame received with a CRC, length, or PHY error is automatically discarded and not forwarded to the user application interface.
	ENET_RACC_LINEDIS_1 = 0x1
	// Position of SHIFT16 field.
	ENET_RACC_SHIFT16_Pos = 0x7
	// Bit mask of SHIFT16 field.
	ENET_RACC_SHIFT16_Msk = 0x80
	// Bit SHIFT16.
	ENET_RACC_SHIFT16 = 0x80
	// Disabled.
	ENET_RACC_SHIFT16_0 = 0x0
	// Instructs the MAC to write two additional bytes in front of each frame received into the RX FIFO.
	ENET_RACC_SHIFT16_1 = 0x1

	// RMON_T_PACKETS: Tx Packet Count Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_PACKETS_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_PACKETS_TXPKTS_Msk = 0xffff

	// RMON_T_BC_PKT: Tx Broadcast Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_BC_PKT_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_BC_PKT_TXPKTS_Msk = 0xffff

	// RMON_T_MC_PKT: Tx Multicast Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_MC_PKT_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_MC_PKT_TXPKTS_Msk = 0xffff

	// RMON_T_CRC_ALIGN: Tx Packets with CRC/Align Error Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_CRC_ALIGN_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_CRC_ALIGN_TXPKTS_Msk = 0xffff

	// RMON_T_UNDERSIZE: Tx Packets Less Than Bytes and Good CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_UNDERSIZE_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_UNDERSIZE_TXPKTS_Msk = 0xffff

	// RMON_T_OVERSIZE: Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_OVERSIZE_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_OVERSIZE_TXPKTS_Msk = 0xffff

	// RMON_T_FRAG: Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_FRAG_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_FRAG_TXPKTS_Msk = 0xffff

	// RMON_T_JAB: Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_JAB_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_JAB_TXPKTS_Msk = 0xffff

	// RMON_T_COL: Tx Collision Count Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_COL_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_COL_TXPKTS_Msk = 0xffff

	// RMON_T_P64: Tx 64-Byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P64_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P64_TXPKTS_Msk = 0xffff

	// RMON_T_P65TO127: Tx 65- to 127-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P65TO127_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P65TO127_TXPKTS_Msk = 0xffff

	// RMON_T_P128TO255: Tx 128- to 255-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P128TO255_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P128TO255_TXPKTS_Msk = 0xffff

	// RMON_T_P256TO511: Tx 256- to 511-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P256TO511_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P256TO511_TXPKTS_Msk = 0xffff

	// RMON_T_P512TO1023: Tx 512- to 1023-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P512TO1023_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P512TO1023_TXPKTS_Msk = 0xffff

	// RMON_T_P1024TO2047: Tx 1024- to 2047-byte Packets Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P1024TO2047_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P1024TO2047_TXPKTS_Msk = 0xffff

	// RMON_T_P_GTE2048: Tx Packets Greater Than 2048 Bytes Statistic Register
	// Position of TXPKTS field.
	ENET_RMON_T_P_GTE2048_TXPKTS_Pos = 0x0
	// Bit mask of TXPKTS field.
	ENET_RMON_T_P_GTE2048_TXPKTS_Msk = 0xffff

	// RMON_T_OCTETS: Tx Octets Statistic Register
	// Position of TXOCTS field.
	ENET_RMON_T_OCTETS_TXOCTS_Pos = 0x0
	// Bit mask of TXOCTS field.
	ENET_RMON_T_OCTETS_TXOCTS_Msk = 0xffffffff

	// IEEE_T_FRAME_OK: Frames Transmitted OK Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_FRAME_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_FRAME_OK_COUNT_Msk = 0xffff

	// IEEE_T_1COL: Frames Transmitted with Single Collision Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_1COL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_1COL_COUNT_Msk = 0xffff

	// IEEE_T_MCOL: Frames Transmitted with Multiple Collisions Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_MCOL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_MCOL_COUNT_Msk = 0xffff

	// IEEE_T_DEF: Frames Transmitted after Deferral Delay Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_DEF_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_DEF_COUNT_Msk = 0xffff

	// IEEE_T_LCOL: Frames Transmitted with Late Collision Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_LCOL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_LCOL_COUNT_Msk = 0xffff

	// IEEE_T_EXCOL: Frames Transmitted with Excessive Collisions Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_EXCOL_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_EXCOL_COUNT_Msk = 0xffff

	// IEEE_T_MACERR: Frames Transmitted with Tx FIFO Underrun Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_MACERR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_MACERR_COUNT_Msk = 0xffff

	// IEEE_T_CSERR: Frames Transmitted with Carrier Sense Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_CSERR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_CSERR_COUNT_Msk = 0xffff

	// IEEE_T_SQE: no description available
	// Position of COUNT field.
	ENET_IEEE_T_SQE_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_SQE_COUNT_Msk = 0xffff

	// IEEE_T_FDXFC: Flow Control Pause Frames Transmitted Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_FDXFC_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_FDXFC_COUNT_Msk = 0xffff

	// IEEE_T_OCTETS_OK: Octet Count for Frames Transmitted w/o Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_T_OCTETS_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_T_OCTETS_OK_COUNT_Msk = 0xffffffff

	// RMON_R_PACKETS: Rx Packet Count Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_PACKETS_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_PACKETS_COUNT_Msk = 0xffff

	// RMON_R_BC_PKT: Rx Broadcast Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_BC_PKT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_BC_PKT_COUNT_Msk = 0xffff

	// RMON_R_MC_PKT: Rx Multicast Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_MC_PKT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_MC_PKT_COUNT_Msk = 0xffff

	// RMON_R_CRC_ALIGN: Rx Packets with CRC/Align Error Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_CRC_ALIGN_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_CRC_ALIGN_COUNT_Msk = 0xffff

	// RMON_R_UNDERSIZE: Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_UNDERSIZE_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_UNDERSIZE_COUNT_Msk = 0xffff

	// RMON_R_OVERSIZE: Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_OVERSIZE_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_OVERSIZE_COUNT_Msk = 0xffff

	// RMON_R_FRAG: Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_FRAG_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_FRAG_COUNT_Msk = 0xffff

	// RMON_R_JAB: Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_JAB_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_JAB_COUNT_Msk = 0xffff

	// RMON_R_P64: Rx 64-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P64_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P64_COUNT_Msk = 0xffff

	// RMON_R_P65TO127: Rx 65- to 127-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P65TO127_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P65TO127_COUNT_Msk = 0xffff

	// RMON_R_P128TO255: Rx 128- to 255-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P128TO255_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P128TO255_COUNT_Msk = 0xffff

	// RMON_R_P256TO511: Rx 256- to 511-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P256TO511_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P256TO511_COUNT_Msk = 0xffff

	// RMON_R_P512TO1023: Rx 512- to 1023-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P512TO1023_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P512TO1023_COUNT_Msk = 0xffff

	// RMON_R_P1024TO2047: Rx 1024- to 2047-Byte Packets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P1024TO2047_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P1024TO2047_COUNT_Msk = 0xffff

	// RMON_R_P_GTE2048: Rx Packets Greater than 2048 Bytes Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_P_GTE2048_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_P_GTE2048_COUNT_Msk = 0xffff

	// RMON_R_OCTETS: Rx Octets Statistic Register
	// Position of COUNT field.
	ENET_RMON_R_OCTETS_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_RMON_R_OCTETS_COUNT_Msk = 0xffffffff

	// IEEE_R_DROP: Frames not Counted Correctly Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_DROP_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_DROP_COUNT_Msk = 0xffff

	// IEEE_R_FRAME_OK: Frames Received OK Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_FRAME_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_FRAME_OK_COUNT_Msk = 0xffff

	// IEEE_R_CRC: Frames Received with CRC Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_CRC_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_CRC_COUNT_Msk = 0xffff

	// IEEE_R_ALIGN: Frames Received with Alignment Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_ALIGN_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_ALIGN_COUNT_Msk = 0xffff

	// IEEE_R_MACERR: Receive FIFO Overflow Count Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_MACERR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_MACERR_COUNT_Msk = 0xffff

	// IEEE_R_FDXFC: Flow Control Pause Frames Received Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_FDXFC_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_FDXFC_COUNT_Msk = 0xffff

	// IEEE_R_OCTETS_OK: Octet Count for Frames Received without Error Statistic Register
	// Position of COUNT field.
	ENET_IEEE_R_OCTETS_OK_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ENET_IEEE_R_OCTETS_OK_COUNT_Msk = 0xffffffff

	// ATCR: Adjustable Timer Control Register
	// Position of EN field.
	ENET_ATCR_EN_Pos = 0x0
	// Bit mask of EN field.
	ENET_ATCR_EN_Msk = 0x1
	// Bit EN.
	ENET_ATCR_EN = 0x1
	// The timer stops at the current value.
	ENET_ATCR_EN_0 = 0x0
	// The timer starts incrementing.
	ENET_ATCR_EN_1 = 0x1
	// Position of OFFEN field.
	ENET_ATCR_OFFEN_Pos = 0x2
	// Bit mask of OFFEN field.
	ENET_ATCR_OFFEN_Msk = 0x4
	// Bit OFFEN.
	ENET_ATCR_OFFEN = 0x4
	// Disable.
	ENET_ATCR_OFFEN_0 = 0x0
	// The timer can be reset to zero when the given offset time is reached (offset event). The field is cleared when the offset event is reached, so no further event occurs until the field is set again. The timer offset value must be set before setting this field.
	ENET_ATCR_OFFEN_1 = 0x1
	// Position of OFFRST field.
	ENET_ATCR_OFFRST_Pos = 0x3
	// Bit mask of OFFRST field.
	ENET_ATCR_OFFRST_Msk = 0x8
	// Bit OFFRST.
	ENET_ATCR_OFFRST = 0x8
	// The timer is not affected and no action occurs, besides clearing OFFEN, when the offset is reached.
	ENET_ATCR_OFFRST_0 = 0x0
	// If OFFEN is set, the timer resets to zero when the offset setting is reached. The offset event does not cause a timer interrupt.
	ENET_ATCR_OFFRST_1 = 0x1
	// Position of PEREN field.
	ENET_ATCR_PEREN_Pos = 0x4
	// Bit mask of PEREN field.
	ENET_ATCR_PEREN_Msk = 0x10
	// Bit PEREN.
	ENET_ATCR_PEREN = 0x10
	// Disable.
	ENET_ATCR_PEREN_0 = 0x0
	// A period event interrupt can be generated (EIR[TS_TIMER]) and the event signal output is asserted when the timer wraps around according to the periodic setting ATPER. The timer period value must be set before setting this bit. Not all devices contain the event signal output. See the chip configuration details.
	ENET_ATCR_PEREN_1 = 0x1
	// Position of PINPER field.
	ENET_ATCR_PINPER_Pos = 0x7
	// Bit mask of PINPER field.
	ENET_ATCR_PINPER_Msk = 0x80
	// Bit PINPER.
	ENET_ATCR_PINPER = 0x80
	// Disable.
	ENET_ATCR_PINPER_0 = 0x0
	// Enable.
	ENET_ATCR_PINPER_1 = 0x1
	// Position of RESTART field.
	ENET_ATCR_RESTART_Pos = 0x9
	// Bit mask of RESTART field.
	ENET_ATCR_RESTART_Msk = 0x200
	// Bit RESTART.
	ENET_ATCR_RESTART = 0x200
	// Position of CAPTURE field.
	ENET_ATCR_CAPTURE_Pos = 0xb
	// Bit mask of CAPTURE field.
	ENET_ATCR_CAPTURE_Msk = 0x800
	// Bit CAPTURE.
	ENET_ATCR_CAPTURE = 0x800
	// No effect.
	ENET_ATCR_CAPTURE_0 = 0x0
	// The current time is captured and can be read from the ATVR register.
	ENET_ATCR_CAPTURE_1 = 0x1
	// Position of SLAVE field.
	ENET_ATCR_SLAVE_Pos = 0xd
	// Bit mask of SLAVE field.
	ENET_ATCR_SLAVE_Msk = 0x2000
	// Bit SLAVE.
	ENET_ATCR_SLAVE = 0x2000
	// The timer is active and all configuration fields in this register are relevant.
	ENET_ATCR_SLAVE_0 = 0x0
	// The internal timer is disabled and the externally provided timer value is used. All other fields, except CAPTURE, in this register have no effect. CAPTURE can still be used to capture the current timer value.
	ENET_ATCR_SLAVE_1 = 0x1

	// ATVR: Timer Value Register
	// Position of ATIME field.
	ENET_ATVR_ATIME_Pos = 0x0
	// Bit mask of ATIME field.
	ENET_ATVR_ATIME_Msk = 0xffffffff

	// ATOFF: Timer Offset Register
	// Position of OFFSET field.
	ENET_ATOFF_OFFSET_Pos = 0x0
	// Bit mask of OFFSET field.
	ENET_ATOFF_OFFSET_Msk = 0xffffffff

	// ATPER: Timer Period Register
	// Position of PERIOD field.
	ENET_ATPER_PERIOD_Pos = 0x0
	// Bit mask of PERIOD field.
	ENET_ATPER_PERIOD_Msk = 0xffffffff

	// ATCOR: Timer Correction Register
	// Position of COR field.
	ENET_ATCOR_COR_Pos = 0x0
	// Bit mask of COR field.
	ENET_ATCOR_COR_Msk = 0x7fffffff

	// ATINC: Time-Stamping Clock Period Register
	// Position of INC field.
	ENET_ATINC_INC_Pos = 0x0
	// Bit mask of INC field.
	ENET_ATINC_INC_Msk = 0x7f
	// Position of INC_CORR field.
	ENET_ATINC_INC_CORR_Pos = 0x8
	// Bit mask of INC_CORR field.
	ENET_ATINC_INC_CORR_Msk = 0x7f00

	// ATSTMP: Timestamp of Last Transmitted Frame
	// Position of TIMESTAMP field.
	ENET_ATSTMP_TIMESTAMP_Pos = 0x0
	// Bit mask of TIMESTAMP field.
	ENET_ATSTMP_TIMESTAMP_Msk = 0xffffffff

	// TGSR: Timer Global Status Register
	// Position of TF0 field.
	ENET_TGSR_TF0_Pos = 0x0
	// Bit mask of TF0 field.
	ENET_TGSR_TF0_Msk = 0x1
	// Bit TF0.
	ENET_TGSR_TF0 = 0x1
	// Timer Flag for Channel 0 is clear
	ENET_TGSR_TF0_0 = 0x0
	// Timer Flag for Channel 0 is set
	ENET_TGSR_TF0_1 = 0x1
	// Position of TF1 field.
	ENET_TGSR_TF1_Pos = 0x1
	// Bit mask of TF1 field.
	ENET_TGSR_TF1_Msk = 0x2
	// Bit TF1.
	ENET_TGSR_TF1 = 0x2
	// Timer Flag for Channel 1 is clear
	ENET_TGSR_TF1_0 = 0x0
	// Timer Flag for Channel 1 is set
	ENET_TGSR_TF1_1 = 0x1
	// Position of TF2 field.
	ENET_TGSR_TF2_Pos = 0x2
	// Bit mask of TF2 field.
	ENET_TGSR_TF2_Msk = 0x4
	// Bit TF2.
	ENET_TGSR_TF2 = 0x4
	// Timer Flag for Channel 2 is clear
	ENET_TGSR_TF2_0 = 0x0
	// Timer Flag for Channel 2 is set
	ENET_TGSR_TF2_1 = 0x1
	// Position of TF3 field.
	ENET_TGSR_TF3_Pos = 0x3
	// Bit mask of TF3 field.
	ENET_TGSR_TF3_Msk = 0x8
	// Bit TF3.
	ENET_TGSR_TF3 = 0x8
	// Timer Flag for Channel 3 is clear
	ENET_TGSR_TF3_0 = 0x0
	// Timer Flag for Channel 3 is set
	ENET_TGSR_TF3_1 = 0x1

	// TCSR0: Timer Control Status Register
	// Position of TDRE field.
	ENET_TCSR_TDRE_Pos = 0x0
	// Bit mask of TDRE field.
	ENET_TCSR_TDRE_Msk = 0x1
	// Bit TDRE.
	ENET_TCSR_TDRE = 0x1
	// DMA request is disabled
	ENET_TCSR_TDRE_0 = 0x0
	// DMA request is enabled
	ENET_TCSR_TDRE_1 = 0x1
	// Position of TMODE field.
	ENET_TCSR_TMODE_Pos = 0x2
	// Bit mask of TMODE field.
	ENET_TCSR_TMODE_Msk = 0x3c
	// Timer Channel is disabled.
	ENET_TCSR_TMODE_0000 = 0x0
	// Timer Channel is configured for Input Capture on rising edge.
	ENET_TCSR_TMODE_0001 = 0x1
	// Timer Channel is configured for Input Capture on falling edge.
	ENET_TCSR_TMODE_0010 = 0x2
	// Timer Channel is configured for Input Capture on both edges.
	ENET_TCSR_TMODE_0011 = 0x3
	// Timer Channel is configured for Output Compare - software only.
	ENET_TCSR_TMODE_0100 = 0x4
	// Timer Channel is configured for Output Compare - toggle output on compare.
	ENET_TCSR_TMODE_0101 = 0x5
	// Timer Channel is configured for Output Compare - clear output on compare.
	ENET_TCSR_TMODE_0110 = 0x6
	// Timer Channel is configured for Output Compare - set output on compare.
	ENET_TCSR_TMODE_0111 = 0x7
	// Timer Channel is configured for Output Compare - clear output on compare, set output on overflow.
	ENET_TCSR_TMODE_1010 = 0xa
	// Timer Channel is configured for Output Compare - pulse output low on compare for one 1588-clock cycle.
	ENET_TCSR_TMODE_1110 = 0xe
	// Timer Channel is configured for Output Compare - pulse output high on compare for one 1588-clock cycle.
	ENET_TCSR_TMODE_1111 = 0xf
	// Position of TIE field.
	ENET_TCSR_TIE_Pos = 0x6
	// Bit mask of TIE field.
	ENET_TCSR_TIE_Msk = 0x40
	// Bit TIE.
	ENET_TCSR_TIE = 0x40
	// Interrupt is disabled
	ENET_TCSR_TIE_0 = 0x0
	// Interrupt is enabled
	ENET_TCSR_TIE_1 = 0x1
	// Position of TF field.
	ENET_TCSR_TF_Pos = 0x7
	// Bit mask of TF field.
	ENET_TCSR_TF_Msk = 0x80
	// Bit TF.
	ENET_TCSR_TF = 0x80
	// Input Capture or Output Compare has not occurred.
	ENET_TCSR_TF_0 = 0x0
	// Input Capture or Output Compare has occurred.
	ENET_TCSR_TF_1 = 0x1

	// TCCR0: Timer Compare Capture Register
	// Position of TCC field.
	ENET_TCCR_TCC_Pos = 0x0
	// Bit mask of TCC field.
	ENET_TCCR_TCC_Msk = 0xffffffff
)

// Constants for LPUART0: Universal Asynchronous Receiver/Transmitter
const (
	// BAUD: LPUART Baud Rate Register
	// Position of SBR field.
	LPUART0_BAUD_SBR_Pos = 0x0
	// Bit mask of SBR field.
	LPUART0_BAUD_SBR_Msk = 0x1fff
	// Position of SBNS field.
	LPUART0_BAUD_SBNS_Pos = 0xd
	// Bit mask of SBNS field.
	LPUART0_BAUD_SBNS_Msk = 0x2000
	// Bit SBNS.
	LPUART0_BAUD_SBNS = 0x2000
	// One stop bit.
	LPUART0_BAUD_SBNS_0 = 0x0
	// Two stop bits.
	LPUART0_BAUD_SBNS_1 = 0x1
	// Position of RXEDGIE field.
	LPUART0_BAUD_RXEDGIE_Pos = 0xe
	// Bit mask of RXEDGIE field.
	LPUART0_BAUD_RXEDGIE_Msk = 0x4000
	// Bit RXEDGIE.
	LPUART0_BAUD_RXEDGIE = 0x4000
	// Hardware interrupts from LPUART_STAT[RXEDGIF] disabled (use polling).
	LPUART0_BAUD_RXEDGIE_0 = 0x0
	// Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag is 1.
	LPUART0_BAUD_RXEDGIE_1 = 0x1
	// Position of LBKDIE field.
	LPUART0_BAUD_LBKDIE_Pos = 0xf
	// Bit mask of LBKDIE field.
	LPUART0_BAUD_LBKDIE_Msk = 0x8000
	// Bit LBKDIE.
	LPUART0_BAUD_LBKDIE = 0x8000
	// Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use polling).
	LPUART0_BAUD_LBKDIE_0 = 0x0
	// Hardware interrupt requested when LPUART_STAT[LBKDIF] flag is 1.
	LPUART0_BAUD_LBKDIE_1 = 0x1
	// Position of RESYNCDIS field.
	LPUART0_BAUD_RESYNCDIS_Pos = 0x10
	// Bit mask of RESYNCDIS field.
	LPUART0_BAUD_RESYNCDIS_Msk = 0x10000
	// Bit RESYNCDIS.
	LPUART0_BAUD_RESYNCDIS = 0x10000
	// Resynchronization during received data word is supported
	LPUART0_BAUD_RESYNCDIS_0 = 0x0
	// Resynchronization during received data word is disabled
	LPUART0_BAUD_RESYNCDIS_1 = 0x1
	// Position of BOTHEDGE field.
	LPUART0_BAUD_BOTHEDGE_Pos = 0x11
	// Bit mask of BOTHEDGE field.
	LPUART0_BAUD_BOTHEDGE_Msk = 0x20000
	// Bit BOTHEDGE.
	LPUART0_BAUD_BOTHEDGE = 0x20000
	// Receiver samples input data using the rising edge of the baud rate clock.
	LPUART0_BAUD_BOTHEDGE_0 = 0x0
	// Receiver samples input data using the rising and falling edge of the baud rate clock.
	LPUART0_BAUD_BOTHEDGE_1 = 0x1
	// Position of MATCFG field.
	LPUART0_BAUD_MATCFG_Pos = 0x12
	// Bit mask of MATCFG field.
	LPUART0_BAUD_MATCFG_Msk = 0xc0000
	// Address Match Wakeup
	LPUART0_BAUD_MATCFG_00 = 0x0
	// Idle Match Wakeup
	LPUART0_BAUD_MATCFG_01 = 0x1
	// Match On and Match Off
	LPUART0_BAUD_MATCFG_10 = 0x2
	// Enables RWU on Data Match and Match On/Off for transmitter CTS input
	LPUART0_BAUD_MATCFG_11 = 0x3
	// Position of RDMAE field.
	LPUART0_BAUD_RDMAE_Pos = 0x15
	// Bit mask of RDMAE field.
	LPUART0_BAUD_RDMAE_Msk = 0x200000
	// Bit RDMAE.
	LPUART0_BAUD_RDMAE = 0x200000
	// DMA request disabled.
	LPUART0_BAUD_RDMAE_0 = 0x0
	// DMA request enabled.
	LPUART0_BAUD_RDMAE_1 = 0x1
	// Position of TDMAE field.
	LPUART0_BAUD_TDMAE_Pos = 0x17
	// Bit mask of TDMAE field.
	LPUART0_BAUD_TDMAE_Msk = 0x800000
	// Bit TDMAE.
	LPUART0_BAUD_TDMAE = 0x800000
	// DMA request disabled.
	LPUART0_BAUD_TDMAE_0 = 0x0
	// DMA request enabled.
	LPUART0_BAUD_TDMAE_1 = 0x1
	// Position of OSR field.
	LPUART0_BAUD_OSR_Pos = 0x18
	// Bit mask of OSR field.
	LPUART0_BAUD_OSR_Msk = 0x1f000000
	// Position of M10 field.
	LPUART0_BAUD_M10_Pos = 0x1d
	// Bit mask of M10 field.
	LPUART0_BAUD_M10_Msk = 0x20000000
	// Bit M10.
	LPUART0_BAUD_M10 = 0x20000000
	// Receiver and transmitter use 8-bit or 9-bit data characters.
	LPUART0_BAUD_M10_0 = 0x0
	// Receiver and transmitter use 10-bit data characters.
	LPUART0_BAUD_M10_1 = 0x1
	// Position of MAEN2 field.
	LPUART0_BAUD_MAEN2_Pos = 0x1e
	// Bit mask of MAEN2 field.
	LPUART0_BAUD_MAEN2_Msk = 0x40000000
	// Bit MAEN2.
	LPUART0_BAUD_MAEN2 = 0x40000000
	// Normal operation.
	LPUART0_BAUD_MAEN2_0 = 0x0
	// Enables automatic address matching or data matching mode for MATCH[MA2].
	LPUART0_BAUD_MAEN2_1 = 0x1
	// Position of MAEN1 field.
	LPUART0_BAUD_MAEN1_Pos = 0x1f
	// Bit mask of MAEN1 field.
	LPUART0_BAUD_MAEN1_Msk = 0x80000000
	// Bit MAEN1.
	LPUART0_BAUD_MAEN1 = 0x80000000
	// Normal operation.
	LPUART0_BAUD_MAEN1_0 = 0x0
	// Enables automatic address matching or data matching mode for MATCH[MA1].
	LPUART0_BAUD_MAEN1_1 = 0x1

	// STAT: LPUART Status Register
	// Position of MA2F field.
	LPUART0_STAT_MA2F_Pos = 0xe
	// Bit mask of MA2F field.
	LPUART0_STAT_MA2F_Msk = 0x4000
	// Bit MA2F.
	LPUART0_STAT_MA2F = 0x4000
	// Received data is not equal to MA2
	LPUART0_STAT_MA2F_0 = 0x0
	// Received data is equal to MA2
	LPUART0_STAT_MA2F_1 = 0x1
	// Position of MA1F field.
	LPUART0_STAT_MA1F_Pos = 0xf
	// Bit mask of MA1F field.
	LPUART0_STAT_MA1F_Msk = 0x8000
	// Bit MA1F.
	LPUART0_STAT_MA1F = 0x8000
	// Received data is not equal to MA1
	LPUART0_STAT_MA1F_0 = 0x0
	// Received data is equal to MA1
	LPUART0_STAT_MA1F_1 = 0x1
	// Position of PF field.
	LPUART0_STAT_PF_Pos = 0x10
	// Bit mask of PF field.
	LPUART0_STAT_PF_Msk = 0x10000
	// Bit PF.
	LPUART0_STAT_PF = 0x10000
	// No parity error.
	LPUART0_STAT_PF_0 = 0x0
	// Parity error.
	LPUART0_STAT_PF_1 = 0x1
	// Position of FE field.
	LPUART0_STAT_FE_Pos = 0x11
	// Bit mask of FE field.
	LPUART0_STAT_FE_Msk = 0x20000
	// Bit FE.
	LPUART0_STAT_FE = 0x20000
	// No framing error detected. This does not guarantee the framing is correct.
	LPUART0_STAT_FE_0 = 0x0
	// Framing error.
	LPUART0_STAT_FE_1 = 0x1
	// Position of NF field.
	LPUART0_STAT_NF_Pos = 0x12
	// Bit mask of NF field.
	LPUART0_STAT_NF_Msk = 0x40000
	// Bit NF.
	LPUART0_STAT_NF = 0x40000
	// No noise detected.
	LPUART0_STAT_NF_0 = 0x0
	// Noise detected in the received character in LPUART_DATA.
	LPUART0_STAT_NF_1 = 0x1
	// Position of OR field.
	LPUART0_STAT_OR_Pos = 0x13
	// Bit mask of OR field.
	LPUART0_STAT_OR_Msk = 0x80000
	// Bit OR.
	LPUART0_STAT_OR = 0x80000
	// No overrun.
	LPUART0_STAT_OR_0 = 0x0
	// Receive overrun (new LPUART data lost).
	LPUART0_STAT_OR_1 = 0x1
	// Position of IDLE field.
	LPUART0_STAT_IDLE_Pos = 0x14
	// Bit mask of IDLE field.
	LPUART0_STAT_IDLE_Msk = 0x100000
	// Bit IDLE.
	LPUART0_STAT_IDLE = 0x100000
	// No idle line detected.
	LPUART0_STAT_IDLE_0 = 0x0
	// Idle line was detected.
	LPUART0_STAT_IDLE_1 = 0x1
	// Position of RDRF field.
	LPUART0_STAT_RDRF_Pos = 0x15
	// Bit mask of RDRF field.
	LPUART0_STAT_RDRF_Msk = 0x200000
	// Bit RDRF.
	LPUART0_STAT_RDRF = 0x200000
	// Receive data buffer empty.
	LPUART0_STAT_RDRF_0 = 0x0
	// Receive data buffer full.
	LPUART0_STAT_RDRF_1 = 0x1
	// Position of TC field.
	LPUART0_STAT_TC_Pos = 0x16
	// Bit mask of TC field.
	LPUART0_STAT_TC_Msk = 0x400000
	// Bit TC.
	LPUART0_STAT_TC = 0x400000
	// Transmitter active (sending data, a preamble, or a break).
	LPUART0_STAT_TC_0 = 0x0
	// Transmitter idle (transmission activity complete).
	LPUART0_STAT_TC_1 = 0x1
	// Position of TDRE field.
	LPUART0_STAT_TDRE_Pos = 0x17
	// Bit mask of TDRE field.
	LPUART0_STAT_TDRE_Msk = 0x800000
	// Bit TDRE.
	LPUART0_STAT_TDRE = 0x800000
	// Transmit data buffer full.
	LPUART0_STAT_TDRE_0 = 0x0
	// Transmit data buffer empty.
	LPUART0_STAT_TDRE_1 = 0x1
	// Position of RAF field.
	LPUART0_STAT_RAF_Pos = 0x18
	// Bit mask of RAF field.
	LPUART0_STAT_RAF_Msk = 0x1000000
	// Bit RAF.
	LPUART0_STAT_RAF = 0x1000000
	// LPUART receiver idle waiting for a start bit.
	LPUART0_STAT_RAF_0 = 0x0
	// LPUART receiver active (LPUART_RX input not idle).
	LPUART0_STAT_RAF_1 = 0x1
	// Position of LBKDE field.
	LPUART0_STAT_LBKDE_Pos = 0x19
	// Bit mask of LBKDE field.
	LPUART0_STAT_LBKDE_Msk = 0x2000000
	// Bit LBKDE.
	LPUART0_STAT_LBKDE = 0x2000000
	// Break character is detected at length 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
	LPUART0_STAT_LBKDE_0 = 0x0
	// Break character is detected at length of 11 bit times (if M = 0, SBNS = 0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).
	LPUART0_STAT_LBKDE_1 = 0x1
	// Position of BRK13 field.
	LPUART0_STAT_BRK13_Pos = 0x1a
	// Bit mask of BRK13 field.
	LPUART0_STAT_BRK13_Msk = 0x4000000
	// Bit BRK13.
	LPUART0_STAT_BRK13 = 0x4000000
	// Break character is transmitted with length of 10 bit times (if M = 0, SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
	LPUART0_STAT_BRK13_0 = 0x0
	// Break character is transmitted with length of 13 bit times (if M = 0, SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1, SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).
	LPUART0_STAT_BRK13_1 = 0x1
	// Position of RWUID field.
	LPUART0_STAT_RWUID_Pos = 0x1b
	// Bit mask of RWUID field.
	LPUART0_STAT_RWUID_Msk = 0x8000000
	// Bit RWUID.
	LPUART0_STAT_RWUID = 0x8000000
	// During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character. During address match wakeup, the IDLE bit does not get set when an address does not match.
	LPUART0_STAT_RWUID_0 = 0x0
	// During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character. During address match wakeup, the IDLE bit does get set when an address does not match.
	LPUART0_STAT_RWUID_1 = 0x1
	// Position of RXINV field.
	LPUART0_STAT_RXINV_Pos = 0x1c
	// Bit mask of RXINV field.
	LPUART0_STAT_RXINV_Msk = 0x10000000
	// Bit RXINV.
	LPUART0_STAT_RXINV = 0x10000000
	// Receive data not inverted.
	LPUART0_STAT_RXINV_0 = 0x0
	// Receive data inverted.
	LPUART0_STAT_RXINV_1 = 0x1
	// Position of MSBF field.
	LPUART0_STAT_MSBF_Pos = 0x1d
	// Bit mask of MSBF field.
	LPUART0_STAT_MSBF_Msk = 0x20000000
	// Bit MSBF.
	LPUART0_STAT_MSBF = 0x20000000
	// LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
	LPUART0_STAT_MSBF_0 = 0x0
	// MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted following the start bit depending on the setting of CTRL[M], CTRL[PE] and BAUD[M10]. Further, the first bit received after the start bit is identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and CTRL[PE].
	LPUART0_STAT_MSBF_1 = 0x1
	// Position of RXEDGIF field.
	LPUART0_STAT_RXEDGIF_Pos = 0x1e
	// Bit mask of RXEDGIF field.
	LPUART0_STAT_RXEDGIF_Msk = 0x40000000
	// Bit RXEDGIF.
	LPUART0_STAT_RXEDGIF = 0x40000000
	// No active edge on the receive pin has occurred.
	LPUART0_STAT_RXEDGIF_0 = 0x0
	// An active edge on the receive pin has occurred.
	LPUART0_STAT_RXEDGIF_1 = 0x1
	// Position of LBKDIF field.
	LPUART0_STAT_LBKDIF_Pos = 0x1f
	// Bit mask of LBKDIF field.
	LPUART0_STAT_LBKDIF_Msk = 0x80000000
	// Bit LBKDIF.
	LPUART0_STAT_LBKDIF = 0x80000000
	// No LIN break character has been detected.
	LPUART0_STAT_LBKDIF_0 = 0x0
	// LIN break character has been detected.
	LPUART0_STAT_LBKDIF_1 = 0x1

	// CTRL: LPUART Control Register
	// Position of PT field.
	LPUART0_CTRL_PT_Pos = 0x0
	// Bit mask of PT field.
	LPUART0_CTRL_PT_Msk = 0x1
	// Bit PT.
	LPUART0_CTRL_PT = 0x1
	// Even parity.
	LPUART0_CTRL_PT_0 = 0x0
	// Odd parity.
	LPUART0_CTRL_PT_1 = 0x1
	// Position of PE field.
	LPUART0_CTRL_PE_Pos = 0x1
	// Bit mask of PE field.
	LPUART0_CTRL_PE_Msk = 0x2
	// Bit PE.
	LPUART0_CTRL_PE = 0x2
	// No hardware parity generation or checking.
	LPUART0_CTRL_PE_0 = 0x0
	// Parity enabled.
	LPUART0_CTRL_PE_1 = 0x1
	// Position of ILT field.
	LPUART0_CTRL_ILT_Pos = 0x2
	// Bit mask of ILT field.
	LPUART0_CTRL_ILT_Msk = 0x4
	// Bit ILT.
	LPUART0_CTRL_ILT = 0x4
	// Idle character bit count starts after start bit.
	LPUART0_CTRL_ILT_0 = 0x0
	// Idle character bit count starts after stop bit.
	LPUART0_CTRL_ILT_1 = 0x1
	// Position of WAKE field.
	LPUART0_CTRL_WAKE_Pos = 0x3
	// Bit mask of WAKE field.
	LPUART0_CTRL_WAKE_Msk = 0x8
	// Bit WAKE.
	LPUART0_CTRL_WAKE = 0x8
	// Configures RWU for idle-line wakeup.
	LPUART0_CTRL_WAKE_0 = 0x0
	// Configures RWU with address-mark wakeup.
	LPUART0_CTRL_WAKE_1 = 0x1
	// Position of M field.
	LPUART0_CTRL_M_Pos = 0x4
	// Bit mask of M field.
	LPUART0_CTRL_M_Msk = 0x10
	// Bit M.
	LPUART0_CTRL_M = 0x10
	// Receiver and transmitter use 8-bit data characters.
	LPUART0_CTRL_M_0 = 0x0
	// Receiver and transmitter use 9-bit data characters.
	LPUART0_CTRL_M_1 = 0x1
	// Position of RSRC field.
	LPUART0_CTRL_RSRC_Pos = 0x5
	// Bit mask of RSRC field.
	LPUART0_CTRL_RSRC_Msk = 0x20
	// Bit RSRC.
	LPUART0_CTRL_RSRC = 0x20
	// Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the LPUART does not use the LPUART_RX pin.
	LPUART0_CTRL_RSRC_0 = 0x0
	// Single-wire LPUART mode where the LPUART_TX pin is connected to the transmitter output and receiver input.
	LPUART0_CTRL_RSRC_1 = 0x1
	// Position of DOZEEN field.
	LPUART0_CTRL_DOZEEN_Pos = 0x6
	// Bit mask of DOZEEN field.
	LPUART0_CTRL_DOZEEN_Msk = 0x40
	// Bit DOZEEN.
	LPUART0_CTRL_DOZEEN = 0x40
	// LPUART is enabled in Doze mode.
	LPUART0_CTRL_DOZEEN_0 = 0x0
	// LPUART is disabled in Doze mode.
	LPUART0_CTRL_DOZEEN_1 = 0x1
	// Position of LOOPS field.
	LPUART0_CTRL_LOOPS_Pos = 0x7
	// Bit mask of LOOPS field.
	LPUART0_CTRL_LOOPS_Msk = 0x80
	// Bit LOOPS.
	LPUART0_CTRL_LOOPS = 0x80
	// Normal operation - LPUART_RX and LPUART_TX use separate pins.
	LPUART0_CTRL_LOOPS_0 = 0x0
	// Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input (see RSRC bit).
	LPUART0_CTRL_LOOPS_1 = 0x1
	// Position of IDLECFG field.
	LPUART0_CTRL_IDLECFG_Pos = 0x8
	// Bit mask of IDLECFG field.
	LPUART0_CTRL_IDLECFG_Msk = 0x700
	// 1 idle character
	LPUART0_CTRL_IDLECFG_000 = 0x0
	// 2 idle characters
	LPUART0_CTRL_IDLECFG_001 = 0x1
	// 4 idle characters
	LPUART0_CTRL_IDLECFG_010 = 0x2
	// 8 idle characters
	LPUART0_CTRL_IDLECFG_011 = 0x3
	// 16 idle characters
	LPUART0_CTRL_IDLECFG_100 = 0x4
	// 32 idle characters
	LPUART0_CTRL_IDLECFG_101 = 0x5
	// 64 idle characters
	LPUART0_CTRL_IDLECFG_110 = 0x6
	// 128 idle characters
	LPUART0_CTRL_IDLECFG_111 = 0x7
	// Position of MA2IE field.
	LPUART0_CTRL_MA2IE_Pos = 0xe
	// Bit mask of MA2IE field.
	LPUART0_CTRL_MA2IE_Msk = 0x4000
	// Bit MA2IE.
	LPUART0_CTRL_MA2IE = 0x4000
	// MA2F interrupt disabled
	LPUART0_CTRL_MA2IE_0 = 0x0
	// MA2F interrupt enabled
	LPUART0_CTRL_MA2IE_1 = 0x1
	// Position of MA1IE field.
	LPUART0_CTRL_MA1IE_Pos = 0xf
	// Bit mask of MA1IE field.
	LPUART0_CTRL_MA1IE_Msk = 0x8000
	// Bit MA1IE.
	LPUART0_CTRL_MA1IE = 0x8000
	// MA1F interrupt disabled
	LPUART0_CTRL_MA1IE_0 = 0x0
	// MA1F interrupt enabled
	LPUART0_CTRL_MA1IE_1 = 0x1
	// Position of SBK field.
	LPUART0_CTRL_SBK_Pos = 0x10
	// Bit mask of SBK field.
	LPUART0_CTRL_SBK_Msk = 0x10000
	// Bit SBK.
	LPUART0_CTRL_SBK = 0x10000
	// Normal transmitter operation.
	LPUART0_CTRL_SBK_0 = 0x0
	// Queue break character(s) to be sent.
	LPUART0_CTRL_SBK_1 = 0x1
	// Position of RWU field.
	LPUART0_CTRL_RWU_Pos = 0x11
	// Bit mask of RWU field.
	LPUART0_CTRL_RWU_Msk = 0x20000
	// Bit RWU.
	LPUART0_CTRL_RWU = 0x20000
	// Normal receiver operation.
	LPUART0_CTRL_RWU_0 = 0x0
	// LPUART receiver in standby waiting for wakeup condition.
	LPUART0_CTRL_RWU_1 = 0x1
	// Position of RE field.
	LPUART0_CTRL_RE_Pos = 0x12
	// Bit mask of RE field.
	LPUART0_CTRL_RE_Msk = 0x40000
	// Bit RE.
	LPUART0_CTRL_RE = 0x40000
	// Receiver disabled.
	LPUART0_CTRL_RE_0 = 0x0
	// Receiver enabled.
	LPUART0_CTRL_RE_1 = 0x1
	// Position of TE field.
	LPUART0_CTRL_TE_Pos = 0x13
	// Bit mask of TE field.
	LPUART0_CTRL_TE_Msk = 0x80000
	// Bit TE.
	LPUART0_CTRL_TE = 0x80000
	// Transmitter disabled.
	LPUART0_CTRL_TE_0 = 0x0
	// Transmitter enabled.
	LPUART0_CTRL_TE_1 = 0x1
	// Position of ILIE field.
	LPUART0_CTRL_ILIE_Pos = 0x14
	// Bit mask of ILIE field.
	LPUART0_CTRL_ILIE_Msk = 0x100000
	// Bit ILIE.
	LPUART0_CTRL_ILIE = 0x100000
	// Hardware interrupts from IDLE disabled; use polling.
	LPUART0_CTRL_ILIE_0 = 0x0
	// Hardware interrupt requested when IDLE flag is 1.
	LPUART0_CTRL_ILIE_1 = 0x1
	// Position of RIE field.
	LPUART0_CTRL_RIE_Pos = 0x15
	// Bit mask of RIE field.
	LPUART0_CTRL_RIE_Msk = 0x200000
	// Bit RIE.
	LPUART0_CTRL_RIE = 0x200000
	// Hardware interrupts from RDRF disabled; use polling.
	LPUART0_CTRL_RIE_0 = 0x0
	// Hardware interrupt requested when RDRF flag is 1.
	LPUART0_CTRL_RIE_1 = 0x1
	// Position of TCIE field.
	LPUART0_CTRL_TCIE_Pos = 0x16
	// Bit mask of TCIE field.
	LPUART0_CTRL_TCIE_Msk = 0x400000
	// Bit TCIE.
	LPUART0_CTRL_TCIE = 0x400000
	// Hardware interrupts from TC disabled; use polling.
	LPUART0_CTRL_TCIE_0 = 0x0
	// Hardware interrupt requested when TC flag is 1.
	LPUART0_CTRL_TCIE_1 = 0x1
	// Position of TIE field.
	LPUART0_CTRL_TIE_Pos = 0x17
	// Bit mask of TIE field.
	LPUART0_CTRL_TIE_Msk = 0x800000
	// Bit TIE.
	LPUART0_CTRL_TIE = 0x800000
	// Hardware interrupts from TDRE disabled; use polling.
	LPUART0_CTRL_TIE_0 = 0x0
	// Hardware interrupt requested when TDRE flag is 1.
	LPUART0_CTRL_TIE_1 = 0x1
	// Position of PEIE field.
	LPUART0_CTRL_PEIE_Pos = 0x18
	// Bit mask of PEIE field.
	LPUART0_CTRL_PEIE_Msk = 0x1000000
	// Bit PEIE.
	LPUART0_CTRL_PEIE = 0x1000000
	// PF interrupts disabled; use polling).
	LPUART0_CTRL_PEIE_0 = 0x0
	// Hardware interrupt requested when PF is set.
	LPUART0_CTRL_PEIE_1 = 0x1
	// Position of FEIE field.
	LPUART0_CTRL_FEIE_Pos = 0x19
	// Bit mask of FEIE field.
	LPUART0_CTRL_FEIE_Msk = 0x2000000
	// Bit FEIE.
	LPUART0_CTRL_FEIE = 0x2000000
	// FE interrupts disabled; use polling.
	LPUART0_CTRL_FEIE_0 = 0x0
	// Hardware interrupt requested when FE is set.
	LPUART0_CTRL_FEIE_1 = 0x1
	// Position of NEIE field.
	LPUART0_CTRL_NEIE_Pos = 0x1a
	// Bit mask of NEIE field.
	LPUART0_CTRL_NEIE_Msk = 0x4000000
	// Bit NEIE.
	LPUART0_CTRL_NEIE = 0x4000000
	// NF interrupts disabled; use polling.
	LPUART0_CTRL_NEIE_0 = 0x0
	// Hardware interrupt requested when NF is set.
	LPUART0_CTRL_NEIE_1 = 0x1
	// Position of ORIE field.
	LPUART0_CTRL_ORIE_Pos = 0x1b
	// Bit mask of ORIE field.
	LPUART0_CTRL_ORIE_Msk = 0x8000000
	// Bit ORIE.
	LPUART0_CTRL_ORIE = 0x8000000
	// OR interrupts disabled; use polling.
	LPUART0_CTRL_ORIE_0 = 0x0
	// Hardware interrupt requested when OR is set.
	LPUART0_CTRL_ORIE_1 = 0x1
	// Position of TXINV field.
	LPUART0_CTRL_TXINV_Pos = 0x1c
	// Bit mask of TXINV field.
	LPUART0_CTRL_TXINV_Msk = 0x10000000
	// Bit TXINV.
	LPUART0_CTRL_TXINV = 0x10000000
	// Transmit data not inverted.
	LPUART0_CTRL_TXINV_0 = 0x0
	// Transmit data inverted.
	LPUART0_CTRL_TXINV_1 = 0x1
	// Position of TXDIR field.
	LPUART0_CTRL_TXDIR_Pos = 0x1d
	// Bit mask of TXDIR field.
	LPUART0_CTRL_TXDIR_Msk = 0x20000000
	// Bit TXDIR.
	LPUART0_CTRL_TXDIR = 0x20000000
	// LPUART_TX pin is an input in single-wire mode.
	LPUART0_CTRL_TXDIR_0 = 0x0
	// LPUART_TX pin is an output in single-wire mode.
	LPUART0_CTRL_TXDIR_1 = 0x1
	// Position of R9T8 field.
	LPUART0_CTRL_R9T8_Pos = 0x1e
	// Bit mask of R9T8 field.
	LPUART0_CTRL_R9T8_Msk = 0x40000000
	// Bit R9T8.
	LPUART0_CTRL_R9T8 = 0x40000000
	// Position of R8T9 field.
	LPUART0_CTRL_R8T9_Pos = 0x1f
	// Bit mask of R8T9 field.
	LPUART0_CTRL_R8T9_Msk = 0x80000000
	// Bit R8T9.
	LPUART0_CTRL_R8T9 = 0x80000000

	// DATA: LPUART Data Register
	// Position of R0T0 field.
	LPUART0_DATA_R0T0_Pos = 0x0
	// Bit mask of R0T0 field.
	LPUART0_DATA_R0T0_Msk = 0x1
	// Bit R0T0.
	LPUART0_DATA_R0T0 = 0x1
	// Position of R1T1 field.
	LPUART0_DATA_R1T1_Pos = 0x1
	// Bit mask of R1T1 field.
	LPUART0_DATA_R1T1_Msk = 0x2
	// Bit R1T1.
	LPUART0_DATA_R1T1 = 0x2
	// Position of R2T2 field.
	LPUART0_DATA_R2T2_Pos = 0x2
	// Bit mask of R2T2 field.
	LPUART0_DATA_R2T2_Msk = 0x4
	// Bit R2T2.
	LPUART0_DATA_R2T2 = 0x4
	// Position of R3T3 field.
	LPUART0_DATA_R3T3_Pos = 0x3
	// Bit mask of R3T3 field.
	LPUART0_DATA_R3T3_Msk = 0x8
	// Bit R3T3.
	LPUART0_DATA_R3T3 = 0x8
	// Position of R4T4 field.
	LPUART0_DATA_R4T4_Pos = 0x4
	// Bit mask of R4T4 field.
	LPUART0_DATA_R4T4_Msk = 0x10
	// Bit R4T4.
	LPUART0_DATA_R4T4 = 0x10
	// Position of R5T5 field.
	LPUART0_DATA_R5T5_Pos = 0x5
	// Bit mask of R5T5 field.
	LPUART0_DATA_R5T5_Msk = 0x20
	// Bit R5T5.
	LPUART0_DATA_R5T5 = 0x20
	// Position of R6T6 field.
	LPUART0_DATA_R6T6_Pos = 0x6
	// Bit mask of R6T6 field.
	LPUART0_DATA_R6T6_Msk = 0x40
	// Bit R6T6.
	LPUART0_DATA_R6T6 = 0x40
	// Position of R7T7 field.
	LPUART0_DATA_R7T7_Pos = 0x7
	// Bit mask of R7T7 field.
	LPUART0_DATA_R7T7_Msk = 0x80
	// Bit R7T7.
	LPUART0_DATA_R7T7 = 0x80
	// Position of R8T8 field.
	LPUART0_DATA_R8T8_Pos = 0x8
	// Bit mask of R8T8 field.
	LPUART0_DATA_R8T8_Msk = 0x100
	// Bit R8T8.
	LPUART0_DATA_R8T8 = 0x100
	// Position of R9T9 field.
	LPUART0_DATA_R9T9_Pos = 0x9
	// Bit mask of R9T9 field.
	LPUART0_DATA_R9T9_Msk = 0x200
	// Bit R9T9.
	LPUART0_DATA_R9T9 = 0x200
	// Position of IDLINE field.
	LPUART0_DATA_IDLINE_Pos = 0xb
	// Bit mask of IDLINE field.
	LPUART0_DATA_IDLINE_Msk = 0x800
	// Bit IDLINE.
	LPUART0_DATA_IDLINE = 0x800
	// Receiver was not idle before receiving this character.
	LPUART0_DATA_IDLINE_0 = 0x0
	// Receiver was idle before receiving this character.
	LPUART0_DATA_IDLINE_1 = 0x1
	// Position of RXEMPT field.
	LPUART0_DATA_RXEMPT_Pos = 0xc
	// Bit mask of RXEMPT field.
	LPUART0_DATA_RXEMPT_Msk = 0x1000
	// Bit RXEMPT.
	LPUART0_DATA_RXEMPT = 0x1000
	// Receive buffer contains valid data.
	LPUART0_DATA_RXEMPT_0 = 0x0
	// Receive buffer is empty, data returned on read is not valid.
	LPUART0_DATA_RXEMPT_1 = 0x1
	// Position of FRETSC field.
	LPUART0_DATA_FRETSC_Pos = 0xd
	// Bit mask of FRETSC field.
	LPUART0_DATA_FRETSC_Msk = 0x2000
	// Bit FRETSC.
	LPUART0_DATA_FRETSC = 0x2000
	// The dataword was received without a frame error on read, transmit a normal character on write.
	LPUART0_DATA_FRETSC_0 = 0x0
	// The dataword was received with a frame error, transmit an idle or break character on transmit.
	LPUART0_DATA_FRETSC_1 = 0x1
	// Position of PARITYE field.
	LPUART0_DATA_PARITYE_Pos = 0xe
	// Bit mask of PARITYE field.
	LPUART0_DATA_PARITYE_Msk = 0x4000
	// Bit PARITYE.
	LPUART0_DATA_PARITYE = 0x4000
	// The dataword was received without a parity error.
	LPUART0_DATA_PARITYE_0 = 0x0
	// The dataword was received with a parity error.
	LPUART0_DATA_PARITYE_1 = 0x1
	// Position of NOISY field.
	LPUART0_DATA_NOISY_Pos = 0xf
	// Bit mask of NOISY field.
	LPUART0_DATA_NOISY_Msk = 0x8000
	// Bit NOISY.
	LPUART0_DATA_NOISY = 0x8000
	// The dataword was received without noise.
	LPUART0_DATA_NOISY_0 = 0x0
	// The data was received with noise.
	LPUART0_DATA_NOISY_1 = 0x1

	// MATCH: LPUART Match Address Register
	// Position of MA1 field.
	LPUART0_MATCH_MA1_Pos = 0x0
	// Bit mask of MA1 field.
	LPUART0_MATCH_MA1_Msk = 0x3ff
	// Position of MA2 field.
	LPUART0_MATCH_MA2_Pos = 0x10
	// Bit mask of MA2 field.
	LPUART0_MATCH_MA2_Msk = 0x3ff0000

	// MODIR: LPUART Modem IrDA Register
	// Position of TXCTSE field.
	LPUART0_MODIR_TXCTSE_Pos = 0x0
	// Bit mask of TXCTSE field.
	LPUART0_MODIR_TXCTSE_Msk = 0x1
	// Bit TXCTSE.
	LPUART0_MODIR_TXCTSE = 0x1
	// CTS has no effect on the transmitter.
	LPUART0_MODIR_TXCTSE_0 = 0x0
	// Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.
	LPUART0_MODIR_TXCTSE_1 = 0x1
	// Position of TXRTSE field.
	LPUART0_MODIR_TXRTSE_Pos = 0x1
	// Bit mask of TXRTSE field.
	LPUART0_MODIR_TXRTSE_Msk = 0x2
	// Bit TXRTSE.
	LPUART0_MODIR_TXRTSE = 0x2
	// The transmitter has no effect on RTS.
	LPUART0_MODIR_TXRTSE_0 = 0x0
	// When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit.
	LPUART0_MODIR_TXRTSE_1 = 0x1
	// Position of TXRTSPOL field.
	LPUART0_MODIR_TXRTSPOL_Pos = 0x2
	// Bit mask of TXRTSPOL field.
	LPUART0_MODIR_TXRTSPOL_Msk = 0x4
	// Bit TXRTSPOL.
	LPUART0_MODIR_TXRTSPOL = 0x4
	// Transmitter RTS is active low.
	LPUART0_MODIR_TXRTSPOL_0 = 0x0
	// Transmitter RTS is active high.
	LPUART0_MODIR_TXRTSPOL_1 = 0x1
	// Position of RXRTSE field.
	LPUART0_MODIR_RXRTSE_Pos = 0x3
	// Bit mask of RXRTSE field.
	LPUART0_MODIR_RXRTSE_Msk = 0x8
	// Bit RXRTSE.
	LPUART0_MODIR_RXRTSE = 0x8
	// The receiver has no effect on RTS.
	LPUART0_MODIR_RXRTSE_0 = 0x0
	// RTS is deasserted if the receiver data register is full or a start bit has been detected that would cause the receiver data register to become full. RTS is asserted if the receiver data register is not full and has not detected a start bit that would cause the receiver data register to become full.
	LPUART0_MODIR_RXRTSE_1 = 0x1
	// Position of TXCTSC field.
	LPUART0_MODIR_TXCTSC_Pos = 0x4
	// Bit mask of TXCTSC field.
	LPUART0_MODIR_TXCTSC_Msk = 0x10
	// Bit TXCTSC.
	LPUART0_MODIR_TXCTSC = 0x10
	// CTS input is sampled at the start of each character.
	LPUART0_MODIR_TXCTSC_0 = 0x0
	// CTS input is sampled when the transmitter is idle.
	LPUART0_MODIR_TXCTSC_1 = 0x1
	// Position of TXCTSSRC field.
	LPUART0_MODIR_TXCTSSRC_Pos = 0x5
	// Bit mask of TXCTSSRC field.
	LPUART0_MODIR_TXCTSSRC_Msk = 0x20
	// Bit TXCTSSRC.
	LPUART0_MODIR_TXCTSSRC = 0x20
	// CTS input is the LPUART_CTS pin.
	LPUART0_MODIR_TXCTSSRC_0 = 0x0
	// CTS input is the inverted Receiver Match result.
	LPUART0_MODIR_TXCTSSRC_1 = 0x1
	// Position of TNP field.
	LPUART0_MODIR_TNP_Pos = 0x10
	// Bit mask of TNP field.
	LPUART0_MODIR_TNP_Msk = 0x30000
	// 1/OSR.
	LPUART0_MODIR_TNP_00 = 0x0
	// 2/OSR.
	LPUART0_MODIR_TNP_01 = 0x1
	// 3/OSR.
	LPUART0_MODIR_TNP_10 = 0x2
	// 4/OSR.
	LPUART0_MODIR_TNP_11 = 0x3
	// Position of IREN field.
	LPUART0_MODIR_IREN_Pos = 0x12
	// Bit mask of IREN field.
	LPUART0_MODIR_IREN_Msk = 0x40000
	// Bit IREN.
	LPUART0_MODIR_IREN = 0x40000
	// IR disabled.
	LPUART0_MODIR_IREN_0 = 0x0
	// IR enabled.
	LPUART0_MODIR_IREN_1 = 0x1
)

// Constants for TPM1: Timer/PWM Module
const (
	// SC: Status and Control
	// Position of PS field.
	TPM_SC_PS_Pos = 0x0
	// Bit mask of PS field.
	TPM_SC_PS_Msk = 0x7
	// Divide by 1
	TPM_SC_PS_000 = 0x0
	// Divide by 2
	TPM_SC_PS_001 = 0x1
	// Divide by 4
	TPM_SC_PS_010 = 0x2
	// Divide by 8
	TPM_SC_PS_011 = 0x3
	// Divide by 16
	TPM_SC_PS_100 = 0x4
	// Divide by 32
	TPM_SC_PS_101 = 0x5
	// Divide by 64
	TPM_SC_PS_110 = 0x6
	// Divide by 128
	TPM_SC_PS_111 = 0x7
	// Position of CMOD field.
	TPM_SC_CMOD_Pos = 0x3
	// Bit mask of CMOD field.
	TPM_SC_CMOD_Msk = 0x18
	// TPM counter is disabled
	TPM_SC_CMOD_00 = 0x0
	// TPM counter increments on every TPM counter clock
	TPM_SC_CMOD_01 = 0x1
	// TPM counter increments on rising edge of TPM_EXTCLK synchronized to the TPM counter clock
	TPM_SC_CMOD_10 = 0x2
	// Position of CPWMS field.
	TPM_SC_CPWMS_Pos = 0x5
	// Bit mask of CPWMS field.
	TPM_SC_CPWMS_Msk = 0x20
	// Bit CPWMS.
	TPM_SC_CPWMS = 0x20
	// TPM counter operates in up counting mode.
	TPM_SC_CPWMS_0 = 0x0
	// TPM counter operates in up-down counting mode.
	TPM_SC_CPWMS_1 = 0x1
	// Position of TOIE field.
	TPM_SC_TOIE_Pos = 0x6
	// Bit mask of TOIE field.
	TPM_SC_TOIE_Msk = 0x40
	// Bit TOIE.
	TPM_SC_TOIE = 0x40
	// Disable TOF interrupts. Use software polling or DMA request.
	TPM_SC_TOIE_0 = 0x0
	// Enable TOF interrupts. An interrupt is generated when TOF equals one.
	TPM_SC_TOIE_1 = 0x1
	// Position of TOF field.
	TPM_SC_TOF_Pos = 0x7
	// Bit mask of TOF field.
	TPM_SC_TOF_Msk = 0x80
	// Bit TOF.
	TPM_SC_TOF = 0x80
	// TPM counter has not overflowed.
	TPM_SC_TOF_0 = 0x0
	// TPM counter has overflowed.
	TPM_SC_TOF_1 = 0x1
	// Position of DMA field.
	TPM_SC_DMA_Pos = 0x8
	// Bit mask of DMA field.
	TPM_SC_DMA_Msk = 0x100
	// Bit DMA.
	TPM_SC_DMA = 0x100
	// Disables DMA transfers.
	TPM_SC_DMA_0 = 0x0
	// Enables DMA transfers.
	TPM_SC_DMA_1 = 0x1

	// CNT: Counter
	// Position of COUNT field.
	TPM_CNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	TPM_CNT_COUNT_Msk = 0xffff

	// MOD: Modulo
	// Position of MOD field.
	TPM_MOD_MOD_Pos = 0x0
	// Bit mask of MOD field.
	TPM_MOD_MOD_Msk = 0xffff

	// C0SC: Channel (n) Status and Control
	// Position of DMA field.
	TPM_CSC_DMA_Pos = 0x0
	// Bit mask of DMA field.
	TPM_CSC_DMA_Msk = 0x1
	// Bit DMA.
	TPM_CSC_DMA = 0x1
	// Disable DMA transfers.
	TPM_CSC_DMA_0 = 0x0
	// Enable DMA transfers.
	TPM_CSC_DMA_1 = 0x1
	// Position of ELSA field.
	TPM_CSC_ELSA_Pos = 0x2
	// Bit mask of ELSA field.
	TPM_CSC_ELSA_Msk = 0x4
	// Bit ELSA.
	TPM_CSC_ELSA = 0x4
	// Position of ELSB field.
	TPM_CSC_ELSB_Pos = 0x3
	// Bit mask of ELSB field.
	TPM_CSC_ELSB_Msk = 0x8
	// Bit ELSB.
	TPM_CSC_ELSB = 0x8
	// Position of MSA field.
	TPM_CSC_MSA_Pos = 0x4
	// Bit mask of MSA field.
	TPM_CSC_MSA_Msk = 0x10
	// Bit MSA.
	TPM_CSC_MSA = 0x10
	// Position of MSB field.
	TPM_CSC_MSB_Pos = 0x5
	// Bit mask of MSB field.
	TPM_CSC_MSB_Msk = 0x20
	// Bit MSB.
	TPM_CSC_MSB = 0x20
	// Position of CHIE field.
	TPM_CSC_CHIE_Pos = 0x6
	// Bit mask of CHIE field.
	TPM_CSC_CHIE_Msk = 0x40
	// Bit CHIE.
	TPM_CSC_CHIE = 0x40
	// Disable channel interrupts.
	TPM_CSC_CHIE_0 = 0x0
	// Enable channel interrupts.
	TPM_CSC_CHIE_1 = 0x1
	// Position of CHF field.
	TPM_CSC_CHF_Pos = 0x7
	// Bit mask of CHF field.
	TPM_CSC_CHF_Msk = 0x80
	// Bit CHF.
	TPM_CSC_CHF = 0x80
	// No channel event has occurred.
	TPM_CSC_CHF_0 = 0x0
	// A channel event has occurred.
	TPM_CSC_CHF_1 = 0x1

	// C0V: Channel (n) Value
	// Position of VAL field.
	TPM_CV_VAL_Pos = 0x0
	// Bit mask of VAL field.
	TPM_CV_VAL_Msk = 0xffff

	// STATUS: Capture and Compare Status
	// Position of CH0F field.
	TPM_STATUS_CH0F_Pos = 0x0
	// Bit mask of CH0F field.
	TPM_STATUS_CH0F_Msk = 0x1
	// Bit CH0F.
	TPM_STATUS_CH0F = 0x1
	// No channel event has occurred.
	TPM_STATUS_CH0F_0 = 0x0
	// A channel event has occurred.
	TPM_STATUS_CH0F_1 = 0x1
	// Position of CH1F field.
	TPM_STATUS_CH1F_Pos = 0x1
	// Bit mask of CH1F field.
	TPM_STATUS_CH1F_Msk = 0x2
	// Bit CH1F.
	TPM_STATUS_CH1F = 0x2
	// No channel event has occurred.
	TPM_STATUS_CH1F_0 = 0x0
	// A channel event has occurred.
	TPM_STATUS_CH1F_1 = 0x1
	// Position of TOF field.
	TPM_STATUS_TOF_Pos = 0x8
	// Bit mask of TOF field.
	TPM_STATUS_TOF_Msk = 0x100
	// Bit TOF.
	TPM_STATUS_TOF = 0x100
	// TPM counter has not overflowed.
	TPM_STATUS_TOF_0 = 0x0
	// TPM counter has overflowed.
	TPM_STATUS_TOF_1 = 0x1

	// COMBINE: Combine Channel Register
	// Position of COMBINE0 field.
	TPM_COMBINE_COMBINE0_Pos = 0x0
	// Bit mask of COMBINE0 field.
	TPM_COMBINE_COMBINE0_Msk = 0x1
	// Bit COMBINE0.
	TPM_COMBINE_COMBINE0 = 0x1
	// Channels 0 and 1 are independent.
	TPM_COMBINE_COMBINE0_0 = 0x0
	// Channels 0 and 1 are combined.
	TPM_COMBINE_COMBINE0_1 = 0x1
	// Position of COMSWAP0 field.
	TPM_COMBINE_COMSWAP0_Pos = 0x1
	// Bit mask of COMSWAP0 field.
	TPM_COMBINE_COMSWAP0_Msk = 0x2
	// Bit COMSWAP0.
	TPM_COMBINE_COMSWAP0 = 0x2
	// Even channel is used for input capture and 1st compare.
	TPM_COMBINE_COMSWAP0_0 = 0x0
	// Odd channel is used for input capture and 1st compare.
	TPM_COMBINE_COMSWAP0_1 = 0x1

	// POL: Channel Polarity
	// Position of POL0 field.
	TPM_POL_POL0_Pos = 0x0
	// Bit mask of POL0 field.
	TPM_POL_POL0_Msk = 0x1
	// Bit POL0.
	TPM_POL_POL0 = 0x1
	// The channel polarity is active high.
	TPM_POL_POL0_0 = 0x0
	// The channel polarity is active low.
	TPM_POL_POL0_1 = 0x1
	// Position of POL1 field.
	TPM_POL_POL1_Pos = 0x1
	// Bit mask of POL1 field.
	TPM_POL_POL1_Msk = 0x2
	// Bit POL1.
	TPM_POL_POL1 = 0x2
	// The channel polarity is active high.
	TPM_POL_POL1_0 = 0x0
	// The channel polarity is active low.
	TPM_POL_POL1_1 = 0x1

	// FILTER: Filter Control
	// Position of CH0FVAL field.
	TPM_FILTER_CH0FVAL_Pos = 0x0
	// Bit mask of CH0FVAL field.
	TPM_FILTER_CH0FVAL_Msk = 0xf
	// Position of CH1FVAL field.
	TPM_FILTER_CH1FVAL_Pos = 0x4
	// Bit mask of CH1FVAL field.
	TPM_FILTER_CH1FVAL_Msk = 0xf0

	// QDCTRL: Quadrature Decoder Control and Status
	// Position of QUADEN field.
	TPM_QDCTRL_QUADEN_Pos = 0x0
	// Bit mask of QUADEN field.
	TPM_QDCTRL_QUADEN_Msk = 0x1
	// Bit QUADEN.
	TPM_QDCTRL_QUADEN = 0x1
	// Quadrature decoder mode is disabled.
	TPM_QDCTRL_QUADEN_0 = 0x0
	// Quadrature decoder mode is enabled.
	TPM_QDCTRL_QUADEN_1 = 0x1
	// Position of TOFDIR field.
	TPM_QDCTRL_TOFDIR_Pos = 0x1
	// Bit mask of TOFDIR field.
	TPM_QDCTRL_TOFDIR_Msk = 0x2
	// Bit TOFDIR.
	TPM_QDCTRL_TOFDIR = 0x2
	// TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (zero) to its maximum value (MOD register).
	TPM_QDCTRL_TOFDIR_0 = 0x0
	// TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (zero).
	TPM_QDCTRL_TOFDIR_1 = 0x1
	// Position of QUADIR field.
	TPM_QDCTRL_QUADIR_Pos = 0x2
	// Bit mask of QUADIR field.
	TPM_QDCTRL_QUADIR_Msk = 0x4
	// Bit QUADIR.
	TPM_QDCTRL_QUADIR = 0x4
	// Counter direction is decreasing (counter decrement).
	TPM_QDCTRL_QUADIR_0 = 0x0
	// Counter direction is increasing (counter increment).
	TPM_QDCTRL_QUADIR_1 = 0x1
	// Position of QUADMODE field.
	TPM_QDCTRL_QUADMODE_Pos = 0x3
	// Bit mask of QUADMODE field.
	TPM_QDCTRL_QUADMODE_Msk = 0x8
	// Bit QUADMODE.
	TPM_QDCTRL_QUADMODE = 0x8
	// Phase encoding mode.
	TPM_QDCTRL_QUADMODE_0 = 0x0
	// Count and direction encoding mode.
	TPM_QDCTRL_QUADMODE_1 = 0x1

	// CONF: Configuration
	// Position of DOZEEN field.
	TPM_CONF_DOZEEN_Pos = 0x5
	// Bit mask of DOZEEN field.
	TPM_CONF_DOZEEN_Msk = 0x20
	// Bit DOZEEN.
	TPM_CONF_DOZEEN = 0x20
	// Internal TPM counter continues in Doze mode.
	TPM_CONF_DOZEEN_0 = 0x0
	// Internal TPM counter is paused and does not increment during Doze mode. Trigger inputs and input capture events are also ignored.
	TPM_CONF_DOZEEN_1 = 0x1
	// Position of DBGMODE field.
	TPM_CONF_DBGMODE_Pos = 0x6
	// Bit mask of DBGMODE field.
	TPM_CONF_DBGMODE_Msk = 0xc0
	// TPM counter is paused and does not increment during debug mode. Trigger inputs and input capture events are also ignored.
	TPM_CONF_DBGMODE_00 = 0x0
	// TPM counter continues in debug mode.
	TPM_CONF_DBGMODE_11 = 0x3
	// Position of GTBSYNC field.
	TPM_CONF_GTBSYNC_Pos = 0x8
	// Bit mask of GTBSYNC field.
	TPM_CONF_GTBSYNC_Msk = 0x100
	// Bit GTBSYNC.
	TPM_CONF_GTBSYNC = 0x100
	// Global timebase synchronization disabled.
	TPM_CONF_GTBSYNC_0 = 0x0
	// Global timebase synchronization enabled.
	TPM_CONF_GTBSYNC_1 = 0x1
	// Position of GTBEEN field.
	TPM_CONF_GTBEEN_Pos = 0x9
	// Bit mask of GTBEEN field.
	TPM_CONF_GTBEEN_Msk = 0x200
	// Bit GTBEEN.
	TPM_CONF_GTBEEN = 0x200
	// All channels use the internally generated TPM counter as their timebase
	TPM_CONF_GTBEEN_0 = 0x0
	// All channels use an externally generated global timebase as their timebase
	TPM_CONF_GTBEEN_1 = 0x1
	// Position of CSOT field.
	TPM_CONF_CSOT_Pos = 0x10
	// Bit mask of CSOT field.
	TPM_CONF_CSOT_Msk = 0x10000
	// Bit CSOT.
	TPM_CONF_CSOT = 0x10000
	// TPM counter starts to increment immediately, once it is enabled.
	TPM_CONF_CSOT_0 = 0x0
	// TPM counter only starts to increment when it a rising edge on the selected input trigger is detected, after it has been enabled or after it has stopped due to overflow.
	TPM_CONF_CSOT_1 = 0x1
	// Position of CSOO field.
	TPM_CONF_CSOO_Pos = 0x11
	// Bit mask of CSOO field.
	TPM_CONF_CSOO_Msk = 0x20000
	// Bit CSOO.
	TPM_CONF_CSOO = 0x20000
	// TPM counter continues incrementing or decrementing after overflow
	TPM_CONF_CSOO_0 = 0x0
	// TPM counter stops incrementing or decrementing after overflow.
	TPM_CONF_CSOO_1 = 0x1
	// Position of CROT field.
	TPM_CONF_CROT_Pos = 0x12
	// Bit mask of CROT field.
	TPM_CONF_CROT_Msk = 0x40000
	// Bit CROT.
	TPM_CONF_CROT = 0x40000
	// Counter is not reloaded due to a rising edge on the selected input trigger
	TPM_CONF_CROT_0 = 0x0
	// Counter is reloaded when a rising edge is detected on the selected input trigger
	TPM_CONF_CROT_1 = 0x1
	// Position of CPOT field.
	TPM_CONF_CPOT_Pos = 0x13
	// Bit mask of CPOT field.
	TPM_CONF_CPOT_Msk = 0x80000
	// Bit CPOT.
	TPM_CONF_CPOT = 0x80000
	// Position of TRGPOL field.
	TPM_CONF_TRGPOL_Pos = 0x16
	// Bit mask of TRGPOL field.
	TPM_CONF_TRGPOL_Msk = 0x400000
	// Bit TRGPOL.
	TPM_CONF_TRGPOL = 0x400000
	// Trigger is active high.
	TPM_CONF_TRGPOL_0 = 0x0
	// Trigger is active low.
	TPM_CONF_TRGPOL_1 = 0x1
	// Position of TRGSRC field.
	TPM_CONF_TRGSRC_Pos = 0x17
	// Bit mask of TRGSRC field.
	TPM_CONF_TRGSRC_Msk = 0x800000
	// Bit TRGSRC.
	TPM_CONF_TRGSRC = 0x800000
	// Trigger source selected by TRGSEL is external.
	TPM_CONF_TRGSRC_0 = 0x0
	// Trigger source selected by TRGSEL is internal (channel pin input capture).
	TPM_CONF_TRGSRC_1 = 0x1
	// Position of TRGSEL field.
	TPM_CONF_TRGSEL_Pos = 0x18
	// Bit mask of TRGSEL field.
	TPM_CONF_TRGSEL_Msk = 0xf000000
	// Channel 0 pin input capture
	TPM_CONF_TRGSEL_0001 = 0x1
	// Channel 1 pin input capture
	TPM_CONF_TRGSEL_0010 = 0x2
	// Channel 0 or Channel 1 pin input capture
	TPM_CONF_TRGSEL_0011 = 0x3
)

// Constants for DAC0: 12-Bit Digital-to-Analog Converter
const (
	// DAT0L: DAC Data Low Register
	// Position of DATA0 field.
	DAC_DATL_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	DAC_DATL_DATA0_Msk = 0xff

	// DAT0H: DAC Data High Register
	// Position of DATA1 field.
	DAC_DATH_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	DAC_DATH_DATA1_Msk = 0xf

	// SR: DAC Status Register
	// Position of DACBFRPBF field.
	DAC_SR_DACBFRPBF_Pos = 0x0
	// Bit mask of DACBFRPBF field.
	DAC_SR_DACBFRPBF_Msk = 0x1
	// Bit DACBFRPBF.
	DAC_SR_DACBFRPBF = 0x1
	// The DAC buffer read pointer is not equal to C2[DACBFUP].
	DAC_SR_DACBFRPBF_0 = 0x0
	// The DAC buffer read pointer is equal to C2[DACBFUP].
	DAC_SR_DACBFRPBF_1 = 0x1
	// Position of DACBFRPTF field.
	DAC_SR_DACBFRPTF_Pos = 0x1
	// Bit mask of DACBFRPTF field.
	DAC_SR_DACBFRPTF_Msk = 0x2
	// Bit DACBFRPTF.
	DAC_SR_DACBFRPTF = 0x2
	// The DAC buffer read pointer is not zero.
	DAC_SR_DACBFRPTF_0 = 0x0
	// The DAC buffer read pointer is zero.
	DAC_SR_DACBFRPTF_1 = 0x1
	// Position of DACBFWMF field.
	DAC_SR_DACBFWMF_Pos = 0x2
	// Bit mask of DACBFWMF field.
	DAC_SR_DACBFWMF_Msk = 0x4
	// Bit DACBFWMF.
	DAC_SR_DACBFWMF = 0x4
	// The DAC buffer read pointer has not reached the watermark level.
	DAC_SR_DACBFWMF_0 = 0x0
	// The DAC buffer read pointer has reached the watermark level.
	DAC_SR_DACBFWMF_1 = 0x1

	// C0: DAC Control Register
	// Position of DACBBIEN field.
	DAC_C0_DACBBIEN_Pos = 0x0
	// Bit mask of DACBBIEN field.
	DAC_C0_DACBBIEN_Msk = 0x1
	// Bit DACBBIEN.
	DAC_C0_DACBBIEN = 0x1
	// The DAC buffer read pointer bottom flag interrupt is disabled.
	DAC_C0_DACBBIEN_0 = 0x0
	// The DAC buffer read pointer bottom flag interrupt is enabled.
	DAC_C0_DACBBIEN_1 = 0x1
	// Position of DACBTIEN field.
	DAC_C0_DACBTIEN_Pos = 0x1
	// Bit mask of DACBTIEN field.
	DAC_C0_DACBTIEN_Msk = 0x2
	// Bit DACBTIEN.
	DAC_C0_DACBTIEN = 0x2
	// The DAC buffer read pointer top flag interrupt is disabled.
	DAC_C0_DACBTIEN_0 = 0x0
	// The DAC buffer read pointer top flag interrupt is enabled.
	DAC_C0_DACBTIEN_1 = 0x1
	// Position of DACBWIEN field.
	DAC_C0_DACBWIEN_Pos = 0x2
	// Bit mask of DACBWIEN field.
	DAC_C0_DACBWIEN_Msk = 0x4
	// Bit DACBWIEN.
	DAC_C0_DACBWIEN = 0x4
	// The DAC buffer watermark interrupt is disabled.
	DAC_C0_DACBWIEN_0 = 0x0
	// The DAC buffer watermark interrupt is enabled.
	DAC_C0_DACBWIEN_1 = 0x1
	// Position of LPEN field.
	DAC_C0_LPEN_Pos = 0x3
	// Bit mask of LPEN field.
	DAC_C0_LPEN_Msk = 0x8
	// Bit LPEN.
	DAC_C0_LPEN = 0x8
	// High-Power mode
	DAC_C0_LPEN_0 = 0x0
	// Low-Power mode
	DAC_C0_LPEN_1 = 0x1
	// Position of DACSWTRG field.
	DAC_C0_DACSWTRG_Pos = 0x4
	// Bit mask of DACSWTRG field.
	DAC_C0_DACSWTRG_Msk = 0x10
	// Bit DACSWTRG.
	DAC_C0_DACSWTRG = 0x10
	// The DAC soft trigger is not valid.
	DAC_C0_DACSWTRG_0 = 0x0
	// The DAC soft trigger is valid.
	DAC_C0_DACSWTRG_1 = 0x1
	// Position of DACTRGSEL field.
	DAC_C0_DACTRGSEL_Pos = 0x5
	// Bit mask of DACTRGSEL field.
	DAC_C0_DACTRGSEL_Msk = 0x20
	// Bit DACTRGSEL.
	DAC_C0_DACTRGSEL = 0x20
	// The DAC hardware trigger is selected.
	DAC_C0_DACTRGSEL_0 = 0x0
	// The DAC software trigger is selected.
	DAC_C0_DACTRGSEL_1 = 0x1
	// Position of DACRFS field.
	DAC_C0_DACRFS_Pos = 0x6
	// Bit mask of DACRFS field.
	DAC_C0_DACRFS_Msk = 0x40
	// Bit DACRFS.
	DAC_C0_DACRFS = 0x40
	// The DAC selects DACREF_1 as the reference voltage.
	DAC_C0_DACRFS_0 = 0x0
	// The DAC selects DACREF_2 as the reference voltage.
	DAC_C0_DACRFS_1 = 0x1
	// Position of DACEN field.
	DAC_C0_DACEN_Pos = 0x7
	// Bit mask of DACEN field.
	DAC_C0_DACEN_Msk = 0x80
	// Bit DACEN.
	DAC_C0_DACEN = 0x80
	// The DAC system is disabled.
	DAC_C0_DACEN_0 = 0x0
	// The DAC system is enabled.
	DAC_C0_DACEN_1 = 0x1

	// C1: DAC Control Register 1
	// Position of DACBFEN field.
	DAC_C1_DACBFEN_Pos = 0x0
	// Bit mask of DACBFEN field.
	DAC_C1_DACBFEN_Msk = 0x1
	// Bit DACBFEN.
	DAC_C1_DACBFEN = 0x1
	// Buffer read pointer is disabled. The converted data is always the first word of the buffer.
	DAC_C1_DACBFEN_0 = 0x0
	// Buffer read pointer is enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer.
	DAC_C1_DACBFEN_1 = 0x1
	// Position of DACBFMD field.
	DAC_C1_DACBFMD_Pos = 0x1
	// Bit mask of DACBFMD field.
	DAC_C1_DACBFMD_Msk = 0x6
	// Normal mode
	DAC_C1_DACBFMD_00 = 0x0
	// Swing mode
	DAC_C1_DACBFMD_01 = 0x1
	// One-Time Scan mode
	DAC_C1_DACBFMD_10 = 0x2
	// Position of DACBFWM field.
	DAC_C1_DACBFWM_Pos = 0x3
	// Bit mask of DACBFWM field.
	DAC_C1_DACBFWM_Msk = 0x18
	// 1 word
	DAC_C1_DACBFWM_00 = 0x0
	// 2 words
	DAC_C1_DACBFWM_01 = 0x1
	// 3 words
	DAC_C1_DACBFWM_10 = 0x2
	// 4 words
	DAC_C1_DACBFWM_11 = 0x3
	// Position of DMAEN field.
	DAC_C1_DMAEN_Pos = 0x7
	// Bit mask of DMAEN field.
	DAC_C1_DMAEN_Msk = 0x80
	// Bit DMAEN.
	DAC_C1_DMAEN = 0x80
	// DMA is disabled.
	DAC_C1_DMAEN_0 = 0x0
	// DMA is enabled. When DMA is enabled, the DMA request will be generated by original interrupts. The interrupts will not be presented on this module at the same time.
	DAC_C1_DMAEN_1 = 0x1

	// C2: DAC Control Register 2
	// Position of DACBFUP field.
	DAC_C2_DACBFUP_Pos = 0x0
	// Bit mask of DACBFUP field.
	DAC_C2_DACBFUP_Msk = 0xf
	// Position of DACBFRP field.
	DAC_C2_DACBFRP_Pos = 0x4
	// Bit mask of DACBFRP field.
	DAC_C2_DACBFRP_Msk = 0xf0
)

// Constants for GPIOA: General Purpose Input/Output
const (
	// PDOR: Port Data Output Register
	// Position of PDO0 field.
	GPIO_PDOR_PDO0_Pos = 0x0
	// Bit mask of PDO0 field.
	GPIO_PDOR_PDO0_Msk = 0x1
	// Bit PDO0.
	GPIO_PDOR_PDO0 = 0x1
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO0_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO0_1 = 0x1
	// Position of PDO1 field.
	GPIO_PDOR_PDO1_Pos = 0x1
	// Bit mask of PDO1 field.
	GPIO_PDOR_PDO1_Msk = 0x2
	// Bit PDO1.
	GPIO_PDOR_PDO1 = 0x2
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO1_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO1_1 = 0x1
	// Position of PDO2 field.
	GPIO_PDOR_PDO2_Pos = 0x2
	// Bit mask of PDO2 field.
	GPIO_PDOR_PDO2_Msk = 0x4
	// Bit PDO2.
	GPIO_PDOR_PDO2 = 0x4
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO2_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO2_1 = 0x1
	// Position of PDO3 field.
	GPIO_PDOR_PDO3_Pos = 0x3
	// Bit mask of PDO3 field.
	GPIO_PDOR_PDO3_Msk = 0x8
	// Bit PDO3.
	GPIO_PDOR_PDO3 = 0x8
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO3_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO3_1 = 0x1
	// Position of PDO4 field.
	GPIO_PDOR_PDO4_Pos = 0x4
	// Bit mask of PDO4 field.
	GPIO_PDOR_PDO4_Msk = 0x10
	// Bit PDO4.
	GPIO_PDOR_PDO4 = 0x10
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO4_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO4_1 = 0x1
	// Position of PDO5 field.
	GPIO_PDOR_PDO5_Pos = 0x5
	// Bit mask of PDO5 field.
	GPIO_PDOR_PDO5_Msk = 0x20
	// Bit PDO5.
	GPIO_PDOR_PDO5 = 0x20
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO5_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO5_1 = 0x1
	// Position of PDO6 field.
	GPIO_PDOR_PDO6_Pos = 0x6
	// Bit mask of PDO6 field.
	GPIO_PDOR_PDO6_Msk = 0x40
	// Bit PDO6.
	GPIO_PDOR_PDO6 = 0x40
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO6_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO6_1 = 0x1
	// Position of PDO7 field.
	GPIO_PDOR_PDO7_Pos = 0x7
	// Bit mask of PDO7 field.
	GPIO_PDOR_PDO7_Msk = 0x80
	// Bit PDO7.
	GPIO_PDOR_PDO7 = 0x80
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO7_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO7_1 = 0x1
	// Position of PDO8 field.
	GPIO_PDOR_PDO8_Pos = 0x8
	// Bit mask of PDO8 field.
	GPIO_PDOR_PDO8_Msk = 0x100
	// Bit PDO8.
	GPIO_PDOR_PDO8 = 0x100
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO8_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO8_1 = 0x1
	// Position of PDO9 field.
	GPIO_PDOR_PDO9_Pos = 0x9
	// Bit mask of PDO9 field.
	GPIO_PDOR_PDO9_Msk = 0x200
	// Bit PDO9.
	GPIO_PDOR_PDO9 = 0x200
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO9_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO9_1 = 0x1
	// Position of PDO10 field.
	GPIO_PDOR_PDO10_Pos = 0xa
	// Bit mask of PDO10 field.
	GPIO_PDOR_PDO10_Msk = 0x400
	// Bit PDO10.
	GPIO_PDOR_PDO10 = 0x400
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO10_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO10_1 = 0x1
	// Position of PDO11 field.
	GPIO_PDOR_PDO11_Pos = 0xb
	// Bit mask of PDO11 field.
	GPIO_PDOR_PDO11_Msk = 0x800
	// Bit PDO11.
	GPIO_PDOR_PDO11 = 0x800
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO11_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO11_1 = 0x1
	// Position of PDO12 field.
	GPIO_PDOR_PDO12_Pos = 0xc
	// Bit mask of PDO12 field.
	GPIO_PDOR_PDO12_Msk = 0x1000
	// Bit PDO12.
	GPIO_PDOR_PDO12 = 0x1000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO12_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO12_1 = 0x1
	// Position of PDO13 field.
	GPIO_PDOR_PDO13_Pos = 0xd
	// Bit mask of PDO13 field.
	GPIO_PDOR_PDO13_Msk = 0x2000
	// Bit PDO13.
	GPIO_PDOR_PDO13 = 0x2000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO13_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO13_1 = 0x1
	// Position of PDO14 field.
	GPIO_PDOR_PDO14_Pos = 0xe
	// Bit mask of PDO14 field.
	GPIO_PDOR_PDO14_Msk = 0x4000
	// Bit PDO14.
	GPIO_PDOR_PDO14 = 0x4000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO14_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO14_1 = 0x1
	// Position of PDO15 field.
	GPIO_PDOR_PDO15_Pos = 0xf
	// Bit mask of PDO15 field.
	GPIO_PDOR_PDO15_Msk = 0x8000
	// Bit PDO15.
	GPIO_PDOR_PDO15 = 0x8000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO15_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO15_1 = 0x1
	// Position of PDO16 field.
	GPIO_PDOR_PDO16_Pos = 0x10
	// Bit mask of PDO16 field.
	GPIO_PDOR_PDO16_Msk = 0x10000
	// Bit PDO16.
	GPIO_PDOR_PDO16 = 0x10000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO16_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO16_1 = 0x1
	// Position of PDO17 field.
	GPIO_PDOR_PDO17_Pos = 0x11
	// Bit mask of PDO17 field.
	GPIO_PDOR_PDO17_Msk = 0x20000
	// Bit PDO17.
	GPIO_PDOR_PDO17 = 0x20000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO17_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO17_1 = 0x1
	// Position of PDO18 field.
	GPIO_PDOR_PDO18_Pos = 0x12
	// Bit mask of PDO18 field.
	GPIO_PDOR_PDO18_Msk = 0x40000
	// Bit PDO18.
	GPIO_PDOR_PDO18 = 0x40000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO18_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO18_1 = 0x1
	// Position of PDO19 field.
	GPIO_PDOR_PDO19_Pos = 0x13
	// Bit mask of PDO19 field.
	GPIO_PDOR_PDO19_Msk = 0x80000
	// Bit PDO19.
	GPIO_PDOR_PDO19 = 0x80000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO19_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO19_1 = 0x1
	// Position of PDO20 field.
	GPIO_PDOR_PDO20_Pos = 0x14
	// Bit mask of PDO20 field.
	GPIO_PDOR_PDO20_Msk = 0x100000
	// Bit PDO20.
	GPIO_PDOR_PDO20 = 0x100000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO20_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO20_1 = 0x1
	// Position of PDO21 field.
	GPIO_PDOR_PDO21_Pos = 0x15
	// Bit mask of PDO21 field.
	GPIO_PDOR_PDO21_Msk = 0x200000
	// Bit PDO21.
	GPIO_PDOR_PDO21 = 0x200000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO21_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO21_1 = 0x1
	// Position of PDO22 field.
	GPIO_PDOR_PDO22_Pos = 0x16
	// Bit mask of PDO22 field.
	GPIO_PDOR_PDO22_Msk = 0x400000
	// Bit PDO22.
	GPIO_PDOR_PDO22 = 0x400000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO22_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO22_1 = 0x1
	// Position of PDO23 field.
	GPIO_PDOR_PDO23_Pos = 0x17
	// Bit mask of PDO23 field.
	GPIO_PDOR_PDO23_Msk = 0x800000
	// Bit PDO23.
	GPIO_PDOR_PDO23 = 0x800000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO23_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO23_1 = 0x1
	// Position of PDO24 field.
	GPIO_PDOR_PDO24_Pos = 0x18
	// Bit mask of PDO24 field.
	GPIO_PDOR_PDO24_Msk = 0x1000000
	// Bit PDO24.
	GPIO_PDOR_PDO24 = 0x1000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO24_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO24_1 = 0x1
	// Position of PDO25 field.
	GPIO_PDOR_PDO25_Pos = 0x19
	// Bit mask of PDO25 field.
	GPIO_PDOR_PDO25_Msk = 0x2000000
	// Bit PDO25.
	GPIO_PDOR_PDO25 = 0x2000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO25_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO25_1 = 0x1
	// Position of PDO26 field.
	GPIO_PDOR_PDO26_Pos = 0x1a
	// Bit mask of PDO26 field.
	GPIO_PDOR_PDO26_Msk = 0x4000000
	// Bit PDO26.
	GPIO_PDOR_PDO26 = 0x4000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO26_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO26_1 = 0x1
	// Position of PDO27 field.
	GPIO_PDOR_PDO27_Pos = 0x1b
	// Bit mask of PDO27 field.
	GPIO_PDOR_PDO27_Msk = 0x8000000
	// Bit PDO27.
	GPIO_PDOR_PDO27 = 0x8000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO27_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO27_1 = 0x1
	// Position of PDO28 field.
	GPIO_PDOR_PDO28_Pos = 0x1c
	// Bit mask of PDO28 field.
	GPIO_PDOR_PDO28_Msk = 0x10000000
	// Bit PDO28.
	GPIO_PDOR_PDO28 = 0x10000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO28_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO28_1 = 0x1
	// Position of PDO29 field.
	GPIO_PDOR_PDO29_Pos = 0x1d
	// Bit mask of PDO29 field.
	GPIO_PDOR_PDO29_Msk = 0x20000000
	// Bit PDO29.
	GPIO_PDOR_PDO29 = 0x20000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO29_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO29_1 = 0x1
	// Position of PDO30 field.
	GPIO_PDOR_PDO30_Pos = 0x1e
	// Bit mask of PDO30 field.
	GPIO_PDOR_PDO30_Msk = 0x40000000
	// Bit PDO30.
	GPIO_PDOR_PDO30 = 0x40000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO30_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO30_1 = 0x1
	// Position of PDO31 field.
	GPIO_PDOR_PDO31_Pos = 0x1f
	// Bit mask of PDO31 field.
	GPIO_PDOR_PDO31_Msk = 0x80000000
	// Bit PDO31.
	GPIO_PDOR_PDO31 = 0x80000000
	// Logic level 0 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO31_0 = 0x0
	// Logic level 1 is driven on pin, provided pin is configured for general-purpose output.
	GPIO_PDOR_PDO31_1 = 0x1

	// PSOR: Port Set Output Register
	// Position of PTSO0 field.
	GPIO_PSOR_PTSO0_Pos = 0x0
	// Bit mask of PTSO0 field.
	GPIO_PSOR_PTSO0_Msk = 0x1
	// Bit PTSO0.
	GPIO_PSOR_PTSO0 = 0x1
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO0_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO0_1 = 0x1
	// Position of PTSO1 field.
	GPIO_PSOR_PTSO1_Pos = 0x1
	// Bit mask of PTSO1 field.
	GPIO_PSOR_PTSO1_Msk = 0x2
	// Bit PTSO1.
	GPIO_PSOR_PTSO1 = 0x2
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO1_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO1_1 = 0x1
	// Position of PTSO2 field.
	GPIO_PSOR_PTSO2_Pos = 0x2
	// Bit mask of PTSO2 field.
	GPIO_PSOR_PTSO2_Msk = 0x4
	// Bit PTSO2.
	GPIO_PSOR_PTSO2 = 0x4
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO2_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO2_1 = 0x1
	// Position of PTSO3 field.
	GPIO_PSOR_PTSO3_Pos = 0x3
	// Bit mask of PTSO3 field.
	GPIO_PSOR_PTSO3_Msk = 0x8
	// Bit PTSO3.
	GPIO_PSOR_PTSO3 = 0x8
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO3_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO3_1 = 0x1
	// Position of PTSO4 field.
	GPIO_PSOR_PTSO4_Pos = 0x4
	// Bit mask of PTSO4 field.
	GPIO_PSOR_PTSO4_Msk = 0x10
	// Bit PTSO4.
	GPIO_PSOR_PTSO4 = 0x10
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO4_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO4_1 = 0x1
	// Position of PTSO5 field.
	GPIO_PSOR_PTSO5_Pos = 0x5
	// Bit mask of PTSO5 field.
	GPIO_PSOR_PTSO5_Msk = 0x20
	// Bit PTSO5.
	GPIO_PSOR_PTSO5 = 0x20
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO5_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO5_1 = 0x1
	// Position of PTSO6 field.
	GPIO_PSOR_PTSO6_Pos = 0x6
	// Bit mask of PTSO6 field.
	GPIO_PSOR_PTSO6_Msk = 0x40
	// Bit PTSO6.
	GPIO_PSOR_PTSO6 = 0x40
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO6_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO6_1 = 0x1
	// Position of PTSO7 field.
	GPIO_PSOR_PTSO7_Pos = 0x7
	// Bit mask of PTSO7 field.
	GPIO_PSOR_PTSO7_Msk = 0x80
	// Bit PTSO7.
	GPIO_PSOR_PTSO7 = 0x80
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO7_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO7_1 = 0x1
	// Position of PTSO8 field.
	GPIO_PSOR_PTSO8_Pos = 0x8
	// Bit mask of PTSO8 field.
	GPIO_PSOR_PTSO8_Msk = 0x100
	// Bit PTSO8.
	GPIO_PSOR_PTSO8 = 0x100
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO8_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO8_1 = 0x1
	// Position of PTSO9 field.
	GPIO_PSOR_PTSO9_Pos = 0x9
	// Bit mask of PTSO9 field.
	GPIO_PSOR_PTSO9_Msk = 0x200
	// Bit PTSO9.
	GPIO_PSOR_PTSO9 = 0x200
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO9_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO9_1 = 0x1
	// Position of PTSO10 field.
	GPIO_PSOR_PTSO10_Pos = 0xa
	// Bit mask of PTSO10 field.
	GPIO_PSOR_PTSO10_Msk = 0x400
	// Bit PTSO10.
	GPIO_PSOR_PTSO10 = 0x400
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO10_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO10_1 = 0x1
	// Position of PTSO11 field.
	GPIO_PSOR_PTSO11_Pos = 0xb
	// Bit mask of PTSO11 field.
	GPIO_PSOR_PTSO11_Msk = 0x800
	// Bit PTSO11.
	GPIO_PSOR_PTSO11 = 0x800
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO11_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO11_1 = 0x1
	// Position of PTSO12 field.
	GPIO_PSOR_PTSO12_Pos = 0xc
	// Bit mask of PTSO12 field.
	GPIO_PSOR_PTSO12_Msk = 0x1000
	// Bit PTSO12.
	GPIO_PSOR_PTSO12 = 0x1000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO12_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO12_1 = 0x1
	// Position of PTSO13 field.
	GPIO_PSOR_PTSO13_Pos = 0xd
	// Bit mask of PTSO13 field.
	GPIO_PSOR_PTSO13_Msk = 0x2000
	// Bit PTSO13.
	GPIO_PSOR_PTSO13 = 0x2000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO13_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO13_1 = 0x1
	// Position of PTSO14 field.
	GPIO_PSOR_PTSO14_Pos = 0xe
	// Bit mask of PTSO14 field.
	GPIO_PSOR_PTSO14_Msk = 0x4000
	// Bit PTSO14.
	GPIO_PSOR_PTSO14 = 0x4000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO14_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO14_1 = 0x1
	// Position of PTSO15 field.
	GPIO_PSOR_PTSO15_Pos = 0xf
	// Bit mask of PTSO15 field.
	GPIO_PSOR_PTSO15_Msk = 0x8000
	// Bit PTSO15.
	GPIO_PSOR_PTSO15 = 0x8000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO15_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO15_1 = 0x1
	// Position of PTSO16 field.
	GPIO_PSOR_PTSO16_Pos = 0x10
	// Bit mask of PTSO16 field.
	GPIO_PSOR_PTSO16_Msk = 0x10000
	// Bit PTSO16.
	GPIO_PSOR_PTSO16 = 0x10000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO16_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO16_1 = 0x1
	// Position of PTSO17 field.
	GPIO_PSOR_PTSO17_Pos = 0x11
	// Bit mask of PTSO17 field.
	GPIO_PSOR_PTSO17_Msk = 0x20000
	// Bit PTSO17.
	GPIO_PSOR_PTSO17 = 0x20000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO17_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO17_1 = 0x1
	// Position of PTSO18 field.
	GPIO_PSOR_PTSO18_Pos = 0x12
	// Bit mask of PTSO18 field.
	GPIO_PSOR_PTSO18_Msk = 0x40000
	// Bit PTSO18.
	GPIO_PSOR_PTSO18 = 0x40000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO18_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO18_1 = 0x1
	// Position of PTSO19 field.
	GPIO_PSOR_PTSO19_Pos = 0x13
	// Bit mask of PTSO19 field.
	GPIO_PSOR_PTSO19_Msk = 0x80000
	// Bit PTSO19.
	GPIO_PSOR_PTSO19 = 0x80000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO19_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO19_1 = 0x1
	// Position of PTSO20 field.
	GPIO_PSOR_PTSO20_Pos = 0x14
	// Bit mask of PTSO20 field.
	GPIO_PSOR_PTSO20_Msk = 0x100000
	// Bit PTSO20.
	GPIO_PSOR_PTSO20 = 0x100000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO20_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO20_1 = 0x1
	// Position of PTSO21 field.
	GPIO_PSOR_PTSO21_Pos = 0x15
	// Bit mask of PTSO21 field.
	GPIO_PSOR_PTSO21_Msk = 0x200000
	// Bit PTSO21.
	GPIO_PSOR_PTSO21 = 0x200000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO21_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO21_1 = 0x1
	// Position of PTSO22 field.
	GPIO_PSOR_PTSO22_Pos = 0x16
	// Bit mask of PTSO22 field.
	GPIO_PSOR_PTSO22_Msk = 0x400000
	// Bit PTSO22.
	GPIO_PSOR_PTSO22 = 0x400000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO22_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO22_1 = 0x1
	// Position of PTSO23 field.
	GPIO_PSOR_PTSO23_Pos = 0x17
	// Bit mask of PTSO23 field.
	GPIO_PSOR_PTSO23_Msk = 0x800000
	// Bit PTSO23.
	GPIO_PSOR_PTSO23 = 0x800000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO23_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO23_1 = 0x1
	// Position of PTSO24 field.
	GPIO_PSOR_PTSO24_Pos = 0x18
	// Bit mask of PTSO24 field.
	GPIO_PSOR_PTSO24_Msk = 0x1000000
	// Bit PTSO24.
	GPIO_PSOR_PTSO24 = 0x1000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO24_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO24_1 = 0x1
	// Position of PTSO25 field.
	GPIO_PSOR_PTSO25_Pos = 0x19
	// Bit mask of PTSO25 field.
	GPIO_PSOR_PTSO25_Msk = 0x2000000
	// Bit PTSO25.
	GPIO_PSOR_PTSO25 = 0x2000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO25_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO25_1 = 0x1
	// Position of PTSO26 field.
	GPIO_PSOR_PTSO26_Pos = 0x1a
	// Bit mask of PTSO26 field.
	GPIO_PSOR_PTSO26_Msk = 0x4000000
	// Bit PTSO26.
	GPIO_PSOR_PTSO26 = 0x4000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO26_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO26_1 = 0x1
	// Position of PTSO27 field.
	GPIO_PSOR_PTSO27_Pos = 0x1b
	// Bit mask of PTSO27 field.
	GPIO_PSOR_PTSO27_Msk = 0x8000000
	// Bit PTSO27.
	GPIO_PSOR_PTSO27 = 0x8000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO27_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO27_1 = 0x1
	// Position of PTSO28 field.
	GPIO_PSOR_PTSO28_Pos = 0x1c
	// Bit mask of PTSO28 field.
	GPIO_PSOR_PTSO28_Msk = 0x10000000
	// Bit PTSO28.
	GPIO_PSOR_PTSO28 = 0x10000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO28_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO28_1 = 0x1
	// Position of PTSO29 field.
	GPIO_PSOR_PTSO29_Pos = 0x1d
	// Bit mask of PTSO29 field.
	GPIO_PSOR_PTSO29_Msk = 0x20000000
	// Bit PTSO29.
	GPIO_PSOR_PTSO29 = 0x20000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO29_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO29_1 = 0x1
	// Position of PTSO30 field.
	GPIO_PSOR_PTSO30_Pos = 0x1e
	// Bit mask of PTSO30 field.
	GPIO_PSOR_PTSO30_Msk = 0x40000000
	// Bit PTSO30.
	GPIO_PSOR_PTSO30 = 0x40000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO30_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO30_1 = 0x1
	// Position of PTSO31 field.
	GPIO_PSOR_PTSO31_Pos = 0x1f
	// Bit mask of PTSO31 field.
	GPIO_PSOR_PTSO31_Msk = 0x80000000
	// Bit PTSO31.
	GPIO_PSOR_PTSO31 = 0x80000000
	// Corresponding bit in PDORn does not change.
	GPIO_PSOR_PTSO31_0 = 0x0
	// Corresponding bit in PDORn is set to logic 1.
	GPIO_PSOR_PTSO31_1 = 0x1

	// PCOR: Port Clear Output Register
	// Position of PTCO0 field.
	GPIO_PCOR_PTCO0_Pos = 0x0
	// Bit mask of PTCO0 field.
	GPIO_PCOR_PTCO0_Msk = 0x1
	// Bit PTCO0.
	GPIO_PCOR_PTCO0 = 0x1
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO0_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO0_1 = 0x1
	// Position of PTCO1 field.
	GPIO_PCOR_PTCO1_Pos = 0x1
	// Bit mask of PTCO1 field.
	GPIO_PCOR_PTCO1_Msk = 0x2
	// Bit PTCO1.
	GPIO_PCOR_PTCO1 = 0x2
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO1_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO1_1 = 0x1
	// Position of PTCO2 field.
	GPIO_PCOR_PTCO2_Pos = 0x2
	// Bit mask of PTCO2 field.
	GPIO_PCOR_PTCO2_Msk = 0x4
	// Bit PTCO2.
	GPIO_PCOR_PTCO2 = 0x4
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO2_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO2_1 = 0x1
	// Position of PTCO3 field.
	GPIO_PCOR_PTCO3_Pos = 0x3
	// Bit mask of PTCO3 field.
	GPIO_PCOR_PTCO3_Msk = 0x8
	// Bit PTCO3.
	GPIO_PCOR_PTCO3 = 0x8
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO3_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO3_1 = 0x1
	// Position of PTCO4 field.
	GPIO_PCOR_PTCO4_Pos = 0x4
	// Bit mask of PTCO4 field.
	GPIO_PCOR_PTCO4_Msk = 0x10
	// Bit PTCO4.
	GPIO_PCOR_PTCO4 = 0x10
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO4_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO4_1 = 0x1
	// Position of PTCO5 field.
	GPIO_PCOR_PTCO5_Pos = 0x5
	// Bit mask of PTCO5 field.
	GPIO_PCOR_PTCO5_Msk = 0x20
	// Bit PTCO5.
	GPIO_PCOR_PTCO5 = 0x20
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO5_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO5_1 = 0x1
	// Position of PTCO6 field.
	GPIO_PCOR_PTCO6_Pos = 0x6
	// Bit mask of PTCO6 field.
	GPIO_PCOR_PTCO6_Msk = 0x40
	// Bit PTCO6.
	GPIO_PCOR_PTCO6 = 0x40
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO6_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO6_1 = 0x1
	// Position of PTCO7 field.
	GPIO_PCOR_PTCO7_Pos = 0x7
	// Bit mask of PTCO7 field.
	GPIO_PCOR_PTCO7_Msk = 0x80
	// Bit PTCO7.
	GPIO_PCOR_PTCO7 = 0x80
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO7_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO7_1 = 0x1
	// Position of PTCO8 field.
	GPIO_PCOR_PTCO8_Pos = 0x8
	// Bit mask of PTCO8 field.
	GPIO_PCOR_PTCO8_Msk = 0x100
	// Bit PTCO8.
	GPIO_PCOR_PTCO8 = 0x100
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO8_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO8_1 = 0x1
	// Position of PTCO9 field.
	GPIO_PCOR_PTCO9_Pos = 0x9
	// Bit mask of PTCO9 field.
	GPIO_PCOR_PTCO9_Msk = 0x200
	// Bit PTCO9.
	GPIO_PCOR_PTCO9 = 0x200
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO9_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO9_1 = 0x1
	// Position of PTCO10 field.
	GPIO_PCOR_PTCO10_Pos = 0xa
	// Bit mask of PTCO10 field.
	GPIO_PCOR_PTCO10_Msk = 0x400
	// Bit PTCO10.
	GPIO_PCOR_PTCO10 = 0x400
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO10_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO10_1 = 0x1
	// Position of PTCO11 field.
	GPIO_PCOR_PTCO11_Pos = 0xb
	// Bit mask of PTCO11 field.
	GPIO_PCOR_PTCO11_Msk = 0x800
	// Bit PTCO11.
	GPIO_PCOR_PTCO11 = 0x800
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO11_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO11_1 = 0x1
	// Position of PTCO12 field.
	GPIO_PCOR_PTCO12_Pos = 0xc
	// Bit mask of PTCO12 field.
	GPIO_PCOR_PTCO12_Msk = 0x1000
	// Bit PTCO12.
	GPIO_PCOR_PTCO12 = 0x1000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO12_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO12_1 = 0x1
	// Position of PTCO13 field.
	GPIO_PCOR_PTCO13_Pos = 0xd
	// Bit mask of PTCO13 field.
	GPIO_PCOR_PTCO13_Msk = 0x2000
	// Bit PTCO13.
	GPIO_PCOR_PTCO13 = 0x2000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO13_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO13_1 = 0x1
	// Position of PTCO14 field.
	GPIO_PCOR_PTCO14_Pos = 0xe
	// Bit mask of PTCO14 field.
	GPIO_PCOR_PTCO14_Msk = 0x4000
	// Bit PTCO14.
	GPIO_PCOR_PTCO14 = 0x4000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO14_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO14_1 = 0x1
	// Position of PTCO15 field.
	GPIO_PCOR_PTCO15_Pos = 0xf
	// Bit mask of PTCO15 field.
	GPIO_PCOR_PTCO15_Msk = 0x8000
	// Bit PTCO15.
	GPIO_PCOR_PTCO15 = 0x8000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO15_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO15_1 = 0x1
	// Position of PTCO16 field.
	GPIO_PCOR_PTCO16_Pos = 0x10
	// Bit mask of PTCO16 field.
	GPIO_PCOR_PTCO16_Msk = 0x10000
	// Bit PTCO16.
	GPIO_PCOR_PTCO16 = 0x10000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO16_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO16_1 = 0x1
	// Position of PTCO17 field.
	GPIO_PCOR_PTCO17_Pos = 0x11
	// Bit mask of PTCO17 field.
	GPIO_PCOR_PTCO17_Msk = 0x20000
	// Bit PTCO17.
	GPIO_PCOR_PTCO17 = 0x20000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO17_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO17_1 = 0x1
	// Position of PTCO18 field.
	GPIO_PCOR_PTCO18_Pos = 0x12
	// Bit mask of PTCO18 field.
	GPIO_PCOR_PTCO18_Msk = 0x40000
	// Bit PTCO18.
	GPIO_PCOR_PTCO18 = 0x40000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO18_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO18_1 = 0x1
	// Position of PTCO19 field.
	GPIO_PCOR_PTCO19_Pos = 0x13
	// Bit mask of PTCO19 field.
	GPIO_PCOR_PTCO19_Msk = 0x80000
	// Bit PTCO19.
	GPIO_PCOR_PTCO19 = 0x80000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO19_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO19_1 = 0x1
	// Position of PTCO20 field.
	GPIO_PCOR_PTCO20_Pos = 0x14
	// Bit mask of PTCO20 field.
	GPIO_PCOR_PTCO20_Msk = 0x100000
	// Bit PTCO20.
	GPIO_PCOR_PTCO20 = 0x100000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO20_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO20_1 = 0x1
	// Position of PTCO21 field.
	GPIO_PCOR_PTCO21_Pos = 0x15
	// Bit mask of PTCO21 field.
	GPIO_PCOR_PTCO21_Msk = 0x200000
	// Bit PTCO21.
	GPIO_PCOR_PTCO21 = 0x200000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO21_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO21_1 = 0x1
	// Position of PTCO22 field.
	GPIO_PCOR_PTCO22_Pos = 0x16
	// Bit mask of PTCO22 field.
	GPIO_PCOR_PTCO22_Msk = 0x400000
	// Bit PTCO22.
	GPIO_PCOR_PTCO22 = 0x400000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO22_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO22_1 = 0x1
	// Position of PTCO23 field.
	GPIO_PCOR_PTCO23_Pos = 0x17
	// Bit mask of PTCO23 field.
	GPIO_PCOR_PTCO23_Msk = 0x800000
	// Bit PTCO23.
	GPIO_PCOR_PTCO23 = 0x800000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO23_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO23_1 = 0x1
	// Position of PTCO24 field.
	GPIO_PCOR_PTCO24_Pos = 0x18
	// Bit mask of PTCO24 field.
	GPIO_PCOR_PTCO24_Msk = 0x1000000
	// Bit PTCO24.
	GPIO_PCOR_PTCO24 = 0x1000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO24_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO24_1 = 0x1
	// Position of PTCO25 field.
	GPIO_PCOR_PTCO25_Pos = 0x19
	// Bit mask of PTCO25 field.
	GPIO_PCOR_PTCO25_Msk = 0x2000000
	// Bit PTCO25.
	GPIO_PCOR_PTCO25 = 0x2000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO25_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO25_1 = 0x1
	// Position of PTCO26 field.
	GPIO_PCOR_PTCO26_Pos = 0x1a
	// Bit mask of PTCO26 field.
	GPIO_PCOR_PTCO26_Msk = 0x4000000
	// Bit PTCO26.
	GPIO_PCOR_PTCO26 = 0x4000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO26_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO26_1 = 0x1
	// Position of PTCO27 field.
	GPIO_PCOR_PTCO27_Pos = 0x1b
	// Bit mask of PTCO27 field.
	GPIO_PCOR_PTCO27_Msk = 0x8000000
	// Bit PTCO27.
	GPIO_PCOR_PTCO27 = 0x8000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO27_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO27_1 = 0x1
	// Position of PTCO28 field.
	GPIO_PCOR_PTCO28_Pos = 0x1c
	// Bit mask of PTCO28 field.
	GPIO_PCOR_PTCO28_Msk = 0x10000000
	// Bit PTCO28.
	GPIO_PCOR_PTCO28 = 0x10000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO28_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO28_1 = 0x1
	// Position of PTCO29 field.
	GPIO_PCOR_PTCO29_Pos = 0x1d
	// Bit mask of PTCO29 field.
	GPIO_PCOR_PTCO29_Msk = 0x20000000
	// Bit PTCO29.
	GPIO_PCOR_PTCO29 = 0x20000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO29_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO29_1 = 0x1
	// Position of PTCO30 field.
	GPIO_PCOR_PTCO30_Pos = 0x1e
	// Bit mask of PTCO30 field.
	GPIO_PCOR_PTCO30_Msk = 0x40000000
	// Bit PTCO30.
	GPIO_PCOR_PTCO30 = 0x40000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO30_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO30_1 = 0x1
	// Position of PTCO31 field.
	GPIO_PCOR_PTCO31_Pos = 0x1f
	// Bit mask of PTCO31 field.
	GPIO_PCOR_PTCO31_Msk = 0x80000000
	// Bit PTCO31.
	GPIO_PCOR_PTCO31 = 0x80000000
	// Corresponding bit in PDORn does not change.
	GPIO_PCOR_PTCO31_0 = 0x0
	// Corresponding bit in PDORn is cleared to logic 0.
	GPIO_PCOR_PTCO31_1 = 0x1

	// PTOR: Port Toggle Output Register
	// Position of PTTO0 field.
	GPIO_PTOR_PTTO0_Pos = 0x0
	// Bit mask of PTTO0 field.
	GPIO_PTOR_PTTO0_Msk = 0x1
	// Bit PTTO0.
	GPIO_PTOR_PTTO0 = 0x1
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO0_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO0_1 = 0x1
	// Position of PTTO1 field.
	GPIO_PTOR_PTTO1_Pos = 0x1
	// Bit mask of PTTO1 field.
	GPIO_PTOR_PTTO1_Msk = 0x2
	// Bit PTTO1.
	GPIO_PTOR_PTTO1 = 0x2
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO1_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO1_1 = 0x1
	// Position of PTTO2 field.
	GPIO_PTOR_PTTO2_Pos = 0x2
	// Bit mask of PTTO2 field.
	GPIO_PTOR_PTTO2_Msk = 0x4
	// Bit PTTO2.
	GPIO_PTOR_PTTO2 = 0x4
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO2_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO2_1 = 0x1
	// Position of PTTO3 field.
	GPIO_PTOR_PTTO3_Pos = 0x3
	// Bit mask of PTTO3 field.
	GPIO_PTOR_PTTO3_Msk = 0x8
	// Bit PTTO3.
	GPIO_PTOR_PTTO3 = 0x8
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO3_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO3_1 = 0x1
	// Position of PTTO4 field.
	GPIO_PTOR_PTTO4_Pos = 0x4
	// Bit mask of PTTO4 field.
	GPIO_PTOR_PTTO4_Msk = 0x10
	// Bit PTTO4.
	GPIO_PTOR_PTTO4 = 0x10
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO4_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO4_1 = 0x1
	// Position of PTTO5 field.
	GPIO_PTOR_PTTO5_Pos = 0x5
	// Bit mask of PTTO5 field.
	GPIO_PTOR_PTTO5_Msk = 0x20
	// Bit PTTO5.
	GPIO_PTOR_PTTO5 = 0x20
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO5_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO5_1 = 0x1
	// Position of PTTO6 field.
	GPIO_PTOR_PTTO6_Pos = 0x6
	// Bit mask of PTTO6 field.
	GPIO_PTOR_PTTO6_Msk = 0x40
	// Bit PTTO6.
	GPIO_PTOR_PTTO6 = 0x40
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO6_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO6_1 = 0x1
	// Position of PTTO7 field.
	GPIO_PTOR_PTTO7_Pos = 0x7
	// Bit mask of PTTO7 field.
	GPIO_PTOR_PTTO7_Msk = 0x80
	// Bit PTTO7.
	GPIO_PTOR_PTTO7 = 0x80
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO7_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO7_1 = 0x1
	// Position of PTTO8 field.
	GPIO_PTOR_PTTO8_Pos = 0x8
	// Bit mask of PTTO8 field.
	GPIO_PTOR_PTTO8_Msk = 0x100
	// Bit PTTO8.
	GPIO_PTOR_PTTO8 = 0x100
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO8_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO8_1 = 0x1
	// Position of PTTO9 field.
	GPIO_PTOR_PTTO9_Pos = 0x9
	// Bit mask of PTTO9 field.
	GPIO_PTOR_PTTO9_Msk = 0x200
	// Bit PTTO9.
	GPIO_PTOR_PTTO9 = 0x200
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO9_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO9_1 = 0x1
	// Position of PTTO10 field.
	GPIO_PTOR_PTTO10_Pos = 0xa
	// Bit mask of PTTO10 field.
	GPIO_PTOR_PTTO10_Msk = 0x400
	// Bit PTTO10.
	GPIO_PTOR_PTTO10 = 0x400
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO10_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO10_1 = 0x1
	// Position of PTTO11 field.
	GPIO_PTOR_PTTO11_Pos = 0xb
	// Bit mask of PTTO11 field.
	GPIO_PTOR_PTTO11_Msk = 0x800
	// Bit PTTO11.
	GPIO_PTOR_PTTO11 = 0x800
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO11_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO11_1 = 0x1
	// Position of PTTO12 field.
	GPIO_PTOR_PTTO12_Pos = 0xc
	// Bit mask of PTTO12 field.
	GPIO_PTOR_PTTO12_Msk = 0x1000
	// Bit PTTO12.
	GPIO_PTOR_PTTO12 = 0x1000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO12_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO12_1 = 0x1
	// Position of PTTO13 field.
	GPIO_PTOR_PTTO13_Pos = 0xd
	// Bit mask of PTTO13 field.
	GPIO_PTOR_PTTO13_Msk = 0x2000
	// Bit PTTO13.
	GPIO_PTOR_PTTO13 = 0x2000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO13_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO13_1 = 0x1
	// Position of PTTO14 field.
	GPIO_PTOR_PTTO14_Pos = 0xe
	// Bit mask of PTTO14 field.
	GPIO_PTOR_PTTO14_Msk = 0x4000
	// Bit PTTO14.
	GPIO_PTOR_PTTO14 = 0x4000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO14_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO14_1 = 0x1
	// Position of PTTO15 field.
	GPIO_PTOR_PTTO15_Pos = 0xf
	// Bit mask of PTTO15 field.
	GPIO_PTOR_PTTO15_Msk = 0x8000
	// Bit PTTO15.
	GPIO_PTOR_PTTO15 = 0x8000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO15_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO15_1 = 0x1
	// Position of PTTO16 field.
	GPIO_PTOR_PTTO16_Pos = 0x10
	// Bit mask of PTTO16 field.
	GPIO_PTOR_PTTO16_Msk = 0x10000
	// Bit PTTO16.
	GPIO_PTOR_PTTO16 = 0x10000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO16_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO16_1 = 0x1
	// Position of PTTO17 field.
	GPIO_PTOR_PTTO17_Pos = 0x11
	// Bit mask of PTTO17 field.
	GPIO_PTOR_PTTO17_Msk = 0x20000
	// Bit PTTO17.
	GPIO_PTOR_PTTO17 = 0x20000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO17_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO17_1 = 0x1
	// Position of PTTO18 field.
	GPIO_PTOR_PTTO18_Pos = 0x12
	// Bit mask of PTTO18 field.
	GPIO_PTOR_PTTO18_Msk = 0x40000
	// Bit PTTO18.
	GPIO_PTOR_PTTO18 = 0x40000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO18_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO18_1 = 0x1
	// Position of PTTO19 field.
	GPIO_PTOR_PTTO19_Pos = 0x13
	// Bit mask of PTTO19 field.
	GPIO_PTOR_PTTO19_Msk = 0x80000
	// Bit PTTO19.
	GPIO_PTOR_PTTO19 = 0x80000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO19_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO19_1 = 0x1
	// Position of PTTO20 field.
	GPIO_PTOR_PTTO20_Pos = 0x14
	// Bit mask of PTTO20 field.
	GPIO_PTOR_PTTO20_Msk = 0x100000
	// Bit PTTO20.
	GPIO_PTOR_PTTO20 = 0x100000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO20_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO20_1 = 0x1
	// Position of PTTO21 field.
	GPIO_PTOR_PTTO21_Pos = 0x15
	// Bit mask of PTTO21 field.
	GPIO_PTOR_PTTO21_Msk = 0x200000
	// Bit PTTO21.
	GPIO_PTOR_PTTO21 = 0x200000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO21_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO21_1 = 0x1
	// Position of PTTO22 field.
	GPIO_PTOR_PTTO22_Pos = 0x16
	// Bit mask of PTTO22 field.
	GPIO_PTOR_PTTO22_Msk = 0x400000
	// Bit PTTO22.
	GPIO_PTOR_PTTO22 = 0x400000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO22_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO22_1 = 0x1
	// Position of PTTO23 field.
	GPIO_PTOR_PTTO23_Pos = 0x17
	// Bit mask of PTTO23 field.
	GPIO_PTOR_PTTO23_Msk = 0x800000
	// Bit PTTO23.
	GPIO_PTOR_PTTO23 = 0x800000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO23_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO23_1 = 0x1
	// Position of PTTO24 field.
	GPIO_PTOR_PTTO24_Pos = 0x18
	// Bit mask of PTTO24 field.
	GPIO_PTOR_PTTO24_Msk = 0x1000000
	// Bit PTTO24.
	GPIO_PTOR_PTTO24 = 0x1000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO24_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO24_1 = 0x1
	// Position of PTTO25 field.
	GPIO_PTOR_PTTO25_Pos = 0x19
	// Bit mask of PTTO25 field.
	GPIO_PTOR_PTTO25_Msk = 0x2000000
	// Bit PTTO25.
	GPIO_PTOR_PTTO25 = 0x2000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO25_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO25_1 = 0x1
	// Position of PTTO26 field.
	GPIO_PTOR_PTTO26_Pos = 0x1a
	// Bit mask of PTTO26 field.
	GPIO_PTOR_PTTO26_Msk = 0x4000000
	// Bit PTTO26.
	GPIO_PTOR_PTTO26 = 0x4000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO26_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO26_1 = 0x1
	// Position of PTTO27 field.
	GPIO_PTOR_PTTO27_Pos = 0x1b
	// Bit mask of PTTO27 field.
	GPIO_PTOR_PTTO27_Msk = 0x8000000
	// Bit PTTO27.
	GPIO_PTOR_PTTO27 = 0x8000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO27_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO27_1 = 0x1
	// Position of PTTO28 field.
	GPIO_PTOR_PTTO28_Pos = 0x1c
	// Bit mask of PTTO28 field.
	GPIO_PTOR_PTTO28_Msk = 0x10000000
	// Bit PTTO28.
	GPIO_PTOR_PTTO28 = 0x10000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO28_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO28_1 = 0x1
	// Position of PTTO29 field.
	GPIO_PTOR_PTTO29_Pos = 0x1d
	// Bit mask of PTTO29 field.
	GPIO_PTOR_PTTO29_Msk = 0x20000000
	// Bit PTTO29.
	GPIO_PTOR_PTTO29 = 0x20000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO29_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO29_1 = 0x1
	// Position of PTTO30 field.
	GPIO_PTOR_PTTO30_Pos = 0x1e
	// Bit mask of PTTO30 field.
	GPIO_PTOR_PTTO30_Msk = 0x40000000
	// Bit PTTO30.
	GPIO_PTOR_PTTO30 = 0x40000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO30_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO30_1 = 0x1
	// Position of PTTO31 field.
	GPIO_PTOR_PTTO31_Pos = 0x1f
	// Bit mask of PTTO31 field.
	GPIO_PTOR_PTTO31_Msk = 0x80000000
	// Bit PTTO31.
	GPIO_PTOR_PTTO31 = 0x80000000
	// Corresponding bit in PDORn does not change.
	GPIO_PTOR_PTTO31_0 = 0x0
	// Corresponding bit in PDORn is set to the inverse of its existing logic state.
	GPIO_PTOR_PTTO31_1 = 0x1

	// PDIR: Port Data Input Register
	// Position of PDI0 field.
	GPIO_PDIR_PDI0_Pos = 0x0
	// Bit mask of PDI0 field.
	GPIO_PDIR_PDI0_Msk = 0x1
	// Bit PDI0.
	GPIO_PDIR_PDI0 = 0x1
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI0_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI0_1 = 0x1
	// Position of PDI1 field.
	GPIO_PDIR_PDI1_Pos = 0x1
	// Bit mask of PDI1 field.
	GPIO_PDIR_PDI1_Msk = 0x2
	// Bit PDI1.
	GPIO_PDIR_PDI1 = 0x2
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI1_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI1_1 = 0x1
	// Position of PDI2 field.
	GPIO_PDIR_PDI2_Pos = 0x2
	// Bit mask of PDI2 field.
	GPIO_PDIR_PDI2_Msk = 0x4
	// Bit PDI2.
	GPIO_PDIR_PDI2 = 0x4
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI2_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI2_1 = 0x1
	// Position of PDI3 field.
	GPIO_PDIR_PDI3_Pos = 0x3
	// Bit mask of PDI3 field.
	GPIO_PDIR_PDI3_Msk = 0x8
	// Bit PDI3.
	GPIO_PDIR_PDI3 = 0x8
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI3_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI3_1 = 0x1
	// Position of PDI4 field.
	GPIO_PDIR_PDI4_Pos = 0x4
	// Bit mask of PDI4 field.
	GPIO_PDIR_PDI4_Msk = 0x10
	// Bit PDI4.
	GPIO_PDIR_PDI4 = 0x10
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI4_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI4_1 = 0x1
	// Position of PDI5 field.
	GPIO_PDIR_PDI5_Pos = 0x5
	// Bit mask of PDI5 field.
	GPIO_PDIR_PDI5_Msk = 0x20
	// Bit PDI5.
	GPIO_PDIR_PDI5 = 0x20
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI5_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI5_1 = 0x1
	// Position of PDI6 field.
	GPIO_PDIR_PDI6_Pos = 0x6
	// Bit mask of PDI6 field.
	GPIO_PDIR_PDI6_Msk = 0x40
	// Bit PDI6.
	GPIO_PDIR_PDI6 = 0x40
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI6_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI6_1 = 0x1
	// Position of PDI7 field.
	GPIO_PDIR_PDI7_Pos = 0x7
	// Bit mask of PDI7 field.
	GPIO_PDIR_PDI7_Msk = 0x80
	// Bit PDI7.
	GPIO_PDIR_PDI7 = 0x80
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI7_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI7_1 = 0x1
	// Position of PDI8 field.
	GPIO_PDIR_PDI8_Pos = 0x8
	// Bit mask of PDI8 field.
	GPIO_PDIR_PDI8_Msk = 0x100
	// Bit PDI8.
	GPIO_PDIR_PDI8 = 0x100
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI8_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI8_1 = 0x1
	// Position of PDI9 field.
	GPIO_PDIR_PDI9_Pos = 0x9
	// Bit mask of PDI9 field.
	GPIO_PDIR_PDI9_Msk = 0x200
	// Bit PDI9.
	GPIO_PDIR_PDI9 = 0x200
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI9_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI9_1 = 0x1
	// Position of PDI10 field.
	GPIO_PDIR_PDI10_Pos = 0xa
	// Bit mask of PDI10 field.
	GPIO_PDIR_PDI10_Msk = 0x400
	// Bit PDI10.
	GPIO_PDIR_PDI10 = 0x400
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI10_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI10_1 = 0x1
	// Position of PDI11 field.
	GPIO_PDIR_PDI11_Pos = 0xb
	// Bit mask of PDI11 field.
	GPIO_PDIR_PDI11_Msk = 0x800
	// Bit PDI11.
	GPIO_PDIR_PDI11 = 0x800
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI11_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI11_1 = 0x1
	// Position of PDI12 field.
	GPIO_PDIR_PDI12_Pos = 0xc
	// Bit mask of PDI12 field.
	GPIO_PDIR_PDI12_Msk = 0x1000
	// Bit PDI12.
	GPIO_PDIR_PDI12 = 0x1000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI12_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI12_1 = 0x1
	// Position of PDI13 field.
	GPIO_PDIR_PDI13_Pos = 0xd
	// Bit mask of PDI13 field.
	GPIO_PDIR_PDI13_Msk = 0x2000
	// Bit PDI13.
	GPIO_PDIR_PDI13 = 0x2000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI13_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI13_1 = 0x1
	// Position of PDI14 field.
	GPIO_PDIR_PDI14_Pos = 0xe
	// Bit mask of PDI14 field.
	GPIO_PDIR_PDI14_Msk = 0x4000
	// Bit PDI14.
	GPIO_PDIR_PDI14 = 0x4000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI14_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI14_1 = 0x1
	// Position of PDI15 field.
	GPIO_PDIR_PDI15_Pos = 0xf
	// Bit mask of PDI15 field.
	GPIO_PDIR_PDI15_Msk = 0x8000
	// Bit PDI15.
	GPIO_PDIR_PDI15 = 0x8000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI15_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI15_1 = 0x1
	// Position of PDI16 field.
	GPIO_PDIR_PDI16_Pos = 0x10
	// Bit mask of PDI16 field.
	GPIO_PDIR_PDI16_Msk = 0x10000
	// Bit PDI16.
	GPIO_PDIR_PDI16 = 0x10000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI16_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI16_1 = 0x1
	// Position of PDI17 field.
	GPIO_PDIR_PDI17_Pos = 0x11
	// Bit mask of PDI17 field.
	GPIO_PDIR_PDI17_Msk = 0x20000
	// Bit PDI17.
	GPIO_PDIR_PDI17 = 0x20000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI17_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI17_1 = 0x1
	// Position of PDI18 field.
	GPIO_PDIR_PDI18_Pos = 0x12
	// Bit mask of PDI18 field.
	GPIO_PDIR_PDI18_Msk = 0x40000
	// Bit PDI18.
	GPIO_PDIR_PDI18 = 0x40000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI18_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI18_1 = 0x1
	// Position of PDI19 field.
	GPIO_PDIR_PDI19_Pos = 0x13
	// Bit mask of PDI19 field.
	GPIO_PDIR_PDI19_Msk = 0x80000
	// Bit PDI19.
	GPIO_PDIR_PDI19 = 0x80000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI19_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI19_1 = 0x1
	// Position of PDI20 field.
	GPIO_PDIR_PDI20_Pos = 0x14
	// Bit mask of PDI20 field.
	GPIO_PDIR_PDI20_Msk = 0x100000
	// Bit PDI20.
	GPIO_PDIR_PDI20 = 0x100000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI20_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI20_1 = 0x1
	// Position of PDI21 field.
	GPIO_PDIR_PDI21_Pos = 0x15
	// Bit mask of PDI21 field.
	GPIO_PDIR_PDI21_Msk = 0x200000
	// Bit PDI21.
	GPIO_PDIR_PDI21 = 0x200000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI21_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI21_1 = 0x1
	// Position of PDI22 field.
	GPIO_PDIR_PDI22_Pos = 0x16
	// Bit mask of PDI22 field.
	GPIO_PDIR_PDI22_Msk = 0x400000
	// Bit PDI22.
	GPIO_PDIR_PDI22 = 0x400000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI22_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI22_1 = 0x1
	// Position of PDI23 field.
	GPIO_PDIR_PDI23_Pos = 0x17
	// Bit mask of PDI23 field.
	GPIO_PDIR_PDI23_Msk = 0x800000
	// Bit PDI23.
	GPIO_PDIR_PDI23 = 0x800000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI23_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI23_1 = 0x1
	// Position of PDI24 field.
	GPIO_PDIR_PDI24_Pos = 0x18
	// Bit mask of PDI24 field.
	GPIO_PDIR_PDI24_Msk = 0x1000000
	// Bit PDI24.
	GPIO_PDIR_PDI24 = 0x1000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI24_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI24_1 = 0x1
	// Position of PDI25 field.
	GPIO_PDIR_PDI25_Pos = 0x19
	// Bit mask of PDI25 field.
	GPIO_PDIR_PDI25_Msk = 0x2000000
	// Bit PDI25.
	GPIO_PDIR_PDI25 = 0x2000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI25_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI25_1 = 0x1
	// Position of PDI26 field.
	GPIO_PDIR_PDI26_Pos = 0x1a
	// Bit mask of PDI26 field.
	GPIO_PDIR_PDI26_Msk = 0x4000000
	// Bit PDI26.
	GPIO_PDIR_PDI26 = 0x4000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI26_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI26_1 = 0x1
	// Position of PDI27 field.
	GPIO_PDIR_PDI27_Pos = 0x1b
	// Bit mask of PDI27 field.
	GPIO_PDIR_PDI27_Msk = 0x8000000
	// Bit PDI27.
	GPIO_PDIR_PDI27 = 0x8000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI27_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI27_1 = 0x1
	// Position of PDI28 field.
	GPIO_PDIR_PDI28_Pos = 0x1c
	// Bit mask of PDI28 field.
	GPIO_PDIR_PDI28_Msk = 0x10000000
	// Bit PDI28.
	GPIO_PDIR_PDI28 = 0x10000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI28_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI28_1 = 0x1
	// Position of PDI29 field.
	GPIO_PDIR_PDI29_Pos = 0x1d
	// Bit mask of PDI29 field.
	GPIO_PDIR_PDI29_Msk = 0x20000000
	// Bit PDI29.
	GPIO_PDIR_PDI29 = 0x20000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI29_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI29_1 = 0x1
	// Position of PDI30 field.
	GPIO_PDIR_PDI30_Pos = 0x1e
	// Bit mask of PDI30 field.
	GPIO_PDIR_PDI30_Msk = 0x40000000
	// Bit PDI30.
	GPIO_PDIR_PDI30 = 0x40000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI30_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI30_1 = 0x1
	// Position of PDI31 field.
	GPIO_PDIR_PDI31_Pos = 0x1f
	// Bit mask of PDI31 field.
	GPIO_PDIR_PDI31_Msk = 0x80000000
	// Bit PDI31.
	GPIO_PDIR_PDI31 = 0x80000000
	// Pin logic level is logic 0, or is not configured for use by digital function.
	GPIO_PDIR_PDI31_0 = 0x0
	// Pin logic level is logic 1.
	GPIO_PDIR_PDI31_1 = 0x1

	// PDDR: Port Data Direction Register
	// Position of PDD0 field.
	GPIO_PDDR_PDD0_Pos = 0x0
	// Bit mask of PDD0 field.
	GPIO_PDDR_PDD0_Msk = 0x1
	// Bit PDD0.
	GPIO_PDDR_PDD0 = 0x1
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD0_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD0_1 = 0x1
	// Position of PDD1 field.
	GPIO_PDDR_PDD1_Pos = 0x1
	// Bit mask of PDD1 field.
	GPIO_PDDR_PDD1_Msk = 0x2
	// Bit PDD1.
	GPIO_PDDR_PDD1 = 0x2
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD1_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD1_1 = 0x1
	// Position of PDD2 field.
	GPIO_PDDR_PDD2_Pos = 0x2
	// Bit mask of PDD2 field.
	GPIO_PDDR_PDD2_Msk = 0x4
	// Bit PDD2.
	GPIO_PDDR_PDD2 = 0x4
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD2_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD2_1 = 0x1
	// Position of PDD3 field.
	GPIO_PDDR_PDD3_Pos = 0x3
	// Bit mask of PDD3 field.
	GPIO_PDDR_PDD3_Msk = 0x8
	// Bit PDD3.
	GPIO_PDDR_PDD3 = 0x8
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD3_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD3_1 = 0x1
	// Position of PDD4 field.
	GPIO_PDDR_PDD4_Pos = 0x4
	// Bit mask of PDD4 field.
	GPIO_PDDR_PDD4_Msk = 0x10
	// Bit PDD4.
	GPIO_PDDR_PDD4 = 0x10
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD4_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD4_1 = 0x1
	// Position of PDD5 field.
	GPIO_PDDR_PDD5_Pos = 0x5
	// Bit mask of PDD5 field.
	GPIO_PDDR_PDD5_Msk = 0x20
	// Bit PDD5.
	GPIO_PDDR_PDD5 = 0x20
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD5_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD5_1 = 0x1
	// Position of PDD6 field.
	GPIO_PDDR_PDD6_Pos = 0x6
	// Bit mask of PDD6 field.
	GPIO_PDDR_PDD6_Msk = 0x40
	// Bit PDD6.
	GPIO_PDDR_PDD6 = 0x40
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD6_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD6_1 = 0x1
	// Position of PDD7 field.
	GPIO_PDDR_PDD7_Pos = 0x7
	// Bit mask of PDD7 field.
	GPIO_PDDR_PDD7_Msk = 0x80
	// Bit PDD7.
	GPIO_PDDR_PDD7 = 0x80
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD7_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD7_1 = 0x1
	// Position of PDD8 field.
	GPIO_PDDR_PDD8_Pos = 0x8
	// Bit mask of PDD8 field.
	GPIO_PDDR_PDD8_Msk = 0x100
	// Bit PDD8.
	GPIO_PDDR_PDD8 = 0x100
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD8_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD8_1 = 0x1
	// Position of PDD9 field.
	GPIO_PDDR_PDD9_Pos = 0x9
	// Bit mask of PDD9 field.
	GPIO_PDDR_PDD9_Msk = 0x200
	// Bit PDD9.
	GPIO_PDDR_PDD9 = 0x200
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD9_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD9_1 = 0x1
	// Position of PDD10 field.
	GPIO_PDDR_PDD10_Pos = 0xa
	// Bit mask of PDD10 field.
	GPIO_PDDR_PDD10_Msk = 0x400
	// Bit PDD10.
	GPIO_PDDR_PDD10 = 0x400
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD10_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD10_1 = 0x1
	// Position of PDD11 field.
	GPIO_PDDR_PDD11_Pos = 0xb
	// Bit mask of PDD11 field.
	GPIO_PDDR_PDD11_Msk = 0x800
	// Bit PDD11.
	GPIO_PDDR_PDD11 = 0x800
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD11_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD11_1 = 0x1
	// Position of PDD12 field.
	GPIO_PDDR_PDD12_Pos = 0xc
	// Bit mask of PDD12 field.
	GPIO_PDDR_PDD12_Msk = 0x1000
	// Bit PDD12.
	GPIO_PDDR_PDD12 = 0x1000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD12_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD12_1 = 0x1
	// Position of PDD13 field.
	GPIO_PDDR_PDD13_Pos = 0xd
	// Bit mask of PDD13 field.
	GPIO_PDDR_PDD13_Msk = 0x2000
	// Bit PDD13.
	GPIO_PDDR_PDD13 = 0x2000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD13_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD13_1 = 0x1
	// Position of PDD14 field.
	GPIO_PDDR_PDD14_Pos = 0xe
	// Bit mask of PDD14 field.
	GPIO_PDDR_PDD14_Msk = 0x4000
	// Bit PDD14.
	GPIO_PDDR_PDD14 = 0x4000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD14_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD14_1 = 0x1
	// Position of PDD15 field.
	GPIO_PDDR_PDD15_Pos = 0xf
	// Bit mask of PDD15 field.
	GPIO_PDDR_PDD15_Msk = 0x8000
	// Bit PDD15.
	GPIO_PDDR_PDD15 = 0x8000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD15_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD15_1 = 0x1
	// Position of PDD16 field.
	GPIO_PDDR_PDD16_Pos = 0x10
	// Bit mask of PDD16 field.
	GPIO_PDDR_PDD16_Msk = 0x10000
	// Bit PDD16.
	GPIO_PDDR_PDD16 = 0x10000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD16_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD16_1 = 0x1
	// Position of PDD17 field.
	GPIO_PDDR_PDD17_Pos = 0x11
	// Bit mask of PDD17 field.
	GPIO_PDDR_PDD17_Msk = 0x20000
	// Bit PDD17.
	GPIO_PDDR_PDD17 = 0x20000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD17_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD17_1 = 0x1
	// Position of PDD18 field.
	GPIO_PDDR_PDD18_Pos = 0x12
	// Bit mask of PDD18 field.
	GPIO_PDDR_PDD18_Msk = 0x40000
	// Bit PDD18.
	GPIO_PDDR_PDD18 = 0x40000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD18_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD18_1 = 0x1
	// Position of PDD19 field.
	GPIO_PDDR_PDD19_Pos = 0x13
	// Bit mask of PDD19 field.
	GPIO_PDDR_PDD19_Msk = 0x80000
	// Bit PDD19.
	GPIO_PDDR_PDD19 = 0x80000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD19_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD19_1 = 0x1
	// Position of PDD20 field.
	GPIO_PDDR_PDD20_Pos = 0x14
	// Bit mask of PDD20 field.
	GPIO_PDDR_PDD20_Msk = 0x100000
	// Bit PDD20.
	GPIO_PDDR_PDD20 = 0x100000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD20_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD20_1 = 0x1
	// Position of PDD21 field.
	GPIO_PDDR_PDD21_Pos = 0x15
	// Bit mask of PDD21 field.
	GPIO_PDDR_PDD21_Msk = 0x200000
	// Bit PDD21.
	GPIO_PDDR_PDD21 = 0x200000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD21_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD21_1 = 0x1
	// Position of PDD22 field.
	GPIO_PDDR_PDD22_Pos = 0x16
	// Bit mask of PDD22 field.
	GPIO_PDDR_PDD22_Msk = 0x400000
	// Bit PDD22.
	GPIO_PDDR_PDD22 = 0x400000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD22_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD22_1 = 0x1
	// Position of PDD23 field.
	GPIO_PDDR_PDD23_Pos = 0x17
	// Bit mask of PDD23 field.
	GPIO_PDDR_PDD23_Msk = 0x800000
	// Bit PDD23.
	GPIO_PDDR_PDD23 = 0x800000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD23_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD23_1 = 0x1
	// Position of PDD24 field.
	GPIO_PDDR_PDD24_Pos = 0x18
	// Bit mask of PDD24 field.
	GPIO_PDDR_PDD24_Msk = 0x1000000
	// Bit PDD24.
	GPIO_PDDR_PDD24 = 0x1000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD24_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD24_1 = 0x1
	// Position of PDD25 field.
	GPIO_PDDR_PDD25_Pos = 0x19
	// Bit mask of PDD25 field.
	GPIO_PDDR_PDD25_Msk = 0x2000000
	// Bit PDD25.
	GPIO_PDDR_PDD25 = 0x2000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD25_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD25_1 = 0x1
	// Position of PDD26 field.
	GPIO_PDDR_PDD26_Pos = 0x1a
	// Bit mask of PDD26 field.
	GPIO_PDDR_PDD26_Msk = 0x4000000
	// Bit PDD26.
	GPIO_PDDR_PDD26 = 0x4000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD26_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD26_1 = 0x1
	// Position of PDD27 field.
	GPIO_PDDR_PDD27_Pos = 0x1b
	// Bit mask of PDD27 field.
	GPIO_PDDR_PDD27_Msk = 0x8000000
	// Bit PDD27.
	GPIO_PDDR_PDD27 = 0x8000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD27_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD27_1 = 0x1
	// Position of PDD28 field.
	GPIO_PDDR_PDD28_Pos = 0x1c
	// Bit mask of PDD28 field.
	GPIO_PDDR_PDD28_Msk = 0x10000000
	// Bit PDD28.
	GPIO_PDDR_PDD28 = 0x10000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD28_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD28_1 = 0x1
	// Position of PDD29 field.
	GPIO_PDDR_PDD29_Pos = 0x1d
	// Bit mask of PDD29 field.
	GPIO_PDDR_PDD29_Msk = 0x20000000
	// Bit PDD29.
	GPIO_PDDR_PDD29 = 0x20000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD29_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD29_1 = 0x1
	// Position of PDD30 field.
	GPIO_PDDR_PDD30_Pos = 0x1e
	// Bit mask of PDD30 field.
	GPIO_PDDR_PDD30_Msk = 0x40000000
	// Bit PDD30.
	GPIO_PDDR_PDD30 = 0x40000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD30_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD30_1 = 0x1
	// Position of PDD31 field.
	GPIO_PDDR_PDD31_Pos = 0x1f
	// Bit mask of PDD31 field.
	GPIO_PDDR_PDD31_Msk = 0x80000000
	// Bit PDD31.
	GPIO_PDDR_PDD31 = 0x80000000
	// Pin is configured as general-purpose input, for the GPIO function.
	GPIO_PDDR_PDD31_0 = 0x0
	// Pin is configured as general-purpose output, for the GPIO function.
	GPIO_PDDR_PDD31_1 = 0x1
)

// Constants for SystemControl: System Control Block
const (
	// ACTLR: Auxiliary Control Register,
	// Position of DISMCYCINT field.
	SystemControl_ACTLR_DISMCYCINT_Pos = 0x0
	// Bit mask of DISMCYCINT field.
	SystemControl_ACTLR_DISMCYCINT_Msk = 0x1
	// Bit DISMCYCINT.
	SystemControl_ACTLR_DISMCYCINT = 0x1
	// Position of DISDEFWBUF field.
	SystemControl_ACTLR_DISDEFWBUF_Pos = 0x1
	// Bit mask of DISDEFWBUF field.
	SystemControl_ACTLR_DISDEFWBUF_Msk = 0x2
	// Bit DISDEFWBUF.
	SystemControl_ACTLR_DISDEFWBUF = 0x2
	// Position of DISFOLD field.
	SystemControl_ACTLR_DISFOLD_Pos = 0x2
	// Bit mask of DISFOLD field.
	SystemControl_ACTLR_DISFOLD_Msk = 0x4
	// Bit DISFOLD.
	SystemControl_ACTLR_DISFOLD = 0x4

	// CPUID: CPUID Base Register
	// Position of REVISION field.
	SystemControl_CPUID_REVISION_Pos = 0x0
	// Bit mask of REVISION field.
	SystemControl_CPUID_REVISION_Msk = 0xf
	// Position of PARTNO field.
	SystemControl_CPUID_PARTNO_Pos = 0x4
	// Bit mask of PARTNO field.
	SystemControl_CPUID_PARTNO_Msk = 0xfff0
	// Position of VARIANT field.
	SystemControl_CPUID_VARIANT_Pos = 0x14
	// Bit mask of VARIANT field.
	SystemControl_CPUID_VARIANT_Msk = 0xf00000
	// Position of IMPLEMENTER field.
	SystemControl_CPUID_IMPLEMENTER_Pos = 0x18
	// Bit mask of IMPLEMENTER field.
	SystemControl_CPUID_IMPLEMENTER_Msk = 0xff000000

	// ICSR: Interrupt Control and State Register
	// Position of VECTACTIVE field.
	SystemControl_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SystemControl_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SystemControl_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SystemControl_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SystemControl_ICSR_RETTOBASE = 0x800
	// there are preempted active exceptions to execute
	SystemControl_ICSR_RETTOBASE_0 = 0x0
	// there are no active exceptions, or the currently-executing exception is the only active exception
	SystemControl_ICSR_RETTOBASE_1 = 0x1
	// Position of VECTPENDING field.
	SystemControl_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SystemControl_ICSR_VECTPENDING_Msk = 0x3f000
	// Position of ISRPENDING field.
	SystemControl_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SystemControl_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SystemControl_ICSR_ISRPENDING = 0x400000
	// Position of ISRPREEMPT field.
	SystemControl_ICSR_ISRPREEMPT_Pos = 0x17
	// Bit mask of ISRPREEMPT field.
	SystemControl_ICSR_ISRPREEMPT_Msk = 0x800000
	// Bit ISRPREEMPT.
	SystemControl_ICSR_ISRPREEMPT = 0x800000
	// Will not service
	SystemControl_ICSR_ISRPREEMPT_0 = 0x0
	// Will service a pending exception
	SystemControl_ICSR_ISRPREEMPT_1 = 0x1
	// Position of PENDSTCLR field.
	SystemControl_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SystemControl_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SystemControl_ICSR_PENDSTCLR = 0x2000000
	// no effect
	SystemControl_ICSR_PENDSTCLR_0 = 0x0
	// removes the pending state from the SysTick exception
	SystemControl_ICSR_PENDSTCLR_1 = 0x1
	// Position of PENDSTSET field.
	SystemControl_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SystemControl_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SystemControl_ICSR_PENDSTSET = 0x4000000
	// write: no effect; read: SysTick exception is not pending
	SystemControl_ICSR_PENDSTSET_0 = 0x0
	// write: changes SysTick exception state to pending; read: SysTick exception is pending
	SystemControl_ICSR_PENDSTSET_1 = 0x1
	// Position of PENDSVCLR field.
	SystemControl_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SystemControl_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SystemControl_ICSR_PENDSVCLR = 0x8000000
	// no effect
	SystemControl_ICSR_PENDSVCLR_0 = 0x0
	// removes the pending state from the PendSV exception
	SystemControl_ICSR_PENDSVCLR_1 = 0x1
	// Position of PENDSVSET field.
	SystemControl_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SystemControl_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SystemControl_ICSR_PENDSVSET = 0x10000000
	// write: no effect; read: PendSV exception is not pending
	SystemControl_ICSR_PENDSVSET_0 = 0x0
	// write: changes PendSV exception state to pending; read: PendSV exception is pending
	SystemControl_ICSR_PENDSVSET_1 = 0x1
	// Position of NMIPENDSET field.
	SystemControl_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SystemControl_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SystemControl_ICSR_NMIPENDSET = 0x80000000
	// write: no effect; read: NMI exception is not pending
	SystemControl_ICSR_NMIPENDSET_0 = 0x0
	// write: changes NMI exception state to pending; read: NMI exception is pending
	SystemControl_ICSR_NMIPENDSET_1 = 0x1

	// VTOR: Vector Table Offset Register
	// Position of TBLOFF field.
	SystemControl_VTOR_TBLOFF_Pos = 0x7
	// Bit mask of TBLOFF field.
	SystemControl_VTOR_TBLOFF_Msk = 0xffffff80

	// AIRCR: Application Interrupt and Reset Control Register
	// Position of VECTRESET field.
	SystemControl_AIRCR_VECTRESET_Pos = 0x0
	// Bit mask of VECTRESET field.
	SystemControl_AIRCR_VECTRESET_Msk = 0x1
	// Bit VECTRESET.
	SystemControl_AIRCR_VECTRESET = 0x1
	// Position of VECTCLRACTIVE field.
	SystemControl_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SystemControl_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SystemControl_AIRCR_VECTCLRACTIVE = 0x2
	// Position of SYSRESETREQ field.
	SystemControl_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SystemControl_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SystemControl_AIRCR_SYSRESETREQ = 0x4
	// no system reset request
	SystemControl_AIRCR_SYSRESETREQ_0 = 0x0
	// asserts a signal to the outer system that requests a reset
	SystemControl_AIRCR_SYSRESETREQ_1 = 0x1
	// Position of PRIGROUP field.
	SystemControl_AIRCR_PRIGROUP_Pos = 0x8
	// Bit mask of PRIGROUP field.
	SystemControl_AIRCR_PRIGROUP_Msk = 0x700
	// Position of ENDIANNESS field.
	SystemControl_AIRCR_ENDIANNESS_Pos = 0xf
	// Bit mask of ENDIANNESS field.
	SystemControl_AIRCR_ENDIANNESS_Msk = 0x8000
	// Bit ENDIANNESS.
	SystemControl_AIRCR_ENDIANNESS = 0x8000
	// Little-endian
	SystemControl_AIRCR_ENDIANNESS_0 = 0x0
	// Big-endian
	SystemControl_AIRCR_ENDIANNESS_1 = 0x1
	// Position of VECTKEY field.
	SystemControl_AIRCR_VECTKEY_Pos = 0x10
	// Bit mask of VECTKEY field.
	SystemControl_AIRCR_VECTKEY_Msk = 0xffff0000

	// SCR: System Control Register
	// Position of SLEEPONEXIT field.
	SystemControl_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SystemControl_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SystemControl_SCR_SLEEPONEXIT = 0x2
	// o not sleep when returning to Thread mode
	SystemControl_SCR_SLEEPONEXIT_0 = 0x0
	// enter sleep, or deep sleep, on return from an ISR
	SystemControl_SCR_SLEEPONEXIT_1 = 0x1
	// Position of SLEEPDEEP field.
	SystemControl_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SystemControl_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SystemControl_SCR_SLEEPDEEP = 0x4
	// sleep
	SystemControl_SCR_SLEEPDEEP_0 = 0x0
	// deep sleep
	SystemControl_SCR_SLEEPDEEP_1 = 0x1
	// Position of SEVONPEND field.
	SystemControl_SCR_SEVONPEND_Pos = 0x4
	// Bit mask of SEVONPEND field.
	SystemControl_SCR_SEVONPEND_Msk = 0x10
	// Bit SEVONPEND.
	SystemControl_SCR_SEVONPEND = 0x10
	// only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
	SystemControl_SCR_SEVONPEND_0 = 0x0
	// enabled events and all interrupts, including disabled interrupts, can wakeup the processor
	SystemControl_SCR_SEVONPEND_1 = 0x1

	// CCR: Configuration and Control Register
	// Position of NONBASETHRDENA field.
	SystemControl_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SystemControl_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SystemControl_CCR_NONBASETHRDENA = 0x1
	// processor can enter Thread mode only when no exception is active
	SystemControl_CCR_NONBASETHRDENA_0 = 0x0
	// processor can enter Thread mode from any level under the control of an EXC_RETURN value
	SystemControl_CCR_NONBASETHRDENA_1 = 0x1
	// Position of USERSETMPEND field.
	SystemControl_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SystemControl_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SystemControl_CCR_USERSETMPEND = 0x2
	// disable
	SystemControl_CCR_USERSETMPEND_0 = 0x0
	// enable
	SystemControl_CCR_USERSETMPEND_1 = 0x1
	// Position of UNALIGN_TRP field.
	SystemControl_CCR_UNALIGN_TRP_Pos = 0x3
	// Bit mask of UNALIGN_TRP field.
	SystemControl_CCR_UNALIGN_TRP_Msk = 0x8
	// Bit UNALIGN_TRP.
	SystemControl_CCR_UNALIGN_TRP = 0x8
	// do not trap unaligned halfword and word accesses
	SystemControl_CCR_UNALIGN_TRP_0 = 0x0
	// trap unaligned halfword and word accesses
	SystemControl_CCR_UNALIGN_TRP_1 = 0x1
	// Position of DIV_0_TRP field.
	SystemControl_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SystemControl_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SystemControl_CCR_DIV_0_TRP = 0x10
	// do not trap divide by 0
	SystemControl_CCR_DIV_0_TRP_0 = 0x0
	// trap divide by 0
	SystemControl_CCR_DIV_0_TRP_1 = 0x1
	// Position of BFHFNMIGN field.
	SystemControl_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SystemControl_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SystemControl_CCR_BFHFNMIGN = 0x100
	// data bus faults caused by load and store instructions cause a lock-up
	SystemControl_CCR_BFHFNMIGN_0 = 0x0
	// handlers running at priority -1 and -2 ignore data bus faults caused by load and store instructions
	SystemControl_CCR_BFHFNMIGN_1 = 0x1
	// Position of STKALIGN field.
	SystemControl_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SystemControl_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SystemControl_CCR_STKALIGN = 0x200
	// 4-byte aligned
	SystemControl_CCR_STKALIGN_0 = 0x0
	// 8-byte aligned
	SystemControl_CCR_STKALIGN_1 = 0x1

	// SHPR1: System Handler Priority Register 1
	// Position of PRI_4 field.
	SystemControl_SHPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	SystemControl_SHPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	SystemControl_SHPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	SystemControl_SHPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	SystemControl_SHPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	SystemControl_SHPR1_PRI_6_Msk = 0xff0000

	// SHPR2: System Handler Priority Register 2
	// Position of PRI_11 field.
	SystemControl_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SystemControl_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System Handler Priority Register 3
	// Position of PRI_14 field.
	SystemControl_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SystemControl_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SystemControl_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SystemControl_SHPR3_PRI_15_Msk = 0xff000000

	// SHCSR: System Handler Control and State Register
	// Position of MEMFAULTACT field.
	SystemControl_SHCSR_MEMFAULTACT_Pos = 0x0
	// Bit mask of MEMFAULTACT field.
	SystemControl_SHCSR_MEMFAULTACT_Msk = 0x1
	// Bit MEMFAULTACT.
	SystemControl_SHCSR_MEMFAULTACT = 0x1
	// exception is not active
	SystemControl_SHCSR_MEMFAULTACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_MEMFAULTACT_1 = 0x1
	// Position of BUSFAULTACT field.
	SystemControl_SHCSR_BUSFAULTACT_Pos = 0x1
	// Bit mask of BUSFAULTACT field.
	SystemControl_SHCSR_BUSFAULTACT_Msk = 0x2
	// Bit BUSFAULTACT.
	SystemControl_SHCSR_BUSFAULTACT = 0x2
	// exception is not active
	SystemControl_SHCSR_BUSFAULTACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_BUSFAULTACT_1 = 0x1
	// Position of USGFAULTACT field.
	SystemControl_SHCSR_USGFAULTACT_Pos = 0x3
	// Bit mask of USGFAULTACT field.
	SystemControl_SHCSR_USGFAULTACT_Msk = 0x8
	// Bit USGFAULTACT.
	SystemControl_SHCSR_USGFAULTACT = 0x8
	// exception is not active
	SystemControl_SHCSR_USGFAULTACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_USGFAULTACT_1 = 0x1
	// Position of SVCALLACT field.
	SystemControl_SHCSR_SVCALLACT_Pos = 0x7
	// Bit mask of SVCALLACT field.
	SystemControl_SHCSR_SVCALLACT_Msk = 0x80
	// Bit SVCALLACT.
	SystemControl_SHCSR_SVCALLACT = 0x80
	// exception is not active
	SystemControl_SHCSR_SVCALLACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_SVCALLACT_1 = 0x1
	// Position of MONITORACT field.
	SystemControl_SHCSR_MONITORACT_Pos = 0x8
	// Bit mask of MONITORACT field.
	SystemControl_SHCSR_MONITORACT_Msk = 0x100
	// Bit MONITORACT.
	SystemControl_SHCSR_MONITORACT = 0x100
	// exception is not active
	SystemControl_SHCSR_MONITORACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_MONITORACT_1 = 0x1
	// Position of PENDSVACT field.
	SystemControl_SHCSR_PENDSVACT_Pos = 0xa
	// Bit mask of PENDSVACT field.
	SystemControl_SHCSR_PENDSVACT_Msk = 0x400
	// Bit PENDSVACT.
	SystemControl_SHCSR_PENDSVACT = 0x400
	// exception is not active
	SystemControl_SHCSR_PENDSVACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_PENDSVACT_1 = 0x1
	// Position of SYSTICKACT field.
	SystemControl_SHCSR_SYSTICKACT_Pos = 0xb
	// Bit mask of SYSTICKACT field.
	SystemControl_SHCSR_SYSTICKACT_Msk = 0x800
	// Bit SYSTICKACT.
	SystemControl_SHCSR_SYSTICKACT = 0x800
	// exception is not active
	SystemControl_SHCSR_SYSTICKACT_0 = 0x0
	// exception is active
	SystemControl_SHCSR_SYSTICKACT_1 = 0x1
	// Position of USGFAULTPENDED field.
	SystemControl_SHCSR_USGFAULTPENDED_Pos = 0xc
	// Bit mask of USGFAULTPENDED field.
	SystemControl_SHCSR_USGFAULTPENDED_Msk = 0x1000
	// Bit USGFAULTPENDED.
	SystemControl_SHCSR_USGFAULTPENDED = 0x1000
	// exception is not pending
	SystemControl_SHCSR_USGFAULTPENDED_0 = 0x0
	// exception is pending
	SystemControl_SHCSR_USGFAULTPENDED_1 = 0x1
	// Position of MEMFAULTPENDED field.
	SystemControl_SHCSR_MEMFAULTPENDED_Pos = 0xd
	// Bit mask of MEMFAULTPENDED field.
	SystemControl_SHCSR_MEMFAULTPENDED_Msk = 0x2000
	// Bit MEMFAULTPENDED.
	SystemControl_SHCSR_MEMFAULTPENDED = 0x2000
	// exception is not pending
	SystemControl_SHCSR_MEMFAULTPENDED_0 = 0x0
	// exception is pending
	SystemControl_SHCSR_MEMFAULTPENDED_1 = 0x1
	// Position of BUSFAULTPENDED field.
	SystemControl_SHCSR_BUSFAULTPENDED_Pos = 0xe
	// Bit mask of BUSFAULTPENDED field.
	SystemControl_SHCSR_BUSFAULTPENDED_Msk = 0x4000
	// Bit BUSFAULTPENDED.
	SystemControl_SHCSR_BUSFAULTPENDED = 0x4000
	// exception is not pending
	SystemControl_SHCSR_BUSFAULTPENDED_0 = 0x0
	// exception is pending
	SystemControl_SHCSR_BUSFAULTPENDED_1 = 0x1
	// Position of SVCALLPENDED field.
	SystemControl_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	SystemControl_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	SystemControl_SHCSR_SVCALLPENDED = 0x8000
	// exception is not pending
	SystemControl_SHCSR_SVCALLPENDED_0 = 0x0
	// exception is pending
	SystemControl_SHCSR_SVCALLPENDED_1 = 0x1
	// Position of MEMFAULTENA field.
	SystemControl_SHCSR_MEMFAULTENA_Pos = 0x10
	// Bit mask of MEMFAULTENA field.
	SystemControl_SHCSR_MEMFAULTENA_Msk = 0x10000
	// Bit MEMFAULTENA.
	SystemControl_SHCSR_MEMFAULTENA = 0x10000
	// disable the exception
	SystemControl_SHCSR_MEMFAULTENA_0 = 0x0
	// enable the exception
	SystemControl_SHCSR_MEMFAULTENA_1 = 0x1
	// Position of BUSFAULTENA field.
	SystemControl_SHCSR_BUSFAULTENA_Pos = 0x11
	// Bit mask of BUSFAULTENA field.
	SystemControl_SHCSR_BUSFAULTENA_Msk = 0x20000
	// Bit BUSFAULTENA.
	SystemControl_SHCSR_BUSFAULTENA = 0x20000
	// disable the exception
	SystemControl_SHCSR_BUSFAULTENA_0 = 0x0
	// enable the exception
	SystemControl_SHCSR_BUSFAULTENA_1 = 0x1
	// Position of USGFAULTENA field.
	SystemControl_SHCSR_USGFAULTENA_Pos = 0x12
	// Bit mask of USGFAULTENA field.
	SystemControl_SHCSR_USGFAULTENA_Msk = 0x40000
	// Bit USGFAULTENA.
	SystemControl_SHCSR_USGFAULTENA = 0x40000
	// disable the exception
	SystemControl_SHCSR_USGFAULTENA_0 = 0x0
	// enable the exception
	SystemControl_SHCSR_USGFAULTENA_1 = 0x1

	// CFSR: Configurable Fault Status Registers
	// Position of IACCVIOL field.
	SystemControl_CFSR_IACCVIOL_Pos = 0x0
	// Bit mask of IACCVIOL field.
	SystemControl_CFSR_IACCVIOL_Msk = 0x1
	// Bit IACCVIOL.
	SystemControl_CFSR_IACCVIOL = 0x1
	// no instruction access violation fault
	SystemControl_CFSR_IACCVIOL_0 = 0x0
	// the processor attempted an instruction fetch from a location that does not permit execution
	SystemControl_CFSR_IACCVIOL_1 = 0x1
	// Position of DACCVIOL field.
	SystemControl_CFSR_DACCVIOL_Pos = 0x1
	// Bit mask of DACCVIOL field.
	SystemControl_CFSR_DACCVIOL_Msk = 0x2
	// Bit DACCVIOL.
	SystemControl_CFSR_DACCVIOL = 0x2
	// no data access violation fault
	SystemControl_CFSR_DACCVIOL_0 = 0x0
	// the processor attempted a load or store at a location that does not permit the operation
	SystemControl_CFSR_DACCVIOL_1 = 0x1
	// Position of MUNSTKERR field.
	SystemControl_CFSR_MUNSTKERR_Pos = 0x3
	// Bit mask of MUNSTKERR field.
	SystemControl_CFSR_MUNSTKERR_Msk = 0x8
	// Bit MUNSTKERR.
	SystemControl_CFSR_MUNSTKERR = 0x8
	// no unstacking fault
	SystemControl_CFSR_MUNSTKERR_0 = 0x0
	// unstack for an exception return has caused one or more access violations
	SystemControl_CFSR_MUNSTKERR_1 = 0x1
	// Position of MSTKERR field.
	SystemControl_CFSR_MSTKERR_Pos = 0x4
	// Bit mask of MSTKERR field.
	SystemControl_CFSR_MSTKERR_Msk = 0x10
	// Bit MSTKERR.
	SystemControl_CFSR_MSTKERR = 0x10
	// no stacking fault
	SystemControl_CFSR_MSTKERR_0 = 0x0
	// stacking for an exception entry has caused one or more access violations
	SystemControl_CFSR_MSTKERR_1 = 0x1
	// Position of MLSPERR field.
	SystemControl_CFSR_MLSPERR_Pos = 0x5
	// Bit mask of MLSPERR field.
	SystemControl_CFSR_MLSPERR_Msk = 0x20
	// Bit MLSPERR.
	SystemControl_CFSR_MLSPERR = 0x20
	// No MemManage fault occurred during floating-point lazy state preservation
	SystemControl_CFSR_MLSPERR_0 = 0x0
	// A MemManage fault occurred during floating-point lazy state preservation
	SystemControl_CFSR_MLSPERR_1 = 0x1
	// Position of MMARVALID field.
	SystemControl_CFSR_MMARVALID_Pos = 0x7
	// Bit mask of MMARVALID field.
	SystemControl_CFSR_MMARVALID_Msk = 0x80
	// Bit MMARVALID.
	SystemControl_CFSR_MMARVALID = 0x80
	// value in MMAR is not a valid fault address
	SystemControl_CFSR_MMARVALID_0 = 0x0
	// MMAR holds a valid fault address
	SystemControl_CFSR_MMARVALID_1 = 0x1
	// Position of IBUSERR field.
	SystemControl_CFSR_IBUSERR_Pos = 0x8
	// Bit mask of IBUSERR field.
	SystemControl_CFSR_IBUSERR_Msk = 0x100
	// Bit IBUSERR.
	SystemControl_CFSR_IBUSERR = 0x100
	// no instruction bus error
	SystemControl_CFSR_IBUSERR_0 = 0x0
	// instruction bus error
	SystemControl_CFSR_IBUSERR_1 = 0x1
	// Position of PRECISERR field.
	SystemControl_CFSR_PRECISERR_Pos = 0x9
	// Bit mask of PRECISERR field.
	SystemControl_CFSR_PRECISERR_Msk = 0x200
	// Bit PRECISERR.
	SystemControl_CFSR_PRECISERR = 0x200
	// no precise data bus error
	SystemControl_CFSR_PRECISERR_0 = 0x0
	// a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault
	SystemControl_CFSR_PRECISERR_1 = 0x1
	// Position of IMPRECISERR field.
	SystemControl_CFSR_IMPRECISERR_Pos = 0xa
	// Bit mask of IMPRECISERR field.
	SystemControl_CFSR_IMPRECISERR_Msk = 0x400
	// Bit IMPRECISERR.
	SystemControl_CFSR_IMPRECISERR = 0x400
	// no imprecise data bus error
	SystemControl_CFSR_IMPRECISERR_0 = 0x0
	// a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error
	SystemControl_CFSR_IMPRECISERR_1 = 0x1
	// Position of UNSTKERR field.
	SystemControl_CFSR_UNSTKERR_Pos = 0xb
	// Bit mask of UNSTKERR field.
	SystemControl_CFSR_UNSTKERR_Msk = 0x800
	// Bit UNSTKERR.
	SystemControl_CFSR_UNSTKERR = 0x800
	// no unstacking fault
	SystemControl_CFSR_UNSTKERR_0 = 0x0
	// unstack for an exception return has caused one or more BusFaults
	SystemControl_CFSR_UNSTKERR_1 = 0x1
	// Position of STKERR field.
	SystemControl_CFSR_STKERR_Pos = 0xc
	// Bit mask of STKERR field.
	SystemControl_CFSR_STKERR_Msk = 0x1000
	// Bit STKERR.
	SystemControl_CFSR_STKERR = 0x1000
	// no stacking fault
	SystemControl_CFSR_STKERR_0 = 0x0
	// stacking for an exception entry has caused one or more BusFaults
	SystemControl_CFSR_STKERR_1 = 0x1
	// Position of LSPERR field.
	SystemControl_CFSR_LSPERR_Pos = 0xd
	// Bit mask of LSPERR field.
	SystemControl_CFSR_LSPERR_Msk = 0x2000
	// Bit LSPERR.
	SystemControl_CFSR_LSPERR = 0x2000
	// No bus fault occurred during floating-point lazy state preservation
	SystemControl_CFSR_LSPERR_0 = 0x0
	// A bus fault occurred during floating-point lazy state preservation
	SystemControl_CFSR_LSPERR_1 = 0x1
	// Position of BFARVALID field.
	SystemControl_CFSR_BFARVALID_Pos = 0xf
	// Bit mask of BFARVALID field.
	SystemControl_CFSR_BFARVALID_Msk = 0x8000
	// Bit BFARVALID.
	SystemControl_CFSR_BFARVALID = 0x8000
	// value in BFAR is not a valid fault address
	SystemControl_CFSR_BFARVALID_0 = 0x0
	// BFAR holds a valid fault address
	SystemControl_CFSR_BFARVALID_1 = 0x1
	// Position of UNDEFINSTR field.
	SystemControl_CFSR_UNDEFINSTR_Pos = 0x10
	// Bit mask of UNDEFINSTR field.
	SystemControl_CFSR_UNDEFINSTR_Msk = 0x10000
	// Bit UNDEFINSTR.
	SystemControl_CFSR_UNDEFINSTR = 0x10000
	// no undefined instruction UsageFault
	SystemControl_CFSR_UNDEFINSTR_0 = 0x0
	// the processor has attempted to execute an undefined instruction
	SystemControl_CFSR_UNDEFINSTR_1 = 0x1
	// Position of INVSTATE field.
	SystemControl_CFSR_INVSTATE_Pos = 0x11
	// Bit mask of INVSTATE field.
	SystemControl_CFSR_INVSTATE_Msk = 0x20000
	// Bit INVSTATE.
	SystemControl_CFSR_INVSTATE = 0x20000
	// no invalid state UsageFault
	SystemControl_CFSR_INVSTATE_0 = 0x0
	// the processor has attempted to execute an instruction that makes illegal use of the EPSR
	SystemControl_CFSR_INVSTATE_1 = 0x1
	// Position of INVPC field.
	SystemControl_CFSR_INVPC_Pos = 0x12
	// Bit mask of INVPC field.
	SystemControl_CFSR_INVPC_Msk = 0x40000
	// Bit INVPC.
	SystemControl_CFSR_INVPC = 0x40000
	// no invalid PC load UsageFault
	SystemControl_CFSR_INVPC_0 = 0x0
	// the processor has attempted an illegal load of EXC_RETURN to the PC
	SystemControl_CFSR_INVPC_1 = 0x1
	// Position of NOCP field.
	SystemControl_CFSR_NOCP_Pos = 0x13
	// Bit mask of NOCP field.
	SystemControl_CFSR_NOCP_Msk = 0x80000
	// Bit NOCP.
	SystemControl_CFSR_NOCP = 0x80000
	// no UsageFault caused by attempting to access a coprocessor
	SystemControl_CFSR_NOCP_0 = 0x0
	// the processor has attempted to access a coprocessor
	SystemControl_CFSR_NOCP_1 = 0x1
	// Position of UNALIGNED field.
	SystemControl_CFSR_UNALIGNED_Pos = 0x18
	// Bit mask of UNALIGNED field.
	SystemControl_CFSR_UNALIGNED_Msk = 0x1000000
	// Bit UNALIGNED.
	SystemControl_CFSR_UNALIGNED = 0x1000000
	// no unaligned access fault, or unaligned access trapping not enabled
	SystemControl_CFSR_UNALIGNED_0 = 0x0
	// the processor has made an unaligned memory access
	SystemControl_CFSR_UNALIGNED_1 = 0x1
	// Position of DIVBYZERO field.
	SystemControl_CFSR_DIVBYZERO_Pos = 0x19
	// Bit mask of DIVBYZERO field.
	SystemControl_CFSR_DIVBYZERO_Msk = 0x2000000
	// Bit DIVBYZERO.
	SystemControl_CFSR_DIVBYZERO = 0x2000000
	// no divide by zero fault, or divide by zero trapping not enabled
	SystemControl_CFSR_DIVBYZERO_0 = 0x0
	// the processor has executed an SDIV or UDIV instruction with a divisor of 0
	SystemControl_CFSR_DIVBYZERO_1 = 0x1

	// HFSR: HardFault Status register
	// Position of VECTTBL field.
	SystemControl_HFSR_VECTTBL_Pos = 0x1
	// Bit mask of VECTTBL field.
	SystemControl_HFSR_VECTTBL_Msk = 0x2
	// Bit VECTTBL.
	SystemControl_HFSR_VECTTBL = 0x2
	// no BusFault on vector table read
	SystemControl_HFSR_VECTTBL_0 = 0x0
	// BusFault on vector table read
	SystemControl_HFSR_VECTTBL_1 = 0x1
	// Position of FORCED field.
	SystemControl_HFSR_FORCED_Pos = 0x1e
	// Bit mask of FORCED field.
	SystemControl_HFSR_FORCED_Msk = 0x40000000
	// Bit FORCED.
	SystemControl_HFSR_FORCED = 0x40000000
	// no forced HardFault
	SystemControl_HFSR_FORCED_0 = 0x0
	// forced HardFault
	SystemControl_HFSR_FORCED_1 = 0x1
	// Position of DEBUGEVT field.
	SystemControl_HFSR_DEBUGEVT_Pos = 0x1f
	// Bit mask of DEBUGEVT field.
	SystemControl_HFSR_DEBUGEVT_Msk = 0x80000000
	// Bit DEBUGEVT.
	SystemControl_HFSR_DEBUGEVT = 0x80000000

	// DFSR: Debug Fault Status Register
	// Position of HALTED field.
	SystemControl_DFSR_HALTED_Pos = 0x0
	// Bit mask of HALTED field.
	SystemControl_DFSR_HALTED_Msk = 0x1
	// Bit HALTED.
	SystemControl_DFSR_HALTED = 0x1
	// No active halt request debug event
	SystemControl_DFSR_HALTED_0 = 0x0
	// Halt request debug event active
	SystemControl_DFSR_HALTED_1 = 0x1
	// Position of BKPT field.
	SystemControl_DFSR_BKPT_Pos = 0x1
	// Bit mask of BKPT field.
	SystemControl_DFSR_BKPT_Msk = 0x2
	// Bit BKPT.
	SystemControl_DFSR_BKPT = 0x2
	// No current breakpoint debug event
	SystemControl_DFSR_BKPT_0 = 0x0
	// At least one current breakpoint debug event
	SystemControl_DFSR_BKPT_1 = 0x1
	// Position of DWTTRAP field.
	SystemControl_DFSR_DWTTRAP_Pos = 0x2
	// Bit mask of DWTTRAP field.
	SystemControl_DFSR_DWTTRAP_Msk = 0x4
	// Bit DWTTRAP.
	SystemControl_DFSR_DWTTRAP = 0x4
	// No current debug events generated by the DWT
	SystemControl_DFSR_DWTTRAP_0 = 0x0
	// At least one current debug event generated by the DWT
	SystemControl_DFSR_DWTTRAP_1 = 0x1
	// Position of VCATCH field.
	SystemControl_DFSR_VCATCH_Pos = 0x3
	// Bit mask of VCATCH field.
	SystemControl_DFSR_VCATCH_Msk = 0x8
	// Bit VCATCH.
	SystemControl_DFSR_VCATCH = 0x8
	// No Vector catch triggered
	SystemControl_DFSR_VCATCH_0 = 0x0
	// Vector catch triggered
	SystemControl_DFSR_VCATCH_1 = 0x1
	// Position of EXTERNAL field.
	SystemControl_DFSR_EXTERNAL_Pos = 0x4
	// Bit mask of EXTERNAL field.
	SystemControl_DFSR_EXTERNAL_Msk = 0x10
	// Bit EXTERNAL.
	SystemControl_DFSR_EXTERNAL = 0x10
	// No EDBGRQ debug event
	SystemControl_DFSR_EXTERNAL_0 = 0x0
	// EDBGRQ debug event
	SystemControl_DFSR_EXTERNAL_1 = 0x1

	// MMFAR: MemManage Address Register
	// Position of ADDRESS field.
	SystemControl_MMFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SystemControl_MMFAR_ADDRESS_Msk = 0xffffffff

	// BFAR: BusFault Address Register
	// Position of ADDRESS field.
	SystemControl_BFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SystemControl_BFAR_ADDRESS_Msk = 0xffffffff

	// AFSR: Auxiliary Fault Status Register
	// Position of AUXFAULT field.
	SystemControl_AFSR_AUXFAULT_Pos = 0x0
	// Bit mask of AUXFAULT field.
	SystemControl_AFSR_AUXFAULT_Msk = 0xffffffff

	// CPACR: Coprocessor Access Control Register
	// Position of CP10 field.
	SystemControl_CPACR_CP10_Pos = 0x14
	// Bit mask of CP10 field.
	SystemControl_CPACR_CP10_Msk = 0x300000
	// Access denied. Any attempted access generates a NOCP UsageFault
	SystemControl_CPACR_CP10_00 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP fault.
	SystemControl_CPACR_CP10_01 = 0x1
	// Reserved. The result of any access is UNPREDICTABLE.
	SystemControl_CPACR_CP10_10 = 0x2
	// Full access.
	SystemControl_CPACR_CP10_11 = 0x3
	// Position of CP11 field.
	SystemControl_CPACR_CP11_Pos = 0x16
	// Bit mask of CP11 field.
	SystemControl_CPACR_CP11_Msk = 0xc00000
	// Access denied. Any attempted access generates a NOCP UsageFault
	SystemControl_CPACR_CP11_00 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP fault.
	SystemControl_CPACR_CP11_01 = 0x1
	// Reserved. The result of any access is UNPREDICTABLE.
	SystemControl_CPACR_CP11_10 = 0x2
	// Full access.
	SystemControl_CPACR_CP11_11 = 0x3

	// FPCCR: Floating-point Context Control Register
	// Position of LSPACT field.
	SystemControl_FPCCR_LSPACT_Pos = 0x0
	// Bit mask of LSPACT field.
	SystemControl_FPCCR_LSPACT_Msk = 0x1
	// Bit LSPACT.
	SystemControl_FPCCR_LSPACT = 0x1
	// Lazy state preservation is not active.
	SystemControl_FPCCR_LSPACT_0 = 0x0
	// Lazy state preservation is active. floating-point stack frame has been allocated but saving state to it has been deferred.
	SystemControl_FPCCR_LSPACT_1 = 0x1
	// Position of USER field.
	SystemControl_FPCCR_USER_Pos = 0x1
	// Bit mask of USER field.
	SystemControl_FPCCR_USER_Msk = 0x2
	// Bit USER.
	SystemControl_FPCCR_USER = 0x2
	// Privilege level was not user when the floating-point stack frame was allocated.
	SystemControl_FPCCR_USER_0 = 0x0
	// Privilege level was user when the floating-point stack frame was allocated.
	SystemControl_FPCCR_USER_1 = 0x1
	// Position of THREAD field.
	SystemControl_FPCCR_THREAD_Pos = 0x3
	// Bit mask of THREAD field.
	SystemControl_FPCCR_THREAD_Msk = 0x8
	// Bit THREAD.
	SystemControl_FPCCR_THREAD = 0x8
	// Mode was not Thread Mode when the floating-point stack frame was allocated.
	SystemControl_FPCCR_THREAD_0 = 0x0
	// Mode was Thread Mode when the floating-point stack frame was allocated.
	SystemControl_FPCCR_THREAD_1 = 0x1
	// Position of HFRDY field.
	SystemControl_FPCCR_HFRDY_Pos = 0x4
	// Bit mask of HFRDY field.
	SystemControl_FPCCR_HFRDY_Msk = 0x10
	// Bit HFRDY.
	SystemControl_FPCCR_HFRDY = 0x10
	// Priority did not permit setting the HardFault handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_HFRDY_0 = 0x0
	// Priority permitted setting the HardFault handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_HFRDY_1 = 0x1
	// Position of MMRDY field.
	SystemControl_FPCCR_MMRDY_Pos = 0x5
	// Bit mask of MMRDY field.
	SystemControl_FPCCR_MMRDY_Msk = 0x20
	// Bit MMRDY.
	SystemControl_FPCCR_MMRDY = 0x20
	// MemManage is disabled or priority did not permit setting the MemManage handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_MMRDY_0 = 0x0
	// MemManage is enabled and priority permitted setting the MemManage handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_MMRDY_1 = 0x1
	// Position of BFRDY field.
	SystemControl_FPCCR_BFRDY_Pos = 0x6
	// Bit mask of BFRDY field.
	SystemControl_FPCCR_BFRDY_Msk = 0x40
	// Bit BFRDY.
	SystemControl_FPCCR_BFRDY = 0x40
	// BusFault is disabled or priority did not permit setting the BusFault handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_BFRDY_0 = 0x0
	// BusFault is disabled or priority did not permit setting the BusFault handler to the pending state when the floating-point stack frame was allocated.
	SystemControl_FPCCR_BFRDY_1 = 0x1
	// Position of MONRDY field.
	SystemControl_FPCCR_MONRDY_Pos = 0x8
	// Bit mask of MONRDY field.
	SystemControl_FPCCR_MONRDY_Msk = 0x100
	// Bit MONRDY.
	SystemControl_FPCCR_MONRDY = 0x100
	// DebugMonitor is disabled or priority did not permit setting MON_PEND when the floating-point stack frame was allocated.
	SystemControl_FPCCR_MONRDY_0 = 0x0
	// DebugMonitor is enabled and priority permits setting MON_PEND when the floating-point stack frame was allocated.
	SystemControl_FPCCR_MONRDY_1 = 0x1
	// Position of LSPEN field.
	SystemControl_FPCCR_LSPEN_Pos = 0x1e
	// Bit mask of LSPEN field.
	SystemControl_FPCCR_LSPEN_Msk = 0x40000000
	// Bit LSPEN.
	SystemControl_FPCCR_LSPEN = 0x40000000
	// Disable automatic lazy state preservation for floating-point context.
	SystemControl_FPCCR_LSPEN_0 = 0x0
	// Enable automatic lazy state preservation for floating-point context.
	SystemControl_FPCCR_LSPEN_1 = 0x1
	// Position of ASPEN field.
	SystemControl_FPCCR_ASPEN_Pos = 0x1f
	// Bit mask of ASPEN field.
	SystemControl_FPCCR_ASPEN_Msk = 0x80000000
	// Bit ASPEN.
	SystemControl_FPCCR_ASPEN = 0x80000000
	// Disable CONTROL2 setting on execution of a floating-point instruction.
	SystemControl_FPCCR_ASPEN_0 = 0x0
	// Enable CONTROL2 setting on execution of a floating-point instruction.
	SystemControl_FPCCR_ASPEN_1 = 0x1

	// FPCAR: Floating-point Context Address Register
	// Position of ADDRESS field.
	SystemControl_FPCAR_ADDRESS_Pos = 0x3
	// Bit mask of ADDRESS field.
	SystemControl_FPCAR_ADDRESS_Msk = 0xfffffff8

	// FPDSCR: Floating-point Default Status Control Register
	// Position of RMode field.
	SystemControl_FPDSCR_RMode_Pos = 0x16
	// Bit mask of RMode field.
	SystemControl_FPDSCR_RMode_Msk = 0xc00000
	// Round to Nearest (RN) mode
	SystemControl_FPDSCR_RMode_00 = 0x0
	// Round towards Plus Infinity (RP) mode.
	SystemControl_FPDSCR_RMode_01 = 0x1
	// Round towards Minus Infinity (RM) mode.
	SystemControl_FPDSCR_RMode_10 = 0x2
	// Round towards Zero (RZ) mode.
	SystemControl_FPDSCR_RMode_11 = 0x3
	// Position of FZ field.
	SystemControl_FPDSCR_FZ_Pos = 0x18
	// Bit mask of FZ field.
	SystemControl_FPDSCR_FZ_Msk = 0x1000000
	// Bit FZ.
	SystemControl_FPDSCR_FZ = 0x1000000
	// Flush-to-zero mode disabled. Behavior of the floating-point system is fully compliant with the IEEE 754 standard.
	SystemControl_FPDSCR_FZ_0 = 0x0
	// Flush-to-zero mode enabled.
	SystemControl_FPDSCR_FZ_1 = 0x1
	// Position of DN field.
	SystemControl_FPDSCR_DN_Pos = 0x19
	// Bit mask of DN field.
	SystemControl_FPDSCR_DN_Msk = 0x2000000
	// Bit DN.
	SystemControl_FPDSCR_DN = 0x2000000
	// NaN operands propagate through to the output of a floating-point operation.
	SystemControl_FPDSCR_DN_0 = 0x0
	// Any operation involving one or more NaNs returns the Default NaN.
	SystemControl_FPDSCR_DN_1 = 0x1
	// Position of AHP field.
	SystemControl_FPDSCR_AHP_Pos = 0x1a
	// Bit mask of AHP field.
	SystemControl_FPDSCR_AHP_Msk = 0x4000000
	// Bit AHP.
	SystemControl_FPDSCR_AHP = 0x4000000
	// IEEE half-precision format selected.
	SystemControl_FPDSCR_AHP_0 = 0x0
	// Alternative half-precision format selected.
	SystemControl_FPDSCR_AHP_1 = 0x1
)

// Constants for SysTick: System timer
const (
	// CSR: SysTick Control and Status Register
	// Position of ENABLE field.
	SysTick_CSR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SysTick_CSR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SysTick_CSR_ENABLE = 0x1
	// counter disabled
	SysTick_CSR_ENABLE_0 = 0x0
	// counter enabled
	SysTick_CSR_ENABLE_1 = 0x1
	// Position of TICKINT field.
	SysTick_CSR_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	SysTick_CSR_TICKINT_Msk = 0x2
	// Bit TICKINT.
	SysTick_CSR_TICKINT = 0x2
	// counting down to 0 does not assert the SysTick exception request
	SysTick_CSR_TICKINT_0 = 0x0
	// counting down to 0 asserts the SysTick exception request
	SysTick_CSR_TICKINT_1 = 0x1
	// Position of CLKSOURCE field.
	SysTick_CSR_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	SysTick_CSR_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	SysTick_CSR_CLKSOURCE = 0x4
	// external clock
	SysTick_CSR_CLKSOURCE_0 = 0x0
	// processor clock
	SysTick_CSR_CLKSOURCE_1 = 0x1
	// Position of COUNTFLAG field.
	SysTick_CSR_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	SysTick_CSR_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	SysTick_CSR_COUNTFLAG = 0x10000

	// RVR: SysTick Reload Value Register
	// Position of RELOAD field.
	SysTick_RVR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	SysTick_RVR_RELOAD_Msk = 0xffffff

	// CVR: SysTick Current Value Register
	// Position of CURRENT field.
	SysTick_CVR_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	SysTick_CVR_CURRENT_Msk = 0xffffff

	// CALIB: SysTick Calibration Value Register
	// Position of TENMS field.
	SysTick_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	SysTick_CALIB_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	SysTick_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	SysTick_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	SysTick_CALIB_SKEW = 0x40000000
	// 10ms calibration value is exact
	SysTick_CALIB_SKEW_0 = 0x0
	// 10ms calibration value is inexact, because of the clock frequency
	SysTick_CALIB_SKEW_1 = 0x1
	// Position of NOREF field.
	SysTick_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	SysTick_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	SysTick_CALIB_NOREF = 0x80000000
	// The reference clock is provided
	SysTick_CALIB_NOREF_0 = 0x0
	// The reference clock is not provided
	SysTick_CALIB_NOREF_1 = 0x1
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// NVICISER0: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER0_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER0_SETENA_Msk = 0xffffffff

	// NVICISER1: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER1_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER1_SETENA_Msk = 0xffffffff

	// NVICISER2: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER2_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER2_SETENA_Msk = 0xffffffff

	// NVICISER3: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER3_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER3_SETENA_Msk = 0xffffffff

	// NVICICER0: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER0_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER0_CLRENA_Msk = 0xffffffff

	// NVICICER1: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER1_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER1_CLRENA_Msk = 0xffffffff

	// NVICICER2: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER2_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER2_CLRENA_Msk = 0xffffffff

	// NVICICER3: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER3_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER3_CLRENA_Msk = 0xffffffff

	// NVICISPR0: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR0_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR0_SETPEND_Msk = 0xffffffff

	// NVICISPR1: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR1_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR1_SETPEND_Msk = 0xffffffff

	// NVICISPR2: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR2_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR2_SETPEND_Msk = 0xffffffff

	// NVICISPR3: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR3_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR3_SETPEND_Msk = 0xffffffff

	// NVICICPR0: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR0_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR0_CLRPEND_Msk = 0xffffffff

	// NVICICPR1: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR1_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR1_CLRPEND_Msk = 0xffffffff

	// NVICICPR2: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR2_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR2_CLRPEND_Msk = 0xffffffff

	// NVICICPR3: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR3_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR3_CLRPEND_Msk = 0xffffffff

	// NVICIABR0: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR0_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR0_ACTIVE_Msk = 0xffffffff

	// NVICIABR1: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR1_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR1_ACTIVE_Msk = 0xffffffff

	// NVICIABR2: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR2_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR2_ACTIVE_Msk = 0xffffffff

	// NVICIABR3: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR3_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR3_ACTIVE_Msk = 0xffffffff

	// NVICIP0: Interrupt Priority Register n
	// Position of PRI0 field.
	NVIC_NVICIP0_PRI0_Pos = 0x0
	// Bit mask of PRI0 field.
	NVIC_NVICIP0_PRI0_Msk = 0xff

	// NVICIP1: Interrupt Priority Register n
	// Position of PRI1 field.
	NVIC_NVICIP1_PRI1_Pos = 0x0
	// Bit mask of PRI1 field.
	NVIC_NVICIP1_PRI1_Msk = 0xff

	// NVICIP2: Interrupt Priority Register n
	// Position of PRI2 field.
	NVIC_NVICIP2_PRI2_Pos = 0x0
	// Bit mask of PRI2 field.
	NVIC_NVICIP2_PRI2_Msk = 0xff

	// NVICIP3: Interrupt Priority Register n
	// Position of PRI3 field.
	NVIC_NVICIP3_PRI3_Pos = 0x0
	// Bit mask of PRI3 field.
	NVIC_NVICIP3_PRI3_Msk = 0xff

	// NVICIP4: Interrupt Priority Register n
	// Position of PRI4 field.
	NVIC_NVICIP4_PRI4_Pos = 0x0
	// Bit mask of PRI4 field.
	NVIC_NVICIP4_PRI4_Msk = 0xff

	// NVICIP5: Interrupt Priority Register n
	// Position of PRI5 field.
	NVIC_NVICIP5_PRI5_Pos = 0x0
	// Bit mask of PRI5 field.
	NVIC_NVICIP5_PRI5_Msk = 0xff

	// NVICIP6: Interrupt Priority Register n
	// Position of PRI6 field.
	NVIC_NVICIP6_PRI6_Pos = 0x0
	// Bit mask of PRI6 field.
	NVIC_NVICIP6_PRI6_Msk = 0xff

	// NVICIP7: Interrupt Priority Register n
	// Position of PRI7 field.
	NVIC_NVICIP7_PRI7_Pos = 0x0
	// Bit mask of PRI7 field.
	NVIC_NVICIP7_PRI7_Msk = 0xff

	// NVICIP8: Interrupt Priority Register n
	// Position of PRI8 field.
	NVIC_NVICIP8_PRI8_Pos = 0x0
	// Bit mask of PRI8 field.
	NVIC_NVICIP8_PRI8_Msk = 0xff

	// NVICIP9: Interrupt Priority Register n
	// Position of PRI9 field.
	NVIC_NVICIP9_PRI9_Pos = 0x0
	// Bit mask of PRI9 field.
	NVIC_NVICIP9_PRI9_Msk = 0xff

	// NVICIP10: Interrupt Priority Register n
	// Position of PRI10 field.
	NVIC_NVICIP10_PRI10_Pos = 0x0
	// Bit mask of PRI10 field.
	NVIC_NVICIP10_PRI10_Msk = 0xff

	// NVICIP11: Interrupt Priority Register n
	// Position of PRI11 field.
	NVIC_NVICIP11_PRI11_Pos = 0x0
	// Bit mask of PRI11 field.
	NVIC_NVICIP11_PRI11_Msk = 0xff

	// NVICIP12: Interrupt Priority Register n
	// Position of PRI12 field.
	NVIC_NVICIP12_PRI12_Pos = 0x0
	// Bit mask of PRI12 field.
	NVIC_NVICIP12_PRI12_Msk = 0xff

	// NVICIP13: Interrupt Priority Register n
	// Position of PRI13 field.
	NVIC_NVICIP13_PRI13_Pos = 0x0
	// Bit mask of PRI13 field.
	NVIC_NVICIP13_PRI13_Msk = 0xff

	// NVICIP14: Interrupt Priority Register n
	// Position of PRI14 field.
	NVIC_NVICIP14_PRI14_Pos = 0x0
	// Bit mask of PRI14 field.
	NVIC_NVICIP14_PRI14_Msk = 0xff

	// NVICIP15: Interrupt Priority Register n
	// Position of PRI15 field.
	NVIC_NVICIP15_PRI15_Pos = 0x0
	// Bit mask of PRI15 field.
	NVIC_NVICIP15_PRI15_Msk = 0xff

	// NVICIP16: Interrupt Priority Register n
	// Position of PRI16 field.
	NVIC_NVICIP16_PRI16_Pos = 0x0
	// Bit mask of PRI16 field.
	NVIC_NVICIP16_PRI16_Msk = 0xff

	// NVICIP17: Interrupt Priority Register n
	// Position of PRI17 field.
	NVIC_NVICIP17_PRI17_Pos = 0x0
	// Bit mask of PRI17 field.
	NVIC_NVICIP17_PRI17_Msk = 0xff

	// NVICIP18: Interrupt Priority Register n
	// Position of PRI18 field.
	NVIC_NVICIP18_PRI18_Pos = 0x0
	// Bit mask of PRI18 field.
	NVIC_NVICIP18_PRI18_Msk = 0xff

	// NVICIP19: Interrupt Priority Register n
	// Position of PRI19 field.
	NVIC_NVICIP19_PRI19_Pos = 0x0
	// Bit mask of PRI19 field.
	NVIC_NVICIP19_PRI19_Msk = 0xff

	// NVICIP20: Interrupt Priority Register n
	// Position of PRI20 field.
	NVIC_NVICIP20_PRI20_Pos = 0x0
	// Bit mask of PRI20 field.
	NVIC_NVICIP20_PRI20_Msk = 0xff

	// NVICIP21: Interrupt Priority Register n
	// Position of PRI21 field.
	NVIC_NVICIP21_PRI21_Pos = 0x0
	// Bit mask of PRI21 field.
	NVIC_NVICIP21_PRI21_Msk = 0xff

	// NVICIP22: Interrupt Priority Register n
	// Position of PRI22 field.
	NVIC_NVICIP22_PRI22_Pos = 0x0
	// Bit mask of PRI22 field.
	NVIC_NVICIP22_PRI22_Msk = 0xff

	// NVICIP23: Interrupt Priority Register n
	// Position of PRI23 field.
	NVIC_NVICIP23_PRI23_Pos = 0x0
	// Bit mask of PRI23 field.
	NVIC_NVICIP23_PRI23_Msk = 0xff

	// NVICIP24: Interrupt Priority Register n
	// Position of PRI24 field.
	NVIC_NVICIP24_PRI24_Pos = 0x0
	// Bit mask of PRI24 field.
	NVIC_NVICIP24_PRI24_Msk = 0xff

	// NVICIP25: Interrupt Priority Register n
	// Position of PRI25 field.
	NVIC_NVICIP25_PRI25_Pos = 0x0
	// Bit mask of PRI25 field.
	NVIC_NVICIP25_PRI25_Msk = 0xff

	// NVICIP26: Interrupt Priority Register n
	// Position of PRI26 field.
	NVIC_NVICIP26_PRI26_Pos = 0x0
	// Bit mask of PRI26 field.
	NVIC_NVICIP26_PRI26_Msk = 0xff

	// NVICIP27: Interrupt Priority Register n
	// Position of PRI27 field.
	NVIC_NVICIP27_PRI27_Pos = 0x0
	// Bit mask of PRI27 field.
	NVIC_NVICIP27_PRI27_Msk = 0xff

	// NVICIP28: Interrupt Priority Register n
	// Position of PRI28 field.
	NVIC_NVICIP28_PRI28_Pos = 0x0
	// Bit mask of PRI28 field.
	NVIC_NVICIP28_PRI28_Msk = 0xff

	// NVICIP29: Interrupt Priority Register n
	// Position of PRI29 field.
	NVIC_NVICIP29_PRI29_Pos = 0x0
	// Bit mask of PRI29 field.
	NVIC_NVICIP29_PRI29_Msk = 0xff

	// NVICIP30: Interrupt Priority Register n
	// Position of PRI30 field.
	NVIC_NVICIP30_PRI30_Pos = 0x0
	// Bit mask of PRI30 field.
	NVIC_NVICIP30_PRI30_Msk = 0xff

	// NVICIP31: Interrupt Priority Register n
	// Position of PRI31 field.
	NVIC_NVICIP31_PRI31_Pos = 0x0
	// Bit mask of PRI31 field.
	NVIC_NVICIP31_PRI31_Msk = 0xff

	// NVICIP32: Interrupt Priority Register n
	// Position of PRI32 field.
	NVIC_NVICIP32_PRI32_Pos = 0x0
	// Bit mask of PRI32 field.
	NVIC_NVICIP32_PRI32_Msk = 0xff

	// NVICIP33: Interrupt Priority Register n
	// Position of PRI33 field.
	NVIC_NVICIP33_PRI33_Pos = 0x0
	// Bit mask of PRI33 field.
	NVIC_NVICIP33_PRI33_Msk = 0xff

	// NVICIP34: Interrupt Priority Register n
	// Position of PRI34 field.
	NVIC_NVICIP34_PRI34_Pos = 0x0
	// Bit mask of PRI34 field.
	NVIC_NVICIP34_PRI34_Msk = 0xff

	// NVICIP35: Interrupt Priority Register n
	// Position of PRI35 field.
	NVIC_NVICIP35_PRI35_Pos = 0x0
	// Bit mask of PRI35 field.
	NVIC_NVICIP35_PRI35_Msk = 0xff

	// NVICIP36: Interrupt Priority Register n
	// Position of PRI36 field.
	NVIC_NVICIP36_PRI36_Pos = 0x0
	// Bit mask of PRI36 field.
	NVIC_NVICIP36_PRI36_Msk = 0xff

	// NVICIP37: Interrupt Priority Register n
	// Position of PRI37 field.
	NVIC_NVICIP37_PRI37_Pos = 0x0
	// Bit mask of PRI37 field.
	NVIC_NVICIP37_PRI37_Msk = 0xff

	// NVICIP38: Interrupt Priority Register n
	// Position of PRI38 field.
	NVIC_NVICIP38_PRI38_Pos = 0x0
	// Bit mask of PRI38 field.
	NVIC_NVICIP38_PRI38_Msk = 0xff

	// NVICIP39: Interrupt Priority Register n
	// Position of PRI39 field.
	NVIC_NVICIP39_PRI39_Pos = 0x0
	// Bit mask of PRI39 field.
	NVIC_NVICIP39_PRI39_Msk = 0xff

	// NVICIP40: Interrupt Priority Register n
	// Position of PRI40 field.
	NVIC_NVICIP40_PRI40_Pos = 0x0
	// Bit mask of PRI40 field.
	NVIC_NVICIP40_PRI40_Msk = 0xff

	// NVICIP41: Interrupt Priority Register n
	// Position of PRI41 field.
	NVIC_NVICIP41_PRI41_Pos = 0x0
	// Bit mask of PRI41 field.
	NVIC_NVICIP41_PRI41_Msk = 0xff

	// NVICIP42: Interrupt Priority Register n
	// Position of PRI42 field.
	NVIC_NVICIP42_PRI42_Pos = 0x0
	// Bit mask of PRI42 field.
	NVIC_NVICIP42_PRI42_Msk = 0xff

	// NVICIP43: Interrupt Priority Register n
	// Position of PRI43 field.
	NVIC_NVICIP43_PRI43_Pos = 0x0
	// Bit mask of PRI43 field.
	NVIC_NVICIP43_PRI43_Msk = 0xff

	// NVICIP44: Interrupt Priority Register n
	// Position of PRI44 field.
	NVIC_NVICIP44_PRI44_Pos = 0x0
	// Bit mask of PRI44 field.
	NVIC_NVICIP44_PRI44_Msk = 0xff

	// NVICIP45: Interrupt Priority Register n
	// Position of PRI45 field.
	NVIC_NVICIP45_PRI45_Pos = 0x0
	// Bit mask of PRI45 field.
	NVIC_NVICIP45_PRI45_Msk = 0xff

	// NVICIP46: Interrupt Priority Register n
	// Position of PRI46 field.
	NVIC_NVICIP46_PRI46_Pos = 0x0
	// Bit mask of PRI46 field.
	NVIC_NVICIP46_PRI46_Msk = 0xff

	// NVICIP47: Interrupt Priority Register n
	// Position of PRI47 field.
	NVIC_NVICIP47_PRI47_Pos = 0x0
	// Bit mask of PRI47 field.
	NVIC_NVICIP47_PRI47_Msk = 0xff

	// NVICIP48: Interrupt Priority Register n
	// Position of PRI48 field.
	NVIC_NVICIP48_PRI48_Pos = 0x0
	// Bit mask of PRI48 field.
	NVIC_NVICIP48_PRI48_Msk = 0xff

	// NVICIP49: Interrupt Priority Register n
	// Position of PRI49 field.
	NVIC_NVICIP49_PRI49_Pos = 0x0
	// Bit mask of PRI49 field.
	NVIC_NVICIP49_PRI49_Msk = 0xff

	// NVICIP50: Interrupt Priority Register n
	// Position of PRI50 field.
	NVIC_NVICIP50_PRI50_Pos = 0x0
	// Bit mask of PRI50 field.
	NVIC_NVICIP50_PRI50_Msk = 0xff

	// NVICIP51: Interrupt Priority Register n
	// Position of PRI51 field.
	NVIC_NVICIP51_PRI51_Pos = 0x0
	// Bit mask of PRI51 field.
	NVIC_NVICIP51_PRI51_Msk = 0xff

	// NVICIP52: Interrupt Priority Register n
	// Position of PRI52 field.
	NVIC_NVICIP52_PRI52_Pos = 0x0
	// Bit mask of PRI52 field.
	NVIC_NVICIP52_PRI52_Msk = 0xff

	// NVICIP53: Interrupt Priority Register n
	// Position of PRI53 field.
	NVIC_NVICIP53_PRI53_Pos = 0x0
	// Bit mask of PRI53 field.
	NVIC_NVICIP53_PRI53_Msk = 0xff

	// NVICIP54: Interrupt Priority Register n
	// Position of PRI54 field.
	NVIC_NVICIP54_PRI54_Pos = 0x0
	// Bit mask of PRI54 field.
	NVIC_NVICIP54_PRI54_Msk = 0xff

	// NVICIP55: Interrupt Priority Register n
	// Position of PRI55 field.
	NVIC_NVICIP55_PRI55_Pos = 0x0
	// Bit mask of PRI55 field.
	NVIC_NVICIP55_PRI55_Msk = 0xff

	// NVICIP56: Interrupt Priority Register n
	// Position of PRI56 field.
	NVIC_NVICIP56_PRI56_Pos = 0x0
	// Bit mask of PRI56 field.
	NVIC_NVICIP56_PRI56_Msk = 0xff

	// NVICIP57: Interrupt Priority Register n
	// Position of PRI57 field.
	NVIC_NVICIP57_PRI57_Pos = 0x0
	// Bit mask of PRI57 field.
	NVIC_NVICIP57_PRI57_Msk = 0xff

	// NVICIP58: Interrupt Priority Register n
	// Position of PRI58 field.
	NVIC_NVICIP58_PRI58_Pos = 0x0
	// Bit mask of PRI58 field.
	NVIC_NVICIP58_PRI58_Msk = 0xff

	// NVICIP59: Interrupt Priority Register n
	// Position of PRI59 field.
	NVIC_NVICIP59_PRI59_Pos = 0x0
	// Bit mask of PRI59 field.
	NVIC_NVICIP59_PRI59_Msk = 0xff

	// NVICIP60: Interrupt Priority Register n
	// Position of PRI60 field.
	NVIC_NVICIP60_PRI60_Pos = 0x0
	// Bit mask of PRI60 field.
	NVIC_NVICIP60_PRI60_Msk = 0xff

	// NVICIP61: Interrupt Priority Register n
	// Position of PRI61 field.
	NVIC_NVICIP61_PRI61_Pos = 0x0
	// Bit mask of PRI61 field.
	NVIC_NVICIP61_PRI61_Msk = 0xff

	// NVICIP62: Interrupt Priority Register n
	// Position of PRI62 field.
	NVIC_NVICIP62_PRI62_Pos = 0x0
	// Bit mask of PRI62 field.
	NVIC_NVICIP62_PRI62_Msk = 0xff

	// NVICIP63: Interrupt Priority Register n
	// Position of PRI63 field.
	NVIC_NVICIP63_PRI63_Pos = 0x0
	// Bit mask of PRI63 field.
	NVIC_NVICIP63_PRI63_Msk = 0xff

	// NVICIP64: Interrupt Priority Register n
	// Position of PRI64 field.
	NVIC_NVICIP64_PRI64_Pos = 0x0
	// Bit mask of PRI64 field.
	NVIC_NVICIP64_PRI64_Msk = 0xff

	// NVICIP65: Interrupt Priority Register n
	// Position of PRI65 field.
	NVIC_NVICIP65_PRI65_Pos = 0x0
	// Bit mask of PRI65 field.
	NVIC_NVICIP65_PRI65_Msk = 0xff

	// NVICIP66: Interrupt Priority Register n
	// Position of PRI66 field.
	NVIC_NVICIP66_PRI66_Pos = 0x0
	// Bit mask of PRI66 field.
	NVIC_NVICIP66_PRI66_Msk = 0xff

	// NVICIP67: Interrupt Priority Register n
	// Position of PRI67 field.
	NVIC_NVICIP67_PRI67_Pos = 0x0
	// Bit mask of PRI67 field.
	NVIC_NVICIP67_PRI67_Msk = 0xff

	// NVICIP68: Interrupt Priority Register n
	// Position of PRI68 field.
	NVIC_NVICIP68_PRI68_Pos = 0x0
	// Bit mask of PRI68 field.
	NVIC_NVICIP68_PRI68_Msk = 0xff

	// NVICIP69: Interrupt Priority Register n
	// Position of PRI69 field.
	NVIC_NVICIP69_PRI69_Pos = 0x0
	// Bit mask of PRI69 field.
	NVIC_NVICIP69_PRI69_Msk = 0xff

	// NVICIP70: Interrupt Priority Register n
	// Position of PRI70 field.
	NVIC_NVICIP70_PRI70_Pos = 0x0
	// Bit mask of PRI70 field.
	NVIC_NVICIP70_PRI70_Msk = 0xff

	// NVICIP71: Interrupt Priority Register n
	// Position of PRI71 field.
	NVIC_NVICIP71_PRI71_Pos = 0x0
	// Bit mask of PRI71 field.
	NVIC_NVICIP71_PRI71_Msk = 0xff

	// NVICIP72: Interrupt Priority Register n
	// Position of PRI72 field.
	NVIC_NVICIP72_PRI72_Pos = 0x0
	// Bit mask of PRI72 field.
	NVIC_NVICIP72_PRI72_Msk = 0xff

	// NVICIP73: Interrupt Priority Register n
	// Position of PRI73 field.
	NVIC_NVICIP73_PRI73_Pos = 0x0
	// Bit mask of PRI73 field.
	NVIC_NVICIP73_PRI73_Msk = 0xff

	// NVICIP74: Interrupt Priority Register n
	// Position of PRI74 field.
	NVIC_NVICIP74_PRI74_Pos = 0x0
	// Bit mask of PRI74 field.
	NVIC_NVICIP74_PRI74_Msk = 0xff

	// NVICIP75: Interrupt Priority Register n
	// Position of PRI75 field.
	NVIC_NVICIP75_PRI75_Pos = 0x0
	// Bit mask of PRI75 field.
	NVIC_NVICIP75_PRI75_Msk = 0xff

	// NVICIP76: Interrupt Priority Register n
	// Position of PRI76 field.
	NVIC_NVICIP76_PRI76_Pos = 0x0
	// Bit mask of PRI76 field.
	NVIC_NVICIP76_PRI76_Msk = 0xff

	// NVICIP77: Interrupt Priority Register n
	// Position of PRI77 field.
	NVIC_NVICIP77_PRI77_Pos = 0x0
	// Bit mask of PRI77 field.
	NVIC_NVICIP77_PRI77_Msk = 0xff

	// NVICIP78: Interrupt Priority Register n
	// Position of PRI78 field.
	NVIC_NVICIP78_PRI78_Pos = 0x0
	// Bit mask of PRI78 field.
	NVIC_NVICIP78_PRI78_Msk = 0xff

	// NVICIP79: Interrupt Priority Register n
	// Position of PRI79 field.
	NVIC_NVICIP79_PRI79_Pos = 0x0
	// Bit mask of PRI79 field.
	NVIC_NVICIP79_PRI79_Msk = 0xff

	// NVICIP80: Interrupt Priority Register n
	// Position of PRI80 field.
	NVIC_NVICIP80_PRI80_Pos = 0x0
	// Bit mask of PRI80 field.
	NVIC_NVICIP80_PRI80_Msk = 0xff

	// NVICIP81: Interrupt Priority Register n
	// Position of PRI81 field.
	NVIC_NVICIP81_PRI81_Pos = 0x0
	// Bit mask of PRI81 field.
	NVIC_NVICIP81_PRI81_Msk = 0xff

	// NVICIP82: Interrupt Priority Register n
	// Position of PRI82 field.
	NVIC_NVICIP82_PRI82_Pos = 0x0
	// Bit mask of PRI82 field.
	NVIC_NVICIP82_PRI82_Msk = 0xff

	// NVICIP83: Interrupt Priority Register n
	// Position of PRI83 field.
	NVIC_NVICIP83_PRI83_Pos = 0x0
	// Bit mask of PRI83 field.
	NVIC_NVICIP83_PRI83_Msk = 0xff

	// NVICIP84: Interrupt Priority Register n
	// Position of PRI84 field.
	NVIC_NVICIP84_PRI84_Pos = 0x0
	// Bit mask of PRI84 field.
	NVIC_NVICIP84_PRI84_Msk = 0xff

	// NVICIP85: Interrupt Priority Register n
	// Position of PRI85 field.
	NVIC_NVICIP85_PRI85_Pos = 0x0
	// Bit mask of PRI85 field.
	NVIC_NVICIP85_PRI85_Msk = 0xff

	// NVICIP86: Interrupt Priority Register n
	// Position of PRI86 field.
	NVIC_NVICIP86_PRI86_Pos = 0x0
	// Bit mask of PRI86 field.
	NVIC_NVICIP86_PRI86_Msk = 0xff

	// NVICIP87: Interrupt Priority Register n
	// Position of PRI87 field.
	NVIC_NVICIP87_PRI87_Pos = 0x0
	// Bit mask of PRI87 field.
	NVIC_NVICIP87_PRI87_Msk = 0xff

	// NVICIP88: Interrupt Priority Register n
	// Position of PRI88 field.
	NVIC_NVICIP88_PRI88_Pos = 0x0
	// Bit mask of PRI88 field.
	NVIC_NVICIP88_PRI88_Msk = 0xff

	// NVICIP89: Interrupt Priority Register n
	// Position of PRI89 field.
	NVIC_NVICIP89_PRI89_Pos = 0x0
	// Bit mask of PRI89 field.
	NVIC_NVICIP89_PRI89_Msk = 0xff

	// NVICIP90: Interrupt Priority Register n
	// Position of PRI90 field.
	NVIC_NVICIP90_PRI90_Pos = 0x0
	// Bit mask of PRI90 field.
	NVIC_NVICIP90_PRI90_Msk = 0xff

	// NVICIP91: Interrupt Priority Register n
	// Position of PRI91 field.
	NVIC_NVICIP91_PRI91_Pos = 0x0
	// Bit mask of PRI91 field.
	NVIC_NVICIP91_PRI91_Msk = 0xff

	// NVICIP92: Interrupt Priority Register n
	// Position of PRI92 field.
	NVIC_NVICIP92_PRI92_Pos = 0x0
	// Bit mask of PRI92 field.
	NVIC_NVICIP92_PRI92_Msk = 0xff

	// NVICIP93: Interrupt Priority Register n
	// Position of PRI93 field.
	NVIC_NVICIP93_PRI93_Pos = 0x0
	// Bit mask of PRI93 field.
	NVIC_NVICIP93_PRI93_Msk = 0xff

	// NVICIP94: Interrupt Priority Register n
	// Position of PRI94 field.
	NVIC_NVICIP94_PRI94_Pos = 0x0
	// Bit mask of PRI94 field.
	NVIC_NVICIP94_PRI94_Msk = 0xff

	// NVICIP95: Interrupt Priority Register n
	// Position of PRI95 field.
	NVIC_NVICIP95_PRI95_Pos = 0x0
	// Bit mask of PRI95 field.
	NVIC_NVICIP95_PRI95_Msk = 0xff

	// NVICIP96: Interrupt Priority Register n
	// Position of PRI96 field.
	NVIC_NVICIP96_PRI96_Pos = 0x0
	// Bit mask of PRI96 field.
	NVIC_NVICIP96_PRI96_Msk = 0xff

	// NVICIP97: Interrupt Priority Register n
	// Position of PRI97 field.
	NVIC_NVICIP97_PRI97_Pos = 0x0
	// Bit mask of PRI97 field.
	NVIC_NVICIP97_PRI97_Msk = 0xff

	// NVICIP98: Interrupt Priority Register n
	// Position of PRI98 field.
	NVIC_NVICIP98_PRI98_Pos = 0x0
	// Bit mask of PRI98 field.
	NVIC_NVICIP98_PRI98_Msk = 0xff

	// NVICIP99: Interrupt Priority Register n
	// Position of PRI99 field.
	NVIC_NVICIP99_PRI99_Pos = 0x0
	// Bit mask of PRI99 field.
	NVIC_NVICIP99_PRI99_Msk = 0xff

	// NVICIP100: Interrupt Priority Register n
	// Position of PRI100 field.
	NVIC_NVICIP100_PRI100_Pos = 0x0
	// Bit mask of PRI100 field.
	NVIC_NVICIP100_PRI100_Msk = 0xff

	// NVICIP101: Interrupt Priority Register n
	// Position of PRI101 field.
	NVIC_NVICIP101_PRI101_Pos = 0x0
	// Bit mask of PRI101 field.
	NVIC_NVICIP101_PRI101_Msk = 0xff

	// NVICIP102: Interrupt Priority Register n
	// Position of PRI102 field.
	NVIC_NVICIP102_PRI102_Pos = 0x0
	// Bit mask of PRI102 field.
	NVIC_NVICIP102_PRI102_Msk = 0xff

	// NVICIP103: Interrupt Priority Register n
	// Position of PRI103 field.
	NVIC_NVICIP103_PRI103_Pos = 0x0
	// Bit mask of PRI103 field.
	NVIC_NVICIP103_PRI103_Msk = 0xff

	// NVICIP104: Interrupt Priority Register n
	// Position of PRI104 field.
	NVIC_NVICIP104_PRI104_Pos = 0x0
	// Bit mask of PRI104 field.
	NVIC_NVICIP104_PRI104_Msk = 0xff

	// NVICIP105: Interrupt Priority Register n
	// Position of PRI105 field.
	NVIC_NVICIP105_PRI105_Pos = 0x0
	// Bit mask of PRI105 field.
	NVIC_NVICIP105_PRI105_Msk = 0xff

	// NVICSTIR: Software Trigger Interrupt Register
	// Position of INTID field.
	NVIC_NVICSTIR_INTID_Pos = 0x0
	// Bit mask of INTID field.
	NVIC_NVICSTIR_INTID_Msk = 0x1ff
)

// Constants for MCM: Core Platform Miscellaneous Control Module
const (
	// PLASC: Crossbar Switch (AXBS) Slave Configuration
	// Position of ASC field.
	MCM_PLASC_ASC_Pos = 0x0
	// Bit mask of ASC field.
	MCM_PLASC_ASC_Msk = 0xff
	// A bus slave connection to AXBS input port n is absent
	MCM_PLASC_ASC_0 = 0x0
	// A bus slave connection to AXBS input port n is present
	MCM_PLASC_ASC_1 = 0x1

	// PLAMC: Crossbar Switch (AXBS) Master Configuration
	// Position of AMC field.
	MCM_PLAMC_AMC_Pos = 0x0
	// Bit mask of AMC field.
	MCM_PLAMC_AMC_Msk = 0xff
	// A bus master connection to AXBS input port n is absent
	MCM_PLAMC_AMC_0 = 0x0
	// A bus master connection to AXBS input port n is present
	MCM_PLAMC_AMC_1 = 0x1

	// CR: Control Register
	// Position of SRAMUAP field.
	MCM_CR_SRAMUAP_Pos = 0x18
	// Bit mask of SRAMUAP field.
	MCM_CR_SRAMUAP_Msk = 0x3000000
	// Round robin
	MCM_CR_SRAMUAP_00 = 0x0
	// Special round robin (favors SRAM backoor accesses over the processor)
	MCM_CR_SRAMUAP_01 = 0x1
	// Fixed priority. Processor has highest, backdoor has lowest
	MCM_CR_SRAMUAP_10 = 0x2
	// Fixed priority. Backdoor has highest, processor has lowest
	MCM_CR_SRAMUAP_11 = 0x3
	// Position of SRAMUWP field.
	MCM_CR_SRAMUWP_Pos = 0x1a
	// Bit mask of SRAMUWP field.
	MCM_CR_SRAMUWP_Msk = 0x4000000
	// Bit SRAMUWP.
	MCM_CR_SRAMUWP = 0x4000000
	// Position of SRAMLAP field.
	MCM_CR_SRAMLAP_Pos = 0x1c
	// Bit mask of SRAMLAP field.
	MCM_CR_SRAMLAP_Msk = 0x30000000
	// Round robin
	MCM_CR_SRAMLAP_00 = 0x0
	// Special round robin (favors SRAM backoor accesses over the processor)
	MCM_CR_SRAMLAP_01 = 0x1
	// Fixed priority. Processor has highest, backdoor has lowest
	MCM_CR_SRAMLAP_10 = 0x2
	// Fixed priority. Backdoor has highest, processor has lowest
	MCM_CR_SRAMLAP_11 = 0x3
	// Position of SRAMLWP field.
	MCM_CR_SRAMLWP_Pos = 0x1e
	// Bit mask of SRAMLWP field.
	MCM_CR_SRAMLWP_Msk = 0x40000000
	// Bit SRAMLWP.
	MCM_CR_SRAMLWP = 0x40000000

	// ISCR: Interrupt Status Register
	// Position of IRQ field.
	MCM_ISCR_IRQ_Pos = 0x1
	// Bit mask of IRQ field.
	MCM_ISCR_IRQ_Msk = 0x2
	// Bit IRQ.
	MCM_ISCR_IRQ = 0x2
	// No pending interrupt
	MCM_ISCR_IRQ_0 = 0x0
	// Due to the ETB counter expiring, a normal interrupt is pending
	MCM_ISCR_IRQ_1 = 0x1
	// Position of NMI field.
	MCM_ISCR_NMI_Pos = 0x2
	// Bit mask of NMI field.
	MCM_ISCR_NMI_Msk = 0x4
	// Bit NMI.
	MCM_ISCR_NMI = 0x4
	// No pending NMI
	MCM_ISCR_NMI_0 = 0x0
	// Due to the ETB counter expiring, an NMI is pending
	MCM_ISCR_NMI_1 = 0x1
	// Position of DHREQ field.
	MCM_ISCR_DHREQ_Pos = 0x3
	// Bit mask of DHREQ field.
	MCM_ISCR_DHREQ_Msk = 0x8
	// Bit DHREQ.
	MCM_ISCR_DHREQ = 0x8
	// No debug halt request
	MCM_ISCR_DHREQ_0 = 0x0
	// Debug halt request initiated
	MCM_ISCR_DHREQ_1 = 0x1
	// Position of FIOC field.
	MCM_ISCR_FIOC_Pos = 0x8
	// Bit mask of FIOC field.
	MCM_ISCR_FIOC_Msk = 0x100
	// Bit FIOC.
	MCM_ISCR_FIOC = 0x100
	// No interrupt
	MCM_ISCR_FIOC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FIOC_1 = 0x1
	// Position of FDZC field.
	MCM_ISCR_FDZC_Pos = 0x9
	// Bit mask of FDZC field.
	MCM_ISCR_FDZC_Msk = 0x200
	// Bit FDZC.
	MCM_ISCR_FDZC = 0x200
	// No interrupt
	MCM_ISCR_FDZC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FDZC_1 = 0x1
	// Position of FOFC field.
	MCM_ISCR_FOFC_Pos = 0xa
	// Bit mask of FOFC field.
	MCM_ISCR_FOFC_Msk = 0x400
	// Bit FOFC.
	MCM_ISCR_FOFC = 0x400
	// No interrupt
	MCM_ISCR_FOFC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FOFC_1 = 0x1
	// Position of FUFC field.
	MCM_ISCR_FUFC_Pos = 0xb
	// Bit mask of FUFC field.
	MCM_ISCR_FUFC_Msk = 0x800
	// Bit FUFC.
	MCM_ISCR_FUFC = 0x800
	// No interrupt
	MCM_ISCR_FUFC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FUFC_1 = 0x1
	// Position of FIXC field.
	MCM_ISCR_FIXC_Pos = 0xc
	// Bit mask of FIXC field.
	MCM_ISCR_FIXC_Msk = 0x1000
	// Bit FIXC.
	MCM_ISCR_FIXC = 0x1000
	// No interrupt
	MCM_ISCR_FIXC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FIXC_1 = 0x1
	// Position of FIDC field.
	MCM_ISCR_FIDC_Pos = 0xf
	// Bit mask of FIDC field.
	MCM_ISCR_FIDC_Msk = 0x8000
	// Bit FIDC.
	MCM_ISCR_FIDC = 0x8000
	// No interrupt
	MCM_ISCR_FIDC_0 = 0x0
	// Interrupt occurred
	MCM_ISCR_FIDC_1 = 0x1
	// Position of FIOCE field.
	MCM_ISCR_FIOCE_Pos = 0x18
	// Bit mask of FIOCE field.
	MCM_ISCR_FIOCE_Msk = 0x1000000
	// Bit FIOCE.
	MCM_ISCR_FIOCE = 0x1000000
	// Disable interrupt
	MCM_ISCR_FIOCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FIOCE_1 = 0x1
	// Position of FDZCE field.
	MCM_ISCR_FDZCE_Pos = 0x19
	// Bit mask of FDZCE field.
	MCM_ISCR_FDZCE_Msk = 0x2000000
	// Bit FDZCE.
	MCM_ISCR_FDZCE = 0x2000000
	// Disable interrupt
	MCM_ISCR_FDZCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FDZCE_1 = 0x1
	// Position of FOFCE field.
	MCM_ISCR_FOFCE_Pos = 0x1a
	// Bit mask of FOFCE field.
	MCM_ISCR_FOFCE_Msk = 0x4000000
	// Bit FOFCE.
	MCM_ISCR_FOFCE = 0x4000000
	// Disable interrupt
	MCM_ISCR_FOFCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FOFCE_1 = 0x1
	// Position of FUFCE field.
	MCM_ISCR_FUFCE_Pos = 0x1b
	// Bit mask of FUFCE field.
	MCM_ISCR_FUFCE_Msk = 0x8000000
	// Bit FUFCE.
	MCM_ISCR_FUFCE = 0x8000000
	// Disable interrupt
	MCM_ISCR_FUFCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FUFCE_1 = 0x1
	// Position of FIXCE field.
	MCM_ISCR_FIXCE_Pos = 0x1c
	// Bit mask of FIXCE field.
	MCM_ISCR_FIXCE_Msk = 0x10000000
	// Bit FIXCE.
	MCM_ISCR_FIXCE = 0x10000000
	// Disable interrupt
	MCM_ISCR_FIXCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FIXCE_1 = 0x1
	// Position of FIDCE field.
	MCM_ISCR_FIDCE_Pos = 0x1f
	// Bit mask of FIDCE field.
	MCM_ISCR_FIDCE_Msk = 0x80000000
	// Bit FIDCE.
	MCM_ISCR_FIDCE = 0x80000000
	// Disable interrupt
	MCM_ISCR_FIDCE_0 = 0x0
	// Enable interrupt
	MCM_ISCR_FIDCE_1 = 0x1

	// ETBCC: ETB Counter Control register
	// Position of CNTEN field.
	MCM_ETBCC_CNTEN_Pos = 0x0
	// Bit mask of CNTEN field.
	MCM_ETBCC_CNTEN_Msk = 0x1
	// Bit CNTEN.
	MCM_ETBCC_CNTEN = 0x1
	// ETB counter disabled
	MCM_ETBCC_CNTEN_0 = 0x0
	// ETB counter enabled
	MCM_ETBCC_CNTEN_1 = 0x1
	// Position of RSPT field.
	MCM_ETBCC_RSPT_Pos = 0x1
	// Bit mask of RSPT field.
	MCM_ETBCC_RSPT_Msk = 0x6
	// No response when the ETB count expires
	MCM_ETBCC_RSPT_00 = 0x0
	// Generate a normal interrupt when the ETB count expires
	MCM_ETBCC_RSPT_01 = 0x1
	// Generate an NMI when the ETB count expires
	MCM_ETBCC_RSPT_10 = 0x2
	// Generate a debug halt when the ETB count expires
	MCM_ETBCC_RSPT_11 = 0x3
	// Position of RLRQ field.
	MCM_ETBCC_RLRQ_Pos = 0x3
	// Bit mask of RLRQ field.
	MCM_ETBCC_RLRQ_Msk = 0x8
	// Bit RLRQ.
	MCM_ETBCC_RLRQ = 0x8
	// No effect
	MCM_ETBCC_RLRQ_0 = 0x0
	// Clears pending debug halt, NMI, or IRQ interrupt requests
	MCM_ETBCC_RLRQ_1 = 0x1
	// Position of ETDIS field.
	MCM_ETBCC_ETDIS_Pos = 0x4
	// Bit mask of ETDIS field.
	MCM_ETBCC_ETDIS_Msk = 0x10
	// Bit ETDIS.
	MCM_ETBCC_ETDIS = 0x10
	// ETM-to-TPIU trace path enabled
	MCM_ETBCC_ETDIS_0 = 0x0
	// ETM-to-TPIU trace path disabled
	MCM_ETBCC_ETDIS_1 = 0x1
	// Position of ITDIS field.
	MCM_ETBCC_ITDIS_Pos = 0x5
	// Bit mask of ITDIS field.
	MCM_ETBCC_ITDIS_Msk = 0x20
	// Bit ITDIS.
	MCM_ETBCC_ITDIS = 0x20
	// ITM-to-TPIU trace path enabled
	MCM_ETBCC_ITDIS_0 = 0x0
	// ITM-to-TPIU trace path disabled
	MCM_ETBCC_ITDIS_1 = 0x1

	// ETBRL: ETB Reload register
	// Position of RELOAD field.
	MCM_ETBRL_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	MCM_ETBRL_RELOAD_Msk = 0x7ff

	// ETBCNT: ETB Counter Value register
	// Position of COUNTER field.
	MCM_ETBCNT_COUNTER_Pos = 0x0
	// Bit mask of COUNTER field.
	MCM_ETBCNT_COUNTER_Msk = 0x7ff

	// FADR: Fault address register
	// Position of ADDRESS field.
	MCM_FADR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	MCM_FADR_ADDRESS_Msk = 0xffffffff

	// FATR: Fault attributes register
	// Position of BEDA field.
	MCM_FATR_BEDA_Pos = 0x0
	// Bit mask of BEDA field.
	MCM_FATR_BEDA_Msk = 0x1
	// Bit BEDA.
	MCM_FATR_BEDA = 0x1
	// Instruction
	MCM_FATR_BEDA_0 = 0x0
	// Data
	MCM_FATR_BEDA_1 = 0x1
	// Position of BEMD field.
	MCM_FATR_BEMD_Pos = 0x1
	// Bit mask of BEMD field.
	MCM_FATR_BEMD_Msk = 0x2
	// Bit BEMD.
	MCM_FATR_BEMD = 0x2
	// User mode
	MCM_FATR_BEMD_0 = 0x0
	// Supervisor/privileged mode
	MCM_FATR_BEMD_1 = 0x1
	// Position of BESZ field.
	MCM_FATR_BESZ_Pos = 0x4
	// Bit mask of BESZ field.
	MCM_FATR_BESZ_Msk = 0x30
	// 8-bit access
	MCM_FATR_BESZ_00 = 0x0
	// 16-bit access
	MCM_FATR_BESZ_01 = 0x1
	// 32-bit access
	MCM_FATR_BESZ_10 = 0x2
	// Position of BEWT field.
	MCM_FATR_BEWT_Pos = 0x7
	// Bit mask of BEWT field.
	MCM_FATR_BEWT_Msk = 0x80
	// Bit BEWT.
	MCM_FATR_BEWT = 0x80
	// Read access
	MCM_FATR_BEWT_0 = 0x0
	// Write access
	MCM_FATR_BEWT_1 = 0x1
	// Position of BEMN field.
	MCM_FATR_BEMN_Pos = 0x8
	// Bit mask of BEMN field.
	MCM_FATR_BEMN_Msk = 0xf00
	// Position of BEOVR field.
	MCM_FATR_BEOVR_Pos = 0x1f
	// Bit mask of BEOVR field.
	MCM_FATR_BEOVR_Msk = 0x80000000
	// Bit BEOVR.
	MCM_FATR_BEOVR = 0x80000000
	// No bus error overrun
	MCM_FATR_BEOVR_0 = 0x0
	// Bus error overrun occurred. The FADR and FDR registers and the other FATR bits are not updated to reflect this new bus error.
	MCM_FATR_BEOVR_1 = 0x1

	// FDR: Fault data register
	// Position of DATA field.
	MCM_FDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	MCM_FDR_DATA_Msk = 0xffffffff

	// PID: Process ID register
	// Position of PID field.
	MCM_PID_PID_Pos = 0x0
	// Bit mask of PID field.
	MCM_PID_PID_Msk = 0xff

	// CPO: Compute Operation Control Register
	// Position of CPOREQ field.
	MCM_CPO_CPOREQ_Pos = 0x0
	// Bit mask of CPOREQ field.
	MCM_CPO_CPOREQ_Msk = 0x1
	// Bit CPOREQ.
	MCM_CPO_CPOREQ = 0x1
	// Request is cleared.
	MCM_CPO_CPOREQ_0 = 0x0
	// Request Compute Operation.
	MCM_CPO_CPOREQ_1 = 0x1
	// Position of CPOACK field.
	MCM_CPO_CPOACK_Pos = 0x1
	// Bit mask of CPOACK field.
	MCM_CPO_CPOACK_Msk = 0x2
	// Bit CPOACK.
	MCM_CPO_CPOACK = 0x2
	// Compute operation entry has not completed or compute operation exit has completed.
	MCM_CPO_CPOACK_0 = 0x0
	// Compute operation entry has completed or compute operation exit has not completed.
	MCM_CPO_CPOACK_1 = 0x1
	// Position of CPOWOI field.
	MCM_CPO_CPOWOI_Pos = 0x2
	// Bit mask of CPOWOI field.
	MCM_CPO_CPOWOI_Msk = 0x4
	// Bit CPOWOI.
	MCM_CPO_CPOWOI = 0x4
	// No effect.
	MCM_CPO_CPOWOI_0 = 0x0
	// When set, the CPOREQ is cleared on any interrupt or exception vector fetch.
	MCM_CPO_CPOWOI_1 = 0x1
)

// Constants for CAU: Memory Mapped Cryptographic Acceleration Unit (MMCAU)
const (
	// CAU_DIRECT0: Direct access register 0
	// Position of CAU_DIRECT0 field.
	CAU_CAU_DIRECT0_CAU_DIRECT0_Pos = 0x0
	// Bit mask of CAU_DIRECT0 field.
	CAU_CAU_DIRECT0_CAU_DIRECT0_Msk = 0xffffffff

	// CAU_DIRECT1: Direct access register 1
	// Position of CAU_DIRECT1 field.
	CAU_CAU_DIRECT1_CAU_DIRECT1_Pos = 0x0
	// Bit mask of CAU_DIRECT1 field.
	CAU_CAU_DIRECT1_CAU_DIRECT1_Msk = 0xffffffff

	// CAU_DIRECT2: Direct access register 2
	// Position of CAU_DIRECT2 field.
	CAU_CAU_DIRECT2_CAU_DIRECT2_Pos = 0x0
	// Bit mask of CAU_DIRECT2 field.
	CAU_CAU_DIRECT2_CAU_DIRECT2_Msk = 0xffffffff

	// CAU_DIRECT3: Direct access register 3
	// Position of CAU_DIRECT3 field.
	CAU_CAU_DIRECT3_CAU_DIRECT3_Pos = 0x0
	// Bit mask of CAU_DIRECT3 field.
	CAU_CAU_DIRECT3_CAU_DIRECT3_Msk = 0xffffffff

	// CAU_DIRECT4: Direct access register 4
	// Position of CAU_DIRECT4 field.
	CAU_CAU_DIRECT4_CAU_DIRECT4_Pos = 0x0
	// Bit mask of CAU_DIRECT4 field.
	CAU_CAU_DIRECT4_CAU_DIRECT4_Msk = 0xffffffff

	// CAU_DIRECT5: Direct access register 5
	// Position of CAU_DIRECT5 field.
	CAU_CAU_DIRECT5_CAU_DIRECT5_Pos = 0x0
	// Bit mask of CAU_DIRECT5 field.
	CAU_CAU_DIRECT5_CAU_DIRECT5_Msk = 0xffffffff

	// CAU_DIRECT6: Direct access register 6
	// Position of CAU_DIRECT6 field.
	CAU_CAU_DIRECT6_CAU_DIRECT6_Pos = 0x0
	// Bit mask of CAU_DIRECT6 field.
	CAU_CAU_DIRECT6_CAU_DIRECT6_Msk = 0xffffffff

	// CAU_DIRECT7: Direct access register 7
	// Position of CAU_DIRECT7 field.
	CAU_CAU_DIRECT7_CAU_DIRECT7_Pos = 0x0
	// Bit mask of CAU_DIRECT7 field.
	CAU_CAU_DIRECT7_CAU_DIRECT7_Msk = 0xffffffff

	// CAU_DIRECT8: Direct access register 8
	// Position of CAU_DIRECT8 field.
	CAU_CAU_DIRECT8_CAU_DIRECT8_Pos = 0x0
	// Bit mask of CAU_DIRECT8 field.
	CAU_CAU_DIRECT8_CAU_DIRECT8_Msk = 0xffffffff

	// CAU_DIRECT9: Direct access register 9
	// Position of CAU_DIRECT9 field.
	CAU_CAU_DIRECT9_CAU_DIRECT9_Pos = 0x0
	// Bit mask of CAU_DIRECT9 field.
	CAU_CAU_DIRECT9_CAU_DIRECT9_Msk = 0xffffffff

	// CAU_DIRECT10: Direct access register 10
	// Position of CAU_DIRECT10 field.
	CAU_CAU_DIRECT10_CAU_DIRECT10_Pos = 0x0
	// Bit mask of CAU_DIRECT10 field.
	CAU_CAU_DIRECT10_CAU_DIRECT10_Msk = 0xffffffff

	// CAU_DIRECT11: Direct access register 11
	// Position of CAU_DIRECT11 field.
	CAU_CAU_DIRECT11_CAU_DIRECT11_Pos = 0x0
	// Bit mask of CAU_DIRECT11 field.
	CAU_CAU_DIRECT11_CAU_DIRECT11_Msk = 0xffffffff

	// CAU_DIRECT12: Direct access register 12
	// Position of CAU_DIRECT12 field.
	CAU_CAU_DIRECT12_CAU_DIRECT12_Pos = 0x0
	// Bit mask of CAU_DIRECT12 field.
	CAU_CAU_DIRECT12_CAU_DIRECT12_Msk = 0xffffffff

	// CAU_DIRECT13: Direct access register 13
	// Position of CAU_DIRECT13 field.
	CAU_CAU_DIRECT13_CAU_DIRECT13_Pos = 0x0
	// Bit mask of CAU_DIRECT13 field.
	CAU_CAU_DIRECT13_CAU_DIRECT13_Msk = 0xffffffff

	// CAU_DIRECT14: Direct access register 14
	// Position of CAU_DIRECT14 field.
	CAU_CAU_DIRECT14_CAU_DIRECT14_Pos = 0x0
	// Bit mask of CAU_DIRECT14 field.
	CAU_CAU_DIRECT14_CAU_DIRECT14_Msk = 0xffffffff

	// CAU_DIRECT15: Direct access register 15
	// Position of CAU_DIRECT15 field.
	CAU_CAU_DIRECT15_CAU_DIRECT15_Pos = 0x0
	// Bit mask of CAU_DIRECT15 field.
	CAU_CAU_DIRECT15_CAU_DIRECT15_Msk = 0xffffffff

	// CAU_LDR_CASR: Status register - Load Register command
	// Position of IC field.
	CAU_CAU_LDR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_LDR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_LDR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_LDR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_LDR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_LDR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_LDR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_LDR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_LDR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_LDR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_LDR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_LDR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_LDR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_LDR_CASR_VER_0010 = 0x2

	// CAU_LDR_CAA: Accumulator register - Load Register command
	// Position of ACC field.
	CAU_CAU_LDR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_LDR_CAA_ACC_Msk = 0xffffffff

	// CAU_LDR_CA0: General Purpose Register 0 - Load Register command
	// Position of CA0 field.
	CAU_CAU_LDR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_LDR_CA0_CA0_Msk = 0xffffffff

	// CAU_LDR_CA1: General Purpose Register 1 - Load Register command
	// Position of CA1 field.
	CAU_CAU_LDR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_LDR_CA1_CA1_Msk = 0xffffffff

	// CAU_LDR_CA2: General Purpose Register 2 - Load Register command
	// Position of CA2 field.
	CAU_CAU_LDR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_LDR_CA2_CA2_Msk = 0xffffffff

	// CAU_LDR_CA3: General Purpose Register 3 - Load Register command
	// Position of CA3 field.
	CAU_CAU_LDR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_LDR_CA3_CA3_Msk = 0xffffffff

	// CAU_LDR_CA4: General Purpose Register 4 - Load Register command
	// Position of CA4 field.
	CAU_CAU_LDR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_LDR_CA4_CA4_Msk = 0xffffffff

	// CAU_LDR_CA5: General Purpose Register 5 - Load Register command
	// Position of CA5 field.
	CAU_CAU_LDR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_LDR_CA5_CA5_Msk = 0xffffffff

	// CAU_LDR_CA6: General Purpose Register 6 - Load Register command
	// Position of CA6 field.
	CAU_CAU_LDR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_LDR_CA6_CA6_Msk = 0xffffffff

	// CAU_LDR_CA7: General Purpose Register 7 - Load Register command
	// Position of CA7 field.
	CAU_CAU_LDR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_LDR_CA7_CA7_Msk = 0xffffffff

	// CAU_LDR_CA8: General Purpose Register 8 - Load Register command
	// Position of CA8 field.
	CAU_CAU_LDR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_LDR_CA8_CA8_Msk = 0xffffffff

	// CAU_STR_CASR: Status register - Store Register command
	// Position of IC field.
	CAU_CAU_STR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_STR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_STR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_STR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_STR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_STR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_STR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_STR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_STR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_STR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_STR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_STR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_STR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_STR_CASR_VER_0010 = 0x2

	// CAU_STR_CAA: Accumulator register - Store Register command
	// Position of ACC field.
	CAU_CAU_STR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_STR_CAA_ACC_Msk = 0xffffffff

	// CAU_STR_CA0: General Purpose Register 0 - Store Register command
	// Position of CA0 field.
	CAU_CAU_STR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_STR_CA0_CA0_Msk = 0xffffffff

	// CAU_STR_CA1: General Purpose Register 1 - Store Register command
	// Position of CA1 field.
	CAU_CAU_STR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_STR_CA1_CA1_Msk = 0xffffffff

	// CAU_STR_CA2: General Purpose Register 2 - Store Register command
	// Position of CA2 field.
	CAU_CAU_STR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_STR_CA2_CA2_Msk = 0xffffffff

	// CAU_STR_CA3: General Purpose Register 3 - Store Register command
	// Position of CA3 field.
	CAU_CAU_STR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_STR_CA3_CA3_Msk = 0xffffffff

	// CAU_STR_CA4: General Purpose Register 4 - Store Register command
	// Position of CA4 field.
	CAU_CAU_STR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_STR_CA4_CA4_Msk = 0xffffffff

	// CAU_STR_CA5: General Purpose Register 5 - Store Register command
	// Position of CA5 field.
	CAU_CAU_STR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_STR_CA5_CA5_Msk = 0xffffffff

	// CAU_STR_CA6: General Purpose Register 6 - Store Register command
	// Position of CA6 field.
	CAU_CAU_STR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_STR_CA6_CA6_Msk = 0xffffffff

	// CAU_STR_CA7: General Purpose Register 7 - Store Register command
	// Position of CA7 field.
	CAU_CAU_STR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_STR_CA7_CA7_Msk = 0xffffffff

	// CAU_STR_CA8: General Purpose Register 8 - Store Register command
	// Position of CA8 field.
	CAU_CAU_STR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_STR_CA8_CA8_Msk = 0xffffffff

	// CAU_ADR_CASR: Status register - Add Register command
	// Position of IC field.
	CAU_CAU_ADR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_ADR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_ADR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_ADR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_ADR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_ADR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_ADR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_ADR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_ADR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_ADR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_ADR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_ADR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_ADR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_ADR_CASR_VER_0010 = 0x2

	// CAU_ADR_CAA: Accumulator register - Add to register command
	// Position of ACC field.
	CAU_CAU_ADR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_ADR_CAA_ACC_Msk = 0xffffffff

	// CAU_ADR_CA0: General Purpose Register 0 - Add to register command
	// Position of CA0 field.
	CAU_CAU_ADR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_ADR_CA0_CA0_Msk = 0xffffffff

	// CAU_ADR_CA1: General Purpose Register 1 - Add to register command
	// Position of CA1 field.
	CAU_CAU_ADR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_ADR_CA1_CA1_Msk = 0xffffffff

	// CAU_ADR_CA2: General Purpose Register 2 - Add to register command
	// Position of CA2 field.
	CAU_CAU_ADR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_ADR_CA2_CA2_Msk = 0xffffffff

	// CAU_ADR_CA3: General Purpose Register 3 - Add to register command
	// Position of CA3 field.
	CAU_CAU_ADR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_ADR_CA3_CA3_Msk = 0xffffffff

	// CAU_ADR_CA4: General Purpose Register 4 - Add to register command
	// Position of CA4 field.
	CAU_CAU_ADR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_ADR_CA4_CA4_Msk = 0xffffffff

	// CAU_ADR_CA5: General Purpose Register 5 - Add to register command
	// Position of CA5 field.
	CAU_CAU_ADR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_ADR_CA5_CA5_Msk = 0xffffffff

	// CAU_ADR_CA6: General Purpose Register 6 - Add to register command
	// Position of CA6 field.
	CAU_CAU_ADR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_ADR_CA6_CA6_Msk = 0xffffffff

	// CAU_ADR_CA7: General Purpose Register 7 - Add to register command
	// Position of CA7 field.
	CAU_CAU_ADR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_ADR_CA7_CA7_Msk = 0xffffffff

	// CAU_ADR_CA8: General Purpose Register 8 - Add to register command
	// Position of CA8 field.
	CAU_CAU_ADR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_ADR_CA8_CA8_Msk = 0xffffffff

	// CAU_RADR_CASR: Status register - Reverse and Add to Register command
	// Position of IC field.
	CAU_CAU_RADR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_RADR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_RADR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_RADR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_RADR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_RADR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_RADR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_RADR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_RADR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_RADR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_RADR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_RADR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_RADR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_RADR_CASR_VER_0010 = 0x2

	// CAU_RADR_CAA: Accumulator register - Reverse and Add to Register command
	// Position of ACC field.
	CAU_CAU_RADR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_RADR_CAA_ACC_Msk = 0xffffffff

	// CAU_RADR_CA0: General Purpose Register 0 - Reverse and Add to Register command
	// Position of CA0 field.
	CAU_CAU_RADR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_RADR_CA0_CA0_Msk = 0xffffffff

	// CAU_RADR_CA1: General Purpose Register 1 - Reverse and Add to Register command
	// Position of CA1 field.
	CAU_CAU_RADR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_RADR_CA1_CA1_Msk = 0xffffffff

	// CAU_RADR_CA2: General Purpose Register 2 - Reverse and Add to Register command
	// Position of CA2 field.
	CAU_CAU_RADR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_RADR_CA2_CA2_Msk = 0xffffffff

	// CAU_RADR_CA3: General Purpose Register 3 - Reverse and Add to Register command
	// Position of CA3 field.
	CAU_CAU_RADR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_RADR_CA3_CA3_Msk = 0xffffffff

	// CAU_RADR_CA4: General Purpose Register 4 - Reverse and Add to Register command
	// Position of CA4 field.
	CAU_CAU_RADR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_RADR_CA4_CA4_Msk = 0xffffffff

	// CAU_RADR_CA5: General Purpose Register 5 - Reverse and Add to Register command
	// Position of CA5 field.
	CAU_CAU_RADR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_RADR_CA5_CA5_Msk = 0xffffffff

	// CAU_RADR_CA6: General Purpose Register 6 - Reverse and Add to Register command
	// Position of CA6 field.
	CAU_CAU_RADR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_RADR_CA6_CA6_Msk = 0xffffffff

	// CAU_RADR_CA7: General Purpose Register 7 - Reverse and Add to Register command
	// Position of CA7 field.
	CAU_CAU_RADR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_RADR_CA7_CA7_Msk = 0xffffffff

	// CAU_RADR_CA8: General Purpose Register 8 - Reverse and Add to Register command
	// Position of CA8 field.
	CAU_CAU_RADR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_RADR_CA8_CA8_Msk = 0xffffffff

	// CAU_XOR_CASR: Status register - Exclusive Or command
	// Position of IC field.
	CAU_CAU_XOR_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_XOR_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_XOR_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_XOR_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_XOR_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_XOR_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_XOR_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_XOR_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_XOR_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_XOR_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_XOR_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_XOR_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_XOR_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_XOR_CASR_VER_0010 = 0x2

	// CAU_XOR_CAA: Accumulator register - Exclusive Or command
	// Position of ACC field.
	CAU_CAU_XOR_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_XOR_CAA_ACC_Msk = 0xffffffff

	// CAU_XOR_CA0: General Purpose Register 0 - Exclusive Or command
	// Position of CA0 field.
	CAU_CAU_XOR_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_XOR_CA0_CA0_Msk = 0xffffffff

	// CAU_XOR_CA1: General Purpose Register 1 - Exclusive Or command
	// Position of CA1 field.
	CAU_CAU_XOR_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_XOR_CA1_CA1_Msk = 0xffffffff

	// CAU_XOR_CA2: General Purpose Register 2 - Exclusive Or command
	// Position of CA2 field.
	CAU_CAU_XOR_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_XOR_CA2_CA2_Msk = 0xffffffff

	// CAU_XOR_CA3: General Purpose Register 3 - Exclusive Or command
	// Position of CA3 field.
	CAU_CAU_XOR_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_XOR_CA3_CA3_Msk = 0xffffffff

	// CAU_XOR_CA4: General Purpose Register 4 - Exclusive Or command
	// Position of CA4 field.
	CAU_CAU_XOR_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_XOR_CA4_CA4_Msk = 0xffffffff

	// CAU_XOR_CA5: General Purpose Register 5 - Exclusive Or command
	// Position of CA5 field.
	CAU_CAU_XOR_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_XOR_CA5_CA5_Msk = 0xffffffff

	// CAU_XOR_CA6: General Purpose Register 6 - Exclusive Or command
	// Position of CA6 field.
	CAU_CAU_XOR_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_XOR_CA6_CA6_Msk = 0xffffffff

	// CAU_XOR_CA7: General Purpose Register 7 - Exclusive Or command
	// Position of CA7 field.
	CAU_CAU_XOR_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_XOR_CA7_CA7_Msk = 0xffffffff

	// CAU_XOR_CA8: General Purpose Register 8 - Exclusive Or command
	// Position of CA8 field.
	CAU_CAU_XOR_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_XOR_CA8_CA8_Msk = 0xffffffff

	// CAU_ROTL_CASR: Status register - Rotate Left command
	// Position of IC field.
	CAU_CAU_ROTL_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_ROTL_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_ROTL_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_ROTL_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_ROTL_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_ROTL_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_ROTL_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_ROTL_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_ROTL_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_ROTL_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_ROTL_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_ROTL_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_ROTL_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_ROTL_CASR_VER_0010 = 0x2

	// CAU_ROTL_CAA: Accumulator register - Rotate Left command
	// Position of ACC field.
	CAU_CAU_ROTL_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_ROTL_CAA_ACC_Msk = 0xffffffff

	// CAU_ROTL_CA0: General Purpose Register 0 - Rotate Left command
	// Position of CA0 field.
	CAU_CAU_ROTL_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_ROTL_CA0_CA0_Msk = 0xffffffff

	// CAU_ROTL_CA1: General Purpose Register 1 - Rotate Left command
	// Position of CA1 field.
	CAU_CAU_ROTL_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_ROTL_CA1_CA1_Msk = 0xffffffff

	// CAU_ROTL_CA2: General Purpose Register 2 - Rotate Left command
	// Position of CA2 field.
	CAU_CAU_ROTL_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_ROTL_CA2_CA2_Msk = 0xffffffff

	// CAU_ROTL_CA3: General Purpose Register 3 - Rotate Left command
	// Position of CA3 field.
	CAU_CAU_ROTL_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_ROTL_CA3_CA3_Msk = 0xffffffff

	// CAU_ROTL_CA4: General Purpose Register 4 - Rotate Left command
	// Position of CA4 field.
	CAU_CAU_ROTL_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_ROTL_CA4_CA4_Msk = 0xffffffff

	// CAU_ROTL_CA5: General Purpose Register 5 - Rotate Left command
	// Position of CA5 field.
	CAU_CAU_ROTL_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_ROTL_CA5_CA5_Msk = 0xffffffff

	// CAU_ROTL_CA6: General Purpose Register 6 - Rotate Left command
	// Position of CA6 field.
	CAU_CAU_ROTL_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_ROTL_CA6_CA6_Msk = 0xffffffff

	// CAU_ROTL_CA7: General Purpose Register 7 - Rotate Left command
	// Position of CA7 field.
	CAU_CAU_ROTL_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_ROTL_CA7_CA7_Msk = 0xffffffff

	// CAU_ROTL_CA8: General Purpose Register 8 - Rotate Left command
	// Position of CA8 field.
	CAU_CAU_ROTL_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_ROTL_CA8_CA8_Msk = 0xffffffff

	// CAU_AESC_CASR: Status register - AES Column Operation command
	// Position of IC field.
	CAU_CAU_AESC_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_AESC_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_AESC_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_AESC_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_AESC_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_AESC_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_AESC_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_AESC_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_AESC_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_AESC_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_AESC_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_AESC_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_AESC_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_AESC_CASR_VER_0010 = 0x2

	// CAU_AESC_CAA: Accumulator register - AES Column Operation command
	// Position of ACC field.
	CAU_CAU_AESC_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_AESC_CAA_ACC_Msk = 0xffffffff

	// CAU_AESC_CA0: General Purpose Register 0 - AES Column Operation command
	// Position of CA0 field.
	CAU_CAU_AESC_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_AESC_CA0_CA0_Msk = 0xffffffff

	// CAU_AESC_CA1: General Purpose Register 1 - AES Column Operation command
	// Position of CA1 field.
	CAU_CAU_AESC_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_AESC_CA1_CA1_Msk = 0xffffffff

	// CAU_AESC_CA2: General Purpose Register 2 - AES Column Operation command
	// Position of CA2 field.
	CAU_CAU_AESC_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_AESC_CA2_CA2_Msk = 0xffffffff

	// CAU_AESC_CA3: General Purpose Register 3 - AES Column Operation command
	// Position of CA3 field.
	CAU_CAU_AESC_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_AESC_CA3_CA3_Msk = 0xffffffff

	// CAU_AESC_CA4: General Purpose Register 4 - AES Column Operation command
	// Position of CA4 field.
	CAU_CAU_AESC_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_AESC_CA4_CA4_Msk = 0xffffffff

	// CAU_AESC_CA5: General Purpose Register 5 - AES Column Operation command
	// Position of CA5 field.
	CAU_CAU_AESC_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_AESC_CA5_CA5_Msk = 0xffffffff

	// CAU_AESC_CA6: General Purpose Register 6 - AES Column Operation command
	// Position of CA6 field.
	CAU_CAU_AESC_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_AESC_CA6_CA6_Msk = 0xffffffff

	// CAU_AESC_CA7: General Purpose Register 7 - AES Column Operation command
	// Position of CA7 field.
	CAU_CAU_AESC_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_AESC_CA7_CA7_Msk = 0xffffffff

	// CAU_AESC_CA8: General Purpose Register 8 - AES Column Operation command
	// Position of CA8 field.
	CAU_CAU_AESC_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_AESC_CA8_CA8_Msk = 0xffffffff

	// CAU_AESIC_CASR: Status register - AES Inverse Column Operation command
	// Position of IC field.
	CAU_CAU_AESIC_CASR_IC_Pos = 0x0
	// Bit mask of IC field.
	CAU_CAU_AESIC_CASR_IC_Msk = 0x1
	// Bit IC.
	CAU_CAU_AESIC_CASR_IC = 0x1
	// No illegal commands issued
	CAU_CAU_AESIC_CASR_IC_0 = 0x0
	// Illegal command issued
	CAU_CAU_AESIC_CASR_IC_1 = 0x1
	// Position of DPE field.
	CAU_CAU_AESIC_CASR_DPE_Pos = 0x1
	// Bit mask of DPE field.
	CAU_CAU_AESIC_CASR_DPE_Msk = 0x2
	// Bit DPE.
	CAU_CAU_AESIC_CASR_DPE = 0x2
	// No error detected
	CAU_CAU_AESIC_CASR_DPE_0 = 0x0
	// DES key parity error detected
	CAU_CAU_AESIC_CASR_DPE_1 = 0x1
	// Position of VER field.
	CAU_CAU_AESIC_CASR_VER_Pos = 0x1c
	// Bit mask of VER field.
	CAU_CAU_AESIC_CASR_VER_Msk = 0xf0000000
	// Initial CAU version
	CAU_CAU_AESIC_CASR_VER_0001 = 0x1
	// Second version, added support for SHA-256 algorithm.(This is the value on this device)
	CAU_CAU_AESIC_CASR_VER_0010 = 0x2

	// CAU_AESIC_CAA: Accumulator register - AES Inverse Column Operation command
	// Position of ACC field.
	CAU_CAU_AESIC_CAA_ACC_Pos = 0x0
	// Bit mask of ACC field.
	CAU_CAU_AESIC_CAA_ACC_Msk = 0xffffffff

	// CAU_AESIC_CA0: General Purpose Register 0 - AES Inverse Column Operation command
	// Position of CA0 field.
	CAU_CAU_AESIC_CA0_CA0_Pos = 0x0
	// Bit mask of CA0 field.
	CAU_CAU_AESIC_CA0_CA0_Msk = 0xffffffff

	// CAU_AESIC_CA1: General Purpose Register 1 - AES Inverse Column Operation command
	// Position of CA1 field.
	CAU_CAU_AESIC_CA1_CA1_Pos = 0x0
	// Bit mask of CA1 field.
	CAU_CAU_AESIC_CA1_CA1_Msk = 0xffffffff

	// CAU_AESIC_CA2: General Purpose Register 2 - AES Inverse Column Operation command
	// Position of CA2 field.
	CAU_CAU_AESIC_CA2_CA2_Pos = 0x0
	// Bit mask of CA2 field.
	CAU_CAU_AESIC_CA2_CA2_Msk = 0xffffffff

	// CAU_AESIC_CA3: General Purpose Register 3 - AES Inverse Column Operation command
	// Position of CA3 field.
	CAU_CAU_AESIC_CA3_CA3_Pos = 0x0
	// Bit mask of CA3 field.
	CAU_CAU_AESIC_CA3_CA3_Msk = 0xffffffff

	// CAU_AESIC_CA4: General Purpose Register 4 - AES Inverse Column Operation command
	// Position of CA4 field.
	CAU_CAU_AESIC_CA4_CA4_Pos = 0x0
	// Bit mask of CA4 field.
	CAU_CAU_AESIC_CA4_CA4_Msk = 0xffffffff

	// CAU_AESIC_CA5: General Purpose Register 5 - AES Inverse Column Operation command
	// Position of CA5 field.
	CAU_CAU_AESIC_CA5_CA5_Pos = 0x0
	// Bit mask of CA5 field.
	CAU_CAU_AESIC_CA5_CA5_Msk = 0xffffffff

	// CAU_AESIC_CA6: General Purpose Register 6 - AES Inverse Column Operation command
	// Position of CA6 field.
	CAU_CAU_AESIC_CA6_CA6_Pos = 0x0
	// Bit mask of CA6 field.
	CAU_CAU_AESIC_CA6_CA6_Msk = 0xffffffff

	// CAU_AESIC_CA7: General Purpose Register 7 - AES Inverse Column Operation command
	// Position of CA7 field.
	CAU_CAU_AESIC_CA7_CA7_Pos = 0x0
	// Bit mask of CA7 field.
	CAU_CAU_AESIC_CA7_CA7_Msk = 0xffffffff

	// CAU_AESIC_CA8: General Purpose Register 8 - AES Inverse Column Operation command
	// Position of CA8 field.
	CAU_CAU_AESIC_CA8_CA8_Pos = 0x0
	// Bit mask of CA8 field.
	CAU_CAU_AESIC_CA8_CA8_Msk = 0xffffffff
)

// Constants for LMEM: Local Memory Controller
const (
	// PCCCR: Cache control register
	// Position of ENCACHE field.
	LMEM_PCCCR_ENCACHE_Pos = 0x0
	// Bit mask of ENCACHE field.
	LMEM_PCCCR_ENCACHE_Msk = 0x1
	// Bit ENCACHE.
	LMEM_PCCCR_ENCACHE = 0x1
	// Cache disabled
	LMEM_PCCCR_ENCACHE_0 = 0x0
	// Cache enabled
	LMEM_PCCCR_ENCACHE_1 = 0x1
	// Position of ENWRBUF field.
	LMEM_PCCCR_ENWRBUF_Pos = 0x1
	// Bit mask of ENWRBUF field.
	LMEM_PCCCR_ENWRBUF_Msk = 0x2
	// Bit ENWRBUF.
	LMEM_PCCCR_ENWRBUF = 0x2
	// Write buffer disabled
	LMEM_PCCCR_ENWRBUF_0 = 0x0
	// Write buffer enabled
	LMEM_PCCCR_ENWRBUF_1 = 0x1
	// Position of PCCR2 field.
	LMEM_PCCCR_PCCR2_Pos = 0x2
	// Bit mask of PCCR2 field.
	LMEM_PCCCR_PCCR2_Msk = 0x4
	// Bit PCCR2.
	LMEM_PCCCR_PCCR2 = 0x4
	// Position of PCCR3 field.
	LMEM_PCCCR_PCCR3_Pos = 0x3
	// Bit mask of PCCR3 field.
	LMEM_PCCCR_PCCR3_Msk = 0x8
	// Bit PCCR3.
	LMEM_PCCCR_PCCR3 = 0x8
	// Position of INVW0 field.
	LMEM_PCCCR_INVW0_Pos = 0x18
	// Bit mask of INVW0 field.
	LMEM_PCCCR_INVW0_Msk = 0x1000000
	// Bit INVW0.
	LMEM_PCCCR_INVW0 = 0x1000000
	// No operation
	LMEM_PCCCR_INVW0_0 = 0x0
	// When setting the GO bit, invalidate all lines in way 0.
	LMEM_PCCCR_INVW0_1 = 0x1
	// Position of PUSHW0 field.
	LMEM_PCCCR_PUSHW0_Pos = 0x19
	// Bit mask of PUSHW0 field.
	LMEM_PCCCR_PUSHW0_Msk = 0x2000000
	// Bit PUSHW0.
	LMEM_PCCCR_PUSHW0 = 0x2000000
	// No operation
	LMEM_PCCCR_PUSHW0_0 = 0x0
	// When setting the GO bit, push all modified lines in way 0
	LMEM_PCCCR_PUSHW0_1 = 0x1
	// Position of INVW1 field.
	LMEM_PCCCR_INVW1_Pos = 0x1a
	// Bit mask of INVW1 field.
	LMEM_PCCCR_INVW1_Msk = 0x4000000
	// Bit INVW1.
	LMEM_PCCCR_INVW1 = 0x4000000
	// No operation
	LMEM_PCCCR_INVW1_0 = 0x0
	// When setting the GO bit, invalidate all lines in way 1
	LMEM_PCCCR_INVW1_1 = 0x1
	// Position of PUSHW1 field.
	LMEM_PCCCR_PUSHW1_Pos = 0x1b
	// Bit mask of PUSHW1 field.
	LMEM_PCCCR_PUSHW1_Msk = 0x8000000
	// Bit PUSHW1.
	LMEM_PCCCR_PUSHW1 = 0x8000000
	// No operation
	LMEM_PCCCR_PUSHW1_0 = 0x0
	// When setting the GO bit, push all modified lines in way 1
	LMEM_PCCCR_PUSHW1_1 = 0x1
	// Position of GO field.
	LMEM_PCCCR_GO_Pos = 0x1f
	// Bit mask of GO field.
	LMEM_PCCCR_GO_Msk = 0x80000000
	// Bit GO.
	LMEM_PCCCR_GO = 0x80000000
	// Write: no effect. Read: no cache command active.
	LMEM_PCCCR_GO_0 = 0x0
	// Write: initiate command indicated by bits 27-24. Read: cache command active.
	LMEM_PCCCR_GO_1 = 0x1

	// PCCLCR: Cache line control register
	// Position of LGO field.
	LMEM_PCCLCR_LGO_Pos = 0x0
	// Bit mask of LGO field.
	LMEM_PCCLCR_LGO_Msk = 0x1
	// Bit LGO.
	LMEM_PCCLCR_LGO = 0x1
	// Write: no effect. Read: no line command active.
	LMEM_PCCLCR_LGO_0 = 0x0
	// Write: initiate line command indicated by bits 27-24. Read: line command active.
	LMEM_PCCLCR_LGO_1 = 0x1
	// Position of CACHEADDR field.
	LMEM_PCCLCR_CACHEADDR_Pos = 0x2
	// Bit mask of CACHEADDR field.
	LMEM_PCCLCR_CACHEADDR_Msk = 0xffc
	// Position of WSEL field.
	LMEM_PCCLCR_WSEL_Pos = 0xe
	// Bit mask of WSEL field.
	LMEM_PCCLCR_WSEL_Msk = 0x4000
	// Bit WSEL.
	LMEM_PCCLCR_WSEL = 0x4000
	// Way 0
	LMEM_PCCLCR_WSEL_0 = 0x0
	// Way 1
	LMEM_PCCLCR_WSEL_1 = 0x1
	// Position of TDSEL field.
	LMEM_PCCLCR_TDSEL_Pos = 0x10
	// Bit mask of TDSEL field.
	LMEM_PCCLCR_TDSEL_Msk = 0x10000
	// Bit TDSEL.
	LMEM_PCCLCR_TDSEL = 0x10000
	// Data
	LMEM_PCCLCR_TDSEL_0 = 0x0
	// Tag
	LMEM_PCCLCR_TDSEL_1 = 0x1
	// Position of LCIVB field.
	LMEM_PCCLCR_LCIVB_Pos = 0x14
	// Bit mask of LCIVB field.
	LMEM_PCCLCR_LCIVB_Msk = 0x100000
	// Bit LCIVB.
	LMEM_PCCLCR_LCIVB = 0x100000
	// Position of LCIMB field.
	LMEM_PCCLCR_LCIMB_Pos = 0x15
	// Bit mask of LCIMB field.
	LMEM_PCCLCR_LCIMB_Msk = 0x200000
	// Bit LCIMB.
	LMEM_PCCLCR_LCIMB = 0x200000
	// Position of LCWAY field.
	LMEM_PCCLCR_LCWAY_Pos = 0x16
	// Bit mask of LCWAY field.
	LMEM_PCCLCR_LCWAY_Msk = 0x400000
	// Bit LCWAY.
	LMEM_PCCLCR_LCWAY = 0x400000
	// Position of LCMD field.
	LMEM_PCCLCR_LCMD_Pos = 0x18
	// Bit mask of LCMD field.
	LMEM_PCCLCR_LCMD_Msk = 0x3000000
	// Search and read or write
	LMEM_PCCLCR_LCMD_00 = 0x0
	// Invalidate
	LMEM_PCCLCR_LCMD_01 = 0x1
	// Push
	LMEM_PCCLCR_LCMD_10 = 0x2
	// Clear
	LMEM_PCCLCR_LCMD_11 = 0x3
	// Position of LADSEL field.
	LMEM_PCCLCR_LADSEL_Pos = 0x1a
	// Bit mask of LADSEL field.
	LMEM_PCCLCR_LADSEL_Msk = 0x4000000
	// Bit LADSEL.
	LMEM_PCCLCR_LADSEL = 0x4000000
	// Cache address
	LMEM_PCCLCR_LADSEL_0 = 0x0
	// Physical address
	LMEM_PCCLCR_LADSEL_1 = 0x1
	// Position of LACC field.
	LMEM_PCCLCR_LACC_Pos = 0x1b
	// Bit mask of LACC field.
	LMEM_PCCLCR_LACC_Msk = 0x8000000
	// Bit LACC.
	LMEM_PCCLCR_LACC = 0x8000000
	// Read
	LMEM_PCCLCR_LACC_0 = 0x0
	// Write
	LMEM_PCCLCR_LACC_1 = 0x1

	// PCCSAR: Cache search address register
	// Position of LGO field.
	LMEM_PCCSAR_LGO_Pos = 0x0
	// Bit mask of LGO field.
	LMEM_PCCSAR_LGO_Msk = 0x1
	// Bit LGO.
	LMEM_PCCSAR_LGO = 0x1
	// Write: no effect. Read: no line command active.
	LMEM_PCCSAR_LGO_0 = 0x0
	// Write: initiate line command indicated by bits CLCR[27:24]. Read: line command active.
	LMEM_PCCSAR_LGO_1 = 0x1
	// Position of PHYADDR field.
	LMEM_PCCSAR_PHYADDR_Pos = 0x2
	// Bit mask of PHYADDR field.
	LMEM_PCCSAR_PHYADDR_Msk = 0xfffffffc

	// PCCCVR: Cache read/write value register
	// Position of DATA field.
	LMEM_PCCCVR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LMEM_PCCCVR_DATA_Msk = 0xffffffff

	// PCCRMR: Cache regions mode register
	// Position of R15 field.
	LMEM_PCCRMR_R15_Pos = 0x0
	// Bit mask of R15 field.
	LMEM_PCCRMR_R15_Msk = 0x3
	// Non-cacheable
	LMEM_PCCRMR_R15_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R15_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R15_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R15_11 = 0x3
	// Position of R14 field.
	LMEM_PCCRMR_R14_Pos = 0x2
	// Bit mask of R14 field.
	LMEM_PCCRMR_R14_Msk = 0xc
	// Non-cacheable
	LMEM_PCCRMR_R14_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R14_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R14_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R14_11 = 0x3
	// Position of R13 field.
	LMEM_PCCRMR_R13_Pos = 0x4
	// Bit mask of R13 field.
	LMEM_PCCRMR_R13_Msk = 0x30
	// Non-cacheable
	LMEM_PCCRMR_R13_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R13_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R13_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R13_11 = 0x3
	// Position of R12 field.
	LMEM_PCCRMR_R12_Pos = 0x6
	// Bit mask of R12 field.
	LMEM_PCCRMR_R12_Msk = 0xc0
	// Non-cacheable
	LMEM_PCCRMR_R12_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R12_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R12_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R12_11 = 0x3
	// Position of R11 field.
	LMEM_PCCRMR_R11_Pos = 0x8
	// Bit mask of R11 field.
	LMEM_PCCRMR_R11_Msk = 0x300
	// Non-cacheable
	LMEM_PCCRMR_R11_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R11_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R11_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R11_11 = 0x3
	// Position of R10 field.
	LMEM_PCCRMR_R10_Pos = 0xa
	// Bit mask of R10 field.
	LMEM_PCCRMR_R10_Msk = 0xc00
	// Non-cacheable
	LMEM_PCCRMR_R10_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R10_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R10_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R10_11 = 0x3
	// Position of R9 field.
	LMEM_PCCRMR_R9_Pos = 0xc
	// Bit mask of R9 field.
	LMEM_PCCRMR_R9_Msk = 0x3000
	// Non-cacheable
	LMEM_PCCRMR_R9_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R9_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R9_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R9_11 = 0x3
	// Position of R8 field.
	LMEM_PCCRMR_R8_Pos = 0xe
	// Bit mask of R8 field.
	LMEM_PCCRMR_R8_Msk = 0xc000
	// Non-cacheable
	LMEM_PCCRMR_R8_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R8_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R8_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R8_11 = 0x3
	// Position of R7 field.
	LMEM_PCCRMR_R7_Pos = 0x10
	// Bit mask of R7 field.
	LMEM_PCCRMR_R7_Msk = 0x30000
	// Non-cacheable
	LMEM_PCCRMR_R7_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R7_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R7_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R7_11 = 0x3
	// Position of R6 field.
	LMEM_PCCRMR_R6_Pos = 0x12
	// Bit mask of R6 field.
	LMEM_PCCRMR_R6_Msk = 0xc0000
	// Non-cacheable
	LMEM_PCCRMR_R6_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R6_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R6_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R6_11 = 0x3
	// Position of R5 field.
	LMEM_PCCRMR_R5_Pos = 0x14
	// Bit mask of R5 field.
	LMEM_PCCRMR_R5_Msk = 0x300000
	// Non-cacheable
	LMEM_PCCRMR_R5_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R5_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R5_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R5_11 = 0x3
	// Position of R4 field.
	LMEM_PCCRMR_R4_Pos = 0x16
	// Bit mask of R4 field.
	LMEM_PCCRMR_R4_Msk = 0xc00000
	// Non-cacheable
	LMEM_PCCRMR_R4_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R4_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R4_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R4_11 = 0x3
	// Position of R3 field.
	LMEM_PCCRMR_R3_Pos = 0x18
	// Bit mask of R3 field.
	LMEM_PCCRMR_R3_Msk = 0x3000000
	// Non-cacheable
	LMEM_PCCRMR_R3_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R3_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R3_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R3_11 = 0x3
	// Position of R2 field.
	LMEM_PCCRMR_R2_Pos = 0x1a
	// Bit mask of R2 field.
	LMEM_PCCRMR_R2_Msk = 0xc000000
	// Non-cacheable
	LMEM_PCCRMR_R2_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R2_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R2_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R2_11 = 0x3
	// Position of R1 field.
	LMEM_PCCRMR_R1_Pos = 0x1c
	// Bit mask of R1 field.
	LMEM_PCCRMR_R1_Msk = 0x30000000
	// Non-cacheable
	LMEM_PCCRMR_R1_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R1_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R1_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R1_11 = 0x3
	// Position of R0 field.
	LMEM_PCCRMR_R0_Pos = 0x1e
	// Bit mask of R0 field.
	LMEM_PCCRMR_R0_Msk = 0xc0000000
	// Non-cacheable
	LMEM_PCCRMR_R0_00 = 0x0
	// Non-cacheable
	LMEM_PCCRMR_R0_01 = 0x1
	// Write-through
	LMEM_PCCRMR_R0_10 = 0x2
	// Write-back
	LMEM_PCCRMR_R0_11 = 0x3
)
