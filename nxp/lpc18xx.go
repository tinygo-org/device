// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from LPC18xx.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/NXP

//go:build nxp && lpc18xx
// +build nxp,lpc18xx

// Register cmsis file for LPC18xx parts
//

package nxp

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "LPC18xx"
	CPU          = "CM3"
	FPUPresent   = false
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// Digital-to-Analog Converter (DAC)
	IRQ_DAC = 0

	// General Purpose DMA (GPDMA)
	IRQ_DMA = 2

	// EEPROM
	IRQ_FLASH = 4

	// Ethernet
	IRQ_ETHERNET = 5

	// SD/MMC
	IRQ_SDIO = 6

	// LCD controller
	IRQ_LCD = 7

	// USB0 Host/Device/OTG controller
	IRQ_USB0 = 8

	// USB1 Host/Device controller
	IRQ_USB1 = 9

	// State Configurable Timer (SCT) with dither engine
	IRQ_SCT = 10

	// Repetitive Interrupt Timer (RIT)
	IRQ_RITIMER = 11

	// Timer0/1/2/3
	IRQ_TIMER0 = 12

	IRQ_TIMER1 = 13

	IRQ_TIMER2 = 14

	IRQ_TIMER3 = 15

	// Motor Control PWM (MOTOCONPWM)
	IRQ_MCPWM = 16

	// 10-bit Analog-to-Digital Converter (ADC)
	IRQ_ADC0 = 17

	// I2C-bus interface
	IRQ_I2C0 = 18

	IRQ_I2C1 = 19

	IRQ_ADC1 = 21

	// SSP0/1
	IRQ_SSP0 = 22

	IRQ_SSP1 = 23

	// USART0_2_3
	IRQ_USART0 = 24

	// UART1
	IRQ_UART1 = 25

	IRQ_USART2 = 26

	IRQ_USART3 = 27

	// I2S interface
	IRQ_I2S0 = 28

	IRQ_I2S1 = 29

	// SPI Flash Interface (SPIFI)
	IRQ_SPIFI = 30

	// GPIO pin interrupt
	IRQ_PIN_INT0 = 32

	// GPIO pin interrupt
	IRQ_PIN_INT1 = 33

	// GPIO pin interrupt
	IRQ_PIN_INT2 = 34

	// GPIO pin interrupt
	IRQ_PIN_INT3 = 35

	// GPIO pin interrupt
	IRQ_PIN_INT4 = 36

	// GPIO pin interrupt
	IRQ_PIN_INT5 = 37

	// GPIO pin interrupt
	IRQ_PIN_INT6 = 38

	// GPIO pin interrupt
	IRQ_PIN_INT7 = 39

	// GPIO group interrupt 0
	IRQ_GINT0 = 40

	IRQ_GINT1 = 41

	// Event router
	IRQ_EVENTROUTER = 42

	// C_CAN
	IRQ_C_CAN1 = 43

	// Alarm timer
	IRQ_ATIMER = 46

	// Real-Time Clock (RTC) and event recorder
	IRQ_RTC = 47

	// Windowed Watchdog timer (WWDT)
	IRQ_WWDT = 49

	IRQ_C_CAN0 = 51

	// Quadrature Encoder Interface (QEI)
	IRQ_QEI = 52

	// Highest interrupt number on this device.
	IRQ_max = 52
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export DAC_IRQHandler
func interruptDAC() {
	callHandlers(IRQ_DAC)
}

//export DMA_IRQHandler
func interruptDMA() {
	callHandlers(IRQ_DMA)
}

//export FLASH_IRQHandler
func interruptFLASH() {
	callHandlers(IRQ_FLASH)
}

//export ETHERNET_IRQHandler
func interruptETHERNET() {
	callHandlers(IRQ_ETHERNET)
}

//export SDIO_IRQHandler
func interruptSDIO() {
	callHandlers(IRQ_SDIO)
}

//export LCD_IRQHandler
func interruptLCD() {
	callHandlers(IRQ_LCD)
}

//export USB0_IRQHandler
func interruptUSB0() {
	callHandlers(IRQ_USB0)
}

//export USB1_IRQHandler
func interruptUSB1() {
	callHandlers(IRQ_USB1)
}

//export SCT_IRQHandler
func interruptSCT() {
	callHandlers(IRQ_SCT)
}

//export RITIMER_IRQHandler
func interruptRITIMER() {
	callHandlers(IRQ_RITIMER)
}

//export TIMER0_IRQHandler
func interruptTIMER0() {
	callHandlers(IRQ_TIMER0)
}

//export TIMER1_IRQHandler
func interruptTIMER1() {
	callHandlers(IRQ_TIMER1)
}

//export TIMER2_IRQHandler
func interruptTIMER2() {
	callHandlers(IRQ_TIMER2)
}

//export TIMER3_IRQHandler
func interruptTIMER3() {
	callHandlers(IRQ_TIMER3)
}

//export MCPWM_IRQHandler
func interruptMCPWM() {
	callHandlers(IRQ_MCPWM)
}

//export ADC0_IRQHandler
func interruptADC0() {
	callHandlers(IRQ_ADC0)
}

//export I2C0_IRQHandler
func interruptI2C0() {
	callHandlers(IRQ_I2C0)
}

//export I2C1_IRQHandler
func interruptI2C1() {
	callHandlers(IRQ_I2C1)
}

//export ADC1_IRQHandler
func interruptADC1() {
	callHandlers(IRQ_ADC1)
}

//export SSP0_IRQHandler
func interruptSSP0() {
	callHandlers(IRQ_SSP0)
}

//export SSP1_IRQHandler
func interruptSSP1() {
	callHandlers(IRQ_SSP1)
}

//export USART0_IRQHandler
func interruptUSART0() {
	callHandlers(IRQ_USART0)
}

//export UART1_IRQHandler
func interruptUART1() {
	callHandlers(IRQ_UART1)
}

//export USART2_IRQHandler
func interruptUSART2() {
	callHandlers(IRQ_USART2)
}

//export USART3_IRQHandler
func interruptUSART3() {
	callHandlers(IRQ_USART3)
}

//export I2S0_IRQHandler
func interruptI2S0() {
	callHandlers(IRQ_I2S0)
}

//export I2S1_IRQHandler
func interruptI2S1() {
	callHandlers(IRQ_I2S1)
}

//export SPIFI_IRQHandler
func interruptSPIFI() {
	callHandlers(IRQ_SPIFI)
}

//export PIN_INT0_IRQHandler
func interruptPIN_INT0() {
	callHandlers(IRQ_PIN_INT0)
}

//export PIN_INT1_IRQHandler
func interruptPIN_INT1() {
	callHandlers(IRQ_PIN_INT1)
}

//export PIN_INT2_IRQHandler
func interruptPIN_INT2() {
	callHandlers(IRQ_PIN_INT2)
}

//export PIN_INT3_IRQHandler
func interruptPIN_INT3() {
	callHandlers(IRQ_PIN_INT3)
}

//export PIN_INT4_IRQHandler
func interruptPIN_INT4() {
	callHandlers(IRQ_PIN_INT4)
}

//export PIN_INT5_IRQHandler
func interruptPIN_INT5() {
	callHandlers(IRQ_PIN_INT5)
}

//export PIN_INT6_IRQHandler
func interruptPIN_INT6() {
	callHandlers(IRQ_PIN_INT6)
}

//export PIN_INT7_IRQHandler
func interruptPIN_INT7() {
	callHandlers(IRQ_PIN_INT7)
}

//export GINT0_IRQHandler
func interruptGINT0() {
	callHandlers(IRQ_GINT0)
}

//export GINT1_IRQHandler
func interruptGINT1() {
	callHandlers(IRQ_GINT1)
}

//export EVENTROUTER_IRQHandler
func interruptEVENTROUTER() {
	callHandlers(IRQ_EVENTROUTER)
}

//export C_CAN1_IRQHandler
func interruptC_CAN1() {
	callHandlers(IRQ_C_CAN1)
}

//export ATIMER_IRQHandler
func interruptATIMER() {
	callHandlers(IRQ_ATIMER)
}

//export RTC_IRQHandler
func interruptRTC() {
	callHandlers(IRQ_RTC)
}

//export WWDT_IRQHandler
func interruptWWDT() {
	callHandlers(IRQ_WWDT)
}

//export C_CAN0_IRQHandler
func interruptC_CAN0() {
	callHandlers(IRQ_C_CAN0)
}

//export QEI_IRQHandler
func interruptQEI() {
	callHandlers(IRQ_QEI)
}

// Peripherals.
var (
	// State Configurable Timer (SCT) with dither engine
	SCT = (*SCT_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// General Purpose DMA (GPDMA)
	GPDMA = (*GPDMA_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// SPI Flash Interface (SPIFI)
	SPIFI = (*SPIFI_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// SD/MMC
	SDMMC = (*SDMMC_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// External Memory Controller (EMC)
	EMC = (*EMC_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// USB0 Host/Device/OTG controller
	USB0 = (*USB0_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// USB1 Host/Device controller
	USB1 = (*USB1_Type)(unsafe.Pointer(uintptr(0x40007000)))

	// LCD controller
	LCD = (*LCD_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// EEPROM
	EEPROM = (*EEPROM_Type)(unsafe.Pointer(uintptr(0x4000e000)))

	// Ethernet
	ETHERNET = (*ETHERNET_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Alarm timer
	ATIMER = (*ATIMER_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// RTC REGFILE
	REGFILE = (*REGFILE_Type)(unsafe.Pointer(uintptr(0x40041000)))

	// Power Management Controller (PMC)
	PMC = (*PMC_Type)(unsafe.Pointer(uintptr(0x40042000)))

	// Configuration Registers (CREG)
	CREG = (*CREG_Type)(unsafe.Pointer(uintptr(0x40043000)))

	// Event router
	EVENTROUTER = (*EVENTROUTER_Type)(unsafe.Pointer(uintptr(0x40044000)))

	// Real-Time Clock (RTC) and event recorder
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40046000)))

	// Clock Generation Unit (CGU)
	CGU = (*CGU_Type)(unsafe.Pointer(uintptr(0x40050000)))

	// Clock Control Unit (CCU)
	CCU1 = (*CCU1_Type)(unsafe.Pointer(uintptr(0x40051000)))

	// Clock Control Unit (CCU2)
	CCU2 = (*CCU2_Type)(unsafe.Pointer(uintptr(0x40052000)))

	// Reset Generation Unit (RGU)
	RGU = (*RGU_Type)(unsafe.Pointer(uintptr(0x40053000)))

	// Windowed Watchdog timer (WWDT)
	WWDT = (*WWDT_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// USART0_2_3
	USART0 = (*USART_Type)(unsafe.Pointer(uintptr(0x40081000)))

	// UART1
	UART1 = (*UART1_Type)(unsafe.Pointer(uintptr(0x40082000)))

	// SSP0/1
	SSP0 = (*SSP_Type)(unsafe.Pointer(uintptr(0x40083000)))

	// Timer0/1/2/3
	TIMER0 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x40084000)))

	// System Control Unit (SCU) I/O configuration
	SCU = (*SCU_Type)(unsafe.Pointer(uintptr(0x40086000)))

	// GPIO pin interrupt
	GPIO_PIN_INT = (*GPIO_PIN_INT_Type)(unsafe.Pointer(uintptr(0x40087000)))

	// GPIO group interrupt 0
	GPIO_GROUP_INT0 = (*GPIO_GROUP_INT0_Type)(unsafe.Pointer(uintptr(0x40088000)))

	// GPIO group interrupt 0
	GPIO_GROUP_INT1 = (*GPIO_GROUP_INT0_Type)(unsafe.Pointer(uintptr(0x40089000)))

	// Motor Control PWM (MOTOCONPWM)
	MCPWM = (*MCPWM_Type)(unsafe.Pointer(uintptr(0x400a0000)))

	// I2C-bus interface
	I2C0 = (*I2C_Type)(unsafe.Pointer(uintptr(0x400a1000)))

	// I2S interface
	I2S0 = (*I2S_Type)(unsafe.Pointer(uintptr(0x400a2000)))

	// C_CAN
	C_CAN1 = (*C_CAN1_Type)(unsafe.Pointer(uintptr(0x400a4000)))

	// Repetitive Interrupt Timer (RIT)
	RITIMER = (*RITIMER_Type)(unsafe.Pointer(uintptr(0x400c0000)))

	// Quadrature Encoder Interface (QEI)
	QEI = (*QEI_Type)(unsafe.Pointer(uintptr(0x400c6000)))

	// Global Input Multiplexer Array (GIMA)
	GIMA = (*GIMA_Type)(unsafe.Pointer(uintptr(0x400c7000)))

	// Digital-to-Analog Converter (DAC)
	DAC = (*DAC_Type)(unsafe.Pointer(uintptr(0x400e1000)))

	// C_CAN
	C_CAN0 = (*C_CAN1_Type)(unsafe.Pointer(uintptr(0x400e2000)))

	// 10-bit Analog-to-Digital Converter (ADC)
	ADC0 = (*ADC_Type)(unsafe.Pointer(uintptr(0x400e3000)))

	// GPIO port
	GPIO_PORT = (*GPIO_PORT_Type)(unsafe.Pointer(uintptr(0x400f4000)))

	// USART0_2_3
	USART2 = (*USART_Type)(unsafe.Pointer(uintptr(0x400c1000)))

	// USART0_2_3
	USART3 = (*USART_Type)(unsafe.Pointer(uintptr(0x400c2000)))

	// SSP0/1
	SSP1 = (*SSP_Type)(unsafe.Pointer(uintptr(0x400c5000)))

	// Timer0/1/2/3
	TIMER1 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x40085000)))

	// Timer0/1/2/3
	TIMER2 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x400c3000)))

	// Timer0/1/2/3
	TIMER3 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x400c4000)))

	// I2C-bus interface
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x400e0000)))

	// I2S interface
	I2S1 = (*I2S_Type)(unsafe.Pointer(uintptr(0x400a3000)))

	// 10-bit Analog-to-Digital Converter (ADC)
	ADC1 = (*ADC_Type)(unsafe.Pointer(uintptr(0x400e4000)))
)

// State Configurable Timer (SCT) with dither engine
type SCT_Type struct {
	CONFIG        volatile.Register32 // 0x0
	CTRL          volatile.Register32 // 0x4
	LIMIT         volatile.Register32 // 0x8
	HALT          volatile.Register32 // 0xC
	STOP          volatile.Register32 // 0x10
	START         volatile.Register32 // 0x14
	DITHER        volatile.Register32 // 0x18
	_             [36]byte
	COUNT         volatile.Register32 // 0x40
	STATE         volatile.Register32 // 0x44
	INPUT         volatile.Register32 // 0x48
	REGMODE       volatile.Register32 // 0x4C
	OUTPUT        volatile.Register32 // 0x50
	OUTPUTDIRCTRL volatile.Register32 // 0x54
	RES           volatile.Register32 // 0x58
	DMAREQ0       volatile.Register32 // 0x5C
	DMAREQ1       volatile.Register32 // 0x60
	_             [140]byte
	EVEN          volatile.Register32 // 0xF0
	EVFLAG        volatile.Register32 // 0xF4
	CONEN         volatile.Register32 // 0xF8
	CONFLAG       volatile.Register32 // 0xFC
	MATCH0        volatile.Register32 // 0x100
	MATCH1        volatile.Register32 // 0x104
	MATCH2        volatile.Register32 // 0x108
	MATCH3        volatile.Register32 // 0x10C
	MATCH4        volatile.Register32 // 0x110
	MATCH5        volatile.Register32 // 0x114
	MATCH6        volatile.Register32 // 0x118
	MATCH7        volatile.Register32 // 0x11C
	MATCH8        volatile.Register32 // 0x120
	MATCH9        volatile.Register32 // 0x124
	MATCH10       volatile.Register32 // 0x128
	MATCH11       volatile.Register32 // 0x12C
	MATCH12       volatile.Register32 // 0x130
	MATCH13       volatile.Register32 // 0x134
	MATCH14       volatile.Register32 // 0x138
	MATCH15       volatile.Register32 // 0x13C
	FRACMAT0      volatile.Register32 // 0x140
	FRACMAT1      volatile.Register32 // 0x144
	FRACMAT2      volatile.Register32 // 0x148
	FRACMAT3      volatile.Register32 // 0x14C
	FRACMAT4      volatile.Register32 // 0x150
	FRACMAT5      volatile.Register32 // 0x154
	_             [168]byte
	MATCHREL0     volatile.Register32 // 0x200
	MATCHREL1     volatile.Register32 // 0x204
	MATCHREL2     volatile.Register32 // 0x208
	MATCHREL3     volatile.Register32 // 0x20C
	MATCHREL4     volatile.Register32 // 0x210
	MATCHREL5     volatile.Register32 // 0x214
	MATCHREL6     volatile.Register32 // 0x218
	MATCHREL7     volatile.Register32 // 0x21C
	MATCHREL8     volatile.Register32 // 0x220
	MATCHREL9     volatile.Register32 // 0x224
	MATCHREL10    volatile.Register32 // 0x228
	MATCHREL11    volatile.Register32 // 0x22C
	MATCHREL12    volatile.Register32 // 0x230
	MATCHREL13    volatile.Register32 // 0x234
	MATCHREL14    volatile.Register32 // 0x238
	MATCHREL15    volatile.Register32 // 0x23C
	FRACMATREL0   volatile.Register32 // 0x240
	FRACMATREL1   volatile.Register32 // 0x244
	FRACMATREL2   volatile.Register32 // 0x248
	FRACMATREL3   volatile.Register32 // 0x24C
	FRACMATREL4   volatile.Register32 // 0x250
	FRACMATREL5   volatile.Register32 // 0x254
	_             [168]byte
	EV0_STATE     volatile.Register32 // 0x300
	EV0_CTRL      volatile.Register32 // 0x304
	EV1_STATE     volatile.Register32 // 0x308
	EV1_CTRL      volatile.Register32 // 0x30C
	EV2_STATE     volatile.Register32 // 0x310
	EV2_CTRL      volatile.Register32 // 0x314
	EV3_STATE     volatile.Register32 // 0x318
	EV3_CTRL      volatile.Register32 // 0x31C
	EV4_STATE     volatile.Register32 // 0x320
	EV4_CTRL      volatile.Register32 // 0x324
	EV5_STATE     volatile.Register32 // 0x328
	EV5_CTRL      volatile.Register32 // 0x32C
	EV6_STATE     volatile.Register32 // 0x330
	EV6_CTRL      volatile.Register32 // 0x334
	EV7_STATE     volatile.Register32 // 0x338
	EV7_CTRL      volatile.Register32 // 0x33C
	EV8_STATE     volatile.Register32 // 0x340
	EV8_CTRL      volatile.Register32 // 0x344
	EV9_STATE     volatile.Register32 // 0x348
	EV9_CTRL      volatile.Register32 // 0x34C
	EV10_STATE    volatile.Register32 // 0x350
	EV10_CTRL     volatile.Register32 // 0x354
	EV11_STATE    volatile.Register32 // 0x358
	EV11_CTRL     volatile.Register32 // 0x35C
	EV12_STATE    volatile.Register32 // 0x360
	EV12_CTRL     volatile.Register32 // 0x364
	EV13_STATE    volatile.Register32 // 0x368
	EV13_CTRL     volatile.Register32 // 0x36C
	EV14_STATE    volatile.Register32 // 0x370
	EV14_CTRL     volatile.Register32 // 0x374
	EV15_STATE    volatile.Register32 // 0x378
	EV15_CTRL     volatile.Register32 // 0x37C
	_             [384]byte
	OUT0_SET      volatile.Register32 // 0x500
	OUT0_CLR      volatile.Register32 // 0x504
	OUT1_SET      volatile.Register32 // 0x508
	OUT1_CLR      volatile.Register32 // 0x50C
	OUT2_SET      volatile.Register32 // 0x510
	OUT2_CLR      volatile.Register32 // 0x514
	OUT3_SET      volatile.Register32 // 0x518
	OUT3_CLR      volatile.Register32 // 0x51C
	OUT4_SET      volatile.Register32 // 0x520
	OUT4_CLR      volatile.Register32 // 0x524
	OUT5_SET      volatile.Register32 // 0x528
	OUT5_CLR      volatile.Register32 // 0x52C
	OUT6_SET      volatile.Register32 // 0x530
	OUT6_CLR      volatile.Register32 // 0x534
	OUT7_SET      volatile.Register32 // 0x538
	OUT7_CLR      volatile.Register32 // 0x53C
	OUT8_SET      volatile.Register32 // 0x540
	OUT8_CLR      volatile.Register32 // 0x544
	OUT9_SET      volatile.Register32 // 0x548
	OUT9_CLR      volatile.Register32 // 0x54C
	OUT10_SET     volatile.Register32 // 0x550
	OUT10_CLR     volatile.Register32 // 0x554
	OUT11_SET     volatile.Register32 // 0x558
	OUT11_CLR     volatile.Register32 // 0x55C
	OUT12_SET     volatile.Register32 // 0x560
	OUT12_CLR     volatile.Register32 // 0x564
	OUT13_SET     volatile.Register32 // 0x568
	OUT13_CLR     volatile.Register32 // 0x56C
	OUT14_SET     volatile.Register32 // 0x570
	OUT14_CLR     volatile.Register32 // 0x574
	OUT15_SET     volatile.Register32 // 0x578
	OUT15_CLR     volatile.Register32 // 0x57C
}

// SCT.CONFIG: SCT configuration register
func (o *SCT_Type) SetCONFIG_UNIFY(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetCONFIG_UNIFY() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SCT_Type) SetCONFIG_CLKMODE(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x6)|value<<1)
}
func (o *SCT_Type) GetCONFIG_CLKMODE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x6) >> 1
}
func (o *SCT_Type) SetCONFIG_CKSEL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x78)|value<<3)
}
func (o *SCT_Type) GetCONFIG_CKSEL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x78) >> 3
}
func (o *SCT_Type) SetCONFIG_NORELAOD_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetCONFIG_NORELAOD_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetCONFIG_NORELOAD_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetCONFIG_NORELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetCONFIG_INSYNC(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1fe00)|value<<9)
}
func (o *SCT_Type) GetCONFIG_INSYNC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x1fe00) >> 9
}
func (o *SCT_Type) SetCONFIG_AUTOLIMIT_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetCONFIG_AUTOLIMIT_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetCONFIG_AUTOLIMIT_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetCONFIG_AUTOLIMIT_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xfff80000)|value<<19)
}
func (o *SCT_Type) GetCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xfff80000) >> 19
}

// SCT.CTRL: SCT control register
func (o *SCT_Type) SetCTRL_DOWN_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetCTRL_DOWN_L() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *SCT_Type) SetCTRL_STOP_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetCTRL_STOP_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetCTRL_HALT_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetCTRL_HALT_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetCTRL_CLRCTR_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetCTRL_CLRCTR_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetCTRL_BIDIR_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetCTRL_BIDIR_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetCTRL_PRE_L(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1fe0)|value<<5)
}
func (o *SCT_Type) GetCTRL_PRE_L() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1fe0) >> 5
}
func (o *SCT_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xe000)|value<<13)
}
func (o *SCT_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xe000) >> 13
}
func (o *SCT_Type) SetCTRL_DOWN_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetCTRL_DOWN_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetCTRL_STOP_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetCTRL_STOP_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetCTRL_HALT_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetCTRL_HALT_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetCTRL_CLRCTR_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetCTRL_CLRCTR_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetCTRL_BIDIR_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetCTRL_BIDIR_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetCTRL_PRE_H(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1fe00000)|value<<21)
}
func (o *SCT_Type) GetCTRL_PRE_H() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1fe00000) >> 21
}
func (o *SCT_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *SCT_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xe0000000) >> 29
}

// SCT.LIMIT: SCT limit register
func (o *SCT_Type) SetLIMIT_LIMMSK_L(value uint32) {
	volatile.StoreUint32(&o.LIMIT.Reg, volatile.LoadUint32(&o.LIMIT.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetLIMIT_LIMMSK_L() uint32 {
	return volatile.LoadUint32(&o.LIMIT.Reg) & 0xffff
}
func (o *SCT_Type) SetLIMIT_LIMMSK_H(value uint32) {
	volatile.StoreUint32(&o.LIMIT.Reg, volatile.LoadUint32(&o.LIMIT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetLIMIT_LIMMSK_H() uint32 {
	return (volatile.LoadUint32(&o.LIMIT.Reg) & 0xffff0000) >> 16
}

// SCT.HALT: SCT halt condition register
func (o *SCT_Type) SetHALT_HALTMSK_L(value uint32) {
	volatile.StoreUint32(&o.HALT.Reg, volatile.LoadUint32(&o.HALT.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetHALT_HALTMSK_L() uint32 {
	return volatile.LoadUint32(&o.HALT.Reg) & 0xffff
}
func (o *SCT_Type) SetHALT_HALTMSK_H(value uint32) {
	volatile.StoreUint32(&o.HALT.Reg, volatile.LoadUint32(&o.HALT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetHALT_HALTMSK_H() uint32 {
	return (volatile.LoadUint32(&o.HALT.Reg) & 0xffff0000) >> 16
}

// SCT.STOP: SCT stop condition register
func (o *SCT_Type) SetSTOP_STOPMSK_L(value uint32) {
	volatile.StoreUint32(&o.STOP.Reg, volatile.LoadUint32(&o.STOP.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetSTOP_STOPMSK_L() uint32 {
	return volatile.LoadUint32(&o.STOP.Reg) & 0xffff
}
func (o *SCT_Type) SetSTOP_STOPMSK_H(value uint32) {
	volatile.StoreUint32(&o.STOP.Reg, volatile.LoadUint32(&o.STOP.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetSTOP_STOPMSK_H() uint32 {
	return (volatile.LoadUint32(&o.STOP.Reg) & 0xffff0000) >> 16
}

// SCT.START: SCT start condition register
func (o *SCT_Type) SetSTART_STARTMSK_L(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetSTART_STARTMSK_L() uint32 {
	return volatile.LoadUint32(&o.START.Reg) & 0xffff
}
func (o *SCT_Type) SetSTART_STARTMSK_H(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetSTART_STARTMSK_H() uint32 {
	return (volatile.LoadUint32(&o.START.Reg) & 0xffff0000) >> 16
}

// SCT.DITHER: SCT dither condition register
func (o *SCT_Type) SetDITHER_DITHMSK_L(value uint32) {
	volatile.StoreUint32(&o.DITHER.Reg, volatile.LoadUint32(&o.DITHER.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetDITHER_DITHMSK_L() uint32 {
	return volatile.LoadUint32(&o.DITHER.Reg) & 0xffff
}
func (o *SCT_Type) SetDITHER_DITHMSK_H(value uint32) {
	volatile.StoreUint32(&o.DITHER.Reg, volatile.LoadUint32(&o.DITHER.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetDITHER_DITHMSK_H() uint32 {
	return (volatile.LoadUint32(&o.DITHER.Reg) & 0xffff0000) >> 16
}

// SCT.COUNT: SCT counter register
func (o *SCT_Type) SetCOUNT_CTR_L(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, volatile.LoadUint32(&o.COUNT.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetCOUNT_CTR_L() uint32 {
	return volatile.LoadUint32(&o.COUNT.Reg) & 0xffff
}
func (o *SCT_Type) SetCOUNT_CTR_H(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, volatile.LoadUint32(&o.COUNT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetCOUNT_CTR_H() uint32 {
	return (volatile.LoadUint32(&o.COUNT.Reg) & 0xffff0000) >> 16
}

// SCT.STATE: SCT state register
func (o *SCT_Type) SetSTATE_STATE_L(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x1f)|value)
}
func (o *SCT_Type) GetSTATE_STATE_L() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x1f
}
func (o *SCT_Type) SetSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xffe0)|value<<5)
}
func (o *SCT_Type) GetSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xffe0) >> 5
}
func (o *SCT_Type) SetSTATE_STATE_H(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x1f0000)|value<<16)
}
func (o *SCT_Type) GetSTATE_STATE_H() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0x1f0000) >> 16
}
func (o *SCT_Type) SetSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xffe00000)|value<<21)
}
func (o *SCT_Type) GetSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xffe00000) >> 21
}

// SCT.INPUT: SCT input register
func (o *SCT_Type) SetINPUT_AIN0(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetINPUT_AIN0() uint32 {
	return volatile.LoadUint32(&o.INPUT.Reg) & 0x1
}
func (o *SCT_Type) SetINPUT_AIN1(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetINPUT_AIN1() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetINPUT_AIN2(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetINPUT_AIN2() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetINPUT_AIN3(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetINPUT_AIN3() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetINPUT_AIN4(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetINPUT_AIN4() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetINPUT_AIN5(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetINPUT_AIN5() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetINPUT_AIN6(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetINPUT_AIN6() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetINPUT_AIN7(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetINPUT_AIN7() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetINPUT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0xff00)|value<<8)
}
func (o *SCT_Type) GetINPUT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0xff00) >> 8
}
func (o *SCT_Type) SetINPUT_SIN0(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetINPUT_SIN0() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetINPUT_SIN1(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetINPUT_SIN1() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetINPUT_SIN2(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetINPUT_SIN2() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetINPUT_SIN3(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetINPUT_SIN3() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetINPUT_SIN4(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetINPUT_SIN4() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetINPUT_SIN5(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetINPUT_SIN5() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetINPUT_SIN6(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetINPUT_SIN6() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetINPUT_SIN7(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetINPUT_SIN7() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetINPUT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INPUT.Reg, volatile.LoadUint32(&o.INPUT.Reg)&^(0xff000000)|value<<24)
}
func (o *SCT_Type) GetINPUT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INPUT.Reg) & 0xff000000) >> 24
}

// SCT.REGMODE: SCT match/capture registers mode register
func (o *SCT_Type) SetREGMODE_REGMOD_L(value uint32) {
	volatile.StoreUint32(&o.REGMODE.Reg, volatile.LoadUint32(&o.REGMODE.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetREGMODE_REGMOD_L() uint32 {
	return volatile.LoadUint32(&o.REGMODE.Reg) & 0xffff
}
func (o *SCT_Type) SetREGMODE_REGMOD_H(value uint32) {
	volatile.StoreUint32(&o.REGMODE.Reg, volatile.LoadUint32(&o.REGMODE.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetREGMODE_REGMOD_H() uint32 {
	return (volatile.LoadUint32(&o.REGMODE.Reg) & 0xffff0000) >> 16
}

// SCT.OUTPUT: SCT output register
func (o *SCT_Type) SetOUTPUT_OUT(value uint32) {
	volatile.StoreUint32(&o.OUTPUT.Reg, volatile.LoadUint32(&o.OUTPUT.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetOUTPUT_OUT() uint32 {
	return volatile.LoadUint32(&o.OUTPUT.Reg) & 0xffff
}
func (o *SCT_Type) SetOUTPUT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUTPUT.Reg, volatile.LoadUint32(&o.OUTPUT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUTPUT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUTPUT.Reg) & 0xffff0000) >> 16
}

// SCT.OUTPUTDIRCTRL: SCT output counter direction control register
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR0(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x3)|value)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR0() uint32 {
	return volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x3
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR1(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc)|value<<2)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR1() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc) >> 2
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR2(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x30)|value<<4)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR2() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x30) >> 4
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR3(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc0)|value<<6)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR3() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc0) >> 6
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR4(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x300)|value<<8)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR4() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x300) >> 8
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR5(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR5() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR6(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR6() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR7(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc000)|value<<14)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR7() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc000) >> 14
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR8(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x30000)|value<<16)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR8() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x30000) >> 16
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR9(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc0000)|value<<18)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR9() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc0000) >> 18
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR10(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x300000)|value<<20)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR10() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x300000) >> 20
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR11(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc00000)|value<<22)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR11() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc00000) >> 22
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR12(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x3000000)|value<<24)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR12() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x3000000) >> 24
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR13(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc000000)|value<<26)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR13() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc000000) >> 26
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR14(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR14() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0x30000000) >> 28
}
func (o *SCT_Type) SetOUTPUTDIRCTRL_SETCLR15(value uint32) {
	volatile.StoreUint32(&o.OUTPUTDIRCTRL.Reg, volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg)&^(0xc0000000)|value<<30)
}
func (o *SCT_Type) GetOUTPUTDIRCTRL_SETCLR15() uint32 {
	return (volatile.LoadUint32(&o.OUTPUTDIRCTRL.Reg) & 0xc0000000) >> 30
}

// SCT.RES: SCT conflict resolution register
func (o *SCT_Type) SetRES_O0RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x3)|value)
}
func (o *SCT_Type) GetRES_O0RES() uint32 {
	return volatile.LoadUint32(&o.RES.Reg) & 0x3
}
func (o *SCT_Type) SetRES_O1RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc)|value<<2)
}
func (o *SCT_Type) GetRES_O1RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc) >> 2
}
func (o *SCT_Type) SetRES_O2RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x30)|value<<4)
}
func (o *SCT_Type) GetRES_O2RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x30) >> 4
}
func (o *SCT_Type) SetRES_O3RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc0)|value<<6)
}
func (o *SCT_Type) GetRES_O3RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc0) >> 6
}
func (o *SCT_Type) SetRES_O4RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x300)|value<<8)
}
func (o *SCT_Type) GetRES_O4RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x300) >> 8
}
func (o *SCT_Type) SetRES_O5RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetRES_O5RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetRES_O6RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetRES_O6RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetRES_O7RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc000)|value<<14)
}
func (o *SCT_Type) GetRES_O7RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc000) >> 14
}
func (o *SCT_Type) SetRES_O8RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x30000)|value<<16)
}
func (o *SCT_Type) GetRES_O8RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x30000) >> 16
}
func (o *SCT_Type) SetRES_O9RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc0000)|value<<18)
}
func (o *SCT_Type) GetRES_O9RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc0000) >> 18
}
func (o *SCT_Type) SetRES_O10RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x300000)|value<<20)
}
func (o *SCT_Type) GetRES_O10RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x300000) >> 20
}
func (o *SCT_Type) SetRES_O11RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc00000)|value<<22)
}
func (o *SCT_Type) GetRES_O11RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc00000) >> 22
}
func (o *SCT_Type) SetRES_O12RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x3000000)|value<<24)
}
func (o *SCT_Type) GetRES_O12RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x3000000) >> 24
}
func (o *SCT_Type) SetRES_O13RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc000000)|value<<26)
}
func (o *SCT_Type) GetRES_O13RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc000000) >> 26
}
func (o *SCT_Type) SetRES_O14RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0x30000000)|value<<28)
}
func (o *SCT_Type) GetRES_O14RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0x30000000) >> 28
}
func (o *SCT_Type) SetRES_O15RES(value uint32) {
	volatile.StoreUint32(&o.RES.Reg, volatile.LoadUint32(&o.RES.Reg)&^(0xc0000000)|value<<30)
}
func (o *SCT_Type) GetRES_O15RES() uint32 {
	return (volatile.LoadUint32(&o.RES.Reg) & 0xc0000000) >> 30
}

// SCT.DMAREQ0: SCT DMA request 0 register
func (o *SCT_Type) SetDMAREQ0_DEV_00(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetDMAREQ0_DEV_00() uint32 {
	return volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x1
}
func (o *SCT_Type) SetDMAREQ0_DEV_01(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetDMAREQ0_DEV_01() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetDMAREQ0_DEV_02(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetDMAREQ0_DEV_02() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetDMAREQ0_DEV_03(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetDMAREQ0_DEV_03() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetDMAREQ0_DEV_04(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetDMAREQ0_DEV_04() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetDMAREQ0_DEV_05(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetDMAREQ0_DEV_05() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetDMAREQ0_DEV_06(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetDMAREQ0_DEV_06() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetDMAREQ0_DEV_07(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetDMAREQ0_DEV_07() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetDMAREQ0_DEV_08(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetDMAREQ0_DEV_08() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetDMAREQ0_DEV_09(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetDMAREQ0_DEV_09() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetDMAREQ0_DEV_010(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetDMAREQ0_DEV_010() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetDMAREQ0_DEV_011(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetDMAREQ0_DEV_011() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetDMAREQ0_DEV_012(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetDMAREQ0_DEV_012() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetDMAREQ0_DEV_013(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetDMAREQ0_DEV_013() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetDMAREQ0_DEV_014(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetDMAREQ0_DEV_014() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetDMAREQ0_DEV_015(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetDMAREQ0_DEV_015() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetDMAREQ0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x3fff0000)|value<<16)
}
func (o *SCT_Type) GetDMAREQ0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x3fff0000) >> 16
}
func (o *SCT_Type) SetDMAREQ0_DRL0(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetDMAREQ0_DRL0() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetDMAREQ0_DRQ0(value uint32) {
	volatile.StoreUint32(&o.DMAREQ0.Reg, volatile.LoadUint32(&o.DMAREQ0.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetDMAREQ0_DRQ0() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ0.Reg) & 0x80000000) >> 31
}

// SCT.DMAREQ1: SCT DMA request 1 register
func (o *SCT_Type) SetDMAREQ1_DEV_10(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetDMAREQ1_DEV_10() uint32 {
	return volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x1
}
func (o *SCT_Type) SetDMAREQ1_DEV_11(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetDMAREQ1_DEV_11() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetDMAREQ1_DEV_12(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetDMAREQ1_DEV_12() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetDMAREQ1_DEV_13(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetDMAREQ1_DEV_13() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetDMAREQ1_DEV_14(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetDMAREQ1_DEV_14() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetDMAREQ1_DEV_15(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetDMAREQ1_DEV_15() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetDMAREQ1_DEV_16(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetDMAREQ1_DEV_16() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetDMAREQ1_DEV_17(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetDMAREQ1_DEV_17() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetDMAREQ1_DEV_18(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetDMAREQ1_DEV_18() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetDMAREQ1_DEV_19(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetDMAREQ1_DEV_19() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetDMAREQ1_DEV_110(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetDMAREQ1_DEV_110() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetDMAREQ1_DEV_111(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetDMAREQ1_DEV_111() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetDMAREQ1_DEV_112(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetDMAREQ1_DEV_112() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetDMAREQ1_DEV_113(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetDMAREQ1_DEV_113() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetDMAREQ1_DEV_114(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetDMAREQ1_DEV_114() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetDMAREQ1_DEV_115(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetDMAREQ1_DEV_115() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetDMAREQ1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x3fff0000)|value<<16)
}
func (o *SCT_Type) GetDMAREQ1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x3fff0000) >> 16
}
func (o *SCT_Type) SetDMAREQ1_DRL1(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetDMAREQ1_DRL1() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetDMAREQ1_DRQ1(value uint32) {
	volatile.StoreUint32(&o.DMAREQ1.Reg, volatile.LoadUint32(&o.DMAREQ1.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetDMAREQ1_DRQ1() uint32 {
	return (volatile.LoadUint32(&o.DMAREQ1.Reg) & 0x80000000) >> 31
}

// SCT.EVEN: SCT event enable register
func (o *SCT_Type) SetEVEN_IEN0(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEVEN_IEN0() uint32 {
	return volatile.LoadUint32(&o.EVEN.Reg) & 0x1
}
func (o *SCT_Type) SetEVEN_IEN1(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEVEN_IEN1() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEVEN_IEN2(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEVEN_IEN2() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEVEN_IEN3(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEVEN_IEN3() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEVEN_IEN4(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEVEN_IEN4() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEVEN_IEN5(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEVEN_IEN5() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEVEN_IEN6(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEVEN_IEN6() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEVEN_IEN7(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEVEN_IEN7() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEVEN_IEN8(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEVEN_IEN8() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEVEN_IEN9(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEVEN_IEN9() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEVEN_IEN10(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEVEN_IEN10() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEVEN_IEN11(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEVEN_IEN11() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEVEN_IEN12(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEVEN_IEN12() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEVEN_IEN13(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEVEN_IEN13() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEVEN_IEN14(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEVEN_IEN14() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEVEN_IEN15(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEVEN_IEN15() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEVEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EVEN.Reg, volatile.LoadUint32(&o.EVEN.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetEVEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EVEN.Reg) & 0xffff0000) >> 16
}

// SCT.EVFLAG: SCT event flag register
func (o *SCT_Type) SetEVFLAG_FLAG0(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEVFLAG_FLAG0() uint32 {
	return volatile.LoadUint32(&o.EVFLAG.Reg) & 0x1
}
func (o *SCT_Type) SetEVFLAG_FLAG1(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEVFLAG_FLAG1() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEVFLAG_FLAG2(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEVFLAG_FLAG2() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEVFLAG_FLAG3(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEVFLAG_FLAG3() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEVFLAG_FLAG4(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEVFLAG_FLAG4() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEVFLAG_FLAG5(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEVFLAG_FLAG5() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEVFLAG_FLAG6(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEVFLAG_FLAG6() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEVFLAG_FLAG7(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEVFLAG_FLAG7() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEVFLAG_FLAG8(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEVFLAG_FLAG8() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEVFLAG_FLAG9(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEVFLAG_FLAG9() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEVFLAG_FLAG10(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEVFLAG_FLAG10() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEVFLAG_FLAG11(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEVFLAG_FLAG11() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEVFLAG_FLAG12(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEVFLAG_FLAG12() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEVFLAG_FLAG13(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEVFLAG_FLAG13() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEVFLAG_FLAG14(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEVFLAG_FLAG14() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEVFLAG_FLAG15(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEVFLAG_FLAG15() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEVFLAG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EVFLAG.Reg, volatile.LoadUint32(&o.EVFLAG.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetEVFLAG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EVFLAG.Reg) & 0xffff0000) >> 16
}

// SCT.CONEN: SCT conflict enable register
func (o *SCT_Type) SetCONEN_NCEN0(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetCONEN_NCEN0() uint32 {
	return volatile.LoadUint32(&o.CONEN.Reg) & 0x1
}
func (o *SCT_Type) SetCONEN_NCEN1(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetCONEN_NCEN1() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetCONEN_NCEN2(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetCONEN_NCEN2() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetCONEN_NCEN3(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetCONEN_NCEN3() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetCONEN_NCEN4(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetCONEN_NCEN4() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetCONEN_NCEN5(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetCONEN_NCEN5() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetCONEN_NCEN6(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetCONEN_NCEN6() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetCONEN_NCEN7(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetCONEN_NCEN7() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetCONEN_NCEN8(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetCONEN_NCEN8() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetCONEN_NCEN9(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetCONEN_NCEN9() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetCONEN_NCEN10(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetCONEN_NCEN10() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetCONEN_NCEN11(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetCONEN_NCEN11() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetCONEN_NCEN12(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetCONEN_NCEN12() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetCONEN_NCEN13(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetCONEN_NCEN13() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetCONEN_NCEN14(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetCONEN_NCEN14() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetCONEN_NCEN15(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetCONEN_NCEN15() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetCONEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONEN.Reg, volatile.LoadUint32(&o.CONEN.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetCONEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONEN.Reg) & 0xffff0000) >> 16
}

// SCT.CONFLAG: SCT conflict flag register
func (o *SCT_Type) SetCONFLAG_NCFLAG0(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG0() uint32 {
	return volatile.LoadUint32(&o.CONFLAG.Reg) & 0x1
}
func (o *SCT_Type) SetCONFLAG_NCFLAG1(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG1() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetCONFLAG_NCFLAG2(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG2() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetCONFLAG_NCFLAG3(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG3() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetCONFLAG_NCFLAG4(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG4() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetCONFLAG_NCFLAG5(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG5() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetCONFLAG_NCFLAG6(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG6() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetCONFLAG_NCFLAG7(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG7() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetCONFLAG_NCFLAG8(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG8() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetCONFLAG_NCFLAG9(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG9() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetCONFLAG_NCFLAG10(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG10() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetCONFLAG_NCFLAG11(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG11() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetCONFLAG_NCFLAG12(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG12() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetCONFLAG_NCFLAG13(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG13() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetCONFLAG_NCFLAG14(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG14() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetCONFLAG_NCFLAG15(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetCONFLAG_NCFLAG15() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetCONFLAG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x3fff0000)|value<<16)
}
func (o *SCT_Type) GetCONFLAG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x3fff0000) >> 16
}
func (o *SCT_Type) SetCONFLAG_BUSERRL(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetCONFLAG_BUSERRL() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetCONFLAG_BUSERRH(value uint32) {
	volatile.StoreUint32(&o.CONFLAG.Reg, volatile.LoadUint32(&o.CONFLAG.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetCONFLAG_BUSERRH() uint32 {
	return (volatile.LoadUint32(&o.CONFLAG.Reg) & 0x80000000) >> 31
}

// SCT.MATCH0: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH0_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH0.Reg, volatile.LoadUint32(&o.MATCH0.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH0_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH0.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH0_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH0.Reg, volatile.LoadUint32(&o.MATCH0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH0_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH0.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH1: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH1_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH1.Reg, volatile.LoadUint32(&o.MATCH1.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH1_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH1.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH1_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH1.Reg, volatile.LoadUint32(&o.MATCH1.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH1_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH1.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH2: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH2_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH2.Reg, volatile.LoadUint32(&o.MATCH2.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH2_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH2.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH2_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH2.Reg, volatile.LoadUint32(&o.MATCH2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH2_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH2.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH3: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH3_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH3.Reg, volatile.LoadUint32(&o.MATCH3.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH3_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH3.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH3_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH3.Reg, volatile.LoadUint32(&o.MATCH3.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH3_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH3.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH4: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH4_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH4.Reg, volatile.LoadUint32(&o.MATCH4.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH4_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH4.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH4_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH4.Reg, volatile.LoadUint32(&o.MATCH4.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH4_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH4.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH5: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH5_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH5.Reg, volatile.LoadUint32(&o.MATCH5.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH5_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH5.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH5_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH5.Reg, volatile.LoadUint32(&o.MATCH5.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH5_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH5.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH6: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH6_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH6.Reg, volatile.LoadUint32(&o.MATCH6.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH6_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH6.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH6_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH6.Reg, volatile.LoadUint32(&o.MATCH6.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH6_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH6.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH7: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH7_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH7.Reg, volatile.LoadUint32(&o.MATCH7.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH7_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH7.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH7_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH7.Reg, volatile.LoadUint32(&o.MATCH7.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH7_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH7.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH8: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH8_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH8.Reg, volatile.LoadUint32(&o.MATCH8.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH8_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH8.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH8_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH8.Reg, volatile.LoadUint32(&o.MATCH8.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH8_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH8.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH9: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH9_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH9.Reg, volatile.LoadUint32(&o.MATCH9.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH9_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH9.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH9_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH9.Reg, volatile.LoadUint32(&o.MATCH9.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH9_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH9.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH10: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH10_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH10.Reg, volatile.LoadUint32(&o.MATCH10.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH10_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH10.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH10_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH10.Reg, volatile.LoadUint32(&o.MATCH10.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH10_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH10.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH11: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH11_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH11.Reg, volatile.LoadUint32(&o.MATCH11.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH11_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH11.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH11_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH11.Reg, volatile.LoadUint32(&o.MATCH11.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH11_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH11.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH12: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH12_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH12.Reg, volatile.LoadUint32(&o.MATCH12.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH12_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH12.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH12_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH12.Reg, volatile.LoadUint32(&o.MATCH12.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH12_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH12.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH13: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH13_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH13.Reg, volatile.LoadUint32(&o.MATCH13.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH13_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH13.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH13_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH13.Reg, volatile.LoadUint32(&o.MATCH13.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH13_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH13.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH14: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH14_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH14.Reg, volatile.LoadUint32(&o.MATCH14.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH14_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH14.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH14_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH14.Reg, volatile.LoadUint32(&o.MATCH14.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH14_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH14.Reg) & 0xffff0000) >> 16
}

// SCT.MATCH15: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCH15_MATCH_L(value uint32) {
	volatile.StoreUint32(&o.MATCH15.Reg, volatile.LoadUint32(&o.MATCH15.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCH15_MATCH_L() uint32 {
	return volatile.LoadUint32(&o.MATCH15.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCH15_MATCH_H(value uint32) {
	volatile.StoreUint32(&o.MATCH15.Reg, volatile.LoadUint32(&o.MATCH15.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCH15_MATCH_H() uint32 {
	return (volatile.LoadUint32(&o.MATCH15.Reg) & 0xffff0000) >> 16
}

// SCT.FRACMAT0: Fractional match registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMAT0_FRACMAT_L(value uint32) {
	volatile.StoreUint32(&o.FRACMAT0.Reg, volatile.LoadUint32(&o.FRACMAT0.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMAT0_FRACMAT_L() uint32 {
	return volatile.LoadUint32(&o.FRACMAT0.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMAT0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT0.Reg, volatile.LoadUint32(&o.FRACMAT0.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMAT0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT0.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMAT0_FRACMAT_H(value uint32) {
	volatile.StoreUint32(&o.FRACMAT0.Reg, volatile.LoadUint32(&o.FRACMAT0.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMAT0_FRACMAT_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT0.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMAT0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT0.Reg, volatile.LoadUint32(&o.FRACMAT0.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMAT0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT0.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMAT1: Fractional match registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMAT1_FRACMAT_L(value uint32) {
	volatile.StoreUint32(&o.FRACMAT1.Reg, volatile.LoadUint32(&o.FRACMAT1.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMAT1_FRACMAT_L() uint32 {
	return volatile.LoadUint32(&o.FRACMAT1.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMAT1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT1.Reg, volatile.LoadUint32(&o.FRACMAT1.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMAT1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT1.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMAT1_FRACMAT_H(value uint32) {
	volatile.StoreUint32(&o.FRACMAT1.Reg, volatile.LoadUint32(&o.FRACMAT1.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMAT1_FRACMAT_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT1.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMAT1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT1.Reg, volatile.LoadUint32(&o.FRACMAT1.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMAT1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT1.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMAT2: Fractional match registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMAT2_FRACMAT_L(value uint32) {
	volatile.StoreUint32(&o.FRACMAT2.Reg, volatile.LoadUint32(&o.FRACMAT2.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMAT2_FRACMAT_L() uint32 {
	return volatile.LoadUint32(&o.FRACMAT2.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMAT2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT2.Reg, volatile.LoadUint32(&o.FRACMAT2.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMAT2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT2.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMAT2_FRACMAT_H(value uint32) {
	volatile.StoreUint32(&o.FRACMAT2.Reg, volatile.LoadUint32(&o.FRACMAT2.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMAT2_FRACMAT_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT2.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMAT2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT2.Reg, volatile.LoadUint32(&o.FRACMAT2.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMAT2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT2.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMAT3: Fractional match registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMAT3_FRACMAT_L(value uint32) {
	volatile.StoreUint32(&o.FRACMAT3.Reg, volatile.LoadUint32(&o.FRACMAT3.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMAT3_FRACMAT_L() uint32 {
	return volatile.LoadUint32(&o.FRACMAT3.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMAT3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT3.Reg, volatile.LoadUint32(&o.FRACMAT3.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMAT3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT3.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMAT3_FRACMAT_H(value uint32) {
	volatile.StoreUint32(&o.FRACMAT3.Reg, volatile.LoadUint32(&o.FRACMAT3.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMAT3_FRACMAT_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT3.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMAT3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT3.Reg, volatile.LoadUint32(&o.FRACMAT3.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMAT3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT3.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMAT4: Fractional match registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMAT4_FRACMAT_L(value uint32) {
	volatile.StoreUint32(&o.FRACMAT4.Reg, volatile.LoadUint32(&o.FRACMAT4.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMAT4_FRACMAT_L() uint32 {
	return volatile.LoadUint32(&o.FRACMAT4.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMAT4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT4.Reg, volatile.LoadUint32(&o.FRACMAT4.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMAT4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT4.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMAT4_FRACMAT_H(value uint32) {
	volatile.StoreUint32(&o.FRACMAT4.Reg, volatile.LoadUint32(&o.FRACMAT4.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMAT4_FRACMAT_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT4.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMAT4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT4.Reg, volatile.LoadUint32(&o.FRACMAT4.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMAT4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT4.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMAT5: Fractional match registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMAT5_FRACMAT_L(value uint32) {
	volatile.StoreUint32(&o.FRACMAT5.Reg, volatile.LoadUint32(&o.FRACMAT5.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMAT5_FRACMAT_L() uint32 {
	return volatile.LoadUint32(&o.FRACMAT5.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMAT5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT5.Reg, volatile.LoadUint32(&o.FRACMAT5.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMAT5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT5.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMAT5_FRACMAT_H(value uint32) {
	volatile.StoreUint32(&o.FRACMAT5.Reg, volatile.LoadUint32(&o.FRACMAT5.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMAT5_FRACMAT_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT5.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMAT5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMAT5.Reg, volatile.LoadUint32(&o.FRACMAT5.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMAT5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMAT5.Reg) & 0xfff00000) >> 20
}

// SCT.MATCHREL0: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL0_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL0.Reg, volatile.LoadUint32(&o.MATCHREL0.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL0_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL0.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL0_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL0.Reg, volatile.LoadUint32(&o.MATCHREL0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL0_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL0.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL1: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL1_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL1.Reg, volatile.LoadUint32(&o.MATCHREL1.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL1_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL1.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL1_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL1.Reg, volatile.LoadUint32(&o.MATCHREL1.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL1_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL1.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL2: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL2_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL2.Reg, volatile.LoadUint32(&o.MATCHREL2.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL2_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL2.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL2_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL2.Reg, volatile.LoadUint32(&o.MATCHREL2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL2_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL2.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL3: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL3_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL3.Reg, volatile.LoadUint32(&o.MATCHREL3.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL3_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL3.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL3_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL3.Reg, volatile.LoadUint32(&o.MATCHREL3.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL3_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL3.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL4: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL4_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL4.Reg, volatile.LoadUint32(&o.MATCHREL4.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL4_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL4.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL4_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL4.Reg, volatile.LoadUint32(&o.MATCHREL4.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL4_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL4.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL5: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL5_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL5.Reg, volatile.LoadUint32(&o.MATCHREL5.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL5_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL5.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL5_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL5.Reg, volatile.LoadUint32(&o.MATCHREL5.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL5_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL5.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL6: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL6_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL6.Reg, volatile.LoadUint32(&o.MATCHREL6.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL6_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL6.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL6_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL6.Reg, volatile.LoadUint32(&o.MATCHREL6.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL6_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL6.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL7: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL7_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL7.Reg, volatile.LoadUint32(&o.MATCHREL7.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL7_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL7.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL7_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL7.Reg, volatile.LoadUint32(&o.MATCHREL7.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL7_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL7.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL8: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL8_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL8.Reg, volatile.LoadUint32(&o.MATCHREL8.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL8_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL8.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL8_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL8.Reg, volatile.LoadUint32(&o.MATCHREL8.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL8_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL8.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL9: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL9_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL9.Reg, volatile.LoadUint32(&o.MATCHREL9.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL9_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL9.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL9_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL9.Reg, volatile.LoadUint32(&o.MATCHREL9.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL9_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL9.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL10: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL10_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL10.Reg, volatile.LoadUint32(&o.MATCHREL10.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL10_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL10.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL10_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL10.Reg, volatile.LoadUint32(&o.MATCHREL10.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL10_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL10.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL11: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL11_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL11.Reg, volatile.LoadUint32(&o.MATCHREL11.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL11_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL11.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL11_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL11.Reg, volatile.LoadUint32(&o.MATCHREL11.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL11_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL11.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL12: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL12_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL12.Reg, volatile.LoadUint32(&o.MATCHREL12.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL12_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL12.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL12_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL12.Reg, volatile.LoadUint32(&o.MATCHREL12.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL12_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL12.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL13: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL13_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL13.Reg, volatile.LoadUint32(&o.MATCHREL13.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL13_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL13.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL13_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL13.Reg, volatile.LoadUint32(&o.MATCHREL13.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL13_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL13.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL14: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL14_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL14.Reg, volatile.LoadUint32(&o.MATCHREL14.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL14_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL14.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL14_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL14.Reg, volatile.LoadUint32(&o.MATCHREL14.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL14_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL14.Reg) & 0xffff0000) >> 16
}

// SCT.MATCHREL15: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
func (o *SCT_Type) SetMATCHREL15_RELOAD_L(value uint32) {
	volatile.StoreUint32(&o.MATCHREL15.Reg, volatile.LoadUint32(&o.MATCHREL15.Reg)&^(0xffff)|value)
}
func (o *SCT_Type) GetMATCHREL15_RELOAD_L() uint32 {
	return volatile.LoadUint32(&o.MATCHREL15.Reg) & 0xffff
}
func (o *SCT_Type) SetMATCHREL15_RELOAD_H(value uint32) {
	volatile.StoreUint32(&o.MATCHREL15.Reg, volatile.LoadUint32(&o.MATCHREL15.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetMATCHREL15_RELOAD_H() uint32 {
	return (volatile.LoadUint32(&o.MATCHREL15.Reg) & 0xffff0000) >> 16
}

// SCT.FRACMATREL0: Fractional match reload registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMATREL0_RELFRAC_L(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL0.Reg, volatile.LoadUint32(&o.FRACMATREL0.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMATREL0_RELFRAC_L() uint32 {
	return volatile.LoadUint32(&o.FRACMATREL0.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMATREL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL0.Reg, volatile.LoadUint32(&o.FRACMATREL0.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMATREL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL0.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMATREL0_RELFRAC_H(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL0.Reg, volatile.LoadUint32(&o.FRACMATREL0.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMATREL0_RELFRAC_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL0.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMATREL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL0.Reg, volatile.LoadUint32(&o.FRACMATREL0.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMATREL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL0.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMATREL1: Fractional match reload registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMATREL1_RELFRAC_L(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL1.Reg, volatile.LoadUint32(&o.FRACMATREL1.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMATREL1_RELFRAC_L() uint32 {
	return volatile.LoadUint32(&o.FRACMATREL1.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMATREL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL1.Reg, volatile.LoadUint32(&o.FRACMATREL1.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMATREL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL1.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMATREL1_RELFRAC_H(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL1.Reg, volatile.LoadUint32(&o.FRACMATREL1.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMATREL1_RELFRAC_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL1.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMATREL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL1.Reg, volatile.LoadUint32(&o.FRACMATREL1.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMATREL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL1.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMATREL2: Fractional match reload registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMATREL2_RELFRAC_L(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL2.Reg, volatile.LoadUint32(&o.FRACMATREL2.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMATREL2_RELFRAC_L() uint32 {
	return volatile.LoadUint32(&o.FRACMATREL2.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMATREL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL2.Reg, volatile.LoadUint32(&o.FRACMATREL2.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMATREL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL2.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMATREL2_RELFRAC_H(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL2.Reg, volatile.LoadUint32(&o.FRACMATREL2.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMATREL2_RELFRAC_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL2.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMATREL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL2.Reg, volatile.LoadUint32(&o.FRACMATREL2.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMATREL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL2.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMATREL3: Fractional match reload registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMATREL3_RELFRAC_L(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL3.Reg, volatile.LoadUint32(&o.FRACMATREL3.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMATREL3_RELFRAC_L() uint32 {
	return volatile.LoadUint32(&o.FRACMATREL3.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMATREL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL3.Reg, volatile.LoadUint32(&o.FRACMATREL3.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMATREL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL3.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMATREL3_RELFRAC_H(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL3.Reg, volatile.LoadUint32(&o.FRACMATREL3.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMATREL3_RELFRAC_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL3.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMATREL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL3.Reg, volatile.LoadUint32(&o.FRACMATREL3.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMATREL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL3.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMATREL4: Fractional match reload registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMATREL4_RELFRAC_L(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL4.Reg, volatile.LoadUint32(&o.FRACMATREL4.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMATREL4_RELFRAC_L() uint32 {
	return volatile.LoadUint32(&o.FRACMATREL4.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMATREL4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL4.Reg, volatile.LoadUint32(&o.FRACMATREL4.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMATREL4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL4.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMATREL4_RELFRAC_H(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL4.Reg, volatile.LoadUint32(&o.FRACMATREL4.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMATREL4_RELFRAC_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL4.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMATREL4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL4.Reg, volatile.LoadUint32(&o.FRACMATREL4.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMATREL4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL4.Reg) & 0xfff00000) >> 20
}

// SCT.FRACMATREL5: Fractional match reload registers 0 to 5 for SCT match value registers 0 to 5.
func (o *SCT_Type) SetFRACMATREL5_RELFRAC_L(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL5.Reg, volatile.LoadUint32(&o.FRACMATREL5.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetFRACMATREL5_RELFRAC_L() uint32 {
	return volatile.LoadUint32(&o.FRACMATREL5.Reg) & 0xf
}
func (o *SCT_Type) SetFRACMATREL5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL5.Reg, volatile.LoadUint32(&o.FRACMATREL5.Reg)&^(0xfff0)|value<<4)
}
func (o *SCT_Type) GetFRACMATREL5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL5.Reg) & 0xfff0) >> 4
}
func (o *SCT_Type) SetFRACMATREL5_RELFRAC_H(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL5.Reg, volatile.LoadUint32(&o.FRACMATREL5.Reg)&^(0xf0000)|value<<16)
}
func (o *SCT_Type) GetFRACMATREL5_RELFRAC_H() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL5.Reg) & 0xf0000) >> 16
}
func (o *SCT_Type) SetFRACMATREL5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRACMATREL5.Reg, volatile.LoadUint32(&o.FRACMATREL5.Reg)&^(0xfff00000)|value<<20)
}
func (o *SCT_Type) GetFRACMATREL5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRACMATREL5.Reg) & 0xfff00000) >> 20
}

// SCT.EV0_STATE: SCT event state register 0
func (o *SCT_Type) SetEV0_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV0_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV0_STATE.Reg, volatile.LoadUint32(&o.EV0_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV0_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV0_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV0_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV0_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV0_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV0_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV0_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV0_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV0_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV0_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV0_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV0_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV0_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV0_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV0_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV0_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV0_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV0_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV0_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV0_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV0_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV0_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV0_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV0_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV0_CTRL.Reg, volatile.LoadUint32(&o.EV0_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV0_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV0_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV1_STATE: SCT event state register 0
func (o *SCT_Type) SetEV1_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV1_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV1_STATE.Reg, volatile.LoadUint32(&o.EV1_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV1_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV1_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV1_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV1_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV1_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV1_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV1_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV1_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV1_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV1_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV1_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV1_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV1_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV1_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV1_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV1_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV1_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV1_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV1_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV1_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV1_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV1_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV1_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV1_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV1_CTRL.Reg, volatile.LoadUint32(&o.EV1_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV1_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV1_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV2_STATE: SCT event state register 0
func (o *SCT_Type) SetEV2_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV2_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV2_STATE.Reg, volatile.LoadUint32(&o.EV2_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV2_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV2_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV2_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV2_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV2_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV2_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV2_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV2_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV2_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV2_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV2_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV2_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV2_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV2_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV2_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV2_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV2_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV2_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV2_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV2_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV2_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV2_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV2_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV2_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV2_CTRL.Reg, volatile.LoadUint32(&o.EV2_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV2_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV2_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV3_STATE: SCT event state register 0
func (o *SCT_Type) SetEV3_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV3_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV3_STATE.Reg, volatile.LoadUint32(&o.EV3_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV3_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV3_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV3_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV3_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV3_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV3_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV3_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV3_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV3_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV3_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV3_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV3_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV3_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV3_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV3_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV3_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV3_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV3_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV3_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV3_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV3_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV3_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV3_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV3_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV3_CTRL.Reg, volatile.LoadUint32(&o.EV3_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV3_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV3_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV4_STATE: SCT event state register 0
func (o *SCT_Type) SetEV4_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV4_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV4_STATE.Reg, volatile.LoadUint32(&o.EV4_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV4_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV4_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV4_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV4_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV4_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV4_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV4_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV4_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV4_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV4_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV4_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV4_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV4_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV4_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV4_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV4_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV4_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV4_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV4_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV4_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV4_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV4_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV4_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV4_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV4_CTRL.Reg, volatile.LoadUint32(&o.EV4_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV4_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV4_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV5_STATE: SCT event state register 0
func (o *SCT_Type) SetEV5_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV5_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV5_STATE.Reg, volatile.LoadUint32(&o.EV5_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV5_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV5_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV5_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV5_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV5_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV5_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV5_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV5_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV5_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV5_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV5_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV5_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV5_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV5_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV5_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV5_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV5_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV5_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV5_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV5_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV5_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV5_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV5_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV5_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV5_CTRL.Reg, volatile.LoadUint32(&o.EV5_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV5_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV5_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV6_STATE: SCT event state register 0
func (o *SCT_Type) SetEV6_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV6_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV6_STATE.Reg, volatile.LoadUint32(&o.EV6_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV6_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV6_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV6_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV6_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV6_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV6_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV6_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV6_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV6_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV6_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV6_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV6_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV6_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV6_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV6_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV6_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV6_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV6_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV6_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV6_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV6_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV6_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV6_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV6_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV6_CTRL.Reg, volatile.LoadUint32(&o.EV6_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV6_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV6_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV7_STATE: SCT event state register 0
func (o *SCT_Type) SetEV7_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV7_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV7_STATE.Reg, volatile.LoadUint32(&o.EV7_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV7_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV7_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV7_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV7_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV7_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV7_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV7_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV7_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV7_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV7_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV7_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV7_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV7_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV7_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV7_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV7_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV7_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV7_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV7_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV7_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV7_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV7_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV7_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV7_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV7_CTRL.Reg, volatile.LoadUint32(&o.EV7_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV7_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV7_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV8_STATE: SCT event state register 0
func (o *SCT_Type) SetEV8_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV8_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV8_STATE.Reg, volatile.LoadUint32(&o.EV8_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV8_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV8_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV8_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV8_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV8_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV8_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV8_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV8_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV8_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV8_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV8_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV8_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV8_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV8_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV8_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV8_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV8_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV8_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV8_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV8_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV8_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV8_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV8_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV8_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV8_CTRL.Reg, volatile.LoadUint32(&o.EV8_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV8_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV8_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV9_STATE: SCT event state register 0
func (o *SCT_Type) SetEV9_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV9_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV9_STATE.Reg, volatile.LoadUint32(&o.EV9_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV9_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV9_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV9_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV9_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV9_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV9_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV9_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV9_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV9_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV9_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV9_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV9_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV9_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV9_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV9_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV9_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV9_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV9_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV9_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV9_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV9_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV9_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV9_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV9_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV9_CTRL.Reg, volatile.LoadUint32(&o.EV9_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV9_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV9_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV10_STATE: SCT event state register 0
func (o *SCT_Type) SetEV10_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV10_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV10_STATE.Reg, volatile.LoadUint32(&o.EV10_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV10_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV10_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV10_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV10_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV10_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV10_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV10_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV10_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV10_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV10_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV10_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV10_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV10_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV10_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV10_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV10_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV10_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV10_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV10_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV10_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV10_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV10_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV10_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV10_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV10_CTRL.Reg, volatile.LoadUint32(&o.EV10_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV10_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV10_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV11_STATE: SCT event state register 0
func (o *SCT_Type) SetEV11_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV11_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV11_STATE.Reg, volatile.LoadUint32(&o.EV11_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV11_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV11_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV11_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV11_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV11_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV11_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV11_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV11_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV11_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV11_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV11_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV11_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV11_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV11_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV11_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV11_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV11_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV11_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV11_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV11_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV11_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV11_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV11_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV11_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV11_CTRL.Reg, volatile.LoadUint32(&o.EV11_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV11_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV11_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV12_STATE: SCT event state register 0
func (o *SCT_Type) SetEV12_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV12_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV12_STATE.Reg, volatile.LoadUint32(&o.EV12_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV12_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV12_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV12_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV12_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV12_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV12_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV12_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV12_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV12_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV12_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV12_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV12_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV12_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV12_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV12_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV12_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV12_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV12_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV12_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV12_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV12_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV12_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV12_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV12_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV12_CTRL.Reg, volatile.LoadUint32(&o.EV12_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV12_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV12_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV13_STATE: SCT event state register 0
func (o *SCT_Type) SetEV13_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV13_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV13_STATE.Reg, volatile.LoadUint32(&o.EV13_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV13_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV13_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV13_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV13_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV13_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV13_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV13_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV13_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV13_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV13_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV13_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV13_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV13_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV13_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV13_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV13_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV13_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV13_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV13_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV13_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV13_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV13_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV13_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV13_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV13_CTRL.Reg, volatile.LoadUint32(&o.EV13_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV13_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV13_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV14_STATE: SCT event state register 0
func (o *SCT_Type) SetEV14_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV14_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV14_STATE.Reg, volatile.LoadUint32(&o.EV14_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV14_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV14_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV14_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV14_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV14_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV14_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV14_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV14_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV14_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV14_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV14_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV14_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV14_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV14_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV14_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV14_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV14_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV14_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV14_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV14_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV14_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV14_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV14_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV14_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV14_CTRL.Reg, volatile.LoadUint32(&o.EV14_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV14_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV14_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.EV15_STATE: SCT event state register 0
func (o *SCT_Type) SetEV15_STATE_STATEMSK0(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK0() uint32 {
	return volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x1
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK1(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK1() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK2(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK2() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK3(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK3() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK4(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK4() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK5(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK5() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK6(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK6() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK7(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK7() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK8(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK8() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK9(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK9() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK10(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK10() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK11(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK11() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK12(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK12() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK13(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK13() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK14(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK14() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK15(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK15() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK16(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x10000)|value<<16)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK16() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x10000) >> 16
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK17(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x20000)|value<<17)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK17() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x20000) >> 17
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK18(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x40000)|value<<18)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK18() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x40000) >> 18
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK19(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x80000)|value<<19)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK19() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x80000) >> 19
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK20(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK20() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK21(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x200000)|value<<21)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK21() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x200000) >> 21
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK22(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x400000)|value<<22)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK22() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x400000) >> 22
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK23(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x800000)|value<<23)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK23() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x800000) >> 23
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK24(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x1000000)|value<<24)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK24() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x1000000) >> 24
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK25(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK25() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x2000000) >> 25
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK26(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK26() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x4000000) >> 26
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK27(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK27() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x8000000) >> 27
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK28(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK28() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x10000000) >> 28
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK29(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK29() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x20000000) >> 29
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK30(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK30() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x40000000) >> 30
}
func (o *SCT_Type) SetEV15_STATE_STATEMSK31(value uint32) {
	volatile.StoreUint32(&o.EV15_STATE.Reg, volatile.LoadUint32(&o.EV15_STATE.Reg)&^(0x80000000)|value<<31)
}
func (o *SCT_Type) GetEV15_STATE_STATEMSK31() uint32 {
	return (volatile.LoadUint32(&o.EV15_STATE.Reg) & 0x80000000) >> 31
}

// SCT.EV15_CTRL: SCT event control register 0
func (o *SCT_Type) SetEV15_CTRL_MATCHSEL(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0xf)|value)
}
func (o *SCT_Type) GetEV15_CTRL_MATCHSEL() uint32 {
	return volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0xf
}
func (o *SCT_Type) SetEV15_CTRL_HEVENT(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetEV15_CTRL_HEVENT() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetEV15_CTRL_OUTSEL(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetEV15_CTRL_OUTSEL() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetEV15_CTRL_IOSEL(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0x3c0)|value<<6)
}
func (o *SCT_Type) GetEV15_CTRL_IOSEL() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0x3c0) >> 6
}
func (o *SCT_Type) SetEV15_CTRL_IOCOND(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *SCT_Type) GetEV15_CTRL_IOCOND() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0xc00) >> 10
}
func (o *SCT_Type) SetEV15_CTRL_COMBMODE(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *SCT_Type) GetEV15_CTRL_COMBMODE() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0x3000) >> 12
}
func (o *SCT_Type) SetEV15_CTRL_STATELD(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetEV15_CTRL_STATELD() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetEV15_CTRL_STATEV(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *SCT_Type) GetEV15_CTRL_STATEV() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0xf8000) >> 15
}
func (o *SCT_Type) SetEV15_CTRL_MATCHMEM(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SCT_Type) GetEV15_CTRL_MATCHMEM() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0x100000) >> 20
}
func (o *SCT_Type) SetEV15_CTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *SCT_Type) GetEV15_CTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0x600000) >> 21
}
func (o *SCT_Type) SetEV15_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EV15_CTRL.Reg, volatile.LoadUint32(&o.EV15_CTRL.Reg)&^(0xff800000)|value<<23)
}
func (o *SCT_Type) GetEV15_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EV15_CTRL.Reg) & 0xff800000) >> 23
}

// SCT.OUT0_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT0_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT0_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT0_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT0_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT0_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT0_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT0_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT0_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT0_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT0_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT0_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT0_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT0_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT0_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT0_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT0_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT0_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT0_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT0_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT0_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT0_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT0_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT0_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT0_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT0_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT0_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT0_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT0_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT0_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT0_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT0_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT0_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT0_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT0_SET.Reg, volatile.LoadUint32(&o.OUT0_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT0_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT0_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT0_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT0_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT0_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT0_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT0_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT0_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT0_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT0_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT0_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT0_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT0_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT0_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT0_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT0_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT0_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT0_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT0_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT0_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT0_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT0_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT0_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT0_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT0_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT0_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT0_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT0_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT0_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT0_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT0_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT0_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT0_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT0_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT0_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT0_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT0_CLR.Reg, volatile.LoadUint32(&o.OUT0_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT0_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT0_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT1_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT1_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT1_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT1_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT1_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT1_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT1_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT1_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT1_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT1_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT1_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT1_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT1_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT1_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT1_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT1_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT1_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT1_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT1_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT1_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT1_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT1_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT1_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT1_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT1_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT1_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT1_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT1_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT1_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT1_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT1_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT1_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT1_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT1_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT1_SET.Reg, volatile.LoadUint32(&o.OUT1_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT1_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT1_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT1_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT1_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT1_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT1_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT1_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT1_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT1_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT1_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT1_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT1_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT1_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT1_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT1_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT1_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT1_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT1_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT1_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT1_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT1_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT1_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT1_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT1_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT1_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT1_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT1_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT1_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT1_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT1_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT1_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT1_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT1_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT1_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT1_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT1_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT1_CLR.Reg, volatile.LoadUint32(&o.OUT1_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT1_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT1_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT2_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT2_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT2_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT2_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT2_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT2_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT2_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT2_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT2_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT2_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT2_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT2_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT2_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT2_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT2_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT2_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT2_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT2_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT2_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT2_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT2_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT2_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT2_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT2_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT2_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT2_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT2_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT2_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT2_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT2_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT2_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT2_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT2_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT2_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT2_SET.Reg, volatile.LoadUint32(&o.OUT2_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT2_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT2_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT2_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT2_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT2_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT2_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT2_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT2_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT2_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT2_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT2_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT2_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT2_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT2_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT2_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT2_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT2_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT2_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT2_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT2_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT2_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT2_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT2_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT2_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT2_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT2_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT2_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT2_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT2_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT2_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT2_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT2_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT2_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT2_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT2_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT2_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT2_CLR.Reg, volatile.LoadUint32(&o.OUT2_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT2_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT2_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT3_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT3_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT3_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT3_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT3_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT3_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT3_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT3_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT3_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT3_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT3_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT3_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT3_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT3_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT3_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT3_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT3_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT3_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT3_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT3_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT3_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT3_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT3_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT3_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT3_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT3_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT3_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT3_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT3_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT3_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT3_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT3_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT3_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT3_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT3_SET.Reg, volatile.LoadUint32(&o.OUT3_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT3_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT3_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT3_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT3_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT3_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT3_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT3_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT3_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT3_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT3_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT3_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT3_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT3_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT3_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT3_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT3_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT3_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT3_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT3_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT3_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT3_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT3_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT3_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT3_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT3_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT3_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT3_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT3_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT3_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT3_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT3_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT3_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT3_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT3_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT3_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT3_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT3_CLR.Reg, volatile.LoadUint32(&o.OUT3_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT3_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT3_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT4_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT4_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT4_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT4_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT4_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT4_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT4_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT4_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT4_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT4_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT4_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT4_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT4_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT4_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT4_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT4_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT4_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT4_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT4_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT4_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT4_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT4_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT4_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT4_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT4_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT4_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT4_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT4_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT4_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT4_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT4_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT4_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT4_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT4_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT4_SET.Reg, volatile.LoadUint32(&o.OUT4_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT4_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT4_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT4_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT4_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT4_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT4_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT4_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT4_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT4_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT4_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT4_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT4_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT4_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT4_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT4_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT4_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT4_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT4_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT4_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT4_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT4_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT4_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT4_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT4_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT4_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT4_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT4_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT4_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT4_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT4_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT4_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT4_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT4_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT4_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT4_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT4_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT4_CLR.Reg, volatile.LoadUint32(&o.OUT4_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT4_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT4_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT5_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT5_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT5_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT5_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT5_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT5_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT5_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT5_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT5_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT5_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT5_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT5_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT5_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT5_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT5_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT5_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT5_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT5_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT5_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT5_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT5_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT5_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT5_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT5_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT5_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT5_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT5_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT5_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT5_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT5_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT5_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT5_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT5_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT5_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT5_SET.Reg, volatile.LoadUint32(&o.OUT5_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT5_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT5_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT5_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT5_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT5_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT5_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT5_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT5_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT5_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT5_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT5_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT5_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT5_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT5_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT5_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT5_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT5_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT5_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT5_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT5_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT5_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT5_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT5_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT5_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT5_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT5_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT5_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT5_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT5_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT5_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT5_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT5_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT5_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT5_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT5_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT5_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT5_CLR.Reg, volatile.LoadUint32(&o.OUT5_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT5_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT5_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT6_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT6_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT6_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT6_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT6_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT6_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT6_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT6_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT6_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT6_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT6_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT6_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT6_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT6_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT6_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT6_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT6_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT6_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT6_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT6_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT6_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT6_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT6_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT6_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT6_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT6_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT6_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT6_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT6_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT6_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT6_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT6_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT6_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT6_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT6_SET.Reg, volatile.LoadUint32(&o.OUT6_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT6_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT6_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT6_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT6_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT6_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT6_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT6_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT6_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT6_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT6_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT6_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT6_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT6_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT6_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT6_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT6_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT6_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT6_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT6_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT6_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT6_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT6_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT6_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT6_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT6_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT6_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT6_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT6_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT6_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT6_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT6_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT6_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT6_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT6_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT6_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT6_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT6_CLR.Reg, volatile.LoadUint32(&o.OUT6_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT6_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT6_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT7_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT7_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT7_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT7_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT7_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT7_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT7_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT7_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT7_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT7_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT7_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT7_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT7_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT7_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT7_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT7_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT7_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT7_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT7_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT7_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT7_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT7_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT7_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT7_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT7_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT7_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT7_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT7_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT7_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT7_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT7_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT7_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT7_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT7_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT7_SET.Reg, volatile.LoadUint32(&o.OUT7_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT7_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT7_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT7_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT7_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT7_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT7_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT7_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT7_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT7_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT7_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT7_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT7_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT7_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT7_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT7_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT7_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT7_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT7_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT7_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT7_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT7_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT7_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT7_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT7_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT7_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT7_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT7_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT7_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT7_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT7_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT7_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT7_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT7_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT7_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT7_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT7_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT7_CLR.Reg, volatile.LoadUint32(&o.OUT7_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT7_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT7_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT8_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT8_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT8_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT8_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT8_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT8_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT8_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT8_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT8_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT8_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT8_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT8_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT8_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT8_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT8_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT8_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT8_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT8_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT8_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT8_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT8_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT8_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT8_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT8_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT8_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT8_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT8_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT8_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT8_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT8_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT8_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT8_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT8_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT8_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT8_SET.Reg, volatile.LoadUint32(&o.OUT8_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT8_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT8_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT8_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT8_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT8_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT8_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT8_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT8_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT8_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT8_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT8_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT8_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT8_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT8_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT8_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT8_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT8_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT8_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT8_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT8_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT8_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT8_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT8_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT8_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT8_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT8_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT8_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT8_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT8_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT8_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT8_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT8_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT8_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT8_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT8_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT8_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT8_CLR.Reg, volatile.LoadUint32(&o.OUT8_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT8_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT8_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT9_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT9_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT9_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT9_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT9_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT9_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT9_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT9_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT9_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT9_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT9_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT9_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT9_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT9_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT9_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT9_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT9_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT9_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT9_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT9_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT9_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT9_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT9_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT9_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT9_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT9_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT9_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT9_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT9_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT9_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT9_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT9_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT9_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT9_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT9_SET.Reg, volatile.LoadUint32(&o.OUT9_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT9_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT9_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT9_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT9_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT9_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT9_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT9_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT9_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT9_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT9_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT9_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT9_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT9_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT9_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT9_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT9_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT9_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT9_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT9_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT9_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT9_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT9_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT9_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT9_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT9_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT9_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT9_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT9_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT9_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT9_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT9_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT9_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT9_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT9_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT9_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT9_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT9_CLR.Reg, volatile.LoadUint32(&o.OUT9_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT9_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT9_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT10_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT10_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT10_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT10_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT10_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT10_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT10_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT10_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT10_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT10_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT10_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT10_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT10_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT10_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT10_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT10_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT10_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT10_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT10_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT10_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT10_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT10_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT10_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT10_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT10_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT10_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT10_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT10_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT10_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT10_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT10_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT10_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT10_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT10_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT10_SET.Reg, volatile.LoadUint32(&o.OUT10_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT10_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT10_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT10_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT10_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT10_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT10_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT10_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT10_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT10_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT10_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT10_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT10_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT10_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT10_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT10_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT10_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT10_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT10_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT10_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT10_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT10_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT10_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT10_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT10_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT10_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT10_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT10_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT10_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT10_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT10_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT10_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT10_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT10_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT10_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT10_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT10_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT10_CLR.Reg, volatile.LoadUint32(&o.OUT10_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT10_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT10_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT11_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT11_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT11_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT11_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT11_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT11_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT11_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT11_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT11_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT11_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT11_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT11_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT11_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT11_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT11_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT11_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT11_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT11_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT11_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT11_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT11_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT11_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT11_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT11_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT11_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT11_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT11_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT11_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT11_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT11_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT11_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT11_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT11_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT11_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT11_SET.Reg, volatile.LoadUint32(&o.OUT11_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT11_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT11_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT11_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT11_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT11_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT11_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT11_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT11_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT11_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT11_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT11_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT11_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT11_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT11_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT11_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT11_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT11_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT11_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT11_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT11_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT11_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT11_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT11_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT11_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT11_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT11_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT11_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT11_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT11_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT11_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT11_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT11_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT11_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT11_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT11_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT11_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT11_CLR.Reg, volatile.LoadUint32(&o.OUT11_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT11_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT11_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT12_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT12_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT12_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT12_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT12_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT12_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT12_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT12_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT12_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT12_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT12_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT12_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT12_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT12_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT12_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT12_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT12_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT12_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT12_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT12_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT12_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT12_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT12_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT12_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT12_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT12_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT12_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT12_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT12_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT12_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT12_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT12_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT12_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT12_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT12_SET.Reg, volatile.LoadUint32(&o.OUT12_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT12_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT12_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT12_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT12_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT12_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT12_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT12_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT12_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT12_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT12_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT12_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT12_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT12_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT12_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT12_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT12_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT12_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT12_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT12_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT12_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT12_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT12_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT12_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT12_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT12_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT12_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT12_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT12_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT12_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT12_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT12_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT12_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT12_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT12_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT12_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT12_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT12_CLR.Reg, volatile.LoadUint32(&o.OUT12_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT12_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT12_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT13_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT13_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT13_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT13_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT13_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT13_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT13_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT13_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT13_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT13_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT13_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT13_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT13_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT13_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT13_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT13_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT13_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT13_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT13_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT13_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT13_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT13_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT13_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT13_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT13_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT13_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT13_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT13_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT13_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT13_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT13_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT13_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT13_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT13_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT13_SET.Reg, volatile.LoadUint32(&o.OUT13_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT13_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT13_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT13_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT13_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT13_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT13_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT13_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT13_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT13_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT13_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT13_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT13_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT13_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT13_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT13_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT13_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT13_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT13_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT13_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT13_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT13_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT13_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT13_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT13_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT13_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT13_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT13_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT13_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT13_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT13_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT13_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT13_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT13_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT13_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT13_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT13_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT13_CLR.Reg, volatile.LoadUint32(&o.OUT13_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT13_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT13_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT14_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT14_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT14_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT14_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT14_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT14_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT14_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT14_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT14_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT14_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT14_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT14_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT14_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT14_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT14_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT14_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT14_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT14_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT14_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT14_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT14_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT14_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT14_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT14_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT14_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT14_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT14_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT14_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT14_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT14_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT14_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT14_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT14_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT14_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT14_SET.Reg, volatile.LoadUint32(&o.OUT14_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT14_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT14_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT14_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT14_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT14_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT14_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT14_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT14_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT14_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT14_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT14_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT14_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT14_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT14_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT14_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT14_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT14_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT14_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT14_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT14_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT14_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT14_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT14_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT14_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT14_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT14_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT14_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT14_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT14_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT14_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT14_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT14_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT14_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT14_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT14_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT14_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT14_CLR.Reg, volatile.LoadUint32(&o.OUT14_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT14_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT14_CLR.Reg) & 0xffff0000) >> 16
}

// SCT.OUT15_SET: SCT output 0 set register
func (o *SCT_Type) SetOUT15_SET_SET0(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT15_SET_SET0() uint32 {
	return volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x1
}
func (o *SCT_Type) SetOUT15_SET_SET1(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT15_SET_SET1() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT15_SET_SET2(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT15_SET_SET2() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT15_SET_SET3(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT15_SET_SET3() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT15_SET_SET4(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT15_SET_SET4() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT15_SET_SET5(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT15_SET_SET5() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT15_SET_SET6(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT15_SET_SET6() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT15_SET_SET7(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT15_SET_SET7() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT15_SET_SET8(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT15_SET_SET8() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT15_SET_SET9(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT15_SET_SET9() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT15_SET_SET10(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT15_SET_SET10() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT15_SET_SET11(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT15_SET_SET11() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT15_SET_SET12(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT15_SET_SET12() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT15_SET_SET13(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT15_SET_SET13() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT15_SET_SET14(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT15_SET_SET14() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT15_SET_SET15(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT15_SET_SET15() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT15_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT15_SET.Reg, volatile.LoadUint32(&o.OUT15_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT15_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT15_SET.Reg) & 0xffff0000) >> 16
}

// SCT.OUT15_CLR: SCT output 0 clear register
func (o *SCT_Type) SetOUT15_CLR_CLR0(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x1)|value)
}
func (o *SCT_Type) GetOUT15_CLR_CLR0() uint32 {
	return volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x1
}
func (o *SCT_Type) SetOUT15_CLR_CLR1(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SCT_Type) GetOUT15_CLR_CLR1() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x2) >> 1
}
func (o *SCT_Type) SetOUT15_CLR_CLR2(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SCT_Type) GetOUT15_CLR_CLR2() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x4) >> 2
}
func (o *SCT_Type) SetOUT15_CLR_CLR3(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SCT_Type) GetOUT15_CLR_CLR3() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x8) >> 3
}
func (o *SCT_Type) SetOUT15_CLR_CLR4(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SCT_Type) GetOUT15_CLR_CLR4() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x10) >> 4
}
func (o *SCT_Type) SetOUT15_CLR_CLR5(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SCT_Type) GetOUT15_CLR_CLR5() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x20) >> 5
}
func (o *SCT_Type) SetOUT15_CLR_CLR6(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SCT_Type) GetOUT15_CLR_CLR6() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x40) >> 6
}
func (o *SCT_Type) SetOUT15_CLR_CLR7(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SCT_Type) GetOUT15_CLR_CLR7() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x80) >> 7
}
func (o *SCT_Type) SetOUT15_CLR_CLR8(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SCT_Type) GetOUT15_CLR_CLR8() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x100) >> 8
}
func (o *SCT_Type) SetOUT15_CLR_CLR9(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SCT_Type) GetOUT15_CLR_CLR9() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x200) >> 9
}
func (o *SCT_Type) SetOUT15_CLR_CLR10(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SCT_Type) GetOUT15_CLR_CLR10() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x400) >> 10
}
func (o *SCT_Type) SetOUT15_CLR_CLR11(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SCT_Type) GetOUT15_CLR_CLR11() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x800) >> 11
}
func (o *SCT_Type) SetOUT15_CLR_CLR12(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCT_Type) GetOUT15_CLR_CLR12() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x1000) >> 12
}
func (o *SCT_Type) SetOUT15_CLR_CLR13(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCT_Type) GetOUT15_CLR_CLR13() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x2000) >> 13
}
func (o *SCT_Type) SetOUT15_CLR_CLR14(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCT_Type) GetOUT15_CLR_CLR14() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x4000) >> 14
}
func (o *SCT_Type) SetOUT15_CLR_CLR15(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCT_Type) GetOUT15_CLR_CLR15() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0x8000) >> 15
}
func (o *SCT_Type) SetOUT15_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OUT15_CLR.Reg, volatile.LoadUint32(&o.OUT15_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCT_Type) GetOUT15_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OUT15_CLR.Reg) & 0xffff0000) >> 16
}

// General Purpose DMA (GPDMA)
type GPDMA_Type struct {
	INTSTAT       volatile.Register32 // 0x0
	INTTCSTAT     volatile.Register32 // 0x4
	INTTCCLEAR    volatile.Register32 // 0x8
	INTERRSTAT    volatile.Register32 // 0xC
	INTERRCLR     volatile.Register32 // 0x10
	RAWINTTCSTAT  volatile.Register32 // 0x14
	RAWINTERRSTAT volatile.Register32 // 0x18
	ENBLDCHNS     volatile.Register32 // 0x1C
	SOFTBREQ      volatile.Register32 // 0x20
	SOFTSREQ      volatile.Register32 // 0x24
	SOFTLBREQ     volatile.Register32 // 0x28
	SOFTLSREQ     volatile.Register32 // 0x2C
	CONFIG        volatile.Register32 // 0x30
	SYNC          volatile.Register32 // 0x34
	_             [200]byte
	C0SRCADDR     volatile.Register32 // 0x100
	C0DESTADDR    volatile.Register32 // 0x104
	C0LLI         volatile.Register32 // 0x108
	C0CONTROL     volatile.Register32 // 0x10C
	C0CONFIG      volatile.Register32 // 0x110
	_             [12]byte
	C1SRCADDR     volatile.Register32 // 0x120
	C1DESTADDR    volatile.Register32 // 0x124
	C1LLI         volatile.Register32 // 0x128
	C1CONTROL     volatile.Register32 // 0x12C
	C1CONFIG      volatile.Register32 // 0x130
	_             [12]byte
	C2SRCADDR     volatile.Register32 // 0x140
	C2DESTADDR    volatile.Register32 // 0x144
	C2LLI         volatile.Register32 // 0x148
	C2CONTROL     volatile.Register32 // 0x14C
	C2CONFIG      volatile.Register32 // 0x150
	_             [12]byte
	C3SRCADDR     volatile.Register32 // 0x160
	C3DESTADDR    volatile.Register32 // 0x164
	C3LLI         volatile.Register32 // 0x168
	C3CONTROL     volatile.Register32 // 0x16C
	C3CONFIG      volatile.Register32 // 0x170
	_             [12]byte
	C4SRCADDR     volatile.Register32 // 0x180
	C4DESTADDR    volatile.Register32 // 0x184
	C4LLI         volatile.Register32 // 0x188
	C4CONTROL     volatile.Register32 // 0x18C
	C4CONFIG      volatile.Register32 // 0x190
	_             [12]byte
	C5SRCADDR     volatile.Register32 // 0x1A0
	C5DESTADDR    volatile.Register32 // 0x1A4
	C5LLI         volatile.Register32 // 0x1A8
	C5CONTROL     volatile.Register32 // 0x1AC
	C5CONFIG      volatile.Register32 // 0x1B0
	_             [12]byte
	C6SRCADDR     volatile.Register32 // 0x1C0
	C6DESTADDR    volatile.Register32 // 0x1C4
	C6LLI         volatile.Register32 // 0x1C8
	C6CONTROL     volatile.Register32 // 0x1CC
	C6CONFIG      volatile.Register32 // 0x1D0
	_             [12]byte
	C7SRCADDR     volatile.Register32 // 0x1E0
	C7DESTADDR    volatile.Register32 // 0x1E4
	C7LLI         volatile.Register32 // 0x1E8
	C7CONTROL     volatile.Register32 // 0x1EC
	C7CONFIG      volatile.Register32 // 0x1F0
}

// GPDMA.INTSTAT: DMA Interrupt Status Register
func (o *GPDMA_Type) SetINTSTAT_INTSTAT0(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT0() uint32 {
	return volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT1(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT1() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT2(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT2() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT3(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT3() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT4(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT4() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT5(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT5() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT6(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT6() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT7(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT7() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.INTTCSTAT: DMA Interrupt Terminal Count Request Status Register
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT0(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT0() uint32 {
	return volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT1(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT1() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT2(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT2() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT3(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT3() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT4(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT4() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT5(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT5() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT6(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT6() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT7(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT7() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTTCSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTTCSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.INTTCCLEAR: DMA Interrupt Terminal Count Request Clear Register
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR0(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR0() uint32 {
	return volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR1(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR1() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR2(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR2() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR3(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR3() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR4(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR4() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR5(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR5() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR6(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR6() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR7(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR7() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTTCCLEAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTTCCLEAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0xffffff00) >> 8
}

// GPDMA.INTERRSTAT: DMA Interrupt Error Status Register
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT0(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT0() uint32 {
	return volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT1(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT1() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT2(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT2() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT3(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT3() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT4(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT4() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT5(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT5() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT6(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT6() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT7(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT7() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTERRSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTERRSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.INTERRCLR: DMA Interrupt Error Clear Register
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR0(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR0() uint32 {
	return volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR1(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR1() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR2(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR2() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR3(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR3() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR4(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR4() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR5(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR5() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR6(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR6() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR7(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR7() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTERRCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTERRCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0xffffff00) >> 8
}

// GPDMA.RAWINTTCSTAT: DMA Raw Interrupt Terminal Count Status Register
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT0(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT0() uint32 {
	return volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT1(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT1() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT2(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT2() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT3(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT3() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT4(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT4() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT5(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT5() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT6(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT6() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT7(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT7() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.RAWINTERRSTAT: DMA Raw Error Interrupt Status Register
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT0(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT0() uint32 {
	return volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT1(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT1() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT2(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT2() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT3(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT3() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT4(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT4() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT5(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT5() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT6(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT6() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT7(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT7() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.ENBLDCHNS: DMA Enabled Channel Register
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS0(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS0() uint32 {
	return volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x1
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS1(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS1() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS2(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS2() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS3(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS3() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS4(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS4() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS5(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS5() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS6(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS6() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS7(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS7() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetENBLDCHNS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetENBLDCHNS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0xffffff00) >> 8
}

// GPDMA.SOFTBREQ: DMA Software Burst Request Register
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ0(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ0() uint32 {
	return volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x1
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ1(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ1() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ2(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ2() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ3(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ3() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ4(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ4() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ5(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ5() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ6(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ6() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ7(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ7() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ8(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ8() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ9(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ9() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ10(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ10() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ11(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ11() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ12(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ12() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ13(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ13() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ14(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ14() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ15(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ15() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSOFTBREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSOFTBREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0xffff0000) >> 16
}

// GPDMA.SOFTSREQ: DMA Software Single Request Register
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ0(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ0() uint32 {
	return volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x1
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ1(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ2(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ3(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ4(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ5(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ6(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ7(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ8(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ8() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ9(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ9() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ10(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ10() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ11(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ11() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ12(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ12() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ13(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ13() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ14(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ14() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ15(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ15() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSOFTSREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSOFTSREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0xffff0000) >> 16
}

// GPDMA.SOFTLBREQ: DMA Software Last Burst Request Register
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ0(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ0() uint32 {
	return volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x1
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ1(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ1() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ2(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ2() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ3(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ3() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ4(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ4() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ5(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ5() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ6(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ6() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ7(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ7() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ8(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ8() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ9(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ9() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ10(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ10() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ11(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ11() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ12(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ12() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ13(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ13() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ14(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ14() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ15(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ15() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSOFTLBREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSOFTLBREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0xffff0000) >> 16
}

// GPDMA.SOFTLSREQ: DMA Software Last Single Request Register
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ0(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ0() uint32 {
	return volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x1
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ1(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ2(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ3(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ4(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ5(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ6(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ7(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ8(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ8() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ9(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ9() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ10(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ10() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ11(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ11() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ12(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ12() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ13(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ13() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ14(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ14() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ15(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ15() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSOFTLSREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSOFTLSREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0xffff0000) >> 16
}

// GPDMA.CONFIG: DMA Configuration Register
func (o *GPDMA_Type) SetCONFIG_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG_M0(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG_M0() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetCONFIG_M1(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetCONFIG_M1() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *GPDMA_Type) GetCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xfffffff8) >> 3
}

// GPDMA.SYNC: DMA Synchronization Register
func (o *GPDMA_Type) SetSYNC_DMACSYNC0(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC0() uint32 {
	return volatile.LoadUint32(&o.SYNC.Reg) & 0x1
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC1(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC1() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC2(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC2() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC3(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC3() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC4(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC4() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC5(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC5() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC6(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC6() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC7(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC7() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC8(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC8() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC9(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC9() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC10(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC10() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC11(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC11() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC12(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC12() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC13(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC13() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC14(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC14() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC15(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC15() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSYNC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSYNC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0xffff0000) >> 16
}

// GPDMA.C0SRCADDR: DMA Channel Source Address Register
func (o *GPDMA_Type) SetC0SRCADDR(value uint32) {
	volatile.StoreUint32(&o.C0SRCADDR.Reg, value)
}
func (o *GPDMA_Type) GetC0SRCADDR() uint32 {
	return volatile.LoadUint32(&o.C0SRCADDR.Reg)
}

// GPDMA.C0DESTADDR: DMA Channel Destination Address Register
func (o *GPDMA_Type) SetC0DESTADDR(value uint32) {
	volatile.StoreUint32(&o.C0DESTADDR.Reg, value)
}
func (o *GPDMA_Type) GetC0DESTADDR() uint32 {
	return volatile.LoadUint32(&o.C0DESTADDR.Reg)
}

// GPDMA.C0LLI: DMA Channel Linked List Item Register
func (o *GPDMA_Type) SetC0LLI_LM(value uint32) {
	volatile.StoreUint32(&o.C0LLI.Reg, volatile.LoadUint32(&o.C0LLI.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC0LLI_LM() uint32 {
	return volatile.LoadUint32(&o.C0LLI.Reg) & 0x1
}
func (o *GPDMA_Type) SetC0LLI_R(value uint32) {
	volatile.StoreUint32(&o.C0LLI.Reg, volatile.LoadUint32(&o.C0LLI.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetC0LLI_R() uint32 {
	return (volatile.LoadUint32(&o.C0LLI.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetC0LLI_LLI(value uint32) {
	volatile.StoreUint32(&o.C0LLI.Reg, volatile.LoadUint32(&o.C0LLI.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetC0LLI_LLI() uint32 {
	return (volatile.LoadUint32(&o.C0LLI.Reg) & 0xfffffffc) >> 2
}

// GPDMA.C0CONTROL: DMA Channel Control Register
func (o *GPDMA_Type) SetC0CONTROL_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetC0CONTROL_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.C0CONTROL.Reg) & 0xfff
}
func (o *GPDMA_Type) SetC0CONTROL_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetC0CONTROL_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetC0CONTROL_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetC0CONTROL_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetC0CONTROL_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetC0CONTROL_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetC0CONTROL_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetC0CONTROL_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetC0CONTROL_S(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *GPDMA_Type) GetC0CONTROL_S() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x1000000) >> 24
}
func (o *GPDMA_Type) SetC0CONTROL_D(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *GPDMA_Type) GetC0CONTROL_D() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x2000000) >> 25
}
func (o *GPDMA_Type) SetC0CONTROL_SI(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetC0CONTROL_SI() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetC0CONTROL_DI(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetC0CONTROL_DI() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetC0CONTROL_PROT1(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetC0CONTROL_PROT1() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetC0CONTROL_PROT2(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetC0CONTROL_PROT2() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetC0CONTROL_PROT3(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetC0CONTROL_PROT3() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetC0CONTROL_I(value uint32) {
	volatile.StoreUint32(&o.C0CONTROL.Reg, volatile.LoadUint32(&o.C0CONTROL.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetC0CONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.C0CONTROL.Reg) & 0x80000000) >> 31
}

// GPDMA.C0CONFIG: DMA Channel Configuration Register
func (o *GPDMA_Type) SetC0CONFIG_E(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC0CONFIG_E() uint32 {
	return volatile.LoadUint32(&o.C0CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetC0CONFIG_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetC0CONFIG_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C0CONFIG.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetC0CONFIG_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetC0CONFIG_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C0CONFIG.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetC0CONFIG_FLOWCNTRL(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetC0CONFIG_FLOWCNTRL() uint32 {
	return (volatile.LoadUint32(&o.C0CONFIG.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetC0CONFIG_IE(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetC0CONFIG_IE() uint32 {
	return (volatile.LoadUint32(&o.C0CONFIG.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetC0CONFIG_ITC(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetC0CONFIG_ITC() uint32 {
	return (volatile.LoadUint32(&o.C0CONFIG.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetC0CONFIG_L(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetC0CONFIG_L() uint32 {
	return (volatile.LoadUint32(&o.C0CONFIG.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetC0CONFIG_A(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetC0CONFIG_A() uint32 {
	return (volatile.LoadUint32(&o.C0CONFIG.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetC0CONFIG_H(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetC0CONFIG_H() uint32 {
	return (volatile.LoadUint32(&o.C0CONFIG.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetC0CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.C0CONFIG.Reg, volatile.LoadUint32(&o.C0CONFIG.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetC0CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.C0CONFIG.Reg) & 0xfff80000) >> 19
}

// GPDMA.C1SRCADDR: DMA Channel Source Address Register
func (o *GPDMA_Type) SetC1SRCADDR(value uint32) {
	volatile.StoreUint32(&o.C1SRCADDR.Reg, value)
}
func (o *GPDMA_Type) GetC1SRCADDR() uint32 {
	return volatile.LoadUint32(&o.C1SRCADDR.Reg)
}

// GPDMA.C1DESTADDR: DMA Channel Destination Address Register
func (o *GPDMA_Type) SetC1DESTADDR(value uint32) {
	volatile.StoreUint32(&o.C1DESTADDR.Reg, value)
}
func (o *GPDMA_Type) GetC1DESTADDR() uint32 {
	return volatile.LoadUint32(&o.C1DESTADDR.Reg)
}

// GPDMA.C1LLI: DMA Channel Linked List Item Register
func (o *GPDMA_Type) SetC1LLI_LM(value uint32) {
	volatile.StoreUint32(&o.C1LLI.Reg, volatile.LoadUint32(&o.C1LLI.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC1LLI_LM() uint32 {
	return volatile.LoadUint32(&o.C1LLI.Reg) & 0x1
}
func (o *GPDMA_Type) SetC1LLI_R(value uint32) {
	volatile.StoreUint32(&o.C1LLI.Reg, volatile.LoadUint32(&o.C1LLI.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetC1LLI_R() uint32 {
	return (volatile.LoadUint32(&o.C1LLI.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetC1LLI_LLI(value uint32) {
	volatile.StoreUint32(&o.C1LLI.Reg, volatile.LoadUint32(&o.C1LLI.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetC1LLI_LLI() uint32 {
	return (volatile.LoadUint32(&o.C1LLI.Reg) & 0xfffffffc) >> 2
}

// GPDMA.C1CONTROL: DMA Channel Control Register
func (o *GPDMA_Type) SetC1CONTROL_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetC1CONTROL_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.C1CONTROL.Reg) & 0xfff
}
func (o *GPDMA_Type) SetC1CONTROL_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetC1CONTROL_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetC1CONTROL_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetC1CONTROL_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetC1CONTROL_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetC1CONTROL_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetC1CONTROL_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetC1CONTROL_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetC1CONTROL_S(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *GPDMA_Type) GetC1CONTROL_S() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x1000000) >> 24
}
func (o *GPDMA_Type) SetC1CONTROL_D(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *GPDMA_Type) GetC1CONTROL_D() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x2000000) >> 25
}
func (o *GPDMA_Type) SetC1CONTROL_SI(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetC1CONTROL_SI() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetC1CONTROL_DI(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetC1CONTROL_DI() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetC1CONTROL_PROT1(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetC1CONTROL_PROT1() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetC1CONTROL_PROT2(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetC1CONTROL_PROT2() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetC1CONTROL_PROT3(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetC1CONTROL_PROT3() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetC1CONTROL_I(value uint32) {
	volatile.StoreUint32(&o.C1CONTROL.Reg, volatile.LoadUint32(&o.C1CONTROL.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetC1CONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.C1CONTROL.Reg) & 0x80000000) >> 31
}

// GPDMA.C1CONFIG: DMA Channel Configuration Register
func (o *GPDMA_Type) SetC1CONFIG_E(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC1CONFIG_E() uint32 {
	return volatile.LoadUint32(&o.C1CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetC1CONFIG_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetC1CONFIG_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C1CONFIG.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetC1CONFIG_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetC1CONFIG_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C1CONFIG.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetC1CONFIG_FLOWCNTRL(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetC1CONFIG_FLOWCNTRL() uint32 {
	return (volatile.LoadUint32(&o.C1CONFIG.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetC1CONFIG_IE(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetC1CONFIG_IE() uint32 {
	return (volatile.LoadUint32(&o.C1CONFIG.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetC1CONFIG_ITC(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetC1CONFIG_ITC() uint32 {
	return (volatile.LoadUint32(&o.C1CONFIG.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetC1CONFIG_L(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetC1CONFIG_L() uint32 {
	return (volatile.LoadUint32(&o.C1CONFIG.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetC1CONFIG_A(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetC1CONFIG_A() uint32 {
	return (volatile.LoadUint32(&o.C1CONFIG.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetC1CONFIG_H(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetC1CONFIG_H() uint32 {
	return (volatile.LoadUint32(&o.C1CONFIG.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetC1CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.C1CONFIG.Reg, volatile.LoadUint32(&o.C1CONFIG.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetC1CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.C1CONFIG.Reg) & 0xfff80000) >> 19
}

// GPDMA.C2SRCADDR: DMA Channel Source Address Register
func (o *GPDMA_Type) SetC2SRCADDR(value uint32) {
	volatile.StoreUint32(&o.C2SRCADDR.Reg, value)
}
func (o *GPDMA_Type) GetC2SRCADDR() uint32 {
	return volatile.LoadUint32(&o.C2SRCADDR.Reg)
}

// GPDMA.C2DESTADDR: DMA Channel Destination Address Register
func (o *GPDMA_Type) SetC2DESTADDR(value uint32) {
	volatile.StoreUint32(&o.C2DESTADDR.Reg, value)
}
func (o *GPDMA_Type) GetC2DESTADDR() uint32 {
	return volatile.LoadUint32(&o.C2DESTADDR.Reg)
}

// GPDMA.C2LLI: DMA Channel Linked List Item Register
func (o *GPDMA_Type) SetC2LLI_LM(value uint32) {
	volatile.StoreUint32(&o.C2LLI.Reg, volatile.LoadUint32(&o.C2LLI.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC2LLI_LM() uint32 {
	return volatile.LoadUint32(&o.C2LLI.Reg) & 0x1
}
func (o *GPDMA_Type) SetC2LLI_R(value uint32) {
	volatile.StoreUint32(&o.C2LLI.Reg, volatile.LoadUint32(&o.C2LLI.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetC2LLI_R() uint32 {
	return (volatile.LoadUint32(&o.C2LLI.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetC2LLI_LLI(value uint32) {
	volatile.StoreUint32(&o.C2LLI.Reg, volatile.LoadUint32(&o.C2LLI.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetC2LLI_LLI() uint32 {
	return (volatile.LoadUint32(&o.C2LLI.Reg) & 0xfffffffc) >> 2
}

// GPDMA.C2CONTROL: DMA Channel Control Register
func (o *GPDMA_Type) SetC2CONTROL_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetC2CONTROL_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.C2CONTROL.Reg) & 0xfff
}
func (o *GPDMA_Type) SetC2CONTROL_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetC2CONTROL_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetC2CONTROL_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetC2CONTROL_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetC2CONTROL_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetC2CONTROL_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetC2CONTROL_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetC2CONTROL_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetC2CONTROL_S(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *GPDMA_Type) GetC2CONTROL_S() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x1000000) >> 24
}
func (o *GPDMA_Type) SetC2CONTROL_D(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *GPDMA_Type) GetC2CONTROL_D() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x2000000) >> 25
}
func (o *GPDMA_Type) SetC2CONTROL_SI(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetC2CONTROL_SI() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetC2CONTROL_DI(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetC2CONTROL_DI() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetC2CONTROL_PROT1(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetC2CONTROL_PROT1() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetC2CONTROL_PROT2(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetC2CONTROL_PROT2() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetC2CONTROL_PROT3(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetC2CONTROL_PROT3() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetC2CONTROL_I(value uint32) {
	volatile.StoreUint32(&o.C2CONTROL.Reg, volatile.LoadUint32(&o.C2CONTROL.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetC2CONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.C2CONTROL.Reg) & 0x80000000) >> 31
}

// GPDMA.C2CONFIG: DMA Channel Configuration Register
func (o *GPDMA_Type) SetC2CONFIG_E(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC2CONFIG_E() uint32 {
	return volatile.LoadUint32(&o.C2CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetC2CONFIG_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetC2CONFIG_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C2CONFIG.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetC2CONFIG_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetC2CONFIG_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C2CONFIG.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetC2CONFIG_FLOWCNTRL(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetC2CONFIG_FLOWCNTRL() uint32 {
	return (volatile.LoadUint32(&o.C2CONFIG.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetC2CONFIG_IE(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetC2CONFIG_IE() uint32 {
	return (volatile.LoadUint32(&o.C2CONFIG.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetC2CONFIG_ITC(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetC2CONFIG_ITC() uint32 {
	return (volatile.LoadUint32(&o.C2CONFIG.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetC2CONFIG_L(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetC2CONFIG_L() uint32 {
	return (volatile.LoadUint32(&o.C2CONFIG.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetC2CONFIG_A(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetC2CONFIG_A() uint32 {
	return (volatile.LoadUint32(&o.C2CONFIG.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetC2CONFIG_H(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetC2CONFIG_H() uint32 {
	return (volatile.LoadUint32(&o.C2CONFIG.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetC2CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.C2CONFIG.Reg, volatile.LoadUint32(&o.C2CONFIG.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetC2CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.C2CONFIG.Reg) & 0xfff80000) >> 19
}

// GPDMA.C3SRCADDR: DMA Channel Source Address Register
func (o *GPDMA_Type) SetC3SRCADDR(value uint32) {
	volatile.StoreUint32(&o.C3SRCADDR.Reg, value)
}
func (o *GPDMA_Type) GetC3SRCADDR() uint32 {
	return volatile.LoadUint32(&o.C3SRCADDR.Reg)
}

// GPDMA.C3DESTADDR: DMA Channel Destination Address Register
func (o *GPDMA_Type) SetC3DESTADDR(value uint32) {
	volatile.StoreUint32(&o.C3DESTADDR.Reg, value)
}
func (o *GPDMA_Type) GetC3DESTADDR() uint32 {
	return volatile.LoadUint32(&o.C3DESTADDR.Reg)
}

// GPDMA.C3LLI: DMA Channel Linked List Item Register
func (o *GPDMA_Type) SetC3LLI_LM(value uint32) {
	volatile.StoreUint32(&o.C3LLI.Reg, volatile.LoadUint32(&o.C3LLI.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC3LLI_LM() uint32 {
	return volatile.LoadUint32(&o.C3LLI.Reg) & 0x1
}
func (o *GPDMA_Type) SetC3LLI_R(value uint32) {
	volatile.StoreUint32(&o.C3LLI.Reg, volatile.LoadUint32(&o.C3LLI.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetC3LLI_R() uint32 {
	return (volatile.LoadUint32(&o.C3LLI.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetC3LLI_LLI(value uint32) {
	volatile.StoreUint32(&o.C3LLI.Reg, volatile.LoadUint32(&o.C3LLI.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetC3LLI_LLI() uint32 {
	return (volatile.LoadUint32(&o.C3LLI.Reg) & 0xfffffffc) >> 2
}

// GPDMA.C3CONTROL: DMA Channel Control Register
func (o *GPDMA_Type) SetC3CONTROL_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetC3CONTROL_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.C3CONTROL.Reg) & 0xfff
}
func (o *GPDMA_Type) SetC3CONTROL_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetC3CONTROL_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetC3CONTROL_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetC3CONTROL_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetC3CONTROL_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetC3CONTROL_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetC3CONTROL_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetC3CONTROL_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetC3CONTROL_S(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *GPDMA_Type) GetC3CONTROL_S() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x1000000) >> 24
}
func (o *GPDMA_Type) SetC3CONTROL_D(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *GPDMA_Type) GetC3CONTROL_D() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x2000000) >> 25
}
func (o *GPDMA_Type) SetC3CONTROL_SI(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetC3CONTROL_SI() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetC3CONTROL_DI(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetC3CONTROL_DI() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetC3CONTROL_PROT1(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetC3CONTROL_PROT1() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetC3CONTROL_PROT2(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetC3CONTROL_PROT2() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetC3CONTROL_PROT3(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetC3CONTROL_PROT3() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetC3CONTROL_I(value uint32) {
	volatile.StoreUint32(&o.C3CONTROL.Reg, volatile.LoadUint32(&o.C3CONTROL.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetC3CONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.C3CONTROL.Reg) & 0x80000000) >> 31
}

// GPDMA.C3CONFIG: DMA Channel Configuration Register
func (o *GPDMA_Type) SetC3CONFIG_E(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC3CONFIG_E() uint32 {
	return volatile.LoadUint32(&o.C3CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetC3CONFIG_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetC3CONFIG_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C3CONFIG.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetC3CONFIG_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetC3CONFIG_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C3CONFIG.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetC3CONFIG_FLOWCNTRL(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetC3CONFIG_FLOWCNTRL() uint32 {
	return (volatile.LoadUint32(&o.C3CONFIG.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetC3CONFIG_IE(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetC3CONFIG_IE() uint32 {
	return (volatile.LoadUint32(&o.C3CONFIG.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetC3CONFIG_ITC(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetC3CONFIG_ITC() uint32 {
	return (volatile.LoadUint32(&o.C3CONFIG.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetC3CONFIG_L(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetC3CONFIG_L() uint32 {
	return (volatile.LoadUint32(&o.C3CONFIG.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetC3CONFIG_A(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetC3CONFIG_A() uint32 {
	return (volatile.LoadUint32(&o.C3CONFIG.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetC3CONFIG_H(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetC3CONFIG_H() uint32 {
	return (volatile.LoadUint32(&o.C3CONFIG.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetC3CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.C3CONFIG.Reg, volatile.LoadUint32(&o.C3CONFIG.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetC3CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.C3CONFIG.Reg) & 0xfff80000) >> 19
}

// GPDMA.C4SRCADDR: DMA Channel Source Address Register
func (o *GPDMA_Type) SetC4SRCADDR(value uint32) {
	volatile.StoreUint32(&o.C4SRCADDR.Reg, value)
}
func (o *GPDMA_Type) GetC4SRCADDR() uint32 {
	return volatile.LoadUint32(&o.C4SRCADDR.Reg)
}

// GPDMA.C4DESTADDR: DMA Channel Destination Address Register
func (o *GPDMA_Type) SetC4DESTADDR(value uint32) {
	volatile.StoreUint32(&o.C4DESTADDR.Reg, value)
}
func (o *GPDMA_Type) GetC4DESTADDR() uint32 {
	return volatile.LoadUint32(&o.C4DESTADDR.Reg)
}

// GPDMA.C4LLI: DMA Channel Linked List Item Register
func (o *GPDMA_Type) SetC4LLI_LM(value uint32) {
	volatile.StoreUint32(&o.C4LLI.Reg, volatile.LoadUint32(&o.C4LLI.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC4LLI_LM() uint32 {
	return volatile.LoadUint32(&o.C4LLI.Reg) & 0x1
}
func (o *GPDMA_Type) SetC4LLI_R(value uint32) {
	volatile.StoreUint32(&o.C4LLI.Reg, volatile.LoadUint32(&o.C4LLI.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetC4LLI_R() uint32 {
	return (volatile.LoadUint32(&o.C4LLI.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetC4LLI_LLI(value uint32) {
	volatile.StoreUint32(&o.C4LLI.Reg, volatile.LoadUint32(&o.C4LLI.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetC4LLI_LLI() uint32 {
	return (volatile.LoadUint32(&o.C4LLI.Reg) & 0xfffffffc) >> 2
}

// GPDMA.C4CONTROL: DMA Channel Control Register
func (o *GPDMA_Type) SetC4CONTROL_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetC4CONTROL_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.C4CONTROL.Reg) & 0xfff
}
func (o *GPDMA_Type) SetC4CONTROL_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetC4CONTROL_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetC4CONTROL_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetC4CONTROL_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetC4CONTROL_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetC4CONTROL_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetC4CONTROL_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetC4CONTROL_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetC4CONTROL_S(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *GPDMA_Type) GetC4CONTROL_S() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x1000000) >> 24
}
func (o *GPDMA_Type) SetC4CONTROL_D(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *GPDMA_Type) GetC4CONTROL_D() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x2000000) >> 25
}
func (o *GPDMA_Type) SetC4CONTROL_SI(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetC4CONTROL_SI() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetC4CONTROL_DI(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetC4CONTROL_DI() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetC4CONTROL_PROT1(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetC4CONTROL_PROT1() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetC4CONTROL_PROT2(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetC4CONTROL_PROT2() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetC4CONTROL_PROT3(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetC4CONTROL_PROT3() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetC4CONTROL_I(value uint32) {
	volatile.StoreUint32(&o.C4CONTROL.Reg, volatile.LoadUint32(&o.C4CONTROL.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetC4CONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.C4CONTROL.Reg) & 0x80000000) >> 31
}

// GPDMA.C4CONFIG: DMA Channel Configuration Register
func (o *GPDMA_Type) SetC4CONFIG_E(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC4CONFIG_E() uint32 {
	return volatile.LoadUint32(&o.C4CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetC4CONFIG_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetC4CONFIG_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C4CONFIG.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetC4CONFIG_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetC4CONFIG_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C4CONFIG.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetC4CONFIG_FLOWCNTRL(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetC4CONFIG_FLOWCNTRL() uint32 {
	return (volatile.LoadUint32(&o.C4CONFIG.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetC4CONFIG_IE(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetC4CONFIG_IE() uint32 {
	return (volatile.LoadUint32(&o.C4CONFIG.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetC4CONFIG_ITC(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetC4CONFIG_ITC() uint32 {
	return (volatile.LoadUint32(&o.C4CONFIG.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetC4CONFIG_L(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetC4CONFIG_L() uint32 {
	return (volatile.LoadUint32(&o.C4CONFIG.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetC4CONFIG_A(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetC4CONFIG_A() uint32 {
	return (volatile.LoadUint32(&o.C4CONFIG.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetC4CONFIG_H(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetC4CONFIG_H() uint32 {
	return (volatile.LoadUint32(&o.C4CONFIG.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetC4CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.C4CONFIG.Reg, volatile.LoadUint32(&o.C4CONFIG.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetC4CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.C4CONFIG.Reg) & 0xfff80000) >> 19
}

// GPDMA.C5SRCADDR: DMA Channel Source Address Register
func (o *GPDMA_Type) SetC5SRCADDR(value uint32) {
	volatile.StoreUint32(&o.C5SRCADDR.Reg, value)
}
func (o *GPDMA_Type) GetC5SRCADDR() uint32 {
	return volatile.LoadUint32(&o.C5SRCADDR.Reg)
}

// GPDMA.C5DESTADDR: DMA Channel Destination Address Register
func (o *GPDMA_Type) SetC5DESTADDR(value uint32) {
	volatile.StoreUint32(&o.C5DESTADDR.Reg, value)
}
func (o *GPDMA_Type) GetC5DESTADDR() uint32 {
	return volatile.LoadUint32(&o.C5DESTADDR.Reg)
}

// GPDMA.C5LLI: DMA Channel Linked List Item Register
func (o *GPDMA_Type) SetC5LLI_LM(value uint32) {
	volatile.StoreUint32(&o.C5LLI.Reg, volatile.LoadUint32(&o.C5LLI.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC5LLI_LM() uint32 {
	return volatile.LoadUint32(&o.C5LLI.Reg) & 0x1
}
func (o *GPDMA_Type) SetC5LLI_R(value uint32) {
	volatile.StoreUint32(&o.C5LLI.Reg, volatile.LoadUint32(&o.C5LLI.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetC5LLI_R() uint32 {
	return (volatile.LoadUint32(&o.C5LLI.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetC5LLI_LLI(value uint32) {
	volatile.StoreUint32(&o.C5LLI.Reg, volatile.LoadUint32(&o.C5LLI.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetC5LLI_LLI() uint32 {
	return (volatile.LoadUint32(&o.C5LLI.Reg) & 0xfffffffc) >> 2
}

// GPDMA.C5CONTROL: DMA Channel Control Register
func (o *GPDMA_Type) SetC5CONTROL_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetC5CONTROL_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.C5CONTROL.Reg) & 0xfff
}
func (o *GPDMA_Type) SetC5CONTROL_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetC5CONTROL_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetC5CONTROL_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetC5CONTROL_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetC5CONTROL_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetC5CONTROL_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetC5CONTROL_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetC5CONTROL_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetC5CONTROL_S(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *GPDMA_Type) GetC5CONTROL_S() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x1000000) >> 24
}
func (o *GPDMA_Type) SetC5CONTROL_D(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *GPDMA_Type) GetC5CONTROL_D() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x2000000) >> 25
}
func (o *GPDMA_Type) SetC5CONTROL_SI(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetC5CONTROL_SI() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetC5CONTROL_DI(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetC5CONTROL_DI() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetC5CONTROL_PROT1(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetC5CONTROL_PROT1() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetC5CONTROL_PROT2(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetC5CONTROL_PROT2() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetC5CONTROL_PROT3(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetC5CONTROL_PROT3() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetC5CONTROL_I(value uint32) {
	volatile.StoreUint32(&o.C5CONTROL.Reg, volatile.LoadUint32(&o.C5CONTROL.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetC5CONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.C5CONTROL.Reg) & 0x80000000) >> 31
}

// GPDMA.C5CONFIG: DMA Channel Configuration Register
func (o *GPDMA_Type) SetC5CONFIG_E(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC5CONFIG_E() uint32 {
	return volatile.LoadUint32(&o.C5CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetC5CONFIG_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetC5CONFIG_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C5CONFIG.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetC5CONFIG_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetC5CONFIG_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C5CONFIG.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetC5CONFIG_FLOWCNTRL(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetC5CONFIG_FLOWCNTRL() uint32 {
	return (volatile.LoadUint32(&o.C5CONFIG.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetC5CONFIG_IE(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetC5CONFIG_IE() uint32 {
	return (volatile.LoadUint32(&o.C5CONFIG.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetC5CONFIG_ITC(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetC5CONFIG_ITC() uint32 {
	return (volatile.LoadUint32(&o.C5CONFIG.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetC5CONFIG_L(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetC5CONFIG_L() uint32 {
	return (volatile.LoadUint32(&o.C5CONFIG.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetC5CONFIG_A(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetC5CONFIG_A() uint32 {
	return (volatile.LoadUint32(&o.C5CONFIG.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetC5CONFIG_H(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetC5CONFIG_H() uint32 {
	return (volatile.LoadUint32(&o.C5CONFIG.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetC5CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.C5CONFIG.Reg, volatile.LoadUint32(&o.C5CONFIG.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetC5CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.C5CONFIG.Reg) & 0xfff80000) >> 19
}

// GPDMA.C6SRCADDR: DMA Channel Source Address Register
func (o *GPDMA_Type) SetC6SRCADDR(value uint32) {
	volatile.StoreUint32(&o.C6SRCADDR.Reg, value)
}
func (o *GPDMA_Type) GetC6SRCADDR() uint32 {
	return volatile.LoadUint32(&o.C6SRCADDR.Reg)
}

// GPDMA.C6DESTADDR: DMA Channel Destination Address Register
func (o *GPDMA_Type) SetC6DESTADDR(value uint32) {
	volatile.StoreUint32(&o.C6DESTADDR.Reg, value)
}
func (o *GPDMA_Type) GetC6DESTADDR() uint32 {
	return volatile.LoadUint32(&o.C6DESTADDR.Reg)
}

// GPDMA.C6LLI: DMA Channel Linked List Item Register
func (o *GPDMA_Type) SetC6LLI_LM(value uint32) {
	volatile.StoreUint32(&o.C6LLI.Reg, volatile.LoadUint32(&o.C6LLI.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC6LLI_LM() uint32 {
	return volatile.LoadUint32(&o.C6LLI.Reg) & 0x1
}
func (o *GPDMA_Type) SetC6LLI_R(value uint32) {
	volatile.StoreUint32(&o.C6LLI.Reg, volatile.LoadUint32(&o.C6LLI.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetC6LLI_R() uint32 {
	return (volatile.LoadUint32(&o.C6LLI.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetC6LLI_LLI(value uint32) {
	volatile.StoreUint32(&o.C6LLI.Reg, volatile.LoadUint32(&o.C6LLI.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetC6LLI_LLI() uint32 {
	return (volatile.LoadUint32(&o.C6LLI.Reg) & 0xfffffffc) >> 2
}

// GPDMA.C6CONTROL: DMA Channel Control Register
func (o *GPDMA_Type) SetC6CONTROL_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetC6CONTROL_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.C6CONTROL.Reg) & 0xfff
}
func (o *GPDMA_Type) SetC6CONTROL_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetC6CONTROL_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetC6CONTROL_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetC6CONTROL_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetC6CONTROL_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetC6CONTROL_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetC6CONTROL_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetC6CONTROL_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetC6CONTROL_S(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *GPDMA_Type) GetC6CONTROL_S() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x1000000) >> 24
}
func (o *GPDMA_Type) SetC6CONTROL_D(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *GPDMA_Type) GetC6CONTROL_D() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x2000000) >> 25
}
func (o *GPDMA_Type) SetC6CONTROL_SI(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetC6CONTROL_SI() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetC6CONTROL_DI(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetC6CONTROL_DI() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetC6CONTROL_PROT1(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetC6CONTROL_PROT1() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetC6CONTROL_PROT2(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetC6CONTROL_PROT2() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetC6CONTROL_PROT3(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetC6CONTROL_PROT3() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetC6CONTROL_I(value uint32) {
	volatile.StoreUint32(&o.C6CONTROL.Reg, volatile.LoadUint32(&o.C6CONTROL.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetC6CONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.C6CONTROL.Reg) & 0x80000000) >> 31
}

// GPDMA.C6CONFIG: DMA Channel Configuration Register
func (o *GPDMA_Type) SetC6CONFIG_E(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC6CONFIG_E() uint32 {
	return volatile.LoadUint32(&o.C6CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetC6CONFIG_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetC6CONFIG_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C6CONFIG.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetC6CONFIG_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetC6CONFIG_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C6CONFIG.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetC6CONFIG_FLOWCNTRL(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetC6CONFIG_FLOWCNTRL() uint32 {
	return (volatile.LoadUint32(&o.C6CONFIG.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetC6CONFIG_IE(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetC6CONFIG_IE() uint32 {
	return (volatile.LoadUint32(&o.C6CONFIG.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetC6CONFIG_ITC(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetC6CONFIG_ITC() uint32 {
	return (volatile.LoadUint32(&o.C6CONFIG.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetC6CONFIG_L(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetC6CONFIG_L() uint32 {
	return (volatile.LoadUint32(&o.C6CONFIG.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetC6CONFIG_A(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetC6CONFIG_A() uint32 {
	return (volatile.LoadUint32(&o.C6CONFIG.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetC6CONFIG_H(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetC6CONFIG_H() uint32 {
	return (volatile.LoadUint32(&o.C6CONFIG.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetC6CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.C6CONFIG.Reg, volatile.LoadUint32(&o.C6CONFIG.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetC6CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.C6CONFIG.Reg) & 0xfff80000) >> 19
}

// GPDMA.C7SRCADDR: DMA Channel Source Address Register
func (o *GPDMA_Type) SetC7SRCADDR(value uint32) {
	volatile.StoreUint32(&o.C7SRCADDR.Reg, value)
}
func (o *GPDMA_Type) GetC7SRCADDR() uint32 {
	return volatile.LoadUint32(&o.C7SRCADDR.Reg)
}

// GPDMA.C7DESTADDR: DMA Channel Destination Address Register
func (o *GPDMA_Type) SetC7DESTADDR(value uint32) {
	volatile.StoreUint32(&o.C7DESTADDR.Reg, value)
}
func (o *GPDMA_Type) GetC7DESTADDR() uint32 {
	return volatile.LoadUint32(&o.C7DESTADDR.Reg)
}

// GPDMA.C7LLI: DMA Channel Linked List Item Register
func (o *GPDMA_Type) SetC7LLI_LM(value uint32) {
	volatile.StoreUint32(&o.C7LLI.Reg, volatile.LoadUint32(&o.C7LLI.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC7LLI_LM() uint32 {
	return volatile.LoadUint32(&o.C7LLI.Reg) & 0x1
}
func (o *GPDMA_Type) SetC7LLI_R(value uint32) {
	volatile.StoreUint32(&o.C7LLI.Reg, volatile.LoadUint32(&o.C7LLI.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetC7LLI_R() uint32 {
	return (volatile.LoadUint32(&o.C7LLI.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetC7LLI_LLI(value uint32) {
	volatile.StoreUint32(&o.C7LLI.Reg, volatile.LoadUint32(&o.C7LLI.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetC7LLI_LLI() uint32 {
	return (volatile.LoadUint32(&o.C7LLI.Reg) & 0xfffffffc) >> 2
}

// GPDMA.C7CONTROL: DMA Channel Control Register
func (o *GPDMA_Type) SetC7CONTROL_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetC7CONTROL_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.C7CONTROL.Reg) & 0xfff
}
func (o *GPDMA_Type) SetC7CONTROL_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetC7CONTROL_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetC7CONTROL_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetC7CONTROL_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetC7CONTROL_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetC7CONTROL_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetC7CONTROL_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetC7CONTROL_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetC7CONTROL_S(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x1000000)|value<<24)
}
func (o *GPDMA_Type) GetC7CONTROL_S() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x1000000) >> 24
}
func (o *GPDMA_Type) SetC7CONTROL_D(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x2000000)|value<<25)
}
func (o *GPDMA_Type) GetC7CONTROL_D() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x2000000) >> 25
}
func (o *GPDMA_Type) SetC7CONTROL_SI(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetC7CONTROL_SI() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetC7CONTROL_DI(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetC7CONTROL_DI() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetC7CONTROL_PROT1(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetC7CONTROL_PROT1() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetC7CONTROL_PROT2(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetC7CONTROL_PROT2() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetC7CONTROL_PROT3(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetC7CONTROL_PROT3() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetC7CONTROL_I(value uint32) {
	volatile.StoreUint32(&o.C7CONTROL.Reg, volatile.LoadUint32(&o.C7CONTROL.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetC7CONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.C7CONTROL.Reg) & 0x80000000) >> 31
}

// GPDMA.C7CONFIG: DMA Channel Configuration Register
func (o *GPDMA_Type) SetC7CONFIG_E(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetC7CONFIG_E() uint32 {
	return volatile.LoadUint32(&o.C7CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetC7CONFIG_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetC7CONFIG_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C7CONFIG.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetC7CONFIG_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetC7CONFIG_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.C7CONFIG.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetC7CONFIG_FLOWCNTRL(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetC7CONFIG_FLOWCNTRL() uint32 {
	return (volatile.LoadUint32(&o.C7CONFIG.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetC7CONFIG_IE(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetC7CONFIG_IE() uint32 {
	return (volatile.LoadUint32(&o.C7CONFIG.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetC7CONFIG_ITC(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetC7CONFIG_ITC() uint32 {
	return (volatile.LoadUint32(&o.C7CONFIG.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetC7CONFIG_L(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetC7CONFIG_L() uint32 {
	return (volatile.LoadUint32(&o.C7CONFIG.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetC7CONFIG_A(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetC7CONFIG_A() uint32 {
	return (volatile.LoadUint32(&o.C7CONFIG.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetC7CONFIG_H(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetC7CONFIG_H() uint32 {
	return (volatile.LoadUint32(&o.C7CONFIG.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetC7CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.C7CONFIG.Reg, volatile.LoadUint32(&o.C7CONFIG.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetC7CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.C7CONFIG.Reg) & 0xfff80000) >> 19
}

// SPI Flash Interface (SPIFI)
type SPIFI_Type struct {
	CTRL   volatile.Register32 // 0x0
	CMD    volatile.Register32 // 0x4
	ADDR   volatile.Register32 // 0x8
	IDATA  volatile.Register32 // 0xC
	CLIMIT volatile.Register32 // 0x10
	DATA   volatile.Register32 // 0x14
	MCMD   volatile.Register32 // 0x18
	STAT   volatile.Register32 // 0x1C
}

// SPIFI.CTRL: SPIFI control register
func (o *SPIFI_Type) SetCTRL_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xffff)|value)
}
func (o *SPIFI_Type) GetCTRL_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0xffff
}
func (o *SPIFI_Type) SetCTRL_CSHIGH(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf0000)|value<<16)
}
func (o *SPIFI_Type) GetCTRL_CSHIGH() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf0000) >> 16
}
func (o *SPIFI_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SPIFI_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *SPIFI_Type) SetCTRL_D_PRFTCH_DIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *SPIFI_Type) GetCTRL_D_PRFTCH_DIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *SPIFI_Type) SetCTRL_INTEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *SPIFI_Type) GetCTRL_INTEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400000) >> 22
}
func (o *SPIFI_Type) SetCTRL_MODE3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SPIFI_Type) GetCTRL_MODE3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800000) >> 23
}
func (o *SPIFI_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x7000000)|value<<24)
}
func (o *SPIFI_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x7000000) >> 24
}
func (o *SPIFI_Type) SetCTRL_PRFTCH_DIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *SPIFI_Type) GetCTRL_PRFTCH_DIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000000) >> 27
}
func (o *SPIFI_Type) SetCTRL_DUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SPIFI_Type) GetCTRL_DUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000000) >> 28
}
func (o *SPIFI_Type) SetCTRL_RFCLK(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SPIFI_Type) GetCTRL_RFCLK() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *SPIFI_Type) SetCTRL_FBCLK(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SPIFI_Type) GetCTRL_FBCLK() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *SPIFI_Type) SetCTRL_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIFI_Type) GetCTRL_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// SPIFI.CMD: SPIFI command register
func (o *SPIFI_Type) SetCMD_DATALEN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x3fff)|value)
}
func (o *SPIFI_Type) GetCMD_DATALEN() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x3fff
}
func (o *SPIFI_Type) SetCMD_POLL(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x4000)|value<<14)
}
func (o *SPIFI_Type) GetCMD_POLL() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x4000) >> 14
}
func (o *SPIFI_Type) SetCMD_DOUT(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x8000)|value<<15)
}
func (o *SPIFI_Type) GetCMD_DOUT() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x8000) >> 15
}
func (o *SPIFI_Type) SetCMD_INTLEN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x70000)|value<<16)
}
func (o *SPIFI_Type) GetCMD_INTLEN() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x70000) >> 16
}
func (o *SPIFI_Type) SetCMD_FIELDFORM(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x180000)|value<<19)
}
func (o *SPIFI_Type) GetCMD_FIELDFORM() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x180000) >> 19
}
func (o *SPIFI_Type) SetCMD_FRAMEFORM(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0xe00000)|value<<21)
}
func (o *SPIFI_Type) GetCMD_FRAMEFORM() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0xe00000) >> 21
}
func (o *SPIFI_Type) SetCMD_OPCODE(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0xff000000)|value<<24)
}
func (o *SPIFI_Type) GetCMD_OPCODE() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0xff000000) >> 24
}

// SPIFI.ADDR: SPIFI address register
func (o *SPIFI_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, value)
}
func (o *SPIFI_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg)
}

// SPIFI.IDATA: SPIFI intermediate data register
func (o *SPIFI_Type) SetIDATA(value uint32) {
	volatile.StoreUint32(&o.IDATA.Reg, value)
}
func (o *SPIFI_Type) GetIDATA() uint32 {
	return volatile.LoadUint32(&o.IDATA.Reg)
}

// SPIFI.CLIMIT: SPIFI cache limit register
func (o *SPIFI_Type) SetCLIMIT(value uint32) {
	volatile.StoreUint32(&o.CLIMIT.Reg, value)
}
func (o *SPIFI_Type) GetCLIMIT() uint32 {
	return volatile.LoadUint32(&o.CLIMIT.Reg)
}

// SPIFI.DATA: SPIFI data register
func (o *SPIFI_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *SPIFI_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// SPIFI.MCMD: SPIFI memory command register
func (o *SPIFI_Type) SetMCMD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x3fff)|value)
}
func (o *SPIFI_Type) GetMCMD_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MCMD.Reg) & 0x3fff
}
func (o *SPIFI_Type) SetMCMD_POLL(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x4000)|value<<14)
}
func (o *SPIFI_Type) GetMCMD_POLL() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0x4000) >> 14
}
func (o *SPIFI_Type) SetMCMD_DOUT(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x8000)|value<<15)
}
func (o *SPIFI_Type) GetMCMD_DOUT() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0x8000) >> 15
}
func (o *SPIFI_Type) SetMCMD_INTLEN(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x70000)|value<<16)
}
func (o *SPIFI_Type) GetMCMD_INTLEN() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0x70000) >> 16
}
func (o *SPIFI_Type) SetMCMD_FIELDFORM(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x180000)|value<<19)
}
func (o *SPIFI_Type) GetMCMD_FIELDFORM() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0x180000) >> 19
}
func (o *SPIFI_Type) SetMCMD_FRAMEFORM(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0xe00000)|value<<21)
}
func (o *SPIFI_Type) GetMCMD_FRAMEFORM() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0xe00000) >> 21
}
func (o *SPIFI_Type) SetMCMD_OPCODE(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0xff000000)|value<<24)
}
func (o *SPIFI_Type) GetMCMD_OPCODE() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0xff000000) >> 24
}

// SPIFI.STAT: SPIFI status register
func (o *SPIFI_Type) SetSTAT_MCINIT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *SPIFI_Type) GetSTAT_MCINIT() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}
func (o *SPIFI_Type) SetSTAT_CMD(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2)|value<<1)
}
func (o *SPIFI_Type) GetSTAT_CMD() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2) >> 1
}
func (o *SPIFI_Type) SetSTAT_RESET(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10)|value<<4)
}
func (o *SPIFI_Type) GetSTAT_RESET() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10) >> 4
}
func (o *SPIFI_Type) SetSTAT_INTRQ(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20)|value<<5)
}
func (o *SPIFI_Type) GetSTAT_INTRQ() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20) >> 5
}
func (o *SPIFI_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xffffc0)|value<<6)
}
func (o *SPIFI_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xffffc0) >> 6
}
func (o *SPIFI_Type) SetSTAT_VERSION(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xff000000)|value<<24)
}
func (o *SPIFI_Type) GetSTAT_VERSION() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xff000000) >> 24
}

// SD/MMC
type SDMMC_Type struct {
	CTRL    volatile.Register32 // 0x0
	PWREN   volatile.Register32 // 0x4
	CLKDIV  volatile.Register32 // 0x8
	CLKSRC  volatile.Register32 // 0xC
	CLKENA  volatile.Register32 // 0x10
	TMOUT   volatile.Register32 // 0x14
	CTYPE   volatile.Register32 // 0x18
	BLKSIZ  volatile.Register32 // 0x1C
	BYTCNT  volatile.Register32 // 0x20
	INTMASK volatile.Register32 // 0x24
	CMDARG  volatile.Register32 // 0x28
	CMD     volatile.Register32 // 0x2C
	RESP0   volatile.Register32 // 0x30
	RESP1   volatile.Register32 // 0x34
	RESP2   volatile.Register32 // 0x38
	RESP3   volatile.Register32 // 0x3C
	MINTSTS volatile.Register32 // 0x40
	RINTSTS volatile.Register32 // 0x44
	STATUS  volatile.Register32 // 0x48
	FIFOTH  volatile.Register32 // 0x4C
	CDETECT volatile.Register32 // 0x50
	WRTPRT  volatile.Register32 // 0x54
	_       [4]byte
	TCBCNT  volatile.Register32 // 0x5C
	TBBCNT  volatile.Register32 // 0x60
	DEBNCE  volatile.Register32 // 0x64
	_       [16]byte
	RST_N   volatile.Register32 // 0x78
	_       [4]byte
	BMOD    volatile.Register32 // 0x80
	PLDMND  volatile.Register32 // 0x84
	DBADDR  volatile.Register32 // 0x88
	IDSTS   volatile.Register32 // 0x8C
	IDINTEN volatile.Register32 // 0x90
	DSCADDR volatile.Register32 // 0x94
	BUFADDR volatile.Register32 // 0x98
}

// SDMMC.CTRL: Control Register
func (o *SDMMC_Type) SetCTRL_CONTROLLER_RESET(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetCTRL_CONTROLLER_RESET() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *SDMMC_Type) SetCTRL_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetCTRL_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetCTRL_DMA_RESET(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetCTRL_DMA_RESET() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetCTRL_INT_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetCTRL_INT_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetCTRL_READ_WAIT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetCTRL_READ_WAIT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetCTRL_SEND_IRQ_RESPONSE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetCTRL_SEND_IRQ_RESPONSE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetCTRL_ABORT_READ_DATA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetCTRL_ABORT_READ_DATA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetCTRL_SEND_CCSD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetCTRL_SEND_CCSD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetCTRL_SEND_AUTO_STOP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetCTRL_SEND_AUTO_STOP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetCTRL_CEATA_DEVICE_INTERRUPT_STATUS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetCTRL_CEATA_DEVICE_INTERRUPT_STATUS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf000)|value<<12)
}
func (o *SDMMC_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf000) >> 12
}
func (o *SDMMC_Type) SetCTRL_CARD_VOLTAGE_A0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetCTRL_CARD_VOLTAGE_A0() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetCTRL_CARD_VOLTAGE_A1(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *SDMMC_Type) GetCTRL_CARD_VOLTAGE_A1() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000) >> 17
}
func (o *SDMMC_Type) SetCTRL_CARD_VOLTAGE_A2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SDMMC_Type) GetCTRL_CARD_VOLTAGE_A2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *SDMMC_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf80000)|value<<19)
}
func (o *SDMMC_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf80000) >> 19
}
func (o *SDMMC_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *SDMMC_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *SDMMC_Type) SetCTRL_USE_INTERNAL_DMAC(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *SDMMC_Type) GetCTRL_USE_INTERNAL_DMAC() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *SDMMC_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfc000000)|value<<26)
}
func (o *SDMMC_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xfc000000) >> 26
}

// SDMMC.PWREN: Power Enable Register
func (o *SDMMC_Type) SetPWREN_POWER_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PWREN.Reg, volatile.LoadUint32(&o.PWREN.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetPWREN_POWER_ENABLE() uint32 {
	return volatile.LoadUint32(&o.PWREN.Reg) & 0x1
}
func (o *SDMMC_Type) SetPWREN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PWREN.Reg, volatile.LoadUint32(&o.PWREN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SDMMC_Type) GetPWREN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PWREN.Reg) & 0xfffffffe) >> 1
}

// SDMMC.CLKDIV: Clock Divider Register
func (o *SDMMC_Type) SetCLKDIV_CLK_DIVIDER0(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xff)|value)
}
func (o *SDMMC_Type) GetCLKDIV_CLK_DIVIDER0() uint32 {
	return volatile.LoadUint32(&o.CLKDIV.Reg) & 0xff
}
func (o *SDMMC_Type) SetCLKDIV_CLK_DIVIDER1(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xff00)|value<<8)
}
func (o *SDMMC_Type) GetCLKDIV_CLK_DIVIDER1() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV.Reg) & 0xff00) >> 8
}
func (o *SDMMC_Type) SetCLKDIV_CLK_DIVIDER2(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xff0000)|value<<16)
}
func (o *SDMMC_Type) GetCLKDIV_CLK_DIVIDER2() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV.Reg) & 0xff0000) >> 16
}
func (o *SDMMC_Type) SetCLKDIV_CLK_DIVIDER3(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xff000000)|value<<24)
}
func (o *SDMMC_Type) GetCLKDIV_CLK_DIVIDER3() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV.Reg) & 0xff000000) >> 24
}

// SDMMC.CLKSRC: SD Clock Source Register
func (o *SDMMC_Type) SetCLKSRC_CLK_SOURCE(value uint32) {
	volatile.StoreUint32(&o.CLKSRC.Reg, volatile.LoadUint32(&o.CLKSRC.Reg)&^(0x3)|value)
}
func (o *SDMMC_Type) GetCLKSRC_CLK_SOURCE() uint32 {
	return volatile.LoadUint32(&o.CLKSRC.Reg) & 0x3
}
func (o *SDMMC_Type) SetCLKSRC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKSRC.Reg, volatile.LoadUint32(&o.CLKSRC.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SDMMC_Type) GetCLKSRC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKSRC.Reg) & 0xfffffffe) >> 1
}

// SDMMC.CLKENA: Clock Enable Register
func (o *SDMMC_Type) SetCLKENA_CCLK_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLKENA.Reg, volatile.LoadUint32(&o.CLKENA.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetCLKENA_CCLK_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CLKENA.Reg) & 0x1
}
func (o *SDMMC_Type) SetCLKENA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKENA.Reg, volatile.LoadUint32(&o.CLKENA.Reg)&^(0xfffe)|value<<1)
}
func (o *SDMMC_Type) GetCLKENA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKENA.Reg) & 0xfffe) >> 1
}
func (o *SDMMC_Type) SetCLKENA_CCLK_LOW_POWER(value uint32) {
	volatile.StoreUint32(&o.CLKENA.Reg, volatile.LoadUint32(&o.CLKENA.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetCLKENA_CCLK_LOW_POWER() uint32 {
	return (volatile.LoadUint32(&o.CLKENA.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetCLKENA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKENA.Reg, volatile.LoadUint32(&o.CLKENA.Reg)&^(0xfffe0000)|value<<17)
}
func (o *SDMMC_Type) GetCLKENA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKENA.Reg) & 0xfffe0000) >> 17
}

// SDMMC.TMOUT: Time-out Register
func (o *SDMMC_Type) SetTMOUT_RESPONSE_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.TMOUT.Reg, volatile.LoadUint32(&o.TMOUT.Reg)&^(0xff)|value)
}
func (o *SDMMC_Type) GetTMOUT_RESPONSE_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.TMOUT.Reg) & 0xff
}
func (o *SDMMC_Type) SetTMOUT_DATA_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.TMOUT.Reg, volatile.LoadUint32(&o.TMOUT.Reg)&^(0xffffff00)|value<<8)
}
func (o *SDMMC_Type) GetTMOUT_DATA_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.TMOUT.Reg) & 0xffffff00) >> 8
}

// SDMMC.CTYPE: Card Type Register
func (o *SDMMC_Type) SetCTYPE_CARD_WIDTH0(value uint32) {
	volatile.StoreUint32(&o.CTYPE.Reg, volatile.LoadUint32(&o.CTYPE.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetCTYPE_CARD_WIDTH0() uint32 {
	return volatile.LoadUint32(&o.CTYPE.Reg) & 0x1
}
func (o *SDMMC_Type) SetCTYPE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTYPE.Reg, volatile.LoadUint32(&o.CTYPE.Reg)&^(0xfffe)|value<<1)
}
func (o *SDMMC_Type) GetCTYPE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTYPE.Reg) & 0xfffe) >> 1
}
func (o *SDMMC_Type) SetCTYPE_CARD_WIDTH1(value uint32) {
	volatile.StoreUint32(&o.CTYPE.Reg, volatile.LoadUint32(&o.CTYPE.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetCTYPE_CARD_WIDTH1() uint32 {
	return (volatile.LoadUint32(&o.CTYPE.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetCTYPE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTYPE.Reg, volatile.LoadUint32(&o.CTYPE.Reg)&^(0xfffe0000)|value<<17)
}
func (o *SDMMC_Type) GetCTYPE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTYPE.Reg) & 0xfffe0000) >> 17
}

// SDMMC.BLKSIZ: Block Size Register
func (o *SDMMC_Type) SetBLKSIZ_BLOCK_SIZE(value uint32) {
	volatile.StoreUint32(&o.BLKSIZ.Reg, volatile.LoadUint32(&o.BLKSIZ.Reg)&^(0xffff)|value)
}
func (o *SDMMC_Type) GetBLKSIZ_BLOCK_SIZE() uint32 {
	return volatile.LoadUint32(&o.BLKSIZ.Reg) & 0xffff
}
func (o *SDMMC_Type) SetBLKSIZ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BLKSIZ.Reg, volatile.LoadUint32(&o.BLKSIZ.Reg)&^(0xffff0000)|value<<16)
}
func (o *SDMMC_Type) GetBLKSIZ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BLKSIZ.Reg) & 0xffff0000) >> 16
}

// SDMMC.BYTCNT: Byte Count Register
func (o *SDMMC_Type) SetBYTCNT(value uint32) {
	volatile.StoreUint32(&o.BYTCNT.Reg, value)
}
func (o *SDMMC_Type) GetBYTCNT() uint32 {
	return volatile.LoadUint32(&o.BYTCNT.Reg)
}

// SDMMC.INTMASK: Interrupt Mask Register
func (o *SDMMC_Type) SetINTMASK_CDET(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetINTMASK_CDET() uint32 {
	return volatile.LoadUint32(&o.INTMASK.Reg) & 0x1
}
func (o *SDMMC_Type) SetINTMASK_RE(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetINTMASK_RE() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetINTMASK_CDONE(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetINTMASK_CDONE() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetINTMASK_DTO(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetINTMASK_DTO() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetINTMASK_TXDR(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetINTMASK_TXDR() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetINTMASK_RXDR(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetINTMASK_RXDR() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetINTMASK_RCRC(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetINTMASK_RCRC() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetINTMASK_DCRC(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetINTMASK_DCRC() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetINTMASK_RTO(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetINTMASK_RTO() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetINTMASK_DRTO(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetINTMASK_DRTO() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetINTMASK_HTO(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetINTMASK_HTO() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetINTMASK_FRUN(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetINTMASK_FRUN() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetINTMASK_HLE(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetINTMASK_HLE() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetINTMASK_SBE(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetINTMASK_SBE() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetINTMASK_ACD(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetINTMASK_ACD() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetINTMASK_EBE(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetINTMASK_EBE() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetINTMASK_SDIO_INT_MASK(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetINTMASK_SDIO_INT_MASK() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetINTMASK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTMASK.Reg, volatile.LoadUint32(&o.INTMASK.Reg)&^(0xfffe0000)|value<<17)
}
func (o *SDMMC_Type) GetINTMASK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTMASK.Reg) & 0xfffe0000) >> 17
}

// SDMMC.CMDARG: Command Argument Register
func (o *SDMMC_Type) SetCMDARG(value uint32) {
	volatile.StoreUint32(&o.CMDARG.Reg, value)
}
func (o *SDMMC_Type) GetCMDARG() uint32 {
	return volatile.LoadUint32(&o.CMDARG.Reg)
}

// SDMMC.CMD: Command Register
func (o *SDMMC_Type) SetCMD_CMD_INDEX(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x3f)|value)
}
func (o *SDMMC_Type) GetCMD_CMD_INDEX() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x3f
}
func (o *SDMMC_Type) SetCMD_RESPONSE_EXPECT(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetCMD_RESPONSE_EXPECT() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetCMD_RESPONSE_LENGTH(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetCMD_RESPONSE_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetCMD_CHECK_RESPONSE_CRC(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetCMD_CHECK_RESPONSE_CRC() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetCMD_DATA_EXPECTED(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetCMD_DATA_EXPECTED() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetCMD_READ_WRITE(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetCMD_READ_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetCMD_TRANSFER_MODE(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetCMD_TRANSFER_MODE() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetCMD_SEND_AUTO_STOP(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetCMD_SEND_AUTO_STOP() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetCMD_WAIT_PRVDATA_COMPLETE(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetCMD_WAIT_PRVDATA_COMPLETE() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetCMD_STOP_ABORT_CMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetCMD_STOP_ABORT_CMD() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetCMD_SEND_INITIALIZATION(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetCMD_SEND_INITIALIZATION() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetCMD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1f0000)|value<<16)
}
func (o *SDMMC_Type) GetCMD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x1f0000) >> 16
}
func (o *SDMMC_Type) SetCMD_UPDATE_CLOCK_REGISTERS_ONLY(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x200000)|value<<21)
}
func (o *SDMMC_Type) GetCMD_UPDATE_CLOCK_REGISTERS_ONLY() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x200000) >> 21
}
func (o *SDMMC_Type) SetCMD_READ_CEATA_DEVICE(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x400000)|value<<22)
}
func (o *SDMMC_Type) GetCMD_READ_CEATA_DEVICE() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x400000) >> 22
}
func (o *SDMMC_Type) SetCMD_CCS_EXPECTED(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x800000)|value<<23)
}
func (o *SDMMC_Type) GetCMD_CCS_EXPECTED() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x800000) >> 23
}
func (o *SDMMC_Type) SetCMD_ENABLE_BOOT(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1000000)|value<<24)
}
func (o *SDMMC_Type) GetCMD_ENABLE_BOOT() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x1000000) >> 24
}
func (o *SDMMC_Type) SetCMD_EXPECT_BOOT_ACK(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x2000000)|value<<25)
}
func (o *SDMMC_Type) GetCMD_EXPECT_BOOT_ACK() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x2000000) >> 25
}
func (o *SDMMC_Type) SetCMD_DISABLE_BOOT(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x4000000)|value<<26)
}
func (o *SDMMC_Type) GetCMD_DISABLE_BOOT() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x4000000) >> 26
}
func (o *SDMMC_Type) SetCMD_BOOT_MODE(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x8000000)|value<<27)
}
func (o *SDMMC_Type) GetCMD_BOOT_MODE() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x8000000) >> 27
}
func (o *SDMMC_Type) SetCMD_VOLT_SWITCH(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x10000000)|value<<28)
}
func (o *SDMMC_Type) GetCMD_VOLT_SWITCH() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x10000000) >> 28
}
func (o *SDMMC_Type) SetCMD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x60000000)|value<<29)
}
func (o *SDMMC_Type) GetCMD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x60000000) >> 29
}
func (o *SDMMC_Type) SetCMD_START_CMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x80000000)|value<<31)
}
func (o *SDMMC_Type) GetCMD_START_CMD() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x80000000) >> 31
}

// SDMMC.RESP0: Response Register 0
func (o *SDMMC_Type) SetRESP0(value uint32) {
	volatile.StoreUint32(&o.RESP0.Reg, value)
}
func (o *SDMMC_Type) GetRESP0() uint32 {
	return volatile.LoadUint32(&o.RESP0.Reg)
}

// SDMMC.RESP1: Response Register 1
func (o *SDMMC_Type) SetRESP1(value uint32) {
	volatile.StoreUint32(&o.RESP1.Reg, value)
}
func (o *SDMMC_Type) GetRESP1() uint32 {
	return volatile.LoadUint32(&o.RESP1.Reg)
}

// SDMMC.RESP2: Response Register 2
func (o *SDMMC_Type) SetRESP2(value uint32) {
	volatile.StoreUint32(&o.RESP2.Reg, value)
}
func (o *SDMMC_Type) GetRESP2() uint32 {
	return volatile.LoadUint32(&o.RESP2.Reg)
}

// SDMMC.RESP3: Response Register 3
func (o *SDMMC_Type) SetRESP3(value uint32) {
	volatile.StoreUint32(&o.RESP3.Reg, value)
}
func (o *SDMMC_Type) GetRESP3() uint32 {
	return volatile.LoadUint32(&o.RESP3.Reg)
}

// SDMMC.MINTSTS: Masked Interrupt Status Register
func (o *SDMMC_Type) SetMINTSTS_CDET(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetMINTSTS_CDET() uint32 {
	return volatile.LoadUint32(&o.MINTSTS.Reg) & 0x1
}
func (o *SDMMC_Type) SetMINTSTS_RE(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetMINTSTS_RE() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetMINTSTS_CDONE(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetMINTSTS_CDONE() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetMINTSTS_DTO(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetMINTSTS_DTO() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetMINTSTS_TXDR(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetMINTSTS_TXDR() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetMINTSTS_RXDR(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetMINTSTS_RXDR() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetMINTSTS_RCRC(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetMINTSTS_RCRC() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetMINTSTS_DCRC(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetMINTSTS_DCRC() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetMINTSTS_RTO(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetMINTSTS_RTO() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetMINTSTS_DRTO(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetMINTSTS_DRTO() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetMINTSTS_HTO(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetMINTSTS_HTO() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetMINTSTS_FRUN(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetMINTSTS_FRUN() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetMINTSTS_HLE(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetMINTSTS_HLE() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetMINTSTS_SBE(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetMINTSTS_SBE() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetMINTSTS_ACD(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetMINTSTS_ACD() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetMINTSTS_EBE(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetMINTSTS_EBE() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetMINTSTS_SDIO_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetMINTSTS_SDIO_INTERRUPT() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetMINTSTS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MINTSTS.Reg, volatile.LoadUint32(&o.MINTSTS.Reg)&^(0xfffe0000)|value<<17)
}
func (o *SDMMC_Type) GetMINTSTS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MINTSTS.Reg) & 0xfffe0000) >> 17
}

// SDMMC.RINTSTS: Raw Interrupt Status Register
func (o *SDMMC_Type) SetRINTSTS_CDET(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetRINTSTS_CDET() uint32 {
	return volatile.LoadUint32(&o.RINTSTS.Reg) & 0x1
}
func (o *SDMMC_Type) SetRINTSTS_RE(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetRINTSTS_RE() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetRINTSTS_CDONE(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetRINTSTS_CDONE() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetRINTSTS_DTO(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetRINTSTS_DTO() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetRINTSTS_TXDR(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetRINTSTS_TXDR() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetRINTSTS_RXDR(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetRINTSTS_RXDR() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetRINTSTS_RCRC(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetRINTSTS_RCRC() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetRINTSTS_DCRC(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetRINTSTS_DCRC() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetRINTSTS_RTO_BAR(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetRINTSTS_RTO_BAR() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetRINTSTS_DRTO_BDS(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetRINTSTS_DRTO_BDS() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetRINTSTS_HTO(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetRINTSTS_HTO() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetRINTSTS_FRUN(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetRINTSTS_FRUN() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetRINTSTS_HLE(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetRINTSTS_HLE() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetRINTSTS_SBE(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetRINTSTS_SBE() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetRINTSTS_ACD(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetRINTSTS_ACD() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetRINTSTS_EBE(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetRINTSTS_EBE() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetRINTSTS_SDIO_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetRINTSTS_SDIO_INTERRUPT() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetRINTSTS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RINTSTS.Reg, volatile.LoadUint32(&o.RINTSTS.Reg)&^(0xfffe0000)|value<<17)
}
func (o *SDMMC_Type) GetRINTSTS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RINTSTS.Reg) & 0xfffe0000) >> 17
}

// SDMMC.STATUS: Status Register
func (o *SDMMC_Type) SetSTATUS_FIFO_RX_WATERMARK(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetSTATUS_FIFO_RX_WATERMARK() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *SDMMC_Type) SetSTATUS_FIFO_TX_WATERMARK(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetSTATUS_FIFO_TX_WATERMARK() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetSTATUS_FIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetSTATUS_FIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetSTATUS_FIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetSTATUS_FIFO_FULL() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetSTATUS_CMDFSMSTATES(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xf0)|value<<4)
}
func (o *SDMMC_Type) GetSTATUS_CMDFSMSTATES() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xf0) >> 4
}
func (o *SDMMC_Type) SetSTATUS_DATA_3_STATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetSTATUS_DATA_3_STATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetSTATUS_DATA_BUSY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetSTATUS_DATA_BUSY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetSTATUS_DATA_STATE_MC_BUSY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetSTATUS_DATA_STATE_MC_BUSY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetSTATUS_RESPONSE_INDEX(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1f800)|value<<11)
}
func (o *SDMMC_Type) GetSTATUS_RESPONSE_INDEX() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1f800) >> 11
}
func (o *SDMMC_Type) SetSTATUS_FIFO_COUNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x3ffe0000)|value<<17)
}
func (o *SDMMC_Type) GetSTATUS_FIFO_COUNT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x3ffe0000) >> 17
}
func (o *SDMMC_Type) SetSTATUS_DMA_ACK(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *SDMMC_Type) GetSTATUS_DMA_ACK() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40000000) >> 30
}
func (o *SDMMC_Type) SetSTATUS_DMA_REQ(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *SDMMC_Type) GetSTATUS_DMA_REQ() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000000) >> 31
}

// SDMMC.FIFOTH: FIFO Threshold Watermark Register
func (o *SDMMC_Type) SetFIFOTH_TX_WMARK(value uint32) {
	volatile.StoreUint32(&o.FIFOTH.Reg, volatile.LoadUint32(&o.FIFOTH.Reg)&^(0xfff)|value)
}
func (o *SDMMC_Type) GetFIFOTH_TX_WMARK() uint32 {
	return volatile.LoadUint32(&o.FIFOTH.Reg) & 0xfff
}
func (o *SDMMC_Type) SetFIFOTH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FIFOTH.Reg, volatile.LoadUint32(&o.FIFOTH.Reg)&^(0xf000)|value<<12)
}
func (o *SDMMC_Type) GetFIFOTH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FIFOTH.Reg) & 0xf000) >> 12
}
func (o *SDMMC_Type) SetFIFOTH_RX_WMARK(value uint32) {
	volatile.StoreUint32(&o.FIFOTH.Reg, volatile.LoadUint32(&o.FIFOTH.Reg)&^(0xfff0000)|value<<16)
}
func (o *SDMMC_Type) GetFIFOTH_RX_WMARK() uint32 {
	return (volatile.LoadUint32(&o.FIFOTH.Reg) & 0xfff0000) >> 16
}
func (o *SDMMC_Type) SetFIFOTH_DMA_MTS(value uint32) {
	volatile.StoreUint32(&o.FIFOTH.Reg, volatile.LoadUint32(&o.FIFOTH.Reg)&^(0x70000000)|value<<28)
}
func (o *SDMMC_Type) GetFIFOTH_DMA_MTS() uint32 {
	return (volatile.LoadUint32(&o.FIFOTH.Reg) & 0x70000000) >> 28
}
func (o *SDMMC_Type) SetFIFOTH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FIFOTH.Reg, volatile.LoadUint32(&o.FIFOTH.Reg)&^(0x80000000)|value<<31)
}
func (o *SDMMC_Type) GetFIFOTH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FIFOTH.Reg) & 0x80000000) >> 31
}

// SDMMC.CDETECT: Card Detect Register
func (o *SDMMC_Type) SetCDETECT_CARD_DETECT(value uint32) {
	volatile.StoreUint32(&o.CDETECT.Reg, volatile.LoadUint32(&o.CDETECT.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetCDETECT_CARD_DETECT() uint32 {
	return volatile.LoadUint32(&o.CDETECT.Reg) & 0x1
}
func (o *SDMMC_Type) SetCDETECT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CDETECT.Reg, volatile.LoadUint32(&o.CDETECT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SDMMC_Type) GetCDETECT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CDETECT.Reg) & 0xfffffffe) >> 1
}

// SDMMC.WRTPRT: Write Protect Register
func (o *SDMMC_Type) SetWRTPRT_WRITE_PROTECT(value uint32) {
	volatile.StoreUint32(&o.WRTPRT.Reg, volatile.LoadUint32(&o.WRTPRT.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetWRTPRT_WRITE_PROTECT() uint32 {
	return volatile.LoadUint32(&o.WRTPRT.Reg) & 0x1
}
func (o *SDMMC_Type) SetWRTPRT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WRTPRT.Reg, volatile.LoadUint32(&o.WRTPRT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SDMMC_Type) GetWRTPRT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WRTPRT.Reg) & 0xfffffffe) >> 1
}

// SDMMC.TCBCNT: Transferred CIU Card Byte Count Register
func (o *SDMMC_Type) SetTCBCNT(value uint32) {
	volatile.StoreUint32(&o.TCBCNT.Reg, value)
}
func (o *SDMMC_Type) GetTCBCNT() uint32 {
	return volatile.LoadUint32(&o.TCBCNT.Reg)
}

// SDMMC.TBBCNT: Transferred Host to BIU-FIFO Byte Count Register
func (o *SDMMC_Type) SetTBBCNT(value uint32) {
	volatile.StoreUint32(&o.TBBCNT.Reg, value)
}
func (o *SDMMC_Type) GetTBBCNT() uint32 {
	return volatile.LoadUint32(&o.TBBCNT.Reg)
}

// SDMMC.DEBNCE: Debounce Count Register
func (o *SDMMC_Type) SetDEBNCE_DEBOUNCE_COUNT(value uint32) {
	volatile.StoreUint32(&o.DEBNCE.Reg, volatile.LoadUint32(&o.DEBNCE.Reg)&^(0xffffff)|value)
}
func (o *SDMMC_Type) GetDEBNCE_DEBOUNCE_COUNT() uint32 {
	return volatile.LoadUint32(&o.DEBNCE.Reg) & 0xffffff
}
func (o *SDMMC_Type) SetDEBNCE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DEBNCE.Reg, volatile.LoadUint32(&o.DEBNCE.Reg)&^(0xff000000)|value<<24)
}
func (o *SDMMC_Type) GetDEBNCE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DEBNCE.Reg) & 0xff000000) >> 24
}

// SDMMC.RST_N: Hardware Reset
func (o *SDMMC_Type) SetRST_N_CARD_RESET(value uint32) {
	volatile.StoreUint32(&o.RST_N.Reg, volatile.LoadUint32(&o.RST_N.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetRST_N_CARD_RESET() uint32 {
	return volatile.LoadUint32(&o.RST_N.Reg) & 0x1
}
func (o *SDMMC_Type) SetRST_N_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RST_N.Reg, volatile.LoadUint32(&o.RST_N.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SDMMC_Type) GetRST_N_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RST_N.Reg) & 0xfffffffe) >> 1
}

// SDMMC.BMOD: Bus Mode Register
func (o *SDMMC_Type) SetBMOD_SWR(value uint32) {
	volatile.StoreUint32(&o.BMOD.Reg, volatile.LoadUint32(&o.BMOD.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetBMOD_SWR() uint32 {
	return volatile.LoadUint32(&o.BMOD.Reg) & 0x1
}
func (o *SDMMC_Type) SetBMOD_FB(value uint32) {
	volatile.StoreUint32(&o.BMOD.Reg, volatile.LoadUint32(&o.BMOD.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetBMOD_FB() uint32 {
	return (volatile.LoadUint32(&o.BMOD.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetBMOD_DSL(value uint32) {
	volatile.StoreUint32(&o.BMOD.Reg, volatile.LoadUint32(&o.BMOD.Reg)&^(0x7c)|value<<2)
}
func (o *SDMMC_Type) GetBMOD_DSL() uint32 {
	return (volatile.LoadUint32(&o.BMOD.Reg) & 0x7c) >> 2
}
func (o *SDMMC_Type) SetBMOD_DE(value uint32) {
	volatile.StoreUint32(&o.BMOD.Reg, volatile.LoadUint32(&o.BMOD.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetBMOD_DE() uint32 {
	return (volatile.LoadUint32(&o.BMOD.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetBMOD_PBL(value uint32) {
	volatile.StoreUint32(&o.BMOD.Reg, volatile.LoadUint32(&o.BMOD.Reg)&^(0x700)|value<<8)
}
func (o *SDMMC_Type) GetBMOD_PBL() uint32 {
	return (volatile.LoadUint32(&o.BMOD.Reg) & 0x700) >> 8
}
func (o *SDMMC_Type) SetBMOD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BMOD.Reg, volatile.LoadUint32(&o.BMOD.Reg)&^(0xfffff800)|value<<11)
}
func (o *SDMMC_Type) GetBMOD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BMOD.Reg) & 0xfffff800) >> 11
}

// SDMMC.PLDMND: Poll Demand Register
func (o *SDMMC_Type) SetPLDMND(value uint32) {
	volatile.StoreUint32(&o.PLDMND.Reg, value)
}
func (o *SDMMC_Type) GetPLDMND() uint32 {
	return volatile.LoadUint32(&o.PLDMND.Reg)
}

// SDMMC.DBADDR: Descriptor List Base Address Register
func (o *SDMMC_Type) SetDBADDR(value uint32) {
	volatile.StoreUint32(&o.DBADDR.Reg, value)
}
func (o *SDMMC_Type) GetDBADDR() uint32 {
	return volatile.LoadUint32(&o.DBADDR.Reg)
}

// SDMMC.IDSTS: Internal DMAC Status Register
func (o *SDMMC_Type) SetIDSTS_TI(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetIDSTS_TI() uint32 {
	return volatile.LoadUint32(&o.IDSTS.Reg) & 0x1
}
func (o *SDMMC_Type) SetIDSTS_RI(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetIDSTS_RI() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetIDSTS_FBE(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetIDSTS_FBE() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetIDSTS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetIDSTS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetIDSTS_DU(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetIDSTS_DU() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetIDSTS_CES(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetIDSTS_CES() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetIDSTS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0xc0)|value<<6)
}
func (o *SDMMC_Type) GetIDSTS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0xc0) >> 6
}
func (o *SDMMC_Type) SetIDSTS_NIS(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetIDSTS_NIS() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetIDSTS_AIS(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetIDSTS_AIS() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetIDSTS_EB(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x1c00)|value<<10)
}
func (o *SDMMC_Type) GetIDSTS_EB() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0x1c00) >> 10
}
func (o *SDMMC_Type) SetIDSTS_FSM(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0x1e000)|value<<13)
}
func (o *SDMMC_Type) GetIDSTS_FSM() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0x1e000) >> 13
}
func (o *SDMMC_Type) SetIDSTS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDSTS.Reg, volatile.LoadUint32(&o.IDSTS.Reg)&^(0xfffe0000)|value<<17)
}
func (o *SDMMC_Type) GetIDSTS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDSTS.Reg) & 0xfffe0000) >> 17
}

// SDMMC.IDINTEN: Internal DMAC Interrupt Enable Register
func (o *SDMMC_Type) SetIDINTEN_TI(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetIDINTEN_TI() uint32 {
	return volatile.LoadUint32(&o.IDINTEN.Reg) & 0x1
}
func (o *SDMMC_Type) SetIDINTEN_RI(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetIDINTEN_RI() uint32 {
	return (volatile.LoadUint32(&o.IDINTEN.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetIDINTEN_FBE(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetIDINTEN_FBE() uint32 {
	return (volatile.LoadUint32(&o.IDINTEN.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetIDINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetIDINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDINTEN.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetIDINTEN_DU(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetIDINTEN_DU() uint32 {
	return (volatile.LoadUint32(&o.IDINTEN.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetIDINTEN_CES(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetIDINTEN_CES() uint32 {
	return (volatile.LoadUint32(&o.IDINTEN.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetIDINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0xc0)|value<<6)
}
func (o *SDMMC_Type) GetIDINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDINTEN.Reg) & 0xc0) >> 6
}
func (o *SDMMC_Type) SetIDINTEN_NIS(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetIDINTEN_NIS() uint32 {
	return (volatile.LoadUint32(&o.IDINTEN.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetIDINTEN_AIS(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetIDINTEN_AIS() uint32 {
	return (volatile.LoadUint32(&o.IDINTEN.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetIDINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDINTEN.Reg, volatile.LoadUint32(&o.IDINTEN.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SDMMC_Type) GetIDINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDINTEN.Reg) & 0xfffffc00) >> 10
}

// SDMMC.DSCADDR: Current Host Descriptor Address Register
func (o *SDMMC_Type) SetDSCADDR(value uint32) {
	volatile.StoreUint32(&o.DSCADDR.Reg, value)
}
func (o *SDMMC_Type) GetDSCADDR() uint32 {
	return volatile.LoadUint32(&o.DSCADDR.Reg)
}

// SDMMC.BUFADDR: Current Buffer Descriptor Address Register
func (o *SDMMC_Type) SetBUFADDR(value uint32) {
	volatile.StoreUint32(&o.BUFADDR.Reg, value)
}
func (o *SDMMC_Type) GetBUFADDR() uint32 {
	return volatile.LoadUint32(&o.BUFADDR.Reg)
}

// External Memory Controller (EMC)
type EMC_Type struct {
	CONTROL            volatile.Register32 // 0x0
	STATUS             volatile.Register32 // 0x4
	CONFIG             volatile.Register32 // 0x8
	_                  [20]byte
	DYNAMICCONTROL     volatile.Register32 // 0x20
	DYNAMICREFRESH     volatile.Register32 // 0x24
	DYNAMICREADCONFIG  volatile.Register32 // 0x28
	_                  [4]byte
	DYNAMICRP          volatile.Register32 // 0x30
	DYNAMICRAS         volatile.Register32 // 0x34
	DYNAMICSREX        volatile.Register32 // 0x38
	DYNAMICAPR         volatile.Register32 // 0x3C
	DYNAMICDAL         volatile.Register32 // 0x40
	DYNAMICWR          volatile.Register32 // 0x44
	DYNAMICRC          volatile.Register32 // 0x48
	DYNAMICRFC         volatile.Register32 // 0x4C
	DYNAMICXSR         volatile.Register32 // 0x50
	DYNAMICRRD         volatile.Register32 // 0x54
	DYNAMICMRD         volatile.Register32 // 0x58
	_                  [36]byte
	STATICEXTENDEDWAIT volatile.Register32 // 0x80
	_                  [124]byte
	DYNAMICCONFIG0     volatile.Register32 // 0x100
	DYNAMICRASCAS0     volatile.Register32 // 0x104
	_                  [24]byte
	DYNAMICCONFIG1     volatile.Register32 // 0x120
	DYNAMICRASCAS1     volatile.Register32 // 0x124
	_                  [24]byte
	DYNAMICCONFIG2     volatile.Register32 // 0x140
	DYNAMICRASCAS2     volatile.Register32 // 0x144
	_                  [24]byte
	DYNAMICCONFIG3     volatile.Register32 // 0x160
	DYNAMICRASCAS3     volatile.Register32 // 0x164
	_                  [152]byte
	STATICCONFIG0      volatile.Register32 // 0x200
	STATICWAITWEN0     volatile.Register32 // 0x204
	STATICWAITOEN0     volatile.Register32 // 0x208
	STATICWAITRD0      volatile.Register32 // 0x20C
	STATICWAITPAGE0    volatile.Register32 // 0x210
	STATICWAITWR0      volatile.Register32 // 0x214
	STATICWAITTURN0    volatile.Register32 // 0x218
	_                  [4]byte
	STATICCONFIG1      volatile.Register32 // 0x220
	STATICWAITWEN1     volatile.Register32 // 0x224
	STATICWAITOEN1     volatile.Register32 // 0x228
	STATICWAITRD1      volatile.Register32 // 0x22C
	STATICWAITPAGE1    volatile.Register32 // 0x230
	STATICWAITWR1      volatile.Register32 // 0x234
	STATICWAITTURN1    volatile.Register32 // 0x238
	_                  [4]byte
	STATICCONFIG2      volatile.Register32 // 0x240
	STATICWAITWEN2     volatile.Register32 // 0x244
	STATICWAITOEN2     volatile.Register32 // 0x248
	STATICWAITRD2      volatile.Register32 // 0x24C
	STATICWAITPAGE2    volatile.Register32 // 0x250
	STATICWAITWR2      volatile.Register32 // 0x254
	STATICWAITTURN2    volatile.Register32 // 0x258
	_                  [4]byte
	STATICCONFIG3      volatile.Register32 // 0x260
	STATICWAITWEN3     volatile.Register32 // 0x264
	STATICWAITOEN3     volatile.Register32 // 0x268
	STATICWAITRD3      volatile.Register32 // 0x26C
	STATICWAITPAGE3    volatile.Register32 // 0x270
	STATICWAITWR3      volatile.Register32 // 0x274
	STATICWAITTURN3    volatile.Register32 // 0x278
}

// EMC.CONTROL: Controls operation of the memory controller.
func (o *EMC_Type) SetCONTROL_E(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x1)|value)
}
func (o *EMC_Type) GetCONTROL_E() uint32 {
	return volatile.LoadUint32(&o.CONTROL.Reg) & 0x1
}
func (o *EMC_Type) SetCONTROL_M(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x2)|value<<1)
}
func (o *EMC_Type) GetCONTROL_M() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x2) >> 1
}
func (o *EMC_Type) SetCONTROL_L(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetCONTROL_L() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EMC_Type) GetCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0xfffffff8) >> 3
}

// EMC.STATUS: Provides EMC status information.
func (o *EMC_Type) SetSTATUS_B(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *EMC_Type) GetSTATUS_B() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *EMC_Type) SetSTATUS_S(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *EMC_Type) GetSTATUS_S() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *EMC_Type) SetSTATUS_SA(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATUS_SA() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EMC_Type) GetSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xfffffff8) >> 3
}

// EMC.CONFIG: Configures operation of the memory controller.
func (o *EMC_Type) SetCONFIG_EM(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *EMC_Type) GetCONFIG_EM() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *EMC_Type) SetCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xfe)|value<<1)
}
func (o *EMC_Type) GetCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xfe) >> 1
}
func (o *EMC_Type) SetCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xfffffe00)|value<<9)
}
func (o *EMC_Type) GetCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xfffffe00) >> 9
}

// EMC.DYNAMICCONTROL: Controls dynamic memory operation.
func (o *EMC_Type) SetDYNAMICCONTROL_CE(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x1)|value)
}
func (o *EMC_Type) GetDYNAMICCONTROL_CE() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x1
}
func (o *EMC_Type) SetDYNAMICCONTROL_CS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x2)|value<<1)
}
func (o *EMC_Type) GetDYNAMICCONTROL_CS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x2) >> 1
}
func (o *EMC_Type) SetDYNAMICCONTROL_SR(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetDYNAMICCONTROL_SR() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetDYNAMICCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONTROL_MMC(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x20)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONTROL_MMC() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x20) >> 5
}
func (o *EMC_Type) SetDYNAMICCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetDYNAMICCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetDYNAMICCONTROL_I(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x180)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x180) >> 7
}
func (o *EMC_Type) SetDYNAMICCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x3e00)|value<<9)
}
func (o *EMC_Type) GetDYNAMICCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x3e00) >> 9
}
func (o *EMC_Type) SetDYNAMICCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0xffffc000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0xffffc000) >> 14
}

// EMC.DYNAMICREFRESH: Configures dynamic memory refresh operation.
func (o *EMC_Type) SetDYNAMICREFRESH_REFRESH(value uint32) {
	volatile.StoreUint32(&o.DYNAMICREFRESH.Reg, volatile.LoadUint32(&o.DYNAMICREFRESH.Reg)&^(0x7ff)|value)
}
func (o *EMC_Type) GetDYNAMICREFRESH_REFRESH() uint32 {
	return volatile.LoadUint32(&o.DYNAMICREFRESH.Reg) & 0x7ff
}
func (o *EMC_Type) SetDYNAMICREFRESH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICREFRESH.Reg, volatile.LoadUint32(&o.DYNAMICREFRESH.Reg)&^(0xfffff800)|value<<11)
}
func (o *EMC_Type) GetDYNAMICREFRESH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICREFRESH.Reg) & 0xfffff800) >> 11
}

// EMC.DYNAMICREADCONFIG: Configures the dynamic memory read strategy.
func (o *EMC_Type) SetDYNAMICREADCONFIG_RD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICREADCONFIG.Reg, volatile.LoadUint32(&o.DYNAMICREADCONFIG.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICREADCONFIG_RD() uint32 {
	return volatile.LoadUint32(&o.DYNAMICREADCONFIG.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICREADCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICREADCONFIG.Reg, volatile.LoadUint32(&o.DYNAMICREADCONFIG.Reg)&^(0xfffffffc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICREADCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICREADCONFIG.Reg) & 0xfffffffc) >> 2
}

// EMC.DYNAMICRP: Selects the precharge command period.
func (o *EMC_Type) SetDYNAMICRP_TRP(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRP.Reg, volatile.LoadUint32(&o.DYNAMICRP.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICRP_TRP() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRP.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICRP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRP.Reg, volatile.LoadUint32(&o.DYNAMICRP.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICRP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRP.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICRAS: Selects the active to precharge command period.
func (o *EMC_Type) SetDYNAMICRAS_TRAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRAS.Reg, volatile.LoadUint32(&o.DYNAMICRAS.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICRAS_TRAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRAS.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICRAS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRAS.Reg, volatile.LoadUint32(&o.DYNAMICRAS.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICRAS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRAS.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICSREX: Selects the self-refresh exit time.
func (o *EMC_Type) SetDYNAMICSREX_TSREX(value uint32) {
	volatile.StoreUint32(&o.DYNAMICSREX.Reg, volatile.LoadUint32(&o.DYNAMICSREX.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICSREX_TSREX() uint32 {
	return volatile.LoadUint32(&o.DYNAMICSREX.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICSREX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICSREX.Reg, volatile.LoadUint32(&o.DYNAMICSREX.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICSREX_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICSREX.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICAPR: Selects the last-data-out to active command time.
func (o *EMC_Type) SetDYNAMICAPR_TAPR(value uint32) {
	volatile.StoreUint32(&o.DYNAMICAPR.Reg, volatile.LoadUint32(&o.DYNAMICAPR.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICAPR_TAPR() uint32 {
	return volatile.LoadUint32(&o.DYNAMICAPR.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICAPR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICAPR.Reg, volatile.LoadUint32(&o.DYNAMICAPR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICAPR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICAPR.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICDAL: Selects the data-in to active command time.
func (o *EMC_Type) SetDYNAMICDAL_TDAL(value uint32) {
	volatile.StoreUint32(&o.DYNAMICDAL.Reg, volatile.LoadUint32(&o.DYNAMICDAL.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICDAL_TDAL() uint32 {
	return volatile.LoadUint32(&o.DYNAMICDAL.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICDAL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICDAL.Reg, volatile.LoadUint32(&o.DYNAMICDAL.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICDAL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICDAL.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICWR: Selects the write recovery time.
func (o *EMC_Type) SetDYNAMICWR_TWR(value uint32) {
	volatile.StoreUint32(&o.DYNAMICWR.Reg, volatile.LoadUint32(&o.DYNAMICWR.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICWR_TWR() uint32 {
	return volatile.LoadUint32(&o.DYNAMICWR.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICWR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICWR.Reg, volatile.LoadUint32(&o.DYNAMICWR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICWR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICWR.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICRC: Selects the active to active command period.
func (o *EMC_Type) SetDYNAMICRC_TRC(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRC.Reg, volatile.LoadUint32(&o.DYNAMICRC.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetDYNAMICRC_TRC() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRC.Reg) & 0x1f
}
func (o *EMC_Type) SetDYNAMICRC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRC.Reg, volatile.LoadUint32(&o.DYNAMICRC.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetDYNAMICRC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRC.Reg) & 0xffffffe0) >> 5
}

// EMC.DYNAMICRFC: Selects the auto-refresh period.
func (o *EMC_Type) SetDYNAMICRFC_TRFC(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRFC.Reg, volatile.LoadUint32(&o.DYNAMICRFC.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetDYNAMICRFC_TRFC() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRFC.Reg) & 0x1f
}
func (o *EMC_Type) SetDYNAMICRFC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRFC.Reg, volatile.LoadUint32(&o.DYNAMICRFC.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetDYNAMICRFC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRFC.Reg) & 0xffffffe0) >> 5
}

// EMC.DYNAMICXSR: Selects the exit self-refresh to active command time.
func (o *EMC_Type) SetDYNAMICXSR_TXSR(value uint32) {
	volatile.StoreUint32(&o.DYNAMICXSR.Reg, volatile.LoadUint32(&o.DYNAMICXSR.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetDYNAMICXSR_TXSR() uint32 {
	return volatile.LoadUint32(&o.DYNAMICXSR.Reg) & 0x1f
}
func (o *EMC_Type) SetDYNAMICXSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICXSR.Reg, volatile.LoadUint32(&o.DYNAMICXSR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetDYNAMICXSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICXSR.Reg) & 0xffffffe0) >> 5
}

// EMC.DYNAMICRRD: Selects the active bank A to active bank B latency.
func (o *EMC_Type) SetDYNAMICRRD_TRRD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRRD.Reg, volatile.LoadUint32(&o.DYNAMICRRD.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICRRD_TRRD() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRRD.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICRRD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRRD.Reg, volatile.LoadUint32(&o.DYNAMICRRD.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICRRD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRRD.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICMRD: Selects the load mode register to active command time.
func (o *EMC_Type) SetDYNAMICMRD_TMRD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICMRD.Reg, volatile.LoadUint32(&o.DYNAMICMRD.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICMRD_TMRD() uint32 {
	return volatile.LoadUint32(&o.DYNAMICMRD.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICMRD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICMRD.Reg, volatile.LoadUint32(&o.DYNAMICMRD.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICMRD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICMRD.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICEXTENDEDWAIT: Selects time for long static memory read and write transfers.
func (o *EMC_Type) SetSTATICEXTENDEDWAIT_EXTENDEDWAIT(value uint32) {
	volatile.StoreUint32(&o.STATICEXTENDEDWAIT.Reg, volatile.LoadUint32(&o.STATICEXTENDEDWAIT.Reg)&^(0x3ff)|value)
}
func (o *EMC_Type) GetSTATICEXTENDEDWAIT_EXTENDEDWAIT() uint32 {
	return volatile.LoadUint32(&o.STATICEXTENDEDWAIT.Reg) & 0x3ff
}
func (o *EMC_Type) SetSTATICEXTENDEDWAIT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICEXTENDEDWAIT.Reg, volatile.LoadUint32(&o.STATICEXTENDEDWAIT.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetSTATICEXTENDEDWAIT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICEXTENDEDWAIT.Reg) & 0xfffffc00) >> 10
}

// EMC.DYNAMICCONFIG0: Selects the configuration information for dynamic memory chip select 0.
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x7)|value)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x7
}
func (o *EMC_Type) SetDYNAMICCONFIG0_MD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_MD() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x60)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x60) >> 5
}
func (o *EMC_Type) SetDYNAMICCONFIG0_AM0(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x1f80)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_AM0() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x1f80) >> 7
}
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x2000)|value<<13)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x2000) >> 13
}
func (o *EMC_Type) SetDYNAMICCONFIG0_AM1(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x4000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_AM1() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x4000) >> 14
}
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x78000)|value<<15)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x78000) >> 15
}
func (o *EMC_Type) SetDYNAMICCONFIG0_B(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_B() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetDYNAMICCONFIG0_P(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_P() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0xffe00000) >> 21
}

// EMC.DYNAMICRASCAS0: Selects the RAS and CAS latencies for dynamic memory chip select 0.
func (o *EMC_Type) SetDYNAMICRASCAS0_RAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS0.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICRASCAS0_RAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICRASCAS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS0.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg)&^(0xfc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICRASCAS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg) & 0xfc) >> 2
}
func (o *EMC_Type) SetDYNAMICRASCAS0_CAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS0.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg)&^(0x300)|value<<8)
}
func (o *EMC_Type) GetDYNAMICRASCAS0_CAS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg) & 0x300) >> 8
}
func (o *EMC_Type) SetDYNAMICRASCAS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS0.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetDYNAMICRASCAS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg) & 0xfffffc00) >> 10
}

// EMC.DYNAMICCONFIG1: Selects the configuration information for dynamic memory chip select 0.
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x7)|value)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x7
}
func (o *EMC_Type) SetDYNAMICCONFIG1_MD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_MD() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x60)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x60) >> 5
}
func (o *EMC_Type) SetDYNAMICCONFIG1_AM0(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x1f80)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_AM0() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x1f80) >> 7
}
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x2000)|value<<13)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x2000) >> 13
}
func (o *EMC_Type) SetDYNAMICCONFIG1_AM1(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x4000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_AM1() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x4000) >> 14
}
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x78000)|value<<15)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x78000) >> 15
}
func (o *EMC_Type) SetDYNAMICCONFIG1_B(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_B() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetDYNAMICCONFIG1_P(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_P() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0xffe00000) >> 21
}

// EMC.DYNAMICRASCAS1: Selects the RAS and CAS latencies for dynamic memory chip select 0.
func (o *EMC_Type) SetDYNAMICRASCAS1_RAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS1.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICRASCAS1_RAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICRASCAS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS1.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg)&^(0xfc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICRASCAS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg) & 0xfc) >> 2
}
func (o *EMC_Type) SetDYNAMICRASCAS1_CAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS1.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg)&^(0x300)|value<<8)
}
func (o *EMC_Type) GetDYNAMICRASCAS1_CAS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg) & 0x300) >> 8
}
func (o *EMC_Type) SetDYNAMICRASCAS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS1.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetDYNAMICRASCAS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg) & 0xfffffc00) >> 10
}

// EMC.DYNAMICCONFIG2: Selects the configuration information for dynamic memory chip select 0.
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x7)|value)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x7
}
func (o *EMC_Type) SetDYNAMICCONFIG2_MD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_MD() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x60)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x60) >> 5
}
func (o *EMC_Type) SetDYNAMICCONFIG2_AM0(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x1f80)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_AM0() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x1f80) >> 7
}
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x2000)|value<<13)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x2000) >> 13
}
func (o *EMC_Type) SetDYNAMICCONFIG2_AM1(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x4000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_AM1() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x4000) >> 14
}
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x78000)|value<<15)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x78000) >> 15
}
func (o *EMC_Type) SetDYNAMICCONFIG2_B(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_B() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetDYNAMICCONFIG2_P(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_P() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0xffe00000) >> 21
}

// EMC.DYNAMICRASCAS2: Selects the RAS and CAS latencies for dynamic memory chip select 0.
func (o *EMC_Type) SetDYNAMICRASCAS2_RAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS2.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICRASCAS2_RAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICRASCAS2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS2.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg)&^(0xfc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICRASCAS2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg) & 0xfc) >> 2
}
func (o *EMC_Type) SetDYNAMICRASCAS2_CAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS2.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg)&^(0x300)|value<<8)
}
func (o *EMC_Type) GetDYNAMICRASCAS2_CAS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg) & 0x300) >> 8
}
func (o *EMC_Type) SetDYNAMICRASCAS2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS2.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetDYNAMICRASCAS2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg) & 0xfffffc00) >> 10
}

// EMC.DYNAMICCONFIG3: Selects the configuration information for dynamic memory chip select 0.
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x7)|value)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x7
}
func (o *EMC_Type) SetDYNAMICCONFIG3_MD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_MD() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x60)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x60) >> 5
}
func (o *EMC_Type) SetDYNAMICCONFIG3_AM0(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x1f80)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_AM0() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x1f80) >> 7
}
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x2000)|value<<13)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x2000) >> 13
}
func (o *EMC_Type) SetDYNAMICCONFIG3_AM1(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x4000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_AM1() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x4000) >> 14
}
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x78000)|value<<15)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x78000) >> 15
}
func (o *EMC_Type) SetDYNAMICCONFIG3_B(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_B() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetDYNAMICCONFIG3_P(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_P() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0xffe00000) >> 21
}

// EMC.DYNAMICRASCAS3: Selects the RAS and CAS latencies for dynamic memory chip select 0.
func (o *EMC_Type) SetDYNAMICRASCAS3_RAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS3.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICRASCAS3_RAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICRASCAS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS3.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg)&^(0xfc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICRASCAS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg) & 0xfc) >> 2
}
func (o *EMC_Type) SetDYNAMICRASCAS3_CAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS3.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg)&^(0x300)|value<<8)
}
func (o *EMC_Type) GetDYNAMICRASCAS3_CAS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg) & 0x300) >> 8
}
func (o *EMC_Type) SetDYNAMICRASCAS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS3.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetDYNAMICRASCAS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg) & 0xfffffc00) >> 10
}

// EMC.STATICCONFIG0: Selects the memory configuration for static chip select 0.
func (o *EMC_Type) SetSTATICCONFIG0_MW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetSTATICCONFIG0_MW() uint32 {
	return volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x3
}
func (o *EMC_Type) SetSTATICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATICCONFIG0_PM(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x8)|value<<3)
}
func (o *EMC_Type) GetSTATICCONFIG0_PM() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x8) >> 3
}
func (o *EMC_Type) SetSTATICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x30)|value<<4)
}
func (o *EMC_Type) GetSTATICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x30) >> 4
}
func (o *EMC_Type) SetSTATICCONFIG0_PC(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetSTATICCONFIG0_PC() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetSTATICCONFIG0_PB(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x80)|value<<7)
}
func (o *EMC_Type) GetSTATICCONFIG0_PB() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x80) >> 7
}
func (o *EMC_Type) SetSTATICCONFIG0_EW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetSTATICCONFIG0_EW() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetSTATICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x7fe00)|value<<9)
}
func (o *EMC_Type) GetSTATICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x7fe00) >> 9
}
func (o *EMC_Type) SetSTATICCONFIG0_B(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetSTATICCONFIG0_B() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetSTATICCONFIG0_P(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetSTATICCONFIG0_P() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetSTATICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetSTATICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0xffe00000) >> 21
}

// EMC.STATICWAITWEN0: Selects the delay from chip select 0 to write enable.
func (o *EMC_Type) SetSTATICWAITWEN0_WAITWEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN0.Reg, volatile.LoadUint32(&o.STATICWAITWEN0.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITWEN0_WAITWEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWEN0.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITWEN0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN0.Reg, volatile.LoadUint32(&o.STATICWAITWEN0.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITWEN0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWEN0.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITOEN0: Selects the delay from chip select 0 or address change, whichever is later, to output enable.
func (o *EMC_Type) SetSTATICWAITOEN0_WAITOEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN0.Reg, volatile.LoadUint32(&o.STATICWAITOEN0.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITOEN0_WAITOEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITOEN0.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITOEN0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN0.Reg, volatile.LoadUint32(&o.STATICWAITOEN0.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITOEN0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITOEN0.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITRD0: Selects the delay from chip select 0 to a read access.
func (o *EMC_Type) SetSTATICWAITRD0_WAITRD(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD0.Reg, volatile.LoadUint32(&o.STATICWAITRD0.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITRD0_WAITRD() uint32 {
	return volatile.LoadUint32(&o.STATICWAITRD0.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITRD0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD0.Reg, volatile.LoadUint32(&o.STATICWAITRD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITRD0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITRD0.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITPAGE0: Selects the delay for asynchronous page mode sequential accesses for chip select 0.
func (o *EMC_Type) SetSTATICWAITPAGE0_WAITPAGE(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE0.Reg, volatile.LoadUint32(&o.STATICWAITPAGE0.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITPAGE0_WAITPAGE() uint32 {
	return volatile.LoadUint32(&o.STATICWAITPAGE0.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITPAGE0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE0.Reg, volatile.LoadUint32(&o.STATICWAITPAGE0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITPAGE0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITPAGE0.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITWR0: Selects the delay from chip select 0 to a write access.
func (o *EMC_Type) SetSTATICWAITWR0_WAITWR(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR0.Reg, volatile.LoadUint32(&o.STATICWAITWR0.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITWR0_WAITWR() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWR0.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITWR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR0.Reg, volatile.LoadUint32(&o.STATICWAITWR0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITWR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWR0.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITTURN0: Selects the number of bus turnaround cycles for chip select 0.
func (o *EMC_Type) SetSTATICWAITTURN0_WAITTURN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN0.Reg, volatile.LoadUint32(&o.STATICWAITTURN0.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITTURN0_WAITTURN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITTURN0.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITTURN0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN0.Reg, volatile.LoadUint32(&o.STATICWAITTURN0.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITTURN0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITTURN0.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICCONFIG1: Selects the memory configuration for static chip select 0.
func (o *EMC_Type) SetSTATICCONFIG1_MW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetSTATICCONFIG1_MW() uint32 {
	return volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x3
}
func (o *EMC_Type) SetSTATICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATICCONFIG1_PM(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x8)|value<<3)
}
func (o *EMC_Type) GetSTATICCONFIG1_PM() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x8) >> 3
}
func (o *EMC_Type) SetSTATICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x30)|value<<4)
}
func (o *EMC_Type) GetSTATICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x30) >> 4
}
func (o *EMC_Type) SetSTATICCONFIG1_PC(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetSTATICCONFIG1_PC() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetSTATICCONFIG1_PB(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x80)|value<<7)
}
func (o *EMC_Type) GetSTATICCONFIG1_PB() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x80) >> 7
}
func (o *EMC_Type) SetSTATICCONFIG1_EW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetSTATICCONFIG1_EW() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetSTATICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x7fe00)|value<<9)
}
func (o *EMC_Type) GetSTATICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x7fe00) >> 9
}
func (o *EMC_Type) SetSTATICCONFIG1_B(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetSTATICCONFIG1_B() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetSTATICCONFIG1_P(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetSTATICCONFIG1_P() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetSTATICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetSTATICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0xffe00000) >> 21
}

// EMC.STATICWAITWEN1: Selects the delay from chip select 0 to write enable.
func (o *EMC_Type) SetSTATICWAITWEN1_WAITWEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN1.Reg, volatile.LoadUint32(&o.STATICWAITWEN1.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITWEN1_WAITWEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWEN1.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITWEN1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN1.Reg, volatile.LoadUint32(&o.STATICWAITWEN1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITWEN1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWEN1.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITOEN1: Selects the delay from chip select 0 or address change, whichever is later, to output enable.
func (o *EMC_Type) SetSTATICWAITOEN1_WAITOEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN1.Reg, volatile.LoadUint32(&o.STATICWAITOEN1.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITOEN1_WAITOEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITOEN1.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITOEN1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN1.Reg, volatile.LoadUint32(&o.STATICWAITOEN1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITOEN1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITOEN1.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITRD1: Selects the delay from chip select 0 to a read access.
func (o *EMC_Type) SetSTATICWAITRD1_WAITRD(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD1.Reg, volatile.LoadUint32(&o.STATICWAITRD1.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITRD1_WAITRD() uint32 {
	return volatile.LoadUint32(&o.STATICWAITRD1.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITRD1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD1.Reg, volatile.LoadUint32(&o.STATICWAITRD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITRD1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITRD1.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITPAGE1: Selects the delay for asynchronous page mode sequential accesses for chip select 0.
func (o *EMC_Type) SetSTATICWAITPAGE1_WAITPAGE(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE1.Reg, volatile.LoadUint32(&o.STATICWAITPAGE1.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITPAGE1_WAITPAGE() uint32 {
	return volatile.LoadUint32(&o.STATICWAITPAGE1.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITPAGE1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE1.Reg, volatile.LoadUint32(&o.STATICWAITPAGE1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITPAGE1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITPAGE1.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITWR1: Selects the delay from chip select 0 to a write access.
func (o *EMC_Type) SetSTATICWAITWR1_WAITWR(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR1.Reg, volatile.LoadUint32(&o.STATICWAITWR1.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITWR1_WAITWR() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWR1.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITWR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR1.Reg, volatile.LoadUint32(&o.STATICWAITWR1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITWR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWR1.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITTURN1: Selects the number of bus turnaround cycles for chip select 0.
func (o *EMC_Type) SetSTATICWAITTURN1_WAITTURN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN1.Reg, volatile.LoadUint32(&o.STATICWAITTURN1.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITTURN1_WAITTURN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITTURN1.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITTURN1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN1.Reg, volatile.LoadUint32(&o.STATICWAITTURN1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITTURN1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITTURN1.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICCONFIG2: Selects the memory configuration for static chip select 0.
func (o *EMC_Type) SetSTATICCONFIG2_MW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetSTATICCONFIG2_MW() uint32 {
	return volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x3
}
func (o *EMC_Type) SetSTATICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATICCONFIG2_PM(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x8)|value<<3)
}
func (o *EMC_Type) GetSTATICCONFIG2_PM() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x8) >> 3
}
func (o *EMC_Type) SetSTATICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x30)|value<<4)
}
func (o *EMC_Type) GetSTATICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x30) >> 4
}
func (o *EMC_Type) SetSTATICCONFIG2_PC(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetSTATICCONFIG2_PC() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetSTATICCONFIG2_PB(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x80)|value<<7)
}
func (o *EMC_Type) GetSTATICCONFIG2_PB() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x80) >> 7
}
func (o *EMC_Type) SetSTATICCONFIG2_EW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetSTATICCONFIG2_EW() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetSTATICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x7fe00)|value<<9)
}
func (o *EMC_Type) GetSTATICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x7fe00) >> 9
}
func (o *EMC_Type) SetSTATICCONFIG2_B(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetSTATICCONFIG2_B() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetSTATICCONFIG2_P(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetSTATICCONFIG2_P() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetSTATICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetSTATICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0xffe00000) >> 21
}

// EMC.STATICWAITWEN2: Selects the delay from chip select 0 to write enable.
func (o *EMC_Type) SetSTATICWAITWEN2_WAITWEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN2.Reg, volatile.LoadUint32(&o.STATICWAITWEN2.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITWEN2_WAITWEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWEN2.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITWEN2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN2.Reg, volatile.LoadUint32(&o.STATICWAITWEN2.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITWEN2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWEN2.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITOEN2: Selects the delay from chip select 0 or address change, whichever is later, to output enable.
func (o *EMC_Type) SetSTATICWAITOEN2_WAITOEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN2.Reg, volatile.LoadUint32(&o.STATICWAITOEN2.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITOEN2_WAITOEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITOEN2.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITOEN2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN2.Reg, volatile.LoadUint32(&o.STATICWAITOEN2.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITOEN2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITOEN2.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITRD2: Selects the delay from chip select 0 to a read access.
func (o *EMC_Type) SetSTATICWAITRD2_WAITRD(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD2.Reg, volatile.LoadUint32(&o.STATICWAITRD2.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITRD2_WAITRD() uint32 {
	return volatile.LoadUint32(&o.STATICWAITRD2.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITRD2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD2.Reg, volatile.LoadUint32(&o.STATICWAITRD2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITRD2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITRD2.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITPAGE2: Selects the delay for asynchronous page mode sequential accesses for chip select 0.
func (o *EMC_Type) SetSTATICWAITPAGE2_WAITPAGE(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE2.Reg, volatile.LoadUint32(&o.STATICWAITPAGE2.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITPAGE2_WAITPAGE() uint32 {
	return volatile.LoadUint32(&o.STATICWAITPAGE2.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITPAGE2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE2.Reg, volatile.LoadUint32(&o.STATICWAITPAGE2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITPAGE2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITPAGE2.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITWR2: Selects the delay from chip select 0 to a write access.
func (o *EMC_Type) SetSTATICWAITWR2_WAITWR(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR2.Reg, volatile.LoadUint32(&o.STATICWAITWR2.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITWR2_WAITWR() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWR2.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITWR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR2.Reg, volatile.LoadUint32(&o.STATICWAITWR2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITWR2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWR2.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITTURN2: Selects the number of bus turnaround cycles for chip select 0.
func (o *EMC_Type) SetSTATICWAITTURN2_WAITTURN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN2.Reg, volatile.LoadUint32(&o.STATICWAITTURN2.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITTURN2_WAITTURN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITTURN2.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITTURN2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN2.Reg, volatile.LoadUint32(&o.STATICWAITTURN2.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITTURN2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITTURN2.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICCONFIG3: Selects the memory configuration for static chip select 0.
func (o *EMC_Type) SetSTATICCONFIG3_MW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetSTATICCONFIG3_MW() uint32 {
	return volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x3
}
func (o *EMC_Type) SetSTATICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATICCONFIG3_PM(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x8)|value<<3)
}
func (o *EMC_Type) GetSTATICCONFIG3_PM() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x8) >> 3
}
func (o *EMC_Type) SetSTATICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x30)|value<<4)
}
func (o *EMC_Type) GetSTATICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x30) >> 4
}
func (o *EMC_Type) SetSTATICCONFIG3_PC(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetSTATICCONFIG3_PC() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetSTATICCONFIG3_PB(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x80)|value<<7)
}
func (o *EMC_Type) GetSTATICCONFIG3_PB() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x80) >> 7
}
func (o *EMC_Type) SetSTATICCONFIG3_EW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetSTATICCONFIG3_EW() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetSTATICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x7fe00)|value<<9)
}
func (o *EMC_Type) GetSTATICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x7fe00) >> 9
}
func (o *EMC_Type) SetSTATICCONFIG3_B(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetSTATICCONFIG3_B() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetSTATICCONFIG3_P(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetSTATICCONFIG3_P() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetSTATICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetSTATICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0xffe00000) >> 21
}

// EMC.STATICWAITWEN3: Selects the delay from chip select 0 to write enable.
func (o *EMC_Type) SetSTATICWAITWEN3_WAITWEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN3.Reg, volatile.LoadUint32(&o.STATICWAITWEN3.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITWEN3_WAITWEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWEN3.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITWEN3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN3.Reg, volatile.LoadUint32(&o.STATICWAITWEN3.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITWEN3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWEN3.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITOEN3: Selects the delay from chip select 0 or address change, whichever is later, to output enable.
func (o *EMC_Type) SetSTATICWAITOEN3_WAITOEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN3.Reg, volatile.LoadUint32(&o.STATICWAITOEN3.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITOEN3_WAITOEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITOEN3.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITOEN3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN3.Reg, volatile.LoadUint32(&o.STATICWAITOEN3.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITOEN3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITOEN3.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITRD3: Selects the delay from chip select 0 to a read access.
func (o *EMC_Type) SetSTATICWAITRD3_WAITRD(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD3.Reg, volatile.LoadUint32(&o.STATICWAITRD3.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITRD3_WAITRD() uint32 {
	return volatile.LoadUint32(&o.STATICWAITRD3.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITRD3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD3.Reg, volatile.LoadUint32(&o.STATICWAITRD3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITRD3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITRD3.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITPAGE3: Selects the delay for asynchronous page mode sequential accesses for chip select 0.
func (o *EMC_Type) SetSTATICWAITPAGE3_WAITPAGE(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE3.Reg, volatile.LoadUint32(&o.STATICWAITPAGE3.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITPAGE3_WAITPAGE() uint32 {
	return volatile.LoadUint32(&o.STATICWAITPAGE3.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITPAGE3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE3.Reg, volatile.LoadUint32(&o.STATICWAITPAGE3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITPAGE3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITPAGE3.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITWR3: Selects the delay from chip select 0 to a write access.
func (o *EMC_Type) SetSTATICWAITWR3_WAITWR(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR3.Reg, volatile.LoadUint32(&o.STATICWAITWR3.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITWR3_WAITWR() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWR3.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITWR3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR3.Reg, volatile.LoadUint32(&o.STATICWAITWR3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITWR3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWR3.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITTURN3: Selects the number of bus turnaround cycles for chip select 0.
func (o *EMC_Type) SetSTATICWAITTURN3_WAITTURN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN3.Reg, volatile.LoadUint32(&o.STATICWAITTURN3.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITTURN3_WAITTURN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITTURN3.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITTURN3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN3.Reg, volatile.LoadUint32(&o.STATICWAITTURN3.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITTURN3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITTURN3.Reg) & 0xfffffff0) >> 4
}

// USB0 Host/Device/OTG controller
type USB0_Type struct {
	_                [256]byte
	CAPLENGTH        volatile.Register32 // 0x100
	HCSPARAMS        volatile.Register32 // 0x104
	HCCPARAMS        volatile.Register32 // 0x108
	_                [20]byte
	DCIVERSION       volatile.Register32 // 0x120
	_                [28]byte
	USBCMD_D         volatile.Register32 // 0x140
	USBSTS_D         volatile.Register32 // 0x144
	USBINTR_D        volatile.Register32 // 0x148
	FRINDEX_D        volatile.Register32 // 0x14C
	_                [4]byte
	DEVICEADDR       volatile.Register32 // 0x154
	ENDPOINTLISTADDR volatile.Register32 // 0x158
	TTCTRL           volatile.Register32 // 0x15C
	BURSTSIZE        volatile.Register32 // 0x160
	TXFILLTUNING     volatile.Register32 // 0x164
	_                [12]byte
	BINTERVAL        volatile.Register32 // 0x174
	ENDPTNAK         volatile.Register32 // 0x178
	ENDPTNAKEN       volatile.Register32 // 0x17C
	_                [4]byte
	PORTSC1_D        volatile.Register32 // 0x184
	_                [28]byte
	OTGSC            volatile.Register32 // 0x1A4
	USBMODE_D        volatile.Register32 // 0x1A8
	ENDPTSETUPSTAT   volatile.Register32 // 0x1AC
	ENDPTPRIME       volatile.Register32 // 0x1B0
	ENDPTFLUSH       volatile.Register32 // 0x1B4
	ENDPTSTAT        volatile.Register32 // 0x1B8
	ENDPTCOMPLETE    volatile.Register32 // 0x1BC
	ENDPTCTRL0       volatile.Register32 // 0x1C0
	ENDPTCTRL1       volatile.Register32 // 0x1C4
	ENDPTCTRL2       volatile.Register32 // 0x1C8
	ENDPTCTRL3       volatile.Register32 // 0x1CC
	ENDPTCTRL4       volatile.Register32 // 0x1D0
	ENDPTCTRL5       volatile.Register32 // 0x1D4
}

// USB0.CAPLENGTH: Capability register length
func (o *USB0_Type) SetCAPLENGTH(value uint32) {
	volatile.StoreUint32(&o.CAPLENGTH.Reg, volatile.LoadUint32(&o.CAPLENGTH.Reg)&^(0xff)|value)
}
func (o *USB0_Type) GetCAPLENGTH() uint32 {
	return volatile.LoadUint32(&o.CAPLENGTH.Reg) & 0xff
}
func (o *USB0_Type) SetCAPLENGTH_HCIVERSION(value uint32) {
	volatile.StoreUint32(&o.CAPLENGTH.Reg, volatile.LoadUint32(&o.CAPLENGTH.Reg)&^(0xffff00)|value<<8)
}
func (o *USB0_Type) GetCAPLENGTH_HCIVERSION() uint32 {
	return (volatile.LoadUint32(&o.CAPLENGTH.Reg) & 0xffff00) >> 8
}
func (o *USB0_Type) SetCAPLENGTH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAPLENGTH.Reg, volatile.LoadUint32(&o.CAPLENGTH.Reg)&^(0xff000000)|value<<24)
}
func (o *USB0_Type) GetCAPLENGTH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAPLENGTH.Reg) & 0xff000000) >> 24
}

// USB0.HCSPARAMS: Host controller structural parameters
func (o *USB0_Type) SetHCSPARAMS_N_PORTS(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf)|value)
}
func (o *USB0_Type) GetHCSPARAMS_N_PORTS() uint32 {
	return volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf
}
func (o *USB0_Type) SetHCSPARAMS_PPC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetHCSPARAMS_PPC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetHCSPARAMS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xe0)|value<<5)
}
func (o *USB0_Type) GetHCSPARAMS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xe0) >> 5
}
func (o *USB0_Type) SetHCSPARAMS_N_PCC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf00)|value<<8)
}
func (o *USB0_Type) GetHCSPARAMS_N_PCC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf00) >> 8
}
func (o *USB0_Type) SetHCSPARAMS_N_CC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf000)|value<<12)
}
func (o *USB0_Type) GetHCSPARAMS_N_CC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf000) >> 12
}
func (o *USB0_Type) SetHCSPARAMS_PI(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetHCSPARAMS_PI() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetHCSPARAMS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xe0000)|value<<17)
}
func (o *USB0_Type) GetHCSPARAMS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xe0000) >> 17
}
func (o *USB0_Type) SetHCSPARAMS_N_PTT(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf00000)|value<<20)
}
func (o *USB0_Type) GetHCSPARAMS_N_PTT() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf00000) >> 20
}
func (o *USB0_Type) SetHCSPARAMS_N_TT(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf000000)|value<<24)
}
func (o *USB0_Type) GetHCSPARAMS_N_TT() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf000000) >> 24
}
func (o *USB0_Type) SetHCSPARAMS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf0000000)|value<<28)
}
func (o *USB0_Type) GetHCSPARAMS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf0000000) >> 28
}

// USB0.HCCPARAMS: Host controller capability parameters
func (o *USB0_Type) SetHCCPARAMS_ADC(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetHCCPARAMS_ADC() uint32 {
	return volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x1
}
func (o *USB0_Type) SetHCCPARAMS_PFL(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetHCCPARAMS_PFL() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetHCCPARAMS_ASP(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetHCCPARAMS_ASP() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetHCCPARAMS_IST(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xf0)|value<<4)
}
func (o *USB0_Type) GetHCCPARAMS_IST() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xf0) >> 4
}
func (o *USB0_Type) SetHCCPARAMS_EECP(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xff00)|value<<8)
}
func (o *USB0_Type) GetHCCPARAMS_EECP() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xff00) >> 8
}
func (o *USB0_Type) SetHCCPARAMS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB0_Type) GetHCCPARAMS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xffff0000) >> 16
}

// USB0.DCIVERSION: Device interface version number
func (o *USB0_Type) SetDCIVERSION(value uint32) {
	volatile.StoreUint32(&o.DCIVERSION.Reg, volatile.LoadUint32(&o.DCIVERSION.Reg)&^(0xffff)|value)
}
func (o *USB0_Type) GetDCIVERSION() uint32 {
	return volatile.LoadUint32(&o.DCIVERSION.Reg) & 0xffff
}

// USB0.USBCMD_D: USB command (device mode)
func (o *USB0_Type) SetUSBCMD_D_RS(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetUSBCMD_D_RS() uint32 {
	return volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x1
}
func (o *USB0_Type) SetUSBCMD_D_RST(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetUSBCMD_D_RST() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0xc)|value<<2)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0xc) >> 2
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x300)|value<<8)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x300) >> 8
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x400)|value<<10)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x400) >> 10
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x800)|value<<11)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x800) >> 11
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x1000)|value<<12)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x1000) >> 12
}
func (o *USB0_Type) SetUSBCMD_D_SUTW(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x2000)|value<<13)
}
func (o *USB0_Type) GetUSBCMD_D_SUTW() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x2000) >> 13
}
func (o *USB0_Type) SetUSBCMD_D_ATDTW(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x4000)|value<<14)
}
func (o *USB0_Type) GetUSBCMD_D_ATDTW() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x4000) >> 14
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x8000)|value<<15)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x8000) >> 15
}
func (o *USB0_Type) SetUSBCMD_D_ITC(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0xff0000)|value<<16)
}
func (o *USB0_Type) GetUSBCMD_D_ITC() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0xff0000) >> 16
}
func (o *USB0_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0xff000000)|value<<24)
}
func (o *USB0_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0xff000000) >> 24
}

// USB0.USBSTS_D: USB status (device mode)
func (o *USB0_Type) SetUSBSTS_D_UI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetUSBSTS_D_UI() uint32 {
	return volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x1
}
func (o *USB0_Type) SetUSBSTS_D_UEI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetUSBSTS_D_UEI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetUSBSTS_D_PCI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetUSBSTS_D_PCI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetUSBSTS_D_AAI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetUSBSTS_D_AAI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetUSBSTS_D_URI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetUSBSTS_D_URI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetUSBSTS_D_SRI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetUSBSTS_D_SRI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetUSBSTS_D_SLI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x100)|value<<8)
}
func (o *USB0_Type) GetUSBSTS_D_SLI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x100) >> 8
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0xe00)|value<<9)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0xe00) >> 9
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x1000)|value<<12)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x1000) >> 12
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x2000)|value<<13)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x2000) >> 13
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x4000)|value<<14)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x4000) >> 14
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x8000)|value<<15)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x8000) >> 15
}
func (o *USB0_Type) SetUSBSTS_D_NAKI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetUSBSTS_D_NAKI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x40000)|value<<18)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x40000) >> 18
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x80000)|value<<19)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x80000) >> 19
}
func (o *USB0_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB0_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0xfff00000) >> 20
}

// USB0.USBINTR_D: USB interrupt enable (device mode)
func (o *USB0_Type) SetUSBINTR_D_UE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetUSBINTR_D_UE() uint32 {
	return volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x1
}
func (o *USB0_Type) SetUSBINTR_D_UEE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetUSBINTR_D_UEE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetUSBINTR_D_PCE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetUSBINTR_D_PCE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetUSBINTR_D_URE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetUSBINTR_D_URE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetUSBINTR_D_SRE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetUSBINTR_D_SRE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetUSBINTR_D_SLE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x100)|value<<8)
}
func (o *USB0_Type) GetUSBINTR_D_SLE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x100) >> 8
}
func (o *USB0_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0xfe00)|value<<9)
}
func (o *USB0_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0xfe00) >> 9
}
func (o *USB0_Type) SetUSBINTR_D_NAKE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetUSBINTR_D_NAKE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x40000)|value<<18)
}
func (o *USB0_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x40000) >> 18
}
func (o *USB0_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x80000)|value<<19)
}
func (o *USB0_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x80000) >> 19
}
func (o *USB0_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB0_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0xfff00000) >> 20
}

// USB0.FRINDEX_D: USB frame index (device mode)
func (o *USB0_Type) SetFRINDEX_D_FRINDEX2_0(value uint32) {
	volatile.StoreUint32(&o.FRINDEX_D.Reg, volatile.LoadUint32(&o.FRINDEX_D.Reg)&^(0x7)|value)
}
func (o *USB0_Type) GetFRINDEX_D_FRINDEX2_0() uint32 {
	return volatile.LoadUint32(&o.FRINDEX_D.Reg) & 0x7
}
func (o *USB0_Type) SetFRINDEX_D_FRINDEX13_3(value uint32) {
	volatile.StoreUint32(&o.FRINDEX_D.Reg, volatile.LoadUint32(&o.FRINDEX_D.Reg)&^(0x3ff8)|value<<3)
}
func (o *USB0_Type) GetFRINDEX_D_FRINDEX13_3() uint32 {
	return (volatile.LoadUint32(&o.FRINDEX_D.Reg) & 0x3ff8) >> 3
}
func (o *USB0_Type) SetFRINDEX_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRINDEX_D.Reg, volatile.LoadUint32(&o.FRINDEX_D.Reg)&^(0xffffc000)|value<<14)
}
func (o *USB0_Type) GetFRINDEX_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRINDEX_D.Reg) & 0xffffc000) >> 14
}

// USB0.DEVICEADDR: USB device address (device mode)
func (o *USB0_Type) SetDEVICEADDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0xffffff)|value)
}
func (o *USB0_Type) GetDEVICEADDR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0xffffff
}
func (o *USB0_Type) SetDEVICEADDR_USBADRA(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0x1000000)|value<<24)
}
func (o *USB0_Type) GetDEVICEADDR_USBADRA() uint32 {
	return (volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0x1000000) >> 24
}
func (o *USB0_Type) SetDEVICEADDR_USBADR(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0xfe000000)|value<<25)
}
func (o *USB0_Type) GetDEVICEADDR_USBADR() uint32 {
	return (volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0xfe000000) >> 25
}

// USB0.ENDPOINTLISTADDR: Address of endpoint list in memory
func (o *USB0_Type) SetENDPOINTLISTADDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPOINTLISTADDR.Reg, volatile.LoadUint32(&o.ENDPOINTLISTADDR.Reg)&^(0x7ff)|value)
}
func (o *USB0_Type) GetENDPOINTLISTADDR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.ENDPOINTLISTADDR.Reg) & 0x7ff
}
func (o *USB0_Type) SetENDPOINTLISTADDR_EPBASE31_11(value uint32) {
	volatile.StoreUint32(&o.ENDPOINTLISTADDR.Reg, volatile.LoadUint32(&o.ENDPOINTLISTADDR.Reg)&^(0xfffff800)|value<<11)
}
func (o *USB0_Type) GetENDPOINTLISTADDR_EPBASE31_11() uint32 {
	return (volatile.LoadUint32(&o.ENDPOINTLISTADDR.Reg) & 0xfffff800) >> 11
}

// USB0.TTCTRL: Asynchronous buffer status for embedded TT (host mode)
func (o *USB0_Type) SetTTCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TTCTRL.Reg, volatile.LoadUint32(&o.TTCTRL.Reg)&^(0xffffff)|value)
}
func (o *USB0_Type) GetTTCTRL_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TTCTRL.Reg) & 0xffffff
}
func (o *USB0_Type) SetTTCTRL_TTHA(value uint32) {
	volatile.StoreUint32(&o.TTCTRL.Reg, volatile.LoadUint32(&o.TTCTRL.Reg)&^(0x7f000000)|value<<24)
}
func (o *USB0_Type) GetTTCTRL_TTHA() uint32 {
	return (volatile.LoadUint32(&o.TTCTRL.Reg) & 0x7f000000) >> 24
}
func (o *USB0_Type) SetTTCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TTCTRL.Reg, volatile.LoadUint32(&o.TTCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USB0_Type) GetTTCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TTCTRL.Reg) & 0x80000000) >> 31
}

// USB0.BURSTSIZE: Programmable burst size
func (o *USB0_Type) SetBURSTSIZE_RXPBURST(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0xff)|value)
}
func (o *USB0_Type) GetBURSTSIZE_RXPBURST() uint32 {
	return volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0xff
}
func (o *USB0_Type) SetBURSTSIZE_TXPBURST(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0xff00)|value<<8)
}
func (o *USB0_Type) GetBURSTSIZE_TXPBURST() uint32 {
	return (volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0xff00) >> 8
}
func (o *USB0_Type) SetBURSTSIZE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB0_Type) GetBURSTSIZE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0xffff0000) >> 16
}

// USB0.TXFILLTUNING: Host transmit pre-buffer packet tuning (host mode)
func (o *USB0_Type) SetTXFILLTUNING_TXSCHOH(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0xff)|value)
}
func (o *USB0_Type) GetTXFILLTUNING_TXSCHOH() uint32 {
	return volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0xff
}
func (o *USB0_Type) SetTXFILLTUNING_TXSCHEATLTH(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0x1f00)|value<<8)
}
func (o *USB0_Type) GetTXFILLTUNING_TXSCHEATLTH() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0x1f00) >> 8
}
func (o *USB0_Type) SetTXFILLTUNING_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0xe000)|value<<13)
}
func (o *USB0_Type) GetTXFILLTUNING_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0xe000) >> 13
}
func (o *USB0_Type) SetTXFILLTUNING_TXFIFOTHRES(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0x3f0000)|value<<16)
}
func (o *USB0_Type) GetTXFILLTUNING_TXFIFOTHRES() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0x3f0000) >> 16
}
func (o *USB0_Type) SetTXFILLTUNING_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0xffc00000)|value<<22)
}
func (o *USB0_Type) GetTXFILLTUNING_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0xffc00000) >> 22
}

// USB0.BINTERVAL: Length of virtual frame
func (o *USB0_Type) SetBINTERVAL_BINT(value uint32) {
	volatile.StoreUint32(&o.BINTERVAL.Reg, volatile.LoadUint32(&o.BINTERVAL.Reg)&^(0xf)|value)
}
func (o *USB0_Type) GetBINTERVAL_BINT() uint32 {
	return volatile.LoadUint32(&o.BINTERVAL.Reg) & 0xf
}
func (o *USB0_Type) SetBINTERVAL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BINTERVAL.Reg, volatile.LoadUint32(&o.BINTERVAL.Reg)&^(0xfffffff0)|value<<4)
}
func (o *USB0_Type) GetBINTERVAL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BINTERVAL.Reg) & 0xfffffff0) >> 4
}

// USB0.ENDPTNAK: Endpoint NAK (device mode)
func (o *USB0_Type) SetENDPTNAK_EPRN0(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTNAK_EPRN0() uint32 {
	return volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTNAK_EPRN1(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTNAK_EPRN1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTNAK_EPRN2(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPTNAK_EPRN2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPTNAK_EPRN3(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPTNAK_EPRN3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPTNAK_EPRN4(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTNAK_EPRN4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTNAK_EPRN5(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTNAK_EPRN5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTNAK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0xffc0)|value<<6)
}
func (o *USB0_Type) GetENDPTNAK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0xffc0) >> 6
}
func (o *USB0_Type) SetENDPTNAK_EPTN0(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTNAK_EPTN0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTNAK_EPTN1(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTNAK_EPTN1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTNAK_EPTN2(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x40000)|value<<18)
}
func (o *USB0_Type) GetENDPTNAK_EPTN2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x40000) >> 18
}
func (o *USB0_Type) SetENDPTNAK_EPTN3(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x80000)|value<<19)
}
func (o *USB0_Type) GetENDPTNAK_EPTN3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x80000) >> 19
}
func (o *USB0_Type) SetENDPTNAK_EPTN4(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTNAK_EPTN4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTNAK_EPTN5(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTNAK_EPTN5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTNAK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0xffc00000)|value<<22)
}
func (o *USB0_Type) GetENDPTNAK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0xffc00000) >> 22
}

// USB0.ENDPTNAKEN: Endpoint NAK Enable (device mode)
func (o *USB0_Type) SetENDPTNAKEN_EPRNE0(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTNAKEN_EPRNE0() uint32 {
	return volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTNAKEN_EPRNE1(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTNAKEN_EPRNE1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTNAKEN_EPRNE2(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPTNAKEN_EPRNE2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPTNAKEN_EPRNE3(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPTNAKEN_EPRNE3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPTNAKEN_EPRNE4(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTNAKEN_EPRNE4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTNAKEN_EPRNE5(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTNAKEN_EPRNE5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTNAKEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0xffc0)|value<<6)
}
func (o *USB0_Type) GetENDPTNAKEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0xffc0) >> 6
}
func (o *USB0_Type) SetENDPTNAKEN_EPTNE0(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTNAKEN_EPTNE0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTNAKEN_EPTNE1(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTNAKEN_EPTNE1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTNAKEN_EPTNE2(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x40000)|value<<18)
}
func (o *USB0_Type) GetENDPTNAKEN_EPTNE2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x40000) >> 18
}
func (o *USB0_Type) SetENDPTNAKEN_EPTNE3(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x80000)|value<<19)
}
func (o *USB0_Type) GetENDPTNAKEN_EPTNE3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x80000) >> 19
}
func (o *USB0_Type) SetENDPTNAKEN_EPTNE4(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTNAKEN_EPTNE4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTNAKEN_EPTNE5(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTNAKEN_EPTNE5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTNAKEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0xffc00000)|value<<22)
}
func (o *USB0_Type) GetENDPTNAKEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0xffc00000) >> 22
}

// USB0.PORTSC1_D: Port 1 status/control (device mode)
func (o *USB0_Type) SetPORTSC1_D_CCS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetPORTSC1_D_CCS() uint32 {
	return volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x1
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetPORTSC1_D_PE(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetPORTSC1_D_PE() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetPORTSC1_D_PEC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetPORTSC1_D_PEC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x30)|value<<4)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x30) >> 4
}
func (o *USB0_Type) SetPORTSC1_D_FPR(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetPORTSC1_D_FPR() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetPORTSC1_D_SUSP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetPORTSC1_D_SUSP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetPORTSC1_D_PR(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x100)|value<<8)
}
func (o *USB0_Type) GetPORTSC1_D_PR() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x100) >> 8
}
func (o *USB0_Type) SetPORTSC1_D_HSP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x200)|value<<9)
}
func (o *USB0_Type) GetPORTSC1_D_HSP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x200) >> 9
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xc00)|value<<10)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xc00) >> 10
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x1000)|value<<12)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x1000) >> 12
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x2000)|value<<13)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x2000) >> 13
}
func (o *USB0_Type) SetPORTSC1_D_PIC1_0(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xc000)|value<<14)
}
func (o *USB0_Type) GetPORTSC1_D_PIC1_0() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xc000) >> 14
}
func (o *USB0_Type) SetPORTSC1_D_PTC3_0(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xf0000)|value<<16)
}
func (o *USB0_Type) GetPORTSC1_D_PTC3_0() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xf0000) >> 16
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x400000)|value<<22)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x400000) >> 22
}
func (o *USB0_Type) SetPORTSC1_D_PHCD(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x800000)|value<<23)
}
func (o *USB0_Type) GetPORTSC1_D_PHCD() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x800000) >> 23
}
func (o *USB0_Type) SetPORTSC1_D_PFSC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x1000000)|value<<24)
}
func (o *USB0_Type) GetPORTSC1_D_PFSC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x1000000) >> 24
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x2000000)|value<<25)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x2000000) >> 25
}
func (o *USB0_Type) SetPORTSC1_D_PSPD(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xc000000)|value<<26)
}
func (o *USB0_Type) GetPORTSC1_D_PSPD() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xc000000) >> 26
}
func (o *USB0_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xf0000000)|value<<28)
}
func (o *USB0_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xf0000000) >> 28
}

// USB0.OTGSC: OTG status and control
func (o *USB0_Type) SetOTGSC_VD(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetOTGSC_VD() uint32 {
	return volatile.LoadUint32(&o.OTGSC.Reg) & 0x1
}
func (o *USB0_Type) SetOTGSC_VC(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetOTGSC_VC() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetOTGSC_HAAR(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetOTGSC_HAAR() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetOTGSC_OT(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetOTGSC_OT() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetOTGSC_DP(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetOTGSC_DP() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetOTGSC_IDPU(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetOTGSC_IDPU() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetOTGSC_HADP(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetOTGSC_HADP() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetOTGSC_HABA(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetOTGSC_HABA() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetOTGSC_ID(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x100)|value<<8)
}
func (o *USB0_Type) GetOTGSC_ID() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x100) >> 8
}
func (o *USB0_Type) SetOTGSC_AVV(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x200)|value<<9)
}
func (o *USB0_Type) GetOTGSC_AVV() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x200) >> 9
}
func (o *USB0_Type) SetOTGSC_ASV(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x400)|value<<10)
}
func (o *USB0_Type) GetOTGSC_ASV() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x400) >> 10
}
func (o *USB0_Type) SetOTGSC_BSV(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x800)|value<<11)
}
func (o *USB0_Type) GetOTGSC_BSV() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x800) >> 11
}
func (o *USB0_Type) SetOTGSC_BSE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x1000)|value<<12)
}
func (o *USB0_Type) GetOTGSC_BSE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x1000) >> 12
}
func (o *USB0_Type) SetOTGSC_MS1T(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x2000)|value<<13)
}
func (o *USB0_Type) GetOTGSC_MS1T() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x2000) >> 13
}
func (o *USB0_Type) SetOTGSC_DPS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x4000)|value<<14)
}
func (o *USB0_Type) GetOTGSC_DPS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x4000) >> 14
}
func (o *USB0_Type) SetOTGSC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x8000)|value<<15)
}
func (o *USB0_Type) GetOTGSC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x8000) >> 15
}
func (o *USB0_Type) SetOTGSC_IDIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetOTGSC_IDIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetOTGSC_AVVIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetOTGSC_AVVIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetOTGSC_ASVIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x40000)|value<<18)
}
func (o *USB0_Type) GetOTGSC_ASVIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x40000) >> 18
}
func (o *USB0_Type) SetOTGSC_BSVIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x80000)|value<<19)
}
func (o *USB0_Type) GetOTGSC_BSVIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x80000) >> 19
}
func (o *USB0_Type) SetOTGSC_BSEIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetOTGSC_BSEIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetOTGSC_MS1S(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetOTGSC_MS1S() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetOTGSC_DPIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x400000)|value<<22)
}
func (o *USB0_Type) GetOTGSC_DPIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x400000) >> 22
}
func (o *USB0_Type) SetOTGSC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x800000)|value<<23)
}
func (o *USB0_Type) GetOTGSC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x800000) >> 23
}
func (o *USB0_Type) SetOTGSC_IDIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x1000000)|value<<24)
}
func (o *USB0_Type) GetOTGSC_IDIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x1000000) >> 24
}
func (o *USB0_Type) SetOTGSC_AVVIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x2000000)|value<<25)
}
func (o *USB0_Type) GetOTGSC_AVVIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x2000000) >> 25
}
func (o *USB0_Type) SetOTGSC_ASVIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x4000000)|value<<26)
}
func (o *USB0_Type) GetOTGSC_ASVIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x4000000) >> 26
}
func (o *USB0_Type) SetOTGSC_BSVIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x8000000)|value<<27)
}
func (o *USB0_Type) GetOTGSC_BSVIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x8000000) >> 27
}
func (o *USB0_Type) SetOTGSC_BSEIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x10000000)|value<<28)
}
func (o *USB0_Type) GetOTGSC_BSEIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x10000000) >> 28
}
func (o *USB0_Type) SetOTGSC_MS1E(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x20000000)|value<<29)
}
func (o *USB0_Type) GetOTGSC_MS1E() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x20000000) >> 29
}
func (o *USB0_Type) SetOTGSC_DPIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x40000000)|value<<30)
}
func (o *USB0_Type) GetOTGSC_DPIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x40000000) >> 30
}
func (o *USB0_Type) SetOTGSC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x80000000)|value<<31)
}
func (o *USB0_Type) GetOTGSC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x80000000) >> 31
}

// USB0.USBMODE_D: USB device mode (device mode)
func (o *USB0_Type) SetUSBMODE_D_CM1_0(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x3)|value)
}
func (o *USB0_Type) GetUSBMODE_D_CM1_0() uint32 {
	return volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x3
}
func (o *USB0_Type) SetUSBMODE_D_ES(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetUSBMODE_D_ES() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetUSBMODE_D_SLOM(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetUSBMODE_D_SLOM() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetUSBMODE_D_SDIS(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetUSBMODE_D_SDIS() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetUSBMODE_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetUSBMODE_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetUSBMODE_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0xffffffc0)|value<<6)
}
func (o *USB0_Type) GetUSBMODE_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0xffffffc0) >> 6
}

// USB0.ENDPTSETUPSTAT: Endpoint setup status
func (o *USB0_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT0(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT0() uint32 {
	return volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT1(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT2(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT3(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT4(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT5(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTSETUPSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0xffffffc0)|value<<6)
}
func (o *USB0_Type) GetENDPTSETUPSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0xffffffc0) >> 6
}

// USB0.ENDPTPRIME: Endpoint initialization
func (o *USB0_Type) SetENDPTPRIME_PERB0(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTPRIME_PERB0() uint32 {
	return volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTPRIME_PERB1(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTPRIME_PERB1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTPRIME_PERB2(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPTPRIME_PERB2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPTPRIME_PERB3(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPTPRIME_PERB3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPTPRIME_PERB4(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTPRIME_PERB4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTPRIME_PERB5(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTPRIME_PERB5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTPRIME_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0xffc0)|value<<6)
}
func (o *USB0_Type) GetENDPTPRIME_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0xffc0) >> 6
}
func (o *USB0_Type) SetENDPTPRIME_PETB0(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTPRIME_PETB0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTPRIME_PETB1(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTPRIME_PETB1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTPRIME_PETB2(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x40000)|value<<18)
}
func (o *USB0_Type) GetENDPTPRIME_PETB2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x40000) >> 18
}
func (o *USB0_Type) SetENDPTPRIME_PETB3(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x80000)|value<<19)
}
func (o *USB0_Type) GetENDPTPRIME_PETB3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x80000) >> 19
}
func (o *USB0_Type) SetENDPTPRIME_PETB4(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTPRIME_PETB4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTPRIME_PETB5(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTPRIME_PETB5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTPRIME_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0xffc00000)|value<<22)
}
func (o *USB0_Type) GetENDPTPRIME_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0xffc00000) >> 22
}

// USB0.ENDPTFLUSH: Endpoint de-initialization
func (o *USB0_Type) SetENDPTFLUSH_FERB0(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTFLUSH_FERB0() uint32 {
	return volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTFLUSH_FERB1(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTFLUSH_FERB1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTFLUSH_FERB2(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPTFLUSH_FERB2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPTFLUSH_FERB3(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPTFLUSH_FERB3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPTFLUSH_FERB4(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTFLUSH_FERB4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTFLUSH_FERB5(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTFLUSH_FERB5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTFLUSH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0xffc0)|value<<6)
}
func (o *USB0_Type) GetENDPTFLUSH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0xffc0) >> 6
}
func (o *USB0_Type) SetENDPTFLUSH_FETB0(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTFLUSH_FETB0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTFLUSH_FETB1(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTFLUSH_FETB1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTFLUSH_FETB2(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x40000)|value<<18)
}
func (o *USB0_Type) GetENDPTFLUSH_FETB2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x40000) >> 18
}
func (o *USB0_Type) SetENDPTFLUSH_FETB3(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x80000)|value<<19)
}
func (o *USB0_Type) GetENDPTFLUSH_FETB3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x80000) >> 19
}
func (o *USB0_Type) SetENDPTFLUSH_FETB4(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTFLUSH_FETB4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTFLUSH_FETB5(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTFLUSH_FETB5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTFLUSH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0xffc00000)|value<<22)
}
func (o *USB0_Type) GetENDPTFLUSH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0xffc00000) >> 22
}

// USB0.ENDPTSTAT: Endpoint status
func (o *USB0_Type) SetENDPTSTAT_ERBR0(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTSTAT_ERBR0() uint32 {
	return volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTSTAT_ERBR1(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTSTAT_ERBR1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTSTAT_ERBR2(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPTSTAT_ERBR2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPTSTAT_ERBR3(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPTSTAT_ERBR3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPTSTAT_ERBR4(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTSTAT_ERBR4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTSTAT_ERBR5(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTSTAT_ERBR5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0xffc0)|value<<6)
}
func (o *USB0_Type) GetENDPTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0xffc0) >> 6
}
func (o *USB0_Type) SetENDPTSTAT_ETBR0(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTSTAT_ETBR0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTSTAT_ETBR1(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTSTAT_ETBR1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTSTAT_ETBR2(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x40000)|value<<18)
}
func (o *USB0_Type) GetENDPTSTAT_ETBR2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x40000) >> 18
}
func (o *USB0_Type) SetENDPTSTAT_ETBR3(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x80000)|value<<19)
}
func (o *USB0_Type) GetENDPTSTAT_ETBR3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x80000) >> 19
}
func (o *USB0_Type) SetENDPTSTAT_ETBR4(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTSTAT_ETBR4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTSTAT_ETBR5(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTSTAT_ETBR5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0xffc00000)|value<<22)
}
func (o *USB0_Type) GetENDPTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0xffc00000) >> 22
}

// USB0.ENDPTCOMPLETE: Endpoint complete
func (o *USB0_Type) SetENDPTCOMPLETE_ERCE0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ERCE0() uint32 {
	return volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTCOMPLETE_ERCE1(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ERCE1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTCOMPLETE_ERCE2(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x4)|value<<2)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ERCE2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x4) >> 2
}
func (o *USB0_Type) SetENDPTCOMPLETE_ERCE3(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x8)|value<<3)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ERCE3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x8) >> 3
}
func (o *USB0_Type) SetENDPTCOMPLETE_ERCE4(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ERCE4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTCOMPLETE_ERCE5(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ERCE5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTCOMPLETE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0xffc0)|value<<6)
}
func (o *USB0_Type) GetENDPTCOMPLETE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0xffc0) >> 6
}
func (o *USB0_Type) SetENDPTCOMPLETE_ETCE0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ETCE0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTCOMPLETE_ETCE1(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ETCE1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTCOMPLETE_ETCE2(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x40000)|value<<18)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ETCE2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x40000) >> 18
}
func (o *USB0_Type) SetENDPTCOMPLETE_ETCE3(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x80000)|value<<19)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ETCE3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x80000) >> 19
}
func (o *USB0_Type) SetENDPTCOMPLETE_ETCE4(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ETCE4() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTCOMPLETE_ETCE5(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTCOMPLETE_ETCE5() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTCOMPLETE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0xffc00000)|value<<22)
}
func (o *USB0_Type) GetENDPTCOMPLETE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0xffc00000) >> 22
}

// USB0.ENDPTCTRL0: Endpoint control 0
func (o *USB0_Type) SetENDPTCTRL0_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTCTRL0_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTCTRL0_RXT1_0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xc)|value<<2)
}
func (o *USB0_Type) GetENDPTCTRL0_RXT1_0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xc) >> 2
}
func (o *USB0_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x70)|value<<4)
}
func (o *USB0_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x70) >> 4
}
func (o *USB0_Type) SetENDPTCTRL0_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPTCTRL0_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xff00)|value<<8)
}
func (o *USB0_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xff00) >> 8
}
func (o *USB0_Type) SetENDPTCTRL0_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTCTRL0_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTCTRL0_TXT1_0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xc0000)|value<<18)
}
func (o *USB0_Type) GetENDPTCTRL0_TXT1_0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xc0000) >> 18
}
func (o *USB0_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x700000)|value<<20)
}
func (o *USB0_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x700000) >> 20
}
func (o *USB0_Type) SetENDPTCTRL0_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x800000)|value<<23)
}
func (o *USB0_Type) GetENDPTCTRL0_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x800000) >> 23
}
func (o *USB0_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xff000000)|value<<24)
}
func (o *USB0_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xff000000) >> 24
}

// USB0.ENDPTCTRL1: Endpoint control
func (o *USB0_Type) SetENDPTCTRL1_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTCTRL1_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTCTRL1_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xc)|value<<2)
}
func (o *USB0_Type) GetENDPTCTRL1_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xc) >> 2
}
func (o *USB0_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTCTRL1_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTCTRL1_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTCTRL1_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPTCTRL1_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPTCTRL1_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPTCTRL1_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xff00)|value<<8)
}
func (o *USB0_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xff00) >> 8
}
func (o *USB0_Type) SetENDPTCTRL1_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTCTRL1_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTCTRL1_TXT1_0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xc0000)|value<<18)
}
func (o *USB0_Type) GetENDPTCTRL1_TXT1_0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xc0000) >> 18
}
func (o *USB0_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTCTRL1_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTCTRL1_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTCTRL1_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *USB0_Type) GetENDPTCTRL1_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x400000) >> 22
}
func (o *USB0_Type) SetENDPTCTRL1_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *USB0_Type) GetENDPTCTRL1_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x800000) >> 23
}
func (o *USB0_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xff000000)|value<<24)
}
func (o *USB0_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xff000000) >> 24
}

// USB0.ENDPTCTRL2: Endpoint control
func (o *USB0_Type) SetENDPTCTRL2_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTCTRL2_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTCTRL2_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xc)|value<<2)
}
func (o *USB0_Type) GetENDPTCTRL2_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xc) >> 2
}
func (o *USB0_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTCTRL2_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTCTRL2_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTCTRL2_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPTCTRL2_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPTCTRL2_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPTCTRL2_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xff00)|value<<8)
}
func (o *USB0_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xff00) >> 8
}
func (o *USB0_Type) SetENDPTCTRL2_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTCTRL2_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTCTRL2_TXT1_0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xc0000)|value<<18)
}
func (o *USB0_Type) GetENDPTCTRL2_TXT1_0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xc0000) >> 18
}
func (o *USB0_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTCTRL2_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTCTRL2_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTCTRL2_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x400000)|value<<22)
}
func (o *USB0_Type) GetENDPTCTRL2_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x400000) >> 22
}
func (o *USB0_Type) SetENDPTCTRL2_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x800000)|value<<23)
}
func (o *USB0_Type) GetENDPTCTRL2_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x800000) >> 23
}
func (o *USB0_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xff000000)|value<<24)
}
func (o *USB0_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xff000000) >> 24
}

// USB0.ENDPTCTRL3: Endpoint control
func (o *USB0_Type) SetENDPTCTRL3_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTCTRL3_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTCTRL3_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xc)|value<<2)
}
func (o *USB0_Type) GetENDPTCTRL3_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xc) >> 2
}
func (o *USB0_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTCTRL3_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTCTRL3_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTCTRL3_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPTCTRL3_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPTCTRL3_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPTCTRL3_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xff00)|value<<8)
}
func (o *USB0_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xff00) >> 8
}
func (o *USB0_Type) SetENDPTCTRL3_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTCTRL3_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTCTRL3_TXT1_0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xc0000)|value<<18)
}
func (o *USB0_Type) GetENDPTCTRL3_TXT1_0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xc0000) >> 18
}
func (o *USB0_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTCTRL3_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTCTRL3_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTCTRL3_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x400000)|value<<22)
}
func (o *USB0_Type) GetENDPTCTRL3_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x400000) >> 22
}
func (o *USB0_Type) SetENDPTCTRL3_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x800000)|value<<23)
}
func (o *USB0_Type) GetENDPTCTRL3_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x800000) >> 23
}
func (o *USB0_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xff000000)|value<<24)
}
func (o *USB0_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xff000000) >> 24
}

// USB0.ENDPTCTRL4: Endpoint control
func (o *USB0_Type) SetENDPTCTRL4_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTCTRL4_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTCTRL4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTCTRL4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTCTRL4_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0xc)|value<<2)
}
func (o *USB0_Type) GetENDPTCTRL4_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0xc) >> 2
}
func (o *USB0_Type) SetENDPTCTRL4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTCTRL4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTCTRL4_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTCTRL4_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTCTRL4_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPTCTRL4_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPTCTRL4_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPTCTRL4_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetENDPTCTRL4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0xff00)|value<<8)
}
func (o *USB0_Type) GetENDPTCTRL4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0xff00) >> 8
}
func (o *USB0_Type) SetENDPTCTRL4_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTCTRL4_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTCTRL4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTCTRL4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTCTRL4_TXT1_0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0xc0000)|value<<18)
}
func (o *USB0_Type) GetENDPTCTRL4_TXT1_0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0xc0000) >> 18
}
func (o *USB0_Type) SetENDPTCTRL4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTCTRL4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTCTRL4_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTCTRL4_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTCTRL4_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x400000)|value<<22)
}
func (o *USB0_Type) GetENDPTCTRL4_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x400000) >> 22
}
func (o *USB0_Type) SetENDPTCTRL4_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x800000)|value<<23)
}
func (o *USB0_Type) GetENDPTCTRL4_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x800000) >> 23
}
func (o *USB0_Type) SetENDPTCTRL4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0xff000000)|value<<24)
}
func (o *USB0_Type) GetENDPTCTRL4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0xff000000) >> 24
}

// USB0.ENDPTCTRL5: Endpoint control
func (o *USB0_Type) SetENDPTCTRL5_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x1)|value)
}
func (o *USB0_Type) GetENDPTCTRL5_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x1
}
func (o *USB0_Type) SetENDPTCTRL5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x2)|value<<1)
}
func (o *USB0_Type) GetENDPTCTRL5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x2) >> 1
}
func (o *USB0_Type) SetENDPTCTRL5_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0xc)|value<<2)
}
func (o *USB0_Type) GetENDPTCTRL5_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0xc) >> 2
}
func (o *USB0_Type) SetENDPTCTRL5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x10)|value<<4)
}
func (o *USB0_Type) GetENDPTCTRL5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x10) >> 4
}
func (o *USB0_Type) SetENDPTCTRL5_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x20)|value<<5)
}
func (o *USB0_Type) GetENDPTCTRL5_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x20) >> 5
}
func (o *USB0_Type) SetENDPTCTRL5_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x40)|value<<6)
}
func (o *USB0_Type) GetENDPTCTRL5_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x40) >> 6
}
func (o *USB0_Type) SetENDPTCTRL5_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x80)|value<<7)
}
func (o *USB0_Type) GetENDPTCTRL5_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x80) >> 7
}
func (o *USB0_Type) SetENDPTCTRL5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0xff00)|value<<8)
}
func (o *USB0_Type) GetENDPTCTRL5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0xff00) >> 8
}
func (o *USB0_Type) SetENDPTCTRL5_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x10000)|value<<16)
}
func (o *USB0_Type) GetENDPTCTRL5_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x10000) >> 16
}
func (o *USB0_Type) SetENDPTCTRL5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x20000)|value<<17)
}
func (o *USB0_Type) GetENDPTCTRL5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x20000) >> 17
}
func (o *USB0_Type) SetENDPTCTRL5_TXT1_0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0xc0000)|value<<18)
}
func (o *USB0_Type) GetENDPTCTRL5_TXT1_0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0xc0000) >> 18
}
func (o *USB0_Type) SetENDPTCTRL5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x100000)|value<<20)
}
func (o *USB0_Type) GetENDPTCTRL5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x100000) >> 20
}
func (o *USB0_Type) SetENDPTCTRL5_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x200000)|value<<21)
}
func (o *USB0_Type) GetENDPTCTRL5_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x200000) >> 21
}
func (o *USB0_Type) SetENDPTCTRL5_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x400000)|value<<22)
}
func (o *USB0_Type) GetENDPTCTRL5_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x400000) >> 22
}
func (o *USB0_Type) SetENDPTCTRL5_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x800000)|value<<23)
}
func (o *USB0_Type) GetENDPTCTRL5_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x800000) >> 23
}
func (o *USB0_Type) SetENDPTCTRL5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0xff000000)|value<<24)
}
func (o *USB0_Type) GetENDPTCTRL5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0xff000000) >> 24
}

// USB1 Host/Device controller
type USB1_Type struct {
	_                [256]byte
	CAPLENGTH        volatile.Register32 // 0x100
	HCSPARAMS        volatile.Register32 // 0x104
	HCCPARAMS        volatile.Register32 // 0x108
	_                [20]byte
	DCIVERSION       volatile.Register32 // 0x120
	_                [28]byte
	USBCMD_D         volatile.Register32 // 0x140
	USBSTS_D         volatile.Register32 // 0x144
	USBINTR_D        volatile.Register32 // 0x148
	FRINDEX_D        volatile.Register32 // 0x14C
	_                [4]byte
	DEVICEADDR       volatile.Register32 // 0x154
	ENDPOINTLISTADDR volatile.Register32 // 0x158
	TTCTRL           volatile.Register32 // 0x15C
	BURSTSIZE        volatile.Register32 // 0x160
	TXFILLTUNING     volatile.Register32 // 0x164
	_                [8]byte
	ULPIVIEWPORT     volatile.Register32 // 0x170
	BINTERVAL        volatile.Register32 // 0x174
	ENDPTNAK         volatile.Register32 // 0x178
	ENDPTNAKEN       volatile.Register32 // 0x17C
	_                [4]byte
	PORTSC1_D        volatile.Register32 // 0x184
	_                [32]byte
	USBMODE_D        volatile.Register32 // 0x1A8
	ENDPTSETUPSTAT   volatile.Register32 // 0x1AC
	ENDPTPRIME       volatile.Register32 // 0x1B0
	ENDPTFLUSH       volatile.Register32 // 0x1B4
	ENDPTSTAT        volatile.Register32 // 0x1B8
	ENDPTCOMPLETE    volatile.Register32 // 0x1BC
	ENDPTCTRL0       volatile.Register32 // 0x1C0
	ENDPTCTRL1       volatile.Register32 // 0x1C4
	ENDPTCTRL2       volatile.Register32 // 0x1C8
	ENDPTCTRL3       volatile.Register32 // 0x1CC
}

// USB1.CAPLENGTH: Capability register length
func (o *USB1_Type) SetCAPLENGTH(value uint32) {
	volatile.StoreUint32(&o.CAPLENGTH.Reg, volatile.LoadUint32(&o.CAPLENGTH.Reg)&^(0xff)|value)
}
func (o *USB1_Type) GetCAPLENGTH() uint32 {
	return volatile.LoadUint32(&o.CAPLENGTH.Reg) & 0xff
}
func (o *USB1_Type) SetCAPLENGTH_HCIVERSION(value uint32) {
	volatile.StoreUint32(&o.CAPLENGTH.Reg, volatile.LoadUint32(&o.CAPLENGTH.Reg)&^(0xffff00)|value<<8)
}
func (o *USB1_Type) GetCAPLENGTH_HCIVERSION() uint32 {
	return (volatile.LoadUint32(&o.CAPLENGTH.Reg) & 0xffff00) >> 8
}
func (o *USB1_Type) SetCAPLENGTH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAPLENGTH.Reg, volatile.LoadUint32(&o.CAPLENGTH.Reg)&^(0xff000000)|value<<24)
}
func (o *USB1_Type) GetCAPLENGTH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAPLENGTH.Reg) & 0xff000000) >> 24
}

// USB1.HCSPARAMS: Host controller structural parameters
func (o *USB1_Type) SetHCSPARAMS_N_PORTS(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf)|value)
}
func (o *USB1_Type) GetHCSPARAMS_N_PORTS() uint32 {
	return volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf
}
func (o *USB1_Type) SetHCSPARAMS_PPC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0x10)|value<<4)
}
func (o *USB1_Type) GetHCSPARAMS_PPC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0x10) >> 4
}
func (o *USB1_Type) SetHCSPARAMS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xe0)|value<<5)
}
func (o *USB1_Type) GetHCSPARAMS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xe0) >> 5
}
func (o *USB1_Type) SetHCSPARAMS_N_PCC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf00)|value<<8)
}
func (o *USB1_Type) GetHCSPARAMS_N_PCC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf00) >> 8
}
func (o *USB1_Type) SetHCSPARAMS_N_CC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf000)|value<<12)
}
func (o *USB1_Type) GetHCSPARAMS_N_CC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf000) >> 12
}
func (o *USB1_Type) SetHCSPARAMS_PI(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetHCSPARAMS_PI() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetHCSPARAMS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xe0000)|value<<17)
}
func (o *USB1_Type) GetHCSPARAMS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xe0000) >> 17
}
func (o *USB1_Type) SetHCSPARAMS_N_PTT(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf00000)|value<<20)
}
func (o *USB1_Type) GetHCSPARAMS_N_PTT() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf00000) >> 20
}
func (o *USB1_Type) SetHCSPARAMS_N_TT(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf000000)|value<<24)
}
func (o *USB1_Type) GetHCSPARAMS_N_TT() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf000000) >> 24
}
func (o *USB1_Type) SetHCSPARAMS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf0000000)|value<<28)
}
func (o *USB1_Type) GetHCSPARAMS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf0000000) >> 28
}

// USB1.HCCPARAMS: Host controller capability parameters
func (o *USB1_Type) SetHCCPARAMS_ADC(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetHCCPARAMS_ADC() uint32 {
	return volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x1
}
func (o *USB1_Type) SetHCCPARAMS_PFL(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetHCCPARAMS_PFL() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetHCCPARAMS_ASP(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetHCCPARAMS_ASP() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetHCCPARAMS_IST(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xf0)|value<<4)
}
func (o *USB1_Type) GetHCCPARAMS_IST() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xf0) >> 4
}
func (o *USB1_Type) SetHCCPARAMS_EECP(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xff00)|value<<8)
}
func (o *USB1_Type) GetHCCPARAMS_EECP() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xff00) >> 8
}
func (o *USB1_Type) SetHCCPARAMS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB1_Type) GetHCCPARAMS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xffff0000) >> 16
}

// USB1.DCIVERSION: Device interface version number
func (o *USB1_Type) SetDCIVERSION(value uint32) {
	volatile.StoreUint32(&o.DCIVERSION.Reg, volatile.LoadUint32(&o.DCIVERSION.Reg)&^(0xffff)|value)
}
func (o *USB1_Type) GetDCIVERSION() uint32 {
	return volatile.LoadUint32(&o.DCIVERSION.Reg) & 0xffff
}
func (o *USB1_Type) SetDCIVERSION_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DCIVERSION.Reg, volatile.LoadUint32(&o.DCIVERSION.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB1_Type) GetDCIVERSION_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DCIVERSION.Reg) & 0xffff0000) >> 16
}

// USB1.USBCMD_D: USB command (device mode)
func (o *USB1_Type) SetUSBCMD_D_RS(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetUSBCMD_D_RS() uint32 {
	return volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x1
}
func (o *USB1_Type) SetUSBCMD_D_RST(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetUSBCMD_D_RST() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0xc)|value<<2)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0xc) >> 2
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x10)|value<<4)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x10) >> 4
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x20)|value<<5)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x20) >> 5
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x40)|value<<6)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x40) >> 6
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x80)|value<<7)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x80) >> 7
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x300)|value<<8)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x300) >> 8
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x400)|value<<10)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x400) >> 10
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x800)|value<<11)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x800) >> 11
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x1000)|value<<12)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x1000) >> 12
}
func (o *USB1_Type) SetUSBCMD_D_SUTW(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x2000)|value<<13)
}
func (o *USB1_Type) GetUSBCMD_D_SUTW() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x2000) >> 13
}
func (o *USB1_Type) SetUSBCMD_D_ATDTW(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x4000)|value<<14)
}
func (o *USB1_Type) GetUSBCMD_D_ATDTW() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x4000) >> 14
}
func (o *USB1_Type) SetUSBCMD_D_FS2(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0x8000)|value<<15)
}
func (o *USB1_Type) GetUSBCMD_D_FS2() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0x8000) >> 15
}
func (o *USB1_Type) SetUSBCMD_D_ITC(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0xff0000)|value<<16)
}
func (o *USB1_Type) GetUSBCMD_D_ITC() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0xff0000) >> 16
}
func (o *USB1_Type) SetUSBCMD_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCMD_D.Reg, volatile.LoadUint32(&o.USBCMD_D.Reg)&^(0xff000000)|value<<24)
}
func (o *USB1_Type) GetUSBCMD_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCMD_D.Reg) & 0xff000000) >> 24
}

// USB1.USBSTS_D: USB status (device mode)
func (o *USB1_Type) SetUSBSTS_D_UI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetUSBSTS_D_UI() uint32 {
	return volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x1
}
func (o *USB1_Type) SetUSBSTS_D_UEI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetUSBSTS_D_UEI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetUSBSTS_D_PCI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetUSBSTS_D_PCI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x10)|value<<4)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x10) >> 4
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x20)|value<<5)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x20) >> 5
}
func (o *USB1_Type) SetUSBSTS_D_URI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x40)|value<<6)
}
func (o *USB1_Type) GetUSBSTS_D_URI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x40) >> 6
}
func (o *USB1_Type) SetUSBSTS_D_SRI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x80)|value<<7)
}
func (o *USB1_Type) GetUSBSTS_D_SRI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x80) >> 7
}
func (o *USB1_Type) SetUSBSTS_D_SLI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x100)|value<<8)
}
func (o *USB1_Type) GetUSBSTS_D_SLI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x100) >> 8
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0xe00)|value<<9)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0xe00) >> 9
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x1000)|value<<12)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x1000) >> 12
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x2000)|value<<13)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x2000) >> 13
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x4000)|value<<14)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x4000) >> 14
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x8000)|value<<15)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x8000) >> 15
}
func (o *USB1_Type) SetUSBSTS_D_NAKI(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetUSBSTS_D_NAKI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x40000)|value<<18)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x40000) >> 18
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0x80000)|value<<19)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0x80000) >> 19
}
func (o *USB1_Type) SetUSBSTS_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBSTS_D.Reg, volatile.LoadUint32(&o.USBSTS_D.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB1_Type) GetUSBSTS_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBSTS_D.Reg) & 0xfff00000) >> 20
}

// USB1.USBINTR_D: USB interrupt enable (device mode)
func (o *USB1_Type) SetUSBINTR_D_UE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetUSBINTR_D_UE() uint32 {
	return volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x1
}
func (o *USB1_Type) SetUSBINTR_D_UEE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetUSBINTR_D_UEE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetUSBINTR_D_PCE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetUSBINTR_D_PCE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x10)|value<<4)
}
func (o *USB1_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x10) >> 4
}
func (o *USB1_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x20)|value<<5)
}
func (o *USB1_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x20) >> 5
}
func (o *USB1_Type) SetUSBINTR_D_URE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x40)|value<<6)
}
func (o *USB1_Type) GetUSBINTR_D_URE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x40) >> 6
}
func (o *USB1_Type) SetUSBINTR_D_SRE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x80)|value<<7)
}
func (o *USB1_Type) GetUSBINTR_D_SRE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x80) >> 7
}
func (o *USB1_Type) SetUSBINTR_D_SLE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x100)|value<<8)
}
func (o *USB1_Type) GetUSBINTR_D_SLE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x100) >> 8
}
func (o *USB1_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0xfe00)|value<<9)
}
func (o *USB1_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0xfe00) >> 9
}
func (o *USB1_Type) SetUSBINTR_D_NAKE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetUSBINTR_D_NAKE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetUSBINTR_D_UAIE(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x40000)|value<<18)
}
func (o *USB1_Type) GetUSBINTR_D_UAIE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x40000) >> 18
}
func (o *USB1_Type) SetUSBINTR_D_UPIA(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0x80000)|value<<19)
}
func (o *USB1_Type) GetUSBINTR_D_UPIA() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0x80000) >> 19
}
func (o *USB1_Type) SetUSBINTR_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTR_D.Reg, volatile.LoadUint32(&o.USBINTR_D.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB1_Type) GetUSBINTR_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTR_D.Reg) & 0xfff00000) >> 20
}

// USB1.FRINDEX_D: USB frame index (device mode)
func (o *USB1_Type) SetFRINDEX_D_FRINDEX2_0(value uint32) {
	volatile.StoreUint32(&o.FRINDEX_D.Reg, volatile.LoadUint32(&o.FRINDEX_D.Reg)&^(0x7)|value)
}
func (o *USB1_Type) GetFRINDEX_D_FRINDEX2_0() uint32 {
	return volatile.LoadUint32(&o.FRINDEX_D.Reg) & 0x7
}
func (o *USB1_Type) SetFRINDEX_D_FRINDEX13_3(value uint32) {
	volatile.StoreUint32(&o.FRINDEX_D.Reg, volatile.LoadUint32(&o.FRINDEX_D.Reg)&^(0x3ff8)|value<<3)
}
func (o *USB1_Type) GetFRINDEX_D_FRINDEX13_3() uint32 {
	return (volatile.LoadUint32(&o.FRINDEX_D.Reg) & 0x3ff8) >> 3
}
func (o *USB1_Type) SetFRINDEX_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FRINDEX_D.Reg, volatile.LoadUint32(&o.FRINDEX_D.Reg)&^(0xffffc000)|value<<14)
}
func (o *USB1_Type) GetFRINDEX_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FRINDEX_D.Reg) & 0xffffc000) >> 14
}

// USB1.DEVICEADDR: USB device address
func (o *USB1_Type) SetDEVICEADDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0xffffff)|value)
}
func (o *USB1_Type) GetDEVICEADDR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0xffffff
}
func (o *USB1_Type) SetDEVICEADDR_USBADRA(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0x1000000)|value<<24)
}
func (o *USB1_Type) GetDEVICEADDR_USBADRA() uint32 {
	return (volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0x1000000) >> 24
}
func (o *USB1_Type) SetDEVICEADDR_USBADR(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0xfe000000)|value<<25)
}
func (o *USB1_Type) GetDEVICEADDR_USBADR() uint32 {
	return (volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0xfe000000) >> 25
}

// USB1.ENDPOINTLISTADDR: Address of endpoint list in memory (device mode)
func (o *USB1_Type) SetENDPOINTLISTADDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPOINTLISTADDR.Reg, volatile.LoadUint32(&o.ENDPOINTLISTADDR.Reg)&^(0x7ff)|value)
}
func (o *USB1_Type) GetENDPOINTLISTADDR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.ENDPOINTLISTADDR.Reg) & 0x7ff
}
func (o *USB1_Type) SetENDPOINTLISTADDR_EPBASE31_11(value uint32) {
	volatile.StoreUint32(&o.ENDPOINTLISTADDR.Reg, volatile.LoadUint32(&o.ENDPOINTLISTADDR.Reg)&^(0xfffff800)|value<<11)
}
func (o *USB1_Type) GetENDPOINTLISTADDR_EPBASE31_11() uint32 {
	return (volatile.LoadUint32(&o.ENDPOINTLISTADDR.Reg) & 0xfffff800) >> 11
}

// USB1.TTCTRL: Asynchronous buffer status for embedded TT (host mode)
func (o *USB1_Type) SetTTCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TTCTRL.Reg, volatile.LoadUint32(&o.TTCTRL.Reg)&^(0xffffff)|value)
}
func (o *USB1_Type) GetTTCTRL_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TTCTRL.Reg) & 0xffffff
}
func (o *USB1_Type) SetTTCTRL_TTHA(value uint32) {
	volatile.StoreUint32(&o.TTCTRL.Reg, volatile.LoadUint32(&o.TTCTRL.Reg)&^(0x7f000000)|value<<24)
}
func (o *USB1_Type) GetTTCTRL_TTHA() uint32 {
	return (volatile.LoadUint32(&o.TTCTRL.Reg) & 0x7f000000) >> 24
}
func (o *USB1_Type) SetTTCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TTCTRL.Reg, volatile.LoadUint32(&o.TTCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USB1_Type) GetTTCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TTCTRL.Reg) & 0x80000000) >> 31
}

// USB1.BURSTSIZE: Programmable burst size
func (o *USB1_Type) SetBURSTSIZE_RXPBURST(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0xff)|value)
}
func (o *USB1_Type) GetBURSTSIZE_RXPBURST() uint32 {
	return volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0xff
}
func (o *USB1_Type) SetBURSTSIZE_TXPBURST(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0xff00)|value<<8)
}
func (o *USB1_Type) GetBURSTSIZE_TXPBURST() uint32 {
	return (volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0xff00) >> 8
}
func (o *USB1_Type) SetBURSTSIZE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB1_Type) GetBURSTSIZE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0xffff0000) >> 16
}

// USB1.TXFILLTUNING: Host transmit pre-buffer packet tuning (host mode)
func (o *USB1_Type) SetTXFILLTUNING_TXSCHOH(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0xff)|value)
}
func (o *USB1_Type) GetTXFILLTUNING_TXSCHOH() uint32 {
	return volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0xff
}
func (o *USB1_Type) SetTXFILLTUNING_TXSCHEATLTH(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0x1f00)|value<<8)
}
func (o *USB1_Type) GetTXFILLTUNING_TXSCHEATLTH() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0x1f00) >> 8
}
func (o *USB1_Type) SetTXFILLTUNING_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0xe000)|value<<13)
}
func (o *USB1_Type) GetTXFILLTUNING_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0xe000) >> 13
}
func (o *USB1_Type) SetTXFILLTUNING_TXFIFOTHRES(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0x3f0000)|value<<16)
}
func (o *USB1_Type) GetTXFILLTUNING_TXFIFOTHRES() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0x3f0000) >> 16
}
func (o *USB1_Type) SetTXFILLTUNING_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0xffc00000)|value<<22)
}
func (o *USB1_Type) GetTXFILLTUNING_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0xffc00000) >> 22
}

// USB1.ULPIVIEWPORT: ULPI viewport
func (o *USB1_Type) SetULPIVIEWPORT_ULPIDATWR(value uint32) {
	volatile.StoreUint32(&o.ULPIVIEWPORT.Reg, volatile.LoadUint32(&o.ULPIVIEWPORT.Reg)&^(0xff)|value)
}
func (o *USB1_Type) GetULPIVIEWPORT_ULPIDATWR() uint32 {
	return volatile.LoadUint32(&o.ULPIVIEWPORT.Reg) & 0xff
}
func (o *USB1_Type) SetULPIVIEWPORT_ULPIDATRD(value uint32) {
	volatile.StoreUint32(&o.ULPIVIEWPORT.Reg, volatile.LoadUint32(&o.ULPIVIEWPORT.Reg)&^(0xff00)|value<<8)
}
func (o *USB1_Type) GetULPIVIEWPORT_ULPIDATRD() uint32 {
	return (volatile.LoadUint32(&o.ULPIVIEWPORT.Reg) & 0xff00) >> 8
}
func (o *USB1_Type) SetULPIVIEWPORT_ULPIADDR(value uint32) {
	volatile.StoreUint32(&o.ULPIVIEWPORT.Reg, volatile.LoadUint32(&o.ULPIVIEWPORT.Reg)&^(0xff0000)|value<<16)
}
func (o *USB1_Type) GetULPIVIEWPORT_ULPIADDR() uint32 {
	return (volatile.LoadUint32(&o.ULPIVIEWPORT.Reg) & 0xff0000) >> 16
}
func (o *USB1_Type) SetULPIVIEWPORT_ULPIPORT(value uint32) {
	volatile.StoreUint32(&o.ULPIVIEWPORT.Reg, volatile.LoadUint32(&o.ULPIVIEWPORT.Reg)&^(0x7000000)|value<<24)
}
func (o *USB1_Type) GetULPIVIEWPORT_ULPIPORT() uint32 {
	return (volatile.LoadUint32(&o.ULPIVIEWPORT.Reg) & 0x7000000) >> 24
}
func (o *USB1_Type) SetULPIVIEWPORT_ULPISS(value uint32) {
	volatile.StoreUint32(&o.ULPIVIEWPORT.Reg, volatile.LoadUint32(&o.ULPIVIEWPORT.Reg)&^(0x8000000)|value<<27)
}
func (o *USB1_Type) GetULPIVIEWPORT_ULPISS() uint32 {
	return (volatile.LoadUint32(&o.ULPIVIEWPORT.Reg) & 0x8000000) >> 27
}
func (o *USB1_Type) SetULPIVIEWPORT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ULPIVIEWPORT.Reg, volatile.LoadUint32(&o.ULPIVIEWPORT.Reg)&^(0x10000000)|value<<28)
}
func (o *USB1_Type) GetULPIVIEWPORT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ULPIVIEWPORT.Reg) & 0x10000000) >> 28
}
func (o *USB1_Type) SetULPIVIEWPORT_ULPIRW(value uint32) {
	volatile.StoreUint32(&o.ULPIVIEWPORT.Reg, volatile.LoadUint32(&o.ULPIVIEWPORT.Reg)&^(0x20000000)|value<<29)
}
func (o *USB1_Type) GetULPIVIEWPORT_ULPIRW() uint32 {
	return (volatile.LoadUint32(&o.ULPIVIEWPORT.Reg) & 0x20000000) >> 29
}
func (o *USB1_Type) SetULPIVIEWPORT_ULPIRUN(value uint32) {
	volatile.StoreUint32(&o.ULPIVIEWPORT.Reg, volatile.LoadUint32(&o.ULPIVIEWPORT.Reg)&^(0x40000000)|value<<30)
}
func (o *USB1_Type) GetULPIVIEWPORT_ULPIRUN() uint32 {
	return (volatile.LoadUint32(&o.ULPIVIEWPORT.Reg) & 0x40000000) >> 30
}
func (o *USB1_Type) SetULPIVIEWPORT_ULPIWU(value uint32) {
	volatile.StoreUint32(&o.ULPIVIEWPORT.Reg, volatile.LoadUint32(&o.ULPIVIEWPORT.Reg)&^(0x80000000)|value<<31)
}
func (o *USB1_Type) GetULPIVIEWPORT_ULPIWU() uint32 {
	return (volatile.LoadUint32(&o.ULPIVIEWPORT.Reg) & 0x80000000) >> 31
}

// USB1.BINTERVAL: Length of virtual frame
func (o *USB1_Type) SetBINTERVAL_BINT(value uint32) {
	volatile.StoreUint32(&o.BINTERVAL.Reg, volatile.LoadUint32(&o.BINTERVAL.Reg)&^(0xf)|value)
}
func (o *USB1_Type) GetBINTERVAL_BINT() uint32 {
	return volatile.LoadUint32(&o.BINTERVAL.Reg) & 0xf
}
func (o *USB1_Type) SetBINTERVAL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BINTERVAL.Reg, volatile.LoadUint32(&o.BINTERVAL.Reg)&^(0xfffffff0)|value<<4)
}
func (o *USB1_Type) GetBINTERVAL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BINTERVAL.Reg) & 0xfffffff0) >> 4
}

// USB1.ENDPTNAK: Endpoint NAK (device mode)
func (o *USB1_Type) SetENDPTNAK_EPRN0(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTNAK_EPRN0() uint32 {
	return volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTNAK_EPRN1(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTNAK_EPRN1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTNAK_EPRN2(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetENDPTNAK_EPRN2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetENDPTNAK_EPRN3(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetENDPTNAK_EPRN3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetENDPTNAK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0xfff0)|value<<4)
}
func (o *USB1_Type) GetENDPTNAK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0xfff0) >> 4
}
func (o *USB1_Type) SetENDPTNAK_EPTN16(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTNAK_EPTN16() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTNAK_EPTN17(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTNAK_EPTN17() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTNAK_EPTN18(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x40000)|value<<18)
}
func (o *USB1_Type) GetENDPTNAK_EPTN18() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x40000) >> 18
}
func (o *USB1_Type) SetENDPTNAK_EPTN19(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0x80000)|value<<19)
}
func (o *USB1_Type) GetENDPTNAK_EPTN19() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0x80000) >> 19
}
func (o *USB1_Type) SetENDPTNAK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB1_Type) GetENDPTNAK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0xfff00000) >> 20
}

// USB1.ENDPTNAKEN: Endpoint NAK Enable (device mode)
func (o *USB1_Type) SetENDPTNAKEN_EPRNE0(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTNAKEN_EPRNE0() uint32 {
	return volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTNAKEN_EPRNE1(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTNAKEN_EPRNE1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTNAKEN_EPRNE2(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetENDPTNAKEN_EPRNE2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetENDPTNAKEN_EPRNE3(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetENDPTNAKEN_EPRNE3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetENDPTNAKEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0xfff0)|value<<4)
}
func (o *USB1_Type) GetENDPTNAKEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0xfff0) >> 4
}
func (o *USB1_Type) SetENDPTNAKEN_EPTNE16(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTNAKEN_EPTNE16() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTNAKEN_EPTNE17(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTNAKEN_EPTNE17() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTNAKEN_EPTNE18(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x40000)|value<<18)
}
func (o *USB1_Type) GetENDPTNAKEN_EPTNE18() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x40000) >> 18
}
func (o *USB1_Type) SetENDPTNAKEN_EPTNE19(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0x80000)|value<<19)
}
func (o *USB1_Type) GetENDPTNAKEN_EPTNE19() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0x80000) >> 19
}
func (o *USB1_Type) SetENDPTNAKEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB1_Type) GetENDPTNAKEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0xfff00000) >> 20
}

// USB1.PORTSC1_D: Port 1 status/control (device mode)
func (o *USB1_Type) SetPORTSC1_D_CCS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetPORTSC1_D_CCS() uint32 {
	return volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x1
}
func (o *USB1_Type) SetPORTSC1_D_CSC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetPORTSC1_D_CSC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetPORTSC1_D_PE(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetPORTSC1_D_PE() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetPORTSC1_D_PEC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetPORTSC1_D_PEC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x30)|value<<4)
}
func (o *USB1_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x30) >> 4
}
func (o *USB1_Type) SetPORTSC1_D_FPR(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x40)|value<<6)
}
func (o *USB1_Type) GetPORTSC1_D_FPR() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x40) >> 6
}
func (o *USB1_Type) SetPORTSC1_D_SUSP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x80)|value<<7)
}
func (o *USB1_Type) GetPORTSC1_D_SUSP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x80) >> 7
}
func (o *USB1_Type) SetPORTSC1_D_PR(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x100)|value<<8)
}
func (o *USB1_Type) GetPORTSC1_D_PR() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x100) >> 8
}
func (o *USB1_Type) SetPORTSC1_D_HSP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x200)|value<<9)
}
func (o *USB1_Type) GetPORTSC1_D_HSP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x200) >> 9
}
func (o *USB1_Type) SetPORTSC1_D_LS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xc00)|value<<10)
}
func (o *USB1_Type) GetPORTSC1_D_LS() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xc00) >> 10
}
func (o *USB1_Type) SetPORTSC1_D_PP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x1000)|value<<12)
}
func (o *USB1_Type) GetPORTSC1_D_PP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x1000) >> 12
}
func (o *USB1_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x2000)|value<<13)
}
func (o *USB1_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x2000) >> 13
}
func (o *USB1_Type) SetPORTSC1_D_PIC1_0(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xc000)|value<<14)
}
func (o *USB1_Type) GetPORTSC1_D_PIC1_0() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xc000) >> 14
}
func (o *USB1_Type) SetPORTSC1_D_PTC3_0(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xf0000)|value<<16)
}
func (o *USB1_Type) GetPORTSC1_D_PTC3_0() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xf0000) >> 16
}
func (o *USB1_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x100000)|value<<20)
}
func (o *USB1_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x100000) >> 20
}
func (o *USB1_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x200000)|value<<21)
}
func (o *USB1_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x200000) >> 21
}
func (o *USB1_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x400000)|value<<22)
}
func (o *USB1_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x400000) >> 22
}
func (o *USB1_Type) SetPORTSC1_D_PHCD(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x800000)|value<<23)
}
func (o *USB1_Type) GetPORTSC1_D_PHCD() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x800000) >> 23
}
func (o *USB1_Type) SetPORTSC1_D_PFSC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x1000000)|value<<24)
}
func (o *USB1_Type) GetPORTSC1_D_PFSC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x1000000) >> 24
}
func (o *USB1_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x2000000)|value<<25)
}
func (o *USB1_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x2000000) >> 25
}
func (o *USB1_Type) SetPORTSC1_D_PSPD(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xc000000)|value<<26)
}
func (o *USB1_Type) GetPORTSC1_D_PSPD() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xc000000) >> 26
}
func (o *USB1_Type) SetPORTSC1_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0x30000000)|value<<28)
}
func (o *USB1_Type) GetPORTSC1_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0x30000000) >> 28
}
func (o *USB1_Type) SetPORTSC1_D_PTS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1_D.Reg, volatile.LoadUint32(&o.PORTSC1_D.Reg)&^(0xc0000000)|value<<30)
}
func (o *USB1_Type) GetPORTSC1_D_PTS() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1_D.Reg) & 0xc0000000) >> 30
}

// USB1.USBMODE_D: USB mode (device mode)
func (o *USB1_Type) SetUSBMODE_D_CM1_0(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x3)|value)
}
func (o *USB1_Type) GetUSBMODE_D_CM1_0() uint32 {
	return volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x3
}
func (o *USB1_Type) SetUSBMODE_D_ES(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetUSBMODE_D_ES() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetUSBMODE_D_SLOM(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetUSBMODE_D_SLOM() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetUSBMODE_D_SDIS(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x10)|value<<4)
}
func (o *USB1_Type) GetUSBMODE_D_SDIS() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x10) >> 4
}
func (o *USB1_Type) SetUSBMODE_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0x20)|value<<5)
}
func (o *USB1_Type) GetUSBMODE_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0x20) >> 5
}
func (o *USB1_Type) SetUSBMODE_D_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBMODE_D.Reg, volatile.LoadUint32(&o.USBMODE_D.Reg)&^(0xffffffc0)|value<<6)
}
func (o *USB1_Type) GetUSBMODE_D_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBMODE_D.Reg) & 0xffffffc0) >> 6
}

// USB1.ENDPTSETUPSTAT: Endpoint setup status
func (o *USB1_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT0(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT0() uint32 {
	return volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT1(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT2(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetENDPTSETUPSTAT_ENDPTSETUPSTAT3(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetENDPTSETUPSTAT_ENDPTSETUPSTAT3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetENDPTSETUPSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0xfffffff0)|value<<4)
}
func (o *USB1_Type) GetENDPTSETUPSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0xfffffff0) >> 4
}

// USB1.ENDPTPRIME: Endpoint initialization
func (o *USB1_Type) SetENDPTPRIME_PERB0(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTPRIME_PERB0() uint32 {
	return volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTPRIME_PERB1(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTPRIME_PERB1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTPRIME_PERB2(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetENDPTPRIME_PERB2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetENDPTPRIME_PERB3(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetENDPTPRIME_PERB3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetENDPTPRIME_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0xfff0)|value<<4)
}
func (o *USB1_Type) GetENDPTPRIME_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0xfff0) >> 4
}
func (o *USB1_Type) SetENDPTPRIME_PETB0(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTPRIME_PETB0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTPRIME_PETB1(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTPRIME_PETB1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTPRIME_PETB2(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x40000)|value<<18)
}
func (o *USB1_Type) GetENDPTPRIME_PETB2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x40000) >> 18
}
func (o *USB1_Type) SetENDPTPRIME_PETB3(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0x80000)|value<<19)
}
func (o *USB1_Type) GetENDPTPRIME_PETB3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0x80000) >> 19
}
func (o *USB1_Type) SetENDPTPRIME_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB1_Type) GetENDPTPRIME_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0xfff00000) >> 20
}

// USB1.ENDPTFLUSH: Endpoint de-initialization
func (o *USB1_Type) SetENDPTFLUSH_FERB0(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTFLUSH_FERB0() uint32 {
	return volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTFLUSH_FERB1(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTFLUSH_FERB1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTFLUSH_FERB2(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetENDPTFLUSH_FERB2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetENDPTFLUSH_FERB3(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetENDPTFLUSH_FERB3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetENDPTFLUSH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0xfff0)|value<<4)
}
func (o *USB1_Type) GetENDPTFLUSH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0xfff0) >> 4
}
func (o *USB1_Type) SetENDPTFLUSH_FETB0(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTFLUSH_FETB0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTFLUSH_FETB1(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTFLUSH_FETB1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTFLUSH_FETB2(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x40000)|value<<18)
}
func (o *USB1_Type) GetENDPTFLUSH_FETB2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x40000) >> 18
}
func (o *USB1_Type) SetENDPTFLUSH_FETB3(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0x80000)|value<<19)
}
func (o *USB1_Type) GetENDPTFLUSH_FETB3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0x80000) >> 19
}
func (o *USB1_Type) SetENDPTFLUSH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB1_Type) GetENDPTFLUSH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0xfff00000) >> 20
}

// USB1.ENDPTSTAT: Endpoint status
func (o *USB1_Type) SetENDPTSTAT_ERBR0(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTSTAT_ERBR0() uint32 {
	return volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTSTAT_ERBR1(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTSTAT_ERBR1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTSTAT_ERBR2(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetENDPTSTAT_ERBR2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetENDPTSTAT_ERBR3(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetENDPTSTAT_ERBR3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetENDPTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0xfff0)|value<<4)
}
func (o *USB1_Type) GetENDPTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0xfff0) >> 4
}
func (o *USB1_Type) SetENDPTSTAT_ETBR0(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTSTAT_ETBR0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTSTAT_ETBR1(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTSTAT_ETBR1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTSTAT_ETBR2(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x40000)|value<<18)
}
func (o *USB1_Type) GetENDPTSTAT_ETBR2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x40000) >> 18
}
func (o *USB1_Type) SetENDPTSTAT_ETBR3(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0x80000)|value<<19)
}
func (o *USB1_Type) GetENDPTSTAT_ETBR3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0x80000) >> 19
}
func (o *USB1_Type) SetENDPTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB1_Type) GetENDPTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0xfff00000) >> 20
}

// USB1.ENDPTCOMPLETE: Endpoint complete
func (o *USB1_Type) SetENDPTCOMPLETE_ERCE0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTCOMPLETE_ERCE0() uint32 {
	return volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTCOMPLETE_ERCE1(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTCOMPLETE_ERCE1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTCOMPLETE_ERCE2(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x4)|value<<2)
}
func (o *USB1_Type) GetENDPTCOMPLETE_ERCE2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x4) >> 2
}
func (o *USB1_Type) SetENDPTCOMPLETE_ERCE3(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x8)|value<<3)
}
func (o *USB1_Type) GetENDPTCOMPLETE_ERCE3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x8) >> 3
}
func (o *USB1_Type) SetENDPTCOMPLETE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0xfff0)|value<<4)
}
func (o *USB1_Type) GetENDPTCOMPLETE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0xfff0) >> 4
}
func (o *USB1_Type) SetENDPTCOMPLETE_ETCE0(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTCOMPLETE_ETCE0() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTCOMPLETE_ETCE1(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTCOMPLETE_ETCE1() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTCOMPLETE_ETCE2(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x40000)|value<<18)
}
func (o *USB1_Type) GetENDPTCOMPLETE_ETCE2() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x40000) >> 18
}
func (o *USB1_Type) SetENDPTCOMPLETE_ETCE3(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0x80000)|value<<19)
}
func (o *USB1_Type) GetENDPTCOMPLETE_ETCE3() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0x80000) >> 19
}
func (o *USB1_Type) SetENDPTCOMPLETE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0xfff00000)|value<<20)
}
func (o *USB1_Type) GetENDPTCOMPLETE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0xfff00000) >> 20
}

// USB1.ENDPTCTRL0: Endpoint control 0
func (o *USB1_Type) SetENDPTCTRL0_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTCTRL0_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTCTRL0_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xc)|value<<2)
}
func (o *USB1_Type) GetENDPTCTRL0_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xc) >> 2
}
func (o *USB1_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x70)|value<<4)
}
func (o *USB1_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x70) >> 4
}
func (o *USB1_Type) SetENDPTCTRL0_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x80)|value<<7)
}
func (o *USB1_Type) GetENDPTCTRL0_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x80) >> 7
}
func (o *USB1_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xff00)|value<<8)
}
func (o *USB1_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xff00) >> 8
}
func (o *USB1_Type) SetENDPTCTRL0_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTCTRL0_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTCTRL0_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xc0000)|value<<18)
}
func (o *USB1_Type) GetENDPTCTRL0_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xc0000) >> 18
}
func (o *USB1_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x700000)|value<<20)
}
func (o *USB1_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x700000) >> 20
}
func (o *USB1_Type) SetENDPTCTRL0_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x800000)|value<<23)
}
func (o *USB1_Type) GetENDPTCTRL0_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x800000) >> 23
}
func (o *USB1_Type) SetENDPTCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xff000000)|value<<24)
}
func (o *USB1_Type) GetENDPTCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xff000000) >> 24
}

// USB1.ENDPTCTRL1: Endpoint control
func (o *USB1_Type) SetENDPTCTRL1_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTCTRL1_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTCTRL1_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xc)|value<<2)
}
func (o *USB1_Type) GetENDPTCTRL1_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xc) >> 2
}
func (o *USB1_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x10)|value<<4)
}
func (o *USB1_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x10) >> 4
}
func (o *USB1_Type) SetENDPTCTRL1_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x20)|value<<5)
}
func (o *USB1_Type) GetENDPTCTRL1_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x20) >> 5
}
func (o *USB1_Type) SetENDPTCTRL1_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x40)|value<<6)
}
func (o *USB1_Type) GetENDPTCTRL1_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x40) >> 6
}
func (o *USB1_Type) SetENDPTCTRL1_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x80)|value<<7)
}
func (o *USB1_Type) GetENDPTCTRL1_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x80) >> 7
}
func (o *USB1_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xff00)|value<<8)
}
func (o *USB1_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xff00) >> 8
}
func (o *USB1_Type) SetENDPTCTRL1_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTCTRL1_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTCTRL1_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xc0000)|value<<18)
}
func (o *USB1_Type) GetENDPTCTRL1_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xc0000) >> 18
}
func (o *USB1_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x100000)|value<<20)
}
func (o *USB1_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x100000) >> 20
}
func (o *USB1_Type) SetENDPTCTRL1_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x200000)|value<<21)
}
func (o *USB1_Type) GetENDPTCTRL1_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x200000) >> 21
}
func (o *USB1_Type) SetENDPTCTRL1_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *USB1_Type) GetENDPTCTRL1_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x400000) >> 22
}
func (o *USB1_Type) SetENDPTCTRL1_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *USB1_Type) GetENDPTCTRL1_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x800000) >> 23
}
func (o *USB1_Type) SetENDPTCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xff000000)|value<<24)
}
func (o *USB1_Type) GetENDPTCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xff000000) >> 24
}

// USB1.ENDPTCTRL2: Endpoint control
func (o *USB1_Type) SetENDPTCTRL2_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTCTRL2_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTCTRL2_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xc)|value<<2)
}
func (o *USB1_Type) GetENDPTCTRL2_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xc) >> 2
}
func (o *USB1_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x10)|value<<4)
}
func (o *USB1_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x10) >> 4
}
func (o *USB1_Type) SetENDPTCTRL2_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x20)|value<<5)
}
func (o *USB1_Type) GetENDPTCTRL2_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x20) >> 5
}
func (o *USB1_Type) SetENDPTCTRL2_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x40)|value<<6)
}
func (o *USB1_Type) GetENDPTCTRL2_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x40) >> 6
}
func (o *USB1_Type) SetENDPTCTRL2_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x80)|value<<7)
}
func (o *USB1_Type) GetENDPTCTRL2_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x80) >> 7
}
func (o *USB1_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xff00)|value<<8)
}
func (o *USB1_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xff00) >> 8
}
func (o *USB1_Type) SetENDPTCTRL2_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTCTRL2_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTCTRL2_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xc0000)|value<<18)
}
func (o *USB1_Type) GetENDPTCTRL2_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xc0000) >> 18
}
func (o *USB1_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x100000)|value<<20)
}
func (o *USB1_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x100000) >> 20
}
func (o *USB1_Type) SetENDPTCTRL2_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x200000)|value<<21)
}
func (o *USB1_Type) GetENDPTCTRL2_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x200000) >> 21
}
func (o *USB1_Type) SetENDPTCTRL2_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x400000)|value<<22)
}
func (o *USB1_Type) GetENDPTCTRL2_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x400000) >> 22
}
func (o *USB1_Type) SetENDPTCTRL2_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x800000)|value<<23)
}
func (o *USB1_Type) GetENDPTCTRL2_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x800000) >> 23
}
func (o *USB1_Type) SetENDPTCTRL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xff000000)|value<<24)
}
func (o *USB1_Type) GetENDPTCTRL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xff000000) >> 24
}

// USB1.ENDPTCTRL3: Endpoint control
func (o *USB1_Type) SetENDPTCTRL3_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x1)|value)
}
func (o *USB1_Type) GetENDPTCTRL3_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x1
}
func (o *USB1_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x2)|value<<1)
}
func (o *USB1_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x2) >> 1
}
func (o *USB1_Type) SetENDPTCTRL3_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xc)|value<<2)
}
func (o *USB1_Type) GetENDPTCTRL3_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xc) >> 2
}
func (o *USB1_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x10)|value<<4)
}
func (o *USB1_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x10) >> 4
}
func (o *USB1_Type) SetENDPTCTRL3_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x20)|value<<5)
}
func (o *USB1_Type) GetENDPTCTRL3_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x20) >> 5
}
func (o *USB1_Type) SetENDPTCTRL3_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x40)|value<<6)
}
func (o *USB1_Type) GetENDPTCTRL3_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x40) >> 6
}
func (o *USB1_Type) SetENDPTCTRL3_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x80)|value<<7)
}
func (o *USB1_Type) GetENDPTCTRL3_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x80) >> 7
}
func (o *USB1_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xff00)|value<<8)
}
func (o *USB1_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xff00) >> 8
}
func (o *USB1_Type) SetENDPTCTRL3_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x10000)|value<<16)
}
func (o *USB1_Type) GetENDPTCTRL3_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x10000) >> 16
}
func (o *USB1_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x20000)|value<<17)
}
func (o *USB1_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x20000) >> 17
}
func (o *USB1_Type) SetENDPTCTRL3_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xc0000)|value<<18)
}
func (o *USB1_Type) GetENDPTCTRL3_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xc0000) >> 18
}
func (o *USB1_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x100000)|value<<20)
}
func (o *USB1_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x100000) >> 20
}
func (o *USB1_Type) SetENDPTCTRL3_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x200000)|value<<21)
}
func (o *USB1_Type) GetENDPTCTRL3_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x200000) >> 21
}
func (o *USB1_Type) SetENDPTCTRL3_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x400000)|value<<22)
}
func (o *USB1_Type) GetENDPTCTRL3_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x400000) >> 22
}
func (o *USB1_Type) SetENDPTCTRL3_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x800000)|value<<23)
}
func (o *USB1_Type) GetENDPTCTRL3_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x800000) >> 23
}
func (o *USB1_Type) SetENDPTCTRL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xff000000)|value<<24)
}
func (o *USB1_Type) GetENDPTCTRL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xff000000) >> 24
}

// LCD controller
type LCD_Type struct {
	TIMH         volatile.Register32 // 0x0
	TIMV         volatile.Register32 // 0x4
	POL          volatile.Register32 // 0x8
	LE           volatile.Register32 // 0xC
	UPBASE       volatile.Register32 // 0x10
	LPBASE       volatile.Register32 // 0x14
	CTRL         volatile.Register32 // 0x18
	INTMSK       volatile.Register32 // 0x1C
	INTRAW       volatile.Register32 // 0x20
	INTSTAT      volatile.Register32 // 0x24
	INTCLR       volatile.Register32 // 0x28
	UPCURR       volatile.Register32 // 0x2C
	LPCURR       volatile.Register32 // 0x30
	_            [460]byte
	PAL          [256]volatile.Register32 // 0x200
	_            [512]byte
	CRSR_IMG     [256]volatile.Register32 // 0x800
	CRSR_CTRL    volatile.Register32      // 0xC00
	CRSR_CFG     volatile.Register32      // 0xC04
	CRSR_PAL0    volatile.Register32      // 0xC08
	CRSR_PAL1    volatile.Register32      // 0xC0C
	CRSR_XY      volatile.Register32      // 0xC10
	CRSR_CLIP    volatile.Register32      // 0xC14
	_            [8]byte
	CRSR_INTMSK  volatile.Register32 // 0xC20
	CRSR_INTCLR  volatile.Register32 // 0xC24
	CRSR_INTRAW  volatile.Register32 // 0xC28
	CRSR_INTSTAT volatile.Register32 // 0xC2C
}

// LCD.TIMH: Horizontal Timing Control register
func (o *LCD_Type) SetTIMH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0x3)|value)
}
func (o *LCD_Type) GetTIMH_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TIMH.Reg) & 0x3
}
func (o *LCD_Type) SetTIMH_PPL(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0xfc)|value<<2)
}
func (o *LCD_Type) GetTIMH_PPL() uint32 {
	return (volatile.LoadUint32(&o.TIMH.Reg) & 0xfc) >> 2
}
func (o *LCD_Type) SetTIMH_HSW(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetTIMH_HSW() uint32 {
	return (volatile.LoadUint32(&o.TIMH.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetTIMH_HFP(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetTIMH_HFP() uint32 {
	return (volatile.LoadUint32(&o.TIMH.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetTIMH_HBP(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetTIMH_HBP() uint32 {
	return (volatile.LoadUint32(&o.TIMH.Reg) & 0xff000000) >> 24
}

// LCD.TIMV: Vertical Timing Control register
func (o *LCD_Type) SetTIMV_LPP(value uint32) {
	volatile.StoreUint32(&o.TIMV.Reg, volatile.LoadUint32(&o.TIMV.Reg)&^(0x3ff)|value)
}
func (o *LCD_Type) GetTIMV_LPP() uint32 {
	return volatile.LoadUint32(&o.TIMV.Reg) & 0x3ff
}
func (o *LCD_Type) SetTIMV_VSW(value uint32) {
	volatile.StoreUint32(&o.TIMV.Reg, volatile.LoadUint32(&o.TIMV.Reg)&^(0xfc00)|value<<10)
}
func (o *LCD_Type) GetTIMV_VSW() uint32 {
	return (volatile.LoadUint32(&o.TIMV.Reg) & 0xfc00) >> 10
}
func (o *LCD_Type) SetTIMV_VFP(value uint32) {
	volatile.StoreUint32(&o.TIMV.Reg, volatile.LoadUint32(&o.TIMV.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetTIMV_VFP() uint32 {
	return (volatile.LoadUint32(&o.TIMV.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetTIMV_VBP(value uint32) {
	volatile.StoreUint32(&o.TIMV.Reg, volatile.LoadUint32(&o.TIMV.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetTIMV_VBP() uint32 {
	return (volatile.LoadUint32(&o.TIMV.Reg) & 0xff000000) >> 24
}

// LCD.POL: Clock and Signal Polarity Control register
func (o *LCD_Type) SetPOL_PCD_LO(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x1f)|value)
}
func (o *LCD_Type) GetPOL_PCD_LO() uint32 {
	return volatile.LoadUint32(&o.POL.Reg) & 0x1f
}
func (o *LCD_Type) SetPOL_CLKSEL(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x20)|value<<5)
}
func (o *LCD_Type) GetPOL_CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x20) >> 5
}
func (o *LCD_Type) SetPOL_ACB(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x7c0)|value<<6)
}
func (o *LCD_Type) GetPOL_ACB() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x7c0) >> 6
}
func (o *LCD_Type) SetPOL_IVS(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x800)|value<<11)
}
func (o *LCD_Type) GetPOL_IVS() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x800) >> 11
}
func (o *LCD_Type) SetPOL_IHS(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x1000)|value<<12)
}
func (o *LCD_Type) GetPOL_IHS() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x1000) >> 12
}
func (o *LCD_Type) SetPOL_IPC(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x2000)|value<<13)
}
func (o *LCD_Type) GetPOL_IPC() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x2000) >> 13
}
func (o *LCD_Type) SetPOL_IOE(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x4000)|value<<14)
}
func (o *LCD_Type) GetPOL_IOE() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x4000) >> 14
}
func (o *LCD_Type) SetPOL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x8000)|value<<15)
}
func (o *LCD_Type) GetPOL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x8000) >> 15
}
func (o *LCD_Type) SetPOL_CPL(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x3ff0000)|value<<16)
}
func (o *LCD_Type) GetPOL_CPL() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x3ff0000) >> 16
}
func (o *LCD_Type) SetPOL_BCD(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x4000000)|value<<26)
}
func (o *LCD_Type) GetPOL_BCD() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x4000000) >> 26
}
func (o *LCD_Type) SetPOL_PCD_HI(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0xf8000000)|value<<27)
}
func (o *LCD_Type) GetPOL_PCD_HI() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0xf8000000) >> 27
}

// LCD.LE: Line End Control register
func (o *LCD_Type) SetLE_LED(value uint32) {
	volatile.StoreUint32(&o.LE.Reg, volatile.LoadUint32(&o.LE.Reg)&^(0x7f)|value)
}
func (o *LCD_Type) GetLE_LED() uint32 {
	return volatile.LoadUint32(&o.LE.Reg) & 0x7f
}
func (o *LCD_Type) SetLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LE.Reg, volatile.LoadUint32(&o.LE.Reg)&^(0xff80)|value<<7)
}
func (o *LCD_Type) GetLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LE.Reg) & 0xff80) >> 7
}
func (o *LCD_Type) SetLE_LEE(value uint32) {
	volatile.StoreUint32(&o.LE.Reg, volatile.LoadUint32(&o.LE.Reg)&^(0x10000)|value<<16)
}
func (o *LCD_Type) GetLE_LEE() uint32 {
	return (volatile.LoadUint32(&o.LE.Reg) & 0x10000) >> 16
}
func (o *LCD_Type) SetLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LE.Reg, volatile.LoadUint32(&o.LE.Reg)&^(0xfffe0000)|value<<17)
}
func (o *LCD_Type) GetLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LE.Reg) & 0xfffe0000) >> 17
}

// LCD.UPBASE: Upper Panel Frame Base Address register
func (o *LCD_Type) SetUPBASE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.UPBASE.Reg, volatile.LoadUint32(&o.UPBASE.Reg)&^(0x7)|value)
}
func (o *LCD_Type) GetUPBASE_RESERVED() uint32 {
	return volatile.LoadUint32(&o.UPBASE.Reg) & 0x7
}
func (o *LCD_Type) SetUPBASE_LCDUPBASE(value uint32) {
	volatile.StoreUint32(&o.UPBASE.Reg, volatile.LoadUint32(&o.UPBASE.Reg)&^(0xfffffff8)|value<<3)
}
func (o *LCD_Type) GetUPBASE_LCDUPBASE() uint32 {
	return (volatile.LoadUint32(&o.UPBASE.Reg) & 0xfffffff8) >> 3
}

// LCD.LPBASE: Lower Panel Frame Base Address register
func (o *LCD_Type) SetLPBASE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LPBASE.Reg, volatile.LoadUint32(&o.LPBASE.Reg)&^(0x7)|value)
}
func (o *LCD_Type) GetLPBASE_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LPBASE.Reg) & 0x7
}
func (o *LCD_Type) SetLPBASE_LCDLPBASE(value uint32) {
	volatile.StoreUint32(&o.LPBASE.Reg, volatile.LoadUint32(&o.LPBASE.Reg)&^(0xfffffff8)|value<<3)
}
func (o *LCD_Type) GetLPBASE_LCDLPBASE() uint32 {
	return (volatile.LoadUint32(&o.LPBASE.Reg) & 0xfffffff8) >> 3
}

// LCD.CTRL: LCD Control register
func (o *LCD_Type) SetCTRL_LCDEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCTRL_LCDEN() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *LCD_Type) SetCTRL_LCDBPP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xe)|value<<1)
}
func (o *LCD_Type) GetCTRL_LCDBPP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xe) >> 1
}
func (o *LCD_Type) SetCTRL_LCDBW(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetCTRL_LCDBW() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetCTRL_LCDTFT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCD_Type) GetCTRL_LCDTFT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *LCD_Type) SetCTRL_LCDMONO8(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *LCD_Type) GetCTRL_LCDMONO8() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *LCD_Type) SetCTRL_LCDDUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *LCD_Type) GetCTRL_LCDDUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *LCD_Type) SetCTRL_BGR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *LCD_Type) GetCTRL_BGR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *LCD_Type) SetCTRL_BEBO(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *LCD_Type) GetCTRL_BEBO() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *LCD_Type) SetCTRL_BEPO(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *LCD_Type) GetCTRL_BEPO() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *LCD_Type) SetCTRL_LCDPWR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *LCD_Type) GetCTRL_LCDPWR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800) >> 11
}
func (o *LCD_Type) SetCTRL_LCDVCOMP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *LCD_Type) GetCTRL_LCDVCOMP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x3000) >> 12
}
func (o *LCD_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc000)|value<<14)
}
func (o *LCD_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc000) >> 14
}
func (o *LCD_Type) SetCTRL_WATERMARK(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *LCD_Type) GetCTRL_WATERMARK() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *LCD_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfffe0000)|value<<17)
}
func (o *LCD_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xfffe0000) >> 17
}

// LCD.INTMSK: Interrupt Mask register
func (o *LCD_Type) SetINTMSK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetINTMSK_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTMSK.Reg) & 0x1
}
func (o *LCD_Type) SetINTMSK_FUFIM(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetINTMSK_FUFIM() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetINTMSK_LNBUIM(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetINTMSK_LNBUIM() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetINTMSK_VCOMPIM(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetINTMSK_VCOMPIM() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0x8) >> 3
}
func (o *LCD_Type) SetINTMSK_BERIM(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetINTMSK_BERIM() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetINTMSK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0xffffffe0)|value<<5)
}
func (o *LCD_Type) GetINTMSK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0xffffffe0) >> 5
}

// LCD.INTRAW: Raw Interrupt Status register
func (o *LCD_Type) SetINTRAW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetINTRAW_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTRAW.Reg) & 0x1
}
func (o *LCD_Type) SetINTRAW_FUFRIS(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetINTRAW_FUFRIS() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetINTRAW_LNBURIS(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetINTRAW_LNBURIS() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetINTRAW_VCOMPRIS(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetINTRAW_VCOMPRIS() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0x8) >> 3
}
func (o *LCD_Type) SetINTRAW_BERRAW(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetINTRAW_BERRAW() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetINTRAW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0xffffffe0)|value<<5)
}
func (o *LCD_Type) GetINTRAW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0xffffffe0) >> 5
}

// LCD.INTSTAT: Masked Interrupt Status register
func (o *LCD_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetINTSTAT_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1
}
func (o *LCD_Type) SetINTSTAT_FUFMIS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetINTSTAT_FUFMIS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetINTSTAT_LNBUMIS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetINTSTAT_LNBUMIS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetINTSTAT_VCOMPMIS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetINTSTAT_VCOMPMIS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8) >> 3
}
func (o *LCD_Type) SetINTSTAT_BERMIS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetINTSTAT_BERMIS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0xffffffe0)|value<<5)
}
func (o *LCD_Type) GetINTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0xffffffe0) >> 5
}

// LCD.INTCLR: Interrupt Clear register
func (o *LCD_Type) SetINTCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetINTCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTCLR.Reg) & 0x1
}
func (o *LCD_Type) SetINTCLR_FUFIC(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetINTCLR_FUFIC() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetINTCLR_LNBUIC(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetINTCLR_LNBUIC() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetINTCLR_VCOMPIC(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetINTCLR_VCOMPIC() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x8) >> 3
}
func (o *LCD_Type) SetINTCLR_BERIC(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetINTCLR_BERIC() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetINTCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *LCD_Type) GetINTCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0xffffffe0) >> 5
}

// LCD.UPCURR: Upper Panel Current Address Value register
func (o *LCD_Type) SetUPCURR(value uint32) {
	volatile.StoreUint32(&o.UPCURR.Reg, value)
}
func (o *LCD_Type) GetUPCURR() uint32 {
	return volatile.LoadUint32(&o.UPCURR.Reg)
}

// LCD.LPCURR: Lower Panel Current Address Value register
func (o *LCD_Type) SetLPCURR(value uint32) {
	volatile.StoreUint32(&o.LPCURR.Reg, value)
}
func (o *LCD_Type) GetLPCURR() uint32 {
	return volatile.LoadUint32(&o.LPCURR.Reg)
}

// LCD.PAL: 256x16-bit Color Palette registers
func (o *LCD_Type) SetPAL_R04_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x1f)|value)
}
func (o *LCD_Type) GetPAL_R04_0(idx int) uint32 {
	return volatile.LoadUint32(&o.PAL[idx].Reg) & 0x1f
}
func (o *LCD_Type) SetPAL_G04_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x3e0)|value<<5)
}
func (o *LCD_Type) GetPAL_G04_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x3e0) >> 5
}
func (o *LCD_Type) SetPAL_B04_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x7c00)|value<<10)
}
func (o *LCD_Type) GetPAL_B04_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x7c00) >> 10
}
func (o *LCD_Type) SetPAL_I0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x8000)|value<<15)
}
func (o *LCD_Type) GetPAL_I0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x8000) >> 15
}
func (o *LCD_Type) SetPAL_R14_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x1f0000)|value<<16)
}
func (o *LCD_Type) GetPAL_R14_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x1f0000) >> 16
}
func (o *LCD_Type) SetPAL_G14_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x3e00000)|value<<21)
}
func (o *LCD_Type) GetPAL_G14_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x3e00000) >> 21
}
func (o *LCD_Type) SetPAL_B14_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x7c000000)|value<<26)
}
func (o *LCD_Type) GetPAL_B14_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x7c000000) >> 26
}
func (o *LCD_Type) SetPAL_I1(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *LCD_Type) GetPAL_I1(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x80000000) >> 31
}

// LCD.CRSR_IMG: Cursor Image registers
func (o *LCD_Type) SetCRSR_IMG(idx int, value uint32) {
	volatile.StoreUint32(&o.CRSR_IMG[idx].Reg, value)
}
func (o *LCD_Type) GetCRSR_IMG(idx int) uint32 {
	return volatile.LoadUint32(&o.CRSR_IMG[idx].Reg)
}

// LCD.CRSR_CTRL: Cursor Control register
func (o *LCD_Type) SetCRSR_CTRL_CrsrOn(value uint32) {
	volatile.StoreUint32(&o.CRSR_CTRL.Reg, volatile.LoadUint32(&o.CRSR_CTRL.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_CTRL_CrsrOn() uint32 {
	return volatile.LoadUint32(&o.CRSR_CTRL.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CTRL.Reg, volatile.LoadUint32(&o.CRSR_CTRL.Reg)&^(0xe)|value<<1)
}
func (o *LCD_Type) GetCRSR_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CTRL.Reg) & 0xe) >> 1
}
func (o *LCD_Type) SetCRSR_CTRL_CRSRNUM1_0(value uint32) {
	volatile.StoreUint32(&o.CRSR_CTRL.Reg, volatile.LoadUint32(&o.CRSR_CTRL.Reg)&^(0x30)|value<<4)
}
func (o *LCD_Type) GetCRSR_CTRL_CRSRNUM1_0() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CTRL.Reg) & 0x30) >> 4
}
func (o *LCD_Type) SetCRSR_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CTRL.Reg, volatile.LoadUint32(&o.CRSR_CTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *LCD_Type) GetCRSR_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CTRL.Reg) & 0xffffffc0) >> 6
}

// LCD.CRSR_CFG: Cursor Configuration register
func (o *LCD_Type) SetCRSR_CFG_CrsrSize(value uint32) {
	volatile.StoreUint32(&o.CRSR_CFG.Reg, volatile.LoadUint32(&o.CRSR_CFG.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_CFG_CrsrSize() uint32 {
	return volatile.LoadUint32(&o.CRSR_CFG.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_CFG_FRAMESYNC(value uint32) {
	volatile.StoreUint32(&o.CRSR_CFG.Reg, volatile.LoadUint32(&o.CRSR_CFG.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetCRSR_CFG_FRAMESYNC() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CFG.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetCRSR_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CFG.Reg, volatile.LoadUint32(&o.CRSR_CFG.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LCD_Type) GetCRSR_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CFG.Reg) & 0xfffffffc) >> 2
}

// LCD.CRSR_PAL0: Cursor Palette register 0
func (o *LCD_Type) SetCRSR_PAL0_RED(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL0.Reg, volatile.LoadUint32(&o.CRSR_PAL0.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetCRSR_PAL0_RED() uint32 {
	return volatile.LoadUint32(&o.CRSR_PAL0.Reg) & 0xff
}
func (o *LCD_Type) SetCRSR_PAL0_GREEN(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL0.Reg, volatile.LoadUint32(&o.CRSR_PAL0.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetCRSR_PAL0_GREEN() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL0.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetCRSR_PAL0_BLUE(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL0.Reg, volatile.LoadUint32(&o.CRSR_PAL0.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetCRSR_PAL0_BLUE() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL0.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetCRSR_PAL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL0.Reg, volatile.LoadUint32(&o.CRSR_PAL0.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetCRSR_PAL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL0.Reg) & 0xff000000) >> 24
}

// LCD.CRSR_PAL1: Cursor Palette register 1
func (o *LCD_Type) SetCRSR_PAL1_RED(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL1.Reg, volatile.LoadUint32(&o.CRSR_PAL1.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetCRSR_PAL1_RED() uint32 {
	return volatile.LoadUint32(&o.CRSR_PAL1.Reg) & 0xff
}
func (o *LCD_Type) SetCRSR_PAL1_GREEN(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL1.Reg, volatile.LoadUint32(&o.CRSR_PAL1.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetCRSR_PAL1_GREEN() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL1.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetCRSR_PAL1_BLUE(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL1.Reg, volatile.LoadUint32(&o.CRSR_PAL1.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetCRSR_PAL1_BLUE() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL1.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetCRSR_PAL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL1.Reg, volatile.LoadUint32(&o.CRSR_PAL1.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetCRSR_PAL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL1.Reg) & 0xff000000) >> 24
}

// LCD.CRSR_XY: Cursor XY Position register
func (o *LCD_Type) SetCRSR_XY_CRSRX(value uint32) {
	volatile.StoreUint32(&o.CRSR_XY.Reg, volatile.LoadUint32(&o.CRSR_XY.Reg)&^(0x3ff)|value)
}
func (o *LCD_Type) GetCRSR_XY_CRSRX() uint32 {
	return volatile.LoadUint32(&o.CRSR_XY.Reg) & 0x3ff
}
func (o *LCD_Type) SetCRSR_XY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_XY.Reg, volatile.LoadUint32(&o.CRSR_XY.Reg)&^(0xfc00)|value<<10)
}
func (o *LCD_Type) GetCRSR_XY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_XY.Reg) & 0xfc00) >> 10
}
func (o *LCD_Type) SetCRSR_XY_CRSRY(value uint32) {
	volatile.StoreUint32(&o.CRSR_XY.Reg, volatile.LoadUint32(&o.CRSR_XY.Reg)&^(0x3ff0000)|value<<16)
}
func (o *LCD_Type) GetCRSR_XY_CRSRY() uint32 {
	return (volatile.LoadUint32(&o.CRSR_XY.Reg) & 0x3ff0000) >> 16
}
func (o *LCD_Type) SetCRSR_XY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_XY.Reg, volatile.LoadUint32(&o.CRSR_XY.Reg)&^(0xfc000000)|value<<26)
}
func (o *LCD_Type) GetCRSR_XY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_XY.Reg) & 0xfc000000) >> 26
}

// LCD.CRSR_CLIP: Cursor Clip Position register
func (o *LCD_Type) SetCRSR_CLIP_CRSRCLIPX(value uint32) {
	volatile.StoreUint32(&o.CRSR_CLIP.Reg, volatile.LoadUint32(&o.CRSR_CLIP.Reg)&^(0x3f)|value)
}
func (o *LCD_Type) GetCRSR_CLIP_CRSRCLIPX() uint32 {
	return volatile.LoadUint32(&o.CRSR_CLIP.Reg) & 0x3f
}
func (o *LCD_Type) SetCRSR_CLIP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CLIP.Reg, volatile.LoadUint32(&o.CRSR_CLIP.Reg)&^(0xc0)|value<<6)
}
func (o *LCD_Type) GetCRSR_CLIP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CLIP.Reg) & 0xc0) >> 6
}
func (o *LCD_Type) SetCRSR_CLIP_CRSRCLIPY(value uint32) {
	volatile.StoreUint32(&o.CRSR_CLIP.Reg, volatile.LoadUint32(&o.CRSR_CLIP.Reg)&^(0x3f00)|value<<8)
}
func (o *LCD_Type) GetCRSR_CLIP_CRSRCLIPY() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CLIP.Reg) & 0x3f00) >> 8
}
func (o *LCD_Type) SetCRSR_CLIP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CLIP.Reg, volatile.LoadUint32(&o.CRSR_CLIP.Reg)&^(0xffffc000)|value<<14)
}
func (o *LCD_Type) GetCRSR_CLIP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CLIP.Reg) & 0xffffc000) >> 14
}

// LCD.CRSR_INTMSK: Cursor Interrupt Mask register
func (o *LCD_Type) SetCRSR_INTMSK_CRSRIM(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTMSK.Reg, volatile.LoadUint32(&o.CRSR_INTMSK.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_INTMSK_CRSRIM() uint32 {
	return volatile.LoadUint32(&o.CRSR_INTMSK.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_INTMSK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTMSK.Reg, volatile.LoadUint32(&o.CRSR_INTMSK.Reg)&^(0xfffffffe)|value<<1)
}
func (o *LCD_Type) GetCRSR_INTMSK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_INTMSK.Reg) & 0xfffffffe) >> 1
}

// LCD.CRSR_INTCLR: Cursor Interrupt Clear register
func (o *LCD_Type) SetCRSR_INTCLR_CRSRIC(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTCLR.Reg, volatile.LoadUint32(&o.CRSR_INTCLR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_INTCLR_CRSRIC() uint32 {
	return volatile.LoadUint32(&o.CRSR_INTCLR.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_INTCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTCLR.Reg, volatile.LoadUint32(&o.CRSR_INTCLR.Reg)&^(0xfffffffe)|value<<1)
}
func (o *LCD_Type) GetCRSR_INTCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_INTCLR.Reg) & 0xfffffffe) >> 1
}

// LCD.CRSR_INTRAW: Cursor Raw Interrupt Status register
func (o *LCD_Type) SetCRSR_INTRAW_CRSRRIS(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTRAW.Reg, volatile.LoadUint32(&o.CRSR_INTRAW.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_INTRAW_CRSRRIS() uint32 {
	return volatile.LoadUint32(&o.CRSR_INTRAW.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_INTRAW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTRAW.Reg, volatile.LoadUint32(&o.CRSR_INTRAW.Reg)&^(0xfffffffe)|value<<1)
}
func (o *LCD_Type) GetCRSR_INTRAW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_INTRAW.Reg) & 0xfffffffe) >> 1
}

// LCD.CRSR_INTSTAT: Cursor Masked Interrupt Status register
func (o *LCD_Type) SetCRSR_INTSTAT_CRSRMIS(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTSTAT.Reg, volatile.LoadUint32(&o.CRSR_INTSTAT.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_INTSTAT_CRSRMIS() uint32 {
	return volatile.LoadUint32(&o.CRSR_INTSTAT.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_INTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTSTAT.Reg, volatile.LoadUint32(&o.CRSR_INTSTAT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *LCD_Type) GetCRSR_INTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_INTSTAT.Reg) & 0xfffffffe) >> 1
}

// EEPROM
type EEPROM_Type struct {
	CMD        volatile.Register32 // 0x0
	_          [4]byte
	RWSTATE    volatile.Register32 // 0x8
	AUTOPROG   volatile.Register32 // 0xC
	WSTATE     volatile.Register32 // 0x10
	CLKDIV     volatile.Register32 // 0x14
	PWRDWN     volatile.Register32 // 0x18
	_          [4028]byte
	INTENCLR   volatile.Register32 // 0xFD8
	INTENSET   volatile.Register32 // 0xFDC
	INTSTAT    volatile.Register32 // 0xFE0
	INTEN      volatile.Register32 // 0xFE4
	INTSTATCLR volatile.Register32 // 0xFE8
	INTSTATSET volatile.Register32 // 0xFEC
}

// EEPROM.CMD: EEPROM command register
func (o *EEPROM_Type) SetCMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x7)|value)
}
func (o *EEPROM_Type) GetCMD() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x7
}
func (o *EEPROM_Type) SetCMD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EEPROM_Type) GetCMD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0xfffffff8) >> 3
}

// EEPROM.RWSTATE: EEPROM read wait state register
func (o *EEPROM_Type) SetRWSTATE_RPHASE2(value uint32) {
	volatile.StoreUint32(&o.RWSTATE.Reg, volatile.LoadUint32(&o.RWSTATE.Reg)&^(0xff)|value)
}
func (o *EEPROM_Type) GetRWSTATE_RPHASE2() uint32 {
	return volatile.LoadUint32(&o.RWSTATE.Reg) & 0xff
}
func (o *EEPROM_Type) SetRWSTATE_RPHASE1(value uint32) {
	volatile.StoreUint32(&o.RWSTATE.Reg, volatile.LoadUint32(&o.RWSTATE.Reg)&^(0xff00)|value<<8)
}
func (o *EEPROM_Type) GetRWSTATE_RPHASE1() uint32 {
	return (volatile.LoadUint32(&o.RWSTATE.Reg) & 0xff00) >> 8
}
func (o *EEPROM_Type) SetRWSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RWSTATE.Reg, volatile.LoadUint32(&o.RWSTATE.Reg)&^(0xffff0000)|value<<16)
}
func (o *EEPROM_Type) GetRWSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RWSTATE.Reg) & 0xffff0000) >> 16
}

// EEPROM.AUTOPROG: EEPROM auto programming register
func (o *EEPROM_Type) SetAUTOPROG(value uint32) {
	volatile.StoreUint32(&o.AUTOPROG.Reg, volatile.LoadUint32(&o.AUTOPROG.Reg)&^(0x3)|value)
}
func (o *EEPROM_Type) GetAUTOPROG() uint32 {
	return volatile.LoadUint32(&o.AUTOPROG.Reg) & 0x3
}
func (o *EEPROM_Type) SetAUTOPROG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AUTOPROG.Reg, volatile.LoadUint32(&o.AUTOPROG.Reg)&^(0xfffffffc)|value<<2)
}
func (o *EEPROM_Type) GetAUTOPROG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AUTOPROG.Reg) & 0xfffffffc) >> 2
}

// EEPROM.WSTATE: EEPROM wait state register
func (o *EEPROM_Type) SetWSTATE_PHASE3(value uint32) {
	volatile.StoreUint32(&o.WSTATE.Reg, volatile.LoadUint32(&o.WSTATE.Reg)&^(0xff)|value)
}
func (o *EEPROM_Type) GetWSTATE_PHASE3() uint32 {
	return volatile.LoadUint32(&o.WSTATE.Reg) & 0xff
}
func (o *EEPROM_Type) SetWSTATE_PHASE2(value uint32) {
	volatile.StoreUint32(&o.WSTATE.Reg, volatile.LoadUint32(&o.WSTATE.Reg)&^(0xff00)|value<<8)
}
func (o *EEPROM_Type) GetWSTATE_PHASE2() uint32 {
	return (volatile.LoadUint32(&o.WSTATE.Reg) & 0xff00) >> 8
}
func (o *EEPROM_Type) SetWSTATE_PHASE1(value uint32) {
	volatile.StoreUint32(&o.WSTATE.Reg, volatile.LoadUint32(&o.WSTATE.Reg)&^(0xff0000)|value<<16)
}
func (o *EEPROM_Type) GetWSTATE_PHASE1() uint32 {
	return (volatile.LoadUint32(&o.WSTATE.Reg) & 0xff0000) >> 16
}
func (o *EEPROM_Type) SetWSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WSTATE.Reg, volatile.LoadUint32(&o.WSTATE.Reg)&^(0x7f000000)|value<<24)
}
func (o *EEPROM_Type) GetWSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WSTATE.Reg) & 0x7f000000) >> 24
}
func (o *EEPROM_Type) SetWSTATE_LCK_PARWEP(value uint32) {
	volatile.StoreUint32(&o.WSTATE.Reg, volatile.LoadUint32(&o.WSTATE.Reg)&^(0x80000000)|value<<31)
}
func (o *EEPROM_Type) GetWSTATE_LCK_PARWEP() uint32 {
	return (volatile.LoadUint32(&o.WSTATE.Reg) & 0x80000000) >> 31
}

// EEPROM.CLKDIV: EEPROM clock divider register
func (o *EEPROM_Type) SetCLKDIV(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xffff)|value)
}
func (o *EEPROM_Type) GetCLKDIV() uint32 {
	return volatile.LoadUint32(&o.CLKDIV.Reg) & 0xffff
}
func (o *EEPROM_Type) SetCLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xffff0000)|value<<16)
}
func (o *EEPROM_Type) GetCLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV.Reg) & 0xffff0000) >> 16
}

// EEPROM.PWRDWN: EEPROM power-down register
func (o *EEPROM_Type) SetPWRDWN(value uint32) {
	volatile.StoreUint32(&o.PWRDWN.Reg, volatile.LoadUint32(&o.PWRDWN.Reg)&^(0x1)|value)
}
func (o *EEPROM_Type) GetPWRDWN() uint32 {
	return volatile.LoadUint32(&o.PWRDWN.Reg) & 0x1
}
func (o *EEPROM_Type) SetPWRDWN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PWRDWN.Reg, volatile.LoadUint32(&o.PWRDWN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *EEPROM_Type) GetPWRDWN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PWRDWN.Reg) & 0xfffffffe) >> 1
}

// EEPROM.INTENCLR: EEPROM interrupt enable clear
func (o *EEPROM_Type) SetINTENCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x3)|value)
}
func (o *EEPROM_Type) GetINTENCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x3
}
func (o *EEPROM_Type) SetINTENCLR_PROG_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *EEPROM_Type) GetINTENCLR_PROG_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *EEPROM_Type) SetINTENCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EEPROM_Type) GetINTENCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0xfffffff8) >> 3
}

// EEPROM.INTENSET: EEPROM interrupt enable set
func (o *EEPROM_Type) SetINTENSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x3)|value)
}
func (o *EEPROM_Type) GetINTENSET_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x3
}
func (o *EEPROM_Type) SetINTENSET_PROG_SET_EN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *EEPROM_Type) GetINTENSET_PROG_SET_EN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *EEPROM_Type) SetINTENSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EEPROM_Type) GetINTENSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0xfffffff8) >> 3
}

// EEPROM.INTSTAT: EEPROM interrupt status
func (o *EEPROM_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x3)|value)
}
func (o *EEPROM_Type) GetINTSTAT_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTSTAT.Reg) & 0x3
}
func (o *EEPROM_Type) SetINTSTAT_END_OF_PROG(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *EEPROM_Type) GetINTSTAT_END_OF_PROG() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4) >> 2
}
func (o *EEPROM_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EEPROM_Type) GetINTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0xfffffff8) >> 3
}

// EEPROM.INTEN: EEPROM interrupt enable
func (o *EEPROM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x3)|value)
}
func (o *EEPROM_Type) GetINTEN_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x3
}
func (o *EEPROM_Type) SetINTEN_EE_PROG_DONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *EEPROM_Type) GetINTEN_EE_PROG_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *EEPROM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EEPROM_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0xfffffff8) >> 3
}

// EEPROM.INTSTATCLR: EEPROM interrupt status clear
func (o *EEPROM_Type) SetINTSTATCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTATCLR.Reg, volatile.LoadUint32(&o.INTSTATCLR.Reg)&^(0x3)|value)
}
func (o *EEPROM_Type) GetINTSTATCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTSTATCLR.Reg) & 0x3
}
func (o *EEPROM_Type) SetINTSTATCLR_PROG_CLR_ST(value uint32) {
	volatile.StoreUint32(&o.INTSTATCLR.Reg, volatile.LoadUint32(&o.INTSTATCLR.Reg)&^(0x4)|value<<2)
}
func (o *EEPROM_Type) GetINTSTATCLR_PROG_CLR_ST() uint32 {
	return (volatile.LoadUint32(&o.INTSTATCLR.Reg) & 0x4) >> 2
}
func (o *EEPROM_Type) SetINTSTATCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTATCLR.Reg, volatile.LoadUint32(&o.INTSTATCLR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EEPROM_Type) GetINTSTATCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTATCLR.Reg) & 0xfffffff8) >> 3
}

// EEPROM.INTSTATSET: EEPROM interrupt status set
func (o *EEPROM_Type) SetINTSTATSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTATSET.Reg, volatile.LoadUint32(&o.INTSTATSET.Reg)&^(0x3)|value)
}
func (o *EEPROM_Type) GetINTSTATSET_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTSTATSET.Reg) & 0x3
}
func (o *EEPROM_Type) SetINTSTATSET_PROG_SET_ST(value uint32) {
	volatile.StoreUint32(&o.INTSTATSET.Reg, volatile.LoadUint32(&o.INTSTATSET.Reg)&^(0x4)|value<<2)
}
func (o *EEPROM_Type) GetINTSTATSET_PROG_SET_ST() uint32 {
	return (volatile.LoadUint32(&o.INTSTATSET.Reg) & 0x4) >> 2
}
func (o *EEPROM_Type) SetINTSTATSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTATSET.Reg, volatile.LoadUint32(&o.INTSTATSET.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EEPROM_Type) GetINTSTATSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTATSET.Reg) & 0xfffffff8) >> 3
}

// Ethernet
type ETHERNET_Type struct {
	MAC_CONFIG            volatile.Register32 // 0x0
	MAC_FRAME_FILTER      volatile.Register32 // 0x4
	MAC_HASHTABLE_HIGH    volatile.Register32 // 0x8
	MAC_HASHTABLE_LOW     volatile.Register32 // 0xC
	MAC_MII_ADDR          volatile.Register32 // 0x10
	MAC_MII_DATA          volatile.Register32 // 0x14
	MAC_FLOW_CTRL         volatile.Register32 // 0x18
	MAC_VLAN_TAG          volatile.Register32 // 0x1C
	_                     [4]byte
	MAC_DEBUG             volatile.Register32 // 0x24
	MAC_RWAKE_FRFLT       volatile.Register32 // 0x28
	MAC_PMT_CTRL_STAT     volatile.Register32 // 0x2C
	_                     [8]byte
	MAC_INTR              volatile.Register32 // 0x38
	MAC_INTR_MASK         volatile.Register32 // 0x3C
	MAC_ADDR0_HIGH        volatile.Register32 // 0x40
	MAC_ADDR0_LOW         volatile.Register32 // 0x44
	_                     [1720]byte
	MAC_TIMESTP_CTRL      volatile.Register32 // 0x700
	SUBSECOND_INCR        volatile.Register32 // 0x704
	SECONDS               volatile.Register32 // 0x708
	NANOSECONDS           volatile.Register32 // 0x70C
	SECONDSUPDATE         volatile.Register32 // 0x710
	NANOSECONDSUPDATE     volatile.Register32 // 0x714
	ADDEND                volatile.Register32 // 0x718
	TARGETSECONDS         volatile.Register32 // 0x71C
	TARGETNANOSECONDS     volatile.Register32 // 0x720
	HIGHWORD              volatile.Register32 // 0x724
	TIMESTAMPSTAT         volatile.Register32 // 0x728
	_                     [2260]byte
	DMA_BUS_MODE          volatile.Register32 // 0x1000
	DMA_TRANS_POLL_DEMAND volatile.Register32 // 0x1004
	DMA_REC_POLL_DEMAND   volatile.Register32 // 0x1008
	DMA_REC_DES_ADDR      volatile.Register32 // 0x100C
	DMA_TRANS_DES_ADDR    volatile.Register32 // 0x1010
	DMA_STAT              volatile.Register32 // 0x1014
	DMA_OP_MODE           volatile.Register32 // 0x1018
	DMA_INT_EN            volatile.Register32 // 0x101C
	DMA_MFRM_BUFOF        volatile.Register32 // 0x1020
	DMA_REC_INT_WDT       volatile.Register32 // 0x1024
	_                     [32]byte
	DMA_CURHOST_TRANS_DES volatile.Register32 // 0x1048
	DMA_CURHOST_REC_DES   volatile.Register32 // 0x104C
	DMA_CURHOST_TRANS_BUF volatile.Register32 // 0x1050
	DMA_CURHOST_REC_BUF   volatile.Register32 // 0x1054
}

// ETHERNET.MAC_CONFIG: MAC configuration register
func (o *ETHERNET_Type) SetMAC_CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x3)|value)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x3
}
func (o *ETHERNET_Type) SetMAC_CONFIG_RE(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_RE() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetMAC_CONFIG_TE(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_TE() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMAC_CONFIG_DF(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_DF() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetMAC_CONFIG_BL(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x60)|value<<5)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_BL() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x60) >> 5
}
func (o *ETHERNET_Type) SetMAC_CONFIG_ACS(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_ACS() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetMAC_CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetMAC_CONFIG_DR(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_DR() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetMAC_CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x400) >> 10
}
func (o *ETHERNET_Type) SetMAC_CONFIG_DM(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x800)|value<<11)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_DM() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x800) >> 11
}
func (o *ETHERNET_Type) SetMAC_CONFIG_LM(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_LM() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x1000) >> 12
}
func (o *ETHERNET_Type) SetMAC_CONFIG_DO(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_DO() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetMAC_CONFIG_FES(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x4000)|value<<14)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_FES() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x4000) >> 14
}
func (o *ETHERNET_Type) SetMAC_CONFIG_PS(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x8000)|value<<15)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_PS() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x8000) >> 15
}
func (o *ETHERNET_Type) SetMAC_CONFIG_DCRS(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_DCRS() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x10000) >> 16
}
func (o *ETHERNET_Type) SetMAC_CONFIG_IFG(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0xe0000)|value<<17)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_IFG() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0xe0000) >> 17
}
func (o *ETHERNET_Type) SetMAC_CONFIG_JE(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x100000)|value<<20)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_JE() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x100000) >> 20
}
func (o *ETHERNET_Type) SetMAC_CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x200000)|value<<21)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x200000) >> 21
}
func (o *ETHERNET_Type) SetMAC_CONFIG_JD(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x400000)|value<<22)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_JD() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x400000) >> 22
}
func (o *ETHERNET_Type) SetMAC_CONFIG_WD(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0x800000)|value<<23)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_WD() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0x800000) >> 23
}
func (o *ETHERNET_Type) SetMAC_CONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_CONFIG.Reg, volatile.LoadUint32(&o.MAC_CONFIG.Reg)&^(0xff000000)|value<<24)
}
func (o *ETHERNET_Type) GetMAC_CONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_CONFIG.Reg) & 0xff000000) >> 24
}

// ETHERNET.MAC_FRAME_FILTER: MAC frame filter
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_PR(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_PR() uint32 {
	return volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_HUC(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_HUC() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_HMC(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_HMC() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_DAIF(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_DAIF() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_PM(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_PM() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_DBF(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_DBF() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_PCF(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0xc0)|value<<6)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_PCF() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0xc0) >> 6
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_HPF(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_HPF() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x400) >> 10
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x7ffff800)|value<<11)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x7ffff800) >> 11
}
func (o *ETHERNET_Type) SetMAC_FRAME_FILTER_RA(value uint32) {
	volatile.StoreUint32(&o.MAC_FRAME_FILTER.Reg, volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg)&^(0x80000000)|value<<31)
}
func (o *ETHERNET_Type) GetMAC_FRAME_FILTER_RA() uint32 {
	return (volatile.LoadUint32(&o.MAC_FRAME_FILTER.Reg) & 0x80000000) >> 31
}

// ETHERNET.MAC_HASHTABLE_HIGH: Hash table high register
func (o *ETHERNET_Type) SetMAC_HASHTABLE_HIGH(value uint32) {
	volatile.StoreUint32(&o.MAC_HASHTABLE_HIGH.Reg, value)
}
func (o *ETHERNET_Type) GetMAC_HASHTABLE_HIGH() uint32 {
	return volatile.LoadUint32(&o.MAC_HASHTABLE_HIGH.Reg)
}

// ETHERNET.MAC_HASHTABLE_LOW: Hash table low register
func (o *ETHERNET_Type) SetMAC_HASHTABLE_LOW(value uint32) {
	volatile.StoreUint32(&o.MAC_HASHTABLE_LOW.Reg, value)
}
func (o *ETHERNET_Type) GetMAC_HASHTABLE_LOW() uint32 {
	return volatile.LoadUint32(&o.MAC_HASHTABLE_LOW.Reg)
}

// ETHERNET.MAC_MII_ADDR: MII address register
func (o *ETHERNET_Type) SetMAC_MII_ADDR_GB(value uint32) {
	volatile.StoreUint32(&o.MAC_MII_ADDR.Reg, volatile.LoadUint32(&o.MAC_MII_ADDR.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMAC_MII_ADDR_GB() uint32 {
	return volatile.LoadUint32(&o.MAC_MII_ADDR.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMAC_MII_ADDR_W(value uint32) {
	volatile.StoreUint32(&o.MAC_MII_ADDR.Reg, volatile.LoadUint32(&o.MAC_MII_ADDR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMAC_MII_ADDR_W() uint32 {
	return (volatile.LoadUint32(&o.MAC_MII_ADDR.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMAC_MII_ADDR_CR(value uint32) {
	volatile.StoreUint32(&o.MAC_MII_ADDR.Reg, volatile.LoadUint32(&o.MAC_MII_ADDR.Reg)&^(0x3c)|value<<2)
}
func (o *ETHERNET_Type) GetMAC_MII_ADDR_CR() uint32 {
	return (volatile.LoadUint32(&o.MAC_MII_ADDR.Reg) & 0x3c) >> 2
}
func (o *ETHERNET_Type) SetMAC_MII_ADDR_GR(value uint32) {
	volatile.StoreUint32(&o.MAC_MII_ADDR.Reg, volatile.LoadUint32(&o.MAC_MII_ADDR.Reg)&^(0x7c0)|value<<6)
}
func (o *ETHERNET_Type) GetMAC_MII_ADDR_GR() uint32 {
	return (volatile.LoadUint32(&o.MAC_MII_ADDR.Reg) & 0x7c0) >> 6
}
func (o *ETHERNET_Type) SetMAC_MII_ADDR_PA(value uint32) {
	volatile.StoreUint32(&o.MAC_MII_ADDR.Reg, volatile.LoadUint32(&o.MAC_MII_ADDR.Reg)&^(0xf800)|value<<11)
}
func (o *ETHERNET_Type) GetMAC_MII_ADDR_PA() uint32 {
	return (volatile.LoadUint32(&o.MAC_MII_ADDR.Reg) & 0xf800) >> 11
}
func (o *ETHERNET_Type) SetMAC_MII_ADDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_MII_ADDR.Reg, volatile.LoadUint32(&o.MAC_MII_ADDR.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetMAC_MII_ADDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_MII_ADDR.Reg) & 0xffff0000) >> 16
}

// ETHERNET.MAC_MII_DATA: MII data register
func (o *ETHERNET_Type) SetMAC_MII_DATA_GD(value uint32) {
	volatile.StoreUint32(&o.MAC_MII_DATA.Reg, volatile.LoadUint32(&o.MAC_MII_DATA.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetMAC_MII_DATA_GD() uint32 {
	return volatile.LoadUint32(&o.MAC_MII_DATA.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetMAC_MII_DATA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_MII_DATA.Reg, volatile.LoadUint32(&o.MAC_MII_DATA.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetMAC_MII_DATA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_MII_DATA.Reg) & 0xffff0000) >> 16
}

// ETHERNET.MAC_FLOW_CTRL: Flow control register
func (o *ETHERNET_Type) SetMAC_FLOW_CTRL_FCB(value uint32) {
	volatile.StoreUint32(&o.MAC_FLOW_CTRL.Reg, volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMAC_FLOW_CTRL_FCB() uint32 {
	return volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMAC_FLOW_CTRL_TFE(value uint32) {
	volatile.StoreUint32(&o.MAC_FLOW_CTRL.Reg, volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMAC_FLOW_CTRL_TFE() uint32 {
	return (volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMAC_FLOW_CTRL_RFE(value uint32) {
	volatile.StoreUint32(&o.MAC_FLOW_CTRL.Reg, volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetMAC_FLOW_CTRL_RFE() uint32 {
	return (volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetMAC_FLOW_CTRL_UP(value uint32) {
	volatile.StoreUint32(&o.MAC_FLOW_CTRL.Reg, volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMAC_FLOW_CTRL_UP() uint32 {
	return (volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMAC_FLOW_CTRL_PLT(value uint32) {
	volatile.StoreUint32(&o.MAC_FLOW_CTRL.Reg, volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg)&^(0x30)|value<<4)
}
func (o *ETHERNET_Type) GetMAC_FLOW_CTRL_PLT() uint32 {
	return (volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg) & 0x30) >> 4
}
func (o *ETHERNET_Type) SetMAC_FLOW_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_FLOW_CTRL.Reg, volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetMAC_FLOW_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetMAC_FLOW_CTRL_DZPQ(value uint32) {
	volatile.StoreUint32(&o.MAC_FLOW_CTRL.Reg, volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetMAC_FLOW_CTRL_DZPQ() uint32 {
	return (volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetMAC_FLOW_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_FLOW_CTRL.Reg, volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg)&^(0xff00)|value<<8)
}
func (o *ETHERNET_Type) GetMAC_FLOW_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg) & 0xff00) >> 8
}
func (o *ETHERNET_Type) SetMAC_FLOW_CTRL_PT(value uint32) {
	volatile.StoreUint32(&o.MAC_FLOW_CTRL.Reg, volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetMAC_FLOW_CTRL_PT() uint32 {
	return (volatile.LoadUint32(&o.MAC_FLOW_CTRL.Reg) & 0xffff0000) >> 16
}

// ETHERNET.MAC_VLAN_TAG: VLAN tag register
func (o *ETHERNET_Type) SetMAC_VLAN_TAG_VL(value uint32) {
	volatile.StoreUint32(&o.MAC_VLAN_TAG.Reg, volatile.LoadUint32(&o.MAC_VLAN_TAG.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetMAC_VLAN_TAG_VL() uint32 {
	return volatile.LoadUint32(&o.MAC_VLAN_TAG.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetMAC_VLAN_TAG_ETV(value uint32) {
	volatile.StoreUint32(&o.MAC_VLAN_TAG.Reg, volatile.LoadUint32(&o.MAC_VLAN_TAG.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERNET_Type) GetMAC_VLAN_TAG_ETV() uint32 {
	return (volatile.LoadUint32(&o.MAC_VLAN_TAG.Reg) & 0x10000) >> 16
}
func (o *ETHERNET_Type) SetMAC_VLAN_TAG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_VLAN_TAG.Reg, volatile.LoadUint32(&o.MAC_VLAN_TAG.Reg)&^(0xfffe0000)|value<<17)
}
func (o *ETHERNET_Type) GetMAC_VLAN_TAG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_VLAN_TAG.Reg) & 0xfffe0000) >> 17
}

// ETHERNET.MAC_DEBUG: Debug register
func (o *ETHERNET_Type) SetMAC_DEBUG_RXIDLESTAT(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_RXIDLESTAT() uint32 {
	return volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMAC_DEBUG_FIFOSTAT0(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x6)|value<<1)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_FIFOSTAT0() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x6) >> 1
}
func (o *ETHERNET_Type) SetMAC_DEBUG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMAC_DEBUG_RXFIFOSTAT1(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_RXFIFOSTAT1() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetMAC_DEBUG_RXFIFOSTAT(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x60)|value<<5)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_RXFIFOSTAT() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x60) >> 5
}
func (o *ETHERNET_Type) SetMAC_DEBUG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetMAC_DEBUG_RXFIFOLVL(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x300)|value<<8)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_RXFIFOLVL() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x300) >> 8
}
func (o *ETHERNET_Type) SetMAC_DEBUG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0xfc00)|value<<10)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0xfc00) >> 10
}
func (o *ETHERNET_Type) SetMAC_DEBUG_TXIDLESTAT(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_TXIDLESTAT() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x10000) >> 16
}
func (o *ETHERNET_Type) SetMAC_DEBUG_TXSTAT(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x60000)|value<<17)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_TXSTAT() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x60000) >> 17
}
func (o *ETHERNET_Type) SetMAC_DEBUG_PAUSE(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x80000)|value<<19)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x80000) >> 19
}
func (o *ETHERNET_Type) SetMAC_DEBUG_TXFIFOSTAT(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x300000)|value<<20)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_TXFIFOSTAT() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x300000) >> 20
}
func (o *ETHERNET_Type) SetMAC_DEBUG_TXFIFOSTAT1(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x400000)|value<<22)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_TXFIFOSTAT1() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x400000) >> 22
}
func (o *ETHERNET_Type) SetMAC_DEBUG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x800000)|value<<23)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x800000) >> 23
}
func (o *ETHERNET_Type) SetMAC_DEBUG_TXFIFOLVL(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x1000000)|value<<24)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_TXFIFOLVL() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x1000000) >> 24
}
func (o *ETHERNET_Type) SetMAC_DEBUG_TXFIFOFULL(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0x2000000)|value<<25)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_TXFIFOFULL() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0x2000000) >> 25
}
func (o *ETHERNET_Type) SetMAC_DEBUG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_DEBUG.Reg, volatile.LoadUint32(&o.MAC_DEBUG.Reg)&^(0xfc000000)|value<<26)
}
func (o *ETHERNET_Type) GetMAC_DEBUG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_DEBUG.Reg) & 0xfc000000) >> 26
}

// ETHERNET.MAC_RWAKE_FRFLT: Remote wake-up frame filter
func (o *ETHERNET_Type) SetMAC_RWAKE_FRFLT(value uint32) {
	volatile.StoreUint32(&o.MAC_RWAKE_FRFLT.Reg, value)
}
func (o *ETHERNET_Type) GetMAC_RWAKE_FRFLT() uint32 {
	return volatile.LoadUint32(&o.MAC_RWAKE_FRFLT.Reg)
}

// ETHERNET.MAC_PMT_CTRL_STAT: PMT control and status
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_PD(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_PD() uint32 {
	return volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_MPE(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_MPE() uint32 {
	return (volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_WFE(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_WFE() uint32 {
	return (volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x18)|value<<3)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x18) >> 3
}
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_MPR(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_MPR() uint32 {
	return (volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_WFR(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_WFR() uint32 {
	return (volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x180)|value<<7)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x180) >> 7
}
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_GU(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_GU() uint32 {
	return (volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x7ffffc00)|value<<10)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x7ffffc00) >> 10
}
func (o *ETHERNET_Type) SetMAC_PMT_CTRL_STAT_WFFRPR(value uint32) {
	volatile.StoreUint32(&o.MAC_PMT_CTRL_STAT.Reg, volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg)&^(0x80000000)|value<<31)
}
func (o *ETHERNET_Type) GetMAC_PMT_CTRL_STAT_WFFRPR() uint32 {
	return (volatile.LoadUint32(&o.MAC_PMT_CTRL_STAT.Reg) & 0x80000000) >> 31
}

// ETHERNET.MAC_INTR: Interrupt status register
func (o *ETHERNET_Type) SetMAC_INTR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR.Reg, volatile.LoadUint32(&o.MAC_INTR.Reg)&^(0x7)|value)
}
func (o *ETHERNET_Type) GetMAC_INTR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MAC_INTR.Reg) & 0x7
}
func (o *ETHERNET_Type) SetMAC_INTR_PMT(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR.Reg, volatile.LoadUint32(&o.MAC_INTR.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMAC_INTR_PMT() uint32 {
	return (volatile.LoadUint32(&o.MAC_INTR.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMAC_INTR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR.Reg, volatile.LoadUint32(&o.MAC_INTR.Reg)&^(0x1f0)|value<<4)
}
func (o *ETHERNET_Type) GetMAC_INTR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_INTR.Reg) & 0x1f0) >> 4
}
func (o *ETHERNET_Type) SetMAC_INTR_TS(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR.Reg, volatile.LoadUint32(&o.MAC_INTR.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetMAC_INTR_TS() uint32 {
	return (volatile.LoadUint32(&o.MAC_INTR.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetMAC_INTR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR.Reg, volatile.LoadUint32(&o.MAC_INTR.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetMAC_INTR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_INTR.Reg) & 0x400) >> 10
}
func (o *ETHERNET_Type) SetMAC_INTR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR.Reg, volatile.LoadUint32(&o.MAC_INTR.Reg)&^(0xfffff800)|value<<11)
}
func (o *ETHERNET_Type) GetMAC_INTR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_INTR.Reg) & 0xfffff800) >> 11
}

// ETHERNET.MAC_INTR_MASK: Interrupt mask register
func (o *ETHERNET_Type) SetMAC_INTR_MASK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR_MASK.Reg, volatile.LoadUint32(&o.MAC_INTR_MASK.Reg)&^(0x7)|value)
}
func (o *ETHERNET_Type) GetMAC_INTR_MASK_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MAC_INTR_MASK.Reg) & 0x7
}
func (o *ETHERNET_Type) SetMAC_INTR_MASK_PMTIM(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR_MASK.Reg, volatile.LoadUint32(&o.MAC_INTR_MASK.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMAC_INTR_MASK_PMTIM() uint32 {
	return (volatile.LoadUint32(&o.MAC_INTR_MASK.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMAC_INTR_MASK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR_MASK.Reg, volatile.LoadUint32(&o.MAC_INTR_MASK.Reg)&^(0x1f0)|value<<4)
}
func (o *ETHERNET_Type) GetMAC_INTR_MASK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_INTR_MASK.Reg) & 0x1f0) >> 4
}
func (o *ETHERNET_Type) SetMAC_INTR_MASK_TSIM(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR_MASK.Reg, volatile.LoadUint32(&o.MAC_INTR_MASK.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetMAC_INTR_MASK_TSIM() uint32 {
	return (volatile.LoadUint32(&o.MAC_INTR_MASK.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetMAC_INTR_MASK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_INTR_MASK.Reg, volatile.LoadUint32(&o.MAC_INTR_MASK.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetMAC_INTR_MASK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_INTR_MASK.Reg) & 0x400) >> 10
}

// ETHERNET.MAC_ADDR0_HIGH: MAC address 0 high register
func (o *ETHERNET_Type) SetMAC_ADDR0_HIGH_A47_32(value uint32) {
	volatile.StoreUint32(&o.MAC_ADDR0_HIGH.Reg, volatile.LoadUint32(&o.MAC_ADDR0_HIGH.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetMAC_ADDR0_HIGH_A47_32() uint32 {
	return volatile.LoadUint32(&o.MAC_ADDR0_HIGH.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetMAC_ADDR0_HIGH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_ADDR0_HIGH.Reg, volatile.LoadUint32(&o.MAC_ADDR0_HIGH.Reg)&^(0x7fff0000)|value<<16)
}
func (o *ETHERNET_Type) GetMAC_ADDR0_HIGH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_ADDR0_HIGH.Reg) & 0x7fff0000) >> 16
}
func (o *ETHERNET_Type) SetMAC_ADDR0_HIGH_MO(value uint32) {
	volatile.StoreUint32(&o.MAC_ADDR0_HIGH.Reg, volatile.LoadUint32(&o.MAC_ADDR0_HIGH.Reg)&^(0x80000000)|value<<31)
}
func (o *ETHERNET_Type) GetMAC_ADDR0_HIGH_MO() uint32 {
	return (volatile.LoadUint32(&o.MAC_ADDR0_HIGH.Reg) & 0x80000000) >> 31
}

// ETHERNET.MAC_ADDR0_LOW: MAC address 0 low register
func (o *ETHERNET_Type) SetMAC_ADDR0_LOW(value uint32) {
	volatile.StoreUint32(&o.MAC_ADDR0_LOW.Reg, value)
}
func (o *ETHERNET_Type) GetMAC_ADDR0_LOW() uint32 {
	return volatile.LoadUint32(&o.MAC_ADDR0_LOW.Reg)
}

// ETHERNET.MAC_TIMESTP_CTRL: Time stamp control register
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSENA(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSENA() uint32 {
	return volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSCFUPDT(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSCFUPDT() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSINIT(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSINIT() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSUPDT(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSUPDT() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSTRIG(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSTRIG() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSADDREG(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSADDREG() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0xc0)|value<<6)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0xc0) >> 6
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSENALL(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSENALL() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSCTRLSSR(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSCTRLSSR() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSVER2ENA(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSVER2ENA() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x400) >> 10
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSIPENA(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSIPENA() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x800) >> 11
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSIPV6ENA(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSIPV6ENA() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x1000) >> 12
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSIPV4ENA(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSIPV4ENA() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSEVNTENA(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSEVNTENA() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x4000) >> 14
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSMSTRENA(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSMSTRENA() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x8000) >> 15
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSCLKTYPE(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSCLKTYPE() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x30000) >> 16
}
func (o *ETHERNET_Type) SetMAC_TIMESTP_CTRL_TSENMACADDR(value uint32) {
	volatile.StoreUint32(&o.MAC_TIMESTP_CTRL.Reg, volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *ETHERNET_Type) GetMAC_TIMESTP_CTRL_TSENMACADDR() uint32 {
	return (volatile.LoadUint32(&o.MAC_TIMESTP_CTRL.Reg) & 0x40000) >> 18
}

// ETHERNET.SUBSECOND_INCR: Sub-second increment register
func (o *ETHERNET_Type) SetSUBSECOND_INCR_SSINC(value uint32) {
	volatile.StoreUint32(&o.SUBSECOND_INCR.Reg, volatile.LoadUint32(&o.SUBSECOND_INCR.Reg)&^(0xff)|value)
}
func (o *ETHERNET_Type) GetSUBSECOND_INCR_SSINC() uint32 {
	return volatile.LoadUint32(&o.SUBSECOND_INCR.Reg) & 0xff
}
func (o *ETHERNET_Type) SetSUBSECOND_INCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SUBSECOND_INCR.Reg, volatile.LoadUint32(&o.SUBSECOND_INCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *ETHERNET_Type) GetSUBSECOND_INCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SUBSECOND_INCR.Reg) & 0xffffff00) >> 8
}

// ETHERNET.SECONDS: System time seconds register
func (o *ETHERNET_Type) SetSECONDS(value uint32) {
	volatile.StoreUint32(&o.SECONDS.Reg, value)
}
func (o *ETHERNET_Type) GetSECONDS() uint32 {
	return volatile.LoadUint32(&o.SECONDS.Reg)
}

// ETHERNET.NANOSECONDS: System time nanoseconds register
func (o *ETHERNET_Type) SetNANOSECONDS_TSSS(value uint32) {
	volatile.StoreUint32(&o.NANOSECONDS.Reg, volatile.LoadUint32(&o.NANOSECONDS.Reg)&^(0x7fffffff)|value)
}
func (o *ETHERNET_Type) GetNANOSECONDS_TSSS() uint32 {
	return volatile.LoadUint32(&o.NANOSECONDS.Reg) & 0x7fffffff
}
func (o *ETHERNET_Type) SetNANOSECONDS_PSNT(value uint32) {
	volatile.StoreUint32(&o.NANOSECONDS.Reg, volatile.LoadUint32(&o.NANOSECONDS.Reg)&^(0x80000000)|value<<31)
}
func (o *ETHERNET_Type) GetNANOSECONDS_PSNT() uint32 {
	return (volatile.LoadUint32(&o.NANOSECONDS.Reg) & 0x80000000) >> 31
}

// ETHERNET.SECONDSUPDATE: System time seconds update register
func (o *ETHERNET_Type) SetSECONDSUPDATE(value uint32) {
	volatile.StoreUint32(&o.SECONDSUPDATE.Reg, value)
}
func (o *ETHERNET_Type) GetSECONDSUPDATE() uint32 {
	return volatile.LoadUint32(&o.SECONDSUPDATE.Reg)
}

// ETHERNET.NANOSECONDSUPDATE: System time nanoseconds update register
func (o *ETHERNET_Type) SetNANOSECONDSUPDATE_TSSS(value uint32) {
	volatile.StoreUint32(&o.NANOSECONDSUPDATE.Reg, volatile.LoadUint32(&o.NANOSECONDSUPDATE.Reg)&^(0x7fffffff)|value)
}
func (o *ETHERNET_Type) GetNANOSECONDSUPDATE_TSSS() uint32 {
	return volatile.LoadUint32(&o.NANOSECONDSUPDATE.Reg) & 0x7fffffff
}
func (o *ETHERNET_Type) SetNANOSECONDSUPDATE_ADDSUB(value uint32) {
	volatile.StoreUint32(&o.NANOSECONDSUPDATE.Reg, volatile.LoadUint32(&o.NANOSECONDSUPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *ETHERNET_Type) GetNANOSECONDSUPDATE_ADDSUB() uint32 {
	return (volatile.LoadUint32(&o.NANOSECONDSUPDATE.Reg) & 0x80000000) >> 31
}

// ETHERNET.ADDEND: Time stamp addend register
func (o *ETHERNET_Type) SetADDEND(value uint32) {
	volatile.StoreUint32(&o.ADDEND.Reg, value)
}
func (o *ETHERNET_Type) GetADDEND() uint32 {
	return volatile.LoadUint32(&o.ADDEND.Reg)
}

// ETHERNET.TARGETSECONDS: Target time seconds register
func (o *ETHERNET_Type) SetTARGETSECONDS(value uint32) {
	volatile.StoreUint32(&o.TARGETSECONDS.Reg, value)
}
func (o *ETHERNET_Type) GetTARGETSECONDS() uint32 {
	return volatile.LoadUint32(&o.TARGETSECONDS.Reg)
}

// ETHERNET.TARGETNANOSECONDS: Target time nanoseconds register
func (o *ETHERNET_Type) SetTARGETNANOSECONDS_TSTR(value uint32) {
	volatile.StoreUint32(&o.TARGETNANOSECONDS.Reg, volatile.LoadUint32(&o.TARGETNANOSECONDS.Reg)&^(0x7fffffff)|value)
}
func (o *ETHERNET_Type) GetTARGETNANOSECONDS_TSTR() uint32 {
	return volatile.LoadUint32(&o.TARGETNANOSECONDS.Reg) & 0x7fffffff
}
func (o *ETHERNET_Type) SetTARGETNANOSECONDS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TARGETNANOSECONDS.Reg, volatile.LoadUint32(&o.TARGETNANOSECONDS.Reg)&^(0x80000000)|value<<31)
}
func (o *ETHERNET_Type) GetTARGETNANOSECONDS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TARGETNANOSECONDS.Reg) & 0x80000000) >> 31
}

// ETHERNET.HIGHWORD: System time higher word seconds register
func (o *ETHERNET_Type) SetHIGHWORD_TSHWR(value uint32) {
	volatile.StoreUint32(&o.HIGHWORD.Reg, volatile.LoadUint32(&o.HIGHWORD.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetHIGHWORD_TSHWR() uint32 {
	return volatile.LoadUint32(&o.HIGHWORD.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetHIGHWORD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HIGHWORD.Reg, volatile.LoadUint32(&o.HIGHWORD.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetHIGHWORD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HIGHWORD.Reg) & 0xffff0000) >> 16
}

// ETHERNET.TIMESTAMPSTAT: Time stamp status register
func (o *ETHERNET_Type) SetTIMESTAMPSTAT_TSSOVF(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMPSTAT.Reg, volatile.LoadUint32(&o.TIMESTAMPSTAT.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetTIMESTAMPSTAT_TSSOVF() uint32 {
	return volatile.LoadUint32(&o.TIMESTAMPSTAT.Reg) & 0x1
}
func (o *ETHERNET_Type) SetTIMESTAMPSTAT_TSTARGT(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMPSTAT.Reg, volatile.LoadUint32(&o.TIMESTAMPSTAT.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetTIMESTAMPSTAT_TSTARGT() uint32 {
	return (volatile.LoadUint32(&o.TIMESTAMPSTAT.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetTIMESTAMPSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMPSTAT.Reg, volatile.LoadUint32(&o.TIMESTAMPSTAT.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ETHERNET_Type) GetTIMESTAMPSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TIMESTAMPSTAT.Reg) & 0xfffffffc) >> 2
}

// ETHERNET.DMA_BUS_MODE: Bus Mode Register
func (o *ETHERNET_Type) SetDMA_BUS_MODE_SWR(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_SWR() uint32 {
	return volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x1
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_DA(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_DA() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_DSL(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x7c)|value<<2)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_DSL() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x7c) >> 2
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_ATDS(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_ATDS() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_PBL(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x3f00)|value<<8)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_PBL() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x3f00) >> 8
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_PR(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0xc000)|value<<14)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_PR() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0xc000) >> 14
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_FB(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_FB() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x10000) >> 16
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_RPBL(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x7e0000)|value<<17)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_RPBL() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x7e0000) >> 17
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_USP(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x800000)|value<<23)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_USP() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x800000) >> 23
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_PBL8X(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x1000000)|value<<24)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_PBL8X() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x1000000) >> 24
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_AAL(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x2000000)|value<<25)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_AAL() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x2000000) >> 25
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_MB(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x4000000)|value<<26)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_MB() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x4000000) >> 26
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_TXPR(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0x8000000)|value<<27)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_TXPR() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0x8000000) >> 27
}
func (o *ETHERNET_Type) SetDMA_BUS_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_BUS_MODE.Reg, volatile.LoadUint32(&o.DMA_BUS_MODE.Reg)&^(0xf0000000)|value<<28)
}
func (o *ETHERNET_Type) GetDMA_BUS_MODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_BUS_MODE.Reg) & 0xf0000000) >> 28
}

// ETHERNET.DMA_TRANS_POLL_DEMAND: Transmit poll demand register
func (o *ETHERNET_Type) SetDMA_TRANS_POLL_DEMAND(value uint32) {
	volatile.StoreUint32(&o.DMA_TRANS_POLL_DEMAND.Reg, value)
}
func (o *ETHERNET_Type) GetDMA_TRANS_POLL_DEMAND() uint32 {
	return volatile.LoadUint32(&o.DMA_TRANS_POLL_DEMAND.Reg)
}

// ETHERNET.DMA_REC_POLL_DEMAND: Receive poll demand register
func (o *ETHERNET_Type) SetDMA_REC_POLL_DEMAND(value uint32) {
	volatile.StoreUint32(&o.DMA_REC_POLL_DEMAND.Reg, value)
}
func (o *ETHERNET_Type) GetDMA_REC_POLL_DEMAND() uint32 {
	return volatile.LoadUint32(&o.DMA_REC_POLL_DEMAND.Reg)
}

// ETHERNET.DMA_REC_DES_ADDR: Receive descriptor list address register
func (o *ETHERNET_Type) SetDMA_REC_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_REC_DES_ADDR.Reg, value)
}
func (o *ETHERNET_Type) GetDMA_REC_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_REC_DES_ADDR.Reg)
}

// ETHERNET.DMA_TRANS_DES_ADDR: Transmit descriptor list address register
func (o *ETHERNET_Type) SetDMA_TRANS_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_TRANS_DES_ADDR.Reg, value)
}
func (o *ETHERNET_Type) GetDMA_TRANS_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_TRANS_DES_ADDR.Reg)
}

// ETHERNET.DMA_STAT: Status register
func (o *ETHERNET_Type) SetDMA_STAT_TI(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetDMA_STAT_TI() uint32 {
	return volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x1
}
func (o *ETHERNET_Type) SetDMA_STAT_TPS(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetDMA_STAT_TPS() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetDMA_STAT_TU(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetDMA_STAT_TU() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetDMA_STAT_TJT(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetDMA_STAT_TJT() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetDMA_STAT_OVF(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetDMA_STAT_OVF() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetDMA_STAT_UNF(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetDMA_STAT_UNF() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetDMA_STAT_RI(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetDMA_STAT_RI() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetDMA_STAT_RU(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetDMA_STAT_RU() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetDMA_STAT_RPS(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetDMA_STAT_RPS() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetDMA_STAT_RWT(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetDMA_STAT_RWT() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetDMA_STAT_ETI(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetDMA_STAT_ETI() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x400) >> 10
}
func (o *ETHERNET_Type) SetDMA_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x1800)|value<<11)
}
func (o *ETHERNET_Type) GetDMA_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x1800) >> 11
}
func (o *ETHERNET_Type) SetDMA_STAT_FBI(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetDMA_STAT_FBI() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetDMA_STAT_ERI(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x4000)|value<<14)
}
func (o *ETHERNET_Type) GetDMA_STAT_ERI() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x4000) >> 14
}
func (o *ETHERNET_Type) SetDMA_STAT_AIE(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x8000)|value<<15)
}
func (o *ETHERNET_Type) GetDMA_STAT_AIE() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x8000) >> 15
}
func (o *ETHERNET_Type) SetDMA_STAT_NIS(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERNET_Type) GetDMA_STAT_NIS() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x10000) >> 16
}
func (o *ETHERNET_Type) SetDMA_STAT_RS(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0xe0000)|value<<17)
}
func (o *ETHERNET_Type) GetDMA_STAT_RS() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0xe0000) >> 17
}
func (o *ETHERNET_Type) SetDMA_STAT_TS(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x700000)|value<<20)
}
func (o *ETHERNET_Type) GetDMA_STAT_TS() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x700000) >> 20
}
func (o *ETHERNET_Type) SetDMA_STAT_EB1(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x800000)|value<<23)
}
func (o *ETHERNET_Type) GetDMA_STAT_EB1() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x800000) >> 23
}
func (o *ETHERNET_Type) SetDMA_STAT_EB2(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x1000000)|value<<24)
}
func (o *ETHERNET_Type) GetDMA_STAT_EB2() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x1000000) >> 24
}
func (o *ETHERNET_Type) SetDMA_STAT_EB3(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0x2000000)|value<<25)
}
func (o *ETHERNET_Type) GetDMA_STAT_EB3() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0x2000000) >> 25
}
func (o *ETHERNET_Type) SetDMA_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_STAT.Reg, volatile.LoadUint32(&o.DMA_STAT.Reg)&^(0xfc000000)|value<<26)
}
func (o *ETHERNET_Type) GetDMA_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_STAT.Reg) & 0xfc000000) >> 26
}

// ETHERNET.DMA_OP_MODE: Operation mode register
func (o *ETHERNET_Type) SetDMA_OP_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x1
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_SR(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_SR() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_OSF(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_OSF() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_RTC(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x18)|value<<3)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RTC() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x18) >> 3
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_FUF(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_FUF() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_FEF(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_FEF() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x1f00)|value<<8)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x1f00) >> 8
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_TTC(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x1c000)|value<<14)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_TTC() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x1c000) >> 14
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0xe0000)|value<<17)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0xe0000) >> 17
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_FTF(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x100000)|value<<20)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_FTF() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x100000) >> 20
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x200000)|value<<21)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x200000) >> 21
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0xc00000)|value<<22)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0xc00000) >> 22
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_DFF(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x1000000)|value<<24)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_DFF() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x1000000) >> 24
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x2000000)|value<<25)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x2000000) >> 25
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0x4000000)|value<<26)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0x4000000) >> 26
}
func (o *ETHERNET_Type) SetDMA_OP_MODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_OP_MODE.Reg, volatile.LoadUint32(&o.DMA_OP_MODE.Reg)&^(0xf8000000)|value<<27)
}
func (o *ETHERNET_Type) GetDMA_OP_MODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_OP_MODE.Reg) & 0xf8000000) >> 27
}

// ETHERNET.DMA_INT_EN: Interrupt enable register
func (o *ETHERNET_Type) SetDMA_INT_EN_TIE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_TIE() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x1
}
func (o *ETHERNET_Type) SetDMA_INT_EN_TSE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_TSE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetDMA_INT_EN_TUE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_TUE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetDMA_INT_EN_TJE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_TJE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetDMA_INT_EN_OVE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_OVE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetDMA_INT_EN_UNE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_UNE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetDMA_INT_EN_RIE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_RIE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetDMA_INT_EN_RUE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_RUE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetDMA_INT_EN_RSE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_RSE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetDMA_INT_EN_RWE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_RWE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetDMA_INT_EN_ETE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_ETE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x400) >> 10
}
func (o *ETHERNET_Type) SetDMA_INT_EN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x1800)|value<<11)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x1800) >> 11
}
func (o *ETHERNET_Type) SetDMA_INT_EN_FBE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_FBE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetDMA_INT_EN_ERE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x4000)|value<<14)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_ERE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x4000) >> 14
}
func (o *ETHERNET_Type) SetDMA_INT_EN_AIE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x8000)|value<<15)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_AIE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x8000) >> 15
}
func (o *ETHERNET_Type) SetDMA_INT_EN_NIE(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_NIE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0x10000) >> 16
}
func (o *ETHERNET_Type) SetDMA_INT_EN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_EN.Reg, volatile.LoadUint32(&o.DMA_INT_EN.Reg)&^(0xfffe0000)|value<<17)
}
func (o *ETHERNET_Type) GetDMA_INT_EN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_EN.Reg) & 0xfffe0000) >> 17
}

// ETHERNET.DMA_MFRM_BUFOF: Missed frame and buffer overflow register
func (o *ETHERNET_Type) SetDMA_MFRM_BUFOF_FMC(value uint32) {
	volatile.StoreUint32(&o.DMA_MFRM_BUFOF.Reg, volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetDMA_MFRM_BUFOF_FMC() uint32 {
	return volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetDMA_MFRM_BUFOF_OC(value uint32) {
	volatile.StoreUint32(&o.DMA_MFRM_BUFOF.Reg, volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERNET_Type) GetDMA_MFRM_BUFOF_OC() uint32 {
	return (volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg) & 0x10000) >> 16
}
func (o *ETHERNET_Type) SetDMA_MFRM_BUFOF_FMA(value uint32) {
	volatile.StoreUint32(&o.DMA_MFRM_BUFOF.Reg, volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg)&^(0xffe0000)|value<<17)
}
func (o *ETHERNET_Type) GetDMA_MFRM_BUFOF_FMA() uint32 {
	return (volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg) & 0xffe0000) >> 17
}
func (o *ETHERNET_Type) SetDMA_MFRM_BUFOF_OF(value uint32) {
	volatile.StoreUint32(&o.DMA_MFRM_BUFOF.Reg, volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg)&^(0x10000000)|value<<28)
}
func (o *ETHERNET_Type) GetDMA_MFRM_BUFOF_OF() uint32 {
	return (volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg) & 0x10000000) >> 28
}
func (o *ETHERNET_Type) SetDMA_MFRM_BUFOF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_MFRM_BUFOF.Reg, volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg)&^(0xe0000000)|value<<29)
}
func (o *ETHERNET_Type) GetDMA_MFRM_BUFOF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_MFRM_BUFOF.Reg) & 0xe0000000) >> 29
}

// ETHERNET.DMA_REC_INT_WDT: Receive interrupt watchdog timer register
func (o *ETHERNET_Type) SetDMA_REC_INT_WDT_RIWT(value uint32) {
	volatile.StoreUint32(&o.DMA_REC_INT_WDT.Reg, volatile.LoadUint32(&o.DMA_REC_INT_WDT.Reg)&^(0xff)|value)
}
func (o *ETHERNET_Type) GetDMA_REC_INT_WDT_RIWT() uint32 {
	return volatile.LoadUint32(&o.DMA_REC_INT_WDT.Reg) & 0xff
}
func (o *ETHERNET_Type) SetDMA_REC_INT_WDT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA_REC_INT_WDT.Reg, volatile.LoadUint32(&o.DMA_REC_INT_WDT.Reg)&^(0xffffff00)|value<<8)
}
func (o *ETHERNET_Type) GetDMA_REC_INT_WDT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA_REC_INT_WDT.Reg) & 0xffffff00) >> 8
}

// ETHERNET.DMA_CURHOST_TRANS_DES: Current host transmit descriptor register
func (o *ETHERNET_Type) SetDMA_CURHOST_TRANS_DES(value uint32) {
	volatile.StoreUint32(&o.DMA_CURHOST_TRANS_DES.Reg, value)
}
func (o *ETHERNET_Type) GetDMA_CURHOST_TRANS_DES() uint32 {
	return volatile.LoadUint32(&o.DMA_CURHOST_TRANS_DES.Reg)
}

// ETHERNET.DMA_CURHOST_REC_DES: Current host receive descriptor register
func (o *ETHERNET_Type) SetDMA_CURHOST_REC_DES(value uint32) {
	volatile.StoreUint32(&o.DMA_CURHOST_REC_DES.Reg, value)
}
func (o *ETHERNET_Type) GetDMA_CURHOST_REC_DES() uint32 {
	return volatile.LoadUint32(&o.DMA_CURHOST_REC_DES.Reg)
}

// ETHERNET.DMA_CURHOST_TRANS_BUF: Current host transmit buffer address register
func (o *ETHERNET_Type) SetDMA_CURHOST_TRANS_BUF(value uint32) {
	volatile.StoreUint32(&o.DMA_CURHOST_TRANS_BUF.Reg, value)
}
func (o *ETHERNET_Type) GetDMA_CURHOST_TRANS_BUF() uint32 {
	return volatile.LoadUint32(&o.DMA_CURHOST_TRANS_BUF.Reg)
}

// ETHERNET.DMA_CURHOST_REC_BUF: Current host receive buffer address register
func (o *ETHERNET_Type) SetDMA_CURHOST_REC_BUF(value uint32) {
	volatile.StoreUint32(&o.DMA_CURHOST_REC_BUF.Reg, value)
}
func (o *ETHERNET_Type) GetDMA_CURHOST_REC_BUF() uint32 {
	return volatile.LoadUint32(&o.DMA_CURHOST_REC_BUF.Reg)
}

// Alarm timer
type ATIMER_Type struct {
	DOWNCOUNTER volatile.Register32 // 0x0
	PRESET      volatile.Register32 // 0x4
	_           [4048]byte
	CLR_EN      volatile.Register32 // 0xFD8
	SET_EN      volatile.Register32 // 0xFDC
	STATUS      volatile.Register32 // 0xFE0
	ENABLE      volatile.Register32 // 0xFE4
	CLR_STAT    volatile.Register32 // 0xFE8
	SET_STAT    volatile.Register32 // 0xFEC
}

// ATIMER.DOWNCOUNTER: Downcounter register
func (o *ATIMER_Type) SetDOWNCOUNTER_CVAL(value uint32) {
	volatile.StoreUint32(&o.DOWNCOUNTER.Reg, volatile.LoadUint32(&o.DOWNCOUNTER.Reg)&^(0xffff)|value)
}
func (o *ATIMER_Type) GetDOWNCOUNTER_CVAL() uint32 {
	return volatile.LoadUint32(&o.DOWNCOUNTER.Reg) & 0xffff
}
func (o *ATIMER_Type) SetDOWNCOUNTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DOWNCOUNTER.Reg, volatile.LoadUint32(&o.DOWNCOUNTER.Reg)&^(0xffff0000)|value<<16)
}
func (o *ATIMER_Type) GetDOWNCOUNTER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DOWNCOUNTER.Reg) & 0xffff0000) >> 16
}

// ATIMER.PRESET: Preset value register
func (o *ATIMER_Type) SetPRESET_PRESETVAL(value uint32) {
	volatile.StoreUint32(&o.PRESET.Reg, volatile.LoadUint32(&o.PRESET.Reg)&^(0xffff)|value)
}
func (o *ATIMER_Type) GetPRESET_PRESETVAL() uint32 {
	return volatile.LoadUint32(&o.PRESET.Reg) & 0xffff
}
func (o *ATIMER_Type) SetPRESET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PRESET.Reg, volatile.LoadUint32(&o.PRESET.Reg)&^(0xffff0000)|value<<16)
}
func (o *ATIMER_Type) GetPRESET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PRESET.Reg) & 0xffff0000) >> 16
}

// ATIMER.CLR_EN: Interrupt clear enable register
func (o *ATIMER_Type) SetCLR_EN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x1)|value)
}
func (o *ATIMER_Type) GetCLR_EN() uint32 {
	return volatile.LoadUint32(&o.CLR_EN.Reg) & 0x1
}
func (o *ATIMER_Type) SetCLR_EN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *ATIMER_Type) GetCLR_EN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0xfffffffe) >> 1
}

// ATIMER.SET_EN: Interrupt set enable register
func (o *ATIMER_Type) SetSET_EN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x1)|value)
}
func (o *ATIMER_Type) GetSET_EN() uint32 {
	return volatile.LoadUint32(&o.SET_EN.Reg) & 0x1
}
func (o *ATIMER_Type) SetSET_EN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *ATIMER_Type) GetSET_EN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0xfffffffe) >> 1
}

// ATIMER.STATUS: Status register
func (o *ATIMER_Type) SetSTATUS_STAT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *ATIMER_Type) GetSTATUS_STAT() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *ATIMER_Type) SetSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xfffffffe)|value<<1)
}
func (o *ATIMER_Type) GetSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xfffffffe) >> 1
}

// ATIMER.ENABLE: Enable register
func (o *ATIMER_Type) SetENABLE_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *ATIMER_Type) GetENABLE_EN() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}
func (o *ATIMER_Type) SetENABLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xfffffffe)|value<<1)
}
func (o *ATIMER_Type) GetENABLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0xfffffffe) >> 1
}

// ATIMER.CLR_STAT: Clear register
func (o *ATIMER_Type) SetCLR_STAT_CSTAT(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x1)|value)
}
func (o *ATIMER_Type) GetCLR_STAT_CSTAT() uint32 {
	return volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x1
}
func (o *ATIMER_Type) SetCLR_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *ATIMER_Type) GetCLR_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0xfffffffe) >> 1
}

// ATIMER.SET_STAT: Set register
func (o *ATIMER_Type) SetSET_STAT_SSTAT(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x1)|value)
}
func (o *ATIMER_Type) GetSET_STAT_SSTAT() uint32 {
	return volatile.LoadUint32(&o.SET_STAT.Reg) & 0x1
}
func (o *ATIMER_Type) SetSET_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *ATIMER_Type) GetSET_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0xfffffffe) >> 1
}

// RTC REGFILE
type REGFILE_Type struct {
	REGFILE [64]volatile.Register32 // 0x0
}

// REGFILE.REGFILE: General purpose storage register
func (o *REGFILE_Type) SetREGFILE(idx int, value uint32) {
	volatile.StoreUint32(&o.REGFILE[idx].Reg, value)
}
func (o *REGFILE_Type) GetREGFILE(idx int) uint32 {
	return volatile.LoadUint32(&o.REGFILE[idx].Reg)
}

// Power Management Controller (PMC)
type PMC_Type struct {
	PD0_SLEEP0_HW_ENA volatile.Register32 // 0x0
	_                 [24]byte
	PD0_SLEEP0_MODE   volatile.Register32 // 0x1C
}

// PMC.PD0_SLEEP0_HW_ENA: Hardware sleep event enable register
func (o *PMC_Type) SetPD0_SLEEP0_HW_ENA_ENA_EVENT0(value uint32) {
	volatile.StoreUint32(&o.PD0_SLEEP0_HW_ENA.Reg, volatile.LoadUint32(&o.PD0_SLEEP0_HW_ENA.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPD0_SLEEP0_HW_ENA_ENA_EVENT0() uint32 {
	return volatile.LoadUint32(&o.PD0_SLEEP0_HW_ENA.Reg) & 0x1
}
func (o *PMC_Type) SetPD0_SLEEP0_HW_ENA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PD0_SLEEP0_HW_ENA.Reg, volatile.LoadUint32(&o.PD0_SLEEP0_HW_ENA.Reg)&^(0xfffffffe)|value<<1)
}
func (o *PMC_Type) GetPD0_SLEEP0_HW_ENA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PD0_SLEEP0_HW_ENA.Reg) & 0xfffffffe) >> 1
}

// PMC.PD0_SLEEP0_MODE: Sleep power mode register
func (o *PMC_Type) SetPD0_SLEEP0_MODE(value uint32) {
	volatile.StoreUint32(&o.PD0_SLEEP0_MODE.Reg, value)
}
func (o *PMC_Type) GetPD0_SLEEP0_MODE() uint32 {
	return volatile.LoadUint32(&o.PD0_SLEEP0_MODE.Reg)
}

// Configuration Registers (CREG)
type CREG_Type struct {
	_         [4]byte
	CREG0     volatile.Register32 // 0x4
	_         [248]byte
	M3MEMMAP  volatile.Register32 // 0x100
	_         [20]byte
	CREG5     volatile.Register32 // 0x118
	DMAMUX    volatile.Register32 // 0x11C
	FLASHCFGA volatile.Register32 // 0x120
	FLASHCFGB volatile.Register32 // 0x124
	ETBCFG    volatile.Register32 // 0x128
	CREG6     volatile.Register32 // 0x12C
	_         [208]byte
	CHIPID    volatile.Register32 // 0x200
	_         [764]byte
	USB0FLADJ volatile.Register32 // 0x500
	_         [252]byte
	USB1FLADJ volatile.Register32 // 0x600
}

// CREG.CREG0: Chip configuration register 32 kHz oscillator output and BOD control register.
func (o *CREG_Type) SetCREG0_EN1KHZ(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0x1)|value)
}
func (o *CREG_Type) GetCREG0_EN1KHZ() uint32 {
	return volatile.LoadUint32(&o.CREG0.Reg) & 0x1
}
func (o *CREG_Type) SetCREG0_EN32KHZ(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0x2)|value<<1)
}
func (o *CREG_Type) GetCREG0_EN32KHZ() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0x2) >> 1
}
func (o *CREG_Type) SetCREG0_RESET32KHZ(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0x4)|value<<2)
}
func (o *CREG_Type) GetCREG0_RESET32KHZ() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0x4) >> 2
}
func (o *CREG_Type) SetCREG0_PD32KHZ(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0x8)|value<<3)
}
func (o *CREG_Type) GetCREG0_PD32KHZ() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0x8) >> 3
}
func (o *CREG_Type) SetCREG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0x10)|value<<4)
}
func (o *CREG_Type) GetCREG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0x10) >> 4
}
func (o *CREG_Type) SetCREG0_USB0PHY(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0x20)|value<<5)
}
func (o *CREG_Type) GetCREG0_USB0PHY() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0x20) >> 5
}
func (o *CREG_Type) SetCREG0_ALARMCTRL(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0xc0)|value<<6)
}
func (o *CREG_Type) GetCREG0_ALARMCTRL() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0xc0) >> 6
}
func (o *CREG_Type) SetCREG0_BODLVL1(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0x300)|value<<8)
}
func (o *CREG_Type) GetCREG0_BODLVL1() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0x300) >> 8
}
func (o *CREG_Type) SetCREG0_BODLVL2(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0xc00)|value<<10)
}
func (o *CREG_Type) GetCREG0_BODLVL2() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0xc00) >> 10
}
func (o *CREG_Type) SetCREG0_SAMPLECTRL(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0x3000)|value<<12)
}
func (o *CREG_Type) GetCREG0_SAMPLECTRL() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0x3000) >> 12
}
func (o *CREG_Type) SetCREG0_WAKEUP0CTRL(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0xc000)|value<<14)
}
func (o *CREG_Type) GetCREG0_WAKEUP0CTRL() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0xc000) >> 14
}
func (o *CREG_Type) SetCREG0_WAKEUP1CTRL(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0x30000)|value<<16)
}
func (o *CREG_Type) GetCREG0_WAKEUP1CTRL() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0x30000) >> 16
}
func (o *CREG_Type) SetCREG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CREG0.Reg, volatile.LoadUint32(&o.CREG0.Reg)&^(0xfffc0000)|value<<18)
}
func (o *CREG_Type) GetCREG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CREG0.Reg) & 0xfffc0000) >> 18
}

// CREG.M3MEMMAP: ARM Cortex-M3 memory mapping
func (o *CREG_Type) SetM3MEMMAP_M3MAP(value uint32) {
	volatile.StoreUint32(&o.M3MEMMAP.Reg, volatile.LoadUint32(&o.M3MEMMAP.Reg)&^(0xfffff000)|value<<12)
}
func (o *CREG_Type) GetM3MEMMAP_M3MAP() uint32 {
	return (volatile.LoadUint32(&o.M3MEMMAP.Reg) & 0xfffff000) >> 12
}

// CREG.CREG5: Chip configuration register 5. Controls JTAG access.
func (o *CREG_Type) SetCREG5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CREG5.Reg, volatile.LoadUint32(&o.CREG5.Reg)&^(0x7ff)|value)
}
func (o *CREG_Type) GetCREG5_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CREG5.Reg) & 0x7ff
}
func (o *CREG_Type) SetCREG5_M3TAPSEL(value uint32) {
	volatile.StoreUint32(&o.CREG5.Reg, volatile.LoadUint32(&o.CREG5.Reg)&^(0x800)|value<<11)
}
func (o *CREG_Type) GetCREG5_M3TAPSEL() uint32 {
	return (volatile.LoadUint32(&o.CREG5.Reg) & 0x800) >> 11
}
func (o *CREG_Type) SetCREG5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CREG5.Reg, volatile.LoadUint32(&o.CREG5.Reg)&^(0xfffff000)|value<<12)
}
func (o *CREG_Type) GetCREG5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CREG5.Reg) & 0xfffff000) >> 12
}

// CREG.DMAMUX: DMA mux control
func (o *CREG_Type) SetDMAMUX_DMAMUXPER0(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0x3)|value)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER0() uint32 {
	return volatile.LoadUint32(&o.DMAMUX.Reg) & 0x3
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER1(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0xc)|value<<2)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER1() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0xc) >> 2
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER2(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0x30)|value<<4)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER2() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0x30) >> 4
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER3(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0xc0)|value<<6)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER3() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0xc0) >> 6
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER4(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0x300)|value<<8)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER4() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0x300) >> 8
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER5(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0xc00)|value<<10)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER5() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0xc00) >> 10
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER6(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0x3000)|value<<12)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER6() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0x3000) >> 12
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER7(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0xc000)|value<<14)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER7() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0xc000) >> 14
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER8(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0x30000)|value<<16)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER8() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0x30000) >> 16
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER9(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0xc0000)|value<<18)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER9() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0xc0000) >> 18
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER10(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0x300000)|value<<20)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER10() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0x300000) >> 20
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER11(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0xc00000)|value<<22)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER11() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0xc00000) >> 22
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER12(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0x3000000)|value<<24)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER12() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0x3000000) >> 24
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER13(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0xc000000)|value<<26)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER13() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0xc000000) >> 26
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER14(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0x30000000)|value<<28)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER14() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0x30000000) >> 28
}
func (o *CREG_Type) SetDMAMUX_DMAMUXPER15(value uint32) {
	volatile.StoreUint32(&o.DMAMUX.Reg, volatile.LoadUint32(&o.DMAMUX.Reg)&^(0xc0000000)|value<<30)
}
func (o *CREG_Type) GetDMAMUX_DMAMUXPER15() uint32 {
	return (volatile.LoadUint32(&o.DMAMUX.Reg) & 0xc0000000) >> 30
}

// CREG.FLASHCFGA: Flash accelerator configuration register for flash bank A
func (o *CREG_Type) SetFLASHCFGA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FLASHCFGA.Reg, volatile.LoadUint32(&o.FLASHCFGA.Reg)&^(0xfff)|value)
}
func (o *CREG_Type) GetFLASHCFGA_RESERVED() uint32 {
	return volatile.LoadUint32(&o.FLASHCFGA.Reg) & 0xfff
}
func (o *CREG_Type) SetFLASHCFGA_FLASHTIM(value uint32) {
	volatile.StoreUint32(&o.FLASHCFGA.Reg, volatile.LoadUint32(&o.FLASHCFGA.Reg)&^(0xf000)|value<<12)
}
func (o *CREG_Type) GetFLASHCFGA_FLASHTIM() uint32 {
	return (volatile.LoadUint32(&o.FLASHCFGA.Reg) & 0xf000) >> 12
}
func (o *CREG_Type) SetFLASHCFGA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FLASHCFGA.Reg, volatile.LoadUint32(&o.FLASHCFGA.Reg)&^(0x7fff0000)|value<<16)
}
func (o *CREG_Type) GetFLASHCFGA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FLASHCFGA.Reg) & 0x7fff0000) >> 16
}
func (o *CREG_Type) SetFLASHCFGA_POW(value uint32) {
	volatile.StoreUint32(&o.FLASHCFGA.Reg, volatile.LoadUint32(&o.FLASHCFGA.Reg)&^(0x80000000)|value<<31)
}
func (o *CREG_Type) GetFLASHCFGA_POW() uint32 {
	return (volatile.LoadUint32(&o.FLASHCFGA.Reg) & 0x80000000) >> 31
}

// CREG.FLASHCFGB: Flash accelerator configuration register for flash bank B
func (o *CREG_Type) SetFLASHCFGB_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FLASHCFGB.Reg, volatile.LoadUint32(&o.FLASHCFGB.Reg)&^(0xfff)|value)
}
func (o *CREG_Type) GetFLASHCFGB_RESERVED() uint32 {
	return volatile.LoadUint32(&o.FLASHCFGB.Reg) & 0xfff
}
func (o *CREG_Type) SetFLASHCFGB_FLASHTIM(value uint32) {
	volatile.StoreUint32(&o.FLASHCFGB.Reg, volatile.LoadUint32(&o.FLASHCFGB.Reg)&^(0xf000)|value<<12)
}
func (o *CREG_Type) GetFLASHCFGB_FLASHTIM() uint32 {
	return (volatile.LoadUint32(&o.FLASHCFGB.Reg) & 0xf000) >> 12
}
func (o *CREG_Type) SetFLASHCFGB_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FLASHCFGB.Reg, volatile.LoadUint32(&o.FLASHCFGB.Reg)&^(0x7fff0000)|value<<16)
}
func (o *CREG_Type) GetFLASHCFGB_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FLASHCFGB.Reg) & 0x7fff0000) >> 16
}
func (o *CREG_Type) SetFLASHCFGB_POW(value uint32) {
	volatile.StoreUint32(&o.FLASHCFGB.Reg, volatile.LoadUint32(&o.FLASHCFGB.Reg)&^(0x80000000)|value<<31)
}
func (o *CREG_Type) GetFLASHCFGB_POW() uint32 {
	return (volatile.LoadUint32(&o.FLASHCFGB.Reg) & 0x80000000) >> 31
}

// CREG.ETBCFG: ETB RAM configuration
func (o *CREG_Type) SetETBCFG_ETB(value uint32) {
	volatile.StoreUint32(&o.ETBCFG.Reg, volatile.LoadUint32(&o.ETBCFG.Reg)&^(0x1)|value)
}
func (o *CREG_Type) GetETBCFG_ETB() uint32 {
	return volatile.LoadUint32(&o.ETBCFG.Reg) & 0x1
}
func (o *CREG_Type) SetETBCFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ETBCFG.Reg, volatile.LoadUint32(&o.ETBCFG.Reg)&^(0xfffffffe)|value<<1)
}
func (o *CREG_Type) GetETBCFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ETBCFG.Reg) & 0xfffffffe) >> 1
}

// CREG.CREG6: Chip configuration register 6. Controls multiple functions : Ethernet interface, SCT output, I2S0/1 inputs, EMC clock.
func (o *CREG_Type) SetCREG6_ETHMODE(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0x7)|value)
}
func (o *CREG_Type) GetCREG6_ETHMODE() uint32 {
	return volatile.LoadUint32(&o.CREG6.Reg) & 0x7
}
func (o *CREG_Type) SetCREG6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0x8)|value<<3)
}
func (o *CREG_Type) GetCREG6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CREG6.Reg) & 0x8) >> 3
}
func (o *CREG_Type) SetCREG6_CTOUTCTRL(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0x10)|value<<4)
}
func (o *CREG_Type) GetCREG6_CTOUTCTRL() uint32 {
	return (volatile.LoadUint32(&o.CREG6.Reg) & 0x10) >> 4
}
func (o *CREG_Type) SetCREG6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0xfe0)|value<<5)
}
func (o *CREG_Type) GetCREG6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CREG6.Reg) & 0xfe0) >> 5
}
func (o *CREG_Type) SetCREG6_I2S0_TX_SCK_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0x1000)|value<<12)
}
func (o *CREG_Type) GetCREG6_I2S0_TX_SCK_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.CREG6.Reg) & 0x1000) >> 12
}
func (o *CREG_Type) SetCREG6_I2S0_RX_SCK_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0x2000)|value<<13)
}
func (o *CREG_Type) GetCREG6_I2S0_RX_SCK_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.CREG6.Reg) & 0x2000) >> 13
}
func (o *CREG_Type) SetCREG6_I2S1_TX_SCK_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0x4000)|value<<14)
}
func (o *CREG_Type) GetCREG6_I2S1_TX_SCK_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.CREG6.Reg) & 0x4000) >> 14
}
func (o *CREG_Type) SetCREG6_I2S1_RX_SCK_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0x8000)|value<<15)
}
func (o *CREG_Type) GetCREG6_I2S1_RX_SCK_IN_SEL() uint32 {
	return (volatile.LoadUint32(&o.CREG6.Reg) & 0x8000) >> 15
}
func (o *CREG_Type) SetCREG6_EMC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0x10000)|value<<16)
}
func (o *CREG_Type) GetCREG6_EMC_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CREG6.Reg) & 0x10000) >> 16
}
func (o *CREG_Type) SetCREG6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CREG6.Reg, volatile.LoadUint32(&o.CREG6.Reg)&^(0xfffe0000)|value<<17)
}
func (o *CREG_Type) GetCREG6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CREG6.Reg) & 0xfffe0000) >> 17
}

// CREG.CHIPID: Part ID
func (o *CREG_Type) SetCHIPID(value uint32) {
	volatile.StoreUint32(&o.CHIPID.Reg, value)
}
func (o *CREG_Type) GetCHIPID() uint32 {
	return volatile.LoadUint32(&o.CHIPID.Reg)
}

// CREG.USB0FLADJ: USB0 frame length adjust register
func (o *CREG_Type) SetUSB0FLADJ_FLTV(value uint32) {
	volatile.StoreUint32(&o.USB0FLADJ.Reg, volatile.LoadUint32(&o.USB0FLADJ.Reg)&^(0x3f)|value)
}
func (o *CREG_Type) GetUSB0FLADJ_FLTV() uint32 {
	return volatile.LoadUint32(&o.USB0FLADJ.Reg) & 0x3f
}
func (o *CREG_Type) SetUSB0FLADJ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USB0FLADJ.Reg, volatile.LoadUint32(&o.USB0FLADJ.Reg)&^(0xffffffc0)|value<<6)
}
func (o *CREG_Type) GetUSB0FLADJ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USB0FLADJ.Reg) & 0xffffffc0) >> 6
}

// CREG.USB1FLADJ: USB1 frame length adjust register
func (o *CREG_Type) SetUSB1FLADJ_FLTV(value uint32) {
	volatile.StoreUint32(&o.USB1FLADJ.Reg, volatile.LoadUint32(&o.USB1FLADJ.Reg)&^(0x3f)|value)
}
func (o *CREG_Type) GetUSB1FLADJ_FLTV() uint32 {
	return volatile.LoadUint32(&o.USB1FLADJ.Reg) & 0x3f
}
func (o *CREG_Type) SetUSB1FLADJ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USB1FLADJ.Reg, volatile.LoadUint32(&o.USB1FLADJ.Reg)&^(0xffffffc0)|value<<6)
}
func (o *CREG_Type) GetUSB1FLADJ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USB1FLADJ.Reg) & 0xffffffc0) >> 6
}

// Event router
type EVENTROUTER_Type struct {
	HILO     volatile.Register32 // 0x0
	EDGE     volatile.Register32 // 0x4
	_        [4048]byte
	CLR_EN   volatile.Register32 // 0xFD8
	SET_EN   volatile.Register32 // 0xFDC
	STATUS   volatile.Register32 // 0xFE0
	ENABLE   volatile.Register32 // 0xFE4
	CLR_STAT volatile.Register32 // 0xFE8
	SET_STAT volatile.Register32 // 0xFEC
}

// EVENTROUTER.HILO: Level configuration register
func (o *EVENTROUTER_Type) SetHILO_WAKEUP0_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x1)|value)
}
func (o *EVENTROUTER_Type) GetHILO_WAKEUP0_L() uint32 {
	return volatile.LoadUint32(&o.HILO.Reg) & 0x1
}
func (o *EVENTROUTER_Type) SetHILO_WAKEUP1_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x2)|value<<1)
}
func (o *EVENTROUTER_Type) GetHILO_WAKEUP1_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x2) >> 1
}
func (o *EVENTROUTER_Type) SetHILO_WAKEUP2_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x4)|value<<2)
}
func (o *EVENTROUTER_Type) GetHILO_WAKEUP2_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x4) >> 2
}
func (o *EVENTROUTER_Type) SetHILO_WAKEUP3_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x8)|value<<3)
}
func (o *EVENTROUTER_Type) GetHILO_WAKEUP3_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x8) >> 3
}
func (o *EVENTROUTER_Type) SetHILO_ATIMER_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x10)|value<<4)
}
func (o *EVENTROUTER_Type) GetHILO_ATIMER_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x10) >> 4
}
func (o *EVENTROUTER_Type) SetHILO_RTC_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x20)|value<<5)
}
func (o *EVENTROUTER_Type) GetHILO_RTC_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x20) >> 5
}
func (o *EVENTROUTER_Type) SetHILO_BOD_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x40)|value<<6)
}
func (o *EVENTROUTER_Type) GetHILO_BOD_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x40) >> 6
}
func (o *EVENTROUTER_Type) SetHILO_WWDT_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x80)|value<<7)
}
func (o *EVENTROUTER_Type) GetHILO_WWDT_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x80) >> 7
}
func (o *EVENTROUTER_Type) SetHILO_ETH_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x100)|value<<8)
}
func (o *EVENTROUTER_Type) GetHILO_ETH_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x100) >> 8
}
func (o *EVENTROUTER_Type) SetHILO_USB0_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x200)|value<<9)
}
func (o *EVENTROUTER_Type) GetHILO_USB0_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x200) >> 9
}
func (o *EVENTROUTER_Type) SetHILO_USB1_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x400)|value<<10)
}
func (o *EVENTROUTER_Type) GetHILO_USB1_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x400) >> 10
}
func (o *EVENTROUTER_Type) SetHILO_SDMMC_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x800)|value<<11)
}
func (o *EVENTROUTER_Type) GetHILO_SDMMC_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x800) >> 11
}
func (o *EVENTROUTER_Type) SetHILO_CAN_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x1000)|value<<12)
}
func (o *EVENTROUTER_Type) GetHILO_CAN_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x1000) >> 12
}
func (o *EVENTROUTER_Type) SetHILO_TIM2_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x2000)|value<<13)
}
func (o *EVENTROUTER_Type) GetHILO_TIM2_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x2000) >> 13
}
func (o *EVENTROUTER_Type) SetHILO_TIM6_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x4000)|value<<14)
}
func (o *EVENTROUTER_Type) GetHILO_TIM6_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x4000) >> 14
}
func (o *EVENTROUTER_Type) SetHILO_QEI_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x8000)|value<<15)
}
func (o *EVENTROUTER_Type) GetHILO_QEI_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x8000) >> 15
}
func (o *EVENTROUTER_Type) SetHILO_TIM14_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x10000)|value<<16)
}
func (o *EVENTROUTER_Type) GetHILO_TIM14_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x10000) >> 16
}
func (o *EVENTROUTER_Type) SetHILO_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x60000)|value<<17)
}
func (o *EVENTROUTER_Type) GetHILO_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x60000) >> 17
}
func (o *EVENTROUTER_Type) SetHILO_RESET_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x80000)|value<<19)
}
func (o *EVENTROUTER_Type) GetHILO_RESET_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x80000) >> 19
}
func (o *EVENTROUTER_Type) SetHILO_BODRESET_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x100000)|value<<20)
}
func (o *EVENTROUTER_Type) GetHILO_BODRESET_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x100000) >> 20
}
func (o *EVENTROUTER_Type) SetHILO_DPDRESET_L(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0x200000)|value<<21)
}
func (o *EVENTROUTER_Type) GetHILO_DPDRESET_L() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0x200000) >> 21
}
func (o *EVENTROUTER_Type) SetHILO_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HILO.Reg, volatile.LoadUint32(&o.HILO.Reg)&^(0xffc00000)|value<<22)
}
func (o *EVENTROUTER_Type) GetHILO_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HILO.Reg) & 0xffc00000) >> 22
}

// EVENTROUTER.EDGE: Edge configuration
func (o *EVENTROUTER_Type) SetEDGE_WAKEUP0_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x1)|value)
}
func (o *EVENTROUTER_Type) GetEDGE_WAKEUP0_E() uint32 {
	return volatile.LoadUint32(&o.EDGE.Reg) & 0x1
}
func (o *EVENTROUTER_Type) SetEDGE_WAKEUP1_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x2)|value<<1)
}
func (o *EVENTROUTER_Type) GetEDGE_WAKEUP1_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x2) >> 1
}
func (o *EVENTROUTER_Type) SetEDGE_WAKEUP2_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x4)|value<<2)
}
func (o *EVENTROUTER_Type) GetEDGE_WAKEUP2_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x4) >> 2
}
func (o *EVENTROUTER_Type) SetEDGE_WAKEUP3_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x8)|value<<3)
}
func (o *EVENTROUTER_Type) GetEDGE_WAKEUP3_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x8) >> 3
}
func (o *EVENTROUTER_Type) SetEDGE_ATIMER_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x10)|value<<4)
}
func (o *EVENTROUTER_Type) GetEDGE_ATIMER_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x10) >> 4
}
func (o *EVENTROUTER_Type) SetEDGE_RTC_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x20)|value<<5)
}
func (o *EVENTROUTER_Type) GetEDGE_RTC_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x20) >> 5
}
func (o *EVENTROUTER_Type) SetEDGE_BOD_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x40)|value<<6)
}
func (o *EVENTROUTER_Type) GetEDGE_BOD_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x40) >> 6
}
func (o *EVENTROUTER_Type) SetEDGE_WWDT_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x80)|value<<7)
}
func (o *EVENTROUTER_Type) GetEDGE_WWDT_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x80) >> 7
}
func (o *EVENTROUTER_Type) SetEDGE_ETH_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x100)|value<<8)
}
func (o *EVENTROUTER_Type) GetEDGE_ETH_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x100) >> 8
}
func (o *EVENTROUTER_Type) SetEDGE_USB0_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x200)|value<<9)
}
func (o *EVENTROUTER_Type) GetEDGE_USB0_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x200) >> 9
}
func (o *EVENTROUTER_Type) SetEDGE_USB1_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x400)|value<<10)
}
func (o *EVENTROUTER_Type) GetEDGE_USB1_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x400) >> 10
}
func (o *EVENTROUTER_Type) SetEDGE_SDMMC_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x800)|value<<11)
}
func (o *EVENTROUTER_Type) GetEDGE_SDMMC_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x800) >> 11
}
func (o *EVENTROUTER_Type) SetEDGE_CAN_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x1000)|value<<12)
}
func (o *EVENTROUTER_Type) GetEDGE_CAN_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x1000) >> 12
}
func (o *EVENTROUTER_Type) SetEDGE_TIM2_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x2000)|value<<13)
}
func (o *EVENTROUTER_Type) GetEDGE_TIM2_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x2000) >> 13
}
func (o *EVENTROUTER_Type) SetEDGE_TIM6_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x4000)|value<<14)
}
func (o *EVENTROUTER_Type) GetEDGE_TIM6_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x4000) >> 14
}
func (o *EVENTROUTER_Type) SetEDGE_QEI_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x8000)|value<<15)
}
func (o *EVENTROUTER_Type) GetEDGE_QEI_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x8000) >> 15
}
func (o *EVENTROUTER_Type) SetEDGE_TIM14_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x10000)|value<<16)
}
func (o *EVENTROUTER_Type) GetEDGE_TIM14_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x10000) >> 16
}
func (o *EVENTROUTER_Type) SetEDGE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x60000)|value<<17)
}
func (o *EVENTROUTER_Type) GetEDGE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x60000) >> 17
}
func (o *EVENTROUTER_Type) SetEDGE_RESET_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x80000)|value<<19)
}
func (o *EVENTROUTER_Type) GetEDGE_RESET_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x80000) >> 19
}
func (o *EVENTROUTER_Type) SetEDGE_BODRESET_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x100000)|value<<20)
}
func (o *EVENTROUTER_Type) GetEDGE_BODRESET_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x100000) >> 20
}
func (o *EVENTROUTER_Type) SetEDGE_DPDRESET_E(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0x200000)|value<<21)
}
func (o *EVENTROUTER_Type) GetEDGE_DPDRESET_E() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0x200000) >> 21
}
func (o *EVENTROUTER_Type) SetEDGE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EDGE.Reg, volatile.LoadUint32(&o.EDGE.Reg)&^(0xffc00000)|value<<22)
}
func (o *EVENTROUTER_Type) GetEDGE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EDGE.Reg) & 0xffc00000) >> 22
}

// EVENTROUTER.CLR_EN: Clear event enable register
func (o *EVENTROUTER_Type) SetCLR_EN_WAKEUP0_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x1)|value)
}
func (o *EVENTROUTER_Type) GetCLR_EN_WAKEUP0_CLREN() uint32 {
	return volatile.LoadUint32(&o.CLR_EN.Reg) & 0x1
}
func (o *EVENTROUTER_Type) SetCLR_EN_WAKEUP1_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x2)|value<<1)
}
func (o *EVENTROUTER_Type) GetCLR_EN_WAKEUP1_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x2) >> 1
}
func (o *EVENTROUTER_Type) SetCLR_EN_WAKEUP2_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x4)|value<<2)
}
func (o *EVENTROUTER_Type) GetCLR_EN_WAKEUP2_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x4) >> 2
}
func (o *EVENTROUTER_Type) SetCLR_EN_WAKEUP3_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x8)|value<<3)
}
func (o *EVENTROUTER_Type) GetCLR_EN_WAKEUP3_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x8) >> 3
}
func (o *EVENTROUTER_Type) SetCLR_EN_ATIMER_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x10)|value<<4)
}
func (o *EVENTROUTER_Type) GetCLR_EN_ATIMER_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x10) >> 4
}
func (o *EVENTROUTER_Type) SetCLR_EN_RTC_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x20)|value<<5)
}
func (o *EVENTROUTER_Type) GetCLR_EN_RTC_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x20) >> 5
}
func (o *EVENTROUTER_Type) SetCLR_EN_BOD_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x40)|value<<6)
}
func (o *EVENTROUTER_Type) GetCLR_EN_BOD_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x40) >> 6
}
func (o *EVENTROUTER_Type) SetCLR_EN_WWDT_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x80)|value<<7)
}
func (o *EVENTROUTER_Type) GetCLR_EN_WWDT_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x80) >> 7
}
func (o *EVENTROUTER_Type) SetCLR_EN_ETH_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x100)|value<<8)
}
func (o *EVENTROUTER_Type) GetCLR_EN_ETH_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x100) >> 8
}
func (o *EVENTROUTER_Type) SetCLR_EN_USB0_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x200)|value<<9)
}
func (o *EVENTROUTER_Type) GetCLR_EN_USB0_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x200) >> 9
}
func (o *EVENTROUTER_Type) SetCLR_EN_USB1_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x400)|value<<10)
}
func (o *EVENTROUTER_Type) GetCLR_EN_USB1_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x400) >> 10
}
func (o *EVENTROUTER_Type) SetCLR_EN_SDMMC_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x800)|value<<11)
}
func (o *EVENTROUTER_Type) GetCLR_EN_SDMMC_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x800) >> 11
}
func (o *EVENTROUTER_Type) SetCLR_EN_CAN_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x1000)|value<<12)
}
func (o *EVENTROUTER_Type) GetCLR_EN_CAN_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x1000) >> 12
}
func (o *EVENTROUTER_Type) SetCLR_EN_TIM2_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x2000)|value<<13)
}
func (o *EVENTROUTER_Type) GetCLR_EN_TIM2_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x2000) >> 13
}
func (o *EVENTROUTER_Type) SetCLR_EN_TIM6_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x4000)|value<<14)
}
func (o *EVENTROUTER_Type) GetCLR_EN_TIM6_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x4000) >> 14
}
func (o *EVENTROUTER_Type) SetCLR_EN_QEI_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x8000)|value<<15)
}
func (o *EVENTROUTER_Type) GetCLR_EN_QEI_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x8000) >> 15
}
func (o *EVENTROUTER_Type) SetCLR_EN_TIM14_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x10000)|value<<16)
}
func (o *EVENTROUTER_Type) GetCLR_EN_TIM14_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x10000) >> 16
}
func (o *EVENTROUTER_Type) SetCLR_EN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x60000)|value<<17)
}
func (o *EVENTROUTER_Type) GetCLR_EN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x60000) >> 17
}
func (o *EVENTROUTER_Type) SetCLR_EN_RESET_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x80000)|value<<19)
}
func (o *EVENTROUTER_Type) GetCLR_EN_RESET_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x80000) >> 19
}
func (o *EVENTROUTER_Type) SetCLR_EN_BODRESET_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x100000)|value<<20)
}
func (o *EVENTROUTER_Type) GetCLR_EN_BODRESET_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x100000) >> 20
}
func (o *EVENTROUTER_Type) SetCLR_EN_DPDRESET_CLREN(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0x200000)|value<<21)
}
func (o *EVENTROUTER_Type) GetCLR_EN_DPDRESET_CLREN() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0x200000) >> 21
}
func (o *EVENTROUTER_Type) SetCLR_EN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLR_EN.Reg, volatile.LoadUint32(&o.CLR_EN.Reg)&^(0xffc00000)|value<<22)
}
func (o *EVENTROUTER_Type) GetCLR_EN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLR_EN.Reg) & 0xffc00000) >> 22
}

// EVENTROUTER.SET_EN: Set event enable register
func (o *EVENTROUTER_Type) SetSET_EN_WAKEUP0_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x1)|value)
}
func (o *EVENTROUTER_Type) GetSET_EN_WAKEUP0_SETEN() uint32 {
	return volatile.LoadUint32(&o.SET_EN.Reg) & 0x1
}
func (o *EVENTROUTER_Type) SetSET_EN_WAKEUP1_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x2)|value<<1)
}
func (o *EVENTROUTER_Type) GetSET_EN_WAKEUP1_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x2) >> 1
}
func (o *EVENTROUTER_Type) SetSET_EN_WAKEUP2_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x4)|value<<2)
}
func (o *EVENTROUTER_Type) GetSET_EN_WAKEUP2_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x4) >> 2
}
func (o *EVENTROUTER_Type) SetSET_EN_WAKEUP3_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x8)|value<<3)
}
func (o *EVENTROUTER_Type) GetSET_EN_WAKEUP3_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x8) >> 3
}
func (o *EVENTROUTER_Type) SetSET_EN_ATIMER_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x10)|value<<4)
}
func (o *EVENTROUTER_Type) GetSET_EN_ATIMER_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x10) >> 4
}
func (o *EVENTROUTER_Type) SetSET_EN_RTC_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x20)|value<<5)
}
func (o *EVENTROUTER_Type) GetSET_EN_RTC_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x20) >> 5
}
func (o *EVENTROUTER_Type) SetSET_EN_BOD_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x40)|value<<6)
}
func (o *EVENTROUTER_Type) GetSET_EN_BOD_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x40) >> 6
}
func (o *EVENTROUTER_Type) SetSET_EN_WWDT_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x80)|value<<7)
}
func (o *EVENTROUTER_Type) GetSET_EN_WWDT_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x80) >> 7
}
func (o *EVENTROUTER_Type) SetSET_EN_ETH_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x100)|value<<8)
}
func (o *EVENTROUTER_Type) GetSET_EN_ETH_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x100) >> 8
}
func (o *EVENTROUTER_Type) SetSET_EN_USB0_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x200)|value<<9)
}
func (o *EVENTROUTER_Type) GetSET_EN_USB0_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x200) >> 9
}
func (o *EVENTROUTER_Type) SetSET_EN_USB1_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x400)|value<<10)
}
func (o *EVENTROUTER_Type) GetSET_EN_USB1_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x400) >> 10
}
func (o *EVENTROUTER_Type) SetSET_EN_SDMMC_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x800)|value<<11)
}
func (o *EVENTROUTER_Type) GetSET_EN_SDMMC_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x800) >> 11
}
func (o *EVENTROUTER_Type) SetSET_EN_CAN_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x1000)|value<<12)
}
func (o *EVENTROUTER_Type) GetSET_EN_CAN_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x1000) >> 12
}
func (o *EVENTROUTER_Type) SetSET_EN_TIM2_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x2000)|value<<13)
}
func (o *EVENTROUTER_Type) GetSET_EN_TIM2_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x2000) >> 13
}
func (o *EVENTROUTER_Type) SetSET_EN_TIM6_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x4000)|value<<14)
}
func (o *EVENTROUTER_Type) GetSET_EN_TIM6_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x4000) >> 14
}
func (o *EVENTROUTER_Type) SetSET_EN_QEI_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x8000)|value<<15)
}
func (o *EVENTROUTER_Type) GetSET_EN_QEI_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x8000) >> 15
}
func (o *EVENTROUTER_Type) SetSET_EN_TIM14_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x10000)|value<<16)
}
func (o *EVENTROUTER_Type) GetSET_EN_TIM14_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x10000) >> 16
}
func (o *EVENTROUTER_Type) SetSET_EN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x60000)|value<<17)
}
func (o *EVENTROUTER_Type) GetSET_EN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x60000) >> 17
}
func (o *EVENTROUTER_Type) SetSET_EN_RESET_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x80000)|value<<19)
}
func (o *EVENTROUTER_Type) GetSET_EN_RESET_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x80000) >> 19
}
func (o *EVENTROUTER_Type) SetSET_EN_BODRESET_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x100000)|value<<20)
}
func (o *EVENTROUTER_Type) GetSET_EN_BODRESET_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x100000) >> 20
}
func (o *EVENTROUTER_Type) SetSET_EN_DPDRESET_SETEN(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0x200000)|value<<21)
}
func (o *EVENTROUTER_Type) GetSET_EN_DPDRESET_SETEN() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0x200000) >> 21
}
func (o *EVENTROUTER_Type) SetSET_EN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SET_EN.Reg, volatile.LoadUint32(&o.SET_EN.Reg)&^(0xffc00000)|value<<22)
}
func (o *EVENTROUTER_Type) GetSET_EN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SET_EN.Reg) & 0xffc00000) >> 22
}

// EVENTROUTER.STATUS: Event Status register
func (o *EVENTROUTER_Type) SetSTATUS_WAKEUP0_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *EVENTROUTER_Type) GetSTATUS_WAKEUP0_ST() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *EVENTROUTER_Type) SetSTATUS_WAKEUP1_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *EVENTROUTER_Type) GetSTATUS_WAKEUP1_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *EVENTROUTER_Type) SetSTATUS_WAKEUP2_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *EVENTROUTER_Type) GetSTATUS_WAKEUP2_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *EVENTROUTER_Type) SetSTATUS_WAKEUP3_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *EVENTROUTER_Type) GetSTATUS_WAKEUP3_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *EVENTROUTER_Type) SetSTATUS_ATIMER_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *EVENTROUTER_Type) GetSTATUS_ATIMER_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *EVENTROUTER_Type) SetSTATUS_RTC_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *EVENTROUTER_Type) GetSTATUS_RTC_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *EVENTROUTER_Type) SetSTATUS_BOD_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *EVENTROUTER_Type) GetSTATUS_BOD_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *EVENTROUTER_Type) SetSTATUS_WWDT_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *EVENTROUTER_Type) GetSTATUS_WWDT_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *EVENTROUTER_Type) SetSTATUS_ETH_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *EVENTROUTER_Type) GetSTATUS_ETH_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *EVENTROUTER_Type) SetSTATUS_USB0_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *EVENTROUTER_Type) GetSTATUS_USB0_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *EVENTROUTER_Type) SetSTATUS_USB1_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *EVENTROUTER_Type) GetSTATUS_USB1_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}
func (o *EVENTROUTER_Type) SetSTATUS_SDMMC_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x800)|value<<11)
}
func (o *EVENTROUTER_Type) GetSTATUS_SDMMC_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x800) >> 11
}
func (o *EVENTROUTER_Type) SetSTATUS_CAN_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *EVENTROUTER_Type) GetSTATUS_CAN_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000) >> 12
}
func (o *EVENTROUTER_Type) SetSTATUS_TIM2_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *EVENTROUTER_Type) GetSTATUS_TIM2_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2000) >> 13
}
func (o *EVENTROUTER_Type) SetSTATUS_TIM6_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *EVENTROUTER_Type) GetSTATUS_TIM6_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4000) >> 14
}
func (o *EVENTROUTER_Type) SetSTATUS_QEI_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *EVENTROUTER_Type) GetSTATUS_QEI_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8000) >> 15
}
func (o *EVENTROUTER_Type) SetSTATUS_TIM14_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *EVENTROUTER_Type) GetSTATUS_TIM14_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10000) >> 16
}
func (o *EVENTROUTER_Type) SetSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x60000)|value<<17)
}
func (o *EVENTROUTER_Type) GetSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x60000) >> 17
}
func (o *EVENTROUTER_Type) SetSTATUS_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *EVENTROUTER_Type) GetSTATUS_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000) >> 19
}
func (o *EVENTROUTER_Type) SetSTATUS_BODRESET_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100000)|value<<20)
}
func (o *EVENTROUTER_Type) GetSTATUS_BODRESET_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100000) >> 20
}
func (o *EVENTROUTER_Type) SetSTATUS_DPDRESET_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *EVENTROUTER_Type) GetSTATUS_DPDRESET_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200000) >> 21
}
func (o *EVENTROUTER_Type) SetSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xffc00000)|value<<22)
}
func (o *EVENTROUTER_Type) GetSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xffc00000) >> 22
}

// EVENTROUTER.ENABLE: Event Enable register
func (o *EVENTROUTER_Type) SetENABLE_WAKEUP0_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *EVENTROUTER_Type) GetENABLE_WAKEUP0_EN() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}
func (o *EVENTROUTER_Type) SetENABLE_WAKEUP1_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x2)|value<<1)
}
func (o *EVENTROUTER_Type) GetENABLE_WAKEUP1_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x2) >> 1
}
func (o *EVENTROUTER_Type) SetENABLE_WAKEUP2_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x4)|value<<2)
}
func (o *EVENTROUTER_Type) GetENABLE_WAKEUP2_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x4) >> 2
}
func (o *EVENTROUTER_Type) SetENABLE_WAKEUP3_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x8)|value<<3)
}
func (o *EVENTROUTER_Type) GetENABLE_WAKEUP3_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x8) >> 3
}
func (o *EVENTROUTER_Type) SetENABLE_ATIMER_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x10)|value<<4)
}
func (o *EVENTROUTER_Type) GetENABLE_ATIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x10) >> 4
}
func (o *EVENTROUTER_Type) SetENABLE_RTC_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x20)|value<<5)
}
func (o *EVENTROUTER_Type) GetENABLE_RTC_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x20) >> 5
}
func (o *EVENTROUTER_Type) SetENABLE_BOD_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x40)|value<<6)
}
func (o *EVENTROUTER_Type) GetENABLE_BOD_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x40) >> 6
}
func (o *EVENTROUTER_Type) SetENABLE_WWDT_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x80)|value<<7)
}
func (o *EVENTROUTER_Type) GetENABLE_WWDT_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x80) >> 7
}
func (o *EVENTROUTER_Type) SetENABLE_ETH_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x100)|value<<8)
}
func (o *EVENTROUTER_Type) GetENABLE_ETH_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x100) >> 8
}
func (o *EVENTROUTER_Type) SetENABLE_USB0_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x200)|value<<9)
}
func (o *EVENTROUTER_Type) GetENABLE_USB0_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x200) >> 9
}
func (o *EVENTROUTER_Type) SetENABLE_USB1_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x400)|value<<10)
}
func (o *EVENTROUTER_Type) GetENABLE_USB1_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x400) >> 10
}
func (o *EVENTROUTER_Type) SetENABLE_SDMMC_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x800)|value<<11)
}
func (o *EVENTROUTER_Type) GetENABLE_SDMMC_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x800) >> 11
}
func (o *EVENTROUTER_Type) SetENABLE_CAN_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1000)|value<<12)
}
func (o *EVENTROUTER_Type) GetENABLE_CAN_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x1000) >> 12
}
func (o *EVENTROUTER_Type) SetENABLE_TIM2_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x2000)|value<<13)
}
func (o *EVENTROUTER_Type) GetENABLE_TIM2_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x2000) >> 13
}
func (o *EVENTROUTER_Type) SetENABLE_TIM6_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x4000)|value<<14)
}
func (o *EVENTROUTER_Type) GetENABLE_TIM6_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x4000) >> 14
}
func (o *EVENTROUTER_Type) SetENABLE_QEI_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x8000)|value<<15)
}
func (o *EVENTROUTER_Type) GetENABLE_QEI_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x8000) >> 15
}
func (o *EVENTROUTER_Type) SetENABLE_TIM14_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x10000)|value<<16)
}
func (o *EVENTROUTER_Type) GetENABLE_TIM14_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x10000) >> 16
}
func (o *EVENTROUTER_Type) SetENABLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x60000)|value<<17)
}
func (o *EVENTROUTER_Type) GetENABLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x60000) >> 17
}
func (o *EVENTROUTER_Type) SetENABLE_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x80000)|value<<19)
}
func (o *EVENTROUTER_Type) GetENABLE_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x80000) >> 19
}
func (o *EVENTROUTER_Type) SetENABLE_BODRESET_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x100000)|value<<20)
}
func (o *EVENTROUTER_Type) GetENABLE_BODRESET_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x100000) >> 20
}
func (o *EVENTROUTER_Type) SetENABLE_DPDRESET_EN(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x200000)|value<<21)
}
func (o *EVENTROUTER_Type) GetENABLE_DPDRESET_EN() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0x200000) >> 21
}
func (o *EVENTROUTER_Type) SetENABLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xffc00000)|value<<22)
}
func (o *EVENTROUTER_Type) GetENABLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENABLE.Reg) & 0xffc00000) >> 22
}

// EVENTROUTER.CLR_STAT: Clear event status register
func (o *EVENTROUTER_Type) SetCLR_STAT_WAKEUP0_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x1)|value)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_WAKEUP0_CLRST() uint32 {
	return volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x1
}
func (o *EVENTROUTER_Type) SetCLR_STAT_WAKEUP1_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x2)|value<<1)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_WAKEUP1_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x2) >> 1
}
func (o *EVENTROUTER_Type) SetCLR_STAT_WAKEUP2_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x4)|value<<2)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_WAKEUP2_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x4) >> 2
}
func (o *EVENTROUTER_Type) SetCLR_STAT_WAKEUP3_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x8)|value<<3)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_WAKEUP3_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x8) >> 3
}
func (o *EVENTROUTER_Type) SetCLR_STAT_ATIMER_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x10)|value<<4)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_ATIMER_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x10) >> 4
}
func (o *EVENTROUTER_Type) SetCLR_STAT_RTC_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x20)|value<<5)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_RTC_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x20) >> 5
}
func (o *EVENTROUTER_Type) SetCLR_STAT_BOD_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x40)|value<<6)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_BOD_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x40) >> 6
}
func (o *EVENTROUTER_Type) SetCLR_STAT_WWDT_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x80)|value<<7)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_WWDT_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x80) >> 7
}
func (o *EVENTROUTER_Type) SetCLR_STAT_ETH_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x100)|value<<8)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_ETH_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x100) >> 8
}
func (o *EVENTROUTER_Type) SetCLR_STAT_USB0_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x200)|value<<9)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_USB0_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x200) >> 9
}
func (o *EVENTROUTER_Type) SetCLR_STAT_USB1_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x400)|value<<10)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_USB1_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x400) >> 10
}
func (o *EVENTROUTER_Type) SetCLR_STAT_SDMMC_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x800)|value<<11)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_SDMMC_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x800) >> 11
}
func (o *EVENTROUTER_Type) SetCLR_STAT_CAN_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x1000)|value<<12)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_CAN_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x1000) >> 12
}
func (o *EVENTROUTER_Type) SetCLR_STAT_TIM2_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x2000)|value<<13)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_TIM2_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x2000) >> 13
}
func (o *EVENTROUTER_Type) SetCLR_STAT_TIM6_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x4000)|value<<14)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_TIM6_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x4000) >> 14
}
func (o *EVENTROUTER_Type) SetCLR_STAT_QEI_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x8000)|value<<15)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_QEI_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x8000) >> 15
}
func (o *EVENTROUTER_Type) SetCLR_STAT_TIM14_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x10000)|value<<16)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_TIM14_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x10000) >> 16
}
func (o *EVENTROUTER_Type) SetCLR_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x60000)|value<<17)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x60000) >> 17
}
func (o *EVENTROUTER_Type) SetCLR_STAT_RESET_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x80000)|value<<19)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_RESET_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x80000) >> 19
}
func (o *EVENTROUTER_Type) SetCLR_STAT_BODRESET_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x100000)|value<<20)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_BODRESET_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x100000) >> 20
}
func (o *EVENTROUTER_Type) SetCLR_STAT_DPDRESET_CLRST(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0x200000)|value<<21)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_DPDRESET_CLRST() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0x200000) >> 21
}
func (o *EVENTROUTER_Type) SetCLR_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLR_STAT.Reg, volatile.LoadUint32(&o.CLR_STAT.Reg)&^(0xffc00000)|value<<22)
}
func (o *EVENTROUTER_Type) GetCLR_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLR_STAT.Reg) & 0xffc00000) >> 22
}

// EVENTROUTER.SET_STAT: Set event status register
func (o *EVENTROUTER_Type) SetSET_STAT_WAKEUP0_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x1)|value)
}
func (o *EVENTROUTER_Type) GetSET_STAT_WAKEUP0_SETST() uint32 {
	return volatile.LoadUint32(&o.SET_STAT.Reg) & 0x1
}
func (o *EVENTROUTER_Type) SetSET_STAT_WAKEUP1_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x2)|value<<1)
}
func (o *EVENTROUTER_Type) GetSET_STAT_WAKEUP1_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x2) >> 1
}
func (o *EVENTROUTER_Type) SetSET_STAT_WAKEUP2_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x4)|value<<2)
}
func (o *EVENTROUTER_Type) GetSET_STAT_WAKEUP2_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x4) >> 2
}
func (o *EVENTROUTER_Type) SetSET_STAT_WAKEUP3_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x8)|value<<3)
}
func (o *EVENTROUTER_Type) GetSET_STAT_WAKEUP3_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x8) >> 3
}
func (o *EVENTROUTER_Type) SetSET_STAT_ATIMER_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x10)|value<<4)
}
func (o *EVENTROUTER_Type) GetSET_STAT_ATIMER_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x10) >> 4
}
func (o *EVENTROUTER_Type) SetSET_STAT_RTC_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x20)|value<<5)
}
func (o *EVENTROUTER_Type) GetSET_STAT_RTC_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x20) >> 5
}
func (o *EVENTROUTER_Type) SetSET_STAT_BOD_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x40)|value<<6)
}
func (o *EVENTROUTER_Type) GetSET_STAT_BOD_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x40) >> 6
}
func (o *EVENTROUTER_Type) SetSET_STAT_WWDT_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x80)|value<<7)
}
func (o *EVENTROUTER_Type) GetSET_STAT_WWDT_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x80) >> 7
}
func (o *EVENTROUTER_Type) SetSET_STAT_ETH_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x100)|value<<8)
}
func (o *EVENTROUTER_Type) GetSET_STAT_ETH_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x100) >> 8
}
func (o *EVENTROUTER_Type) SetSET_STAT_USB0_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x200)|value<<9)
}
func (o *EVENTROUTER_Type) GetSET_STAT_USB0_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x200) >> 9
}
func (o *EVENTROUTER_Type) SetSET_STAT_USB1_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x400)|value<<10)
}
func (o *EVENTROUTER_Type) GetSET_STAT_USB1_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x400) >> 10
}
func (o *EVENTROUTER_Type) SetSET_STAT_SDMMC_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x800)|value<<11)
}
func (o *EVENTROUTER_Type) GetSET_STAT_SDMMC_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x800) >> 11
}
func (o *EVENTROUTER_Type) SetSET_STAT_CAN_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x1000)|value<<12)
}
func (o *EVENTROUTER_Type) GetSET_STAT_CAN_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x1000) >> 12
}
func (o *EVENTROUTER_Type) SetSET_STAT_TIM2_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x2000)|value<<13)
}
func (o *EVENTROUTER_Type) GetSET_STAT_TIM2_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x2000) >> 13
}
func (o *EVENTROUTER_Type) SetSET_STAT_TIM6_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x4000)|value<<14)
}
func (o *EVENTROUTER_Type) GetSET_STAT_TIM6_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x4000) >> 14
}
func (o *EVENTROUTER_Type) SetSET_STAT_QEI_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x8000)|value<<15)
}
func (o *EVENTROUTER_Type) GetSET_STAT_QEI_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x8000) >> 15
}
func (o *EVENTROUTER_Type) SetSET_STAT_TIM14_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x10000)|value<<16)
}
func (o *EVENTROUTER_Type) GetSET_STAT_TIM14_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x10000) >> 16
}
func (o *EVENTROUTER_Type) SetSET_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x60000)|value<<17)
}
func (o *EVENTROUTER_Type) GetSET_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x60000) >> 17
}
func (o *EVENTROUTER_Type) SetSET_STAT_RESET_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x80000)|value<<19)
}
func (o *EVENTROUTER_Type) GetSET_STAT_RESET_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x80000) >> 19
}
func (o *EVENTROUTER_Type) SetSET_STAT_BODRESET_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x100000)|value<<20)
}
func (o *EVENTROUTER_Type) GetSET_STAT_BODRESET_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x100000) >> 20
}
func (o *EVENTROUTER_Type) SetSET_STAT_DPDRESET_SETST(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0x200000)|value<<21)
}
func (o *EVENTROUTER_Type) GetSET_STAT_DPDRESET_SETST() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0x200000) >> 21
}
func (o *EVENTROUTER_Type) SetSET_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SET_STAT.Reg, volatile.LoadUint32(&o.SET_STAT.Reg)&^(0xffc00000)|value<<22)
}
func (o *EVENTROUTER_Type) GetSET_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SET_STAT.Reg) & 0xffc00000) >> 22
}

// Real-Time Clock (RTC) and event recorder
type RTC_Type struct {
	ILR           volatile.Register32 // 0x0
	_             [4]byte
	CCR           volatile.Register32 // 0x8
	CIIR          volatile.Register32 // 0xC
	AMR           volatile.Register32 // 0x10
	CTIME0        volatile.Register32 // 0x14
	CTIME1        volatile.Register32 // 0x18
	CTIME2        volatile.Register32 // 0x1C
	SEC           volatile.Register32 // 0x20
	MIN           volatile.Register32 // 0x24
	HRS           volatile.Register32 // 0x28
	DOM           volatile.Register32 // 0x2C
	DOW           volatile.Register32 // 0x30
	DOY           volatile.Register32 // 0x34
	MONTH         volatile.Register32 // 0x38
	YEAR          volatile.Register32 // 0x3C
	CALIBRATION   volatile.Register32 // 0x40
	_             [28]byte
	ASEC          volatile.Register32 // 0x60
	AMIN          volatile.Register32 // 0x64
	AHRS          volatile.Register32 // 0x68
	ADOM          volatile.Register32 // 0x6C
	ADOW          volatile.Register32 // 0x70
	ADOY          volatile.Register32 // 0x74
	AMON          volatile.Register32 // 0x78
	AYRS          volatile.Register32 // 0x7C
	ERSTATUS      volatile.Register32 // 0x80
	ERCONTRO      volatile.Register32 // 0x84
	ERCOUNTERS    volatile.Register32 // 0x88
	_             [4]byte
	ERFIRSTSTAMP0 volatile.Register32 // 0x90
	ERFIRSTSTAMP1 volatile.Register32 // 0x94
	ERFIRSTSTAMP2 volatile.Register32 // 0x98
	_             [4]byte
	ERLASTSTAMP0  volatile.Register32 // 0xA0
	ERLASTSTAMP1  volatile.Register32 // 0xA4
	ERLASTSTAMP2  volatile.Register32 // 0xA8
}

// RTC.ILR: Interrupt Location Register
func (o *RTC_Type) SetILR_RTCCIF(value uint32) {
	volatile.StoreUint32(&o.ILR.Reg, volatile.LoadUint32(&o.ILR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetILR_RTCCIF() uint32 {
	return volatile.LoadUint32(&o.ILR.Reg) & 0x1
}
func (o *RTC_Type) SetILR_RTCALF(value uint32) {
	volatile.StoreUint32(&o.ILR.Reg, volatile.LoadUint32(&o.ILR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetILR_RTCALF() uint32 {
	return (volatile.LoadUint32(&o.ILR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetILR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ILR.Reg, volatile.LoadUint32(&o.ILR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *RTC_Type) GetILR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ILR.Reg) & 0xfffffffc) >> 2
}

// RTC.CCR: Clock Control Register
func (o *RTC_Type) SetCCR_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCCR_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *RTC_Type) SetCCR_CTCRST(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCCR_CTCRST() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xc)|value<<2)
}
func (o *RTC_Type) GetCCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xc) >> 2
}
func (o *RTC_Type) SetCCR_CCALEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCCR_CCALEN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetCCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xffffffe0) >> 5
}

// RTC.CIIR: Counter Increment Interrupt Register
func (o *RTC_Type) SetCIIR_IMSEC(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCIIR_IMSEC() uint32 {
	return volatile.LoadUint32(&o.CIIR.Reg) & 0x1
}
func (o *RTC_Type) SetCIIR_IMMIN(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCIIR_IMMIN() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCIIR_IMHOUR(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetCIIR_IMHOUR() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetCIIR_IMDOM(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCIIR_IMDOM() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetCIIR_IMDOW(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCIIR_IMDOW() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCIIR_IMDOY(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetCIIR_IMDOY() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetCIIR_IMMON(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetCIIR_IMMON() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetCIIR_IMYEAR(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetCIIR_IMYEAR() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetCIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0xffffff00)|value<<8)
}
func (o *RTC_Type) GetCIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0xffffff00) >> 8
}

// RTC.AMR: Alarm Mask Register
func (o *RTC_Type) SetAMR_AMRSEC(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetAMR_AMRSEC() uint32 {
	return volatile.LoadUint32(&o.AMR.Reg) & 0x1
}
func (o *RTC_Type) SetAMR_AMRMIN(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetAMR_AMRMIN() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetAMR_AMRHOUR(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetAMR_AMRHOUR() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetAMR_AMRDOM(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetAMR_AMRDOM() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetAMR_AMRDOW(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetAMR_AMRDOW() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetAMR_AMRDOY(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetAMR_AMRDOY() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetAMR_AMRMON(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetAMR_AMRMON() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetAMR_AMRYEAR(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetAMR_AMRYEAR() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetAMR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *RTC_Type) GetAMR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0xffffff00) >> 8
}

// RTC.CTIME0: Consolidated Time Register 0
func (o *RTC_Type) SetCTIME0_SECONDS(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetCTIME0_SECONDS() uint32 {
	return volatile.LoadUint32(&o.CTIME0.Reg) & 0x3f
}
func (o *RTC_Type) SetCTIME0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetCTIME0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0xc0) >> 6
}
func (o *RTC_Type) SetCTIME0_MINUTES(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0x3f00)|value<<8)
}
func (o *RTC_Type) GetCTIME0_MINUTES() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0x3f00) >> 8
}
func (o *RTC_Type) SetCTIME0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0xc000)|value<<14)
}
func (o *RTC_Type) GetCTIME0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0xc000) >> 14
}
func (o *RTC_Type) SetCTIME0_HOURS(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0x1f0000)|value<<16)
}
func (o *RTC_Type) GetCTIME0_HOURS() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0x1f0000) >> 16
}
func (o *RTC_Type) SetCTIME0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0xe00000)|value<<21)
}
func (o *RTC_Type) GetCTIME0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0xe00000) >> 21
}
func (o *RTC_Type) SetCTIME0_DOW(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0x7000000)|value<<24)
}
func (o *RTC_Type) GetCTIME0_DOW() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0x7000000) >> 24
}
func (o *RTC_Type) SetCTIME0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0xf8000000)|value<<27)
}
func (o *RTC_Type) GetCTIME0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0xf8000000) >> 27
}

// RTC.CTIME1: Consolidated Time Register 1
func (o *RTC_Type) SetCTIME1_DOM(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetCTIME1_DOM() uint32 {
	return volatile.LoadUint32(&o.CTIME1.Reg) & 0x1f
}
func (o *RTC_Type) SetCTIME1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xe0)|value<<5)
}
func (o *RTC_Type) GetCTIME1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xe0) >> 5
}
func (o *RTC_Type) SetCTIME1_MONTH(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetCTIME1_MONTH() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetCTIME1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xf000)|value<<12)
}
func (o *RTC_Type) GetCTIME1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xf000) >> 12
}
func (o *RTC_Type) SetCTIME1_YEAR(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xfff0000)|value<<16)
}
func (o *RTC_Type) GetCTIME1_YEAR() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xfff0000) >> 16
}
func (o *RTC_Type) SetCTIME1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xf0000000)|value<<28)
}
func (o *RTC_Type) GetCTIME1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xf0000000) >> 28
}

// RTC.CTIME2: Consolidated Time Register 2
func (o *RTC_Type) SetCTIME2_DOY(value uint32) {
	volatile.StoreUint32(&o.CTIME2.Reg, volatile.LoadUint32(&o.CTIME2.Reg)&^(0xfff)|value)
}
func (o *RTC_Type) GetCTIME2_DOY() uint32 {
	return volatile.LoadUint32(&o.CTIME2.Reg) & 0xfff
}
func (o *RTC_Type) SetCTIME2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME2.Reg, volatile.LoadUint32(&o.CTIME2.Reg)&^(0xfffff000)|value<<12)
}
func (o *RTC_Type) GetCTIME2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME2.Reg) & 0xfffff000) >> 12
}

// RTC.SEC: Seconds Register
func (o *RTC_Type) SetSEC_SECONDS(value uint32) {
	volatile.StoreUint32(&o.SEC.Reg, volatile.LoadUint32(&o.SEC.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetSEC_SECONDS() uint32 {
	return volatile.LoadUint32(&o.SEC.Reg) & 0x3f
}
func (o *RTC_Type) SetSEC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SEC.Reg, volatile.LoadUint32(&o.SEC.Reg)&^(0xffffffc0)|value<<6)
}
func (o *RTC_Type) GetSEC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SEC.Reg) & 0xffffffc0) >> 6
}

// RTC.MIN: Minutes Register
func (o *RTC_Type) SetMIN_MINUTES(value uint32) {
	volatile.StoreUint32(&o.MIN.Reg, volatile.LoadUint32(&o.MIN.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetMIN_MINUTES() uint32 {
	return volatile.LoadUint32(&o.MIN.Reg) & 0x3f
}
func (o *RTC_Type) SetMIN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MIN.Reg, volatile.LoadUint32(&o.MIN.Reg)&^(0xffffffc0)|value<<6)
}
func (o *RTC_Type) GetMIN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MIN.Reg) & 0xffffffc0) >> 6
}

// RTC.HRS: Hours Register
func (o *RTC_Type) SetHRS_HOURS(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetHRS_HOURS() uint32 {
	return volatile.LoadUint32(&o.HRS.Reg) & 0x1f
}
func (o *RTC_Type) SetHRS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetHRS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0xffffffe0) >> 5
}

// RTC.DOM: Day of Month Register
func (o *RTC_Type) SetDOM(value uint32) {
	volatile.StoreUint32(&o.DOM.Reg, volatile.LoadUint32(&o.DOM.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetDOM() uint32 {
	return volatile.LoadUint32(&o.DOM.Reg) & 0x1f
}
func (o *RTC_Type) SetDOM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DOM.Reg, volatile.LoadUint32(&o.DOM.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetDOM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DOM.Reg) & 0xffffffe0) >> 5
}

// RTC.DOW: Day of Week Register
func (o *RTC_Type) SetDOW(value uint32) {
	volatile.StoreUint32(&o.DOW.Reg, volatile.LoadUint32(&o.DOW.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetDOW() uint32 {
	return volatile.LoadUint32(&o.DOW.Reg) & 0x7
}
func (o *RTC_Type) SetDOW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DOW.Reg, volatile.LoadUint32(&o.DOW.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RTC_Type) GetDOW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DOW.Reg) & 0xfffffff8) >> 3
}

// RTC.DOY: Day of Year Register
func (o *RTC_Type) SetDOY(value uint32) {
	volatile.StoreUint32(&o.DOY.Reg, volatile.LoadUint32(&o.DOY.Reg)&^(0x1ff)|value)
}
func (o *RTC_Type) GetDOY() uint32 {
	return volatile.LoadUint32(&o.DOY.Reg) & 0x1ff
}
func (o *RTC_Type) SetDOY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DOY.Reg, volatile.LoadUint32(&o.DOY.Reg)&^(0xfffffe00)|value<<9)
}
func (o *RTC_Type) GetDOY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DOY.Reg) & 0xfffffe00) >> 9
}

// RTC.MONTH: Months Register
func (o *RTC_Type) SetMONTH(value uint32) {
	volatile.StoreUint32(&o.MONTH.Reg, volatile.LoadUint32(&o.MONTH.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetMONTH() uint32 {
	return volatile.LoadUint32(&o.MONTH.Reg) & 0xf
}
func (o *RTC_Type) SetMONTH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MONTH.Reg, volatile.LoadUint32(&o.MONTH.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RTC_Type) GetMONTH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MONTH.Reg) & 0xfffffff0) >> 4
}

// RTC.YEAR: Years Register
func (o *RTC_Type) SetYEAR(value uint32) {
	volatile.StoreUint32(&o.YEAR.Reg, volatile.LoadUint32(&o.YEAR.Reg)&^(0xfff)|value)
}
func (o *RTC_Type) GetYEAR() uint32 {
	return volatile.LoadUint32(&o.YEAR.Reg) & 0xfff
}
func (o *RTC_Type) SetYEAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.YEAR.Reg, volatile.LoadUint32(&o.YEAR.Reg)&^(0xfffff000)|value<<12)
}
func (o *RTC_Type) GetYEAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.YEAR.Reg) & 0xfffff000) >> 12
}

// RTC.CALIBRATION: Calibration Value Register
func (o *RTC_Type) SetCALIBRATION_CALVAL(value uint32) {
	volatile.StoreUint32(&o.CALIBRATION.Reg, volatile.LoadUint32(&o.CALIBRATION.Reg)&^(0x1ffff)|value)
}
func (o *RTC_Type) GetCALIBRATION_CALVAL() uint32 {
	return volatile.LoadUint32(&o.CALIBRATION.Reg) & 0x1ffff
}
func (o *RTC_Type) SetCALIBRATION_CALDIR(value uint32) {
	volatile.StoreUint32(&o.CALIBRATION.Reg, volatile.LoadUint32(&o.CALIBRATION.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetCALIBRATION_CALDIR() uint32 {
	return (volatile.LoadUint32(&o.CALIBRATION.Reg) & 0x20000) >> 17
}

// RTC.ASEC: Alarm value for Seconds
func (o *RTC_Type) SetASEC_SECONDS(value uint32) {
	volatile.StoreUint32(&o.ASEC.Reg, volatile.LoadUint32(&o.ASEC.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetASEC_SECONDS() uint32 {
	return volatile.LoadUint32(&o.ASEC.Reg) & 0x3f
}
func (o *RTC_Type) SetASEC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ASEC.Reg, volatile.LoadUint32(&o.ASEC.Reg)&^(0xffffffc0)|value<<6)
}
func (o *RTC_Type) GetASEC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ASEC.Reg) & 0xffffffc0) >> 6
}

// RTC.AMIN: Alarm value for Minutes
func (o *RTC_Type) SetAMIN_MINUTES(value uint32) {
	volatile.StoreUint32(&o.AMIN.Reg, volatile.LoadUint32(&o.AMIN.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetAMIN_MINUTES() uint32 {
	return volatile.LoadUint32(&o.AMIN.Reg) & 0x3f
}
func (o *RTC_Type) SetAMIN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AMIN.Reg, volatile.LoadUint32(&o.AMIN.Reg)&^(0xffffffc0)|value<<6)
}
func (o *RTC_Type) GetAMIN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AMIN.Reg) & 0xffffffc0) >> 6
}

// RTC.AHRS: Alarm value for Hours
func (o *RTC_Type) SetAHRS_HOURS(value uint32) {
	volatile.StoreUint32(&o.AHRS.Reg, volatile.LoadUint32(&o.AHRS.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetAHRS_HOURS() uint32 {
	return volatile.LoadUint32(&o.AHRS.Reg) & 0x1f
}
func (o *RTC_Type) SetAHRS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AHRS.Reg, volatile.LoadUint32(&o.AHRS.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetAHRS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AHRS.Reg) & 0xffffffe0) >> 5
}

// RTC.ADOM: Alarm value for Day of Month
func (o *RTC_Type) SetADOM_DOM(value uint32) {
	volatile.StoreUint32(&o.ADOM.Reg, volatile.LoadUint32(&o.ADOM.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetADOM_DOM() uint32 {
	return volatile.LoadUint32(&o.ADOM.Reg) & 0x1f
}
func (o *RTC_Type) SetADOM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADOM.Reg, volatile.LoadUint32(&o.ADOM.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetADOM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADOM.Reg) & 0xffffffe0) >> 5
}

// RTC.ADOW: Alarm value for Day of Week
func (o *RTC_Type) SetADOW_DOW(value uint32) {
	volatile.StoreUint32(&o.ADOW.Reg, volatile.LoadUint32(&o.ADOW.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetADOW_DOW() uint32 {
	return volatile.LoadUint32(&o.ADOW.Reg) & 0x7
}
func (o *RTC_Type) SetADOW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADOW.Reg, volatile.LoadUint32(&o.ADOW.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RTC_Type) GetADOW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADOW.Reg) & 0xfffffff8) >> 3
}

// RTC.ADOY: Alarm value for Day of Year
func (o *RTC_Type) SetADOY_DOY(value uint32) {
	volatile.StoreUint32(&o.ADOY.Reg, volatile.LoadUint32(&o.ADOY.Reg)&^(0x1ff)|value)
}
func (o *RTC_Type) GetADOY_DOY() uint32 {
	return volatile.LoadUint32(&o.ADOY.Reg) & 0x1ff
}
func (o *RTC_Type) SetADOY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADOY.Reg, volatile.LoadUint32(&o.ADOY.Reg)&^(0xfffffe00)|value<<9)
}
func (o *RTC_Type) GetADOY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADOY.Reg) & 0xfffffe00) >> 9
}

// RTC.AMON: Alarm value for Months
func (o *RTC_Type) SetAMON_MONTH(value uint32) {
	volatile.StoreUint32(&o.AMON.Reg, volatile.LoadUint32(&o.AMON.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetAMON_MONTH() uint32 {
	return volatile.LoadUint32(&o.AMON.Reg) & 0xf
}
func (o *RTC_Type) SetAMON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AMON.Reg, volatile.LoadUint32(&o.AMON.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RTC_Type) GetAMON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AMON.Reg) & 0xfffffff0) >> 4
}

// RTC.AYRS: Alarm value for Year
func (o *RTC_Type) SetAYRS_YEAR(value uint32) {
	volatile.StoreUint32(&o.AYRS.Reg, volatile.LoadUint32(&o.AYRS.Reg)&^(0xfff)|value)
}
func (o *RTC_Type) GetAYRS_YEAR() uint32 {
	return volatile.LoadUint32(&o.AYRS.Reg) & 0xfff
}
func (o *RTC_Type) SetAYRS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AYRS.Reg, volatile.LoadUint32(&o.AYRS.Reg)&^(0xfffff000)|value<<12)
}
func (o *RTC_Type) GetAYRS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AYRS.Reg) & 0xfffff000) >> 12
}

// RTC.ERSTATUS: Event Monitor/Recorder Status register. Contains status flags for event channels and other Event Monitor/Recorder conditions.
func (o *RTC_Type) SetERSTATUS_EV0(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetERSTATUS_EV0() uint32 {
	return volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x1
}
func (o *RTC_Type) SetERSTATUS_EV1(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetERSTATUS_EV1() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetERSTATUS_EV2(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetERSTATUS_EV2() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetERSTATUS_GP_CLEARED(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetERSTATUS_GP_CLEARED() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetERSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x7ffffff0)|value<<4)
}
func (o *RTC_Type) GetERSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x7ffffff0) >> 4
}
func (o *RTC_Type) SetERSTATUS_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetERSTATUS_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x80000000) >> 31
}

// RTC.ERCONTRO: Event Monitor/Recorder Control register. Contains bits that control actions for the event channels as well as for Event Monitor/Recorder setup.
func (o *RTC_Type) SetERCONTRO_INTWAKE_EN0(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetERCONTRO_INTWAKE_EN0() uint32 {
	return volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x1
}
func (o *RTC_Type) SetERCONTRO_GPCLEAR_EN0(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetERCONTRO_GPCLEAR_EN0() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetERCONTRO_POL0(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetERCONTRO_POL0() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetERCONTRO_EV0_INPUT_EN(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetERCONTRO_EV0_INPUT_EN() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetERCONTRO_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x3f0)|value<<4)
}
func (o *RTC_Type) GetERCONTRO_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x3f0) >> 4
}
func (o *RTC_Type) SetERCONTRO_INTWAKE_EN1(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetERCONTRO_INTWAKE_EN1() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetERCONTRO_GPCLEAR_EN1(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetERCONTRO_GPCLEAR_EN1() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetERCONTRO_POL1(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetERCONTRO_POL1() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetERCONTRO_EV1_INPUT_EN(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetERCONTRO_EV1_INPUT_EN() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetERCONTRO_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0xfc000)|value<<14)
}
func (o *RTC_Type) GetERCONTRO_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0xfc000) >> 14
}
func (o *RTC_Type) SetERCONTRO_INTWAKE_EN2(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetERCONTRO_INTWAKE_EN2() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetERCONTRO_GPCLEAR_EN2(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_Type) GetERCONTRO_GPCLEAR_EN2() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x200000) >> 21
}
func (o *RTC_Type) SetERCONTRO_POL2(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetERCONTRO_POL2() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetERCONTRO_EV2_INPUT_EN(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetERCONTRO_EV2_INPUT_EN() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetERCONTRO_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0x3f000000)|value<<24)
}
func (o *RTC_Type) GetERCONTRO_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0x3f000000) >> 24
}
func (o *RTC_Type) SetERCONTRO_ERMODE(value uint32) {
	volatile.StoreUint32(&o.ERCONTRO.Reg, volatile.LoadUint32(&o.ERCONTRO.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTC_Type) GetERCONTRO_ERMODE() uint32 {
	return (volatile.LoadUint32(&o.ERCONTRO.Reg) & 0xc0000000) >> 30
}

// RTC.ERCOUNTERS: Event Monitor/Recorder Counters register. Allows reading the counters associated with the event channels.
func (o *RTC_Type) SetERCOUNTERS_COUNTER0(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetERCOUNTERS_COUNTER0() uint32 {
	return volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0x7
}
func (o *RTC_Type) SetERCOUNTERS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0xf8)|value<<3)
}
func (o *RTC_Type) GetERCOUNTERS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0xf8) >> 3
}
func (o *RTC_Type) SetERCOUNTERS_COUNTER1(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0x700)|value<<8)
}
func (o *RTC_Type) GetERCOUNTERS_COUNTER1() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0x700) >> 8
}
func (o *RTC_Type) SetERCOUNTERS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0xf800)|value<<11)
}
func (o *RTC_Type) GetERCOUNTERS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0xf800) >> 11
}
func (o *RTC_Type) SetERCOUNTERS_COUNTER2(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0x70000)|value<<16)
}
func (o *RTC_Type) GetERCOUNTERS_COUNTER2() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0x70000) >> 16
}
func (o *RTC_Type) SetERCOUNTERS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0xfff80000)|value<<19)
}
func (o *RTC_Type) GetERCOUNTERS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0xfff80000) >> 19
}

// RTC.ERFIRSTSTAMP0: Event Monitor/Recorder First Stamp register for channel 0. Retains the time stamp for the first event on channel 0.
func (o *RTC_Type) SetERFIRSTSTAMP0_SEC(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_SEC() uint32 {
	return volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0x3f
}
func (o *RTC_Type) SetERFIRSTSTAMP0_MIN(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERFIRSTSTAMP0_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERFIRSTSTAMP0_DOY(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERFIRSTSTAMP0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0xfc000000) >> 26
}

// RTC.ERFIRSTSTAMP1: Event Monitor/Recorder First Stamp register for channel 0. Retains the time stamp for the first event on channel 0.
func (o *RTC_Type) SetERFIRSTSTAMP1_SEC(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_SEC() uint32 {
	return volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0x3f
}
func (o *RTC_Type) SetERFIRSTSTAMP1_MIN(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERFIRSTSTAMP1_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERFIRSTSTAMP1_DOY(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERFIRSTSTAMP1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0xfc000000) >> 26
}

// RTC.ERFIRSTSTAMP2: Event Monitor/Recorder First Stamp register for channel 0. Retains the time stamp for the first event on channel 0.
func (o *RTC_Type) SetERFIRSTSTAMP2_SEC(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_SEC() uint32 {
	return volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0x3f
}
func (o *RTC_Type) SetERFIRSTSTAMP2_MIN(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERFIRSTSTAMP2_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERFIRSTSTAMP2_DOY(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERFIRSTSTAMP2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0xfc000000) >> 26
}

// RTC.ERLASTSTAMP0: Event Monitor/Recorder Last Stamp register for channel 0. Retains the time stamp for the last (i.e. most recent) event on channel 0.
func (o *RTC_Type) SetERLASTSTAMP0_SEC(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERLASTSTAMP0_SEC() uint32 {
	return volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0x3f
}
func (o *RTC_Type) SetERLASTSTAMP0_MIN(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERLASTSTAMP0_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERLASTSTAMP0_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERLASTSTAMP0_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERLASTSTAMP0_DOY(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERLASTSTAMP0_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERLASTSTAMP0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERLASTSTAMP0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0xfc000000) >> 26
}

// RTC.ERLASTSTAMP1: Event Monitor/Recorder Last Stamp register for channel 0. Retains the time stamp for the last (i.e. most recent) event on channel 0.
func (o *RTC_Type) SetERLASTSTAMP1_SEC(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERLASTSTAMP1_SEC() uint32 {
	return volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0x3f
}
func (o *RTC_Type) SetERLASTSTAMP1_MIN(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERLASTSTAMP1_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERLASTSTAMP1_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERLASTSTAMP1_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERLASTSTAMP1_DOY(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERLASTSTAMP1_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERLASTSTAMP1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERLASTSTAMP1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0xfc000000) >> 26
}

// RTC.ERLASTSTAMP2: Event Monitor/Recorder Last Stamp register for channel 0. Retains the time stamp for the last (i.e. most recent) event on channel 0.
func (o *RTC_Type) SetERLASTSTAMP2_SEC(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERLASTSTAMP2_SEC() uint32 {
	return volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0x3f
}
func (o *RTC_Type) SetERLASTSTAMP2_MIN(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERLASTSTAMP2_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERLASTSTAMP2_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERLASTSTAMP2_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERLASTSTAMP2_DOY(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERLASTSTAMP2_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERLASTSTAMP2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERLASTSTAMP2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0xfc000000) >> 26
}

// Clock Generation Unit (CGU)
type CGU_Type struct {
	_                 [20]byte
	FREQ_MON          volatile.Register32 // 0x14
	XTAL_OSC_CTRL     volatile.Register32 // 0x18
	PLL0USB_STAT      volatile.Register32 // 0x1C
	PLL0USB_CTRL      volatile.Register32 // 0x20
	PLL0USB_MDIV      volatile.Register32 // 0x24
	PLL0USB_NP_DIV    volatile.Register32 // 0x28
	PLL0AUDIO_STAT    volatile.Register32 // 0x2C
	PLL0AUDIO_CTRL    volatile.Register32 // 0x30
	PLL0AUDIO_MDIV    volatile.Register32 // 0x34
	PLL0AUDIO_NP_DIV  volatile.Register32 // 0x38
	PLL0AUDIO_FRAC    volatile.Register32 // 0x3C
	PLL1_STAT         volatile.Register32 // 0x40
	PLL1_CTRL         volatile.Register32 // 0x44
	IDIVA_CTRL        volatile.Register32 // 0x48
	IDIVB_CTRL        volatile.Register32 // 0x4C
	IDIVC_CTRL        volatile.Register32 // 0x50
	IDIVD_CTRL        volatile.Register32 // 0x54
	IDIVE_CTRL        volatile.Register32 // 0x58
	BASE_SAFE_CLK     volatile.Register32 // 0x5C
	BASE_USB0_CLK     volatile.Register32 // 0x60
	BASE_PERIPH_CLK   volatile.Register32 // 0x64
	BASE_USB1_CLK     volatile.Register32 // 0x68
	BASE_M3_CLK       volatile.Register32 // 0x6C
	BASE_SPIFI_CLK    volatile.Register32 // 0x70
	_                 [4]byte
	BASE_PHY_RX_CLK   volatile.Register32 // 0x78
	BASE_PHY_TX_CLK   volatile.Register32 // 0x7C
	BASE_APB1_CLK     volatile.Register32 // 0x80
	BASE_APB3_CLK     volatile.Register32 // 0x84
	BASE_LCD_CLK      volatile.Register32 // 0x88
	_                 [4]byte
	BASE_SDIO_CLK     volatile.Register32 // 0x90
	BASE_SSP0_CLK     volatile.Register32 // 0x94
	BASE_SSP1_CLK     volatile.Register32 // 0x98
	BASE_UART0_CLK    volatile.Register32 // 0x9C
	BASE_UART1_CLK    volatile.Register32 // 0xA0
	BASE_UART2_CLK    volatile.Register32 // 0xA4
	BASE_UART3_CLK    volatile.Register32 // 0xA8
	BASE_OUT_CLK      volatile.Register32 // 0xAC
	_                 [16]byte
	BASE_AUDIO_CLK    volatile.Register32 // 0xC0
	BASE_CGU_OUT0_CLK volatile.Register32 // 0xC4
	BASE_CGU_OUT1_CLK volatile.Register32 // 0xC8
}

// CGU.FREQ_MON: Frequency monitor register
func (o *CGU_Type) SetFREQ_MON_RCNT(value uint32) {
	volatile.StoreUint32(&o.FREQ_MON.Reg, volatile.LoadUint32(&o.FREQ_MON.Reg)&^(0x1ff)|value)
}
func (o *CGU_Type) GetFREQ_MON_RCNT() uint32 {
	return volatile.LoadUint32(&o.FREQ_MON.Reg) & 0x1ff
}
func (o *CGU_Type) SetFREQ_MON_FCNT(value uint32) {
	volatile.StoreUint32(&o.FREQ_MON.Reg, volatile.LoadUint32(&o.FREQ_MON.Reg)&^(0x7ffe00)|value<<9)
}
func (o *CGU_Type) GetFREQ_MON_FCNT() uint32 {
	return (volatile.LoadUint32(&o.FREQ_MON.Reg) & 0x7ffe00) >> 9
}
func (o *CGU_Type) SetFREQ_MON_MEAS(value uint32) {
	volatile.StoreUint32(&o.FREQ_MON.Reg, volatile.LoadUint32(&o.FREQ_MON.Reg)&^(0x800000)|value<<23)
}
func (o *CGU_Type) GetFREQ_MON_MEAS() uint32 {
	return (volatile.LoadUint32(&o.FREQ_MON.Reg) & 0x800000) >> 23
}
func (o *CGU_Type) SetFREQ_MON_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.FREQ_MON.Reg, volatile.LoadUint32(&o.FREQ_MON.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetFREQ_MON_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.FREQ_MON.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetFREQ_MON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FREQ_MON.Reg, volatile.LoadUint32(&o.FREQ_MON.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetFREQ_MON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FREQ_MON.Reg) & 0xe0000000) >> 29
}

// CGU.XTAL_OSC_CTRL: Crystal oscillator control register
func (o *CGU_Type) SetXTAL_OSC_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.XTAL_OSC_CTRL.Reg, volatile.LoadUint32(&o.XTAL_OSC_CTRL.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetXTAL_OSC_CTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.XTAL_OSC_CTRL.Reg) & 0x1
}
func (o *CGU_Type) SetXTAL_OSC_CTRL_BYPASS(value uint32) {
	volatile.StoreUint32(&o.XTAL_OSC_CTRL.Reg, volatile.LoadUint32(&o.XTAL_OSC_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetXTAL_OSC_CTRL_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.XTAL_OSC_CTRL.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetXTAL_OSC_CTRL_HF(value uint32) {
	volatile.StoreUint32(&o.XTAL_OSC_CTRL.Reg, volatile.LoadUint32(&o.XTAL_OSC_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *CGU_Type) GetXTAL_OSC_CTRL_HF() uint32 {
	return (volatile.LoadUint32(&o.XTAL_OSC_CTRL.Reg) & 0x4) >> 2
}
func (o *CGU_Type) SetXTAL_OSC_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.XTAL_OSC_CTRL.Reg, volatile.LoadUint32(&o.XTAL_OSC_CTRL.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CGU_Type) GetXTAL_OSC_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.XTAL_OSC_CTRL.Reg) & 0xfffffff8) >> 3
}

// CGU.PLL0USB_STAT: PLL0USB status register
func (o *CGU_Type) SetPLL0USB_STAT_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_STAT.Reg, volatile.LoadUint32(&o.PLL0USB_STAT.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetPLL0USB_STAT_LOCK() uint32 {
	return volatile.LoadUint32(&o.PLL0USB_STAT.Reg) & 0x1
}
func (o *CGU_Type) SetPLL0USB_STAT_FR(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_STAT.Reg, volatile.LoadUint32(&o.PLL0USB_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetPLL0USB_STAT_FR() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_STAT.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetPLL0USB_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_STAT.Reg, volatile.LoadUint32(&o.PLL0USB_STAT.Reg)&^(0xfffffffc)|value<<2)
}
func (o *CGU_Type) GetPLL0USB_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_STAT.Reg) & 0xfffffffc) >> 2
}

// CGU.PLL0USB_CTRL: PLL0USB control register
func (o *CGU_Type) SetPLL0USB_CTRL_PD(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetPLL0USB_CTRL_PD() uint32 {
	return volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x1
}
func (o *CGU_Type) SetPLL0USB_CTRL_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetPLL0USB_CTRL_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetPLL0USB_CTRL_DIRECTI(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *CGU_Type) GetPLL0USB_CTRL_DIRECTI() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x4) >> 2
}
func (o *CGU_Type) SetPLL0USB_CTRL_DIRECTO(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *CGU_Type) GetPLL0USB_CTRL_DIRECTO() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x8) >> 3
}
func (o *CGU_Type) SetPLL0USB_CTRL_CLKEN(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *CGU_Type) GetPLL0USB_CTRL_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x10) >> 4
}
func (o *CGU_Type) SetPLL0USB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *CGU_Type) GetPLL0USB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x20) >> 5
}
func (o *CGU_Type) SetPLL0USB_CTRL_FRM(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *CGU_Type) GetPLL0USB_CTRL_FRM() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x40) >> 6
}
func (o *CGU_Type) SetPLL0USB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *CGU_Type) GetPLL0USB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x80) >> 7
}
func (o *CGU_Type) SetPLL0USB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *CGU_Type) GetPLL0USB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x100) >> 8
}
func (o *CGU_Type) SetPLL0USB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *CGU_Type) GetPLL0USB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x200) >> 9
}
func (o *CGU_Type) SetPLL0USB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CGU_Type) GetPLL0USB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x400) >> 10
}
func (o *CGU_Type) SetPLL0USB_CTRL_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetPLL0USB_CTRL_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetPLL0USB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetPLL0USB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetPLL0USB_CTRL_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetPLL0USB_CTRL_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetPLL0USB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_CTRL.Reg, volatile.LoadUint32(&o.PLL0USB_CTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetPLL0USB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_CTRL.Reg) & 0xe0000000) >> 29
}

// CGU.PLL0USB_MDIV: PLL0USB M-divider register
func (o *CGU_Type) SetPLL0USB_MDIV_MDEC(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_MDIV.Reg, volatile.LoadUint32(&o.PLL0USB_MDIV.Reg)&^(0x1ffff)|value)
}
func (o *CGU_Type) GetPLL0USB_MDIV_MDEC() uint32 {
	return volatile.LoadUint32(&o.PLL0USB_MDIV.Reg) & 0x1ffff
}
func (o *CGU_Type) SetPLL0USB_MDIV_SELP(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_MDIV.Reg, volatile.LoadUint32(&o.PLL0USB_MDIV.Reg)&^(0x3e0000)|value<<17)
}
func (o *CGU_Type) GetPLL0USB_MDIV_SELP() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_MDIV.Reg) & 0x3e0000) >> 17
}
func (o *CGU_Type) SetPLL0USB_MDIV_SELI(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_MDIV.Reg, volatile.LoadUint32(&o.PLL0USB_MDIV.Reg)&^(0xfc00000)|value<<22)
}
func (o *CGU_Type) GetPLL0USB_MDIV_SELI() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_MDIV.Reg) & 0xfc00000) >> 22
}
func (o *CGU_Type) SetPLL0USB_MDIV_SELR(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_MDIV.Reg, volatile.LoadUint32(&o.PLL0USB_MDIV.Reg)&^(0xf0000000)|value<<28)
}
func (o *CGU_Type) GetPLL0USB_MDIV_SELR() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_MDIV.Reg) & 0xf0000000) >> 28
}

// CGU.PLL0USB_NP_DIV: PLL0USB N/P-divider register
func (o *CGU_Type) SetPLL0USB_NP_DIV_PDEC(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_NP_DIV.Reg, volatile.LoadUint32(&o.PLL0USB_NP_DIV.Reg)&^(0x7f)|value)
}
func (o *CGU_Type) GetPLL0USB_NP_DIV_PDEC() uint32 {
	return volatile.LoadUint32(&o.PLL0USB_NP_DIV.Reg) & 0x7f
}
func (o *CGU_Type) SetPLL0USB_NP_DIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_NP_DIV.Reg, volatile.LoadUint32(&o.PLL0USB_NP_DIV.Reg)&^(0xf80)|value<<7)
}
func (o *CGU_Type) GetPLL0USB_NP_DIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_NP_DIV.Reg) & 0xf80) >> 7
}
func (o *CGU_Type) SetPLL0USB_NP_DIV_NDEC(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_NP_DIV.Reg, volatile.LoadUint32(&o.PLL0USB_NP_DIV.Reg)&^(0x3ff000)|value<<12)
}
func (o *CGU_Type) GetPLL0USB_NP_DIV_NDEC() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_NP_DIV.Reg) & 0x3ff000) >> 12
}
func (o *CGU_Type) SetPLL0USB_NP_DIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0USB_NP_DIV.Reg, volatile.LoadUint32(&o.PLL0USB_NP_DIV.Reg)&^(0xffc00000)|value<<22)
}
func (o *CGU_Type) GetPLL0USB_NP_DIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0USB_NP_DIV.Reg) & 0xffc00000) >> 22
}

// CGU.PLL0AUDIO_STAT: PLL0AUDIO status register
func (o *CGU_Type) SetPLL0AUDIO_STAT_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_STAT.Reg, volatile.LoadUint32(&o.PLL0AUDIO_STAT.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetPLL0AUDIO_STAT_LOCK() uint32 {
	return volatile.LoadUint32(&o.PLL0AUDIO_STAT.Reg) & 0x1
}
func (o *CGU_Type) SetPLL0AUDIO_STAT_FR(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_STAT.Reg, volatile.LoadUint32(&o.PLL0AUDIO_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetPLL0AUDIO_STAT_FR() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_STAT.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetPLL0AUDIO_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_STAT.Reg, volatile.LoadUint32(&o.PLL0AUDIO_STAT.Reg)&^(0xfffffffc)|value<<2)
}
func (o *CGU_Type) GetPLL0AUDIO_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_STAT.Reg) & 0xfffffffc) >> 2
}

// CGU.PLL0AUDIO_CTRL: PLL0AUDIO control register
func (o *CGU_Type) SetPLL0AUDIO_CTRL_PD(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_PD() uint32 {
	return volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x1
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_DIRECTI(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_DIRECTI() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x4) >> 2
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_DIRECTO(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_DIRECTO() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x8) >> 3
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_CLKEN(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x10) >> 4
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x20) >> 5
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_FRM(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_FRM() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x40) >> 6
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x80) >> 7
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x100) >> 8
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x200) >> 9
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x400) >> 10
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_PLLFRACT_REQ(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_PLLFRACT_REQ() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x1000) >> 12
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_SEL_EXT(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_SEL_EXT() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x2000) >> 13
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_MOD_PD(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_MOD_PD() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x4000) >> 14
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0xff8000)|value<<15)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0xff8000) >> 15
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetPLL0AUDIO_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_CTRL.Reg, volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetPLL0AUDIO_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_CTRL.Reg) & 0xe0000000) >> 29
}

// CGU.PLL0AUDIO_MDIV: PLL0AUDIO M-divider register
func (o *CGU_Type) SetPLL0AUDIO_MDIV_MDEC(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_MDIV.Reg, volatile.LoadUint32(&o.PLL0AUDIO_MDIV.Reg)&^(0x1ffff)|value)
}
func (o *CGU_Type) GetPLL0AUDIO_MDIV_MDEC() uint32 {
	return volatile.LoadUint32(&o.PLL0AUDIO_MDIV.Reg) & 0x1ffff
}
func (o *CGU_Type) SetPLL0AUDIO_MDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_MDIV.Reg, volatile.LoadUint32(&o.PLL0AUDIO_MDIV.Reg)&^(0xfffe0000)|value<<17)
}
func (o *CGU_Type) GetPLL0AUDIO_MDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_MDIV.Reg) & 0xfffe0000) >> 17
}

// CGU.PLL0AUDIO_NP_DIV: PLL0AUDIO N/P-divider register
func (o *CGU_Type) SetPLL0AUDIO_NP_DIV_PDEC(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_NP_DIV.Reg, volatile.LoadUint32(&o.PLL0AUDIO_NP_DIV.Reg)&^(0x7f)|value)
}
func (o *CGU_Type) GetPLL0AUDIO_NP_DIV_PDEC() uint32 {
	return volatile.LoadUint32(&o.PLL0AUDIO_NP_DIV.Reg) & 0x7f
}
func (o *CGU_Type) SetPLL0AUDIO_NP_DIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_NP_DIV.Reg, volatile.LoadUint32(&o.PLL0AUDIO_NP_DIV.Reg)&^(0xf80)|value<<7)
}
func (o *CGU_Type) GetPLL0AUDIO_NP_DIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_NP_DIV.Reg) & 0xf80) >> 7
}
func (o *CGU_Type) SetPLL0AUDIO_NP_DIV_NDEC(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_NP_DIV.Reg, volatile.LoadUint32(&o.PLL0AUDIO_NP_DIV.Reg)&^(0x3ff000)|value<<12)
}
func (o *CGU_Type) GetPLL0AUDIO_NP_DIV_NDEC() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_NP_DIV.Reg) & 0x3ff000) >> 12
}
func (o *CGU_Type) SetPLL0AUDIO_NP_DIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_NP_DIV.Reg, volatile.LoadUint32(&o.PLL0AUDIO_NP_DIV.Reg)&^(0xffc00000)|value<<22)
}
func (o *CGU_Type) GetPLL0AUDIO_NP_DIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_NP_DIV.Reg) & 0xffc00000) >> 22
}

// CGU.PLL0AUDIO_FRAC: PLL0AUDIO fractional divider register
func (o *CGU_Type) SetPLL0AUDIO_FRAC_PLLFRACT_CTRL(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_FRAC.Reg, volatile.LoadUint32(&o.PLL0AUDIO_FRAC.Reg)&^(0x3fffff)|value)
}
func (o *CGU_Type) GetPLL0AUDIO_FRAC_PLLFRACT_CTRL() uint32 {
	return volatile.LoadUint32(&o.PLL0AUDIO_FRAC.Reg) & 0x3fffff
}
func (o *CGU_Type) SetPLL0AUDIO_FRAC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL0AUDIO_FRAC.Reg, volatile.LoadUint32(&o.PLL0AUDIO_FRAC.Reg)&^(0xffc00000)|value<<22)
}
func (o *CGU_Type) GetPLL0AUDIO_FRAC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL0AUDIO_FRAC.Reg) & 0xffc00000) >> 22
}

// CGU.PLL1_STAT: PLL1 status register
func (o *CGU_Type) SetPLL1_STAT_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL1_STAT.Reg, volatile.LoadUint32(&o.PLL1_STAT.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetPLL1_STAT_LOCK() uint32 {
	return volatile.LoadUint32(&o.PLL1_STAT.Reg) & 0x1
}
func (o *CGU_Type) SetPLL1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL1_STAT.Reg, volatile.LoadUint32(&o.PLL1_STAT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *CGU_Type) GetPLL1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL1_STAT.Reg) & 0xfffffffe) >> 1
}

// CGU.PLL1_CTRL: PLL1 control register
func (o *CGU_Type) SetPLL1_CTRL_PD(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetPLL1_CTRL_PD() uint32 {
	return volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x1
}
func (o *CGU_Type) SetPLL1_CTRL_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetPLL1_CTRL_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetPLL1_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *CGU_Type) GetPLL1_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x4) >> 2
}
func (o *CGU_Type) SetPLL1_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x38)|value<<3)
}
func (o *CGU_Type) GetPLL1_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x38) >> 3
}
func (o *CGU_Type) SetPLL1_CTRL_FBSEL(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *CGU_Type) GetPLL1_CTRL_FBSEL() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x40) >> 6
}
func (o *CGU_Type) SetPLL1_CTRL_DIRECT(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *CGU_Type) GetPLL1_CTRL_DIRECT() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x80) >> 7
}
func (o *CGU_Type) SetPLL1_CTRL_PSEL(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *CGU_Type) GetPLL1_CTRL_PSEL() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x300) >> 8
}
func (o *CGU_Type) SetPLL1_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CGU_Type) GetPLL1_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x400) >> 10
}
func (o *CGU_Type) SetPLL1_CTRL_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetPLL1_CTRL_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetPLL1_CTRL_NSEL(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *CGU_Type) GetPLL1_CTRL_NSEL() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x3000) >> 12
}
func (o *CGU_Type) SetPLL1_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0xc000)|value<<14)
}
func (o *CGU_Type) GetPLL1_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0xc000) >> 14
}
func (o *CGU_Type) SetPLL1_CTRL_MSEL(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0xff0000)|value<<16)
}
func (o *CGU_Type) GetPLL1_CTRL_MSEL() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0xff0000) >> 16
}
func (o *CGU_Type) SetPLL1_CTRL_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetPLL1_CTRL_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetPLL1_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLL1_CTRL.Reg, volatile.LoadUint32(&o.PLL1_CTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetPLL1_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLL1_CTRL.Reg) & 0xe0000000) >> 29
}

// CGU.IDIVA_CTRL: Integer divider A control register
func (o *CGU_Type) SetIDIVA_CTRL_PD(value uint32) {
	volatile.StoreUint32(&o.IDIVA_CTRL.Reg, volatile.LoadUint32(&o.IDIVA_CTRL.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetIDIVA_CTRL_PD() uint32 {
	return volatile.LoadUint32(&o.IDIVA_CTRL.Reg) & 0x1
}
func (o *CGU_Type) SetIDIVA_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVA_CTRL.Reg, volatile.LoadUint32(&o.IDIVA_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetIDIVA_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVA_CTRL.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetIDIVA_CTRL_IDIV(value uint32) {
	volatile.StoreUint32(&o.IDIVA_CTRL.Reg, volatile.LoadUint32(&o.IDIVA_CTRL.Reg)&^(0xc)|value<<2)
}
func (o *CGU_Type) GetIDIVA_CTRL_IDIV() uint32 {
	return (volatile.LoadUint32(&o.IDIVA_CTRL.Reg) & 0xc) >> 2
}
func (o *CGU_Type) SetIDIVA_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVA_CTRL.Reg, volatile.LoadUint32(&o.IDIVA_CTRL.Reg)&^(0x7f0)|value<<4)
}
func (o *CGU_Type) GetIDIVA_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVA_CTRL.Reg) & 0x7f0) >> 4
}
func (o *CGU_Type) SetIDIVA_CTRL_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.IDIVA_CTRL.Reg, volatile.LoadUint32(&o.IDIVA_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetIDIVA_CTRL_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.IDIVA_CTRL.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetIDIVA_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVA_CTRL.Reg, volatile.LoadUint32(&o.IDIVA_CTRL.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetIDIVA_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVA_CTRL.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetIDIVA_CTRL_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.IDIVA_CTRL.Reg, volatile.LoadUint32(&o.IDIVA_CTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetIDIVA_CTRL_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.IDIVA_CTRL.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetIDIVA_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVA_CTRL.Reg, volatile.LoadUint32(&o.IDIVA_CTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetIDIVA_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVA_CTRL.Reg) & 0xe0000000) >> 29
}

// CGU.IDIVB_CTRL: Integer divider B control register
func (o *CGU_Type) SetIDIVB_CTRL_PD(value uint32) {
	volatile.StoreUint32(&o.IDIVB_CTRL.Reg, volatile.LoadUint32(&o.IDIVB_CTRL.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetIDIVB_CTRL_PD() uint32 {
	return volatile.LoadUint32(&o.IDIVB_CTRL.Reg) & 0x1
}
func (o *CGU_Type) SetIDIVB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVB_CTRL.Reg, volatile.LoadUint32(&o.IDIVB_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetIDIVB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVB_CTRL.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetIDIVB_CTRL_IDIV(value uint32) {
	volatile.StoreUint32(&o.IDIVB_CTRL.Reg, volatile.LoadUint32(&o.IDIVB_CTRL.Reg)&^(0x3c)|value<<2)
}
func (o *CGU_Type) GetIDIVB_CTRL_IDIV() uint32 {
	return (volatile.LoadUint32(&o.IDIVB_CTRL.Reg) & 0x3c) >> 2
}
func (o *CGU_Type) SetIDIVB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVB_CTRL.Reg, volatile.LoadUint32(&o.IDIVB_CTRL.Reg)&^(0x7c0)|value<<6)
}
func (o *CGU_Type) GetIDIVB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVB_CTRL.Reg) & 0x7c0) >> 6
}
func (o *CGU_Type) SetIDIVB_CTRL_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.IDIVB_CTRL.Reg, volatile.LoadUint32(&o.IDIVB_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetIDIVB_CTRL_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.IDIVB_CTRL.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetIDIVB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVB_CTRL.Reg, volatile.LoadUint32(&o.IDIVB_CTRL.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetIDIVB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVB_CTRL.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetIDIVB_CTRL_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.IDIVB_CTRL.Reg, volatile.LoadUint32(&o.IDIVB_CTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetIDIVB_CTRL_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.IDIVB_CTRL.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetIDIVB_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVB_CTRL.Reg, volatile.LoadUint32(&o.IDIVB_CTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetIDIVB_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVB_CTRL.Reg) & 0xe0000000) >> 29
}

// CGU.IDIVC_CTRL: Integer divider C control register
func (o *CGU_Type) SetIDIVC_CTRL_PD(value uint32) {
	volatile.StoreUint32(&o.IDIVC_CTRL.Reg, volatile.LoadUint32(&o.IDIVC_CTRL.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetIDIVC_CTRL_PD() uint32 {
	return volatile.LoadUint32(&o.IDIVC_CTRL.Reg) & 0x1
}
func (o *CGU_Type) SetIDIVC_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVC_CTRL.Reg, volatile.LoadUint32(&o.IDIVC_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetIDIVC_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVC_CTRL.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetIDIVC_CTRL_IDIV(value uint32) {
	volatile.StoreUint32(&o.IDIVC_CTRL.Reg, volatile.LoadUint32(&o.IDIVC_CTRL.Reg)&^(0x3c)|value<<2)
}
func (o *CGU_Type) GetIDIVC_CTRL_IDIV() uint32 {
	return (volatile.LoadUint32(&o.IDIVC_CTRL.Reg) & 0x3c) >> 2
}
func (o *CGU_Type) SetIDIVC_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVC_CTRL.Reg, volatile.LoadUint32(&o.IDIVC_CTRL.Reg)&^(0x7c0)|value<<6)
}
func (o *CGU_Type) GetIDIVC_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVC_CTRL.Reg) & 0x7c0) >> 6
}
func (o *CGU_Type) SetIDIVC_CTRL_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.IDIVC_CTRL.Reg, volatile.LoadUint32(&o.IDIVC_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetIDIVC_CTRL_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.IDIVC_CTRL.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetIDIVC_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVC_CTRL.Reg, volatile.LoadUint32(&o.IDIVC_CTRL.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetIDIVC_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVC_CTRL.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetIDIVC_CTRL_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.IDIVC_CTRL.Reg, volatile.LoadUint32(&o.IDIVC_CTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetIDIVC_CTRL_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.IDIVC_CTRL.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetIDIVC_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVC_CTRL.Reg, volatile.LoadUint32(&o.IDIVC_CTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetIDIVC_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVC_CTRL.Reg) & 0xe0000000) >> 29
}

// CGU.IDIVD_CTRL: Integer divider D control register
func (o *CGU_Type) SetIDIVD_CTRL_PD(value uint32) {
	volatile.StoreUint32(&o.IDIVD_CTRL.Reg, volatile.LoadUint32(&o.IDIVD_CTRL.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetIDIVD_CTRL_PD() uint32 {
	return volatile.LoadUint32(&o.IDIVD_CTRL.Reg) & 0x1
}
func (o *CGU_Type) SetIDIVD_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVD_CTRL.Reg, volatile.LoadUint32(&o.IDIVD_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetIDIVD_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVD_CTRL.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetIDIVD_CTRL_IDIV(value uint32) {
	volatile.StoreUint32(&o.IDIVD_CTRL.Reg, volatile.LoadUint32(&o.IDIVD_CTRL.Reg)&^(0x3c)|value<<2)
}
func (o *CGU_Type) GetIDIVD_CTRL_IDIV() uint32 {
	return (volatile.LoadUint32(&o.IDIVD_CTRL.Reg) & 0x3c) >> 2
}
func (o *CGU_Type) SetIDIVD_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVD_CTRL.Reg, volatile.LoadUint32(&o.IDIVD_CTRL.Reg)&^(0x7c0)|value<<6)
}
func (o *CGU_Type) GetIDIVD_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVD_CTRL.Reg) & 0x7c0) >> 6
}
func (o *CGU_Type) SetIDIVD_CTRL_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.IDIVD_CTRL.Reg, volatile.LoadUint32(&o.IDIVD_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetIDIVD_CTRL_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.IDIVD_CTRL.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetIDIVD_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVD_CTRL.Reg, volatile.LoadUint32(&o.IDIVD_CTRL.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetIDIVD_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVD_CTRL.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetIDIVD_CTRL_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.IDIVD_CTRL.Reg, volatile.LoadUint32(&o.IDIVD_CTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetIDIVD_CTRL_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.IDIVD_CTRL.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetIDIVD_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVD_CTRL.Reg, volatile.LoadUint32(&o.IDIVD_CTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetIDIVD_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVD_CTRL.Reg) & 0xe0000000) >> 29
}

// CGU.IDIVE_CTRL: Integer divider E control register
func (o *CGU_Type) SetIDIVE_CTRL_PD(value uint32) {
	volatile.StoreUint32(&o.IDIVE_CTRL.Reg, volatile.LoadUint32(&o.IDIVE_CTRL.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetIDIVE_CTRL_PD() uint32 {
	return volatile.LoadUint32(&o.IDIVE_CTRL.Reg) & 0x1
}
func (o *CGU_Type) SetIDIVE_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVE_CTRL.Reg, volatile.LoadUint32(&o.IDIVE_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CGU_Type) GetIDIVE_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVE_CTRL.Reg) & 0x2) >> 1
}
func (o *CGU_Type) SetIDIVE_CTRL_IDIV(value uint32) {
	volatile.StoreUint32(&o.IDIVE_CTRL.Reg, volatile.LoadUint32(&o.IDIVE_CTRL.Reg)&^(0x3fc)|value<<2)
}
func (o *CGU_Type) GetIDIVE_CTRL_IDIV() uint32 {
	return (volatile.LoadUint32(&o.IDIVE_CTRL.Reg) & 0x3fc) >> 2
}
func (o *CGU_Type) SetIDIVE_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVE_CTRL.Reg, volatile.LoadUint32(&o.IDIVE_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CGU_Type) GetIDIVE_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVE_CTRL.Reg) & 0x400) >> 10
}
func (o *CGU_Type) SetIDIVE_CTRL_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.IDIVE_CTRL.Reg, volatile.LoadUint32(&o.IDIVE_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetIDIVE_CTRL_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.IDIVE_CTRL.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetIDIVE_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVE_CTRL.Reg, volatile.LoadUint32(&o.IDIVE_CTRL.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetIDIVE_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVE_CTRL.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetIDIVE_CTRL_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.IDIVE_CTRL.Reg, volatile.LoadUint32(&o.IDIVE_CTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetIDIVE_CTRL_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.IDIVE_CTRL.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetIDIVE_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IDIVE_CTRL.Reg, volatile.LoadUint32(&o.IDIVE_CTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetIDIVE_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IDIVE_CTRL.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_SAFE_CLK: Output stage 0 control register for base clock BASE_SAFE_CLK
func (o *CGU_Type) SetBASE_SAFE_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_SAFE_CLK.Reg, volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_SAFE_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_SAFE_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SAFE_CLK.Reg, volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_SAFE_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_SAFE_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_SAFE_CLK.Reg, volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_SAFE_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_SAFE_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SAFE_CLK.Reg, volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_SAFE_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_SAFE_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_SAFE_CLK.Reg, volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_SAFE_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_SAFE_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SAFE_CLK.Reg, volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_SAFE_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SAFE_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_USB0_CLK: Output stage 1 control register for base clock BASE_USB0_CLK
func (o *CGU_Type) SetBASE_USB0_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_USB0_CLK.Reg, volatile.LoadUint32(&o.BASE_USB0_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_USB0_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_USB0_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_USB0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_USB0_CLK.Reg, volatile.LoadUint32(&o.BASE_USB0_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_USB0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB0_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_USB0_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_USB0_CLK.Reg, volatile.LoadUint32(&o.BASE_USB0_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_USB0_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB0_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_USB0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_USB0_CLK.Reg, volatile.LoadUint32(&o.BASE_USB0_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_USB0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB0_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_USB0_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_USB0_CLK.Reg, volatile.LoadUint32(&o.BASE_USB0_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_USB0_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB0_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_USB0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_USB0_CLK.Reg, volatile.LoadUint32(&o.BASE_USB0_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_USB0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB0_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_PERIPH_CLK: Output stage 2 control register for base clock BASE_PERIPH_CLK
func (o *CGU_Type) SetBASE_PERIPH_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_PERIPH_CLK.Reg, volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_PERIPH_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_PERIPH_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_PERIPH_CLK.Reg, volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_PERIPH_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_PERIPH_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_PERIPH_CLK.Reg, volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_PERIPH_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_PERIPH_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_PERIPH_CLK.Reg, volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_PERIPH_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_PERIPH_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_PERIPH_CLK.Reg, volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_PERIPH_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_PERIPH_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_PERIPH_CLK.Reg, volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_PERIPH_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_PERIPH_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_USB1_CLK: Output stage 3 control register for base clock BASE_USB1_CLK
func (o *CGU_Type) SetBASE_USB1_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_USB1_CLK.Reg, volatile.LoadUint32(&o.BASE_USB1_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_USB1_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_USB1_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_USB1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_USB1_CLK.Reg, volatile.LoadUint32(&o.BASE_USB1_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_USB1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB1_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_USB1_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_USB1_CLK.Reg, volatile.LoadUint32(&o.BASE_USB1_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_USB1_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB1_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_USB1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_USB1_CLK.Reg, volatile.LoadUint32(&o.BASE_USB1_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_USB1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB1_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_USB1_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_USB1_CLK.Reg, volatile.LoadUint32(&o.BASE_USB1_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_USB1_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB1_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_USB1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_USB1_CLK.Reg, volatile.LoadUint32(&o.BASE_USB1_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_USB1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_USB1_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_M3_CLK: Output stage BASE_M3_CLK control register
func (o *CGU_Type) SetBASE_M3_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_M3_CLK.Reg, volatile.LoadUint32(&o.BASE_M3_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_M3_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_M3_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_M3_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_M3_CLK.Reg, volatile.LoadUint32(&o.BASE_M3_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_M3_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_M3_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_M3_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_M3_CLK.Reg, volatile.LoadUint32(&o.BASE_M3_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_M3_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_M3_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_M3_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_M3_CLK.Reg, volatile.LoadUint32(&o.BASE_M3_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_M3_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_M3_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_M3_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_M3_CLK.Reg, volatile.LoadUint32(&o.BASE_M3_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_M3_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_M3_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_M3_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_M3_CLK.Reg, volatile.LoadUint32(&o.BASE_M3_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_M3_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_M3_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_SPIFI_CLK: Output stage BASE_SPIFI_CLK control register
func (o *CGU_Type) SetBASE_SPIFI_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_SPIFI_CLK.Reg, volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_SPIFI_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_SPIFI_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SPIFI_CLK.Reg, volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_SPIFI_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_SPIFI_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_SPIFI_CLK.Reg, volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_SPIFI_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_SPIFI_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SPIFI_CLK.Reg, volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_SPIFI_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_SPIFI_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_SPIFI_CLK.Reg, volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_SPIFI_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_SPIFI_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SPIFI_CLK.Reg, volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_SPIFI_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SPIFI_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_PHY_RX_CLK: Output stage BASE_PHY_RX_CLK control register
func (o *CGU_Type) SetBASE_PHY_RX_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_RX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_PHY_RX_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_PHY_RX_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_RX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_PHY_RX_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_PHY_RX_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_RX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_PHY_RX_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_PHY_RX_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_RX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_PHY_RX_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_PHY_RX_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_RX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_PHY_RX_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_PHY_RX_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_RX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_PHY_RX_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_RX_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_PHY_TX_CLK: Output stage BASE_PHY_TX_CLK control register
func (o *CGU_Type) SetBASE_PHY_TX_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_TX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_PHY_TX_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_PHY_TX_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_TX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_PHY_TX_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_PHY_TX_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_TX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_PHY_TX_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_PHY_TX_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_TX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_PHY_TX_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_PHY_TX_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_TX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_PHY_TX_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_PHY_TX_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_PHY_TX_CLK.Reg, volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_PHY_TX_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_PHY_TX_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_APB1_CLK: Output stage BASE_APB1_CLK control register
func (o *CGU_Type) SetBASE_APB1_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_APB1_CLK.Reg, volatile.LoadUint32(&o.BASE_APB1_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_APB1_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_APB1_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_APB1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_APB1_CLK.Reg, volatile.LoadUint32(&o.BASE_APB1_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_APB1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB1_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_APB1_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_APB1_CLK.Reg, volatile.LoadUint32(&o.BASE_APB1_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_APB1_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB1_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_APB1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_APB1_CLK.Reg, volatile.LoadUint32(&o.BASE_APB1_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_APB1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB1_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_APB1_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_APB1_CLK.Reg, volatile.LoadUint32(&o.BASE_APB1_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_APB1_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB1_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_APB1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_APB1_CLK.Reg, volatile.LoadUint32(&o.BASE_APB1_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_APB1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB1_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_APB3_CLK: Output stage BASE_APB3_CLK control register
func (o *CGU_Type) SetBASE_APB3_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_APB3_CLK.Reg, volatile.LoadUint32(&o.BASE_APB3_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_APB3_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_APB3_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_APB3_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_APB3_CLK.Reg, volatile.LoadUint32(&o.BASE_APB3_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_APB3_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB3_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_APB3_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_APB3_CLK.Reg, volatile.LoadUint32(&o.BASE_APB3_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_APB3_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB3_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_APB3_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_APB3_CLK.Reg, volatile.LoadUint32(&o.BASE_APB3_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_APB3_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB3_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_APB3_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_APB3_CLK.Reg, volatile.LoadUint32(&o.BASE_APB3_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_APB3_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB3_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_APB3_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_APB3_CLK.Reg, volatile.LoadUint32(&o.BASE_APB3_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_APB3_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_APB3_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_LCD_CLK: Output stage BASE_LCD_CLK control register
func (o *CGU_Type) SetBASE_LCD_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_LCD_CLK.Reg, volatile.LoadUint32(&o.BASE_LCD_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_LCD_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_LCD_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_LCD_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_LCD_CLK.Reg, volatile.LoadUint32(&o.BASE_LCD_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_LCD_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_LCD_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_LCD_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_LCD_CLK.Reg, volatile.LoadUint32(&o.BASE_LCD_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_LCD_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_LCD_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_LCD_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_LCD_CLK.Reg, volatile.LoadUint32(&o.BASE_LCD_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_LCD_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_LCD_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_LCD_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_LCD_CLK.Reg, volatile.LoadUint32(&o.BASE_LCD_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_LCD_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_LCD_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_LCD_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_LCD_CLK.Reg, volatile.LoadUint32(&o.BASE_LCD_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_LCD_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_LCD_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_SDIO_CLK: Output stage BASE_SDIO_CLK control register
func (o *CGU_Type) SetBASE_SDIO_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_SDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_SDIO_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_SDIO_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_SDIO_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_SDIO_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_SDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_SDIO_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_SDIO_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_SDIO_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_SDIO_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_SDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_SDIO_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_SDIO_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_SDIO_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SDIO_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_SSP0_CLK: Output stage BASE_SSP0_CLK control register
func (o *CGU_Type) SetBASE_SSP0_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP0_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_SSP0_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_SSP0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP0_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_SSP0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_SSP0_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP0_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_SSP0_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_SSP0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP0_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_SSP0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_SSP0_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP0_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_SSP0_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_SSP0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP0_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_SSP0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP0_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_SSP1_CLK: Output stage BASE_SSP1_CLK control register
func (o *CGU_Type) SetBASE_SSP1_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP1_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_SSP1_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_SSP1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP1_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_SSP1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_SSP1_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP1_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_SSP1_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_SSP1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP1_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_SSP1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_SSP1_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP1_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_SSP1_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_SSP1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_SSP1_CLK.Reg, volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_SSP1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_SSP1_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_UART0_CLK: Output stage BASE_UART0_CLK control register
func (o *CGU_Type) SetBASE_UART0_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_UART0_CLK.Reg, volatile.LoadUint32(&o.BASE_UART0_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_UART0_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_UART0_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_UART0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART0_CLK.Reg, volatile.LoadUint32(&o.BASE_UART0_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_UART0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART0_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_UART0_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_UART0_CLK.Reg, volatile.LoadUint32(&o.BASE_UART0_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_UART0_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART0_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_UART0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART0_CLK.Reg, volatile.LoadUint32(&o.BASE_UART0_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_UART0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART0_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_UART0_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_UART0_CLK.Reg, volatile.LoadUint32(&o.BASE_UART0_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_UART0_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART0_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_UART0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART0_CLK.Reg, volatile.LoadUint32(&o.BASE_UART0_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_UART0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART0_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_UART1_CLK: Output stage BASE_UART1_CLK control register
func (o *CGU_Type) SetBASE_UART1_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_UART1_CLK.Reg, volatile.LoadUint32(&o.BASE_UART1_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_UART1_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_UART1_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_UART1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART1_CLK.Reg, volatile.LoadUint32(&o.BASE_UART1_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_UART1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART1_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_UART1_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_UART1_CLK.Reg, volatile.LoadUint32(&o.BASE_UART1_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_UART1_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART1_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_UART1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART1_CLK.Reg, volatile.LoadUint32(&o.BASE_UART1_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_UART1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART1_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_UART1_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_UART1_CLK.Reg, volatile.LoadUint32(&o.BASE_UART1_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_UART1_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART1_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_UART1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART1_CLK.Reg, volatile.LoadUint32(&o.BASE_UART1_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_UART1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART1_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_UART2_CLK: Output stage BASE_UART2_CLK control register
func (o *CGU_Type) SetBASE_UART2_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_UART2_CLK.Reg, volatile.LoadUint32(&o.BASE_UART2_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_UART2_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_UART2_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_UART2_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART2_CLK.Reg, volatile.LoadUint32(&o.BASE_UART2_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_UART2_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART2_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_UART2_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_UART2_CLK.Reg, volatile.LoadUint32(&o.BASE_UART2_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_UART2_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART2_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_UART2_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART2_CLK.Reg, volatile.LoadUint32(&o.BASE_UART2_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_UART2_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART2_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_UART2_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_UART2_CLK.Reg, volatile.LoadUint32(&o.BASE_UART2_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_UART2_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART2_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_UART2_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART2_CLK.Reg, volatile.LoadUint32(&o.BASE_UART2_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_UART2_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART2_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_UART3_CLK: Output stage BASE_UART3_CLK control register
func (o *CGU_Type) SetBASE_UART3_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_UART3_CLK.Reg, volatile.LoadUint32(&o.BASE_UART3_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_UART3_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_UART3_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_UART3_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART3_CLK.Reg, volatile.LoadUint32(&o.BASE_UART3_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_UART3_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART3_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_UART3_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_UART3_CLK.Reg, volatile.LoadUint32(&o.BASE_UART3_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_UART3_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART3_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_UART3_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART3_CLK.Reg, volatile.LoadUint32(&o.BASE_UART3_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_UART3_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART3_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_UART3_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_UART3_CLK.Reg, volatile.LoadUint32(&o.BASE_UART3_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_UART3_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART3_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_UART3_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_UART3_CLK.Reg, volatile.LoadUint32(&o.BASE_UART3_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_UART3_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_UART3_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_OUT_CLK: Output stage 20 control register for base clock BASE_OUT_CLK
func (o *CGU_Type) SetBASE_OUT_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_OUT_CLK.Reg, volatile.LoadUint32(&o.BASE_OUT_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_OUT_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_OUT_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_OUT_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_OUT_CLK.Reg, volatile.LoadUint32(&o.BASE_OUT_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_OUT_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_OUT_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_OUT_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_OUT_CLK.Reg, volatile.LoadUint32(&o.BASE_OUT_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_OUT_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_OUT_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_OUT_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_OUT_CLK.Reg, volatile.LoadUint32(&o.BASE_OUT_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_OUT_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_OUT_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_OUT_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_OUT_CLK.Reg, volatile.LoadUint32(&o.BASE_OUT_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_OUT_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_OUT_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_OUT_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_OUT_CLK.Reg, volatile.LoadUint32(&o.BASE_OUT_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_OUT_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_OUT_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_AUDIO_CLK: Output stage 25 control register for base clock BASE_AUDIO_CLK
func (o *CGU_Type) SetBASE_AUDIO_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_AUDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_AUDIO_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_AUDIO_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_AUDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_AUDIO_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_AUDIO_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_AUDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_AUDIO_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_AUDIO_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_AUDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_AUDIO_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_AUDIO_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_AUDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_AUDIO_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_AUDIO_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_AUDIO_CLK.Reg, volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_AUDIO_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_AUDIO_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_CGU_OUT0_CLK: Output stage 25 control register for base clock BASE_CGU_OUT0_CLK
func (o *CGU_Type) SetBASE_CGU_OUT0_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT0_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_CGU_OUT0_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_CGU_OUT0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT0_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_CGU_OUT0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_CGU_OUT0_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT0_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_CGU_OUT0_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_CGU_OUT0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT0_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_CGU_OUT0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_CGU_OUT0_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT0_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_CGU_OUT0_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_CGU_OUT0_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT0_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_CGU_OUT0_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT0_CLK.Reg) & 0xe0000000) >> 29
}

// CGU.BASE_CGU_OUT1_CLK: Output stage 25 control register for base clock BASE_CGU_OUT1_CLK
func (o *CGU_Type) SetBASE_CGU_OUT1_CLK_PD(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT1_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg)&^(0x1)|value)
}
func (o *CGU_Type) GetBASE_CGU_OUT1_CLK_PD() uint32 {
	return volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg) & 0x1
}
func (o *CGU_Type) SetBASE_CGU_OUT1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT1_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg)&^(0x7fe)|value<<1)
}
func (o *CGU_Type) GetBASE_CGU_OUT1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg) & 0x7fe) >> 1
}
func (o *CGU_Type) SetBASE_CGU_OUT1_CLK_AUTOBLOCK(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT1_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg)&^(0x800)|value<<11)
}
func (o *CGU_Type) GetBASE_CGU_OUT1_CLK_AUTOBLOCK() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg) & 0x800) >> 11
}
func (o *CGU_Type) SetBASE_CGU_OUT1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT1_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg)&^(0xfff000)|value<<12)
}
func (o *CGU_Type) GetBASE_CGU_OUT1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg) & 0xfff000) >> 12
}
func (o *CGU_Type) SetBASE_CGU_OUT1_CLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT1_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg)&^(0x1f000000)|value<<24)
}
func (o *CGU_Type) GetBASE_CGU_OUT1_CLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg) & 0x1f000000) >> 24
}
func (o *CGU_Type) SetBASE_CGU_OUT1_CLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_CGU_OUT1_CLK.Reg, volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg)&^(0xe0000000)|value<<29)
}
func (o *CGU_Type) GetBASE_CGU_OUT1_CLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_CGU_OUT1_CLK.Reg) & 0xe0000000) >> 29
}

// Clock Control Unit (CCU)
type CCU1_Type struct {
	PM                       volatile.Register32 // 0x0
	BASE_STAT                volatile.Register32 // 0x4
	_                        [248]byte
	CLK_APB3_BUS_CFG         volatile.Register32 // 0x100
	CLK_APB3_BUS_STAT        volatile.Register32 // 0x104
	CLK_APB3_I2C1_CFG        volatile.Register32 // 0x108
	CLK_APB3_I2C1_STAT       volatile.Register32 // 0x10C
	CLK_APB3_DAC_CFG         volatile.Register32 // 0x110
	CLK_APB3_DAC_STAT        volatile.Register32 // 0x114
	CLK_APB3_ADC0_CFG        volatile.Register32 // 0x118
	CLK_APB3_ADC0_STAT       volatile.Register32 // 0x11C
	CLK_APB3_ADC1_CFG        volatile.Register32 // 0x120
	CLK_APB3_ADC1_STAT       volatile.Register32 // 0x124
	CLK_APB3_CAN0_CFG        volatile.Register32 // 0x128
	CLK_APB3_CAN0_STAT       volatile.Register32 // 0x12C
	_                        [208]byte
	CLK_APB1_BUS_CFG         volatile.Register32 // 0x200
	CLK_APB1_BUS_STAT        volatile.Register32 // 0x204
	CLK_APB1_MOTOCONPWM_CFG  volatile.Register32 // 0x208
	CLK_APB1_MOTOCONPWM_STAT volatile.Register32 // 0x20C
	CLK_APB1_I2C0_CFG        volatile.Register32 // 0x210
	CLK_APB1_I2C0_STAT       volatile.Register32 // 0x214
	CLK_APB1_I2S_CFG         volatile.Register32 // 0x218
	CLK_APB1_I2S_STAT        volatile.Register32 // 0x21C
	CLK_APB1_CAN1_CFG        volatile.Register32 // 0x220
	CLK_APB1_CAN1_STAT       volatile.Register32 // 0x224
	_                        [216]byte
	CLK_SPIFI_CFG            volatile.Register32 // 0x300
	CLK_SPIFI_STAT           volatile.Register32 // 0x304
	_                        [248]byte
	CLK_M3_BUS_CFG           volatile.Register32 // 0x400
	CLK_M3_BUS_STAT          volatile.Register32 // 0x404
	CLK_M3_SPIFI_CFG         volatile.Register32 // 0x408
	CLK_M3_SPIFI_STAT        volatile.Register32 // 0x40C
	CLK_M3_GPIO_CFG          volatile.Register32 // 0x410
	CLK_M3_GPIO_STAT         volatile.Register32 // 0x414
	CLK_M3_LCD_CFG           volatile.Register32 // 0x418
	CLK_M3_LCD_STAT          volatile.Register32 // 0x41C
	CLK_M3_ETHERNET_CFG      volatile.Register32 // 0x420
	CLK_M3_ETHERNET_STAT     volatile.Register32 // 0x424
	CLK_M3_USB0_CFG          volatile.Register32 // 0x428
	CLK_M3_USB0_STAT         volatile.Register32 // 0x42C
	CLK_M3_EMC_CFG           volatile.Register32 // 0x430
	CLK_M3_EMC_STAT          volatile.Register32 // 0x434
	CLK_M3_SDIO_CFG          volatile.Register32 // 0x438
	CLK_M3_SDIO_STAT         volatile.Register32 // 0x43C
	CLK_M3_DMA_CFG           volatile.Register32 // 0x440
	CLK_M3_DMA_STAT          volatile.Register32 // 0x444
	CLK_M3_M3CORE_CFG        volatile.Register32 // 0x448
	CLK_M3_M3CORE_STAT       volatile.Register32 // 0x44C
	_                        [24]byte
	CLK_M3_SCT_CFG           volatile.Register32 // 0x468
	CLK_M3_SCT_STAT          volatile.Register32 // 0x46C
	CLK_M3_USB1_CFG          volatile.Register32 // 0x470
	CLK_M3_USB1_STAT         volatile.Register32 // 0x474
	CLK_M3_EMCDIV_CFG        volatile.Register32 // 0x478
	CLK_M3_EMCDIV_STAT       volatile.Register32 // 0x47C
	CLK_M3_FLASHA_CFG        volatile.Register32 // 0x480
	CLK_M3_FLASHA_STAT       volatile.Register32 // 0x484
	CLK_M3_FLASHB_CFG        volatile.Register32 // 0x488
	CLK_M3_FLASHB_STAT       volatile.Register32 // 0x48C
	_                        [16]byte
	CLK_M3_EEPROM_CFG        volatile.Register32 // 0x4A0
	CLK_M3_EEPROM_STAT       volatile.Register32 // 0x4A4
	_                        [88]byte
	CLK_M3_WWDT_CFG          volatile.Register32 // 0x500
	CLK_M3_WWDT_STAT         volatile.Register32 // 0x504
	CLK_M3_USART0_CFG        volatile.Register32 // 0x508
	CLK_M3_USART0_STAT       volatile.Register32 // 0x50C
	CLK_M3_UART1_CFG         volatile.Register32 // 0x510
	CLK_M3_UART1_STAT        volatile.Register32 // 0x514
	CLK_M3_SSP0_CFG          volatile.Register32 // 0x518
	CLK_M3_SSP0_STAT         volatile.Register32 // 0x51C
	CLK_M3_TIMER0_CFG        volatile.Register32 // 0x520
	CLK_M3_TIMER0_STAT       volatile.Register32 // 0x524
	CLK_M3_TIMER1_CFG        volatile.Register32 // 0x528
	CLK_M3_TIMER1_STAT       volatile.Register32 // 0x52C
	CLK_M3_SCU_CFG           volatile.Register32 // 0x530
	CLK_M3_SCU_STAT          volatile.Register32 // 0x534
	CLK_M3_CREG_CFG          volatile.Register32 // 0x538
	CLK_M3_CREG_STAT         volatile.Register32 // 0x53C
	_                        [192]byte
	CLK_M3_RITIMER_CFG       volatile.Register32 // 0x600
	CLK_M3_RITIMER_STAT      volatile.Register32 // 0x604
	CLK_M3_USART2_CFG        volatile.Register32 // 0x608
	CLK_M3_USART2_STAT       volatile.Register32 // 0x60C
	CLK_M3_USART3_CFG        volatile.Register32 // 0x610
	CLK_M3_USART3_STAT       volatile.Register32 // 0x614
	CLK_M3_TIMER2_CFG        volatile.Register32 // 0x618
	CLK_M3_TIMER2_STAT       volatile.Register32 // 0x61C
	CLK_M3_TIMER3_CFG        volatile.Register32 // 0x620
	CLK_M3_TIMER3_STAT       volatile.Register32 // 0x624
	CLK_M3_SSP1_CFG          volatile.Register32 // 0x628
	CLK_M3_SSP1_STAT         volatile.Register32 // 0x62C
	CLK_M3_QEI_CFG           volatile.Register32 // 0x630
	CLK_M3_QEI_STAT          volatile.Register32 // 0x634
	_                        [456]byte
	CLK_USB0_CFG             volatile.Register32 // 0x800
	CLK_USB0_STAT            volatile.Register32 // 0x804
	_                        [248]byte
	CLK_USB1_CFG             volatile.Register32 // 0x900
	CLK_USB1_STAT            volatile.Register32 // 0x904
}

// CCU1.PM: CCU1 power mode register
func (o *CCU1_Type) SetPM_PD(value uint32) {
	volatile.StoreUint32(&o.PM.Reg, volatile.LoadUint32(&o.PM.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetPM_PD() uint32 {
	return volatile.LoadUint32(&o.PM.Reg) & 0x1
}
func (o *CCU1_Type) SetPM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PM.Reg, volatile.LoadUint32(&o.PM.Reg)&^(0xfffffffe)|value<<1)
}
func (o *CCU1_Type) GetPM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PM.Reg) & 0xfffffffe) >> 1
}

// CCU1.BASE_STAT: CCU1 base clocks status register
func (o *CCU1_Type) SetBASE_STAT_BASE_APB3_CLK_IND(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetBASE_STAT_BASE_APB3_CLK_IND() uint32 {
	return volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetBASE_STAT_BASE_APB1_CLK_IND(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetBASE_STAT_BASE_APB1_CLK_IND() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetBASE_STAT_BASE_SPIFI_CLK_IND(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetBASE_STAT_BASE_SPIFI_CLK_IND() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetBASE_STAT_BASE_M3_CLK_IND(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x8)|value<<3)
}
func (o *CCU1_Type) GetBASE_STAT_BASE_M3_CLK_IND() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x8) >> 3
}
func (o *CCU1_Type) SetBASE_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x70)|value<<4)
}
func (o *CCU1_Type) GetBASE_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x70) >> 4
}
func (o *CCU1_Type) SetBASE_STAT_BASE_USB0_CLK_IND(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x80)|value<<7)
}
func (o *CCU1_Type) GetBASE_STAT_BASE_USB0_CLK_IND() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x80) >> 7
}
func (o *CCU1_Type) SetBASE_STAT_BASE_USB1_CLK_IND(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x100)|value<<8)
}
func (o *CCU1_Type) GetBASE_STAT_BASE_USB1_CLK_IND() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x100) >> 8
}
func (o *CCU1_Type) SetBASE_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0xfffffe00)|value<<9)
}
func (o *CCU1_Type) GetBASE_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0xfffffe00) >> 9
}

// CCU1.CLK_APB3_BUS_CFG: CLK_APB3_BUS clock configuration register
func (o *CCU1_Type) SetCLK_APB3_BUS_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_BUS_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_BUS_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_BUS_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_BUS_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_BUS_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_BUS_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_BUS_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_BUS_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_BUS_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_BUS_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_BUS_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_BUS_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_BUS_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_BUS_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_BUS_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_BUS_STAT: CLK_APB3_BUS clock status register
func (o *CCU1_Type) SetCLK_APB3_BUS_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_BUS_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_BUS_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_BUS_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_BUS_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_BUS_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_BUS_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_BUS_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_BUS_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_BUS_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_BUS_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_BUS_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_BUS_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_BUS_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_BUS_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_BUS_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_I2C1_CFG: CLK_APB3_I2C1 clock configuration register
func (o *CCU1_Type) SetCLK_APB3_I2C1_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_I2C1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_I2C1_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_I2C1_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_I2C1_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_I2C1_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_I2C1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_I2C1_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_I2C1_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_I2C1_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_I2C1_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_I2C1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_I2C1_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_I2C1_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_I2C1_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_I2C1_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_I2C1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_I2C1_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_I2C1_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_I2C1_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_I2C1_STAT: CLK_APB3_I2C1 clock status register
func (o *CCU1_Type) SetCLK_APB3_I2C1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_I2C1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_I2C1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_I2C1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_I2C1_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_I2C1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_I2C1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_I2C1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_I2C1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_I2C1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_I2C1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_I2C1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_I2C1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_I2C1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_I2C1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_I2C1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_I2C1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_I2C1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_I2C1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_I2C1_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_DAC_CFG: CLK_APB3_DAC clock configuration register
func (o *CCU1_Type) SetCLK_APB3_DAC_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_DAC_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_DAC_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_DAC_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_DAC_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_DAC_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_DAC_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_DAC_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_DAC_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_DAC_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_DAC_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_DAC_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_DAC_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_DAC_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_DAC_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_DAC_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_DAC_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_DAC_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_DAC_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_DAC_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_DAC_STAT: CLK_APB3_DAC clock status register
func (o *CCU1_Type) SetCLK_APB3_DAC_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_DAC_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_DAC_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_DAC_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_DAC_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_DAC_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_DAC_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_DAC_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_DAC_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_DAC_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_DAC_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_DAC_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_DAC_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_DAC_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_DAC_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_DAC_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_DAC_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_DAC_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_DAC_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_DAC_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_ADC0_CFG: CLK_APB3_ADC0 clock configuration register
func (o *CCU1_Type) SetCLK_APB3_ADC0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_ADC0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_ADC0_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_ADC0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_ADC0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_ADC0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_ADC0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_ADC0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_ADC0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_ADC0_STAT: CLK_APB3_ADC0 clock status register
func (o *CCU1_Type) SetCLK_APB3_ADC0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_ADC0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_ADC0_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_ADC0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_ADC0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_ADC0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_ADC0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_ADC0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_ADC0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_ADC1_CFG: CLK_APB3_ADC1 clock configuration register
func (o *CCU1_Type) SetCLK_APB3_ADC1_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC1_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_ADC1_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_ADC1_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_ADC1_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC1_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_ADC1_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC1_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_ADC1_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC1_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_ADC1_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC1_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_ADC1_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC1_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_ADC1_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC1_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_ADC1_STAT: CLK_APB3_ADC1 clock status register
func (o *CCU1_Type) SetCLK_APB3_ADC1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_ADC1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_ADC1_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_ADC1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_ADC1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_ADC1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_ADC1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_ADC1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_ADC1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_ADC1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_ADC1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_ADC1_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_CAN0_CFG: CLK_APB3_CAN0 clock configuration register
func (o *CCU1_Type) SetCLK_APB3_CAN0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_CAN0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_CAN0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_CAN0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_CAN0_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_CAN0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_CAN0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_CAN0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_CAN0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_CAN0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_CAN0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_CAN0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_CAN0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_CAN0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_CAN0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_CAN0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_CAN0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB3_CAN0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_CAN0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_CAN0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB3_CAN0_STAT: CLK_APB3_CAN0 clock status register
func (o *CCU1_Type) SetCLK_APB3_CAN0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_CAN0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_CAN0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB3_CAN0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB3_CAN0_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB3_CAN0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_CAN0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_CAN0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB3_CAN0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_CAN0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB3_CAN0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_CAN0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_CAN0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB3_CAN0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_CAN0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB3_CAN0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB3_CAN0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB3_CAN0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB3_CAN0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB3_CAN0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_BUS_CFG: CLK_APB1_BUS clock configuration register
func (o *CCU1_Type) SetCLK_APB1_BUS_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_BUS_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_BUS_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_BUS_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_BUS_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_BUS_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_BUS_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_BUS_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_BUS_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_BUS_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_BUS_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_BUS_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_BUS_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_BUS_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_BUS_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_BUS_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_BUS_STAT: CLK_APB1_BUS clock status register
func (o *CCU1_Type) SetCLK_APB1_BUS_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_BUS_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_BUS_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_BUS_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_BUS_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_BUS_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_BUS_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_BUS_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_BUS_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_BUS_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_BUS_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_BUS_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_BUS_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_BUS_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_BUS_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_BUS_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_MOTOCONPWM_CFG: CLK_APB1_MOTOCONPWM clock configuration register
func (o *CCU1_Type) SetCLK_APB1_MOTOCONPWM_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_MOTOCONPWM_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_MOTOCONPWM_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_MOTOCONPWM_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_MOTOCONPWM_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_MOTOCONPWM_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_MOTOCONPWM_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_MOTOCONPWM_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_MOTOCONPWM_STAT: CLK_APB1_MOTOCONPWM clock status register
func (o *CCU1_Type) SetCLK_APB1_MOTOCONPWM_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_MOTOCONPWM_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_MOTOCONPWM_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_MOTOCONPWM_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_MOTOCONPWM_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_MOTOCONPWM_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_MOTOCONPWM_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_MOTOCONPWM_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_MOTOCONPWM_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_I2C0_CFG: CLK_ABP1_I2C0 clock configuration register
func (o *CCU1_Type) SetCLK_APB1_I2C0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2C0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_I2C0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_I2C0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_I2C0_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_I2C0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2C0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_I2C0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_I2C0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2C0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_I2C0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2C0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_I2C0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_I2C0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2C0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_I2C0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2C0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_I2C0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_I2C0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2C0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_I2C0_STAT: CLK_APB1_I2C0 clock status register
func (o *CCU1_Type) SetCLK_APB1_I2C0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2C0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_I2C0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_I2C0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_I2C0_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_I2C0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2C0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_I2C0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_I2C0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2C0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_I2C0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2C0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_I2C0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_I2C0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2C0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_I2C0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2C0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_I2C0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_I2C0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2C0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_I2S_CFG: CLK_APB1_I2S clock configuration register
func (o *CCU1_Type) SetCLK_APB1_I2S_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2S_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_I2S_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_I2S_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_I2S_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_I2S_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2S_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_I2S_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_I2S_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2S_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_I2S_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2S_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_I2S_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_I2S_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2S_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_I2S_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2S_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_I2S_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_I2S_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2S_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_I2S_STAT: CLK_APB1_I2S clock status register
func (o *CCU1_Type) SetCLK_APB1_I2S_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2S_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_I2S_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_I2S_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_I2S_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_I2S_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2S_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_I2S_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_I2S_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2S_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_I2S_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2S_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_I2S_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_I2S_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2S_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_I2S_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_I2S_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_I2S_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_I2S_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_I2S_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_CAN1_CFG: CLK_APB1_CAN1 clock configuration register
func (o *CCU1_Type) SetCLK_APB1_CAN1_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_CAN1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_CAN1_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_CAN1_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_CAN1_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_CAN1_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_CAN1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_CAN1_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_CAN1_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_CAN1_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_CAN1_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_CAN1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_CAN1_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_CAN1_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_CAN1_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_CAN1_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_CAN1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB1_CAN1_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_CAN1_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_CAN1_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_APB1_CAN1_STAT: CLK_APB1_CAN1 clock status register
func (o *CCU1_Type) SetCLK_APB1_CAN1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_CAN1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_CAN1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_APB1_CAN1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB1_CAN1_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_APB1_CAN1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_CAN1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_CAN1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_APB1_CAN1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_CAN1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_APB1_CAN1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_CAN1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_CAN1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_APB1_CAN1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_CAN1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_APB1_CAN1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB1_CAN1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB1_CAN1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_APB1_CAN1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB1_CAN1_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_SPIFI_CFG: CLK_SPIFI clock configuration register
func (o *CCU1_Type) SetCLK_SPIFI_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_SPIFI_CFG.Reg, volatile.LoadUint32(&o.CLK_SPIFI_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_SPIFI_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_SPIFI_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_SPIFI_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_SPIFI_CFG.Reg, volatile.LoadUint32(&o.CLK_SPIFI_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_SPIFI_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_SPIFI_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_SPIFI_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_SPIFI_CFG.Reg, volatile.LoadUint32(&o.CLK_SPIFI_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_SPIFI_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_SPIFI_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_SPIFI_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_SPIFI_CFG.Reg, volatile.LoadUint32(&o.CLK_SPIFI_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_SPIFI_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_SPIFI_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_SPIFI_STAT: CLK_APB1_SPIFI clock status register
func (o *CCU1_Type) SetCLK_SPIFI_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_SPIFI_STAT.Reg, volatile.LoadUint32(&o.CLK_SPIFI_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_SPIFI_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_SPIFI_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_SPIFI_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_SPIFI_STAT.Reg, volatile.LoadUint32(&o.CLK_SPIFI_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_SPIFI_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_SPIFI_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_SPIFI_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_SPIFI_STAT.Reg, volatile.LoadUint32(&o.CLK_SPIFI_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_SPIFI_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_SPIFI_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_SPIFI_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_SPIFI_STAT.Reg, volatile.LoadUint32(&o.CLK_SPIFI_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_SPIFI_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_SPIFI_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_BUS_CFG: CLK_M3_BUS clock configuration register
func (o *CCU1_Type) SetCLK_M3_BUS_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_BUS_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_BUS_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_BUS_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_BUS_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_BUS_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_BUS_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_BUS_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_BUS_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_BUS_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_BUS_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_BUS_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_BUS_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_BUS_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_BUS_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_BUS_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_BUS_STAT: CLK_M4_BUSclock status register
func (o *CCU1_Type) SetCLK_M3_BUS_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_BUS_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_BUS_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_BUS_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_BUS_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_BUS_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_BUS_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_BUS_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_BUS_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_BUS_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_BUS_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_BUS_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_BUS_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_BUS_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_BUS_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_BUS_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_BUS_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SPIFI_CFG: CLK_M3_SPIFI clock configuration register
func (o *CCU1_Type) SetCLK_M3_SPIFI_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SPIFI_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SPIFI_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SPIFI_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SPIFI_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SPIFI_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SPIFI_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SPIFI_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SPIFI_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SPIFI_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SPIFI_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SPIFI_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SPIFI_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SPIFI_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SPIFI_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SPIFI_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SPIFI_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SPIFI_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SPIFI_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SPIFI_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SPIFI_STAT: CLK_M3_SPIFI clock status register
func (o *CCU1_Type) SetCLK_M3_SPIFI_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SPIFI_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SPIFI_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SPIFI_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SPIFI_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SPIFI_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SPIFI_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SPIFI_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SPIFI_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SPIFI_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SPIFI_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SPIFI_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SPIFI_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SPIFI_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SPIFI_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SPIFI_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SPIFI_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SPIFI_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SPIFI_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SPIFI_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_GPIO_CFG: CLK_M3_GPIO clock configuration register
func (o *CCU1_Type) SetCLK_M3_GPIO_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_GPIO_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_GPIO_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_GPIO_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_GPIO_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_GPIO_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_GPIO_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_GPIO_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_GPIO_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_GPIO_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_GPIO_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_GPIO_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_GPIO_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_GPIO_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_GPIO_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_GPIO_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_GPIO_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_GPIO_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_GPIO_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_GPIO_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_GPIO_STAT: CLK_M3_GPIO clock status register
func (o *CCU1_Type) SetCLK_M3_GPIO_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_GPIO_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_GPIO_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_GPIO_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_GPIO_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_GPIO_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_GPIO_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_GPIO_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_GPIO_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_GPIO_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_GPIO_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_GPIO_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_GPIO_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_GPIO_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_GPIO_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_GPIO_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_GPIO_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_GPIO_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_GPIO_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_GPIO_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_LCD_CFG: CLK_M3_LCD clock configuration register
func (o *CCU1_Type) SetCLK_M3_LCD_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_LCD_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_LCD_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_LCD_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_LCD_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_LCD_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_LCD_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_LCD_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_LCD_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_LCD_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_LCD_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_LCD_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_LCD_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_LCD_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_LCD_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_LCD_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_LCD_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_LCD_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_LCD_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_LCD_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_LCD_STAT: CLK_M3_LCD clock status register
func (o *CCU1_Type) SetCLK_M3_LCD_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_LCD_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_LCD_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_LCD_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_LCD_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_LCD_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_LCD_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_LCD_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_LCD_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_LCD_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_LCD_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_LCD_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_LCD_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_LCD_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_LCD_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_LCD_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_LCD_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_LCD_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_LCD_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_LCD_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_ETHERNET_CFG: CLK_M3_ETHERNET clock configuration register
func (o *CCU1_Type) SetCLK_M3_ETHERNET_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_ETHERNET_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_ETHERNET_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_ETHERNET_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_ETHERNET_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_ETHERNET_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_ETHERNET_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_ETHERNET_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_ETHERNET_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_ETHERNET_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_ETHERNET_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_ETHERNET_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_ETHERNET_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_ETHERNET_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_ETHERNET_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_ETHERNET_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_ETHERNET_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_ETHERNET_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_ETHERNET_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_ETHERNET_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_ETHERNET_STAT: CLK_M3_ETHERNET clock status register
func (o *CCU1_Type) SetCLK_M3_ETHERNET_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_ETHERNET_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_ETHERNET_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_ETHERNET_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_ETHERNET_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_ETHERNET_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_ETHERNET_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_ETHERNET_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_ETHERNET_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_ETHERNET_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_ETHERNET_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_ETHERNET_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_ETHERNET_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_ETHERNET_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_ETHERNET_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_ETHERNET_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_ETHERNET_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_ETHERNET_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_ETHERNET_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_ETHERNET_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USB0_CFG: CLK_M3_USB0 clock configuration register
func (o *CCU1_Type) SetCLK_M3_USB0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USB0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USB0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USB0_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USB0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USB0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USB0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USB0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USB0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USB0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USB0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USB0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USB0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USB0_STAT: CLK_M3_USB0 clock status register
func (o *CCU1_Type) SetCLK_M3_USB0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USB0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USB0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USB0_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USB0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USB0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USB0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USB0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USB0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USB0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USB0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USB0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USB0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_EMC_CFG: CLK_M3_EMC clock configuration register
func (o *CCU1_Type) SetCLK_M3_EMC_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMC_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMC_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_EMC_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_EMC_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_EMC_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMC_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMC_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_EMC_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMC_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_EMC_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMC_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMC_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_EMC_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMC_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_EMC_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMC_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMC_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_EMC_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMC_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_EMC_STAT: CLK_M3_EMC clock status register
func (o *CCU1_Type) SetCLK_M3_EMC_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMC_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMC_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_EMC_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_EMC_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_EMC_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMC_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMC_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_EMC_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMC_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_EMC_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMC_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMC_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_EMC_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMC_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_EMC_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMC_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMC_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_EMC_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMC_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SDIO_CFG: CLK_M3_SDIO clock configuration register
func (o *CCU1_Type) SetCLK_M3_SDIO_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SDIO_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SDIO_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SDIO_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SDIO_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SDIO_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SDIO_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SDIO_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SDIO_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SDIO_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SDIO_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SDIO_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SDIO_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SDIO_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SDIO_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SDIO_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SDIO_STAT: CLK_M3_SDIO clock status register
func (o *CCU1_Type) SetCLK_M3_SDIO_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SDIO_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SDIO_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SDIO_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SDIO_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SDIO_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SDIO_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SDIO_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SDIO_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SDIO_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SDIO_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SDIO_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SDIO_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SDIO_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SDIO_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SDIO_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_DMA_CFG: CLK_M3_DMA clock configuration register
func (o *CCU1_Type) SetCLK_M3_DMA_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_DMA_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_DMA_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_DMA_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_DMA_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_DMA_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_DMA_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_DMA_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_DMA_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_DMA_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_DMA_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_DMA_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_DMA_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_DMA_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_DMA_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_DMA_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_DMA_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_DMA_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_DMA_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_DMA_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_DMA_STAT: CLK_M3_DMA clock status register
func (o *CCU1_Type) SetCLK_M3_DMA_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_DMA_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_DMA_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_DMA_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_DMA_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_DMA_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_DMA_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_DMA_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_DMA_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_DMA_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_DMA_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_DMA_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_DMA_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_DMA_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_DMA_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_DMA_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_DMA_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_DMA_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_DMA_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_DMA_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_M3CORE_CFG: CLK_M3_M3CORE clock configuration register
func (o *CCU1_Type) SetCLK_M3_M3CORE_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_M3CORE_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_M3CORE_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_M3CORE_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_M3CORE_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_M3CORE_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_M3CORE_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_M3CORE_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_M3CORE_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_M3CORE_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_M3CORE_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_M3CORE_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_M3CORE_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_M3CORE_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_M3CORE_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_M3CORE_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_M3CORE_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_M3CORE_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_M3CORE_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_M3CORE_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_M3CORE_STAT: CLK_M3_M3CORE clock status register
func (o *CCU1_Type) SetCLK_M3_M3CORE_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_M3CORE_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_M3CORE_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_M3CORE_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_M3CORE_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_M3CORE_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_M3CORE_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_M3CORE_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_M3CORE_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_M3CORE_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_M3CORE_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_M3CORE_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_M3CORE_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_M3CORE_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_M3CORE_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_M3CORE_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_M3CORE_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_M3CORE_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_M3CORE_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_M3CORE_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SCT_CFG: CLK_M3_SCT clock configuration register
func (o *CCU1_Type) SetCLK_M3_SCT_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCT_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SCT_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SCT_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SCT_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SCT_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCT_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SCT_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SCT_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCT_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SCT_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCT_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SCT_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SCT_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCT_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SCT_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCT_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SCT_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SCT_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCT_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SCT_STAT: CLK_M3_SCT clock status register
func (o *CCU1_Type) SetCLK_M3_SCT_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCT_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SCT_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SCT_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SCT_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SCT_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCT_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SCT_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SCT_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCT_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SCT_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCT_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SCT_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SCT_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCT_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SCT_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCT_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SCT_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SCT_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCT_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USB1_CFG: CLK_M3_USB1 clock configuration register
func (o *CCU1_Type) SetCLK_M3_USB1_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USB1_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USB1_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USB1_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USB1_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USB1_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USB1_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB1_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USB1_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USB1_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USB1_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB1_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USB1_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USB1_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USB1_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB1_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USB1_STAT: CLK_M3_USB1 clock status register
func (o *CCU1_Type) SetCLK_M3_USB1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USB1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USB1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USB1_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USB1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USB1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USB1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USB1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USB1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USB1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USB1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USB1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USB1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USB1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USB1_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_EMCDIV_CFG: CLK_M3_EMCDIV clock configuration register
func (o *CCU1_Type) SetCLK_M3_EMCDIV_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg)&^(0x18)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg) & 0x18) >> 3
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_CFG_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg)&^(0xe0)|value<<5)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_CFG_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg) & 0xe0) >> 5
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg)&^(0xffffff00)|value<<8)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_CFG.Reg) & 0xffffff00) >> 8
}

// CCU1.CLK_M3_EMCDIV_STAT: CLK_M3_EMCDIV clock status register
func (o *CCU1_Type) SetCLK_M3_EMCDIV_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg)&^(0x18)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg) & 0x18) >> 3
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_STAT_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg)&^(0xe0)|value<<5)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_STAT_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg) & 0xe0) >> 5
}
func (o *CCU1_Type) SetCLK_M3_EMCDIV_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EMCDIV_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *CCU1_Type) GetCLK_M3_EMCDIV_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EMCDIV_STAT.Reg) & 0xffffff00) >> 8
}

// CCU1.CLK_M3_FLASHA_CFG: CLK_M3_FLASHA clock configuration register
func (o *CCU1_Type) SetCLK_M3_FLASHA_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHA_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHA_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_FLASHA_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_FLASHA_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_FLASHA_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHA_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHA_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_FLASHA_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHA_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_FLASHA_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHA_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHA_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_FLASHA_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHA_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_FLASHA_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHA_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHA_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_FLASHA_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHA_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_FLASHA_STAT: CLK_M3_FLASHA clock status register
func (o *CCU1_Type) SetCLK_M3_FLASHA_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHA_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHA_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_FLASHA_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_FLASHA_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_FLASHA_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHA_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHA_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_FLASHA_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHA_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_FLASHA_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHA_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHA_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_FLASHA_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHA_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_FLASHA_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHA_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHA_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_FLASHA_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHA_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_FLASHB_CFG: CLK_M3_FLASHB clock configuration register
func (o *CCU1_Type) SetCLK_M3_FLASHB_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHB_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHB_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_FLASHB_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_FLASHB_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_FLASHB_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHB_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHB_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_FLASHB_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHB_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_FLASHB_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHB_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHB_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_FLASHB_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHB_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_FLASHB_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHB_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHB_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_FLASHB_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHB_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_FLASHB_STAT: CLK_M3_FLASHB clock status register
func (o *CCU1_Type) SetCLK_M3_FLASHB_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHB_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHB_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_FLASHB_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_FLASHB_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_FLASHB_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHB_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHB_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_FLASHB_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHB_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_FLASHB_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHB_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHB_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_FLASHB_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHB_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_FLASHB_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_FLASHB_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_FLASHB_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_FLASHB_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_FLASHB_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_EEPROM_CFG: CLK_EEPROM_CFG clock configuration register
func (o *CCU1_Type) SetCLK_M3_EEPROM_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EEPROM_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EEPROM_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_EEPROM_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_EEPROM_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_EEPROM_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EEPROM_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EEPROM_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_EEPROM_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EEPROM_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_EEPROM_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EEPROM_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EEPROM_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_EEPROM_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EEPROM_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_EEPROM_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EEPROM_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_EEPROM_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_EEPROM_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EEPROM_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_EEPROM_STAT: CLK_M3_EEPROM clock status register
func (o *CCU1_Type) SetCLK_M3_EEPROM_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EEPROM_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EEPROM_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_EEPROM_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_EEPROM_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_EEPROM_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EEPROM_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EEPROM_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_EEPROM_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EEPROM_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_EEPROM_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EEPROM_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EEPROM_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_EEPROM_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EEPROM_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_EEPROM_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_EEPROM_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_EEPROM_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_EEPROM_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_EEPROM_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_WWDT_CFG: CLK_M3_WWDT clock configuration register
func (o *CCU1_Type) SetCLK_M3_WWDT_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_WWDT_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_WWDT_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_WWDT_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_WWDT_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_WWDT_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_WWDT_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_WWDT_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_WWDT_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_WWDT_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_WWDT_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_WWDT_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_WWDT_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_WWDT_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_WWDT_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_WWDT_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_WWDT_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_WWDT_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_WWDT_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_WWDT_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_WWDT_STAT: CLK_M3_WWDT clock status register
func (o *CCU1_Type) SetCLK_M3_WWDT_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_WWDT_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_WWDT_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_WWDT_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_WWDT_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_WWDT_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_WWDT_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_WWDT_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_WWDT_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_WWDT_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_WWDT_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_WWDT_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_WWDT_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_WWDT_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_WWDT_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_WWDT_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_WWDT_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_WWDT_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_WWDT_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_WWDT_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USART0_CFG: CLK_M3_USART0 clock configuration register
func (o *CCU1_Type) SetCLK_M3_USART0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USART0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USART0_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USART0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USART0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USART0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USART0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USART0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USART0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USART0_STAT: CLK_M3_USART0 clock status register
func (o *CCU1_Type) SetCLK_M3_USART0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USART0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USART0_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USART0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USART0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USART0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USART0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USART0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USART0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_UART1_CFG: CLK_M3_UART1 clock configuration register
func (o *CCU1_Type) SetCLK_M3_UART1_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_UART1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_UART1_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_UART1_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_UART1_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_UART1_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_UART1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_UART1_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_UART1_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_UART1_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_UART1_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_UART1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_UART1_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_UART1_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_UART1_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_UART1_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_UART1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_UART1_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_UART1_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_UART1_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_UART1_STAT: CLK_M3_UART1 clock status register
func (o *CCU1_Type) SetCLK_M3_UART1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_UART1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_UART1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_UART1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_UART1_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_UART1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_UART1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_UART1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_UART1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_UART1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_UART1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_UART1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_UART1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_UART1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_UART1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_UART1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_UART1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_UART1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_UART1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_UART1_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SSP0_CFG: CLK_M3_SSP0 clock configuration register
func (o *CCU1_Type) SetCLK_M3_SSP0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SSP0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SSP0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SSP0_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SSP0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SSP0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SSP0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SSP0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SSP0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SSP0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SSP0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SSP0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SSP0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SSP0_STAT: CLK_M3_SSP0 clock status register
func (o *CCU1_Type) SetCLK_M3_SSP0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SSP0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SSP0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SSP0_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SSP0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SSP0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SSP0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SSP0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SSP0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SSP0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SSP0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SSP0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SSP0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_TIMER0_CFG: CLK_M3_TIMER0 clock configuration register
func (o *CCU1_Type) SetCLK_M3_TIMER0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_TIMER0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_TIMER0_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_TIMER0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_TIMER0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_TIMER0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_TIMER0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_TIMER0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER0_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_TIMER0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_TIMER0_STAT: CLK_M3_TIMER0 clock status register
func (o *CCU1_Type) SetCLK_M3_TIMER0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_TIMER0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_TIMER0_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_TIMER0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_TIMER0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_TIMER0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_TIMER0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_TIMER0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER0_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_TIMER0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_TIMER1_CFG: CLK_M3_TIMER1clock configuration register
func (o *CCU1_Type) SetCLK_M3_TIMER1_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER1_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_TIMER1_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_TIMER1_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_TIMER1_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER1_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_TIMER1_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER1_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_TIMER1_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER1_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_TIMER1_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER1_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_TIMER1_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER1_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_TIMER1_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER1_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_TIMER1_STAT: CLK_M3_TIMER1 clock status register
func (o *CCU1_Type) SetCLK_M3_TIMER1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_TIMER1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_TIMER1_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_TIMER1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_TIMER1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_TIMER1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_TIMER1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_TIMER1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_TIMER1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER1_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SCU_CFG: CLK_M3_SCU clock configuration register
func (o *CCU1_Type) SetCLK_M3_SCU_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCU_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SCU_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SCU_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SCU_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SCU_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCU_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SCU_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SCU_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCU_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SCU_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCU_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SCU_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SCU_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCU_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SCU_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCU_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SCU_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SCU_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCU_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SCU_STAT: CLK_SCU_XXX clock status register
func (o *CCU1_Type) SetCLK_M3_SCU_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCU_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SCU_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SCU_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SCU_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SCU_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCU_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SCU_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SCU_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCU_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SCU_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCU_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SCU_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SCU_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCU_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SCU_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SCU_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SCU_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SCU_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SCU_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_CREG_CFG: CLK_M3_CREG clock configuration register
func (o *CCU1_Type) SetCLK_M3_CREG_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_CREG_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_CREG_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_CREG_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_CREG_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_CREG_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_CREG_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_CREG_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_CREG_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_CREG_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_CREG_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_CREG_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_CREG_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_CREG_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_CREG_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_CREG_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_CREG_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_CREG_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_CREG_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_CREG_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_CREG_STAT: CLK_M3_CREG clock status register
func (o *CCU1_Type) SetCLK_M3_CREG_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_CREG_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_CREG_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_CREG_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_CREG_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_CREG_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_CREG_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_CREG_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_CREG_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_CREG_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_CREG_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_CREG_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_CREG_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_CREG_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_CREG_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_CREG_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_CREG_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_CREG_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_CREG_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_CREG_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_RITIMER_CFG: CLK_M3_RITIMER clock configuration register
func (o *CCU1_Type) SetCLK_M3_RITIMER_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_RITIMER_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_RITIMER_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_RITIMER_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_RITIMER_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_RITIMER_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_RITIMER_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_RITIMER_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_RITIMER_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_RITIMER_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_RITIMER_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_RITIMER_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_RITIMER_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_RITIMER_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_RITIMER_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_RITIMER_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_RITIMER_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_RITIMER_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_RITIMER_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_RITIMER_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_RITIMER_STAT: CLK_M3_RITIMER clock status register
func (o *CCU1_Type) SetCLK_M3_RITIMER_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_RITIMER_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_RITIMER_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_RITIMER_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_RITIMER_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_RITIMER_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_RITIMER_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_RITIMER_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_RITIMER_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_RITIMER_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_RITIMER_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_RITIMER_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_RITIMER_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_RITIMER_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_RITIMER_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_RITIMER_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_RITIMER_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_RITIMER_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_RITIMER_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_RITIMER_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USART2_CFG: CLK_M3_USART2 clock configuration register
func (o *CCU1_Type) SetCLK_M3_USART2_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART2_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART2_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USART2_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USART2_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USART2_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART2_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART2_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USART2_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART2_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USART2_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART2_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART2_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USART2_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART2_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USART2_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART2_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART2_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USART2_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART2_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USART2_STAT: CLK_M3_USART2 clock status register
func (o *CCU1_Type) SetCLK_M3_USART2_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART2_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART2_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USART2_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USART2_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USART2_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART2_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART2_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USART2_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART2_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USART2_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART2_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART2_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USART2_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART2_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USART2_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART2_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART2_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USART2_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART2_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USART3_CFG: CLK_M3_USART3 clock configuration register
func (o *CCU1_Type) SetCLK_M3_USART3_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART3_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART3_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USART3_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USART3_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USART3_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART3_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART3_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USART3_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART3_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USART3_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART3_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART3_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USART3_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART3_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USART3_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART3_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_USART3_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USART3_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART3_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_USART3_STAT: CLK_M3_USART3 clock status register
func (o *CCU1_Type) SetCLK_M3_USART3_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART3_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART3_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_USART3_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_USART3_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_USART3_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART3_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART3_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_USART3_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART3_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_USART3_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART3_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART3_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_USART3_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART3_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_USART3_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_USART3_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_USART3_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_USART3_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_USART3_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_TIMER2_CFG: CLK_M3_TIMER2 clock configuration register
func (o *CCU1_Type) SetCLK_M3_TIMER2_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER2_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER2_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_TIMER2_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_TIMER2_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_TIMER2_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER2_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER2_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_TIMER2_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER2_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_TIMER2_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER2_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER2_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_TIMER2_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER2_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_TIMER2_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER2_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER2_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_TIMER2_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER2_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_TIMER2_STAT: CLK_M3_TIMER2 clock status register
func (o *CCU1_Type) SetCLK_M3_TIMER2_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER2_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER2_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_TIMER2_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_TIMER2_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_TIMER2_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER2_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER2_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_TIMER2_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER2_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_TIMER2_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER2_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER2_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_TIMER2_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER2_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_TIMER2_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER2_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER2_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_TIMER2_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER2_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_TIMER3_CFG: CLK_M3_TIMER3 clock configuration register
func (o *CCU1_Type) SetCLK_M3_TIMER3_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER3_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER3_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_TIMER3_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_TIMER3_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_TIMER3_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER3_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER3_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_TIMER3_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER3_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_TIMER3_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER3_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER3_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_TIMER3_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER3_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_TIMER3_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER3_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER3_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_TIMER3_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER3_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_TIMER3_STAT: CLK_M3_TIMER3 clock status register
func (o *CCU1_Type) SetCLK_M3_TIMER3_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER3_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER3_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_TIMER3_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_TIMER3_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_TIMER3_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER3_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER3_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_TIMER3_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER3_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_TIMER3_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER3_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER3_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_TIMER3_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER3_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_TIMER3_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_TIMER3_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_TIMER3_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_TIMER3_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_TIMER3_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SSP1_CFG: CLK_M3_SSP1 clock configuration register
func (o *CCU1_Type) SetCLK_M3_SSP1_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SSP1_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SSP1_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SSP1_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SSP1_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SSP1_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SSP1_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP1_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SSP1_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SSP1_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SSP1_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP1_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SSP1_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP1_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_SSP1_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SSP1_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP1_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_SSP1_STAT: CLK_M3_SSP1 clock status register
func (o *CCU1_Type) SetCLK_M3_SSP1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SSP1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_SSP1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_SSP1_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_SSP1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SSP1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_SSP1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_SSP1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SSP1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_SSP1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_SSP1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_SSP1_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_SSP1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_SSP1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_SSP1_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_QEI_CFG: CLK_M3_QEIclock configuration register
func (o *CCU1_Type) SetCLK_M3_QEI_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_QEI_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_QEI_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_QEI_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_QEI_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_QEI_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_QEI_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_QEI_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_QEI_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_QEI_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_QEI_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_QEI_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_QEI_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_QEI_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_QEI_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_QEI_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_QEI_CFG.Reg, volatile.LoadUint32(&o.CLK_M3_QEI_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_QEI_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_QEI_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_M3_QEI_STAT: CLK_M3_QEI clock status register
func (o *CCU1_Type) SetCLK_M3_QEI_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_QEI_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_QEI_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_M3_QEI_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_M3_QEI_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_M3_QEI_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_QEI_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_QEI_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_M3_QEI_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_QEI_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_M3_QEI_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_QEI_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_QEI_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_M3_QEI_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_QEI_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_M3_QEI_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_M3_QEI_STAT.Reg, volatile.LoadUint32(&o.CLK_M3_QEI_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_M3_QEI_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_M3_QEI_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_USB0_CFG: CLK_USB0 clock configuration register
func (o *CCU1_Type) SetCLK_USB0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_USB0_CFG.Reg, volatile.LoadUint32(&o.CLK_USB0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_USB0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_USB0_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_USB0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_USB0_CFG.Reg, volatile.LoadUint32(&o.CLK_USB0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_USB0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_USB0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_USB0_CFG.Reg, volatile.LoadUint32(&o.CLK_USB0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_USB0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_USB0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_USB0_CFG.Reg, volatile.LoadUint32(&o.CLK_USB0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_USB0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_USB0_STAT: CLK_USB0 clock status register
func (o *CCU1_Type) SetCLK_USB0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_USB0_STAT.Reg, volatile.LoadUint32(&o.CLK_USB0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_USB0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_USB0_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_USB0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_USB0_STAT.Reg, volatile.LoadUint32(&o.CLK_USB0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_USB0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_USB0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_USB0_STAT.Reg, volatile.LoadUint32(&o.CLK_USB0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_USB0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_USB0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_USB0_STAT.Reg, volatile.LoadUint32(&o.CLK_USB0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_USB0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_USB1_CFG: CLK_USB1 clock configuration register
func (o *CCU1_Type) SetCLK_USB1_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_USB1_CFG.Reg, volatile.LoadUint32(&o.CLK_USB1_CFG.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_USB1_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_USB1_CFG.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_USB1_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_USB1_CFG.Reg, volatile.LoadUint32(&o.CLK_USB1_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_USB1_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB1_CFG.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_USB1_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_USB1_CFG.Reg, volatile.LoadUint32(&o.CLK_USB1_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_USB1_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB1_CFG.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_USB1_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_USB1_CFG.Reg, volatile.LoadUint32(&o.CLK_USB1_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_USB1_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB1_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU1.CLK_USB1_STAT: CLK_USB1 clock status register
func (o *CCU1_Type) SetCLK_USB1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_USB1_STAT.Reg, volatile.LoadUint32(&o.CLK_USB1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU1_Type) GetCLK_USB1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_USB1_STAT.Reg) & 0x1
}
func (o *CCU1_Type) SetCLK_USB1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_USB1_STAT.Reg, volatile.LoadUint32(&o.CLK_USB1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU1_Type) GetCLK_USB1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU1_Type) SetCLK_USB1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_USB1_STAT.Reg, volatile.LoadUint32(&o.CLK_USB1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU1_Type) GetCLK_USB1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU1_Type) SetCLK_USB1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_USB1_STAT.Reg, volatile.LoadUint32(&o.CLK_USB1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU1_Type) GetCLK_USB1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB1_STAT.Reg) & 0xfffffff8) >> 3
}

// Clock Control Unit (CCU2)
type CCU2_Type struct {
	PM                     volatile.Register32 // 0x0
	BASE_STAT              volatile.Register32 // 0x4
	_                      [248]byte
	CLK_AUDIO_CFG          volatile.Register32 // 0x100
	CLK_AUDIO_STAT         volatile.Register32 // 0x104
	_                      [248]byte
	CLK_APB2_USART3_CFG    volatile.Register32 // 0x200
	CLK_APB2_USART3_STAT   volatile.Register32 // 0x204
	_                      [248]byte
	CLK_APB2_USART2_CFG    volatile.Register32 // 0x300
	CLK_APB2_USART2_STAT   volatile.Register32 // 0x304
	_                      [248]byte
	CLK_APB0_UART1_BUS_CFG volatile.Register32 // 0x400
	CLK_APB0_UART1_STAT    volatile.Register32 // 0x404
	_                      [248]byte
	CLK_APB0_USART0_CFG    volatile.Register32 // 0x500
	CLK_APB0_USART0_STAT   volatile.Register32 // 0x504
	_                      [248]byte
	CLK_APB2_SSP1_CFG      volatile.Register32 // 0x600
	CLK_APB2_SSP1_STAT     volatile.Register32 // 0x604
	_                      [248]byte
	CLK_APB0_SSP0_CFG      volatile.Register32 // 0x700
	CLK_APB0_SSP0_STAT     volatile.Register32 // 0x704
	_                      [248]byte
	CLK_SDIO_CFG           volatile.Register32 // 0x800
	CLK_SDIO_STAT          volatile.Register32 // 0x804
}

// CCU2.PM: Power mode register
func (o *CCU2_Type) SetPM_PD(value uint32) {
	volatile.StoreUint32(&o.PM.Reg, volatile.LoadUint32(&o.PM.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetPM_PD() uint32 {
	return volatile.LoadUint32(&o.PM.Reg) & 0x1
}
func (o *CCU2_Type) SetPM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PM.Reg, volatile.LoadUint32(&o.PM.Reg)&^(0xfffffffe)|value<<1)
}
func (o *CCU2_Type) GetPM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PM.Reg) & 0xfffffffe) >> 1
}

// CCU2.BASE_STAT: CCU base clocks status register
func (o *CCU2_Type) SetBASE_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetBASE_STAT_RESERVED() uint32 {
	return volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x1
}
func (o *CCU2_Type) SetBASE_STAT_BASE_UART3_CLK(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetBASE_STAT_BASE_UART3_CLK() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetBASE_STAT_BASE_UART2_CLK(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetBASE_STAT_BASE_UART2_CLK() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetBASE_STAT_BASE_UART1_CLK(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x8)|value<<3)
}
func (o *CCU2_Type) GetBASE_STAT_BASE_UART1_CLK() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x8) >> 3
}
func (o *CCU2_Type) SetBASE_STAT_BASE_UART0_CLK(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x10)|value<<4)
}
func (o *CCU2_Type) GetBASE_STAT_BASE_UART0_CLK() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x10) >> 4
}
func (o *CCU2_Type) SetBASE_STAT_BASE_SSP1_CLK(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x20)|value<<5)
}
func (o *CCU2_Type) GetBASE_STAT_BASE_SSP1_CLK() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x20) >> 5
}
func (o *CCU2_Type) SetBASE_STAT_BASE_SSP0_CLK(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x40)|value<<6)
}
func (o *CCU2_Type) GetBASE_STAT_BASE_SSP0_CLK() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x40) >> 6
}
func (o *CCU2_Type) SetBASE_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0x80)|value<<7)
}
func (o *CCU2_Type) GetBASE_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0x80) >> 7
}
func (o *CCU2_Type) SetBASE_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BASE_STAT.Reg, volatile.LoadUint32(&o.BASE_STAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *CCU2_Type) GetBASE_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BASE_STAT.Reg) & 0xffffff00) >> 8
}

// CCU2.CLK_AUDIO_CFG: CLK_AUDIO clock configuration register
func (o *CCU2_Type) SetCLK_AUDIO_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_AUDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_AUDIO_CFG.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_AUDIO_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_AUDIO_CFG.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_AUDIO_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_AUDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_AUDIO_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_AUDIO_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_AUDIO_CFG.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_AUDIO_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_AUDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_AUDIO_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_AUDIO_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_AUDIO_CFG.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_AUDIO_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_AUDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_AUDIO_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_AUDIO_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_AUDIO_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_AUDIO_STAT: CLK_AUDIO clock status register
func (o *CCU2_Type) SetCLK_AUDIO_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_AUDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_AUDIO_STAT.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_AUDIO_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_AUDIO_STAT.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_AUDIO_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_AUDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_AUDIO_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_AUDIO_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_AUDIO_STAT.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_AUDIO_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_AUDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_AUDIO_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_AUDIO_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_AUDIO_STAT.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_AUDIO_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_AUDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_AUDIO_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_AUDIO_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_AUDIO_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB2_USART3_CFG: CLK_APB2_USART3 clock configuration register
func (o *CCU2_Type) SetCLK_APB2_USART3_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART3_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_USART3_CFG.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB2_USART3_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB2_USART3_CFG.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB2_USART3_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART3_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_USART3_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB2_USART3_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART3_CFG.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB2_USART3_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART3_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_USART3_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB2_USART3_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART3_CFG.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB2_USART3_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART3_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_USART3_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB2_USART3_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART3_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB2_USART3_STAT: CLK_APB2_USART3 clock status register
func (o *CCU2_Type) SetCLK_APB2_USART3_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART3_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_USART3_STAT.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB2_USART3_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB2_USART3_STAT.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB2_USART3_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART3_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_USART3_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB2_USART3_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART3_STAT.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB2_USART3_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART3_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_USART3_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB2_USART3_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART3_STAT.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB2_USART3_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART3_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_USART3_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB2_USART3_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART3_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB2_USART2_CFG: CLK_APB2_USART2 clock configuration register
func (o *CCU2_Type) SetCLK_APB2_USART2_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART2_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_USART2_CFG.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB2_USART2_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB2_USART2_CFG.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB2_USART2_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART2_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_USART2_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB2_USART2_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART2_CFG.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB2_USART2_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART2_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_USART2_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB2_USART2_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART2_CFG.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB2_USART2_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART2_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_USART2_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB2_USART2_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART2_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB2_USART2_STAT: CLK_APB2_USART clock status register
func (o *CCU2_Type) SetCLK_APB2_USART2_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART2_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_USART2_STAT.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB2_USART2_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB2_USART2_STAT.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB2_USART2_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART2_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_USART2_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB2_USART2_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART2_STAT.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB2_USART2_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART2_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_USART2_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB2_USART2_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART2_STAT.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB2_USART2_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_USART2_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_USART2_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB2_USART2_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_USART2_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB0_UART1_BUS_CFG: CLK_APB2_UART1 clock configuration register
func (o *CCU2_Type) SetCLK_APB0_UART1_BUS_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB0_UART1_BUS_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB0_UART1_BUS_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB0_UART1_BUS_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB0_UART1_BUS_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB0_UART1_BUS_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB0_UART1_BUS_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB0_UART1_BUS_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_UART1_BUS_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB0_UART1_STAT: CLK_APB0_UART1 clock status register
func (o *CCU2_Type) SetCLK_APB0_UART1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_UART1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_UART1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB0_UART1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB0_UART1_STAT.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB0_UART1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_UART1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_UART1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB0_UART1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_UART1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB0_UART1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_UART1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_UART1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB0_UART1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_UART1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB0_UART1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_UART1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_UART1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB0_UART1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_UART1_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB0_USART0_CFG: CLK_APB2_USART0 clock configuration register
func (o *CCU2_Type) SetCLK_APB0_USART0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_USART0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_USART0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB0_USART0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB0_USART0_CFG.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB0_USART0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_USART0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_USART0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB0_USART0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_USART0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB0_USART0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_USART0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_USART0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB0_USART0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_USART0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB0_USART0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_USART0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_USART0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB0_USART0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_USART0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB0_USART0_STAT: CLK_APB0_USART0 clock status register
func (o *CCU2_Type) SetCLK_APB0_USART0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_USART0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_USART0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB0_USART0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB0_USART0_STAT.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB0_USART0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_USART0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_USART0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB0_USART0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_USART0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB0_USART0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_USART0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_USART0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB0_USART0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_USART0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB0_USART0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_USART0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_USART0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB0_USART0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_USART0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB2_SSP1_CFG: CLK_APB2_SSP1 clock configuration register
func (o *CCU2_Type) SetCLK_APB2_SSP1_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_SSP1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_SSP1_CFG.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB2_SSP1_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB2_SSP1_CFG.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB2_SSP1_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_SSP1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_SSP1_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB2_SSP1_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_SSP1_CFG.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB2_SSP1_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_SSP1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_SSP1_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB2_SSP1_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_SSP1_CFG.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB2_SSP1_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_SSP1_CFG.Reg, volatile.LoadUint32(&o.CLK_APB2_SSP1_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB2_SSP1_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_SSP1_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB2_SSP1_STAT: CLK_APB2_SSP1 clock status register
func (o *CCU2_Type) SetCLK_APB2_SSP1_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_SSP1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_SSP1_STAT.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB2_SSP1_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB2_SSP1_STAT.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB2_SSP1_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_SSP1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_SSP1_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB2_SSP1_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_SSP1_STAT.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB2_SSP1_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_SSP1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_SSP1_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB2_SSP1_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_SSP1_STAT.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB2_SSP1_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB2_SSP1_STAT.Reg, volatile.LoadUint32(&o.CLK_APB2_SSP1_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB2_SSP1_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB2_SSP1_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB0_SSP0_CFG: CLK_APB0_SSP0 clock configuration register
func (o *CCU2_Type) SetCLK_APB0_SSP0_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_SSP0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_SSP0_CFG.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB0_SSP0_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB0_SSP0_CFG.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB0_SSP0_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_SSP0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_SSP0_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB0_SSP0_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_SSP0_CFG.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB0_SSP0_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_SSP0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_SSP0_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB0_SSP0_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_SSP0_CFG.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB0_SSP0_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_SSP0_CFG.Reg, volatile.LoadUint32(&o.CLK_APB0_SSP0_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB0_SSP0_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_SSP0_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_APB0_SSP0_STAT: CLK_APB0_SSP0 clock status register
func (o *CCU2_Type) SetCLK_APB0_SSP0_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_SSP0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_SSP0_STAT.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_APB0_SSP0_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_APB0_SSP0_STAT.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_APB0_SSP0_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_SSP0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_SSP0_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_APB0_SSP0_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_SSP0_STAT.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_APB0_SSP0_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_SSP0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_SSP0_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_APB0_SSP0_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_SSP0_STAT.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_APB0_SSP0_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_APB0_SSP0_STAT.Reg, volatile.LoadUint32(&o.CLK_APB0_SSP0_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_APB0_SSP0_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_APB0_SSP0_STAT.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_SDIO_CFG: CLK_SDIO clock configuration register
func (o *CCU2_Type) SetCLK_SDIO_CFG_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_SDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_SDIO_CFG.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_SDIO_CFG_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_SDIO_CFG.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_SDIO_CFG_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_SDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_SDIO_CFG.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_SDIO_CFG_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_SDIO_CFG.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_SDIO_CFG_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_SDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_SDIO_CFG.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_SDIO_CFG_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_SDIO_CFG.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_SDIO_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_SDIO_CFG.Reg, volatile.LoadUint32(&o.CLK_SDIO_CFG.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_SDIO_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_SDIO_CFG.Reg) & 0xfffffff8) >> 3
}

// CCU2.CLK_SDIO_STAT: CLK_SDIO clock status register
func (o *CCU2_Type) SetCLK_SDIO_STAT_RUN(value uint32) {
	volatile.StoreUint32(&o.CLK_SDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_SDIO_STAT.Reg)&^(0x1)|value)
}
func (o *CCU2_Type) GetCLK_SDIO_STAT_RUN() uint32 {
	return volatile.LoadUint32(&o.CLK_SDIO_STAT.Reg) & 0x1
}
func (o *CCU2_Type) SetCLK_SDIO_STAT_AUTO(value uint32) {
	volatile.StoreUint32(&o.CLK_SDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_SDIO_STAT.Reg)&^(0x2)|value<<1)
}
func (o *CCU2_Type) GetCLK_SDIO_STAT_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CLK_SDIO_STAT.Reg) & 0x2) >> 1
}
func (o *CCU2_Type) SetCLK_SDIO_STAT_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.CLK_SDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_SDIO_STAT.Reg)&^(0x4)|value<<2)
}
func (o *CCU2_Type) GetCLK_SDIO_STAT_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CLK_SDIO_STAT.Reg) & 0x4) >> 2
}
func (o *CCU2_Type) SetCLK_SDIO_STAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLK_SDIO_STAT.Reg, volatile.LoadUint32(&o.CLK_SDIO_STAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CCU2_Type) GetCLK_SDIO_STAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLK_SDIO_STAT.Reg) & 0xfffffff8) >> 3
}

// Reset Generation Unit (RGU)
type RGU_Type struct {
	_                    [256]byte
	RESET_CTRL0          volatile.Register32 // 0x100
	RESET_CTRL1          volatile.Register32 // 0x104
	_                    [8]byte
	RESET_STATUS0        volatile.Register32 // 0x110
	RESET_STATUS1        volatile.Register32 // 0x114
	RESET_STATUS2        volatile.Register32 // 0x118
	RESET_STATUS3        volatile.Register32 // 0x11C
	_                    [48]byte
	RESET_ACTIVE_STATUS0 volatile.Register32 // 0x150
	RESET_ACTIVE_STATUS1 volatile.Register32 // 0x154
	_                    [684]byte
	RESET_EXT_STAT1      volatile.Register32 // 0x404
	RESET_EXT_STAT2      volatile.Register32 // 0x408
	_                    [8]byte
	RESET_EXT_STAT5      volatile.Register32 // 0x414
	_                    [8]byte
	RESET_EXT_STAT8      volatile.Register32 // 0x420
	RESET_EXT_STAT9      volatile.Register32 // 0x424
	_                    [12]byte
	RESET_EXT_STAT13     volatile.Register32 // 0x434
	_                    [8]byte
	RESET_EXT_STAT16     volatile.Register32 // 0x440
	RESET_EXT_STAT17     volatile.Register32 // 0x444
	RESET_EXT_STAT18     volatile.Register32 // 0x448
	RESET_EXT_STAT19     volatile.Register32 // 0x44C
	RESET_EXT_STAT20     volatile.Register32 // 0x450
	RESET_EXT_STAT21     volatile.Register32 // 0x454
	RESET_EXT_STAT22     volatile.Register32 // 0x458
	_                    [8]byte
	RESET_EXT_STAT25     volatile.Register32 // 0x464
	_                    [4]byte
	RESET_EXT_STAT27     volatile.Register32 // 0x46C
	RESET_EXT_STAT28     volatile.Register32 // 0x470
	RESET_EXT_STAT29     volatile.Register32 // 0x474
	_                    [8]byte
	RESET_EXT_STAT32     volatile.Register32 // 0x480
	RESET_EXT_STAT33     volatile.Register32 // 0x484
	RESET_EXT_STAT34     volatile.Register32 // 0x488
	RESET_EXT_STAT35     volatile.Register32 // 0x48C
	RESET_EXT_STAT36     volatile.Register32 // 0x490
	RESET_EXT_STAT37     volatile.Register32 // 0x494
	RESET_EXT_STAT38     volatile.Register32 // 0x498
	RESET_EXT_STAT39     volatile.Register32 // 0x49C
	RESET_EXT_STAT40     volatile.Register32 // 0x4A0
	RESET_EXT_STAT41     volatile.Register32 // 0x4A4
	RESET_EXT_STAT42     volatile.Register32 // 0x4A8
	_                    [4]byte
	RESET_EXT_STAT44     volatile.Register32 // 0x4B0
	RESET_EXT_STAT45     volatile.Register32 // 0x4B4
	RESET_EXT_STAT46     volatile.Register32 // 0x4B8
	RESET_EXT_STAT47     volatile.Register32 // 0x4BC
	RESET_EXT_STAT48     volatile.Register32 // 0x4C0
	RESET_EXT_STAT49     volatile.Register32 // 0x4C4
	RESET_EXT_STAT50     volatile.Register32 // 0x4C8
	RESET_EXT_STAT51     volatile.Register32 // 0x4CC
	RESET_EXT_STAT52     volatile.Register32 // 0x4D0
	RESET_EXT_STAT53     volatile.Register32 // 0x4D4
	RESET_EXT_STAT54     volatile.Register32 // 0x4D8
	RESET_EXT_STAT55     volatile.Register32 // 0x4DC
}

// RGU.RESET_CTRL0: Reset control register 0
func (o *RGU_Type) SetRESET_CTRL0_CORE_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x1)|value)
}
func (o *RGU_Type) GetRESET_CTRL0_CORE_RST() uint32 {
	return volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x1
}
func (o *RGU_Type) SetRESET_CTRL0_PERIPH_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x2)|value<<1)
}
func (o *RGU_Type) GetRESET_CTRL0_PERIPH_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x2) >> 1
}
func (o *RGU_Type) SetRESET_CTRL0_MASTER_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_CTRL0_MASTER_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_CTRL0_WWDT_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x10)|value<<4)
}
func (o *RGU_Type) GetRESET_CTRL0_WWDT_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x10) >> 4
}
func (o *RGU_Type) SetRESET_CTRL0_CREG_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x20)|value<<5)
}
func (o *RGU_Type) GetRESET_CTRL0_CREG_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x20) >> 5
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x40)|value<<6)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x40) >> 6
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x80)|value<<7)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x80) >> 7
}
func (o *RGU_Type) SetRESET_CTRL0_BUS_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x100)|value<<8)
}
func (o *RGU_Type) GetRESET_CTRL0_BUS_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x100) >> 8
}
func (o *RGU_Type) SetRESET_CTRL0_SCU_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x200)|value<<9)
}
func (o *RGU_Type) GetRESET_CTRL0_SCU_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x200) >> 9
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x400)|value<<10)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x400) >> 10
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x800)|value<<11)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x800) >> 11
}
func (o *RGU_Type) SetRESET_CTRL0_M0_SUB_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x1000)|value<<12)
}
func (o *RGU_Type) GetRESET_CTRL0_M0_SUB_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x1000) >> 12
}
func (o *RGU_Type) SetRESET_CTRL0_M3_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x2000)|value<<13)
}
func (o *RGU_Type) GetRESET_CTRL0_M3_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x2000) >> 13
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x4000)|value<<14)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x4000) >> 14
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x8000)|value<<15)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x8000) >> 15
}
func (o *RGU_Type) SetRESET_CTRL0_LCD_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x10000)|value<<16)
}
func (o *RGU_Type) GetRESET_CTRL0_LCD_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x10000) >> 16
}
func (o *RGU_Type) SetRESET_CTRL0_USB0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x20000)|value<<17)
}
func (o *RGU_Type) GetRESET_CTRL0_USB0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x20000) >> 17
}
func (o *RGU_Type) SetRESET_CTRL0_USB1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x40000)|value<<18)
}
func (o *RGU_Type) GetRESET_CTRL0_USB1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x40000) >> 18
}
func (o *RGU_Type) SetRESET_CTRL0_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x80000)|value<<19)
}
func (o *RGU_Type) GetRESET_CTRL0_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x80000) >> 19
}
func (o *RGU_Type) SetRESET_CTRL0_SDIO_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x100000)|value<<20)
}
func (o *RGU_Type) GetRESET_CTRL0_SDIO_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x100000) >> 20
}
func (o *RGU_Type) SetRESET_CTRL0_EMC_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x200000)|value<<21)
}
func (o *RGU_Type) GetRESET_CTRL0_EMC_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x200000) >> 21
}
func (o *RGU_Type) SetRESET_CTRL0_ETHERNET_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x400000)|value<<22)
}
func (o *RGU_Type) GetRESET_CTRL0_ETHERNET_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x400000) >> 22
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x800000)|value<<23)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x800000) >> 23
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x1000000)|value<<24)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x1000000) >> 24
}
func (o *RGU_Type) SetRESET_CTRL0_FLASHA_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x2000000)|value<<25)
}
func (o *RGU_Type) GetRESET_CTRL0_FLASHA_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x2000000) >> 25
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x4000000)|value<<26)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x4000000) >> 26
}
func (o *RGU_Type) SetRESET_CTRL0_EEPROM_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x8000000)|value<<27)
}
func (o *RGU_Type) GetRESET_CTRL0_EEPROM_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x8000000) >> 27
}
func (o *RGU_Type) SetRESET_CTRL0_GPIO_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x10000000)|value<<28)
}
func (o *RGU_Type) GetRESET_CTRL0_GPIO_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x10000000) >> 28
}
func (o *RGU_Type) SetRESET_CTRL0_FLASHB_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x20000000)|value<<29)
}
func (o *RGU_Type) GetRESET_CTRL0_FLASHB_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x20000000) >> 29
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x40000000)|value<<30)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x40000000) >> 30
}
func (o *RGU_Type) SetRESET_CTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL0.Reg, volatile.LoadUint32(&o.RESET_CTRL0.Reg)&^(0x80000000)|value<<31)
}
func (o *RGU_Type) GetRESET_CTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL0.Reg) & 0x80000000) >> 31
}

// RGU.RESET_CTRL1: Reset control register 1
func (o *RGU_Type) SetRESET_CTRL1_TIMER0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x1)|value)
}
func (o *RGU_Type) GetRESET_CTRL1_TIMER0_RST() uint32 {
	return volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x1
}
func (o *RGU_Type) SetRESET_CTRL1_TIMER1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x2)|value<<1)
}
func (o *RGU_Type) GetRESET_CTRL1_TIMER1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x2) >> 1
}
func (o *RGU_Type) SetRESET_CTRL1_TIMER2_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_CTRL1_TIMER2_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_CTRL1_TIMER3_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_CTRL1_TIMER3_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_CTRL1_RITIMER_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x10)|value<<4)
}
func (o *RGU_Type) GetRESET_CTRL1_RITIMER_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x10) >> 4
}
func (o *RGU_Type) SetRESET_CTRL1_SCT_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x20)|value<<5)
}
func (o *RGU_Type) GetRESET_CTRL1_SCT_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x20) >> 5
}
func (o *RGU_Type) SetRESET_CTRL1_MOTOCONPWM_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x40)|value<<6)
}
func (o *RGU_Type) GetRESET_CTRL1_MOTOCONPWM_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x40) >> 6
}
func (o *RGU_Type) SetRESET_CTRL1_QEI_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x80)|value<<7)
}
func (o *RGU_Type) GetRESET_CTRL1_QEI_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x80) >> 7
}
func (o *RGU_Type) SetRESET_CTRL1_ADC0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x100)|value<<8)
}
func (o *RGU_Type) GetRESET_CTRL1_ADC0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x100) >> 8
}
func (o *RGU_Type) SetRESET_CTRL1_ADC1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x200)|value<<9)
}
func (o *RGU_Type) GetRESET_CTRL1_ADC1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x200) >> 9
}
func (o *RGU_Type) SetRESET_CTRL1_DAC_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x400)|value<<10)
}
func (o *RGU_Type) GetRESET_CTRL1_DAC_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x400) >> 10
}
func (o *RGU_Type) SetRESET_CTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x800)|value<<11)
}
func (o *RGU_Type) GetRESET_CTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x800) >> 11
}
func (o *RGU_Type) SetRESET_CTRL1_UART0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x1000)|value<<12)
}
func (o *RGU_Type) GetRESET_CTRL1_UART0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x1000) >> 12
}
func (o *RGU_Type) SetRESET_CTRL1_UART1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x2000)|value<<13)
}
func (o *RGU_Type) GetRESET_CTRL1_UART1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x2000) >> 13
}
func (o *RGU_Type) SetRESET_CTRL1_UART2_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x4000)|value<<14)
}
func (o *RGU_Type) GetRESET_CTRL1_UART2_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x4000) >> 14
}
func (o *RGU_Type) SetRESET_CTRL1_UART3_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x8000)|value<<15)
}
func (o *RGU_Type) GetRESET_CTRL1_UART3_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x8000) >> 15
}
func (o *RGU_Type) SetRESET_CTRL1_I2C0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x10000)|value<<16)
}
func (o *RGU_Type) GetRESET_CTRL1_I2C0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x10000) >> 16
}
func (o *RGU_Type) SetRESET_CTRL1_I2C1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x20000)|value<<17)
}
func (o *RGU_Type) GetRESET_CTRL1_I2C1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x20000) >> 17
}
func (o *RGU_Type) SetRESET_CTRL1_SSP0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x40000)|value<<18)
}
func (o *RGU_Type) GetRESET_CTRL1_SSP0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x40000) >> 18
}
func (o *RGU_Type) SetRESET_CTRL1_SSP1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x80000)|value<<19)
}
func (o *RGU_Type) GetRESET_CTRL1_SSP1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x80000) >> 19
}
func (o *RGU_Type) SetRESET_CTRL1_I2S_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x100000)|value<<20)
}
func (o *RGU_Type) GetRESET_CTRL1_I2S_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x100000) >> 20
}
func (o *RGU_Type) SetRESET_CTRL1_SPIFI_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x200000)|value<<21)
}
func (o *RGU_Type) GetRESET_CTRL1_SPIFI_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x200000) >> 21
}
func (o *RGU_Type) SetRESET_CTRL1_CAN1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *RGU_Type) GetRESET_CTRL1_CAN1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x400000) >> 22
}
func (o *RGU_Type) SetRESET_CTRL1_CAN0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *RGU_Type) GetRESET_CTRL1_CAN0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x800000) >> 23
}
func (o *RGU_Type) SetRESET_CTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x1000000)|value<<24)
}
func (o *RGU_Type) GetRESET_CTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x1000000) >> 24
}
func (o *RGU_Type) SetRESET_CTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0xe000000)|value<<25)
}
func (o *RGU_Type) GetRESET_CTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0xe000000) >> 25
}
func (o *RGU_Type) SetRESET_CTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x10000000)|value<<28)
}
func (o *RGU_Type) GetRESET_CTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x10000000) >> 28
}
func (o *RGU_Type) SetRESET_CTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x20000000)|value<<29)
}
func (o *RGU_Type) GetRESET_CTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x20000000) >> 29
}
func (o *RGU_Type) SetRESET_CTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x40000000)|value<<30)
}
func (o *RGU_Type) GetRESET_CTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x40000000) >> 30
}
func (o *RGU_Type) SetRESET_CTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_CTRL1.Reg, volatile.LoadUint32(&o.RESET_CTRL1.Reg)&^(0x80000000)|value<<31)
}
func (o *RGU_Type) GetRESET_CTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_CTRL1.Reg) & 0x80000000) >> 31
}

// RGU.RESET_STATUS0: Reset status register 0
func (o *RGU_Type) SetRESET_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_STATUS0_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_STATUS0_PERIPH_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0xc)|value<<2)
}
func (o *RGU_Type) GetRESET_STATUS0_PERIPH_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0xc) >> 2
}
func (o *RGU_Type) SetRESET_STATUS0_MASTER_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0x30)|value<<4)
}
func (o *RGU_Type) GetRESET_STATUS0_MASTER_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0x30) >> 4
}
func (o *RGU_Type) SetRESET_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0xc0)|value<<6)
}
func (o *RGU_Type) GetRESET_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0xc0) >> 6
}
func (o *RGU_Type) SetRESET_STATUS0_WWDT_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0x300)|value<<8)
}
func (o *RGU_Type) GetRESET_STATUS0_WWDT_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0x300) >> 8
}
func (o *RGU_Type) SetRESET_STATUS0_CREG_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0xc00)|value<<10)
}
func (o *RGU_Type) GetRESET_STATUS0_CREG_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0xc00) >> 10
}
func (o *RGU_Type) SetRESET_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0x3000)|value<<12)
}
func (o *RGU_Type) GetRESET_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0x3000) >> 12
}
func (o *RGU_Type) SetRESET_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0xc000)|value<<14)
}
func (o *RGU_Type) GetRESET_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0xc000) >> 14
}
func (o *RGU_Type) SetRESET_STATUS0_BUS_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0x30000)|value<<16)
}
func (o *RGU_Type) GetRESET_STATUS0_BUS_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0x30000) >> 16
}
func (o *RGU_Type) SetRESET_STATUS0_SCU_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0xc0000)|value<<18)
}
func (o *RGU_Type) GetRESET_STATUS0_SCU_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0xc0000) >> 18
}
func (o *RGU_Type) SetRESET_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0x300000)|value<<20)
}
func (o *RGU_Type) GetRESET_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0x300000) >> 20
}
func (o *RGU_Type) SetRESET_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0xc00000)|value<<22)
}
func (o *RGU_Type) GetRESET_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0xc00000) >> 22
}
func (o *RGU_Type) SetRESET_STATUS0_M0SUB_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0x3000000)|value<<24)
}
func (o *RGU_Type) GetRESET_STATUS0_M0SUB_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0x3000000) >> 24
}
func (o *RGU_Type) SetRESET_STATUS0_M3_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0xc000000)|value<<26)
}
func (o *RGU_Type) GetRESET_STATUS0_M3_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0xc000000) >> 26
}
func (o *RGU_Type) SetRESET_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0x30000000)|value<<28)
}
func (o *RGU_Type) GetRESET_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0x30000000) >> 28
}
func (o *RGU_Type) SetRESET_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS0.Reg, volatile.LoadUint32(&o.RESET_STATUS0.Reg)&^(0xc0000000)|value<<30)
}
func (o *RGU_Type) GetRESET_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS0.Reg) & 0xc0000000) >> 30
}

// RGU.RESET_STATUS1: Reset status register 1
func (o *RGU_Type) SetRESET_STATUS1_LCD_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_STATUS1_LCD_RST() uint32 {
	return volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_STATUS1_USB0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0xc)|value<<2)
}
func (o *RGU_Type) GetRESET_STATUS1_USB0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0xc) >> 2
}
func (o *RGU_Type) SetRESET_STATUS1_USB1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0x30)|value<<4)
}
func (o *RGU_Type) GetRESET_STATUS1_USB1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0x30) >> 4
}
func (o *RGU_Type) SetRESET_STATUS1_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0xc0)|value<<6)
}
func (o *RGU_Type) GetRESET_STATUS1_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0xc0) >> 6
}
func (o *RGU_Type) SetRESET_STATUS1_SDIO_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0x300)|value<<8)
}
func (o *RGU_Type) GetRESET_STATUS1_SDIO_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0x300) >> 8
}
func (o *RGU_Type) SetRESET_STATUS1_EMC_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0xc00)|value<<10)
}
func (o *RGU_Type) GetRESET_STATUS1_EMC_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0xc00) >> 10
}
func (o *RGU_Type) SetRESET_STATUS1_ETHERNET_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0x3000)|value<<12)
}
func (o *RGU_Type) GetRESET_STATUS1_ETHERNET_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0x3000) >> 12
}
func (o *RGU_Type) SetRESET_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0xc000)|value<<14)
}
func (o *RGU_Type) GetRESET_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0xc000) >> 14
}
func (o *RGU_Type) SetRESET_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0x30000)|value<<16)
}
func (o *RGU_Type) GetRESET_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0x30000) >> 16
}
func (o *RGU_Type) SetRESET_STATUS1_FLASHA_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0xc0000)|value<<18)
}
func (o *RGU_Type) GetRESET_STATUS1_FLASHA_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0xc0000) >> 18
}
func (o *RGU_Type) SetRESET_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0x300000)|value<<20)
}
func (o *RGU_Type) GetRESET_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0x300000) >> 20
}
func (o *RGU_Type) SetRESET_STATUS1_EEPROM_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0xc00000)|value<<22)
}
func (o *RGU_Type) GetRESET_STATUS1_EEPROM_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0xc00000) >> 22
}
func (o *RGU_Type) SetRESET_STATUS1_GPIO_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0x3000000)|value<<24)
}
func (o *RGU_Type) GetRESET_STATUS1_GPIO_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0x3000000) >> 24
}
func (o *RGU_Type) SetRESET_STATUS1_FLASHB_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0xc000000)|value<<26)
}
func (o *RGU_Type) GetRESET_STATUS1_FLASHB_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0xc000000) >> 26
}
func (o *RGU_Type) SetRESET_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0x30000000)|value<<28)
}
func (o *RGU_Type) GetRESET_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0x30000000) >> 28
}
func (o *RGU_Type) SetRESET_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS1.Reg, volatile.LoadUint32(&o.RESET_STATUS1.Reg)&^(0xc0000000)|value<<30)
}
func (o *RGU_Type) GetRESET_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS1.Reg) & 0xc0000000) >> 30
}

// RGU.RESET_STATUS2: Reset status register 2
func (o *RGU_Type) SetRESET_STATUS2_TIMER0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_STATUS2_TIMER0_RST() uint32 {
	return volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_STATUS2_TIMER1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0xc)|value<<2)
}
func (o *RGU_Type) GetRESET_STATUS2_TIMER1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0xc) >> 2
}
func (o *RGU_Type) SetRESET_STATUS2_TIMER2_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0x30)|value<<4)
}
func (o *RGU_Type) GetRESET_STATUS2_TIMER2_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0x30) >> 4
}
func (o *RGU_Type) SetRESET_STATUS2_TIMER3_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0xc0)|value<<6)
}
func (o *RGU_Type) GetRESET_STATUS2_TIMER3_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0xc0) >> 6
}
func (o *RGU_Type) SetRESET_STATUS2_RITIMER_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0x300)|value<<8)
}
func (o *RGU_Type) GetRESET_STATUS2_RITIMER_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0x300) >> 8
}
func (o *RGU_Type) SetRESET_STATUS2_SCT_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0xc00)|value<<10)
}
func (o *RGU_Type) GetRESET_STATUS2_SCT_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0xc00) >> 10
}
func (o *RGU_Type) SetRESET_STATUS2_MOTOCONPWM_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0x3000)|value<<12)
}
func (o *RGU_Type) GetRESET_STATUS2_MOTOCONPWM_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0x3000) >> 12
}
func (o *RGU_Type) SetRESET_STATUS2_QEI_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0xc000)|value<<14)
}
func (o *RGU_Type) GetRESET_STATUS2_QEI_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0xc000) >> 14
}
func (o *RGU_Type) SetRESET_STATUS2_ADC0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0x30000)|value<<16)
}
func (o *RGU_Type) GetRESET_STATUS2_ADC0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0x30000) >> 16
}
func (o *RGU_Type) SetRESET_STATUS2_ADC1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0xc0000)|value<<18)
}
func (o *RGU_Type) GetRESET_STATUS2_ADC1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0xc0000) >> 18
}
func (o *RGU_Type) SetRESET_STATUS2_DAC_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0x300000)|value<<20)
}
func (o *RGU_Type) GetRESET_STATUS2_DAC_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0x300000) >> 20
}
func (o *RGU_Type) SetRESET_STATUS2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0xc00000)|value<<22)
}
func (o *RGU_Type) GetRESET_STATUS2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0xc00000) >> 22
}
func (o *RGU_Type) SetRESET_STATUS2_UART0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0x3000000)|value<<24)
}
func (o *RGU_Type) GetRESET_STATUS2_UART0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0x3000000) >> 24
}
func (o *RGU_Type) SetRESET_STATUS2_UART1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0xc000000)|value<<26)
}
func (o *RGU_Type) GetRESET_STATUS2_UART1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0xc000000) >> 26
}
func (o *RGU_Type) SetRESET_STATUS2_UART2_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0x30000000)|value<<28)
}
func (o *RGU_Type) GetRESET_STATUS2_UART2_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0x30000000) >> 28
}
func (o *RGU_Type) SetRESET_STATUS2_UART3_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS2.Reg, volatile.LoadUint32(&o.RESET_STATUS2.Reg)&^(0xc0000000)|value<<30)
}
func (o *RGU_Type) GetRESET_STATUS2_UART3_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS2.Reg) & 0xc0000000) >> 30
}

// RGU.RESET_STATUS3: Reset status register 3
func (o *RGU_Type) SetRESET_STATUS3_I2C0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_STATUS3_I2C0_RST() uint32 {
	return volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_STATUS3_I2C1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0xc)|value<<2)
}
func (o *RGU_Type) GetRESET_STATUS3_I2C1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0xc) >> 2
}
func (o *RGU_Type) SetRESET_STATUS3_SSP0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0x30)|value<<4)
}
func (o *RGU_Type) GetRESET_STATUS3_SSP0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0x30) >> 4
}
func (o *RGU_Type) SetRESET_STATUS3_SSP1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0xc0)|value<<6)
}
func (o *RGU_Type) GetRESET_STATUS3_SSP1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0xc0) >> 6
}
func (o *RGU_Type) SetRESET_STATUS3_I2S_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0x300)|value<<8)
}
func (o *RGU_Type) GetRESET_STATUS3_I2S_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0x300) >> 8
}
func (o *RGU_Type) SetRESET_STATUS3_SPIFI_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0xc00)|value<<10)
}
func (o *RGU_Type) GetRESET_STATUS3_SPIFI_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0xc00) >> 10
}
func (o *RGU_Type) SetRESET_STATUS3_CAN1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0x3000)|value<<12)
}
func (o *RGU_Type) GetRESET_STATUS3_CAN1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0x3000) >> 12
}
func (o *RGU_Type) SetRESET_STATUS3_CAN0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0xc000)|value<<14)
}
func (o *RGU_Type) GetRESET_STATUS3_CAN0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0xc000) >> 14
}
func (o *RGU_Type) SetRESET_STATUS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0x30000)|value<<16)
}
func (o *RGU_Type) GetRESET_STATUS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0x30000) >> 16
}
func (o *RGU_Type) SetRESET_STATUS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0xfc0000)|value<<18)
}
func (o *RGU_Type) GetRESET_STATUS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0xfc0000) >> 18
}
func (o *RGU_Type) SetRESET_STATUS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0x3000000)|value<<24)
}
func (o *RGU_Type) GetRESET_STATUS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0x3000000) >> 24
}
func (o *RGU_Type) SetRESET_STATUS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0xc000000)|value<<26)
}
func (o *RGU_Type) GetRESET_STATUS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0xc000000) >> 26
}
func (o *RGU_Type) SetRESET_STATUS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0x30000000)|value<<28)
}
func (o *RGU_Type) GetRESET_STATUS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0x30000000) >> 28
}
func (o *RGU_Type) SetRESET_STATUS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_STATUS3.Reg, volatile.LoadUint32(&o.RESET_STATUS3.Reg)&^(0xc0000000)|value<<30)
}
func (o *RGU_Type) GetRESET_STATUS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATUS3.Reg) & 0xc0000000) >> 30
}

// RGU.RESET_ACTIVE_STATUS0: Reset active status register 0
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_CORE_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x1)|value)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_CORE_RST() uint32 {
	return volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x1
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_PERIPH_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x2)|value<<1)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_PERIPH_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x2) >> 1
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_MASTER_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_MASTER_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_WWDT_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x10)|value<<4)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_WWDT_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x10) >> 4
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_CREG_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x20)|value<<5)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_CREG_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x20) >> 5
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x40)|value<<6)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x40) >> 6
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x80)|value<<7)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x80) >> 7
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_BUS_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x100)|value<<8)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_BUS_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x100) >> 8
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_SCU_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x200)|value<<9)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_SCU_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x200) >> 9
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x400)|value<<10)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x400) >> 10
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x800)|value<<11)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x800) >> 11
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_M0SUB_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x1000)|value<<12)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_M0SUB_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x1000) >> 12
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_M3_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x2000)|value<<13)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_M3_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x2000) >> 13
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x4000)|value<<14)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x4000) >> 14
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x8000)|value<<15)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x8000) >> 15
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_LCD_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x10000)|value<<16)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_LCD_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x10000) >> 16
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_USB0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x20000)|value<<17)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_USB0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x20000) >> 17
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_USB1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x40000)|value<<18)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_USB1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x40000) >> 18
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x80000)|value<<19)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x80000) >> 19
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_SDIO_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x100000)|value<<20)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_SDIO_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x100000) >> 20
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_EMC_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x200000)|value<<21)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_EMC_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x200000) >> 21
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_ETHERNET_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x400000)|value<<22)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_ETHERNET_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x400000) >> 22
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x800000)|value<<23)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x800000) >> 23
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x1000000)|value<<24)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x1000000) >> 24
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_FLASHA_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x2000000)|value<<25)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_FLASHA_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x2000000) >> 25
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x4000000)|value<<26)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x4000000) >> 26
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_EEPROM_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x8000000)|value<<27)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_EEPROM_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x8000000) >> 27
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_GPIO_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x10000000)|value<<28)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_GPIO_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x10000000) >> 28
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_FLASHB_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x20000000)|value<<29)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_FLASHB_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x20000000) >> 29
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x40000000)|value<<30)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x40000000) >> 30
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS0.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg)&^(0x80000000)|value<<31)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS0.Reg) & 0x80000000) >> 31
}

// RGU.RESET_ACTIVE_STATUS1: Reset active status register 1
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_TIMER0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x1)|value)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_TIMER0_RST() uint32 {
	return volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x1
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_TIMER1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x2)|value<<1)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_TIMER1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x2) >> 1
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_TIMER2_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_TIMER2_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_TIMER3_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_TIMER3_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_RITIMER_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x10)|value<<4)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_RITIMER_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x10) >> 4
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_SCT_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x20)|value<<5)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_SCT_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x20) >> 5
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_MOTOCONPWM_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x40)|value<<6)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_MOTOCONPWM_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x40) >> 6
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_QEI_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x80)|value<<7)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_QEI_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x80) >> 7
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_ADC0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x100)|value<<8)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_ADC0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x100) >> 8
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_ADC1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x200)|value<<9)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_ADC1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x200) >> 9
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_DAC_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x400)|value<<10)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_DAC_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x400) >> 10
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x800)|value<<11)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x800) >> 11
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_UART0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x1000)|value<<12)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_UART0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x1000) >> 12
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_UART1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x2000)|value<<13)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_UART1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x2000) >> 13
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_UART2_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x4000)|value<<14)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_UART2_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x4000) >> 14
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_UART3_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x8000)|value<<15)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_UART3_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x8000) >> 15
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_I2C0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x10000)|value<<16)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_I2C0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x10000) >> 16
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_I2C1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x20000)|value<<17)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_I2C1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x20000) >> 17
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_SSP0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x40000)|value<<18)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_SSP0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x40000) >> 18
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_SSP1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x80000)|value<<19)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_SSP1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x80000) >> 19
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_I2S_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x100000)|value<<20)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_I2S_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x100000) >> 20
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_SPIFI_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x200000)|value<<21)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_SPIFI_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x200000) >> 21
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_CAN1_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x400000)|value<<22)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_CAN1_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x400000) >> 22
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_CAN0_RST(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x800000)|value<<23)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_CAN0_RST() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x800000) >> 23
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x1000000)|value<<24)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x1000000) >> 24
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0xe000000)|value<<25)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0xe000000) >> 25
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x10000000)|value<<28)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x10000000) >> 28
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x20000000)|value<<29)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x20000000) >> 29
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x40000000)|value<<30)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x40000000) >> 30
}
func (o *RGU_Type) SetRESET_ACTIVE_STATUS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_ACTIVE_STATUS1.Reg, volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg)&^(0x80000000)|value<<31)
}
func (o *RGU_Type) GetRESET_ACTIVE_STATUS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_ACTIVE_STATUS1.Reg) & 0x80000000) >> 31
}

// RGU.RESET_EXT_STAT1: Reset external status register 1 for PERIPH_RST
func (o *RGU_Type) SetRESET_EXT_STAT1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT1.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT1.Reg)&^(0x1)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT1_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT1.Reg) & 0x1
}
func (o *RGU_Type) SetRESET_EXT_STAT1_CORE_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT1.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT1.Reg)&^(0x2)|value<<1)
}
func (o *RGU_Type) GetRESET_EXT_STAT1_CORE_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT1.Reg) & 0x2) >> 1
}
func (o *RGU_Type) SetRESET_EXT_STAT1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT1.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT1.Reg)&^(0xfffffffc)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT1.Reg) & 0xfffffffc) >> 2
}

// RGU.RESET_EXT_STAT2: Reset external status register 2 for MASTER_RST
func (o *RGU_Type) SetRESET_EXT_STAT2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT2.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT2.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT2_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT2.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT2_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT2.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT2.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT2_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT2.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT2.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT2.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT2.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT5: Reset external status register 5 for CREG_RST
func (o *RGU_Type) SetRESET_EXT_STAT5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT5.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT5.Reg)&^(0x1)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT5_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT5.Reg) & 0x1
}
func (o *RGU_Type) SetRESET_EXT_STAT5_CORE_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT5.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT5.Reg)&^(0x2)|value<<1)
}
func (o *RGU_Type) GetRESET_EXT_STAT5_CORE_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT5.Reg) & 0x2) >> 1
}
func (o *RGU_Type) SetRESET_EXT_STAT5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT5.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT5.Reg)&^(0xfffffffc)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT5.Reg) & 0xfffffffc) >> 2
}

// RGU.RESET_EXT_STAT8: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT8.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT8.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT8_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT8.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT8_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT8.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT8.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT8_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT8.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT8.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT8.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT8.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT9: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT9.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT9.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT9_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT9.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT9_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT9.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT9.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT9_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT9.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT9.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT9.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT9.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT13: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT13.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT13.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT13_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT13.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT13_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT13.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT13.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT13_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT13.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT13.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT13.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT13.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT16: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT16.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT16.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT16_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT16.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT16_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT16.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT16.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT16_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT16.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT16.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT16.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT16.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT17: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT17.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT17.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT17_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT17.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT17_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT17.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT17.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT17_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT17.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT17.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT17.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT17.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT18: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT18.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT18.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT18_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT18.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT18_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT18.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT18.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT18_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT18.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT18.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT18.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT18.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT19: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT19.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT19.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT19_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT19.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT19_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT19.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT19.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT19_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT19.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT19.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT19.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT19.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT20: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT20.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT20.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT20_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT20.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT20_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT20.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT20.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT20_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT20.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT20.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT20.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT20.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT21: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT21.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT21.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT21_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT21.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT21_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT21.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT21.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT21_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT21.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT21.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT21.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT21.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT22: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT22.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT22.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT22_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT22.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT22_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT22.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT22.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT22_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT22.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT22.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT22.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT22.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT25: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT25.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT25.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT25_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT25.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT25_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT25.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT25.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT25_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT25.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT25.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT25.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT25_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT25.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT27: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT27.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT27.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT27_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT27.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT27_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT27.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT27.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT27_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT27.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT27.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT27.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT27.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT28: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT28.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT28.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT28_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT28.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT28_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT28.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT28.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT28_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT28.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT28.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT28.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT28.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT29: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT29.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT29.Reg)&^(0x7)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT29_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT29.Reg) & 0x7
}
func (o *RGU_Type) SetRESET_EXT_STAT29_MASTER_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT29.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT29.Reg)&^(0x8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT29_MASTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT29.Reg) & 0x8) >> 3
}
func (o *RGU_Type) SetRESET_EXT_STAT29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT29.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT29.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RGU_Type) GetRESET_EXT_STAT29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT29.Reg) & 0xfffffff0) >> 4
}

// RGU.RESET_EXT_STAT32: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT32_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT32.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT32.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT32_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT32.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT32_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT32.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT32.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT32_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT32.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT32_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT32.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT32.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT32_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT32.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT33: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT33_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT33.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT33.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT33_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT33.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT33_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT33.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT33.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT33_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT33.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT33_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT33.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT33.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT33_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT33.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT34: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT34_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT34.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT34.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT34_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT34.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT34_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT34.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT34.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT34_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT34.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT34_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT34.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT34.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT34_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT34.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT35: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT35_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT35.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT35.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT35_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT35.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT35_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT35.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT35.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT35_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT35.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT35_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT35.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT35.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT35_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT35.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT36: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT36_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT36.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT36.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT36_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT36.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT36_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT36.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT36.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT36_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT36.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT36_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT36.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT36.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT36_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT36.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT37: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT37_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT37.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT37.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT37_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT37.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT37_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT37.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT37.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT37_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT37.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT37_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT37.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT37.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT37_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT37.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT38: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT38_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT38.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT38.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT38_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT38.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT38_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT38.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT38.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT38_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT38.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT38_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT38.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT38.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT38_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT38.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT39: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT39_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT39.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT39.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT39_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT39.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT39_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT39.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT39.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT39_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT39.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT39_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT39.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT39.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT39_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT39.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT40: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT40_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT40.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT40.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT40_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT40.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT40_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT40.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT40.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT40_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT40.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT40_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT40.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT40.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT40_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT40.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT41: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT41_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT41.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT41.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT41_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT41.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT41_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT41.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT41.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT41_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT41.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT41_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT41.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT41.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT41_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT41.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT42: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT42_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT42.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT42.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT42_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT42.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT42_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT42.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT42.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT42_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT42.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT42_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT42.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT42.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT42_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT42.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT44: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT44_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT44.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT44.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT44_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT44.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT44_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT44.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT44.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT44_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT44.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT44_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT44.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT44.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT44_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT44.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT45: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT45_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT45.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT45.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT45_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT45.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT45_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT45.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT45.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT45_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT45.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT45_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT45.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT45.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT45_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT45.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT46: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT46_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT46.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT46.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT46_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT46.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT46_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT46.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT46.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT46_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT46.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT46_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT46.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT46.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT46_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT46.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT47: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT47_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT47.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT47.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT47_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT47.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT47_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT47.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT47.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT47_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT47.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT47_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT47.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT47.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT47_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT47.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT48: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT48_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT48.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT48.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT48_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT48.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT48_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT48.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT48.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT48_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT48.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT48_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT48.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT48.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT48_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT48.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT49: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT49_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT49.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT49.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT49_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT49.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT49_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT49.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT49.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT49_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT49.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT49_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT49.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT49.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT49_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT49.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT50: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT50_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT50.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT50.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT50_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT50.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT50_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT50.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT50.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT50_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT50.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT50_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT50.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT50.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT50_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT50.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT51: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT51_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT51.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT51.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT51_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT51.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT51_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT51.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT51.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT51_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT51.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT51_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT51.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT51.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT51_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT51.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT52: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT52_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT52.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT52.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT52_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT52.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT52_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT52.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT52.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT52_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT52.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT52_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT52.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT52.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT52_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT52.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT53: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT53_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT53.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT53.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT53_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT53.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT53_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT53.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT53.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT53_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT53.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT53_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT53.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT53.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT53_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT53.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT54: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT54_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT54.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT54.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT54_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT54.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT54_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT54.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT54.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT54_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT54.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT54_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT54.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT54.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT54_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT54.Reg) & 0xfffffff8) >> 3
}

// RGU.RESET_EXT_STAT55: Reset external status register
func (o *RGU_Type) SetRESET_EXT_STAT55_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT55.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT55.Reg)&^(0x3)|value)
}
func (o *RGU_Type) GetRESET_EXT_STAT55_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RESET_EXT_STAT55.Reg) & 0x3
}
func (o *RGU_Type) SetRESET_EXT_STAT55_PERIPHERAL_RESET(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT55.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT55.Reg)&^(0x4)|value<<2)
}
func (o *RGU_Type) GetRESET_EXT_STAT55_PERIPHERAL_RESET() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT55.Reg) & 0x4) >> 2
}
func (o *RGU_Type) SetRESET_EXT_STAT55_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESET_EXT_STAT55.Reg, volatile.LoadUint32(&o.RESET_EXT_STAT55.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RGU_Type) GetRESET_EXT_STAT55_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESET_EXT_STAT55.Reg) & 0xfffffff8) >> 3
}

// Windowed Watchdog timer (WWDT)
type WWDT_Type struct {
	MOD     volatile.Register32 // 0x0
	TC      volatile.Register32 // 0x4
	FEED    volatile.Register32 // 0x8
	TV      volatile.Register32 // 0xC
	_       [4]byte
	WARNINT volatile.Register32 // 0x14
	WINDOW  volatile.Register32 // 0x18
}

// WWDT.MOD: Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.
func (o *WWDT_Type) SetMOD_WDEN(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x1)|value)
}
func (o *WWDT_Type) GetMOD_WDEN() uint32 {
	return volatile.LoadUint32(&o.MOD.Reg) & 0x1
}
func (o *WWDT_Type) SetMOD_WDRESET(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x2)|value<<1)
}
func (o *WWDT_Type) GetMOD_WDRESET() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x2) >> 1
}
func (o *WWDT_Type) SetMOD_WDTOF(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x4)|value<<2)
}
func (o *WWDT_Type) GetMOD_WDTOF() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x4) >> 2
}
func (o *WWDT_Type) SetMOD_WDINT(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x8)|value<<3)
}
func (o *WWDT_Type) GetMOD_WDINT() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x8) >> 3
}
func (o *WWDT_Type) SetMOD_WDPROTECT(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x10)|value<<4)
}
func (o *WWDT_Type) GetMOD_WDPROTECT() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x10) >> 4
}
func (o *WWDT_Type) SetMOD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0xe0)|value<<5)
}
func (o *WWDT_Type) GetMOD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0xe0) >> 5
}

// WWDT.TC: Watchdog timer constant register. This register determines the time-out value.
func (o *WWDT_Type) SetTC_WDTC(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, volatile.LoadUint32(&o.TC.Reg)&^(0xffffff)|value)
}
func (o *WWDT_Type) GetTC_WDTC() uint32 {
	return volatile.LoadUint32(&o.TC.Reg) & 0xffffff
}
func (o *WWDT_Type) SetTC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, volatile.LoadUint32(&o.TC.Reg)&^(0xff000000)|value<<24)
}
func (o *WWDT_Type) GetTC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TC.Reg) & 0xff000000) >> 24
}

// WWDT.FEED: Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.
func (o *WWDT_Type) SetFEED_Feed(value uint32) {
	volatile.StoreUint32(&o.FEED.Reg, volatile.LoadUint32(&o.FEED.Reg)&^(0xff)|value)
}
func (o *WWDT_Type) GetFEED_Feed() uint32 {
	return volatile.LoadUint32(&o.FEED.Reg) & 0xff
}

// WWDT.TV: Watchdog timer value register. This register reads out the current value of the Watchdog timer.
func (o *WWDT_Type) SetTV_Count(value uint32) {
	volatile.StoreUint32(&o.TV.Reg, volatile.LoadUint32(&o.TV.Reg)&^(0xffffff)|value)
}
func (o *WWDT_Type) GetTV_Count() uint32 {
	return volatile.LoadUint32(&o.TV.Reg) & 0xffffff
}
func (o *WWDT_Type) SetTV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TV.Reg, volatile.LoadUint32(&o.TV.Reg)&^(0xff000000)|value<<24)
}
func (o *WWDT_Type) GetTV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TV.Reg) & 0xff000000) >> 24
}

// WWDT.WARNINT: Watchdog warning interrupt register. This register contains the Watchdog warning interrupt compare value.
func (o *WWDT_Type) SetWARNINT_WDWARNINT(value uint32) {
	volatile.StoreUint32(&o.WARNINT.Reg, volatile.LoadUint32(&o.WARNINT.Reg)&^(0x3ff)|value)
}
func (o *WWDT_Type) GetWARNINT_WDWARNINT() uint32 {
	return volatile.LoadUint32(&o.WARNINT.Reg) & 0x3ff
}
func (o *WWDT_Type) SetWARNINT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WARNINT.Reg, volatile.LoadUint32(&o.WARNINT.Reg)&^(0xfffffc00)|value<<10)
}
func (o *WWDT_Type) GetWARNINT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WARNINT.Reg) & 0xfffffc00) >> 10
}

// WWDT.WINDOW: Watchdog timer window register. This register contains the Watchdog window value.
func (o *WWDT_Type) SetWINDOW_WDWINDOW(value uint32) {
	volatile.StoreUint32(&o.WINDOW.Reg, volatile.LoadUint32(&o.WINDOW.Reg)&^(0xffffff)|value)
}
func (o *WWDT_Type) GetWINDOW_WDWINDOW() uint32 {
	return volatile.LoadUint32(&o.WINDOW.Reg) & 0xffffff
}
func (o *WWDT_Type) SetWINDOW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WINDOW.Reg, volatile.LoadUint32(&o.WINDOW.Reg)&^(0xff000000)|value<<24)
}
func (o *WWDT_Type) GetWINDOW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WINDOW.Reg) & 0xff000000) >> 24
}

// USART0_2_3
type USART_Type struct {
	RBR           volatile.Register32 // 0x0
	DLM           volatile.Register32 // 0x4
	IIR           volatile.Register32 // 0x8
	LCR           volatile.Register32 // 0xC
	_             [4]byte
	LSR           volatile.Register32 // 0x14
	_             [4]byte
	SCR           volatile.Register32 // 0x1C
	ACR           volatile.Register32 // 0x20
	ICR           volatile.Register32 // 0x24
	FDR           volatile.Register32 // 0x28
	OSR           volatile.Register32 // 0x2C
	_             [16]byte
	HDEN          volatile.Register32 // 0x40
	_             [4]byte
	SCICTRL       volatile.Register32 // 0x48
	RS485CTRL     volatile.Register32 // 0x4C
	RS485ADRMATCH volatile.Register32 // 0x50
	RS485DLY      volatile.Register32 // 0x54
	SYNCCTRL      volatile.Register32 // 0x58
	TER           volatile.Register32 // 0x5C
}

// USART.RBR: Receiver Buffer Register. Contains the next received character to be read (DLAB = 0).
func (o *USART_Type) SetRBR(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetRBR() uint32 {
	return volatile.LoadUint32(&o.RBR.Reg) & 0xff
}
func (o *USART_Type) SetRBR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetRBR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RBR.Reg) & 0xffffff00) >> 8
}

// USART.DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB = 1).
func (o *USART_Type) SetDLM_DLMSB(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetDLM_DLMSB() uint32 {
	return volatile.LoadUint32(&o.DLM.Reg) & 0xff
}
func (o *USART_Type) SetDLM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetDLM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DLM.Reg) & 0xffffff00) >> 8
}

// USART.IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
func (o *USART_Type) SetIIR_INTSTATUS(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIIR_INTSTATUS() uint32 {
	return volatile.LoadUint32(&o.IIR.Reg) & 0x1
}
func (o *USART_Type) SetIIR_INTID(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xe)|value<<1)
}
func (o *USART_Type) GetIIR_INTID() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xe) >> 1
}
func (o *USART_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x30)|value<<4)
}
func (o *USART_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x30) >> 4
}
func (o *USART_Type) SetIIR_FIFOENABLE(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xc0)|value<<6)
}
func (o *USART_Type) GetIIR_FIFOENABLE() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xc0) >> 6
}
func (o *USART_Type) SetIIR_ABEOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIIR_ABEOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIIR_ABTOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIIR_ABTOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *USART_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xfffffc00) >> 10
}

// USART.LCR: Line Control Register. Contains controls for frame formatting and break generation.
func (o *USART_Type) SetLCR_WLS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x3)|value)
}
func (o *USART_Type) GetLCR_WLS() uint32 {
	return volatile.LoadUint32(&o.LCR.Reg) & 0x3
}
func (o *USART_Type) SetLCR_SBS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetLCR_SBS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetLCR_PE(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetLCR_PE() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetLCR_PS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x30)|value<<4)
}
func (o *USART_Type) GetLCR_PS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x30) >> 4
}
func (o *USART_Type) SetLCR_BC(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetLCR_BC() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetLCR_DLAB(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetLCR_DLAB() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetLCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetLCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0xffffff00) >> 8
}

// USART.LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
func (o *USART_Type) SetLSR_RDR(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetLSR_RDR() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *USART_Type) SetLSR_OE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetLSR_OE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetLSR_PE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetLSR_PE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetLSR_FE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetLSR_FE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetLSR_BI(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetLSR_BI() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetLSR_THRE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetLSR_THRE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetLSR_TEMT(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetLSR_TEMT() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetLSR_RXFE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetLSR_RXFE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetLSR_TXERR(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetLSR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetLSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0xfffffe00)|value<<9)
}
func (o *USART_Type) GetLSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0xfffffe00) >> 9
}

// USART.SCR: Scratch Pad Register. Eight-bit temporary storage for software.
func (o *USART_Type) SetSCR_PAD(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetSCR_PAD() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0xff
}
func (o *USART_Type) SetSCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetSCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xffffff00) >> 8
}

// USART.ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
func (o *USART_Type) SetACR_START(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetACR_START() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x1
}
func (o *USART_Type) SetACR_MODE(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetACR_MODE() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetACR_AUTORESTART(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetACR_AUTORESTART() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xf8)|value<<3)
}
func (o *USART_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xf8) >> 3
}
func (o *USART_Type) SetACR_ABEOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetACR_ABEOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetACR_ABTOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetACR_ABTOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *USART_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xfffffc00) >> 10
}

// USART.ICR: IrDA control register (USART3 only)
func (o *USART_Type) SetICR_IRDAEN(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetICR_IRDAEN() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *USART_Type) SetICR_IRDAINV(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetICR_IRDAINV() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetICR_FIXPULSEEN(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetICR_FIXPULSEEN() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetICR_PULSEDIV(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x38)|value<<3)
}
func (o *USART_Type) GetICR_PULSEDIV() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x38) >> 3
}
func (o *USART_Type) SetICR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *USART_Type) GetICR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xffffffc0) >> 6
}

// USART.FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
func (o *USART_Type) SetFDR_DIVADDVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetFDR_DIVADDVAL() uint32 {
	return volatile.LoadUint32(&o.FDR.Reg) & 0xf
}
func (o *USART_Type) SetFDR_MULVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf0)|value<<4)
}
func (o *USART_Type) GetFDR_MULVAL() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xf0) >> 4
}
func (o *USART_Type) SetFDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetFDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xffffff00) >> 8
}

// USART.OSR: Oversampling Register. Controls the degree of oversampling during each bit time.
func (o *USART_Type) SetOSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetOSR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.OSR.Reg) & 0x1
}
func (o *USART_Type) SetOSR_OSFRAC(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0xe)|value<<1)
}
func (o *USART_Type) GetOSR_OSFRAC() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0xe) >> 1
}
func (o *USART_Type) SetOSR_OSINT(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0xf0)|value<<4)
}
func (o *USART_Type) GetOSR_OSINT() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0xf0) >> 4
}
func (o *USART_Type) SetOSR_FDINT(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x7f00)|value<<8)
}
func (o *USART_Type) GetOSR_FDINT() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x7f00) >> 8
}
func (o *USART_Type) SetOSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0xffff8000)|value<<15)
}
func (o *USART_Type) GetOSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0xffff8000) >> 15
}

// USART.HDEN: Half-duplex enable Register
func (o *USART_Type) SetHDEN(value uint32) {
	volatile.StoreUint32(&o.HDEN.Reg, volatile.LoadUint32(&o.HDEN.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetHDEN() uint32 {
	return volatile.LoadUint32(&o.HDEN.Reg) & 0x1
}
func (o *USART_Type) SetHDEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HDEN.Reg, volatile.LoadUint32(&o.HDEN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *USART_Type) GetHDEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HDEN.Reg) & 0xfffffffe) >> 1
}

// USART.SCICTRL: Smart card interface control register
func (o *USART_Type) SetSCICTRL_SCIEN(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetSCICTRL_SCIEN() uint32 {
	return volatile.LoadUint32(&o.SCICTRL.Reg) & 0x1
}
func (o *USART_Type) SetSCICTRL_NACKDIS(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetSCICTRL_NACKDIS() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetSCICTRL_PROTSEL(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetSCICTRL_PROTSEL() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetSCICTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0x18)|value<<3)
}
func (o *USART_Type) GetSCICTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0x18) >> 3
}
func (o *USART_Type) SetSCICTRL_TXRETRY(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0xe0)|value<<5)
}
func (o *USART_Type) GetSCICTRL_TXRETRY() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0xe0) >> 5
}
func (o *USART_Type) SetSCICTRL_GUARDTIME(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0xff00)|value<<8)
}
func (o *USART_Type) GetSCICTRL_GUARDTIME() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0xff00) >> 8
}
func (o *USART_Type) SetSCICTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *USART_Type) GetSCICTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0xffff0000) >> 16
}

// USART.RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
func (o *USART_Type) SetRS485CTRL_NMMEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetRS485CTRL_NMMEN() uint32 {
	return volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x1
}
func (o *USART_Type) SetRS485CTRL_RXDIS(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetRS485CTRL_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetRS485CTRL_AADEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetRS485CTRL_AADEN() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetRS485CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetRS485CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetRS485CTRL_DCTRL(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetRS485CTRL_DCTRL() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetRS485CTRL_OINV(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetRS485CTRL_OINV() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetRS485CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *USART_Type) GetRS485CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0xffffffc0) >> 6
}

// USART.RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
func (o *USART_Type) SetRS485ADRMATCH_ADRMATCH(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetRS485ADRMATCH_ADRMATCH() uint32 {
	return volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xff
}
func (o *USART_Type) SetRS485ADRMATCH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetRS485ADRMATCH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xffffff00) >> 8
}

// USART.RS485DLY: RS-485/EIA-485 direction control delay.
func (o *USART_Type) SetRS485DLY_DLY(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetRS485DLY_DLY() uint32 {
	return volatile.LoadUint32(&o.RS485DLY.Reg) & 0xff
}
func (o *USART_Type) SetRS485DLY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetRS485DLY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485DLY.Reg) & 0xffffff00) >> 8
}

// USART.SYNCCTRL: Synchronous mode control register.
func (o *USART_Type) SetSYNCCTRL_SYNC(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetSYNCCTRL_SYNC() uint32 {
	return volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x1
}
func (o *USART_Type) SetSYNCCTRL_CSRC(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetSYNCCTRL_CSRC() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetSYNCCTRL_FES(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetSYNCCTRL_FES() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetSYNCCTRL_TSBYPASS(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetSYNCCTRL_TSBYPASS() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetSYNCCTRL_CSCEN(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetSYNCCTRL_CSCEN() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetSYNCCTRL_SSSDIS(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetSYNCCTRL_SSSDIS() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetSYNCCTRL_CCCLR(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetSYNCCTRL_CCCLR() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetSYNCCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0xffffff80)|value<<7)
}
func (o *USART_Type) GetSYNCCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0xffffff80) >> 7
}

// USART.TER: Transmit Enable Register. Turns off USART transmitter for use with software flow control.
func (o *USART_Type) SetTER_TXEN(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetTER_TXEN() uint32 {
	return volatile.LoadUint32(&o.TER.Reg) & 0x1
}
func (o *USART_Type) SetTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0xfffffffe)|value<<1)
}
func (o *USART_Type) GetTER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TER.Reg) & 0xfffffffe) >> 1
}

// UART1
type UART1_Type struct {
	RBR           volatile.Register32 // 0x0
	DLM           volatile.Register32 // 0x4
	IIR           volatile.Register32 // 0x8
	LCR           volatile.Register32 // 0xC
	MCR           volatile.Register32 // 0x10
	LSR           volatile.Register32 // 0x14
	MSR           volatile.Register32 // 0x18
	SCR           volatile.Register32 // 0x1C
	ACR           volatile.Register32 // 0x20
	_             [4]byte
	FDR           volatile.Register32 // 0x28
	_             [32]byte
	RS485CTRL     volatile.Register32 // 0x4C
	RS485ADRMATCH volatile.Register32 // 0x50
	RS485DLY      volatile.Register32 // 0x54
	_             [4]byte
	TER           volatile.Register32 // 0x5C
}

// UART1.RBR: Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)
func (o *UART1_Type) SetRBR(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetRBR() uint32 {
	return volatile.LoadUint32(&o.RBR.Reg) & 0xff
}
func (o *UART1_Type) SetRBR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetRBR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RBR.Reg) & 0xffffff00) >> 8
}

// UART1.DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider.(DLAB=1)
func (o *UART1_Type) SetDLM_DLMSB(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetDLM_DLMSB() uint32 {
	return volatile.LoadUint32(&o.DLM.Reg) & 0xff
}
func (o *UART1_Type) SetDLM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetDLM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DLM.Reg) & 0xffffff00) >> 8
}

// UART1.IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
func (o *UART1_Type) SetIIR_INTSTATUS(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetIIR_INTSTATUS() uint32 {
	return volatile.LoadUint32(&o.IIR.Reg) & 0x1
}
func (o *UART1_Type) SetIIR_INTID(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xe)|value<<1)
}
func (o *UART1_Type) GetIIR_INTID() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xe) >> 1
}
func (o *UART1_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x30)|value<<4)
}
func (o *UART1_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x30) >> 4
}
func (o *UART1_Type) SetIIR_FIFOENABLE(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xc0)|value<<6)
}
func (o *UART1_Type) GetIIR_FIFOENABLE() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xc0) >> 6
}
func (o *UART1_Type) SetIIR_ABEOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x100)|value<<8)
}
func (o *UART1_Type) GetIIR_ABEOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x100) >> 8
}
func (o *UART1_Type) SetIIR_ABTOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x200)|value<<9)
}
func (o *UART1_Type) GetIIR_ABTOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x200) >> 9
}
func (o *UART1_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART1_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xfffffc00) >> 10
}

// UART1.LCR: Line Control Register. Contains controls for frame formatting and break generation.
func (o *UART1_Type) SetLCR_WLS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x3)|value)
}
func (o *UART1_Type) GetLCR_WLS() uint32 {
	return volatile.LoadUint32(&o.LCR.Reg) & 0x3
}
func (o *UART1_Type) SetLCR_SBS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetLCR_SBS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetLCR_PE(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetLCR_PE() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetLCR_PS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x30)|value<<4)
}
func (o *UART1_Type) GetLCR_PS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x30) >> 4
}
func (o *UART1_Type) SetLCR_BC(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetLCR_BC() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetLCR_DLAB(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetLCR_DLAB() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetLCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetLCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0xffffff00) >> 8
}

// UART1.MCR: Modem Control Register. Contains controls for flow control handshaking and loopback mode.
func (o *UART1_Type) SetMCR_DTRCTRL(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetMCR_DTRCTRL() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *UART1_Type) SetMCR_RTSCTRL(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetMCR_RTSCTRL() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xc)|value<<2)
}
func (o *UART1_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xc) >> 2
}
func (o *UART1_Type) SetMCR_LMS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetMCR_LMS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetMCR_RTSEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetMCR_RTSEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetMCR_CTSEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetMCR_CTSEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xffffff00) >> 8
}

// UART1.LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
func (o *UART1_Type) SetLSR_RDR(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetLSR_RDR() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *UART1_Type) SetLSR_OE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetLSR_OE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetLSR_PE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetLSR_PE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetLSR_FE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetLSR_FE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetLSR_BI(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetLSR_BI() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetLSR_THRE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetLSR_THRE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetLSR_TEMT(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetLSR_TEMT() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetLSR_RXFE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetLSR_RXFE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetLSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetLSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0xffffff00) >> 8
}

// UART1.MSR: Modem Status Register. Contains handshake signal status flags.
func (o *UART1_Type) SetMSR_DCTS(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetMSR_DCTS() uint32 {
	return volatile.LoadUint32(&o.MSR.Reg) & 0x1
}
func (o *UART1_Type) SetMSR_DDSR(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetMSR_DDSR() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetMSR_TERI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetMSR_TERI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetMSR_DDCD(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetMSR_DDCD() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetMSR_CTS(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetMSR_CTS() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetMSR_DSR(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetMSR_DSR() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetMSR_RI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetMSR_RI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetMSR_DCD(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetMSR_DCD() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetMSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetMSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0xffffff00) >> 8
}

// UART1.SCR: Scratch Pad Register. 8-bit temporary storage for software.
func (o *UART1_Type) SetSCR_Pad(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetSCR_Pad() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0xff
}
func (o *UART1_Type) SetSCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetSCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xffffff00) >> 8
}

// UART1.ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
func (o *UART1_Type) SetACR_START(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetACR_START() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x1
}
func (o *UART1_Type) SetACR_MODE(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetACR_MODE() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetACR_AUTORESTART(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetACR_AUTORESTART() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xf8)|value<<3)
}
func (o *UART1_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xf8) >> 3
}
func (o *UART1_Type) SetACR_ABEOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *UART1_Type) GetACR_ABEOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *UART1_Type) SetACR_ABTOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *UART1_Type) GetACR_ABTOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *UART1_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART1_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xfffffc00) >> 10
}

// UART1.FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
func (o *UART1_Type) SetFDR_DIVADDVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf)|value)
}
func (o *UART1_Type) GetFDR_DIVADDVAL() uint32 {
	return volatile.LoadUint32(&o.FDR.Reg) & 0xf
}
func (o *UART1_Type) SetFDR_MULVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf0)|value<<4)
}
func (o *UART1_Type) GetFDR_MULVAL() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xf0) >> 4
}
func (o *UART1_Type) SetFDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetFDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xffffff00) >> 8
}

// UART1.RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
func (o *UART1_Type) SetRS485CTRL_NMMEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetRS485CTRL_NMMEN() uint32 {
	return volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x1
}
func (o *UART1_Type) SetRS485CTRL_RXDIS(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetRS485CTRL_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetRS485CTRL_AADEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetRS485CTRL_AADEN() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetRS485CTRL_SEL(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetRS485CTRL_SEL() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetRS485CTRL_DCTRL(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetRS485CTRL_DCTRL() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetRS485CTRL_OINV(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetRS485CTRL_OINV() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetRS485CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *UART1_Type) GetRS485CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0xffffffc0) >> 6
}

// UART1.RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
func (o *UART1_Type) SetRS485ADRMATCH_ADRMATCH(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetRS485ADRMATCH_ADRMATCH() uint32 {
	return volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xff
}
func (o *UART1_Type) SetRS485ADRMATCH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetRS485ADRMATCH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xffffff00) >> 8
}

// UART1.RS485DLY: RS-485/EIA-485 direction control delay.
func (o *UART1_Type) SetRS485DLY_DLY(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetRS485DLY_DLY() uint32 {
	return volatile.LoadUint32(&o.RS485DLY.Reg) & 0xff
}
func (o *UART1_Type) SetRS485DLY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetRS485DLY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485DLY.Reg) & 0xffffff00) >> 8
}

// UART1.TER: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
func (o *UART1_Type) SetTER_TXEN(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetTER_TXEN() uint32 {
	return volatile.LoadUint32(&o.TER.Reg) & 0x1
}
func (o *UART1_Type) SetTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0xfffffffe)|value<<1)
}
func (o *UART1_Type) GetTER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TER.Reg) & 0xfffffffe) >> 1
}

// SSP0/1
type SSP_Type struct {
	CR0   volatile.Register32 // 0x0
	CR1   volatile.Register32 // 0x4
	DR    volatile.Register32 // 0x8
	SR    volatile.Register32 // 0xC
	CPSR  volatile.Register32 // 0x10
	IMSC  volatile.Register32 // 0x14
	RIS   volatile.Register32 // 0x18
	MIS   volatile.Register32 // 0x1C
	ICR   volatile.Register32 // 0x20
	DMACR volatile.Register32 // 0x24
}

// SSP.CR0: Control Register 0. Selects the serial clock rate, bus type, and data size.
func (o *SSP_Type) SetCR0_DSS(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xf)|value)
}
func (o *SSP_Type) GetCR0_DSS() uint32 {
	return volatile.LoadUint32(&o.CR0.Reg) & 0xf
}
func (o *SSP_Type) SetCR0_FRF(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0x30)|value<<4)
}
func (o *SSP_Type) GetCR0_FRF() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0x30) >> 4
}
func (o *SSP_Type) SetCR0_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0x40)|value<<6)
}
func (o *SSP_Type) GetCR0_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0x40) >> 6
}
func (o *SSP_Type) SetCR0_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0x80)|value<<7)
}
func (o *SSP_Type) GetCR0_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0x80) >> 7
}
func (o *SSP_Type) SetCR0_SCR(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xff00)|value<<8)
}
func (o *SSP_Type) GetCR0_SCR() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0xff00) >> 8
}
func (o *SSP_Type) SetCR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SSP_Type) GetCR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0xffff0000) >> 16
}

// SSP.CR1: Control Register 1. Selects master/slave and other modes.
func (o *SSP_Type) SetCR1_LBM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *SSP_Type) GetCR1_LBM() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *SSP_Type) SetCR1_SSE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *SSP_Type) GetCR1_SSE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *SSP_Type) SetCR1_MS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *SSP_Type) GetCR1_MS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *SSP_Type) SetCR1_SOD(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *SSP_Type) GetCR1_SOD() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *SSP_Type) SetCR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SSP_Type) GetCR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xfffffff0) >> 4
}

// SSP.DR: Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
func (o *SSP_Type) SetDR_DATA(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *SSP_Type) GetDR_DATA() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}
func (o *SSP_Type) SetDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SSP_Type) GetDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xffff0000) >> 16
}

// SSP.SR: Status Register
func (o *SSP_Type) SetSR_TFE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SSP_Type) GetSR_TFE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SSP_Type) SetSR_TNF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SSP_Type) GetSR_TNF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SSP_Type) SetSR_RNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SSP_Type) GetSR_RNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SSP_Type) SetSR_RFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SSP_Type) GetSR_RFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SSP_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SSP_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SSP_Type) SetSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SSP_Type) GetSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xffffffe0) >> 5
}

// SSP.CPSR: Clock Prescale Register
func (o *SSP_Type) SetCPSR_CPSDVSR(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xff)|value)
}
func (o *SSP_Type) GetCPSR_CPSDVSR() uint32 {
	return volatile.LoadUint32(&o.CPSR.Reg) & 0xff
}
func (o *SSP_Type) SetCPSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *SSP_Type) GetCPSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CPSR.Reg) & 0xffffff00) >> 8
}

// SSP.IMSC: Interrupt Mask Set and Clear Register
func (o *SSP_Type) SetIMSC_RORIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x1)|value)
}
func (o *SSP_Type) GetIMSC_RORIM() uint32 {
	return volatile.LoadUint32(&o.IMSC.Reg) & 0x1
}
func (o *SSP_Type) SetIMSC_RTIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x2)|value<<1)
}
func (o *SSP_Type) GetIMSC_RTIM() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0x2) >> 1
}
func (o *SSP_Type) SetIMSC_RXIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x4)|value<<2)
}
func (o *SSP_Type) GetIMSC_RXIM() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0x4) >> 2
}
func (o *SSP_Type) SetIMSC_TXIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x8)|value<<3)
}
func (o *SSP_Type) GetIMSC_TXIM() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0x8) >> 3
}
func (o *SSP_Type) SetIMSC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SSP_Type) GetIMSC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0xfffffff0) >> 4
}

// SSP.RIS: Raw Interrupt Status Register
func (o *SSP_Type) SetRIS_RORRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x1)|value)
}
func (o *SSP_Type) GetRIS_RORRIS() uint32 {
	return volatile.LoadUint32(&o.RIS.Reg) & 0x1
}
func (o *SSP_Type) SetRIS_RTRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x2)|value<<1)
}
func (o *SSP_Type) GetRIS_RTRIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x2) >> 1
}
func (o *SSP_Type) SetRIS_RXRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x4)|value<<2)
}
func (o *SSP_Type) GetRIS_RXRIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x4) >> 2
}
func (o *SSP_Type) SetRIS_TXRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x8)|value<<3)
}
func (o *SSP_Type) GetRIS_TXRIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x8) >> 3
}
func (o *SSP_Type) SetRIS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SSP_Type) GetRIS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0xfffffff0) >> 4
}

// SSP.MIS: Masked Interrupt Status Register
func (o *SSP_Type) SetMIS_RORMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x1)|value)
}
func (o *SSP_Type) GetMIS_RORMIS() uint32 {
	return volatile.LoadUint32(&o.MIS.Reg) & 0x1
}
func (o *SSP_Type) SetMIS_RTMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x2)|value<<1)
}
func (o *SSP_Type) GetMIS_RTMIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x2) >> 1
}
func (o *SSP_Type) SetMIS_RXMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x4)|value<<2)
}
func (o *SSP_Type) GetMIS_RXMIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x4) >> 2
}
func (o *SSP_Type) SetMIS_TXMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x8)|value<<3)
}
func (o *SSP_Type) GetMIS_TXMIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x8) >> 3
}
func (o *SSP_Type) SetMIS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SSP_Type) GetMIS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0xfffffff0) >> 4
}

// SSP.ICR: SSPICR Interrupt Clear Register
func (o *SSP_Type) SetICR_RORIC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *SSP_Type) GetICR_RORIC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *SSP_Type) SetICR_RTIC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *SSP_Type) GetICR_RTIC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *SSP_Type) SetICR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SSP_Type) GetICR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xfffffffc) >> 2
}

// SSP.DMACR: SSP0 DMA control register
func (o *SSP_Type) SetDMACR_RXDMAE(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x1)|value)
}
func (o *SSP_Type) GetDMACR_RXDMAE() uint32 {
	return volatile.LoadUint32(&o.DMACR.Reg) & 0x1
}
func (o *SSP_Type) SetDMACR_TXDMAE(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x2)|value<<1)
}
func (o *SSP_Type) GetDMACR_TXDMAE() uint32 {
	return (volatile.LoadUint32(&o.DMACR.Reg) & 0x2) >> 1
}
func (o *SSP_Type) SetDMACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SSP_Type) GetDMACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMACR.Reg) & 0xfffffffc) >> 2
}

// Timer0/1/2/3
type TIMER_Type struct {
	IR   volatile.Register32 // 0x0
	TCR  volatile.Register32 // 0x4
	TC   volatile.Register32 // 0x8
	PR   volatile.Register32 // 0xC
	PC   volatile.Register32 // 0x10
	MCR  volatile.Register32 // 0x14
	MR0  volatile.Register32 // 0x18
	MR1  volatile.Register32 // 0x1C
	MR2  volatile.Register32 // 0x20
	MR3  volatile.Register32 // 0x24
	CCR  volatile.Register32 // 0x28
	CR0  volatile.Register32 // 0x2C
	CR1  volatile.Register32 // 0x30
	CR2  volatile.Register32 // 0x34
	CR3  volatile.Register32 // 0x38
	EMR  volatile.Register32 // 0x3C
	_    [48]byte
	CTCR volatile.Register32 // 0x70
}

// TIMER.IR: Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
func (o *TIMER_Type) SetIR_MR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetIR_MR0INT() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *TIMER_Type) SetIR_MR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetIR_MR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetIR_MR2INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetIR_MR2INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetIR_MR3INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetIR_MR3INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetIR_CR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10)|value<<4)
}
func (o *TIMER_Type) GetIR_CR0INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10) >> 4
}
func (o *TIMER_Type) SetIR_CR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20)|value<<5)
}
func (o *TIMER_Type) GetIR_CR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20) >> 5
}
func (o *TIMER_Type) SetIR_CR2INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x40)|value<<6)
}
func (o *TIMER_Type) GetIR_CR2INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x40) >> 6
}
func (o *TIMER_Type) SetIR_CR3INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x80)|value<<7)
}
func (o *TIMER_Type) GetIR_CR3INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x80) >> 7
}
func (o *TIMER_Type) SetIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TIMER_Type) GetIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0xffffff00) >> 8
}

// TIMER.TCR: Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
func (o *TIMER_Type) SetTCR_CEN(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTCR_CEN() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *TIMER_Type) SetTCR_CRST(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetTCR_CRST() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *TIMER_Type) GetTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xfffffffc) >> 2
}

// TIMER.TC: Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
func (o *TIMER_Type) SetTC(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, value)
}
func (o *TIMER_Type) GetTC() uint32 {
	return volatile.LoadUint32(&o.TC.Reg)
}

// TIMER.PR: Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
func (o *TIMER_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, value)
}
func (o *TIMER_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg)
}

// TIMER.PC: Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
func (o *TIMER_Type) SetPC(value uint32) {
	volatile.StoreUint32(&o.PC.Reg, value)
}
func (o *TIMER_Type) GetPC() uint32 {
	return volatile.LoadUint32(&o.PC.Reg)
}

// TIMER.MCR: Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
func (o *TIMER_Type) SetMCR_MR0I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetMCR_MR0I() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *TIMER_Type) SetMCR_MR0R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetMCR_MR0R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetMCR_MR0S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetMCR_MR0S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetMCR_MR1I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetMCR_MR1I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetMCR_MR1R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *TIMER_Type) GetMCR_MR1R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *TIMER_Type) SetMCR_MR1S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *TIMER_Type) GetMCR_MR1S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *TIMER_Type) SetMCR_MR2I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *TIMER_Type) GetMCR_MR2I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *TIMER_Type) SetMCR_MR2R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *TIMER_Type) GetMCR_MR2R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *TIMER_Type) SetMCR_MR2S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100)|value<<8)
}
func (o *TIMER_Type) GetMCR_MR2S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100) >> 8
}
func (o *TIMER_Type) SetMCR_MR3I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200)|value<<9)
}
func (o *TIMER_Type) GetMCR_MR3I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200) >> 9
}
func (o *TIMER_Type) SetMCR_MR3R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400)|value<<10)
}
func (o *TIMER_Type) GetMCR_MR3R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400) >> 10
}
func (o *TIMER_Type) SetMCR_MR3S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800)|value<<11)
}
func (o *TIMER_Type) GetMCR_MR3S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800) >> 11
}
func (o *TIMER_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xfffff000)|value<<12)
}
func (o *TIMER_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xfffff000) >> 12
}

// TIMER.MR0: Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
func (o *TIMER_Type) SetMR0(value uint32) {
	volatile.StoreUint32(&o.MR0.Reg, value)
}
func (o *TIMER_Type) GetMR0() uint32 {
	return volatile.LoadUint32(&o.MR0.Reg)
}

// TIMER.MR1: Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
func (o *TIMER_Type) SetMR1(value uint32) {
	volatile.StoreUint32(&o.MR1.Reg, value)
}
func (o *TIMER_Type) GetMR1() uint32 {
	return volatile.LoadUint32(&o.MR1.Reg)
}

// TIMER.MR2: Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
func (o *TIMER_Type) SetMR2(value uint32) {
	volatile.StoreUint32(&o.MR2.Reg, value)
}
func (o *TIMER_Type) GetMR2() uint32 {
	return volatile.LoadUint32(&o.MR2.Reg)
}

// TIMER.MR3: Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
func (o *TIMER_Type) SetMR3(value uint32) {
	volatile.StoreUint32(&o.MR3.Reg, value)
}
func (o *TIMER_Type) GetMR3() uint32 {
	return volatile.LoadUint32(&o.MR3.Reg)
}

// TIMER.CCR: Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
func (o *TIMER_Type) SetCCR_CAP0RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetCCR_CAP0RE() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *TIMER_Type) SetCCR_CAP0FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetCCR_CAP0FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetCCR_CAP0I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetCCR_CAP0I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetCCR_CAP1RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetCCR_CAP1RE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetCCR_CAP1FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *TIMER_Type) GetCCR_CAP1FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *TIMER_Type) SetCCR_CAP1I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20)|value<<5)
}
func (o *TIMER_Type) GetCCR_CAP1I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20) >> 5
}
func (o *TIMER_Type) SetCCR_CAP2RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x40)|value<<6)
}
func (o *TIMER_Type) GetCCR_CAP2RE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x40) >> 6
}
func (o *TIMER_Type) SetCCR_CAP2FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x80)|value<<7)
}
func (o *TIMER_Type) GetCCR_CAP2FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x80) >> 7
}
func (o *TIMER_Type) SetCCR_CAP2I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *TIMER_Type) GetCCR_CAP2I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *TIMER_Type) SetCCR_CAP3RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *TIMER_Type) GetCCR_CAP3RE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}
func (o *TIMER_Type) SetCCR_CAP3FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x400)|value<<10)
}
func (o *TIMER_Type) GetCCR_CAP3FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x400) >> 10
}
func (o *TIMER_Type) SetCCR_CAP3I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x800)|value<<11)
}
func (o *TIMER_Type) GetCCR_CAP3I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x800) >> 11
}
func (o *TIMER_Type) SetCCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xfffff000)|value<<12)
}
func (o *TIMER_Type) GetCCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xfffff000) >> 12
}

// TIMER.CR0: Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
func (o *TIMER_Type) SetCR0(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, value)
}
func (o *TIMER_Type) GetCR0() uint32 {
	return volatile.LoadUint32(&o.CR0.Reg)
}

// TIMER.CR1: Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
func (o *TIMER_Type) SetCR1(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, value)
}
func (o *TIMER_Type) GetCR1() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg)
}

// TIMER.CR2: Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
func (o *TIMER_Type) SetCR2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, value)
}
func (o *TIMER_Type) GetCR2() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg)
}

// TIMER.CR3: Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
func (o *TIMER_Type) SetCR3(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, value)
}
func (o *TIMER_Type) GetCR3() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg)
}

// TIMER.EMR: External Match Register. The EMR controls the external match pins MATn.0-3 (MAT0.0-3 and MAT1.0-3 respectively).
func (o *TIMER_Type) SetEMR_EM0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetEMR_EM0() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x1
}
func (o *TIMER_Type) SetEMR_EM1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetEMR_EM1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetEMR_EM2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetEMR_EM2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetEMR_EM3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetEMR_EM3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetEMR_EMC0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x30)|value<<4)
}
func (o *TIMER_Type) GetEMR_EMC0() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x30) >> 4
}
func (o *TIMER_Type) SetEMR_EMC1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc0)|value<<6)
}
func (o *TIMER_Type) GetEMR_EMC1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc0) >> 6
}
func (o *TIMER_Type) SetEMR_EMC2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x300)|value<<8)
}
func (o *TIMER_Type) GetEMR_EMC2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x300) >> 8
}
func (o *TIMER_Type) SetEMR_EMC3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc00)|value<<10)
}
func (o *TIMER_Type) GetEMR_EMC3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc00) >> 10
}
func (o *TIMER_Type) SetEMR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xfffff000)|value<<12)
}
func (o *TIMER_Type) GetEMR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xfffff000) >> 12
}

// TIMER.CTCR: Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
func (o *TIMER_Type) SetCTCR_CTMODE(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0x3)|value)
}
func (o *TIMER_Type) GetCTCR_CTMODE() uint32 {
	return volatile.LoadUint32(&o.CTCR.Reg) & 0x3
}
func (o *TIMER_Type) SetCTCR_CINSEL(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xc)|value<<2)
}
func (o *TIMER_Type) GetCTCR_CINSEL() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xc) >> 2
}
func (o *TIMER_Type) SetCTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *TIMER_Type) GetCTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xfffffff0) >> 4
}

// System Control Unit (SCU) I/O configuration
type SCU_Type struct {
	SFSP0_0     volatile.Register32 // 0x0
	SFSP0_1     volatile.Register32 // 0x4
	_           [120]byte
	SFSP1_0     volatile.Register32 // 0x80
	SFSP1_1     volatile.Register32 // 0x84
	SFSP1_2     volatile.Register32 // 0x88
	SFSP1_3     volatile.Register32 // 0x8C
	SFSP1_4     volatile.Register32 // 0x90
	SFSP1_5     volatile.Register32 // 0x94
	SFSP1_6     volatile.Register32 // 0x98
	SFSP1_7     volatile.Register32 // 0x9C
	SFSP1_8     volatile.Register32 // 0xA0
	SFSP1_9     volatile.Register32 // 0xA4
	SFSP1_10    volatile.Register32 // 0xA8
	SFSP1_11    volatile.Register32 // 0xAC
	SFSP1_12    volatile.Register32 // 0xB0
	SFSP1_13    volatile.Register32 // 0xB4
	SFSP1_14    volatile.Register32 // 0xB8
	SFSP1_15    volatile.Register32 // 0xBC
	SFSP1_16    volatile.Register32 // 0xC0
	SFSP1_17    volatile.Register32 // 0xC4
	SFSP1_18    volatile.Register32 // 0xC8
	SFSP1_19    volatile.Register32 // 0xCC
	SFSP1_20    volatile.Register32 // 0xD0
	_           [44]byte
	SFSP2_0     volatile.Register32 // 0x100
	SFSP2_1     volatile.Register32 // 0x104
	SFSP2_2     volatile.Register32 // 0x108
	SFSP2_3     volatile.Register32 // 0x10C
	SFSP2_4     volatile.Register32 // 0x110
	SFSP2_5     volatile.Register32 // 0x114
	SFSP2_6     volatile.Register32 // 0x118
	SFSP2_7     volatile.Register32 // 0x11C
	SFSP2_8     volatile.Register32 // 0x120
	SFSP2_9     volatile.Register32 // 0x124
	SFSP2_10    volatile.Register32 // 0x128
	SFSP2_11    volatile.Register32 // 0x12C
	SFSP2_12    volatile.Register32 // 0x130
	_           [76]byte
	SFSP3_0     volatile.Register32 // 0x180
	SFSP3_1     volatile.Register32 // 0x184
	SFSP3_2     volatile.Register32 // 0x188
	SFSP3_3     volatile.Register32 // 0x18C
	SFSP3_4     volatile.Register32 // 0x190
	SFSP3_5     volatile.Register32 // 0x194
	SFSP3_6     volatile.Register32 // 0x198
	SFSP3_7     volatile.Register32 // 0x19C
	SFSP3_8     volatile.Register32 // 0x1A0
	_           [92]byte
	SFSP4_0     volatile.Register32 // 0x200
	SFSP4_1     volatile.Register32 // 0x204
	SFSP4_2     volatile.Register32 // 0x208
	SFSP4_3     volatile.Register32 // 0x20C
	SFSP4_4     volatile.Register32 // 0x210
	SFSP4_5     volatile.Register32 // 0x214
	SFSP4_6     volatile.Register32 // 0x218
	SFSP4_7     volatile.Register32 // 0x21C
	SFSP4_8     volatile.Register32 // 0x220
	SFSP4_9     volatile.Register32 // 0x224
	SFSP4_10    volatile.Register32 // 0x228
	_           [84]byte
	SFSP5_0     volatile.Register32 // 0x280
	SFSP5_1     volatile.Register32 // 0x284
	SFSP5_2     volatile.Register32 // 0x288
	SFSP5_3     volatile.Register32 // 0x28C
	SFSP5_4     volatile.Register32 // 0x290
	SFSP5_5     volatile.Register32 // 0x294
	SFSP5_6     volatile.Register32 // 0x298
	SFSP5_7     volatile.Register32 // 0x29C
	_           [96]byte
	SFSP6_0     volatile.Register32 // 0x300
	SFSP6_1     volatile.Register32 // 0x304
	SFSP6_2     volatile.Register32 // 0x308
	SFSP6_3     volatile.Register32 // 0x30C
	SFSP6_4     volatile.Register32 // 0x310
	SFSP6_5     volatile.Register32 // 0x314
	SFSP6_6     volatile.Register32 // 0x318
	SFSP6_7     volatile.Register32 // 0x31C
	SFSP6_8     volatile.Register32 // 0x320
	SFSP6_9     volatile.Register32 // 0x324
	SFSP6_10    volatile.Register32 // 0x328
	SFSP6_11    volatile.Register32 // 0x32C
	SFSP6_12    volatile.Register32 // 0x330
	_           [76]byte
	SFSP7_0     volatile.Register32 // 0x380
	SFSP7_1     volatile.Register32 // 0x384
	SFSP7_2     volatile.Register32 // 0x388
	SFSP7_3     volatile.Register32 // 0x38C
	SFSP7_4     volatile.Register32 // 0x390
	SFSP7_5     volatile.Register32 // 0x394
	SFSP7_6     volatile.Register32 // 0x398
	SFSP7_7     volatile.Register32 // 0x39C
	_           [96]byte
	SFSP8_0     volatile.Register32 // 0x400
	SFSP8_1     volatile.Register32 // 0x404
	SFSP8_2     volatile.Register32 // 0x408
	SFSP8_3     volatile.Register32 // 0x40C
	SFSP8_4     volatile.Register32 // 0x410
	SFSP8_5     volatile.Register32 // 0x414
	SFSP8_6     volatile.Register32 // 0x418
	SFSP8_7     volatile.Register32 // 0x41C
	SFSP8_8     volatile.Register32 // 0x420
	_           [92]byte
	SFSP9_0     volatile.Register32 // 0x480
	SFSP9_1     volatile.Register32 // 0x484
	SFSP9_2     volatile.Register32 // 0x488
	SFSP9_3     volatile.Register32 // 0x48C
	SFSP9_4     volatile.Register32 // 0x490
	SFSP9_5     volatile.Register32 // 0x494
	SFSP9_6     volatile.Register32 // 0x498
	_           [100]byte
	SFSPA_0     volatile.Register32 // 0x500
	SFSPA_1     volatile.Register32 // 0x504
	SFSPA_2     volatile.Register32 // 0x508
	SFSPA_3     volatile.Register32 // 0x50C
	SFSPA_4     volatile.Register32 // 0x510
	_           [108]byte
	SFSPB_0     volatile.Register32 // 0x580
	SFSPB_1     volatile.Register32 // 0x584
	SFSPB_2     volatile.Register32 // 0x588
	SFSPB_3     volatile.Register32 // 0x58C
	SFSPB_4     volatile.Register32 // 0x590
	SFSPB_5     volatile.Register32 // 0x594
	SFSPB_6     volatile.Register32 // 0x598
	_           [100]byte
	SFSPC_0     volatile.Register32 // 0x600
	SFSPC_1     volatile.Register32 // 0x604
	SFSPC_2     volatile.Register32 // 0x608
	SFSPC_3     volatile.Register32 // 0x60C
	SFSPC_4     volatile.Register32 // 0x610
	SFSPC_5     volatile.Register32 // 0x614
	SFSPC_6     volatile.Register32 // 0x618
	SFSPC_7     volatile.Register32 // 0x61C
	SFSPC_8     volatile.Register32 // 0x620
	SFSPC_9     volatile.Register32 // 0x624
	SFSPC_10    volatile.Register32 // 0x628
	SFSPC_11    volatile.Register32 // 0x62C
	SFSPC_12    volatile.Register32 // 0x630
	SFSPC_13    volatile.Register32 // 0x634
	SFSPC_14    volatile.Register32 // 0x638
	_           [68]byte
	SFSPD_0     volatile.Register32 // 0x680
	SFSPD_1     volatile.Register32 // 0x684
	SFSPD_2     volatile.Register32 // 0x688
	SFSPD_3     volatile.Register32 // 0x68C
	SFSPD_4     volatile.Register32 // 0x690
	SFSPD_5     volatile.Register32 // 0x694
	SFSPD_6     volatile.Register32 // 0x698
	SFSPD_7     volatile.Register32 // 0x69C
	SFSPD_8     volatile.Register32 // 0x6A0
	SFSPD_9     volatile.Register32 // 0x6A4
	SFSPD_10    volatile.Register32 // 0x6A8
	SFSPD_11    volatile.Register32 // 0x6AC
	SFSPD_12    volatile.Register32 // 0x6B0
	SFSPD_13    volatile.Register32 // 0x6B4
	SFSPD_14    volatile.Register32 // 0x6B8
	SFSPD_15    volatile.Register32 // 0x6BC
	SFSPD_16    volatile.Register32 // 0x6C0
	_           [60]byte
	SFSPE_0     volatile.Register32 // 0x700
	SFSPE_1     volatile.Register32 // 0x704
	SFSPE_2     volatile.Register32 // 0x708
	SFSPE_3     volatile.Register32 // 0x70C
	SFSPE_4     volatile.Register32 // 0x710
	SFSPE_5     volatile.Register32 // 0x714
	SFSPE_6     volatile.Register32 // 0x718
	SFSPE_7     volatile.Register32 // 0x71C
	SFSPE_8     volatile.Register32 // 0x720
	SFSPE_9     volatile.Register32 // 0x724
	SFSPE_10    volatile.Register32 // 0x728
	SFSPE_11    volatile.Register32 // 0x72C
	SFSPE_12    volatile.Register32 // 0x730
	SFSPE_13    volatile.Register32 // 0x734
	SFSPE_14    volatile.Register32 // 0x738
	SFSPE_15    volatile.Register32 // 0x73C
	_           [64]byte
	SFSPF_0     volatile.Register32 // 0x780
	SFSPF_1     volatile.Register32 // 0x784
	SFSPF_2     volatile.Register32 // 0x788
	SFSPF_3     volatile.Register32 // 0x78C
	SFSPF_4     volatile.Register32 // 0x790
	SFSPF_5     volatile.Register32 // 0x794
	SFSPF_6     volatile.Register32 // 0x798
	SFSPF_7     volatile.Register32 // 0x79C
	SFSPF_8     volatile.Register32 // 0x7A0
	SFSPF_9     volatile.Register32 // 0x7A4
	SFSPF_10    volatile.Register32 // 0x7A8
	SFSPF_11    volatile.Register32 // 0x7AC
	_           [1104]byte
	SFSCLK_0    volatile.Register32 // 0xC00
	SFSCLK_1    volatile.Register32 // 0xC04
	SFSCLK_2    volatile.Register32 // 0xC08
	SFSCLK_3    volatile.Register32 // 0xC0C
	_           [112]byte
	SFSUSB      volatile.Register32 // 0xC80
	SFSI2C0     volatile.Register32 // 0xC84
	ENAIO0      volatile.Register32 // 0xC88
	ENAIO1      volatile.Register32 // 0xC8C
	ENAIO2      volatile.Register32 // 0xC90
	_           [108]byte
	EMCDELAYCLK volatile.Register32 // 0xD00
	_           [124]byte
	SDDELAY     volatile.Register32 // 0xD80
	_           [124]byte
	PINTSEL0    volatile.Register32 // 0xE00
	PINTSEL1    volatile.Register32 // 0xE04
}

// SCU.SFSP0_0: Pin configuration register for pins P0
func (o *SCU_Type) SetSFSP0_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP0_0.Reg, volatile.LoadUint32(&o.SFSP0_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP0_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP0_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP0_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP0_0.Reg, volatile.LoadUint32(&o.SFSP0_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP0_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP0_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP0_0.Reg, volatile.LoadUint32(&o.SFSP0_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP0_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP0_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP0_0.Reg, volatile.LoadUint32(&o.SFSP0_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP0_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP0_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP0_0.Reg, volatile.LoadUint32(&o.SFSP0_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP0_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP0_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP0_0.Reg, volatile.LoadUint32(&o.SFSP0_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP0_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP0_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP0_0.Reg, volatile.LoadUint32(&o.SFSP0_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP0_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP0_1: Pin configuration register for pins P0
func (o *SCU_Type) SetSFSP0_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP0_1.Reg, volatile.LoadUint32(&o.SFSP0_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP0_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP0_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP0_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP0_1.Reg, volatile.LoadUint32(&o.SFSP0_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP0_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP0_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP0_1.Reg, volatile.LoadUint32(&o.SFSP0_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP0_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP0_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP0_1.Reg, volatile.LoadUint32(&o.SFSP0_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP0_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP0_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP0_1.Reg, volatile.LoadUint32(&o.SFSP0_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP0_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP0_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP0_1.Reg, volatile.LoadUint32(&o.SFSP0_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP0_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP0_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP0_1.Reg, volatile.LoadUint32(&o.SFSP0_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP0_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP0_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_0: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_0.Reg, volatile.LoadUint32(&o.SFSP1_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_0.Reg, volatile.LoadUint32(&o.SFSP1_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_0.Reg, volatile.LoadUint32(&o.SFSP1_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_0.Reg, volatile.LoadUint32(&o.SFSP1_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_0.Reg, volatile.LoadUint32(&o.SFSP1_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_0.Reg, volatile.LoadUint32(&o.SFSP1_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_0.Reg, volatile.LoadUint32(&o.SFSP1_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_1: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_1.Reg, volatile.LoadUint32(&o.SFSP1_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_1.Reg, volatile.LoadUint32(&o.SFSP1_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_1.Reg, volatile.LoadUint32(&o.SFSP1_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_1.Reg, volatile.LoadUint32(&o.SFSP1_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_1.Reg, volatile.LoadUint32(&o.SFSP1_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_1.Reg, volatile.LoadUint32(&o.SFSP1_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_1.Reg, volatile.LoadUint32(&o.SFSP1_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_2: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_2.Reg, volatile.LoadUint32(&o.SFSP1_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_2.Reg, volatile.LoadUint32(&o.SFSP1_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_2.Reg, volatile.LoadUint32(&o.SFSP1_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_2.Reg, volatile.LoadUint32(&o.SFSP1_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_2.Reg, volatile.LoadUint32(&o.SFSP1_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_2.Reg, volatile.LoadUint32(&o.SFSP1_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_2.Reg, volatile.LoadUint32(&o.SFSP1_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_3: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_3.Reg, volatile.LoadUint32(&o.SFSP1_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_3.Reg, volatile.LoadUint32(&o.SFSP1_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_3.Reg, volatile.LoadUint32(&o.SFSP1_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_3.Reg, volatile.LoadUint32(&o.SFSP1_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_3.Reg, volatile.LoadUint32(&o.SFSP1_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_3.Reg, volatile.LoadUint32(&o.SFSP1_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_3.Reg, volatile.LoadUint32(&o.SFSP1_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_4: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_4.Reg, volatile.LoadUint32(&o.SFSP1_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_4.Reg, volatile.LoadUint32(&o.SFSP1_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_4.Reg, volatile.LoadUint32(&o.SFSP1_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_4.Reg, volatile.LoadUint32(&o.SFSP1_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_4.Reg, volatile.LoadUint32(&o.SFSP1_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_4.Reg, volatile.LoadUint32(&o.SFSP1_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_4.Reg, volatile.LoadUint32(&o.SFSP1_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_5: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_5.Reg, volatile.LoadUint32(&o.SFSP1_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_5.Reg, volatile.LoadUint32(&o.SFSP1_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_5.Reg, volatile.LoadUint32(&o.SFSP1_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_5.Reg, volatile.LoadUint32(&o.SFSP1_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_5.Reg, volatile.LoadUint32(&o.SFSP1_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_5.Reg, volatile.LoadUint32(&o.SFSP1_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_5.Reg, volatile.LoadUint32(&o.SFSP1_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_6: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_6.Reg, volatile.LoadUint32(&o.SFSP1_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_6.Reg, volatile.LoadUint32(&o.SFSP1_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_6.Reg, volatile.LoadUint32(&o.SFSP1_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_6.Reg, volatile.LoadUint32(&o.SFSP1_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_6.Reg, volatile.LoadUint32(&o.SFSP1_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_6.Reg, volatile.LoadUint32(&o.SFSP1_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_6.Reg, volatile.LoadUint32(&o.SFSP1_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_7: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_7.Reg, volatile.LoadUint32(&o.SFSP1_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_7.Reg, volatile.LoadUint32(&o.SFSP1_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_7.Reg, volatile.LoadUint32(&o.SFSP1_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_7.Reg, volatile.LoadUint32(&o.SFSP1_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_7.Reg, volatile.LoadUint32(&o.SFSP1_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_7.Reg, volatile.LoadUint32(&o.SFSP1_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_7.Reg, volatile.LoadUint32(&o.SFSP1_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_8: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_8.Reg, volatile.LoadUint32(&o.SFSP1_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_8.Reg, volatile.LoadUint32(&o.SFSP1_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_8.Reg, volatile.LoadUint32(&o.SFSP1_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_8.Reg, volatile.LoadUint32(&o.SFSP1_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_8.Reg, volatile.LoadUint32(&o.SFSP1_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_8.Reg, volatile.LoadUint32(&o.SFSP1_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_8.Reg, volatile.LoadUint32(&o.SFSP1_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_9: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_9_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_9.Reg, volatile.LoadUint32(&o.SFSP1_9.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_9_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_9.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_9_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_9.Reg, volatile.LoadUint32(&o.SFSP1_9.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_9_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_9.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_9_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_9.Reg, volatile.LoadUint32(&o.SFSP1_9.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_9_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_9.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_9_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_9.Reg, volatile.LoadUint32(&o.SFSP1_9.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_9_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_9.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_9_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_9.Reg, volatile.LoadUint32(&o.SFSP1_9.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_9_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_9.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_9_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_9.Reg, volatile.LoadUint32(&o.SFSP1_9.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_9_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_9.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_9.Reg, volatile.LoadUint32(&o.SFSP1_9.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_9.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_10: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_10_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_10.Reg, volatile.LoadUint32(&o.SFSP1_10.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_10_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_10.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_10_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_10.Reg, volatile.LoadUint32(&o.SFSP1_10.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_10_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_10.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_10_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_10.Reg, volatile.LoadUint32(&o.SFSP1_10.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_10_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_10.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_10_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_10.Reg, volatile.LoadUint32(&o.SFSP1_10.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_10_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_10.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_10_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_10.Reg, volatile.LoadUint32(&o.SFSP1_10.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_10_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_10.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_10_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_10.Reg, volatile.LoadUint32(&o.SFSP1_10.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_10_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_10.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_10.Reg, volatile.LoadUint32(&o.SFSP1_10.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_10.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_11: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_11_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_11.Reg, volatile.LoadUint32(&o.SFSP1_11.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_11_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_11.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_11_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_11.Reg, volatile.LoadUint32(&o.SFSP1_11.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_11_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_11.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_11_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_11.Reg, volatile.LoadUint32(&o.SFSP1_11.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_11_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_11.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_11_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_11.Reg, volatile.LoadUint32(&o.SFSP1_11.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_11_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_11.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_11_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_11.Reg, volatile.LoadUint32(&o.SFSP1_11.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_11_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_11.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_11_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_11.Reg, volatile.LoadUint32(&o.SFSP1_11.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_11_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_11.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_11.Reg, volatile.LoadUint32(&o.SFSP1_11.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_11.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_12: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_12_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_12.Reg, volatile.LoadUint32(&o.SFSP1_12.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_12_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_12.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_12_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_12.Reg, volatile.LoadUint32(&o.SFSP1_12.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_12_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_12.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_12_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_12.Reg, volatile.LoadUint32(&o.SFSP1_12.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_12_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_12.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_12_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_12.Reg, volatile.LoadUint32(&o.SFSP1_12.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_12_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_12.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_12_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_12.Reg, volatile.LoadUint32(&o.SFSP1_12.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_12_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_12.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_12_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_12.Reg, volatile.LoadUint32(&o.SFSP1_12.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_12_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_12.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_12.Reg, volatile.LoadUint32(&o.SFSP1_12.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_12.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_13: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_13_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_13.Reg, volatile.LoadUint32(&o.SFSP1_13.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_13_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_13.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_13_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_13.Reg, volatile.LoadUint32(&o.SFSP1_13.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_13_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_13.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_13_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_13.Reg, volatile.LoadUint32(&o.SFSP1_13.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_13_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_13.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_13_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_13.Reg, volatile.LoadUint32(&o.SFSP1_13.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_13_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_13.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_13_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_13.Reg, volatile.LoadUint32(&o.SFSP1_13.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_13_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_13.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_13_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_13.Reg, volatile.LoadUint32(&o.SFSP1_13.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_13_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_13.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_13.Reg, volatile.LoadUint32(&o.SFSP1_13.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_13.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_14: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_14_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_14.Reg, volatile.LoadUint32(&o.SFSP1_14.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_14_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_14.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_14_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_14.Reg, volatile.LoadUint32(&o.SFSP1_14.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_14_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_14.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_14_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_14.Reg, volatile.LoadUint32(&o.SFSP1_14.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_14_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_14.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_14_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_14.Reg, volatile.LoadUint32(&o.SFSP1_14.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_14_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_14.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_14_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_14.Reg, volatile.LoadUint32(&o.SFSP1_14.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_14_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_14.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_14_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_14.Reg, volatile.LoadUint32(&o.SFSP1_14.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_14_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_14.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_14.Reg, volatile.LoadUint32(&o.SFSP1_14.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_14.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_15: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_15_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_15.Reg, volatile.LoadUint32(&o.SFSP1_15.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_15_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_15.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_15_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_15.Reg, volatile.LoadUint32(&o.SFSP1_15.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_15_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_15.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_15_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_15.Reg, volatile.LoadUint32(&o.SFSP1_15.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_15_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_15.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_15_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_15.Reg, volatile.LoadUint32(&o.SFSP1_15.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_15_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_15.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_15_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_15.Reg, volatile.LoadUint32(&o.SFSP1_15.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_15_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_15.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_15_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_15.Reg, volatile.LoadUint32(&o.SFSP1_15.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_15_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_15.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_15.Reg, volatile.LoadUint32(&o.SFSP1_15.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_15.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_16: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_16_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_16.Reg, volatile.LoadUint32(&o.SFSP1_16.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_16_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_16.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_16_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_16.Reg, volatile.LoadUint32(&o.SFSP1_16.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_16_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_16.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_16_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_16.Reg, volatile.LoadUint32(&o.SFSP1_16.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_16_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_16.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_16_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_16.Reg, volatile.LoadUint32(&o.SFSP1_16.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_16_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_16.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_16_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_16.Reg, volatile.LoadUint32(&o.SFSP1_16.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_16_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_16.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_16_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_16.Reg, volatile.LoadUint32(&o.SFSP1_16.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_16_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_16.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_16.Reg, volatile.LoadUint32(&o.SFSP1_16.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_16.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_17: Pin configuration register for pins P1_17
func (o *SCU_Type) SetSFSP1_17_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_17.Reg, volatile.LoadUint32(&o.SFSP1_17.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_17_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_17.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_17_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_17.Reg, volatile.LoadUint32(&o.SFSP1_17.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_17_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_17.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_17_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_17.Reg, volatile.LoadUint32(&o.SFSP1_17.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_17_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_17.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_17.Reg, volatile.LoadUint32(&o.SFSP1_17.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_17.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_17_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_17.Reg, volatile.LoadUint32(&o.SFSP1_17.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_17_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_17.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_17_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_17.Reg, volatile.LoadUint32(&o.SFSP1_17.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_17_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_17.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_17_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_17.Reg, volatile.LoadUint32(&o.SFSP1_17.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP1_17_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_17.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP1_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_17.Reg, volatile.LoadUint32(&o.SFSP1_17.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP1_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_17.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP1_18: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_18_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_18.Reg, volatile.LoadUint32(&o.SFSP1_18.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_18_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_18.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_18_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_18.Reg, volatile.LoadUint32(&o.SFSP1_18.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_18_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_18.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_18_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_18.Reg, volatile.LoadUint32(&o.SFSP1_18.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_18_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_18.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_18_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_18.Reg, volatile.LoadUint32(&o.SFSP1_18.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_18_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_18.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_18_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_18.Reg, volatile.LoadUint32(&o.SFSP1_18.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_18_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_18.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_18_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_18.Reg, volatile.LoadUint32(&o.SFSP1_18.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_18_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_18.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_18.Reg, volatile.LoadUint32(&o.SFSP1_18.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_18.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_19: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_19_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_19.Reg, volatile.LoadUint32(&o.SFSP1_19.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_19_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_19.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_19_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_19.Reg, volatile.LoadUint32(&o.SFSP1_19.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_19_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_19.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_19_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_19.Reg, volatile.LoadUint32(&o.SFSP1_19.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_19_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_19.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_19_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_19.Reg, volatile.LoadUint32(&o.SFSP1_19.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_19_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_19.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_19_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_19.Reg, volatile.LoadUint32(&o.SFSP1_19.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_19_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_19.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_19_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_19.Reg, volatile.LoadUint32(&o.SFSP1_19.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_19_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_19.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_19.Reg, volatile.LoadUint32(&o.SFSP1_19.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_19.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP1_20: Pin configuration register for pins P1
func (o *SCU_Type) SetSFSP1_20_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP1_20.Reg, volatile.LoadUint32(&o.SFSP1_20.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP1_20_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP1_20.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP1_20_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP1_20.Reg, volatile.LoadUint32(&o.SFSP1_20.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP1_20_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_20.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP1_20_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP1_20.Reg, volatile.LoadUint32(&o.SFSP1_20.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP1_20_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_20.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP1_20_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP1_20.Reg, volatile.LoadUint32(&o.SFSP1_20.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP1_20_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_20.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP1_20_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP1_20.Reg, volatile.LoadUint32(&o.SFSP1_20.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP1_20_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_20.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP1_20_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP1_20.Reg, volatile.LoadUint32(&o.SFSP1_20.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP1_20_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_20.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP1_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP1_20.Reg, volatile.LoadUint32(&o.SFSP1_20.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP1_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP1_20.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_0: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_0.Reg, volatile.LoadUint32(&o.SFSP2_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_0.Reg, volatile.LoadUint32(&o.SFSP2_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_0.Reg, volatile.LoadUint32(&o.SFSP2_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_0.Reg, volatile.LoadUint32(&o.SFSP2_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_0.Reg, volatile.LoadUint32(&o.SFSP2_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_0.Reg, volatile.LoadUint32(&o.SFSP2_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_0.Reg, volatile.LoadUint32(&o.SFSP2_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_1: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_1.Reg, volatile.LoadUint32(&o.SFSP2_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_1.Reg, volatile.LoadUint32(&o.SFSP2_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_1.Reg, volatile.LoadUint32(&o.SFSP2_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_1.Reg, volatile.LoadUint32(&o.SFSP2_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_1.Reg, volatile.LoadUint32(&o.SFSP2_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_1.Reg, volatile.LoadUint32(&o.SFSP2_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_1.Reg, volatile.LoadUint32(&o.SFSP2_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_2: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_2.Reg, volatile.LoadUint32(&o.SFSP2_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_2.Reg, volatile.LoadUint32(&o.SFSP2_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_2.Reg, volatile.LoadUint32(&o.SFSP2_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_2.Reg, volatile.LoadUint32(&o.SFSP2_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_2.Reg, volatile.LoadUint32(&o.SFSP2_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_2.Reg, volatile.LoadUint32(&o.SFSP2_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_2.Reg, volatile.LoadUint32(&o.SFSP2_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_3: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_3.Reg, volatile.LoadUint32(&o.SFSP2_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_3.Reg, volatile.LoadUint32(&o.SFSP2_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_3.Reg, volatile.LoadUint32(&o.SFSP2_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_3.Reg, volatile.LoadUint32(&o.SFSP2_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_3.Reg, volatile.LoadUint32(&o.SFSP2_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_3.Reg, volatile.LoadUint32(&o.SFSP2_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_3_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_3.Reg, volatile.LoadUint32(&o.SFSP2_3.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP2_3_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_3.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP2_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_3.Reg, volatile.LoadUint32(&o.SFSP2_3.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP2_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_3.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP2_4: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_4.Reg, volatile.LoadUint32(&o.SFSP2_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_4.Reg, volatile.LoadUint32(&o.SFSP2_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_4.Reg, volatile.LoadUint32(&o.SFSP2_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_4.Reg, volatile.LoadUint32(&o.SFSP2_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_4.Reg, volatile.LoadUint32(&o.SFSP2_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_4.Reg, volatile.LoadUint32(&o.SFSP2_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_4_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_4.Reg, volatile.LoadUint32(&o.SFSP2_4.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP2_4_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_4.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP2_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_4.Reg, volatile.LoadUint32(&o.SFSP2_4.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP2_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_4.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP2_5: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_5.Reg, volatile.LoadUint32(&o.SFSP2_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_5.Reg, volatile.LoadUint32(&o.SFSP2_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_5.Reg, volatile.LoadUint32(&o.SFSP2_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_5.Reg, volatile.LoadUint32(&o.SFSP2_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_5.Reg, volatile.LoadUint32(&o.SFSP2_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_5.Reg, volatile.LoadUint32(&o.SFSP2_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_5_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_5.Reg, volatile.LoadUint32(&o.SFSP2_5.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP2_5_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_5.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP2_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_5.Reg, volatile.LoadUint32(&o.SFSP2_5.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP2_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_5.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP2_6: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_6.Reg, volatile.LoadUint32(&o.SFSP2_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_6.Reg, volatile.LoadUint32(&o.SFSP2_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_6.Reg, volatile.LoadUint32(&o.SFSP2_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_6.Reg, volatile.LoadUint32(&o.SFSP2_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_6.Reg, volatile.LoadUint32(&o.SFSP2_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_6.Reg, volatile.LoadUint32(&o.SFSP2_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_6.Reg, volatile.LoadUint32(&o.SFSP2_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_7: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_7.Reg, volatile.LoadUint32(&o.SFSP2_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_7.Reg, volatile.LoadUint32(&o.SFSP2_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_7.Reg, volatile.LoadUint32(&o.SFSP2_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_7.Reg, volatile.LoadUint32(&o.SFSP2_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_7.Reg, volatile.LoadUint32(&o.SFSP2_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_7.Reg, volatile.LoadUint32(&o.SFSP2_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_7.Reg, volatile.LoadUint32(&o.SFSP2_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_8: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_8.Reg, volatile.LoadUint32(&o.SFSP2_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_8.Reg, volatile.LoadUint32(&o.SFSP2_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_8.Reg, volatile.LoadUint32(&o.SFSP2_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_8.Reg, volatile.LoadUint32(&o.SFSP2_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_8.Reg, volatile.LoadUint32(&o.SFSP2_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_8.Reg, volatile.LoadUint32(&o.SFSP2_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_8.Reg, volatile.LoadUint32(&o.SFSP2_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_9: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_9_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_9.Reg, volatile.LoadUint32(&o.SFSP2_9.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_9_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_9.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_9_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_9.Reg, volatile.LoadUint32(&o.SFSP2_9.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_9_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_9.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_9_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_9.Reg, volatile.LoadUint32(&o.SFSP2_9.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_9_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_9.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_9_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_9.Reg, volatile.LoadUint32(&o.SFSP2_9.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_9_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_9.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_9_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_9.Reg, volatile.LoadUint32(&o.SFSP2_9.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_9_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_9.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_9_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_9.Reg, volatile.LoadUint32(&o.SFSP2_9.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_9_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_9.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_9.Reg, volatile.LoadUint32(&o.SFSP2_9.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_9.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_10: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_10_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_10.Reg, volatile.LoadUint32(&o.SFSP2_10.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_10_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_10.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_10_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_10.Reg, volatile.LoadUint32(&o.SFSP2_10.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_10_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_10.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_10_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_10.Reg, volatile.LoadUint32(&o.SFSP2_10.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_10_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_10.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_10_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_10.Reg, volatile.LoadUint32(&o.SFSP2_10.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_10_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_10.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_10_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_10.Reg, volatile.LoadUint32(&o.SFSP2_10.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_10_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_10.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_10_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_10.Reg, volatile.LoadUint32(&o.SFSP2_10.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_10_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_10.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_10.Reg, volatile.LoadUint32(&o.SFSP2_10.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_10.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_11: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_11_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_11.Reg, volatile.LoadUint32(&o.SFSP2_11.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_11_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_11.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_11_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_11.Reg, volatile.LoadUint32(&o.SFSP2_11.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_11_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_11.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_11_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_11.Reg, volatile.LoadUint32(&o.SFSP2_11.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_11_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_11.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_11_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_11.Reg, volatile.LoadUint32(&o.SFSP2_11.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_11_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_11.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_11_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_11.Reg, volatile.LoadUint32(&o.SFSP2_11.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_11_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_11.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_11_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_11.Reg, volatile.LoadUint32(&o.SFSP2_11.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_11_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_11.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_11.Reg, volatile.LoadUint32(&o.SFSP2_11.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_11.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP2_12: Pin configuration register for pins P2
func (o *SCU_Type) SetSFSP2_12_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP2_12.Reg, volatile.LoadUint32(&o.SFSP2_12.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP2_12_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP2_12.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP2_12_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP2_12.Reg, volatile.LoadUint32(&o.SFSP2_12.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP2_12_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_12.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP2_12_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP2_12.Reg, volatile.LoadUint32(&o.SFSP2_12.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP2_12_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_12.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP2_12_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP2_12.Reg, volatile.LoadUint32(&o.SFSP2_12.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP2_12_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_12.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP2_12_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP2_12.Reg, volatile.LoadUint32(&o.SFSP2_12.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP2_12_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_12.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP2_12_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP2_12.Reg, volatile.LoadUint32(&o.SFSP2_12.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP2_12_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_12.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP2_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP2_12.Reg, volatile.LoadUint32(&o.SFSP2_12.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP2_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP2_12.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP3_0: Pin configuration register for pins P3
func (o *SCU_Type) SetSFSP3_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP3_0.Reg, volatile.LoadUint32(&o.SFSP3_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP3_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP3_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP3_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP3_0.Reg, volatile.LoadUint32(&o.SFSP3_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP3_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP3_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP3_0.Reg, volatile.LoadUint32(&o.SFSP3_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP3_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP3_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP3_0.Reg, volatile.LoadUint32(&o.SFSP3_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP3_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP3_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP3_0.Reg, volatile.LoadUint32(&o.SFSP3_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP3_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP3_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP3_0.Reg, volatile.LoadUint32(&o.SFSP3_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP3_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP3_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP3_0.Reg, volatile.LoadUint32(&o.SFSP3_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP3_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP3_1: Pin configuration register for pins P3
func (o *SCU_Type) SetSFSP3_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP3_1.Reg, volatile.LoadUint32(&o.SFSP3_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP3_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP3_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP3_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP3_1.Reg, volatile.LoadUint32(&o.SFSP3_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP3_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP3_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP3_1.Reg, volatile.LoadUint32(&o.SFSP3_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP3_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP3_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP3_1.Reg, volatile.LoadUint32(&o.SFSP3_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP3_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP3_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP3_1.Reg, volatile.LoadUint32(&o.SFSP3_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP3_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP3_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP3_1.Reg, volatile.LoadUint32(&o.SFSP3_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP3_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP3_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP3_1.Reg, volatile.LoadUint32(&o.SFSP3_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP3_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP3_2: Pin configuration register for pins P3
func (o *SCU_Type) SetSFSP3_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP3_2.Reg, volatile.LoadUint32(&o.SFSP3_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP3_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP3_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP3_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP3_2.Reg, volatile.LoadUint32(&o.SFSP3_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP3_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP3_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP3_2.Reg, volatile.LoadUint32(&o.SFSP3_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP3_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP3_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP3_2.Reg, volatile.LoadUint32(&o.SFSP3_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP3_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP3_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP3_2.Reg, volatile.LoadUint32(&o.SFSP3_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP3_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP3_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP3_2.Reg, volatile.LoadUint32(&o.SFSP3_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP3_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP3_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP3_2.Reg, volatile.LoadUint32(&o.SFSP3_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP3_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP3_3: Pin configuration register for pins P3
func (o *SCU_Type) SetSFSP3_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP3_3.Reg, volatile.LoadUint32(&o.SFSP3_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP3_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP3_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP3_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP3_3.Reg, volatile.LoadUint32(&o.SFSP3_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP3_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP3_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP3_3.Reg, volatile.LoadUint32(&o.SFSP3_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP3_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP3_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP3_3.Reg, volatile.LoadUint32(&o.SFSP3_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP3_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP3_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP3_3.Reg, volatile.LoadUint32(&o.SFSP3_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP3_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP3_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP3_3.Reg, volatile.LoadUint32(&o.SFSP3_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP3_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP3_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP3_3.Reg, volatile.LoadUint32(&o.SFSP3_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP3_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP3_4: Pin configuration register for pins P3
func (o *SCU_Type) SetSFSP3_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP3_4.Reg, volatile.LoadUint32(&o.SFSP3_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP3_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP3_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP3_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP3_4.Reg, volatile.LoadUint32(&o.SFSP3_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP3_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP3_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP3_4.Reg, volatile.LoadUint32(&o.SFSP3_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP3_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP3_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP3_4.Reg, volatile.LoadUint32(&o.SFSP3_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP3_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP3_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP3_4.Reg, volatile.LoadUint32(&o.SFSP3_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP3_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP3_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP3_4.Reg, volatile.LoadUint32(&o.SFSP3_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP3_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP3_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP3_4.Reg, volatile.LoadUint32(&o.SFSP3_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP3_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP3_5: Pin configuration register for pins P3
func (o *SCU_Type) SetSFSP3_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP3_5.Reg, volatile.LoadUint32(&o.SFSP3_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP3_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP3_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP3_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP3_5.Reg, volatile.LoadUint32(&o.SFSP3_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP3_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP3_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP3_5.Reg, volatile.LoadUint32(&o.SFSP3_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP3_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP3_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP3_5.Reg, volatile.LoadUint32(&o.SFSP3_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP3_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP3_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP3_5.Reg, volatile.LoadUint32(&o.SFSP3_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP3_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP3_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP3_5.Reg, volatile.LoadUint32(&o.SFSP3_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP3_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP3_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP3_5.Reg, volatile.LoadUint32(&o.SFSP3_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP3_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP3_6: Pin configuration register for pins P3
func (o *SCU_Type) SetSFSP3_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP3_6.Reg, volatile.LoadUint32(&o.SFSP3_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP3_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP3_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP3_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP3_6.Reg, volatile.LoadUint32(&o.SFSP3_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP3_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP3_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP3_6.Reg, volatile.LoadUint32(&o.SFSP3_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP3_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP3_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP3_6.Reg, volatile.LoadUint32(&o.SFSP3_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP3_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP3_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP3_6.Reg, volatile.LoadUint32(&o.SFSP3_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP3_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP3_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP3_6.Reg, volatile.LoadUint32(&o.SFSP3_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP3_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP3_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP3_6.Reg, volatile.LoadUint32(&o.SFSP3_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP3_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP3_7: Pin configuration register for pins P3
func (o *SCU_Type) SetSFSP3_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP3_7.Reg, volatile.LoadUint32(&o.SFSP3_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP3_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP3_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP3_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP3_7.Reg, volatile.LoadUint32(&o.SFSP3_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP3_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP3_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP3_7.Reg, volatile.LoadUint32(&o.SFSP3_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP3_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP3_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP3_7.Reg, volatile.LoadUint32(&o.SFSP3_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP3_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP3_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP3_7.Reg, volatile.LoadUint32(&o.SFSP3_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP3_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP3_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP3_7.Reg, volatile.LoadUint32(&o.SFSP3_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP3_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP3_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP3_7.Reg, volatile.LoadUint32(&o.SFSP3_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP3_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP3_8: Pin configuration register for pins P3
func (o *SCU_Type) SetSFSP3_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP3_8.Reg, volatile.LoadUint32(&o.SFSP3_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP3_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP3_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP3_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP3_8.Reg, volatile.LoadUint32(&o.SFSP3_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP3_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP3_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP3_8.Reg, volatile.LoadUint32(&o.SFSP3_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP3_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP3_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP3_8.Reg, volatile.LoadUint32(&o.SFSP3_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP3_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP3_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP3_8.Reg, volatile.LoadUint32(&o.SFSP3_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP3_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP3_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP3_8.Reg, volatile.LoadUint32(&o.SFSP3_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP3_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP3_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP3_8.Reg, volatile.LoadUint32(&o.SFSP3_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP3_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP3_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_0: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_0.Reg, volatile.LoadUint32(&o.SFSP4_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_0.Reg, volatile.LoadUint32(&o.SFSP4_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_0.Reg, volatile.LoadUint32(&o.SFSP4_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_0.Reg, volatile.LoadUint32(&o.SFSP4_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_0.Reg, volatile.LoadUint32(&o.SFSP4_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_0.Reg, volatile.LoadUint32(&o.SFSP4_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_0.Reg, volatile.LoadUint32(&o.SFSP4_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_1: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_1.Reg, volatile.LoadUint32(&o.SFSP4_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_1.Reg, volatile.LoadUint32(&o.SFSP4_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_1.Reg, volatile.LoadUint32(&o.SFSP4_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_1.Reg, volatile.LoadUint32(&o.SFSP4_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_1.Reg, volatile.LoadUint32(&o.SFSP4_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_1.Reg, volatile.LoadUint32(&o.SFSP4_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_1.Reg, volatile.LoadUint32(&o.SFSP4_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_2: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_2.Reg, volatile.LoadUint32(&o.SFSP4_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_2.Reg, volatile.LoadUint32(&o.SFSP4_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_2.Reg, volatile.LoadUint32(&o.SFSP4_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_2.Reg, volatile.LoadUint32(&o.SFSP4_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_2.Reg, volatile.LoadUint32(&o.SFSP4_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_2.Reg, volatile.LoadUint32(&o.SFSP4_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_2.Reg, volatile.LoadUint32(&o.SFSP4_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_3: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_3.Reg, volatile.LoadUint32(&o.SFSP4_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_3.Reg, volatile.LoadUint32(&o.SFSP4_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_3.Reg, volatile.LoadUint32(&o.SFSP4_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_3.Reg, volatile.LoadUint32(&o.SFSP4_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_3.Reg, volatile.LoadUint32(&o.SFSP4_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_3.Reg, volatile.LoadUint32(&o.SFSP4_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_3.Reg, volatile.LoadUint32(&o.SFSP4_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_4: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_4.Reg, volatile.LoadUint32(&o.SFSP4_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_4.Reg, volatile.LoadUint32(&o.SFSP4_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_4.Reg, volatile.LoadUint32(&o.SFSP4_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_4.Reg, volatile.LoadUint32(&o.SFSP4_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_4.Reg, volatile.LoadUint32(&o.SFSP4_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_4.Reg, volatile.LoadUint32(&o.SFSP4_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_4.Reg, volatile.LoadUint32(&o.SFSP4_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_5: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_5.Reg, volatile.LoadUint32(&o.SFSP4_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_5.Reg, volatile.LoadUint32(&o.SFSP4_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_5.Reg, volatile.LoadUint32(&o.SFSP4_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_5.Reg, volatile.LoadUint32(&o.SFSP4_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_5.Reg, volatile.LoadUint32(&o.SFSP4_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_5.Reg, volatile.LoadUint32(&o.SFSP4_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_5.Reg, volatile.LoadUint32(&o.SFSP4_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_6: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_6.Reg, volatile.LoadUint32(&o.SFSP4_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_6.Reg, volatile.LoadUint32(&o.SFSP4_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_6.Reg, volatile.LoadUint32(&o.SFSP4_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_6.Reg, volatile.LoadUint32(&o.SFSP4_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_6.Reg, volatile.LoadUint32(&o.SFSP4_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_6.Reg, volatile.LoadUint32(&o.SFSP4_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_6.Reg, volatile.LoadUint32(&o.SFSP4_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_7: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_7.Reg, volatile.LoadUint32(&o.SFSP4_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_7.Reg, volatile.LoadUint32(&o.SFSP4_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_7.Reg, volatile.LoadUint32(&o.SFSP4_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_7.Reg, volatile.LoadUint32(&o.SFSP4_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_7.Reg, volatile.LoadUint32(&o.SFSP4_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_7.Reg, volatile.LoadUint32(&o.SFSP4_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_7.Reg, volatile.LoadUint32(&o.SFSP4_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_8: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_8.Reg, volatile.LoadUint32(&o.SFSP4_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_8.Reg, volatile.LoadUint32(&o.SFSP4_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_8.Reg, volatile.LoadUint32(&o.SFSP4_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_8.Reg, volatile.LoadUint32(&o.SFSP4_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_8.Reg, volatile.LoadUint32(&o.SFSP4_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_8.Reg, volatile.LoadUint32(&o.SFSP4_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_8.Reg, volatile.LoadUint32(&o.SFSP4_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_9: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_9_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_9.Reg, volatile.LoadUint32(&o.SFSP4_9.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_9_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_9.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_9_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_9.Reg, volatile.LoadUint32(&o.SFSP4_9.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_9_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_9.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_9_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_9.Reg, volatile.LoadUint32(&o.SFSP4_9.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_9_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_9.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_9_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_9.Reg, volatile.LoadUint32(&o.SFSP4_9.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_9_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_9.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_9_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_9.Reg, volatile.LoadUint32(&o.SFSP4_9.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_9_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_9.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_9_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_9.Reg, volatile.LoadUint32(&o.SFSP4_9.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_9_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_9.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_9.Reg, volatile.LoadUint32(&o.SFSP4_9.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_9.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP4_10: Pin configuration register for pins P4
func (o *SCU_Type) SetSFSP4_10_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP4_10.Reg, volatile.LoadUint32(&o.SFSP4_10.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP4_10_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP4_10.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP4_10_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP4_10.Reg, volatile.LoadUint32(&o.SFSP4_10.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP4_10_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_10.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP4_10_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP4_10.Reg, volatile.LoadUint32(&o.SFSP4_10.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP4_10_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_10.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP4_10_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP4_10.Reg, volatile.LoadUint32(&o.SFSP4_10.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP4_10_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_10.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP4_10_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP4_10.Reg, volatile.LoadUint32(&o.SFSP4_10.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP4_10_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_10.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP4_10_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP4_10.Reg, volatile.LoadUint32(&o.SFSP4_10.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP4_10_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_10.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP4_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP4_10.Reg, volatile.LoadUint32(&o.SFSP4_10.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP4_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP4_10.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP5_0: Pin configuration register for pins P5
func (o *SCU_Type) SetSFSP5_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP5_0.Reg, volatile.LoadUint32(&o.SFSP5_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP5_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP5_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP5_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP5_0.Reg, volatile.LoadUint32(&o.SFSP5_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP5_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP5_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP5_0.Reg, volatile.LoadUint32(&o.SFSP5_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP5_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP5_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP5_0.Reg, volatile.LoadUint32(&o.SFSP5_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP5_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP5_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP5_0.Reg, volatile.LoadUint32(&o.SFSP5_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP5_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP5_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP5_0.Reg, volatile.LoadUint32(&o.SFSP5_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP5_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP5_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP5_0.Reg, volatile.LoadUint32(&o.SFSP5_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP5_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP5_1: Pin configuration register for pins P5
func (o *SCU_Type) SetSFSP5_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP5_1.Reg, volatile.LoadUint32(&o.SFSP5_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP5_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP5_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP5_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP5_1.Reg, volatile.LoadUint32(&o.SFSP5_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP5_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP5_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP5_1.Reg, volatile.LoadUint32(&o.SFSP5_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP5_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP5_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP5_1.Reg, volatile.LoadUint32(&o.SFSP5_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP5_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP5_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP5_1.Reg, volatile.LoadUint32(&o.SFSP5_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP5_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP5_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP5_1.Reg, volatile.LoadUint32(&o.SFSP5_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP5_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP5_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP5_1.Reg, volatile.LoadUint32(&o.SFSP5_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP5_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP5_2: Pin configuration register for pins P5
func (o *SCU_Type) SetSFSP5_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP5_2.Reg, volatile.LoadUint32(&o.SFSP5_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP5_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP5_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP5_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP5_2.Reg, volatile.LoadUint32(&o.SFSP5_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP5_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP5_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP5_2.Reg, volatile.LoadUint32(&o.SFSP5_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP5_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP5_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP5_2.Reg, volatile.LoadUint32(&o.SFSP5_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP5_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP5_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP5_2.Reg, volatile.LoadUint32(&o.SFSP5_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP5_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP5_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP5_2.Reg, volatile.LoadUint32(&o.SFSP5_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP5_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP5_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP5_2.Reg, volatile.LoadUint32(&o.SFSP5_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP5_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP5_3: Pin configuration register for pins P5
func (o *SCU_Type) SetSFSP5_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP5_3.Reg, volatile.LoadUint32(&o.SFSP5_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP5_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP5_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP5_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP5_3.Reg, volatile.LoadUint32(&o.SFSP5_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP5_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP5_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP5_3.Reg, volatile.LoadUint32(&o.SFSP5_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP5_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP5_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP5_3.Reg, volatile.LoadUint32(&o.SFSP5_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP5_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP5_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP5_3.Reg, volatile.LoadUint32(&o.SFSP5_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP5_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP5_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP5_3.Reg, volatile.LoadUint32(&o.SFSP5_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP5_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP5_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP5_3.Reg, volatile.LoadUint32(&o.SFSP5_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP5_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP5_4: Pin configuration register for pins P5
func (o *SCU_Type) SetSFSP5_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP5_4.Reg, volatile.LoadUint32(&o.SFSP5_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP5_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP5_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP5_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP5_4.Reg, volatile.LoadUint32(&o.SFSP5_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP5_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP5_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP5_4.Reg, volatile.LoadUint32(&o.SFSP5_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP5_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP5_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP5_4.Reg, volatile.LoadUint32(&o.SFSP5_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP5_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP5_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP5_4.Reg, volatile.LoadUint32(&o.SFSP5_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP5_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP5_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP5_4.Reg, volatile.LoadUint32(&o.SFSP5_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP5_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP5_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP5_4.Reg, volatile.LoadUint32(&o.SFSP5_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP5_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP5_5: Pin configuration register for pins P5
func (o *SCU_Type) SetSFSP5_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP5_5.Reg, volatile.LoadUint32(&o.SFSP5_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP5_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP5_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP5_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP5_5.Reg, volatile.LoadUint32(&o.SFSP5_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP5_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP5_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP5_5.Reg, volatile.LoadUint32(&o.SFSP5_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP5_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP5_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP5_5.Reg, volatile.LoadUint32(&o.SFSP5_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP5_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP5_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP5_5.Reg, volatile.LoadUint32(&o.SFSP5_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP5_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP5_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP5_5.Reg, volatile.LoadUint32(&o.SFSP5_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP5_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP5_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP5_5.Reg, volatile.LoadUint32(&o.SFSP5_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP5_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP5_6: Pin configuration register for pins P5
func (o *SCU_Type) SetSFSP5_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP5_6.Reg, volatile.LoadUint32(&o.SFSP5_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP5_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP5_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP5_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP5_6.Reg, volatile.LoadUint32(&o.SFSP5_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP5_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP5_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP5_6.Reg, volatile.LoadUint32(&o.SFSP5_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP5_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP5_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP5_6.Reg, volatile.LoadUint32(&o.SFSP5_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP5_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP5_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP5_6.Reg, volatile.LoadUint32(&o.SFSP5_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP5_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP5_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP5_6.Reg, volatile.LoadUint32(&o.SFSP5_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP5_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP5_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP5_6.Reg, volatile.LoadUint32(&o.SFSP5_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP5_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP5_7: Pin configuration register for pins P5
func (o *SCU_Type) SetSFSP5_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP5_7.Reg, volatile.LoadUint32(&o.SFSP5_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP5_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP5_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP5_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP5_7.Reg, volatile.LoadUint32(&o.SFSP5_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP5_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP5_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP5_7.Reg, volatile.LoadUint32(&o.SFSP5_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP5_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP5_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP5_7.Reg, volatile.LoadUint32(&o.SFSP5_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP5_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP5_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP5_7.Reg, volatile.LoadUint32(&o.SFSP5_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP5_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP5_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP5_7.Reg, volatile.LoadUint32(&o.SFSP5_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP5_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP5_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP5_7.Reg, volatile.LoadUint32(&o.SFSP5_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP5_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP5_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_0: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_0.Reg, volatile.LoadUint32(&o.SFSP6_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_0.Reg, volatile.LoadUint32(&o.SFSP6_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_0.Reg, volatile.LoadUint32(&o.SFSP6_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_0.Reg, volatile.LoadUint32(&o.SFSP6_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_0.Reg, volatile.LoadUint32(&o.SFSP6_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_0.Reg, volatile.LoadUint32(&o.SFSP6_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_0.Reg, volatile.LoadUint32(&o.SFSP6_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_1: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_1.Reg, volatile.LoadUint32(&o.SFSP6_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_1.Reg, volatile.LoadUint32(&o.SFSP6_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_1.Reg, volatile.LoadUint32(&o.SFSP6_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_1.Reg, volatile.LoadUint32(&o.SFSP6_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_1.Reg, volatile.LoadUint32(&o.SFSP6_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_1.Reg, volatile.LoadUint32(&o.SFSP6_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_1.Reg, volatile.LoadUint32(&o.SFSP6_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_2: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_2.Reg, volatile.LoadUint32(&o.SFSP6_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_2.Reg, volatile.LoadUint32(&o.SFSP6_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_2.Reg, volatile.LoadUint32(&o.SFSP6_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_2.Reg, volatile.LoadUint32(&o.SFSP6_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_2.Reg, volatile.LoadUint32(&o.SFSP6_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_2.Reg, volatile.LoadUint32(&o.SFSP6_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_2.Reg, volatile.LoadUint32(&o.SFSP6_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_3: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_3.Reg, volatile.LoadUint32(&o.SFSP6_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_3.Reg, volatile.LoadUint32(&o.SFSP6_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_3.Reg, volatile.LoadUint32(&o.SFSP6_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_3.Reg, volatile.LoadUint32(&o.SFSP6_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_3.Reg, volatile.LoadUint32(&o.SFSP6_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_3.Reg, volatile.LoadUint32(&o.SFSP6_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_3.Reg, volatile.LoadUint32(&o.SFSP6_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_4: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_4.Reg, volatile.LoadUint32(&o.SFSP6_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_4.Reg, volatile.LoadUint32(&o.SFSP6_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_4.Reg, volatile.LoadUint32(&o.SFSP6_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_4.Reg, volatile.LoadUint32(&o.SFSP6_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_4.Reg, volatile.LoadUint32(&o.SFSP6_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_4.Reg, volatile.LoadUint32(&o.SFSP6_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_4.Reg, volatile.LoadUint32(&o.SFSP6_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_5: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_5.Reg, volatile.LoadUint32(&o.SFSP6_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_5.Reg, volatile.LoadUint32(&o.SFSP6_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_5.Reg, volatile.LoadUint32(&o.SFSP6_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_5.Reg, volatile.LoadUint32(&o.SFSP6_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_5.Reg, volatile.LoadUint32(&o.SFSP6_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_5.Reg, volatile.LoadUint32(&o.SFSP6_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_5.Reg, volatile.LoadUint32(&o.SFSP6_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_6: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_6.Reg, volatile.LoadUint32(&o.SFSP6_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_6.Reg, volatile.LoadUint32(&o.SFSP6_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_6.Reg, volatile.LoadUint32(&o.SFSP6_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_6.Reg, volatile.LoadUint32(&o.SFSP6_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_6.Reg, volatile.LoadUint32(&o.SFSP6_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_6.Reg, volatile.LoadUint32(&o.SFSP6_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_6.Reg, volatile.LoadUint32(&o.SFSP6_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_7: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_7.Reg, volatile.LoadUint32(&o.SFSP6_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_7.Reg, volatile.LoadUint32(&o.SFSP6_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_7.Reg, volatile.LoadUint32(&o.SFSP6_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_7.Reg, volatile.LoadUint32(&o.SFSP6_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_7.Reg, volatile.LoadUint32(&o.SFSP6_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_7.Reg, volatile.LoadUint32(&o.SFSP6_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_7.Reg, volatile.LoadUint32(&o.SFSP6_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_8: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_8.Reg, volatile.LoadUint32(&o.SFSP6_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_8.Reg, volatile.LoadUint32(&o.SFSP6_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_8.Reg, volatile.LoadUint32(&o.SFSP6_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_8.Reg, volatile.LoadUint32(&o.SFSP6_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_8.Reg, volatile.LoadUint32(&o.SFSP6_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_8.Reg, volatile.LoadUint32(&o.SFSP6_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_8.Reg, volatile.LoadUint32(&o.SFSP6_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_9: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_9_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_9.Reg, volatile.LoadUint32(&o.SFSP6_9.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_9_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_9.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_9_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_9.Reg, volatile.LoadUint32(&o.SFSP6_9.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_9_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_9.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_9_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_9.Reg, volatile.LoadUint32(&o.SFSP6_9.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_9_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_9.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_9_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_9.Reg, volatile.LoadUint32(&o.SFSP6_9.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_9_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_9.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_9_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_9.Reg, volatile.LoadUint32(&o.SFSP6_9.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_9_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_9.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_9_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_9.Reg, volatile.LoadUint32(&o.SFSP6_9.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_9_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_9.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_9.Reg, volatile.LoadUint32(&o.SFSP6_9.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_9.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_10: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_10_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_10.Reg, volatile.LoadUint32(&o.SFSP6_10.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_10_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_10.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_10_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_10.Reg, volatile.LoadUint32(&o.SFSP6_10.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_10_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_10.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_10_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_10.Reg, volatile.LoadUint32(&o.SFSP6_10.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_10_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_10.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_10_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_10.Reg, volatile.LoadUint32(&o.SFSP6_10.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_10_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_10.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_10_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_10.Reg, volatile.LoadUint32(&o.SFSP6_10.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_10_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_10.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_10_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_10.Reg, volatile.LoadUint32(&o.SFSP6_10.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_10_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_10.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_10.Reg, volatile.LoadUint32(&o.SFSP6_10.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_10.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_11: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_11_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_11.Reg, volatile.LoadUint32(&o.SFSP6_11.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_11_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_11.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_11_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_11.Reg, volatile.LoadUint32(&o.SFSP6_11.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_11_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_11.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_11_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_11.Reg, volatile.LoadUint32(&o.SFSP6_11.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_11_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_11.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_11_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_11.Reg, volatile.LoadUint32(&o.SFSP6_11.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_11_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_11.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_11_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_11.Reg, volatile.LoadUint32(&o.SFSP6_11.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_11_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_11.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_11_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_11.Reg, volatile.LoadUint32(&o.SFSP6_11.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_11_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_11.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_11.Reg, volatile.LoadUint32(&o.SFSP6_11.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_11.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP6_12: Pin configuration register for pins P6
func (o *SCU_Type) SetSFSP6_12_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP6_12.Reg, volatile.LoadUint32(&o.SFSP6_12.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP6_12_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP6_12.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP6_12_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP6_12.Reg, volatile.LoadUint32(&o.SFSP6_12.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP6_12_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_12.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP6_12_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP6_12.Reg, volatile.LoadUint32(&o.SFSP6_12.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP6_12_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_12.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP6_12_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP6_12.Reg, volatile.LoadUint32(&o.SFSP6_12.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP6_12_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_12.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP6_12_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP6_12.Reg, volatile.LoadUint32(&o.SFSP6_12.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP6_12_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_12.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP6_12_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP6_12.Reg, volatile.LoadUint32(&o.SFSP6_12.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP6_12_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_12.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP6_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP6_12.Reg, volatile.LoadUint32(&o.SFSP6_12.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP6_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP6_12.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP7_0: Pin configuration register for pins P7
func (o *SCU_Type) SetSFSP7_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP7_0.Reg, volatile.LoadUint32(&o.SFSP7_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP7_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP7_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP7_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP7_0.Reg, volatile.LoadUint32(&o.SFSP7_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP7_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP7_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP7_0.Reg, volatile.LoadUint32(&o.SFSP7_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP7_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP7_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP7_0.Reg, volatile.LoadUint32(&o.SFSP7_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP7_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP7_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP7_0.Reg, volatile.LoadUint32(&o.SFSP7_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP7_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP7_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP7_0.Reg, volatile.LoadUint32(&o.SFSP7_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP7_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP7_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP7_0.Reg, volatile.LoadUint32(&o.SFSP7_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP7_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP7_1: Pin configuration register for pins P7
func (o *SCU_Type) SetSFSP7_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP7_1.Reg, volatile.LoadUint32(&o.SFSP7_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP7_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP7_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP7_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP7_1.Reg, volatile.LoadUint32(&o.SFSP7_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP7_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP7_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP7_1.Reg, volatile.LoadUint32(&o.SFSP7_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP7_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP7_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP7_1.Reg, volatile.LoadUint32(&o.SFSP7_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP7_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP7_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP7_1.Reg, volatile.LoadUint32(&o.SFSP7_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP7_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP7_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP7_1.Reg, volatile.LoadUint32(&o.SFSP7_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP7_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP7_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP7_1.Reg, volatile.LoadUint32(&o.SFSP7_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP7_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP7_2: Pin configuration register for pins P7
func (o *SCU_Type) SetSFSP7_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP7_2.Reg, volatile.LoadUint32(&o.SFSP7_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP7_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP7_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP7_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP7_2.Reg, volatile.LoadUint32(&o.SFSP7_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP7_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP7_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP7_2.Reg, volatile.LoadUint32(&o.SFSP7_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP7_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP7_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP7_2.Reg, volatile.LoadUint32(&o.SFSP7_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP7_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP7_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP7_2.Reg, volatile.LoadUint32(&o.SFSP7_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP7_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP7_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP7_2.Reg, volatile.LoadUint32(&o.SFSP7_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP7_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP7_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP7_2.Reg, volatile.LoadUint32(&o.SFSP7_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP7_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP7_3: Pin configuration register for pins P7
func (o *SCU_Type) SetSFSP7_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP7_3.Reg, volatile.LoadUint32(&o.SFSP7_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP7_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP7_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP7_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP7_3.Reg, volatile.LoadUint32(&o.SFSP7_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP7_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP7_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP7_3.Reg, volatile.LoadUint32(&o.SFSP7_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP7_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP7_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP7_3.Reg, volatile.LoadUint32(&o.SFSP7_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP7_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP7_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP7_3.Reg, volatile.LoadUint32(&o.SFSP7_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP7_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP7_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP7_3.Reg, volatile.LoadUint32(&o.SFSP7_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP7_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP7_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP7_3.Reg, volatile.LoadUint32(&o.SFSP7_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP7_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP7_4: Pin configuration register for pins P7
func (o *SCU_Type) SetSFSP7_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP7_4.Reg, volatile.LoadUint32(&o.SFSP7_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP7_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP7_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP7_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP7_4.Reg, volatile.LoadUint32(&o.SFSP7_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP7_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP7_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP7_4.Reg, volatile.LoadUint32(&o.SFSP7_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP7_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP7_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP7_4.Reg, volatile.LoadUint32(&o.SFSP7_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP7_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP7_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP7_4.Reg, volatile.LoadUint32(&o.SFSP7_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP7_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP7_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP7_4.Reg, volatile.LoadUint32(&o.SFSP7_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP7_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP7_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP7_4.Reg, volatile.LoadUint32(&o.SFSP7_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP7_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP7_5: Pin configuration register for pins P7
func (o *SCU_Type) SetSFSP7_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP7_5.Reg, volatile.LoadUint32(&o.SFSP7_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP7_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP7_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP7_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP7_5.Reg, volatile.LoadUint32(&o.SFSP7_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP7_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP7_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP7_5.Reg, volatile.LoadUint32(&o.SFSP7_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP7_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP7_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP7_5.Reg, volatile.LoadUint32(&o.SFSP7_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP7_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP7_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP7_5.Reg, volatile.LoadUint32(&o.SFSP7_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP7_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP7_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP7_5.Reg, volatile.LoadUint32(&o.SFSP7_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP7_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP7_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP7_5.Reg, volatile.LoadUint32(&o.SFSP7_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP7_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP7_6: Pin configuration register for pins P7
func (o *SCU_Type) SetSFSP7_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP7_6.Reg, volatile.LoadUint32(&o.SFSP7_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP7_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP7_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP7_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP7_6.Reg, volatile.LoadUint32(&o.SFSP7_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP7_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP7_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP7_6.Reg, volatile.LoadUint32(&o.SFSP7_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP7_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP7_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP7_6.Reg, volatile.LoadUint32(&o.SFSP7_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP7_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP7_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP7_6.Reg, volatile.LoadUint32(&o.SFSP7_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP7_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP7_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP7_6.Reg, volatile.LoadUint32(&o.SFSP7_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP7_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP7_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP7_6.Reg, volatile.LoadUint32(&o.SFSP7_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP7_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP7_7: Pin configuration register for pins P7
func (o *SCU_Type) SetSFSP7_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP7_7.Reg, volatile.LoadUint32(&o.SFSP7_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP7_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP7_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP7_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP7_7.Reg, volatile.LoadUint32(&o.SFSP7_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP7_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP7_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP7_7.Reg, volatile.LoadUint32(&o.SFSP7_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP7_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP7_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP7_7.Reg, volatile.LoadUint32(&o.SFSP7_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP7_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP7_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP7_7.Reg, volatile.LoadUint32(&o.SFSP7_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP7_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP7_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP7_7.Reg, volatile.LoadUint32(&o.SFSP7_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP7_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP7_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP7_7.Reg, volatile.LoadUint32(&o.SFSP7_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP7_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP7_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP8_0: Pin configuration register for pins P8
func (o *SCU_Type) SetSFSP8_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP8_0.Reg, volatile.LoadUint32(&o.SFSP8_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP8_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP8_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP8_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP8_0.Reg, volatile.LoadUint32(&o.SFSP8_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP8_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP8_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP8_0.Reg, volatile.LoadUint32(&o.SFSP8_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP8_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP8_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP8_0.Reg, volatile.LoadUint32(&o.SFSP8_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP8_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP8_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP8_0.Reg, volatile.LoadUint32(&o.SFSP8_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP8_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP8_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP8_0.Reg, volatile.LoadUint32(&o.SFSP8_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP8_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP8_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP8_0.Reg, volatile.LoadUint32(&o.SFSP8_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP8_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP8_1: Pin configuration register for pins P8
func (o *SCU_Type) SetSFSP8_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP8_1.Reg, volatile.LoadUint32(&o.SFSP8_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP8_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP8_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP8_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP8_1.Reg, volatile.LoadUint32(&o.SFSP8_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP8_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP8_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP8_1.Reg, volatile.LoadUint32(&o.SFSP8_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP8_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP8_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP8_1.Reg, volatile.LoadUint32(&o.SFSP8_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP8_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP8_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP8_1.Reg, volatile.LoadUint32(&o.SFSP8_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP8_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP8_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP8_1.Reg, volatile.LoadUint32(&o.SFSP8_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP8_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP8_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP8_1.Reg, volatile.LoadUint32(&o.SFSP8_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP8_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP8_2: Pin configuration register for pins P8
func (o *SCU_Type) SetSFSP8_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP8_2.Reg, volatile.LoadUint32(&o.SFSP8_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP8_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP8_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP8_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP8_2.Reg, volatile.LoadUint32(&o.SFSP8_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP8_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP8_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP8_2.Reg, volatile.LoadUint32(&o.SFSP8_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP8_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP8_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP8_2.Reg, volatile.LoadUint32(&o.SFSP8_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP8_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP8_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP8_2.Reg, volatile.LoadUint32(&o.SFSP8_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP8_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP8_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP8_2.Reg, volatile.LoadUint32(&o.SFSP8_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP8_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP8_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP8_2.Reg, volatile.LoadUint32(&o.SFSP8_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP8_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP8_3: Pin configuration register for pins P8
func (o *SCU_Type) SetSFSP8_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP8_3.Reg, volatile.LoadUint32(&o.SFSP8_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP8_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP8_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP8_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP8_3.Reg, volatile.LoadUint32(&o.SFSP8_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP8_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP8_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP8_3.Reg, volatile.LoadUint32(&o.SFSP8_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP8_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP8_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP8_3.Reg, volatile.LoadUint32(&o.SFSP8_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP8_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP8_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP8_3.Reg, volatile.LoadUint32(&o.SFSP8_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP8_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP8_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP8_3.Reg, volatile.LoadUint32(&o.SFSP8_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP8_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP8_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP8_3.Reg, volatile.LoadUint32(&o.SFSP8_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP8_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP8_4: Pin configuration register for pins P8
func (o *SCU_Type) SetSFSP8_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP8_4.Reg, volatile.LoadUint32(&o.SFSP8_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP8_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP8_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP8_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP8_4.Reg, volatile.LoadUint32(&o.SFSP8_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP8_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP8_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP8_4.Reg, volatile.LoadUint32(&o.SFSP8_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP8_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP8_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP8_4.Reg, volatile.LoadUint32(&o.SFSP8_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP8_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP8_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP8_4.Reg, volatile.LoadUint32(&o.SFSP8_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP8_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP8_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP8_4.Reg, volatile.LoadUint32(&o.SFSP8_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP8_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP8_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP8_4.Reg, volatile.LoadUint32(&o.SFSP8_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP8_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP8_5: Pin configuration register for pins P8
func (o *SCU_Type) SetSFSP8_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP8_5.Reg, volatile.LoadUint32(&o.SFSP8_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP8_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP8_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP8_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP8_5.Reg, volatile.LoadUint32(&o.SFSP8_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP8_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP8_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP8_5.Reg, volatile.LoadUint32(&o.SFSP8_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP8_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP8_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP8_5.Reg, volatile.LoadUint32(&o.SFSP8_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP8_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP8_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP8_5.Reg, volatile.LoadUint32(&o.SFSP8_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP8_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP8_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP8_5.Reg, volatile.LoadUint32(&o.SFSP8_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP8_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP8_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP8_5.Reg, volatile.LoadUint32(&o.SFSP8_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP8_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP8_6: Pin configuration register for pins P8
func (o *SCU_Type) SetSFSP8_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP8_6.Reg, volatile.LoadUint32(&o.SFSP8_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP8_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP8_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP8_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP8_6.Reg, volatile.LoadUint32(&o.SFSP8_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP8_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP8_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP8_6.Reg, volatile.LoadUint32(&o.SFSP8_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP8_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP8_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP8_6.Reg, volatile.LoadUint32(&o.SFSP8_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP8_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP8_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP8_6.Reg, volatile.LoadUint32(&o.SFSP8_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP8_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP8_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP8_6.Reg, volatile.LoadUint32(&o.SFSP8_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP8_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP8_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP8_6.Reg, volatile.LoadUint32(&o.SFSP8_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP8_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP8_7: Pin configuration register for pins P8
func (o *SCU_Type) SetSFSP8_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP8_7.Reg, volatile.LoadUint32(&o.SFSP8_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP8_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP8_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP8_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP8_7.Reg, volatile.LoadUint32(&o.SFSP8_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP8_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP8_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP8_7.Reg, volatile.LoadUint32(&o.SFSP8_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP8_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP8_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP8_7.Reg, volatile.LoadUint32(&o.SFSP8_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP8_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP8_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP8_7.Reg, volatile.LoadUint32(&o.SFSP8_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP8_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP8_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP8_7.Reg, volatile.LoadUint32(&o.SFSP8_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP8_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP8_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP8_7.Reg, volatile.LoadUint32(&o.SFSP8_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP8_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP8_8: Pin configuration register for pins P8
func (o *SCU_Type) SetSFSP8_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP8_8.Reg, volatile.LoadUint32(&o.SFSP8_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP8_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP8_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP8_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP8_8.Reg, volatile.LoadUint32(&o.SFSP8_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP8_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP8_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP8_8.Reg, volatile.LoadUint32(&o.SFSP8_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP8_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP8_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP8_8.Reg, volatile.LoadUint32(&o.SFSP8_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP8_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP8_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP8_8.Reg, volatile.LoadUint32(&o.SFSP8_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP8_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP8_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSP8_8.Reg, volatile.LoadUint32(&o.SFSP8_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP8_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP8_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP8_8.Reg, volatile.LoadUint32(&o.SFSP8_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSP8_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP8_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSP9_0: Pin configuration register for pins P9
func (o *SCU_Type) SetSFSP9_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP9_0.Reg, volatile.LoadUint32(&o.SFSP9_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP9_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP9_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP9_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_0.Reg, volatile.LoadUint32(&o.SFSP9_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP9_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP9_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP9_0.Reg, volatile.LoadUint32(&o.SFSP9_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP9_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP9_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP9_0.Reg, volatile.LoadUint32(&o.SFSP9_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP9_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP9_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP9_0.Reg, volatile.LoadUint32(&o.SFSP9_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP9_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP9_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_0.Reg, volatile.LoadUint32(&o.SFSP9_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP9_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP9_0_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_0.Reg, volatile.LoadUint32(&o.SFSP9_0.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP9_0_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_0.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP9_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_0.Reg, volatile.LoadUint32(&o.SFSP9_0.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP9_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_0.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP9_1: Pin configuration register for pins P9
func (o *SCU_Type) SetSFSP9_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP9_1.Reg, volatile.LoadUint32(&o.SFSP9_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP9_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP9_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP9_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_1.Reg, volatile.LoadUint32(&o.SFSP9_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP9_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP9_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP9_1.Reg, volatile.LoadUint32(&o.SFSP9_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP9_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP9_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP9_1.Reg, volatile.LoadUint32(&o.SFSP9_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP9_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP9_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP9_1.Reg, volatile.LoadUint32(&o.SFSP9_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP9_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP9_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_1.Reg, volatile.LoadUint32(&o.SFSP9_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP9_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP9_1_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_1.Reg, volatile.LoadUint32(&o.SFSP9_1.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP9_1_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_1.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP9_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_1.Reg, volatile.LoadUint32(&o.SFSP9_1.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP9_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_1.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP9_2: Pin configuration register for pins P9
func (o *SCU_Type) SetSFSP9_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP9_2.Reg, volatile.LoadUint32(&o.SFSP9_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP9_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP9_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP9_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_2.Reg, volatile.LoadUint32(&o.SFSP9_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP9_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP9_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP9_2.Reg, volatile.LoadUint32(&o.SFSP9_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP9_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP9_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP9_2.Reg, volatile.LoadUint32(&o.SFSP9_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP9_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP9_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP9_2.Reg, volatile.LoadUint32(&o.SFSP9_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP9_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP9_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_2.Reg, volatile.LoadUint32(&o.SFSP9_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP9_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP9_2_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_2.Reg, volatile.LoadUint32(&o.SFSP9_2.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP9_2_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_2.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP9_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_2.Reg, volatile.LoadUint32(&o.SFSP9_2.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP9_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_2.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP9_3: Pin configuration register for pins P9
func (o *SCU_Type) SetSFSP9_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP9_3.Reg, volatile.LoadUint32(&o.SFSP9_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP9_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP9_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP9_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_3.Reg, volatile.LoadUint32(&o.SFSP9_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP9_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP9_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP9_3.Reg, volatile.LoadUint32(&o.SFSP9_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP9_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP9_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP9_3.Reg, volatile.LoadUint32(&o.SFSP9_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP9_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP9_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP9_3.Reg, volatile.LoadUint32(&o.SFSP9_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP9_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP9_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_3.Reg, volatile.LoadUint32(&o.SFSP9_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP9_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP9_3_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_3.Reg, volatile.LoadUint32(&o.SFSP9_3.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP9_3_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_3.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP9_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_3.Reg, volatile.LoadUint32(&o.SFSP9_3.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP9_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_3.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP9_4: Pin configuration register for pins P9
func (o *SCU_Type) SetSFSP9_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP9_4.Reg, volatile.LoadUint32(&o.SFSP9_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP9_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP9_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP9_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_4.Reg, volatile.LoadUint32(&o.SFSP9_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP9_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP9_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP9_4.Reg, volatile.LoadUint32(&o.SFSP9_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP9_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP9_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP9_4.Reg, volatile.LoadUint32(&o.SFSP9_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP9_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP9_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP9_4.Reg, volatile.LoadUint32(&o.SFSP9_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP9_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP9_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_4.Reg, volatile.LoadUint32(&o.SFSP9_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP9_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP9_4_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_4.Reg, volatile.LoadUint32(&o.SFSP9_4.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP9_4_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_4.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP9_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_4.Reg, volatile.LoadUint32(&o.SFSP9_4.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP9_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_4.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP9_5: Pin configuration register for pins P9
func (o *SCU_Type) SetSFSP9_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP9_5.Reg, volatile.LoadUint32(&o.SFSP9_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP9_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP9_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP9_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_5.Reg, volatile.LoadUint32(&o.SFSP9_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP9_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP9_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP9_5.Reg, volatile.LoadUint32(&o.SFSP9_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP9_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP9_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP9_5.Reg, volatile.LoadUint32(&o.SFSP9_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP9_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP9_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP9_5.Reg, volatile.LoadUint32(&o.SFSP9_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP9_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP9_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_5.Reg, volatile.LoadUint32(&o.SFSP9_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP9_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP9_5_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_5.Reg, volatile.LoadUint32(&o.SFSP9_5.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP9_5_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_5.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP9_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_5.Reg, volatile.LoadUint32(&o.SFSP9_5.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP9_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_5.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSP9_6: Pin configuration register for pins P9
func (o *SCU_Type) SetSFSP9_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSP9_6.Reg, volatile.LoadUint32(&o.SFSP9_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSP9_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSP9_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSP9_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_6.Reg, volatile.LoadUint32(&o.SFSP9_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSP9_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSP9_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSP9_6.Reg, volatile.LoadUint32(&o.SFSP9_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSP9_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSP9_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSP9_6.Reg, volatile.LoadUint32(&o.SFSP9_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSP9_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSP9_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSP9_6.Reg, volatile.LoadUint32(&o.SFSP9_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSP9_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSP9_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_6.Reg, volatile.LoadUint32(&o.SFSP9_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSP9_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSP9_6_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSP9_6.Reg, volatile.LoadUint32(&o.SFSP9_6.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSP9_6_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_6.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSP9_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSP9_6.Reg, volatile.LoadUint32(&o.SFSP9_6.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSP9_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSP9_6.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSPA_0: Pin configuration register for pins PA
func (o *SCU_Type) SetSFSPA_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPA_0.Reg, volatile.LoadUint32(&o.SFSPA_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPA_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPA_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPA_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPA_0.Reg, volatile.LoadUint32(&o.SFSPA_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPA_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPA_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPA_0.Reg, volatile.LoadUint32(&o.SFSPA_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPA_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPA_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPA_0.Reg, volatile.LoadUint32(&o.SFSPA_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPA_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPA_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPA_0.Reg, volatile.LoadUint32(&o.SFSPA_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPA_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPA_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPA_0.Reg, volatile.LoadUint32(&o.SFSPA_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPA_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPA_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPA_0.Reg, volatile.LoadUint32(&o.SFSPA_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPA_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPA_1: Pin configuration register for pins PA
func (o *SCU_Type) SetSFSPA_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPA_1.Reg, volatile.LoadUint32(&o.SFSPA_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPA_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPA_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPA_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPA_1.Reg, volatile.LoadUint32(&o.SFSPA_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPA_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPA_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPA_1.Reg, volatile.LoadUint32(&o.SFSPA_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPA_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPA_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPA_1.Reg, volatile.LoadUint32(&o.SFSPA_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPA_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPA_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPA_1.Reg, volatile.LoadUint32(&o.SFSPA_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPA_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPA_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPA_1.Reg, volatile.LoadUint32(&o.SFSPA_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPA_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPA_1_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSPA_1.Reg, volatile.LoadUint32(&o.SFSPA_1.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSPA_1_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_1.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSPA_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPA_1.Reg, volatile.LoadUint32(&o.SFSPA_1.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSPA_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_1.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSPA_2: Pin configuration register for pins PA
func (o *SCU_Type) SetSFSPA_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPA_2.Reg, volatile.LoadUint32(&o.SFSPA_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPA_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPA_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPA_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPA_2.Reg, volatile.LoadUint32(&o.SFSPA_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPA_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPA_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPA_2.Reg, volatile.LoadUint32(&o.SFSPA_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPA_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPA_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPA_2.Reg, volatile.LoadUint32(&o.SFSPA_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPA_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPA_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPA_2.Reg, volatile.LoadUint32(&o.SFSPA_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPA_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPA_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPA_2.Reg, volatile.LoadUint32(&o.SFSPA_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPA_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPA_2_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSPA_2.Reg, volatile.LoadUint32(&o.SFSPA_2.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSPA_2_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_2.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSPA_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPA_2.Reg, volatile.LoadUint32(&o.SFSPA_2.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSPA_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_2.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSPA_3: Pin configuration register for pins PA
func (o *SCU_Type) SetSFSPA_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPA_3.Reg, volatile.LoadUint32(&o.SFSPA_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPA_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPA_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPA_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPA_3.Reg, volatile.LoadUint32(&o.SFSPA_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPA_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPA_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPA_3.Reg, volatile.LoadUint32(&o.SFSPA_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPA_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPA_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPA_3.Reg, volatile.LoadUint32(&o.SFSPA_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPA_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPA_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPA_3.Reg, volatile.LoadUint32(&o.SFSPA_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPA_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPA_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPA_3.Reg, volatile.LoadUint32(&o.SFSPA_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPA_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPA_3_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSPA_3.Reg, volatile.LoadUint32(&o.SFSPA_3.Reg)&^(0x300)|value<<8)
}
func (o *SCU_Type) GetSFSPA_3_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_3.Reg) & 0x300) >> 8
}
func (o *SCU_Type) SetSFSPA_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPA_3.Reg, volatile.LoadUint32(&o.SFSPA_3.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SCU_Type) GetSFSPA_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_3.Reg) & 0xfffffc00) >> 10
}

// SCU.SFSPA_4: Pin configuration register for pins PA
func (o *SCU_Type) SetSFSPA_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPA_4.Reg, volatile.LoadUint32(&o.SFSPA_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPA_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPA_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPA_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPA_4.Reg, volatile.LoadUint32(&o.SFSPA_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPA_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPA_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPA_4.Reg, volatile.LoadUint32(&o.SFSPA_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPA_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPA_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPA_4.Reg, volatile.LoadUint32(&o.SFSPA_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPA_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPA_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPA_4.Reg, volatile.LoadUint32(&o.SFSPA_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPA_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPA_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPA_4.Reg, volatile.LoadUint32(&o.SFSPA_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPA_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPA_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPA_4.Reg, volatile.LoadUint32(&o.SFSPA_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPA_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPA_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPB_0: Pin configuration register for pins PB
func (o *SCU_Type) SetSFSPB_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPB_0.Reg, volatile.LoadUint32(&o.SFSPB_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPB_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPB_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPB_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPB_0.Reg, volatile.LoadUint32(&o.SFSPB_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPB_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPB_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPB_0.Reg, volatile.LoadUint32(&o.SFSPB_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPB_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPB_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPB_0.Reg, volatile.LoadUint32(&o.SFSPB_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPB_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPB_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPB_0.Reg, volatile.LoadUint32(&o.SFSPB_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPB_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPB_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPB_0.Reg, volatile.LoadUint32(&o.SFSPB_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPB_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPB_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPB_0.Reg, volatile.LoadUint32(&o.SFSPB_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPB_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPB_1: Pin configuration register for pins PB
func (o *SCU_Type) SetSFSPB_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPB_1.Reg, volatile.LoadUint32(&o.SFSPB_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPB_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPB_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPB_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPB_1.Reg, volatile.LoadUint32(&o.SFSPB_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPB_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPB_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPB_1.Reg, volatile.LoadUint32(&o.SFSPB_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPB_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPB_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPB_1.Reg, volatile.LoadUint32(&o.SFSPB_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPB_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPB_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPB_1.Reg, volatile.LoadUint32(&o.SFSPB_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPB_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPB_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPB_1.Reg, volatile.LoadUint32(&o.SFSPB_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPB_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPB_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPB_1.Reg, volatile.LoadUint32(&o.SFSPB_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPB_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPB_2: Pin configuration register for pins PB
func (o *SCU_Type) SetSFSPB_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPB_2.Reg, volatile.LoadUint32(&o.SFSPB_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPB_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPB_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPB_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPB_2.Reg, volatile.LoadUint32(&o.SFSPB_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPB_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPB_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPB_2.Reg, volatile.LoadUint32(&o.SFSPB_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPB_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPB_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPB_2.Reg, volatile.LoadUint32(&o.SFSPB_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPB_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPB_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPB_2.Reg, volatile.LoadUint32(&o.SFSPB_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPB_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPB_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPB_2.Reg, volatile.LoadUint32(&o.SFSPB_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPB_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPB_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPB_2.Reg, volatile.LoadUint32(&o.SFSPB_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPB_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPB_3: Pin configuration register for pins PB
func (o *SCU_Type) SetSFSPB_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPB_3.Reg, volatile.LoadUint32(&o.SFSPB_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPB_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPB_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPB_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPB_3.Reg, volatile.LoadUint32(&o.SFSPB_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPB_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPB_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPB_3.Reg, volatile.LoadUint32(&o.SFSPB_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPB_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPB_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPB_3.Reg, volatile.LoadUint32(&o.SFSPB_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPB_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPB_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPB_3.Reg, volatile.LoadUint32(&o.SFSPB_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPB_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPB_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPB_3.Reg, volatile.LoadUint32(&o.SFSPB_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPB_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPB_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPB_3.Reg, volatile.LoadUint32(&o.SFSPB_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPB_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPB_4: Pin configuration register for pins PB
func (o *SCU_Type) SetSFSPB_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPB_4.Reg, volatile.LoadUint32(&o.SFSPB_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPB_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPB_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPB_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPB_4.Reg, volatile.LoadUint32(&o.SFSPB_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPB_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPB_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPB_4.Reg, volatile.LoadUint32(&o.SFSPB_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPB_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPB_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPB_4.Reg, volatile.LoadUint32(&o.SFSPB_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPB_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPB_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPB_4.Reg, volatile.LoadUint32(&o.SFSPB_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPB_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPB_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPB_4.Reg, volatile.LoadUint32(&o.SFSPB_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPB_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPB_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPB_4.Reg, volatile.LoadUint32(&o.SFSPB_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPB_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPB_5: Pin configuration register for pins PB
func (o *SCU_Type) SetSFSPB_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPB_5.Reg, volatile.LoadUint32(&o.SFSPB_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPB_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPB_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPB_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPB_5.Reg, volatile.LoadUint32(&o.SFSPB_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPB_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPB_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPB_5.Reg, volatile.LoadUint32(&o.SFSPB_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPB_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPB_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPB_5.Reg, volatile.LoadUint32(&o.SFSPB_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPB_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPB_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPB_5.Reg, volatile.LoadUint32(&o.SFSPB_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPB_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPB_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPB_5.Reg, volatile.LoadUint32(&o.SFSPB_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPB_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPB_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPB_5.Reg, volatile.LoadUint32(&o.SFSPB_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPB_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPB_6: Pin configuration register for pins PB
func (o *SCU_Type) SetSFSPB_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPB_6.Reg, volatile.LoadUint32(&o.SFSPB_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPB_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPB_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPB_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPB_6.Reg, volatile.LoadUint32(&o.SFSPB_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPB_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPB_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPB_6.Reg, volatile.LoadUint32(&o.SFSPB_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPB_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPB_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPB_6.Reg, volatile.LoadUint32(&o.SFSPB_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPB_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPB_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPB_6.Reg, volatile.LoadUint32(&o.SFSPB_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPB_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPB_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPB_6.Reg, volatile.LoadUint32(&o.SFSPB_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPB_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPB_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPB_6.Reg, volatile.LoadUint32(&o.SFSPB_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPB_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPB_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_0: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_0.Reg, volatile.LoadUint32(&o.SFSPC_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_0.Reg, volatile.LoadUint32(&o.SFSPC_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_0.Reg, volatile.LoadUint32(&o.SFSPC_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_0.Reg, volatile.LoadUint32(&o.SFSPC_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_0.Reg, volatile.LoadUint32(&o.SFSPC_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_0.Reg, volatile.LoadUint32(&o.SFSPC_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_0.Reg, volatile.LoadUint32(&o.SFSPC_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_1: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_1.Reg, volatile.LoadUint32(&o.SFSPC_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_1.Reg, volatile.LoadUint32(&o.SFSPC_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_1.Reg, volatile.LoadUint32(&o.SFSPC_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_1.Reg, volatile.LoadUint32(&o.SFSPC_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_1.Reg, volatile.LoadUint32(&o.SFSPC_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_1.Reg, volatile.LoadUint32(&o.SFSPC_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_1.Reg, volatile.LoadUint32(&o.SFSPC_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_2: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_2.Reg, volatile.LoadUint32(&o.SFSPC_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_2.Reg, volatile.LoadUint32(&o.SFSPC_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_2.Reg, volatile.LoadUint32(&o.SFSPC_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_2.Reg, volatile.LoadUint32(&o.SFSPC_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_2.Reg, volatile.LoadUint32(&o.SFSPC_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_2.Reg, volatile.LoadUint32(&o.SFSPC_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_2.Reg, volatile.LoadUint32(&o.SFSPC_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_3: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_3.Reg, volatile.LoadUint32(&o.SFSPC_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_3.Reg, volatile.LoadUint32(&o.SFSPC_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_3.Reg, volatile.LoadUint32(&o.SFSPC_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_3.Reg, volatile.LoadUint32(&o.SFSPC_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_3.Reg, volatile.LoadUint32(&o.SFSPC_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_3.Reg, volatile.LoadUint32(&o.SFSPC_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_3.Reg, volatile.LoadUint32(&o.SFSPC_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_4: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_4.Reg, volatile.LoadUint32(&o.SFSPC_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_4.Reg, volatile.LoadUint32(&o.SFSPC_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_4.Reg, volatile.LoadUint32(&o.SFSPC_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_4.Reg, volatile.LoadUint32(&o.SFSPC_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_4.Reg, volatile.LoadUint32(&o.SFSPC_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_4.Reg, volatile.LoadUint32(&o.SFSPC_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_4.Reg, volatile.LoadUint32(&o.SFSPC_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_5: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_5.Reg, volatile.LoadUint32(&o.SFSPC_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_5.Reg, volatile.LoadUint32(&o.SFSPC_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_5.Reg, volatile.LoadUint32(&o.SFSPC_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_5.Reg, volatile.LoadUint32(&o.SFSPC_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_5.Reg, volatile.LoadUint32(&o.SFSPC_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_5.Reg, volatile.LoadUint32(&o.SFSPC_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_5.Reg, volatile.LoadUint32(&o.SFSPC_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_6: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_6.Reg, volatile.LoadUint32(&o.SFSPC_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_6.Reg, volatile.LoadUint32(&o.SFSPC_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_6.Reg, volatile.LoadUint32(&o.SFSPC_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_6.Reg, volatile.LoadUint32(&o.SFSPC_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_6.Reg, volatile.LoadUint32(&o.SFSPC_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_6.Reg, volatile.LoadUint32(&o.SFSPC_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_6.Reg, volatile.LoadUint32(&o.SFSPC_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_7: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_7.Reg, volatile.LoadUint32(&o.SFSPC_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_7.Reg, volatile.LoadUint32(&o.SFSPC_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_7.Reg, volatile.LoadUint32(&o.SFSPC_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_7.Reg, volatile.LoadUint32(&o.SFSPC_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_7.Reg, volatile.LoadUint32(&o.SFSPC_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_7.Reg, volatile.LoadUint32(&o.SFSPC_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_7.Reg, volatile.LoadUint32(&o.SFSPC_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_8: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_8.Reg, volatile.LoadUint32(&o.SFSPC_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_8.Reg, volatile.LoadUint32(&o.SFSPC_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_8.Reg, volatile.LoadUint32(&o.SFSPC_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_8.Reg, volatile.LoadUint32(&o.SFSPC_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_8.Reg, volatile.LoadUint32(&o.SFSPC_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_8.Reg, volatile.LoadUint32(&o.SFSPC_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_8.Reg, volatile.LoadUint32(&o.SFSPC_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_9: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_9_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_9.Reg, volatile.LoadUint32(&o.SFSPC_9.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_9_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_9.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_9_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_9.Reg, volatile.LoadUint32(&o.SFSPC_9.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_9_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_9.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_9_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_9.Reg, volatile.LoadUint32(&o.SFSPC_9.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_9_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_9.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_9_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_9.Reg, volatile.LoadUint32(&o.SFSPC_9.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_9_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_9.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_9_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_9.Reg, volatile.LoadUint32(&o.SFSPC_9.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_9_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_9.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_9_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_9.Reg, volatile.LoadUint32(&o.SFSPC_9.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_9_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_9.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_9.Reg, volatile.LoadUint32(&o.SFSPC_9.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_9.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_10: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_10_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_10.Reg, volatile.LoadUint32(&o.SFSPC_10.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_10_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_10.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_10_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_10.Reg, volatile.LoadUint32(&o.SFSPC_10.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_10_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_10.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_10_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_10.Reg, volatile.LoadUint32(&o.SFSPC_10.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_10_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_10.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_10_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_10.Reg, volatile.LoadUint32(&o.SFSPC_10.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_10_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_10.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_10_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_10.Reg, volatile.LoadUint32(&o.SFSPC_10.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_10_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_10.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_10_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_10.Reg, volatile.LoadUint32(&o.SFSPC_10.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_10_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_10.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_10.Reg, volatile.LoadUint32(&o.SFSPC_10.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_10.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_11: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_11_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_11.Reg, volatile.LoadUint32(&o.SFSPC_11.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_11_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_11.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_11_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_11.Reg, volatile.LoadUint32(&o.SFSPC_11.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_11_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_11.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_11_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_11.Reg, volatile.LoadUint32(&o.SFSPC_11.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_11_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_11.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_11_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_11.Reg, volatile.LoadUint32(&o.SFSPC_11.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_11_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_11.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_11_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_11.Reg, volatile.LoadUint32(&o.SFSPC_11.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_11_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_11.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_11_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_11.Reg, volatile.LoadUint32(&o.SFSPC_11.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_11_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_11.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_11.Reg, volatile.LoadUint32(&o.SFSPC_11.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_11.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_12: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_12_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_12.Reg, volatile.LoadUint32(&o.SFSPC_12.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_12_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_12.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_12_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_12.Reg, volatile.LoadUint32(&o.SFSPC_12.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_12_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_12.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_12_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_12.Reg, volatile.LoadUint32(&o.SFSPC_12.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_12_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_12.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_12_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_12.Reg, volatile.LoadUint32(&o.SFSPC_12.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_12_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_12.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_12_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_12.Reg, volatile.LoadUint32(&o.SFSPC_12.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_12_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_12.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_12_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_12.Reg, volatile.LoadUint32(&o.SFSPC_12.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_12_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_12.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_12.Reg, volatile.LoadUint32(&o.SFSPC_12.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_12.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_13: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_13_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_13.Reg, volatile.LoadUint32(&o.SFSPC_13.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_13_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_13.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_13_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_13.Reg, volatile.LoadUint32(&o.SFSPC_13.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_13_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_13.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_13_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_13.Reg, volatile.LoadUint32(&o.SFSPC_13.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_13_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_13.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_13_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_13.Reg, volatile.LoadUint32(&o.SFSPC_13.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_13_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_13.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_13_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_13.Reg, volatile.LoadUint32(&o.SFSPC_13.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_13_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_13.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_13_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_13.Reg, volatile.LoadUint32(&o.SFSPC_13.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_13_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_13.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_13.Reg, volatile.LoadUint32(&o.SFSPC_13.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_13.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPC_14: Pin configuration register for pins PC
func (o *SCU_Type) SetSFSPC_14_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPC_14.Reg, volatile.LoadUint32(&o.SFSPC_14.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPC_14_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPC_14.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPC_14_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPC_14.Reg, volatile.LoadUint32(&o.SFSPC_14.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPC_14_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_14.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPC_14_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPC_14.Reg, volatile.LoadUint32(&o.SFSPC_14.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPC_14_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_14.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPC_14_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPC_14.Reg, volatile.LoadUint32(&o.SFSPC_14.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPC_14_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_14.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPC_14_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPC_14.Reg, volatile.LoadUint32(&o.SFSPC_14.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPC_14_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_14.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPC_14_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPC_14.Reg, volatile.LoadUint32(&o.SFSPC_14.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPC_14_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_14.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPC_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPC_14.Reg, volatile.LoadUint32(&o.SFSPC_14.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPC_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPC_14.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_0: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_0.Reg, volatile.LoadUint32(&o.SFSPD_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_0.Reg, volatile.LoadUint32(&o.SFSPD_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_0.Reg, volatile.LoadUint32(&o.SFSPD_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_0.Reg, volatile.LoadUint32(&o.SFSPD_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_0.Reg, volatile.LoadUint32(&o.SFSPD_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_0.Reg, volatile.LoadUint32(&o.SFSPD_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_0.Reg, volatile.LoadUint32(&o.SFSPD_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_1: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_1.Reg, volatile.LoadUint32(&o.SFSPD_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_1.Reg, volatile.LoadUint32(&o.SFSPD_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_1.Reg, volatile.LoadUint32(&o.SFSPD_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_1.Reg, volatile.LoadUint32(&o.SFSPD_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_1.Reg, volatile.LoadUint32(&o.SFSPD_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_1.Reg, volatile.LoadUint32(&o.SFSPD_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_1.Reg, volatile.LoadUint32(&o.SFSPD_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_2: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_2.Reg, volatile.LoadUint32(&o.SFSPD_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_2.Reg, volatile.LoadUint32(&o.SFSPD_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_2.Reg, volatile.LoadUint32(&o.SFSPD_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_2.Reg, volatile.LoadUint32(&o.SFSPD_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_2.Reg, volatile.LoadUint32(&o.SFSPD_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_2.Reg, volatile.LoadUint32(&o.SFSPD_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_2.Reg, volatile.LoadUint32(&o.SFSPD_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_3: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_3.Reg, volatile.LoadUint32(&o.SFSPD_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_3.Reg, volatile.LoadUint32(&o.SFSPD_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_3.Reg, volatile.LoadUint32(&o.SFSPD_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_3.Reg, volatile.LoadUint32(&o.SFSPD_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_3.Reg, volatile.LoadUint32(&o.SFSPD_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_3.Reg, volatile.LoadUint32(&o.SFSPD_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_3.Reg, volatile.LoadUint32(&o.SFSPD_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_4: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_4.Reg, volatile.LoadUint32(&o.SFSPD_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_4.Reg, volatile.LoadUint32(&o.SFSPD_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_4.Reg, volatile.LoadUint32(&o.SFSPD_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_4.Reg, volatile.LoadUint32(&o.SFSPD_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_4.Reg, volatile.LoadUint32(&o.SFSPD_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_4.Reg, volatile.LoadUint32(&o.SFSPD_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_4.Reg, volatile.LoadUint32(&o.SFSPD_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_5: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_5.Reg, volatile.LoadUint32(&o.SFSPD_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_5.Reg, volatile.LoadUint32(&o.SFSPD_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_5.Reg, volatile.LoadUint32(&o.SFSPD_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_5.Reg, volatile.LoadUint32(&o.SFSPD_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_5.Reg, volatile.LoadUint32(&o.SFSPD_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_5.Reg, volatile.LoadUint32(&o.SFSPD_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_5.Reg, volatile.LoadUint32(&o.SFSPD_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_6: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_6.Reg, volatile.LoadUint32(&o.SFSPD_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_6.Reg, volatile.LoadUint32(&o.SFSPD_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_6.Reg, volatile.LoadUint32(&o.SFSPD_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_6.Reg, volatile.LoadUint32(&o.SFSPD_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_6.Reg, volatile.LoadUint32(&o.SFSPD_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_6.Reg, volatile.LoadUint32(&o.SFSPD_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_6.Reg, volatile.LoadUint32(&o.SFSPD_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_7: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_7.Reg, volatile.LoadUint32(&o.SFSPD_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_7.Reg, volatile.LoadUint32(&o.SFSPD_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_7.Reg, volatile.LoadUint32(&o.SFSPD_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_7.Reg, volatile.LoadUint32(&o.SFSPD_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_7.Reg, volatile.LoadUint32(&o.SFSPD_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_7.Reg, volatile.LoadUint32(&o.SFSPD_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_7.Reg, volatile.LoadUint32(&o.SFSPD_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_8: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_8.Reg, volatile.LoadUint32(&o.SFSPD_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_8.Reg, volatile.LoadUint32(&o.SFSPD_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_8.Reg, volatile.LoadUint32(&o.SFSPD_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_8.Reg, volatile.LoadUint32(&o.SFSPD_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_8.Reg, volatile.LoadUint32(&o.SFSPD_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_8.Reg, volatile.LoadUint32(&o.SFSPD_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_8.Reg, volatile.LoadUint32(&o.SFSPD_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_9: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_9_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_9.Reg, volatile.LoadUint32(&o.SFSPD_9.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_9_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_9.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_9_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_9.Reg, volatile.LoadUint32(&o.SFSPD_9.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_9_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_9.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_9_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_9.Reg, volatile.LoadUint32(&o.SFSPD_9.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_9_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_9.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_9_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_9.Reg, volatile.LoadUint32(&o.SFSPD_9.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_9_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_9.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_9_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_9.Reg, volatile.LoadUint32(&o.SFSPD_9.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_9_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_9.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_9_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_9.Reg, volatile.LoadUint32(&o.SFSPD_9.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_9_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_9.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_9.Reg, volatile.LoadUint32(&o.SFSPD_9.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_9.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_10: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_10_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_10.Reg, volatile.LoadUint32(&o.SFSPD_10.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_10_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_10.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_10_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_10.Reg, volatile.LoadUint32(&o.SFSPD_10.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_10_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_10.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_10_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_10.Reg, volatile.LoadUint32(&o.SFSPD_10.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_10_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_10.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_10_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_10.Reg, volatile.LoadUint32(&o.SFSPD_10.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_10_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_10.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_10_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_10.Reg, volatile.LoadUint32(&o.SFSPD_10.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_10_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_10.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_10_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_10.Reg, volatile.LoadUint32(&o.SFSPD_10.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_10_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_10.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_10.Reg, volatile.LoadUint32(&o.SFSPD_10.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_10.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_11: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_11_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_11.Reg, volatile.LoadUint32(&o.SFSPD_11.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_11_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_11.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_11_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_11.Reg, volatile.LoadUint32(&o.SFSPD_11.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_11_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_11.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_11_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_11.Reg, volatile.LoadUint32(&o.SFSPD_11.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_11_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_11.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_11_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_11.Reg, volatile.LoadUint32(&o.SFSPD_11.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_11_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_11.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_11_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_11.Reg, volatile.LoadUint32(&o.SFSPD_11.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_11_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_11.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_11_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_11.Reg, volatile.LoadUint32(&o.SFSPD_11.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_11_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_11.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_11.Reg, volatile.LoadUint32(&o.SFSPD_11.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_11.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_12: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_12_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_12.Reg, volatile.LoadUint32(&o.SFSPD_12.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_12_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_12.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_12_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_12.Reg, volatile.LoadUint32(&o.SFSPD_12.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_12_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_12.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_12_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_12.Reg, volatile.LoadUint32(&o.SFSPD_12.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_12_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_12.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_12_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_12.Reg, volatile.LoadUint32(&o.SFSPD_12.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_12_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_12.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_12_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_12.Reg, volatile.LoadUint32(&o.SFSPD_12.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_12_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_12.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_12_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_12.Reg, volatile.LoadUint32(&o.SFSPD_12.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_12_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_12.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_12.Reg, volatile.LoadUint32(&o.SFSPD_12.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_12.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_13: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_13_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_13.Reg, volatile.LoadUint32(&o.SFSPD_13.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_13_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_13.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_13_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_13.Reg, volatile.LoadUint32(&o.SFSPD_13.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_13_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_13.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_13_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_13.Reg, volatile.LoadUint32(&o.SFSPD_13.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_13_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_13.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_13_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_13.Reg, volatile.LoadUint32(&o.SFSPD_13.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_13_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_13.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_13_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_13.Reg, volatile.LoadUint32(&o.SFSPD_13.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_13_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_13.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_13_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_13.Reg, volatile.LoadUint32(&o.SFSPD_13.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_13_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_13.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_13.Reg, volatile.LoadUint32(&o.SFSPD_13.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_13.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_14: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_14_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_14.Reg, volatile.LoadUint32(&o.SFSPD_14.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_14_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_14.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_14_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_14.Reg, volatile.LoadUint32(&o.SFSPD_14.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_14_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_14.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_14_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_14.Reg, volatile.LoadUint32(&o.SFSPD_14.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_14_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_14.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_14_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_14.Reg, volatile.LoadUint32(&o.SFSPD_14.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_14_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_14.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_14_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_14.Reg, volatile.LoadUint32(&o.SFSPD_14.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_14_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_14.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_14_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_14.Reg, volatile.LoadUint32(&o.SFSPD_14.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_14_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_14.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_14.Reg, volatile.LoadUint32(&o.SFSPD_14.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_14.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_15: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_15_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_15.Reg, volatile.LoadUint32(&o.SFSPD_15.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_15_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_15.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_15_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_15.Reg, volatile.LoadUint32(&o.SFSPD_15.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_15_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_15.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_15_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_15.Reg, volatile.LoadUint32(&o.SFSPD_15.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_15_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_15.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_15_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_15.Reg, volatile.LoadUint32(&o.SFSPD_15.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_15_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_15.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_15_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_15.Reg, volatile.LoadUint32(&o.SFSPD_15.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_15_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_15.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_15_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_15.Reg, volatile.LoadUint32(&o.SFSPD_15.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_15_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_15.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_15.Reg, volatile.LoadUint32(&o.SFSPD_15.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_15.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPD_16: Pin configuration register for pins PD
func (o *SCU_Type) SetSFSPD_16_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPD_16.Reg, volatile.LoadUint32(&o.SFSPD_16.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPD_16_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPD_16.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPD_16_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPD_16.Reg, volatile.LoadUint32(&o.SFSPD_16.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPD_16_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_16.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPD_16_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPD_16.Reg, volatile.LoadUint32(&o.SFSPD_16.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPD_16_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_16.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPD_16_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPD_16.Reg, volatile.LoadUint32(&o.SFSPD_16.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPD_16_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_16.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPD_16_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPD_16.Reg, volatile.LoadUint32(&o.SFSPD_16.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPD_16_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_16.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPD_16_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPD_16.Reg, volatile.LoadUint32(&o.SFSPD_16.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPD_16_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_16.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPD_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPD_16.Reg, volatile.LoadUint32(&o.SFSPD_16.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPD_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPD_16.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_0: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_0.Reg, volatile.LoadUint32(&o.SFSPE_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_0.Reg, volatile.LoadUint32(&o.SFSPE_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_0.Reg, volatile.LoadUint32(&o.SFSPE_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_0.Reg, volatile.LoadUint32(&o.SFSPE_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_0.Reg, volatile.LoadUint32(&o.SFSPE_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_0.Reg, volatile.LoadUint32(&o.SFSPE_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_0.Reg, volatile.LoadUint32(&o.SFSPE_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_1: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_1.Reg, volatile.LoadUint32(&o.SFSPE_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_1.Reg, volatile.LoadUint32(&o.SFSPE_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_1.Reg, volatile.LoadUint32(&o.SFSPE_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_1.Reg, volatile.LoadUint32(&o.SFSPE_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_1.Reg, volatile.LoadUint32(&o.SFSPE_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_1.Reg, volatile.LoadUint32(&o.SFSPE_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_1.Reg, volatile.LoadUint32(&o.SFSPE_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_2: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_2.Reg, volatile.LoadUint32(&o.SFSPE_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_2.Reg, volatile.LoadUint32(&o.SFSPE_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_2.Reg, volatile.LoadUint32(&o.SFSPE_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_2.Reg, volatile.LoadUint32(&o.SFSPE_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_2.Reg, volatile.LoadUint32(&o.SFSPE_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_2.Reg, volatile.LoadUint32(&o.SFSPE_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_2.Reg, volatile.LoadUint32(&o.SFSPE_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_3: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_3.Reg, volatile.LoadUint32(&o.SFSPE_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_3.Reg, volatile.LoadUint32(&o.SFSPE_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_3.Reg, volatile.LoadUint32(&o.SFSPE_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_3.Reg, volatile.LoadUint32(&o.SFSPE_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_3.Reg, volatile.LoadUint32(&o.SFSPE_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_3.Reg, volatile.LoadUint32(&o.SFSPE_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_3.Reg, volatile.LoadUint32(&o.SFSPE_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_4: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_4.Reg, volatile.LoadUint32(&o.SFSPE_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_4.Reg, volatile.LoadUint32(&o.SFSPE_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_4.Reg, volatile.LoadUint32(&o.SFSPE_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_4.Reg, volatile.LoadUint32(&o.SFSPE_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_4.Reg, volatile.LoadUint32(&o.SFSPE_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_4.Reg, volatile.LoadUint32(&o.SFSPE_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_4.Reg, volatile.LoadUint32(&o.SFSPE_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_5: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_5.Reg, volatile.LoadUint32(&o.SFSPE_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_5.Reg, volatile.LoadUint32(&o.SFSPE_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_5.Reg, volatile.LoadUint32(&o.SFSPE_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_5.Reg, volatile.LoadUint32(&o.SFSPE_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_5.Reg, volatile.LoadUint32(&o.SFSPE_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_5.Reg, volatile.LoadUint32(&o.SFSPE_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_5.Reg, volatile.LoadUint32(&o.SFSPE_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_6: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_6.Reg, volatile.LoadUint32(&o.SFSPE_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_6.Reg, volatile.LoadUint32(&o.SFSPE_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_6.Reg, volatile.LoadUint32(&o.SFSPE_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_6.Reg, volatile.LoadUint32(&o.SFSPE_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_6.Reg, volatile.LoadUint32(&o.SFSPE_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_6.Reg, volatile.LoadUint32(&o.SFSPE_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_6.Reg, volatile.LoadUint32(&o.SFSPE_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_7: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_7.Reg, volatile.LoadUint32(&o.SFSPE_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_7.Reg, volatile.LoadUint32(&o.SFSPE_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_7.Reg, volatile.LoadUint32(&o.SFSPE_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_7.Reg, volatile.LoadUint32(&o.SFSPE_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_7.Reg, volatile.LoadUint32(&o.SFSPE_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_7.Reg, volatile.LoadUint32(&o.SFSPE_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_7.Reg, volatile.LoadUint32(&o.SFSPE_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_8: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_8.Reg, volatile.LoadUint32(&o.SFSPE_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_8.Reg, volatile.LoadUint32(&o.SFSPE_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_8.Reg, volatile.LoadUint32(&o.SFSPE_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_8.Reg, volatile.LoadUint32(&o.SFSPE_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_8.Reg, volatile.LoadUint32(&o.SFSPE_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_8.Reg, volatile.LoadUint32(&o.SFSPE_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_8.Reg, volatile.LoadUint32(&o.SFSPE_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_9: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_9_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_9.Reg, volatile.LoadUint32(&o.SFSPE_9.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_9_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_9.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_9_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_9.Reg, volatile.LoadUint32(&o.SFSPE_9.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_9_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_9.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_9_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_9.Reg, volatile.LoadUint32(&o.SFSPE_9.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_9_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_9.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_9_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_9.Reg, volatile.LoadUint32(&o.SFSPE_9.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_9_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_9.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_9_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_9.Reg, volatile.LoadUint32(&o.SFSPE_9.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_9_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_9.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_9_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_9.Reg, volatile.LoadUint32(&o.SFSPE_9.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_9_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_9.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_9.Reg, volatile.LoadUint32(&o.SFSPE_9.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_9.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_10: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_10_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_10.Reg, volatile.LoadUint32(&o.SFSPE_10.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_10_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_10.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_10_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_10.Reg, volatile.LoadUint32(&o.SFSPE_10.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_10_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_10.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_10_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_10.Reg, volatile.LoadUint32(&o.SFSPE_10.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_10_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_10.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_10_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_10.Reg, volatile.LoadUint32(&o.SFSPE_10.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_10_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_10.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_10_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_10.Reg, volatile.LoadUint32(&o.SFSPE_10.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_10_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_10.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_10_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_10.Reg, volatile.LoadUint32(&o.SFSPE_10.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_10_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_10.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_10.Reg, volatile.LoadUint32(&o.SFSPE_10.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_10.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_11: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_11_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_11.Reg, volatile.LoadUint32(&o.SFSPE_11.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_11_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_11.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_11_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_11.Reg, volatile.LoadUint32(&o.SFSPE_11.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_11_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_11.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_11_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_11.Reg, volatile.LoadUint32(&o.SFSPE_11.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_11_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_11.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_11_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_11.Reg, volatile.LoadUint32(&o.SFSPE_11.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_11_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_11.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_11_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_11.Reg, volatile.LoadUint32(&o.SFSPE_11.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_11_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_11.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_11_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_11.Reg, volatile.LoadUint32(&o.SFSPE_11.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_11_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_11.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_11.Reg, volatile.LoadUint32(&o.SFSPE_11.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_11.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_12: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_12_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_12.Reg, volatile.LoadUint32(&o.SFSPE_12.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_12_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_12.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_12_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_12.Reg, volatile.LoadUint32(&o.SFSPE_12.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_12_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_12.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_12_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_12.Reg, volatile.LoadUint32(&o.SFSPE_12.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_12_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_12.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_12_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_12.Reg, volatile.LoadUint32(&o.SFSPE_12.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_12_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_12.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_12_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_12.Reg, volatile.LoadUint32(&o.SFSPE_12.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_12_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_12.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_12_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_12.Reg, volatile.LoadUint32(&o.SFSPE_12.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_12_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_12.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_12.Reg, volatile.LoadUint32(&o.SFSPE_12.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_12.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_13: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_13_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_13.Reg, volatile.LoadUint32(&o.SFSPE_13.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_13_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_13.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_13_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_13.Reg, volatile.LoadUint32(&o.SFSPE_13.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_13_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_13.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_13_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_13.Reg, volatile.LoadUint32(&o.SFSPE_13.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_13_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_13.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_13_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_13.Reg, volatile.LoadUint32(&o.SFSPE_13.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_13_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_13.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_13_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_13.Reg, volatile.LoadUint32(&o.SFSPE_13.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_13_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_13.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_13_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_13.Reg, volatile.LoadUint32(&o.SFSPE_13.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_13_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_13.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_13.Reg, volatile.LoadUint32(&o.SFSPE_13.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_13.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_14: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_14_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_14.Reg, volatile.LoadUint32(&o.SFSPE_14.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_14_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_14.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_14_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_14.Reg, volatile.LoadUint32(&o.SFSPE_14.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_14_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_14.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_14_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_14.Reg, volatile.LoadUint32(&o.SFSPE_14.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_14_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_14.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_14_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_14.Reg, volatile.LoadUint32(&o.SFSPE_14.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_14_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_14.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_14_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_14.Reg, volatile.LoadUint32(&o.SFSPE_14.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_14_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_14.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_14_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_14.Reg, volatile.LoadUint32(&o.SFSPE_14.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_14_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_14.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_14.Reg, volatile.LoadUint32(&o.SFSPE_14.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_14.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPE_15: Pin configuration register for pins PE
func (o *SCU_Type) SetSFSPE_15_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPE_15.Reg, volatile.LoadUint32(&o.SFSPE_15.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPE_15_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPE_15.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPE_15_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPE_15.Reg, volatile.LoadUint32(&o.SFSPE_15.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPE_15_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_15.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPE_15_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPE_15.Reg, volatile.LoadUint32(&o.SFSPE_15.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPE_15_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_15.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPE_15_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPE_15.Reg, volatile.LoadUint32(&o.SFSPE_15.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPE_15_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_15.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPE_15_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPE_15.Reg, volatile.LoadUint32(&o.SFSPE_15.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPE_15_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_15.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPE_15_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPE_15.Reg, volatile.LoadUint32(&o.SFSPE_15.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPE_15_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_15.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPE_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPE_15.Reg, volatile.LoadUint32(&o.SFSPE_15.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPE_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPE_15.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_0: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_0.Reg, volatile.LoadUint32(&o.SFSPF_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_0.Reg, volatile.LoadUint32(&o.SFSPF_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_0.Reg, volatile.LoadUint32(&o.SFSPF_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_0.Reg, volatile.LoadUint32(&o.SFSPF_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_0.Reg, volatile.LoadUint32(&o.SFSPF_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_0.Reg, volatile.LoadUint32(&o.SFSPF_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_0.Reg, volatile.LoadUint32(&o.SFSPF_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_1: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_1.Reg, volatile.LoadUint32(&o.SFSPF_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_1.Reg, volatile.LoadUint32(&o.SFSPF_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_1.Reg, volatile.LoadUint32(&o.SFSPF_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_1.Reg, volatile.LoadUint32(&o.SFSPF_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_1.Reg, volatile.LoadUint32(&o.SFSPF_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_1.Reg, volatile.LoadUint32(&o.SFSPF_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_1.Reg, volatile.LoadUint32(&o.SFSPF_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_2: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_2.Reg, volatile.LoadUint32(&o.SFSPF_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_2.Reg, volatile.LoadUint32(&o.SFSPF_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_2.Reg, volatile.LoadUint32(&o.SFSPF_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_2.Reg, volatile.LoadUint32(&o.SFSPF_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_2.Reg, volatile.LoadUint32(&o.SFSPF_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_2.Reg, volatile.LoadUint32(&o.SFSPF_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_2.Reg, volatile.LoadUint32(&o.SFSPF_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_3: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_3.Reg, volatile.LoadUint32(&o.SFSPF_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_3.Reg, volatile.LoadUint32(&o.SFSPF_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_3.Reg, volatile.LoadUint32(&o.SFSPF_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_3.Reg, volatile.LoadUint32(&o.SFSPF_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_3.Reg, volatile.LoadUint32(&o.SFSPF_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_3.Reg, volatile.LoadUint32(&o.SFSPF_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_3.Reg, volatile.LoadUint32(&o.SFSPF_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_4: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_4_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_4.Reg, volatile.LoadUint32(&o.SFSPF_4.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_4_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_4.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_4_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_4.Reg, volatile.LoadUint32(&o.SFSPF_4.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_4_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_4.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_4_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_4.Reg, volatile.LoadUint32(&o.SFSPF_4.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_4_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_4.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_4_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_4.Reg, volatile.LoadUint32(&o.SFSPF_4.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_4_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_4.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_4_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_4.Reg, volatile.LoadUint32(&o.SFSPF_4.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_4_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_4.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_4_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_4.Reg, volatile.LoadUint32(&o.SFSPF_4.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_4_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_4.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_4.Reg, volatile.LoadUint32(&o.SFSPF_4.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_4.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_5: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_5_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_5.Reg, volatile.LoadUint32(&o.SFSPF_5.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_5_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_5.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_5_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_5.Reg, volatile.LoadUint32(&o.SFSPF_5.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_5_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_5.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_5_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_5.Reg, volatile.LoadUint32(&o.SFSPF_5.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_5_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_5.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_5_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_5.Reg, volatile.LoadUint32(&o.SFSPF_5.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_5_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_5.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_5_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_5.Reg, volatile.LoadUint32(&o.SFSPF_5.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_5_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_5.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_5_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_5.Reg, volatile.LoadUint32(&o.SFSPF_5.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_5_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_5.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_5.Reg, volatile.LoadUint32(&o.SFSPF_5.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_5.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_6: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_6_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_6.Reg, volatile.LoadUint32(&o.SFSPF_6.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_6_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_6.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_6_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_6.Reg, volatile.LoadUint32(&o.SFSPF_6.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_6_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_6.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_6_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_6.Reg, volatile.LoadUint32(&o.SFSPF_6.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_6_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_6.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_6_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_6.Reg, volatile.LoadUint32(&o.SFSPF_6.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_6_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_6.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_6_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_6.Reg, volatile.LoadUint32(&o.SFSPF_6.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_6_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_6.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_6_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_6.Reg, volatile.LoadUint32(&o.SFSPF_6.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_6_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_6.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_6.Reg, volatile.LoadUint32(&o.SFSPF_6.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_6.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_7: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_7_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_7.Reg, volatile.LoadUint32(&o.SFSPF_7.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_7_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_7.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_7_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_7.Reg, volatile.LoadUint32(&o.SFSPF_7.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_7_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_7.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_7_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_7.Reg, volatile.LoadUint32(&o.SFSPF_7.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_7_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_7.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_7_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_7.Reg, volatile.LoadUint32(&o.SFSPF_7.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_7_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_7.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_7_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_7.Reg, volatile.LoadUint32(&o.SFSPF_7.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_7_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_7.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_7_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_7.Reg, volatile.LoadUint32(&o.SFSPF_7.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_7_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_7.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_7.Reg, volatile.LoadUint32(&o.SFSPF_7.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_7.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_8: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_8_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_8.Reg, volatile.LoadUint32(&o.SFSPF_8.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_8_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_8.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_8_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_8.Reg, volatile.LoadUint32(&o.SFSPF_8.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_8_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_8.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_8_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_8.Reg, volatile.LoadUint32(&o.SFSPF_8.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_8_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_8.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_8_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_8.Reg, volatile.LoadUint32(&o.SFSPF_8.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_8_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_8.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_8_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_8.Reg, volatile.LoadUint32(&o.SFSPF_8.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_8_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_8.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_8_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_8.Reg, volatile.LoadUint32(&o.SFSPF_8.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_8_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_8.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_8.Reg, volatile.LoadUint32(&o.SFSPF_8.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_8.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_9: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_9_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_9.Reg, volatile.LoadUint32(&o.SFSPF_9.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_9_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_9.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_9_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_9.Reg, volatile.LoadUint32(&o.SFSPF_9.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_9_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_9.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_9_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_9.Reg, volatile.LoadUint32(&o.SFSPF_9.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_9_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_9.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_9_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_9.Reg, volatile.LoadUint32(&o.SFSPF_9.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_9_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_9.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_9_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_9.Reg, volatile.LoadUint32(&o.SFSPF_9.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_9_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_9.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_9_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_9.Reg, volatile.LoadUint32(&o.SFSPF_9.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_9_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_9.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_9.Reg, volatile.LoadUint32(&o.SFSPF_9.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_9.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_10: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_10_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_10.Reg, volatile.LoadUint32(&o.SFSPF_10.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_10_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_10.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_10_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_10.Reg, volatile.LoadUint32(&o.SFSPF_10.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_10_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_10.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_10_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_10.Reg, volatile.LoadUint32(&o.SFSPF_10.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_10_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_10.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_10_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_10.Reg, volatile.LoadUint32(&o.SFSPF_10.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_10_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_10.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_10_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_10.Reg, volatile.LoadUint32(&o.SFSPF_10.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_10_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_10.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_10_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_10.Reg, volatile.LoadUint32(&o.SFSPF_10.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_10_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_10.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_10.Reg, volatile.LoadUint32(&o.SFSPF_10.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_10.Reg) & 0xffffff00) >> 8
}

// SCU.SFSPF_11: Pin configuration register for pins PF
func (o *SCU_Type) SetSFSPF_11_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSPF_11.Reg, volatile.LoadUint32(&o.SFSPF_11.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSPF_11_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSPF_11.Reg) & 0x7
}
func (o *SCU_Type) SetSFSPF_11_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSPF_11.Reg, volatile.LoadUint32(&o.SFSPF_11.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSPF_11_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_11.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSPF_11_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSPF_11.Reg, volatile.LoadUint32(&o.SFSPF_11.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSPF_11_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_11.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSPF_11_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSPF_11.Reg, volatile.LoadUint32(&o.SFSPF_11.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSPF_11_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_11.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSPF_11_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSPF_11.Reg, volatile.LoadUint32(&o.SFSPF_11.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSPF_11_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_11.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSPF_11_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSPF_11.Reg, volatile.LoadUint32(&o.SFSPF_11.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSPF_11_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_11.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSPF_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSPF_11.Reg, volatile.LoadUint32(&o.SFSPF_11.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSPF_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSPF_11.Reg) & 0xffffff00) >> 8
}

// SCU.SFSCLK_0: Pin configuration register for pins CLK
func (o *SCU_Type) SetSFSCLK_0_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_0.Reg, volatile.LoadUint32(&o.SFSCLK_0.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSCLK_0_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSCLK_0.Reg) & 0x7
}
func (o *SCU_Type) SetSFSCLK_0_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_0.Reg, volatile.LoadUint32(&o.SFSCLK_0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSCLK_0_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSCLK_0_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_0.Reg, volatile.LoadUint32(&o.SFSCLK_0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSCLK_0_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSCLK_0_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_0.Reg, volatile.LoadUint32(&o.SFSCLK_0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSCLK_0_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSCLK_0_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_0.Reg, volatile.LoadUint32(&o.SFSCLK_0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSCLK_0_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_0.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSCLK_0_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_0.Reg, volatile.LoadUint32(&o.SFSCLK_0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSCLK_0_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSCLK_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_0.Reg, volatile.LoadUint32(&o.SFSCLK_0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSCLK_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_0.Reg) & 0xffffff00) >> 8
}

// SCU.SFSCLK_1: Pin configuration register for pins CLK
func (o *SCU_Type) SetSFSCLK_1_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_1.Reg, volatile.LoadUint32(&o.SFSCLK_1.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSCLK_1_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSCLK_1.Reg) & 0x7
}
func (o *SCU_Type) SetSFSCLK_1_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_1.Reg, volatile.LoadUint32(&o.SFSCLK_1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSCLK_1_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSCLK_1_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_1.Reg, volatile.LoadUint32(&o.SFSCLK_1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSCLK_1_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSCLK_1_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_1.Reg, volatile.LoadUint32(&o.SFSCLK_1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSCLK_1_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSCLK_1_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_1.Reg, volatile.LoadUint32(&o.SFSCLK_1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSCLK_1_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSCLK_1_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_1.Reg, volatile.LoadUint32(&o.SFSCLK_1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSCLK_1_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_1.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSCLK_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_1.Reg, volatile.LoadUint32(&o.SFSCLK_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSCLK_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_1.Reg) & 0xffffff00) >> 8
}

// SCU.SFSCLK_2: Pin configuration register for pins CLK
func (o *SCU_Type) SetSFSCLK_2_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_2.Reg, volatile.LoadUint32(&o.SFSCLK_2.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSCLK_2_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSCLK_2.Reg) & 0x7
}
func (o *SCU_Type) SetSFSCLK_2_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_2.Reg, volatile.LoadUint32(&o.SFSCLK_2.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSCLK_2_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_2.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSCLK_2_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_2.Reg, volatile.LoadUint32(&o.SFSCLK_2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSCLK_2_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_2.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSCLK_2_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_2.Reg, volatile.LoadUint32(&o.SFSCLK_2.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSCLK_2_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_2.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSCLK_2_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_2.Reg, volatile.LoadUint32(&o.SFSCLK_2.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSCLK_2_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_2.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSCLK_2_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_2.Reg, volatile.LoadUint32(&o.SFSCLK_2.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSCLK_2_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_2.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSCLK_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_2.Reg, volatile.LoadUint32(&o.SFSCLK_2.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSCLK_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_2.Reg) & 0xffffff00) >> 8
}

// SCU.SFSCLK_3: Pin configuration register for pins CLK
func (o *SCU_Type) SetSFSCLK_3_MODE(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_3.Reg, volatile.LoadUint32(&o.SFSCLK_3.Reg)&^(0x7)|value)
}
func (o *SCU_Type) GetSFSCLK_3_MODE() uint32 {
	return volatile.LoadUint32(&o.SFSCLK_3.Reg) & 0x7
}
func (o *SCU_Type) SetSFSCLK_3_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_3.Reg, volatile.LoadUint32(&o.SFSCLK_3.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSCLK_3_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_3.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSCLK_3_EPUN(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_3.Reg, volatile.LoadUint32(&o.SFSCLK_3.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSCLK_3_EPUN() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_3.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSCLK_3_EHS(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_3.Reg, volatile.LoadUint32(&o.SFSCLK_3.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSCLK_3_EHS() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_3.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSCLK_3_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_3.Reg, volatile.LoadUint32(&o.SFSCLK_3.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetSFSCLK_3_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_3.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetSFSCLK_3_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_3.Reg, volatile.LoadUint32(&o.SFSCLK_3.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSCLK_3_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_3.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSCLK_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSCLK_3.Reg, volatile.LoadUint32(&o.SFSCLK_3.Reg)&^(0xffffff00)|value<<8)
}
func (o *SCU_Type) GetSFSCLK_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSCLK_3.Reg) & 0xffffff00) >> 8
}

// SCU.SFSUSB: Pin configuration register for pins USB1_DM and USB1_DP
func (o *SCU_Type) SetSFSUSB_USB_AIM(value uint32) {
	volatile.StoreUint32(&o.SFSUSB.Reg, volatile.LoadUint32(&o.SFSUSB.Reg)&^(0x1)|value)
}
func (o *SCU_Type) GetSFSUSB_USB_AIM() uint32 {
	return volatile.LoadUint32(&o.SFSUSB.Reg) & 0x1
}
func (o *SCU_Type) SetSFSUSB_USB_ESEA(value uint32) {
	volatile.StoreUint32(&o.SFSUSB.Reg, volatile.LoadUint32(&o.SFSUSB.Reg)&^(0x2)|value<<1)
}
func (o *SCU_Type) GetSFSUSB_USB_ESEA() uint32 {
	return (volatile.LoadUint32(&o.SFSUSB.Reg) & 0x2) >> 1
}
func (o *SCU_Type) SetSFSUSB_USB_EPD(value uint32) {
	volatile.StoreUint32(&o.SFSUSB.Reg, volatile.LoadUint32(&o.SFSUSB.Reg)&^(0x4)|value<<2)
}
func (o *SCU_Type) GetSFSUSB_USB_EPD() uint32 {
	return (volatile.LoadUint32(&o.SFSUSB.Reg) & 0x4) >> 2
}
func (o *SCU_Type) SetSFSUSB_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSUSB.Reg, volatile.LoadUint32(&o.SFSUSB.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSUSB_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSUSB.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSUSB_USB_EPWR(value uint32) {
	volatile.StoreUint32(&o.SFSUSB.Reg, volatile.LoadUint32(&o.SFSUSB.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetSFSUSB_USB_EPWR() uint32 {
	return (volatile.LoadUint32(&o.SFSUSB.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetSFSUSB_USB_VBUS(value uint32) {
	volatile.StoreUint32(&o.SFSUSB.Reg, volatile.LoadUint32(&o.SFSUSB.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetSFSUSB_USB_VBUS() uint32 {
	return (volatile.LoadUint32(&o.SFSUSB.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetSFSUSB_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSUSB.Reg, volatile.LoadUint32(&o.SFSUSB.Reg)&^(0xffffffc0)|value<<6)
}
func (o *SCU_Type) GetSFSUSB_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSUSB.Reg) & 0xffffffc0) >> 6
}

// SCU.SFSI2C0: Pin configuration register for I2C0-bus pins
func (o *SCU_Type) SetSFSI2C0_SCL_EFP(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x1)|value)
}
func (o *SCU_Type) GetSFSI2C0_SCL_EFP() uint32 {
	return volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x1
}
func (o *SCU_Type) SetSFSI2C0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x2)|value<<1)
}
func (o *SCU_Type) GetSFSI2C0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x2) >> 1
}
func (o *SCU_Type) SetSFSI2C0_SCL_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x4)|value<<2)
}
func (o *SCU_Type) GetSFSI2C0_SCL_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x4) >> 2
}
func (o *SCU_Type) SetSFSI2C0_SCL_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetSFSI2C0_SCL_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetSFSI2C0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x70)|value<<4)
}
func (o *SCU_Type) GetSFSI2C0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x70) >> 4
}
func (o *SCU_Type) SetSFSI2C0_SCL_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetSFSI2C0_SCL_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x80) >> 7
}
func (o *SCU_Type) SetSFSI2C0_SDA_EFP(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x100)|value<<8)
}
func (o *SCU_Type) GetSFSI2C0_SDA_EFP() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x100) >> 8
}
func (o *SCU_Type) SetSFSI2C0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x200)|value<<9)
}
func (o *SCU_Type) GetSFSI2C0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x200) >> 9
}
func (o *SCU_Type) SetSFSI2C0_SDA_EHD(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x400)|value<<10)
}
func (o *SCU_Type) GetSFSI2C0_SDA_EHD() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x400) >> 10
}
func (o *SCU_Type) SetSFSI2C0_SDA_EZI(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x800)|value<<11)
}
func (o *SCU_Type) GetSFSI2C0_SDA_EZI() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x800) >> 11
}
func (o *SCU_Type) SetSFSI2C0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x7000)|value<<12)
}
func (o *SCU_Type) GetSFSI2C0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x7000) >> 12
}
func (o *SCU_Type) SetSFSI2C0_SDA_ZIF(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0x8000)|value<<15)
}
func (o *SCU_Type) GetSFSI2C0_SDA_ZIF() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0x8000) >> 15
}
func (o *SCU_Type) SetSFSI2C0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFSI2C0.Reg, volatile.LoadUint32(&o.SFSI2C0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCU_Type) GetSFSI2C0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFSI2C0.Reg) & 0xffff0000) >> 16
}

// SCU.ENAIO0: ADC0 function select register
func (o *SCU_Type) SetENAIO0_ADC0_0(value uint32) {
	volatile.StoreUint32(&o.ENAIO0.Reg, volatile.LoadUint32(&o.ENAIO0.Reg)&^(0x1)|value)
}
func (o *SCU_Type) GetENAIO0_ADC0_0() uint32 {
	return volatile.LoadUint32(&o.ENAIO0.Reg) & 0x1
}
func (o *SCU_Type) SetENAIO0_ADC0_1(value uint32) {
	volatile.StoreUint32(&o.ENAIO0.Reg, volatile.LoadUint32(&o.ENAIO0.Reg)&^(0x2)|value<<1)
}
func (o *SCU_Type) GetENAIO0_ADC0_1() uint32 {
	return (volatile.LoadUint32(&o.ENAIO0.Reg) & 0x2) >> 1
}
func (o *SCU_Type) SetENAIO0_ADC0_2(value uint32) {
	volatile.StoreUint32(&o.ENAIO0.Reg, volatile.LoadUint32(&o.ENAIO0.Reg)&^(0x4)|value<<2)
}
func (o *SCU_Type) GetENAIO0_ADC0_2() uint32 {
	return (volatile.LoadUint32(&o.ENAIO0.Reg) & 0x4) >> 2
}
func (o *SCU_Type) SetENAIO0_ADC0_3(value uint32) {
	volatile.StoreUint32(&o.ENAIO0.Reg, volatile.LoadUint32(&o.ENAIO0.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetENAIO0_ADC0_3() uint32 {
	return (volatile.LoadUint32(&o.ENAIO0.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetENAIO0_ADC0_4(value uint32) {
	volatile.StoreUint32(&o.ENAIO0.Reg, volatile.LoadUint32(&o.ENAIO0.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetENAIO0_ADC0_4() uint32 {
	return (volatile.LoadUint32(&o.ENAIO0.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetENAIO0_ADC0_5(value uint32) {
	volatile.StoreUint32(&o.ENAIO0.Reg, volatile.LoadUint32(&o.ENAIO0.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetENAIO0_ADC0_5() uint32 {
	return (volatile.LoadUint32(&o.ENAIO0.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetENAIO0_ADC0_6(value uint32) {
	volatile.StoreUint32(&o.ENAIO0.Reg, volatile.LoadUint32(&o.ENAIO0.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetENAIO0_ADC0_6() uint32 {
	return (volatile.LoadUint32(&o.ENAIO0.Reg) & 0x40) >> 6
}

// SCU.ENAIO1: ADC1 function select register
func (o *SCU_Type) SetENAIO1_ADC1_0(value uint32) {
	volatile.StoreUint32(&o.ENAIO1.Reg, volatile.LoadUint32(&o.ENAIO1.Reg)&^(0x1)|value)
}
func (o *SCU_Type) GetENAIO1_ADC1_0() uint32 {
	return volatile.LoadUint32(&o.ENAIO1.Reg) & 0x1
}
func (o *SCU_Type) SetENAIO1_ADC1_1(value uint32) {
	volatile.StoreUint32(&o.ENAIO1.Reg, volatile.LoadUint32(&o.ENAIO1.Reg)&^(0x2)|value<<1)
}
func (o *SCU_Type) GetENAIO1_ADC1_1() uint32 {
	return (volatile.LoadUint32(&o.ENAIO1.Reg) & 0x2) >> 1
}
func (o *SCU_Type) SetENAIO1_ADC1_2(value uint32) {
	volatile.StoreUint32(&o.ENAIO1.Reg, volatile.LoadUint32(&o.ENAIO1.Reg)&^(0x4)|value<<2)
}
func (o *SCU_Type) GetENAIO1_ADC1_2() uint32 {
	return (volatile.LoadUint32(&o.ENAIO1.Reg) & 0x4) >> 2
}
func (o *SCU_Type) SetENAIO1_ADC1_3(value uint32) {
	volatile.StoreUint32(&o.ENAIO1.Reg, volatile.LoadUint32(&o.ENAIO1.Reg)&^(0x8)|value<<3)
}
func (o *SCU_Type) GetENAIO1_ADC1_3() uint32 {
	return (volatile.LoadUint32(&o.ENAIO1.Reg) & 0x8) >> 3
}
func (o *SCU_Type) SetENAIO1_ADC1_4(value uint32) {
	volatile.StoreUint32(&o.ENAIO1.Reg, volatile.LoadUint32(&o.ENAIO1.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetENAIO1_ADC1_4() uint32 {
	return (volatile.LoadUint32(&o.ENAIO1.Reg) & 0x10) >> 4
}
func (o *SCU_Type) SetENAIO1_ADC1_5(value uint32) {
	volatile.StoreUint32(&o.ENAIO1.Reg, volatile.LoadUint32(&o.ENAIO1.Reg)&^(0x20)|value<<5)
}
func (o *SCU_Type) GetENAIO1_ADC1_5() uint32 {
	return (volatile.LoadUint32(&o.ENAIO1.Reg) & 0x20) >> 5
}
func (o *SCU_Type) SetENAIO1_ADC1_6(value uint32) {
	volatile.StoreUint32(&o.ENAIO1.Reg, volatile.LoadUint32(&o.ENAIO1.Reg)&^(0x40)|value<<6)
}
func (o *SCU_Type) GetENAIO1_ADC1_6() uint32 {
	return (volatile.LoadUint32(&o.ENAIO1.Reg) & 0x40) >> 6
}
func (o *SCU_Type) SetENAIO1_ADC1_7(value uint32) {
	volatile.StoreUint32(&o.ENAIO1.Reg, volatile.LoadUint32(&o.ENAIO1.Reg)&^(0x80)|value<<7)
}
func (o *SCU_Type) GetENAIO1_ADC1_7() uint32 {
	return (volatile.LoadUint32(&o.ENAIO1.Reg) & 0x80) >> 7
}

// SCU.ENAIO2: Analog function select register
func (o *SCU_Type) SetENAIO2_DAC(value uint32) {
	volatile.StoreUint32(&o.ENAIO2.Reg, volatile.LoadUint32(&o.ENAIO2.Reg)&^(0x1)|value)
}
func (o *SCU_Type) GetENAIO2_DAC() uint32 {
	return volatile.LoadUint32(&o.ENAIO2.Reg) & 0x1
}
func (o *SCU_Type) SetENAIO2_BG(value uint32) {
	volatile.StoreUint32(&o.ENAIO2.Reg, volatile.LoadUint32(&o.ENAIO2.Reg)&^(0x10)|value<<4)
}
func (o *SCU_Type) GetENAIO2_BG() uint32 {
	return (volatile.LoadUint32(&o.ENAIO2.Reg) & 0x10) >> 4
}

// SCU.EMCDELAYCLK: EMC clock delay register
func (o *SCU_Type) SetEMCDELAYCLK_CLK_DELAY(value uint32) {
	volatile.StoreUint32(&o.EMCDELAYCLK.Reg, volatile.LoadUint32(&o.EMCDELAYCLK.Reg)&^(0xffff)|value)
}
func (o *SCU_Type) GetEMCDELAYCLK_CLK_DELAY() uint32 {
	return volatile.LoadUint32(&o.EMCDELAYCLK.Reg) & 0xffff
}
func (o *SCU_Type) SetEMCDELAYCLK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMCDELAYCLK.Reg, volatile.LoadUint32(&o.EMCDELAYCLK.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCU_Type) GetEMCDELAYCLK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMCDELAYCLK.Reg) & 0xffff0000) >> 16
}

// SCU.SDDELAY: SD/MMC sample and drive delay register
func (o *SCU_Type) SetSDDELAY_SAMPLE_DELAY(value uint32) {
	volatile.StoreUint32(&o.SDDELAY.Reg, volatile.LoadUint32(&o.SDDELAY.Reg)&^(0xf)|value)
}
func (o *SCU_Type) GetSDDELAY_SAMPLE_DELAY() uint32 {
	return volatile.LoadUint32(&o.SDDELAY.Reg) & 0xf
}
func (o *SCU_Type) SetSDDELAY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SDDELAY.Reg, volatile.LoadUint32(&o.SDDELAY.Reg)&^(0xf0)|value<<4)
}
func (o *SCU_Type) GetSDDELAY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SDDELAY.Reg) & 0xf0) >> 4
}
func (o *SCU_Type) SetSDDELAY_DRV_DELAY(value uint32) {
	volatile.StoreUint32(&o.SDDELAY.Reg, volatile.LoadUint32(&o.SDDELAY.Reg)&^(0xf00)|value<<8)
}
func (o *SCU_Type) GetSDDELAY_DRV_DELAY() uint32 {
	return (volatile.LoadUint32(&o.SDDELAY.Reg) & 0xf00) >> 8
}
func (o *SCU_Type) SetSDDELAY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SDDELAY.Reg, volatile.LoadUint32(&o.SDDELAY.Reg)&^(0xfffff000)|value<<12)
}
func (o *SCU_Type) GetSDDELAY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SDDELAY.Reg) & 0xfffff000) >> 12
}

// SCU.PINTSEL0: Pin interrupt select register for pin interrupts 0 to 3.
func (o *SCU_Type) SetPINTSEL0_INTPIN0(value uint32) {
	volatile.StoreUint32(&o.PINTSEL0.Reg, volatile.LoadUint32(&o.PINTSEL0.Reg)&^(0x1f)|value)
}
func (o *SCU_Type) GetPINTSEL0_INTPIN0() uint32 {
	return volatile.LoadUint32(&o.PINTSEL0.Reg) & 0x1f
}
func (o *SCU_Type) SetPINTSEL0_PORTSEL0(value uint32) {
	volatile.StoreUint32(&o.PINTSEL0.Reg, volatile.LoadUint32(&o.PINTSEL0.Reg)&^(0xe0)|value<<5)
}
func (o *SCU_Type) GetPINTSEL0_PORTSEL0() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL0.Reg) & 0xe0) >> 5
}
func (o *SCU_Type) SetPINTSEL0_INTPIN1(value uint32) {
	volatile.StoreUint32(&o.PINTSEL0.Reg, volatile.LoadUint32(&o.PINTSEL0.Reg)&^(0x1f00)|value<<8)
}
func (o *SCU_Type) GetPINTSEL0_INTPIN1() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL0.Reg) & 0x1f00) >> 8
}
func (o *SCU_Type) SetPINTSEL0_PORTSEL1(value uint32) {
	volatile.StoreUint32(&o.PINTSEL0.Reg, volatile.LoadUint32(&o.PINTSEL0.Reg)&^(0xe000)|value<<13)
}
func (o *SCU_Type) GetPINTSEL0_PORTSEL1() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL0.Reg) & 0xe000) >> 13
}
func (o *SCU_Type) SetPINTSEL0_INTPIN2(value uint32) {
	volatile.StoreUint32(&o.PINTSEL0.Reg, volatile.LoadUint32(&o.PINTSEL0.Reg)&^(0x1f0000)|value<<16)
}
func (o *SCU_Type) GetPINTSEL0_INTPIN2() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL0.Reg) & 0x1f0000) >> 16
}
func (o *SCU_Type) SetPINTSEL0_PORTSEL2(value uint32) {
	volatile.StoreUint32(&o.PINTSEL0.Reg, volatile.LoadUint32(&o.PINTSEL0.Reg)&^(0xe00000)|value<<21)
}
func (o *SCU_Type) GetPINTSEL0_PORTSEL2() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL0.Reg) & 0xe00000) >> 21
}
func (o *SCU_Type) SetPINTSEL0_INTPIN3(value uint32) {
	volatile.StoreUint32(&o.PINTSEL0.Reg, volatile.LoadUint32(&o.PINTSEL0.Reg)&^(0x1f000000)|value<<24)
}
func (o *SCU_Type) GetPINTSEL0_INTPIN3() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL0.Reg) & 0x1f000000) >> 24
}
func (o *SCU_Type) SetPINTSEL0_PORTSEL3(value uint32) {
	volatile.StoreUint32(&o.PINTSEL0.Reg, volatile.LoadUint32(&o.PINTSEL0.Reg)&^(0xe0000000)|value<<29)
}
func (o *SCU_Type) GetPINTSEL0_PORTSEL3() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL0.Reg) & 0xe0000000) >> 29
}

// SCU.PINTSEL1: Pin interrupt select register for pin interrupts 4 to 7.
func (o *SCU_Type) SetPINTSEL1_INTPIN4(value uint32) {
	volatile.StoreUint32(&o.PINTSEL1.Reg, volatile.LoadUint32(&o.PINTSEL1.Reg)&^(0x1f)|value)
}
func (o *SCU_Type) GetPINTSEL1_INTPIN4() uint32 {
	return volatile.LoadUint32(&o.PINTSEL1.Reg) & 0x1f
}
func (o *SCU_Type) SetPINTSEL1_PORTSEL4(value uint32) {
	volatile.StoreUint32(&o.PINTSEL1.Reg, volatile.LoadUint32(&o.PINTSEL1.Reg)&^(0xe0)|value<<5)
}
func (o *SCU_Type) GetPINTSEL1_PORTSEL4() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL1.Reg) & 0xe0) >> 5
}
func (o *SCU_Type) SetPINTSEL1_INTPIN5(value uint32) {
	volatile.StoreUint32(&o.PINTSEL1.Reg, volatile.LoadUint32(&o.PINTSEL1.Reg)&^(0x1f00)|value<<8)
}
func (o *SCU_Type) GetPINTSEL1_INTPIN5() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL1.Reg) & 0x1f00) >> 8
}
func (o *SCU_Type) SetPINTSEL1_PORTSEL5(value uint32) {
	volatile.StoreUint32(&o.PINTSEL1.Reg, volatile.LoadUint32(&o.PINTSEL1.Reg)&^(0xe000)|value<<13)
}
func (o *SCU_Type) GetPINTSEL1_PORTSEL5() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL1.Reg) & 0xe000) >> 13
}
func (o *SCU_Type) SetPINTSEL1_INTPIN6(value uint32) {
	volatile.StoreUint32(&o.PINTSEL1.Reg, volatile.LoadUint32(&o.PINTSEL1.Reg)&^(0x1f0000)|value<<16)
}
func (o *SCU_Type) GetPINTSEL1_INTPIN6() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL1.Reg) & 0x1f0000) >> 16
}
func (o *SCU_Type) SetPINTSEL1_PORTSEL6(value uint32) {
	volatile.StoreUint32(&o.PINTSEL1.Reg, volatile.LoadUint32(&o.PINTSEL1.Reg)&^(0xe00000)|value<<21)
}
func (o *SCU_Type) GetPINTSEL1_PORTSEL6() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL1.Reg) & 0xe00000) >> 21
}
func (o *SCU_Type) SetPINTSEL1_INTPIN7(value uint32) {
	volatile.StoreUint32(&o.PINTSEL1.Reg, volatile.LoadUint32(&o.PINTSEL1.Reg)&^(0x1f000000)|value<<24)
}
func (o *SCU_Type) GetPINTSEL1_INTPIN7() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL1.Reg) & 0x1f000000) >> 24
}
func (o *SCU_Type) SetPINTSEL1_PORTSEL7(value uint32) {
	volatile.StoreUint32(&o.PINTSEL1.Reg, volatile.LoadUint32(&o.PINTSEL1.Reg)&^(0xe0000000)|value<<29)
}
func (o *SCU_Type) GetPINTSEL1_PORTSEL7() uint32 {
	return (volatile.LoadUint32(&o.PINTSEL1.Reg) & 0xe0000000) >> 29
}

// GPIO pin interrupt
type GPIO_PIN_INT_Type struct {
	ISEL  volatile.Register32 // 0x0
	IENR  volatile.Register32 // 0x4
	SIENR volatile.Register32 // 0x8
	CIENR volatile.Register32 // 0xC
	IENF  volatile.Register32 // 0x10
	SIENF volatile.Register32 // 0x14
	CIENF volatile.Register32 // 0x18
	RISE  volatile.Register32 // 0x1C
	FALL  volatile.Register32 // 0x20
	IST   volatile.Register32 // 0x24
}

// GPIO_PIN_INT.ISEL: Pin Interrupt Mode register
func (o *GPIO_PIN_INT_Type) SetISEL_PMODE0(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetISEL_PMODE0() uint32 {
	return volatile.LoadUint32(&o.ISEL.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetISEL_PMODE1(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetISEL_PMODE1() uint32 {
	return (volatile.LoadUint32(&o.ISEL.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetISEL_PMODE2(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetISEL_PMODE2() uint32 {
	return (volatile.LoadUint32(&o.ISEL.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetISEL_PMODE3(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetISEL_PMODE3() uint32 {
	return (volatile.LoadUint32(&o.ISEL.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetISEL_PMODE4(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetISEL_PMODE4() uint32 {
	return (volatile.LoadUint32(&o.ISEL.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetISEL_PMODE5(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetISEL_PMODE5() uint32 {
	return (volatile.LoadUint32(&o.ISEL.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetISEL_PMODE6(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetISEL_PMODE6() uint32 {
	return (volatile.LoadUint32(&o.ISEL.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetISEL_PMODE7(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetISEL_PMODE7() uint32 {
	return (volatile.LoadUint32(&o.ISEL.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetISEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ISEL.Reg, volatile.LoadUint32(&o.ISEL.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetISEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ISEL.Reg) & 0xffffff00) >> 8
}

// GPIO_PIN_INT.IENR: Pin Interrupt Enable (Rising) register
func (o *GPIO_PIN_INT_Type) SetIENR_ENRL0(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetIENR_ENRL0() uint32 {
	return volatile.LoadUint32(&o.IENR.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetIENR_ENRL1(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetIENR_ENRL1() uint32 {
	return (volatile.LoadUint32(&o.IENR.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetIENR_ENRL2(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetIENR_ENRL2() uint32 {
	return (volatile.LoadUint32(&o.IENR.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetIENR_ENRL3(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetIENR_ENRL3() uint32 {
	return (volatile.LoadUint32(&o.IENR.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetIENR_ENRL4(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetIENR_ENRL4() uint32 {
	return (volatile.LoadUint32(&o.IENR.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetIENR_ENRL5(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetIENR_ENRL5() uint32 {
	return (volatile.LoadUint32(&o.IENR.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetIENR_ENRL6(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetIENR_ENRL6() uint32 {
	return (volatile.LoadUint32(&o.IENR.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetIENR_ENRL7(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetIENR_ENRL7() uint32 {
	return (volatile.LoadUint32(&o.IENR.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetIENR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IENR.Reg, volatile.LoadUint32(&o.IENR.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetIENR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IENR.Reg) & 0xffffff00) >> 8
}

// GPIO_PIN_INT.SIENR: Set Pin Interrupt Enable (Rising) register
func (o *GPIO_PIN_INT_Type) SetSIENR_SETENRL0(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetSIENR_SETENRL0() uint32 {
	return volatile.LoadUint32(&o.SIENR.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetSIENR_SETENRL1(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetSIENR_SETENRL1() uint32 {
	return (volatile.LoadUint32(&o.SIENR.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetSIENR_SETENRL2(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetSIENR_SETENRL2() uint32 {
	return (volatile.LoadUint32(&o.SIENR.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetSIENR_SETENRL3(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetSIENR_SETENRL3() uint32 {
	return (volatile.LoadUint32(&o.SIENR.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetSIENR_SETENRL4(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetSIENR_SETENRL4() uint32 {
	return (volatile.LoadUint32(&o.SIENR.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetSIENR_SETENRL5(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetSIENR_SETENRL5() uint32 {
	return (volatile.LoadUint32(&o.SIENR.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetSIENR_SETENRL6(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetSIENR_SETENRL6() uint32 {
	return (volatile.LoadUint32(&o.SIENR.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetSIENR_SETENRL7(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetSIENR_SETENRL7() uint32 {
	return (volatile.LoadUint32(&o.SIENR.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetSIENR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SIENR.Reg, volatile.LoadUint32(&o.SIENR.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetSIENR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SIENR.Reg) & 0xffffff00) >> 8
}

// GPIO_PIN_INT.CIENR: Clear Pin Interrupt Enable (Rising) register
func (o *GPIO_PIN_INT_Type) SetCIENR_CENRL0(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetCIENR_CENRL0() uint32 {
	return volatile.LoadUint32(&o.CIENR.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetCIENR_CENRL1(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetCIENR_CENRL1() uint32 {
	return (volatile.LoadUint32(&o.CIENR.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetCIENR_CENRL2(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetCIENR_CENRL2() uint32 {
	return (volatile.LoadUint32(&o.CIENR.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetCIENR_CENRL3(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetCIENR_CENRL3() uint32 {
	return (volatile.LoadUint32(&o.CIENR.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetCIENR_CENRL4(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetCIENR_CENRL4() uint32 {
	return (volatile.LoadUint32(&o.CIENR.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetCIENR_CENRL5(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetCIENR_CENRL5() uint32 {
	return (volatile.LoadUint32(&o.CIENR.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetCIENR_CENRL6(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetCIENR_CENRL6() uint32 {
	return (volatile.LoadUint32(&o.CIENR.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetCIENR_CENRL7(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetCIENR_CENRL7() uint32 {
	return (volatile.LoadUint32(&o.CIENR.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetCIENR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CIENR.Reg, volatile.LoadUint32(&o.CIENR.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetCIENR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CIENR.Reg) & 0xffffff00) >> 8
}

// GPIO_PIN_INT.IENF: Pin Interrupt Enable Falling Edge / Active Level register
func (o *GPIO_PIN_INT_Type) SetIENF_ENAF0(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetIENF_ENAF0() uint32 {
	return volatile.LoadUint32(&o.IENF.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetIENF_ENAF1(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetIENF_ENAF1() uint32 {
	return (volatile.LoadUint32(&o.IENF.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetIENF_ENAF2(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetIENF_ENAF2() uint32 {
	return (volatile.LoadUint32(&o.IENF.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetIENF_ENAF3(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetIENF_ENAF3() uint32 {
	return (volatile.LoadUint32(&o.IENF.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetIENF_ENAF4(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetIENF_ENAF4() uint32 {
	return (volatile.LoadUint32(&o.IENF.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetIENF_ENAF5(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetIENF_ENAF5() uint32 {
	return (volatile.LoadUint32(&o.IENF.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetIENF_ENAF6(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetIENF_ENAF6() uint32 {
	return (volatile.LoadUint32(&o.IENF.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetIENF_ENAF7(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetIENF_ENAF7() uint32 {
	return (volatile.LoadUint32(&o.IENF.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetIENF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IENF.Reg, volatile.LoadUint32(&o.IENF.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetIENF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IENF.Reg) & 0xffffff00) >> 8
}

// GPIO_PIN_INT.SIENF: Set Pin Interrupt Enable Falling Edge / Active Level register
func (o *GPIO_PIN_INT_Type) SetSIENF_SETENAF0(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetSIENF_SETENAF0() uint32 {
	return volatile.LoadUint32(&o.SIENF.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetSIENF_SETENAF1(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetSIENF_SETENAF1() uint32 {
	return (volatile.LoadUint32(&o.SIENF.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetSIENF_SETENAF2(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetSIENF_SETENAF2() uint32 {
	return (volatile.LoadUint32(&o.SIENF.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetSIENF_SETENAF3(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetSIENF_SETENAF3() uint32 {
	return (volatile.LoadUint32(&o.SIENF.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetSIENF_SETENAF4(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetSIENF_SETENAF4() uint32 {
	return (volatile.LoadUint32(&o.SIENF.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetSIENF_SETENAF5(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetSIENF_SETENAF5() uint32 {
	return (volatile.LoadUint32(&o.SIENF.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetSIENF_SETENAF6(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetSIENF_SETENAF6() uint32 {
	return (volatile.LoadUint32(&o.SIENF.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetSIENF_SETENAF7(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetSIENF_SETENAF7() uint32 {
	return (volatile.LoadUint32(&o.SIENF.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetSIENF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SIENF.Reg, volatile.LoadUint32(&o.SIENF.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetSIENF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SIENF.Reg) & 0xffffff00) >> 8
}

// GPIO_PIN_INT.CIENF: Clear Pin Interrupt Enable Falling Edge / Active Level address
func (o *GPIO_PIN_INT_Type) SetCIENF_CENAF0(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetCIENF_CENAF0() uint32 {
	return volatile.LoadUint32(&o.CIENF.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetCIENF_CENAF1(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetCIENF_CENAF1() uint32 {
	return (volatile.LoadUint32(&o.CIENF.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetCIENF_CENAF2(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetCIENF_CENAF2() uint32 {
	return (volatile.LoadUint32(&o.CIENF.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetCIENF_CENAF3(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetCIENF_CENAF3() uint32 {
	return (volatile.LoadUint32(&o.CIENF.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetCIENF_CENAF4(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetCIENF_CENAF4() uint32 {
	return (volatile.LoadUint32(&o.CIENF.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetCIENF_CENAF5(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetCIENF_CENAF5() uint32 {
	return (volatile.LoadUint32(&o.CIENF.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetCIENF_CENAF6(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetCIENF_CENAF6() uint32 {
	return (volatile.LoadUint32(&o.CIENF.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetCIENF_CENAF7(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetCIENF_CENAF7() uint32 {
	return (volatile.LoadUint32(&o.CIENF.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetCIENF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CIENF.Reg, volatile.LoadUint32(&o.CIENF.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetCIENF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CIENF.Reg) & 0xffffff00) >> 8
}

// GPIO_PIN_INT.RISE: Pin Interrupt Rising Edge register
func (o *GPIO_PIN_INT_Type) SetRISE_RDET0(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetRISE_RDET0() uint32 {
	return volatile.LoadUint32(&o.RISE.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetRISE_RDET1(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetRISE_RDET1() uint32 {
	return (volatile.LoadUint32(&o.RISE.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetRISE_RDET2(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetRISE_RDET2() uint32 {
	return (volatile.LoadUint32(&o.RISE.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetRISE_RDET3(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetRISE_RDET3() uint32 {
	return (volatile.LoadUint32(&o.RISE.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetRISE_RDET4(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetRISE_RDET4() uint32 {
	return (volatile.LoadUint32(&o.RISE.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetRISE_RDET5(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetRISE_RDET5() uint32 {
	return (volatile.LoadUint32(&o.RISE.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetRISE_RDET6(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetRISE_RDET6() uint32 {
	return (volatile.LoadUint32(&o.RISE.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetRISE_RDET7(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetRISE_RDET7() uint32 {
	return (volatile.LoadUint32(&o.RISE.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetRISE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RISE.Reg, volatile.LoadUint32(&o.RISE.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetRISE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RISE.Reg) & 0xffffff00) >> 8
}

// GPIO_PIN_INT.FALL: Pin Interrupt Falling Edge register
func (o *GPIO_PIN_INT_Type) SetFALL_FDET0(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetFALL_FDET0() uint32 {
	return volatile.LoadUint32(&o.FALL.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetFALL_FDET1(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetFALL_FDET1() uint32 {
	return (volatile.LoadUint32(&o.FALL.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetFALL_FDET2(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetFALL_FDET2() uint32 {
	return (volatile.LoadUint32(&o.FALL.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetFALL_FDET3(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetFALL_FDET3() uint32 {
	return (volatile.LoadUint32(&o.FALL.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetFALL_FDET4(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetFALL_FDET4() uint32 {
	return (volatile.LoadUint32(&o.FALL.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetFALL_FDET5(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetFALL_FDET5() uint32 {
	return (volatile.LoadUint32(&o.FALL.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetFALL_FDET6(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetFALL_FDET6() uint32 {
	return (volatile.LoadUint32(&o.FALL.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetFALL_FDET7(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetFALL_FDET7() uint32 {
	return (volatile.LoadUint32(&o.FALL.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetFALL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FALL.Reg, volatile.LoadUint32(&o.FALL.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetFALL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FALL.Reg) & 0xffffff00) >> 8
}

// GPIO_PIN_INT.IST: Pin Interrupt Status register
func (o *GPIO_PIN_INT_Type) SetIST_PSTAT0(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0x1)|value)
}
func (o *GPIO_PIN_INT_Type) GetIST_PSTAT0() uint32 {
	return volatile.LoadUint32(&o.IST.Reg) & 0x1
}
func (o *GPIO_PIN_INT_Type) SetIST_PSTAT1(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PIN_INT_Type) GetIST_PSTAT1() uint32 {
	return (volatile.LoadUint32(&o.IST.Reg) & 0x2) >> 1
}
func (o *GPIO_PIN_INT_Type) SetIST_PSTAT2(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PIN_INT_Type) GetIST_PSTAT2() uint32 {
	return (volatile.LoadUint32(&o.IST.Reg) & 0x4) >> 2
}
func (o *GPIO_PIN_INT_Type) SetIST_PSTAT3(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PIN_INT_Type) GetIST_PSTAT3() uint32 {
	return (volatile.LoadUint32(&o.IST.Reg) & 0x8) >> 3
}
func (o *GPIO_PIN_INT_Type) SetIST_PSTAT4(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PIN_INT_Type) GetIST_PSTAT4() uint32 {
	return (volatile.LoadUint32(&o.IST.Reg) & 0x10) >> 4
}
func (o *GPIO_PIN_INT_Type) SetIST_PSTAT5(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PIN_INT_Type) GetIST_PSTAT5() uint32 {
	return (volatile.LoadUint32(&o.IST.Reg) & 0x20) >> 5
}
func (o *GPIO_PIN_INT_Type) SetIST_PSTAT6(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PIN_INT_Type) GetIST_PSTAT6() uint32 {
	return (volatile.LoadUint32(&o.IST.Reg) & 0x40) >> 6
}
func (o *GPIO_PIN_INT_Type) SetIST_PSTAT7(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PIN_INT_Type) GetIST_PSTAT7() uint32 {
	return (volatile.LoadUint32(&o.IST.Reg) & 0x80) >> 7
}
func (o *GPIO_PIN_INT_Type) SetIST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IST.Reg, volatile.LoadUint32(&o.IST.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPIO_PIN_INT_Type) GetIST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IST.Reg) & 0xffffff00) >> 8
}

// GPIO group interrupt 0
type GPIO_GROUP_INT0_Type struct {
	CTRL      volatile.Register32 // 0x0
	_         [28]byte
	PORT_POL0 volatile.Register32 // 0x20
	PORT_POL1 volatile.Register32 // 0x24
	PORT_POL2 volatile.Register32 // 0x28
	PORT_POL3 volatile.Register32 // 0x2C
	PORT_POL4 volatile.Register32 // 0x30
	PORT_POL5 volatile.Register32 // 0x34
	PORT_POL6 volatile.Register32 // 0x38
	PORT_POL7 volatile.Register32 // 0x3C
	PORT_ENA0 volatile.Register32 // 0x40
	PORT_ENA1 volatile.Register32 // 0x44
	PORT_ENA2 volatile.Register32 // 0x48
	PORT_ENA3 volatile.Register32 // 0x4C
	PORT_ENA4 volatile.Register32 // 0x50
	PORT_ENA5 volatile.Register32 // 0x54
	PORT_ENA6 volatile.Register32 // 0x58
	PORT_ENA7 volatile.Register32 // 0x5C
}

// GPIO_GROUP_INT0.CTRL: GPIO grouped interrupt control register
func (o *GPIO_GROUP_INT0_Type) SetCTRL_INT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetCTRL_INT() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetCTRL_COMB(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetCTRL_COMB() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetCTRL_TRIG(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetCTRL_TRIG() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfffffff8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xfffffff8) >> 3
}

// GPIO_GROUP_INT0.PORT_POL0: GPIO grouped interrupt port polarity register
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_0(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_0() uint32 {
	return volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_1(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_2(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_3(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_4(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_5(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_6(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_7(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_8(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_9(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_10(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_11(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_12(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_13(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_14(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_15(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_16(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_17(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_18(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_19(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_20(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_21(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_22(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_23(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_24(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_25(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_26(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_27(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_28(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_29(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_30(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL0_POL_31(value uint32) {
	volatile.StoreUint32(&o.PORT_POL0.Reg, volatile.LoadUint32(&o.PORT_POL0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL0_POL_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL0.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_POL1: GPIO grouped interrupt port polarity register
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_0(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_0() uint32 {
	return volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_1(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_2(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_3(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_4(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_5(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_6(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_7(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_8(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_9(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_10(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_11(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_12(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_13(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_14(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_15(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_16(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_17(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_18(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_19(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_20(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_21(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_22(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_23(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_24(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_25(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_26(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_27(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_28(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_29(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_30(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL1_POL_31(value uint32) {
	volatile.StoreUint32(&o.PORT_POL1.Reg, volatile.LoadUint32(&o.PORT_POL1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL1_POL_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL1.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_POL2: GPIO grouped interrupt port polarity register
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_0(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_0() uint32 {
	return volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_1(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_2(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_3(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_4(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_5(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_6(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_7(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_8(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_9(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_10(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_11(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_12(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_13(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_14(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_15(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_16(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_17(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_18(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_19(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_20(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_21(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_22(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_23(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_24(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_25(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_26(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_27(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_28(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_29(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_30(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL2_POL_31(value uint32) {
	volatile.StoreUint32(&o.PORT_POL2.Reg, volatile.LoadUint32(&o.PORT_POL2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL2_POL_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL2.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_POL3: GPIO grouped interrupt port polarity register
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_0(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_0() uint32 {
	return volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_1(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_2(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_3(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_4(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_5(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_6(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_7(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_8(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_9(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_10(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_11(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_12(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_13(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_14(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_15(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_16(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_17(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_18(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_19(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_20(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_21(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_22(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_23(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_24(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_25(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_26(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_27(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_28(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_29(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_30(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL3_POL_31(value uint32) {
	volatile.StoreUint32(&o.PORT_POL3.Reg, volatile.LoadUint32(&o.PORT_POL3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL3_POL_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL3.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_POL4: GPIO grouped interrupt port polarity register
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_0(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_0() uint32 {
	return volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_1(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_2(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_3(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_4(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_5(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_6(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_7(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_8(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_9(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_10(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_11(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_12(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_13(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_14(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_15(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_16(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_17(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_18(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_19(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_20(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_21(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_22(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_23(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_24(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_25(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_26(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_27(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_28(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_29(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_30(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL4_POL_31(value uint32) {
	volatile.StoreUint32(&o.PORT_POL4.Reg, volatile.LoadUint32(&o.PORT_POL4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL4_POL_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL4.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_POL5: GPIO grouped interrupt port polarity register
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_0(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_0() uint32 {
	return volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_1(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_2(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_3(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_4(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_5(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_6(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_7(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_8(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_9(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_10(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_11(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_12(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_13(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_14(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_15(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_16(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_17(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_18(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_19(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_20(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_21(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_22(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_23(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_24(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_25(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_26(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_27(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_28(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_29(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_30(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL5_POL_31(value uint32) {
	volatile.StoreUint32(&o.PORT_POL5.Reg, volatile.LoadUint32(&o.PORT_POL5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL5_POL_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL5.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_POL6: GPIO grouped interrupt port polarity register
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_0(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_0() uint32 {
	return volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_1(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_2(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_3(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_4(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_5(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_6(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_7(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_8(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_9(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_10(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_11(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_12(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_13(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_14(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_15(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_16(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_17(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_18(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_19(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_20(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_21(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_22(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_23(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_24(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_25(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_26(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_27(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_28(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_29(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_30(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL6_POL_31(value uint32) {
	volatile.StoreUint32(&o.PORT_POL6.Reg, volatile.LoadUint32(&o.PORT_POL6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL6_POL_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL6.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_POL7: GPIO grouped interrupt port polarity register
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_0(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_0() uint32 {
	return volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_1(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_2(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_3(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_4(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_5(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_6(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_7(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_8(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_9(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_10(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_11(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_12(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_13(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_14(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_15(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_16(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_17(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_18(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_19(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_20(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_21(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_22(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_23(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_24(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_25(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_26(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_27(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_28(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_29(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_30(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_POL7_POL_31(value uint32) {
	volatile.StoreUint32(&o.PORT_POL7.Reg, volatile.LoadUint32(&o.PORT_POL7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_POL7_POL_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_POL7.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_ENA0: GPIO grouped interrupt port m enable register
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_0(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_0() uint32 {
	return volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_1(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_2(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_3(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_4(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_5(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_6(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_7(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_8(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_9(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_10(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_11(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_12(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_13(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_14(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_15(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_16(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_17(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_18(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_19(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_20(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_21(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_22(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_23(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_24(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_25(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_26(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_27(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_28(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_29(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_30(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA0_ENA_31(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA0.Reg, volatile.LoadUint32(&o.PORT_ENA0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA0_ENA_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA0.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_ENA1: GPIO grouped interrupt port m enable register
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_0(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_0() uint32 {
	return volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_1(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_2(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_3(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_4(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_5(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_6(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_7(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_8(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_9(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_10(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_11(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_12(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_13(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_14(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_15(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_16(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_17(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_18(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_19(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_20(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_21(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_22(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_23(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_24(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_25(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_26(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_27(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_28(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_29(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_30(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA1_ENA_31(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA1.Reg, volatile.LoadUint32(&o.PORT_ENA1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA1_ENA_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA1.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_ENA2: GPIO grouped interrupt port m enable register
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_0(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_0() uint32 {
	return volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_1(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_2(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_3(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_4(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_5(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_6(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_7(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_8(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_9(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_10(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_11(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_12(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_13(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_14(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_15(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_16(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_17(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_18(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_19(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_20(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_21(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_22(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_23(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_24(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_25(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_26(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_27(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_28(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_29(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_30(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA2_ENA_31(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA2.Reg, volatile.LoadUint32(&o.PORT_ENA2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA2_ENA_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA2.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_ENA3: GPIO grouped interrupt port m enable register
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_0(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_0() uint32 {
	return volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_1(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_2(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_3(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_4(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_5(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_6(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_7(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_8(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_9(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_10(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_11(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_12(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_13(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_14(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_15(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_16(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_17(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_18(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_19(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_20(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_21(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_22(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_23(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_24(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_25(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_26(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_27(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_28(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_29(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_30(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA3_ENA_31(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA3.Reg, volatile.LoadUint32(&o.PORT_ENA3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA3_ENA_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA3.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_ENA4: GPIO grouped interrupt port m enable register
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_0(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_0() uint32 {
	return volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_1(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_2(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_3(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_4(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_5(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_6(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_7(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_8(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_9(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_10(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_11(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_12(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_13(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_14(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_15(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_16(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_17(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_18(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_19(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_20(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_21(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_22(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_23(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_24(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_25(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_26(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_27(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_28(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_29(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_30(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA4_ENA_31(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA4.Reg, volatile.LoadUint32(&o.PORT_ENA4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA4_ENA_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA4.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_ENA5: GPIO grouped interrupt port m enable register
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_0(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_0() uint32 {
	return volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_1(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_2(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_3(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_4(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_5(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_6(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_7(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_8(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_9(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_10(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_11(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_12(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_13(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_14(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_15(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_16(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_17(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_18(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_19(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_20(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_21(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_22(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_23(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_24(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_25(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_26(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_27(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_28(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_29(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_30(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA5_ENA_31(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA5.Reg, volatile.LoadUint32(&o.PORT_ENA5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA5_ENA_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA5.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_ENA6: GPIO grouped interrupt port m enable register
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_0(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_0() uint32 {
	return volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_1(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_2(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_3(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_4(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_5(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_6(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_7(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_8(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_9(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_10(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_11(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_12(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_13(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_14(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_15(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_16(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_17(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_18(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_19(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_20(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_21(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_22(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_23(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_24(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_25(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_26(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_27(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_28(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_29(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_30(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA6_ENA_31(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA6.Reg, volatile.LoadUint32(&o.PORT_ENA6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA6_ENA_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA6.Reg) & 0x80000000) >> 31
}

// GPIO_GROUP_INT0.PORT_ENA7: GPIO grouped interrupt port m enable register
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_0(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x1)|value)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_0() uint32 {
	return volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_1(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_1() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x2) >> 1
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_2(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_2() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x4) >> 2
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_3(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_3() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x8) >> 3
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_4(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_4() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x10) >> 4
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_5(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_5() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x20) >> 5
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_6(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_6() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x40) >> 6
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_7(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_7() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x80) >> 7
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_8(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_8() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x100) >> 8
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_9(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_9() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x200) >> 9
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_10(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_10() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x400) >> 10
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_11(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_11() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x800) >> 11
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_12(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_12() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x1000) >> 12
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_13(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_13() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x2000) >> 13
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_14(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_14() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x4000) >> 14
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_15(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_15() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x8000) >> 15
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_16(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_16() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x10000) >> 16
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_17(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_17() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x20000) >> 17
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_18(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_18() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x40000) >> 18
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_19(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_19() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x80000) >> 19
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_20(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_20() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x100000) >> 20
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_21(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_21() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x200000) >> 21
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_22(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_22() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x400000) >> 22
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_23(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_23() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x800000) >> 23
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_24(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_24() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x1000000) >> 24
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_25(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_25() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x2000000) >> 25
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_26(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_26() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x4000000) >> 26
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_27(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_27() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x8000000) >> 27
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_28(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_28() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x10000000) >> 28
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_29(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_29() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x20000000) >> 29
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_30(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_30() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x40000000) >> 30
}
func (o *GPIO_GROUP_INT0_Type) SetPORT_ENA7_ENA_31(value uint32) {
	volatile.StoreUint32(&o.PORT_ENA7.Reg, volatile.LoadUint32(&o.PORT_ENA7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_GROUP_INT0_Type) GetPORT_ENA7_ENA_31() uint32 {
	return (volatile.LoadUint32(&o.PORT_ENA7.Reg) & 0x80000000) >> 31
}

// Motor Control PWM (MOTOCONPWM)
type MCPWM_Type struct {
	CON        volatile.Register32 // 0x0
	CON_SET    volatile.Register32 // 0x4
	CON_CLR    volatile.Register32 // 0x8
	CAPCON     volatile.Register32 // 0xC
	CAPCON_SET volatile.Register32 // 0x10
	CAPCON_CLR volatile.Register32 // 0x14
	TC0        volatile.Register32 // 0x18
	TC1        volatile.Register32 // 0x1C
	TC2        volatile.Register32 // 0x20
	LIM0       volatile.Register32 // 0x24
	LIM1       volatile.Register32 // 0x28
	LIM2       volatile.Register32 // 0x2C
	MAT0       volatile.Register32 // 0x30
	MAT1       volatile.Register32 // 0x34
	MAT2       volatile.Register32 // 0x38
	DT         volatile.Register32 // 0x3C
	CCP        volatile.Register32 // 0x40
	CAP0       volatile.Register32 // 0x44
	CAP1       volatile.Register32 // 0x48
	CAP2       volatile.Register32 // 0x4C
	INTEN      volatile.Register32 // 0x50
	INTEN_SET  volatile.Register32 // 0x54
	INTEN_CLR  volatile.Register32 // 0x58
	CNTCON     volatile.Register32 // 0x5C
	CNTCON_SET volatile.Register32 // 0x60
	CNTCON_CLR volatile.Register32 // 0x64
	INTF       volatile.Register32 // 0x68
	INTF_SET   volatile.Register32 // 0x6C
	INTF_CLR   volatile.Register32 // 0x70
	CAP_CLR    volatile.Register32 // 0x74
}

// MCPWM.CON: PWM Control read address
func (o *MCPWM_Type) SetCON_RUN0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCON_RUN0() uint32 {
	return volatile.LoadUint32(&o.CON.Reg) & 0x1
}
func (o *MCPWM_Type) SetCON_CENTER0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCON_CENTER0() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCON_POLA0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCON_POLA0() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCON_DTE0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCON_DTE0() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCON_DISUP0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCON_DISUP0() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0xe0)|value<<5)
}
func (o *MCPWM_Type) GetCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0xe0) >> 5
}
func (o *MCPWM_Type) SetCON_RUN1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCON_RUN1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCON_CENTER1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCON_CENTER1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCON_POLA1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCON_POLA1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCON_DTE1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCON_DTE1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCON_DISUP1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCON_DISUP1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0xe000)|value<<13)
}
func (o *MCPWM_Type) GetCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0xe000) >> 13
}
func (o *MCPWM_Type) SetCON_RUN2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCON_RUN2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCON_CENTER2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCON_CENTER2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCON_POLA2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCON_POLA2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCON_DTE2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCON_DTE2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCON_DISUP2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCON_DISUP2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x1fe00000)|value<<21)
}
func (o *MCPWM_Type) GetCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x1fe00000) >> 21
}
func (o *MCPWM_Type) SetCON_INVBDC(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCON_INVBDC() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCON_ACMODE(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCON_ACMODE() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCON_DCMODE(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCON_DCMODE() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x80000000) >> 31
}

// MCPWM.CON_SET: PWM Control set address
func (o *MCPWM_Type) SetCON_SET_RUN0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCON_SET_RUN0_SET() uint32 {
	return volatile.LoadUint32(&o.CON_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetCON_SET_CENTER0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCON_SET_CENTER0_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCON_SET_POLA0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCON_SET_POLA0_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCON_SET_DTE0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCON_SET_DTE0_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCON_SET_DISUP0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCON_SET_DISUP0_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0xe0)|value<<5)
}
func (o *MCPWM_Type) GetCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0xe0) >> 5
}
func (o *MCPWM_Type) SetCON_SET_RUN1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCON_SET_RUN1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCON_SET_CENTER1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCON_SET_CENTER1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCON_SET_POLA1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCON_SET_POLA1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCON_SET_DTE1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCON_SET_DTE1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCON_SET_DISUP1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCON_SET_DISUP1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0xe000)|value<<13)
}
func (o *MCPWM_Type) GetCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0xe000) >> 13
}
func (o *MCPWM_Type) SetCON_SET_RUN2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCON_SET_RUN2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCON_SET_CENTER2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCON_SET_CENTER2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCON_SET_POLA2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCON_SET_POLA2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCON_SET_DTE2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCON_SET_DTE2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCON_SET_DISUP2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCON_SET_DISUP2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x1fe00000)|value<<21)
}
func (o *MCPWM_Type) GetCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x1fe00000) >> 21
}
func (o *MCPWM_Type) SetCON_SET_INVBDC_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCON_SET_INVBDC_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCON_SET_ACMODE_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCON_SET_ACMODE_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCON_SET_DCMODE_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCON_SET_DCMODE_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x80000000) >> 31
}

// MCPWM.CON_CLR: PWM Control clear address
func (o *MCPWM_Type) SetCON_CLR_RUN0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCON_CLR_RUN0_CLR() uint32 {
	return volatile.LoadUint32(&o.CON_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetCON_CLR_CENTER0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCON_CLR_CENTER0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCON_CLR_POLA0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCON_CLR_POLA0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCON_CLR_DTE0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCON_CLR_DTE0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCON_CLR_DISUP0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCON_CLR_DISUP0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0xe0)|value<<5)
}
func (o *MCPWM_Type) GetCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0xe0) >> 5
}
func (o *MCPWM_Type) SetCON_CLR_RUN1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCON_CLR_RUN1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCON_CLR_CENTER1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCON_CLR_CENTER1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCON_CLR_POLA1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCON_CLR_POLA1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCON_CLR_DTE1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCON_CLR_DTE1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCON_CLR_DISUP1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCON_CLR_DISUP1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0xe000)|value<<13)
}
func (o *MCPWM_Type) GetCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0xe000) >> 13
}
func (o *MCPWM_Type) SetCON_CLR_RUN2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCON_CLR_RUN2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCON_CLR_CENTER2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCON_CLR_CENTER2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCON_CLR_POLA2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCON_CLR_POLA2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCON_CLR_DTE2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCON_CLR_DTE2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCON_CLR_DISUP2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCON_CLR_DISUP2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x1fe00000)|value<<21)
}
func (o *MCPWM_Type) GetCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x1fe00000) >> 21
}
func (o *MCPWM_Type) SetCON_CLR_INVBDC_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCON_CLR_INVBDC_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCON_CLR_ACMOD_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCON_CLR_ACMOD_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCON_CLR_DCMODE_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCON_CLR_DCMODE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x80000000) >> 31
}

// MCPWM.CAPCON: Capture Control read address
func (o *MCPWM_Type) SetCAPCON_CAP0MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI0_RE() uint32 {
	return volatile.LoadUint32(&o.CAPCON.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI0_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI0_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCAPCON_RT0(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCAPCON_RT0() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCAPCON_RT1(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCAPCON_RT1() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCAPCON_RT2(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCAPCON_RT2() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCAPCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0xffe00000)|value<<21)
}
func (o *MCPWM_Type) GetCAPCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0xffe00000) >> 21
}

// MCPWM.CAPCON_SET: Capture Control set address
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI0_RE_SET() uint32 {
	return volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI0_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI0_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCAPCON_SET_RT0_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCAPCON_SET_RT0_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCAPCON_SET_RT1_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCAPCON_SET_RT1_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCAPCON_SET_RT2_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCAPCON_SET_RT2_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCAPCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0xffe00000)|value<<21)
}
func (o *MCPWM_Type) GetCAPCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0xffe00000) >> 21
}

// MCPWM.CAPCON_CLR: Event Control clear address
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI0_RE_CLR() uint32 {
	return volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI0_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI0_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCAPCON_CLR_RT0_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCAPCON_CLR_RT0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCAPCON_CLR_RT1_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCAPCON_CLR_RT1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCAPCON_CLR_RT2_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCAPCON_CLR_RT2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCAPCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0xffe00000)|value<<21)
}
func (o *MCPWM_Type) GetCAPCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0xffe00000) >> 21
}

// MCPWM.TC0: Timer Counter register
func (o *MCPWM_Type) SetTC0(value uint32) {
	volatile.StoreUint32(&o.TC0.Reg, value)
}
func (o *MCPWM_Type) GetTC0() uint32 {
	return volatile.LoadUint32(&o.TC0.Reg)
}

// MCPWM.TC1: Timer Counter register
func (o *MCPWM_Type) SetTC1(value uint32) {
	volatile.StoreUint32(&o.TC1.Reg, value)
}
func (o *MCPWM_Type) GetTC1() uint32 {
	return volatile.LoadUint32(&o.TC1.Reg)
}

// MCPWM.TC2: Timer Counter register
func (o *MCPWM_Type) SetTC2(value uint32) {
	volatile.StoreUint32(&o.TC2.Reg, value)
}
func (o *MCPWM_Type) GetTC2() uint32 {
	return volatile.LoadUint32(&o.TC2.Reg)
}

// MCPWM.LIM0: Limit register
func (o *MCPWM_Type) SetLIM0(value uint32) {
	volatile.StoreUint32(&o.LIM0.Reg, value)
}
func (o *MCPWM_Type) GetLIM0() uint32 {
	return volatile.LoadUint32(&o.LIM0.Reg)
}

// MCPWM.LIM1: Limit register
func (o *MCPWM_Type) SetLIM1(value uint32) {
	volatile.StoreUint32(&o.LIM1.Reg, value)
}
func (o *MCPWM_Type) GetLIM1() uint32 {
	return volatile.LoadUint32(&o.LIM1.Reg)
}

// MCPWM.LIM2: Limit register
func (o *MCPWM_Type) SetLIM2(value uint32) {
	volatile.StoreUint32(&o.LIM2.Reg, value)
}
func (o *MCPWM_Type) GetLIM2() uint32 {
	return volatile.LoadUint32(&o.LIM2.Reg)
}

// MCPWM.MAT0: Match register
func (o *MCPWM_Type) SetMAT0(value uint32) {
	volatile.StoreUint32(&o.MAT0.Reg, value)
}
func (o *MCPWM_Type) GetMAT0() uint32 {
	return volatile.LoadUint32(&o.MAT0.Reg)
}

// MCPWM.MAT1: Match register
func (o *MCPWM_Type) SetMAT1(value uint32) {
	volatile.StoreUint32(&o.MAT1.Reg, value)
}
func (o *MCPWM_Type) GetMAT1() uint32 {
	return volatile.LoadUint32(&o.MAT1.Reg)
}

// MCPWM.MAT2: Match register
func (o *MCPWM_Type) SetMAT2(value uint32) {
	volatile.StoreUint32(&o.MAT2.Reg, value)
}
func (o *MCPWM_Type) GetMAT2() uint32 {
	return volatile.LoadUint32(&o.MAT2.Reg)
}

// MCPWM.DT: Dead time register
func (o *MCPWM_Type) SetDT_DT0(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0x3ff)|value)
}
func (o *MCPWM_Type) GetDT_DT0() uint32 {
	return volatile.LoadUint32(&o.DT.Reg) & 0x3ff
}
func (o *MCPWM_Type) SetDT_DT1(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0xffc00)|value<<10)
}
func (o *MCPWM_Type) GetDT_DT1() uint32 {
	return (volatile.LoadUint32(&o.DT.Reg) & 0xffc00) >> 10
}
func (o *MCPWM_Type) SetDT_DT2(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0x3ff00000)|value<<20)
}
func (o *MCPWM_Type) GetDT_DT2() uint32 {
	return (volatile.LoadUint32(&o.DT.Reg) & 0x3ff00000) >> 20
}
func (o *MCPWM_Type) SetDT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0xc0000000)|value<<30)
}
func (o *MCPWM_Type) GetDT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DT.Reg) & 0xc0000000) >> 30
}

// MCPWM.CCP: Communication Pattern register
func (o *MCPWM_Type) SetCCP_CCPA0(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCCP_CCPA0() uint32 {
	return volatile.LoadUint32(&o.CCP.Reg) & 0x1
}
func (o *MCPWM_Type) SetCCP_CCPB0(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCCP_CCPB0() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCCP_CCPA1(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCCP_CCPA1() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCCP_CCPB1(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCCP_CCPB1() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCCP_CCPA2(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCCP_CCPA2() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCCP_CCPB2(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCCP_CCPB2() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCCP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0xffffffc0)|value<<6)
}
func (o *MCPWM_Type) GetCCP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0xffffffc0) >> 6
}

// MCPWM.CAP0: Capture register
func (o *MCPWM_Type) SetCAP0(value uint32) {
	volatile.StoreUint32(&o.CAP0.Reg, value)
}
func (o *MCPWM_Type) GetCAP0() uint32 {
	return volatile.LoadUint32(&o.CAP0.Reg)
}

// MCPWM.CAP1: Capture register
func (o *MCPWM_Type) SetCAP1(value uint32) {
	volatile.StoreUint32(&o.CAP1.Reg, value)
}
func (o *MCPWM_Type) GetCAP1() uint32 {
	return volatile.LoadUint32(&o.CAP1.Reg)
}

// MCPWM.CAP2: Capture register
func (o *MCPWM_Type) SetCAP2(value uint32) {
	volatile.StoreUint32(&o.CAP2.Reg, value)
}
func (o *MCPWM_Type) GetCAP2() uint32 {
	return volatile.LoadUint32(&o.CAP2.Reg)
}

// MCPWM.INTEN: Interrupt Enable read address
func (o *MCPWM_Type) SetINTEN_ILIM0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTEN_ILIM0() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTEN_IMAT0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTEN_IMAT0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTEN_ICAP0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTEN_ICAP0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTEN_ILIM1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTEN_ILIM1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTEN_IMAT1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTEN_IMAT1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTEN_ICAP1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTEN_ICAP1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTEN_ILIM2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTEN_ILIM2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTEN_IMAT2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTEN_IMAT2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTEN_ICAP2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTEN_ICAP2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTEN_ABORT(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTEN_ABORT() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0xffff0000) >> 16
}

// MCPWM.INTEN_SET: Interrupt Enable set address
func (o *MCPWM_Type) SetINTEN_SET_ILIM0_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTEN_SET_ILIM0_SET() uint32 {
	return volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTEN_SET_IMAT0_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTEN_SET_IMAT0_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTEN_SET_ICAP0_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTEN_SET_ICAP0_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTEN_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTEN_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTEN_SET_ILIM1_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTEN_SET_ILIM1_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTEN_SET_IMAT1_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTEN_SET_IMAT1_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTEN_SET_ICAP1_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTEN_SET_ICAP1_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTEN_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTEN_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTEN_SET_ILIM2_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTEN_SET_ILIM2_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTEN_SET_IMAT2_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTEN_SET_IMAT2_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTEN_SET_ICAP2_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetINTEN_SET_ICAP2_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetINTEN_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x7000)|value<<12)
}
func (o *MCPWM_Type) GetINTEN_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x7000) >> 12
}
func (o *MCPWM_Type) SetINTEN_SET_ABORT_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTEN_SET_ABORT_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTEN_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTEN_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0xffff0000) >> 16
}

// MCPWM.INTEN_CLR: Interrupt Enable clear address
func (o *MCPWM_Type) SetINTEN_CLR_ILIM0_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTEN_CLR_ILIM0_CLR() uint32 {
	return volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTEN_CLR_IMAT0_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTEN_CLR_IMAT0_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTEN_CLR_ICAP0_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTEN_CLR_ICAP0_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTEN_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTEN_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTEN_CLR_ILIM1_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTEN_CLR_ILIM1_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTEN_CLR_IMAT1_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTEN_CLR_IMAT1_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTEN_CLR_ICAP1_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTEN_CLR_ICAP1_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTEN_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTEN_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTEN_CLR_ILIM2_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTEN_CLR_ILIM2_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTEN_CLR_IMAT2_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTEN_CLR_IMAT2_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTEN_CLR_ICAP2_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTEN_CLR_ICAP2_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTEN_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTEN_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTEN_CLR_ABORT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTEN_CLR_ABORT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTEN_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTEN_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0xffff0000) >> 16
}

// MCPWM.CNTCON: Count Control read address
func (o *MCPWM_Type) SetCNTCON_TC0MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI0_RE() uint32 {
	return volatile.LoadUint32(&o.CNTCON.Reg) & 0x1
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI0_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI0_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCNTCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *MCPWM_Type) GetCNTCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x1ffc0000) >> 18
}
func (o *MCPWM_Type) SetCNTCON_CNTR0(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCNTCON_CNTR0() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCNTCON_CNTR1(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCNTCON_CNTR1() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCNTCON_CNTR2(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCNTCON_CNTR2() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x80000000) >> 31
}

// MCPWM.CNTCON_SET: Count Control set address
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI0_RE_SET() uint32 {
	return volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI0_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI0_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCNTCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *MCPWM_Type) GetCNTCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x1ffc0000) >> 18
}
func (o *MCPWM_Type) SetCNTCON_SET_CNTR0_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCNTCON_SET_CNTR0_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCNTCON_SET_CNTR1_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCNTCON_SET_CNTR1_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCNTCON_SET_CNTR2_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCNTCON_SET_CNTR2_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x80000000) >> 31
}

// MCPWM.CNTCON_CLR: Count Control clear address
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI0_RE_CLR() uint32 {
	return volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI0_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI0_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCNTCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *MCPWM_Type) GetCNTCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x1ffc0000) >> 18
}
func (o *MCPWM_Type) SetCNTCON_CLR_CNTR0_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCNTCON_CLR_CNTR0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCNTCON_CLR_CNTR1_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCNTCON_CLR_CNTR1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCNTCON_CLR_CNTR2_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCNTCON_CLR_CNTR2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x80000000) >> 31
}

// MCPWM.INTF: Interrupt flags read address
func (o *MCPWM_Type) SetINTF_ILIM0_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTF_ILIM0_F() uint32 {
	return volatile.LoadUint32(&o.INTF.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTF_IMAT0_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTF_IMAT0_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTF_ICAP0_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTF_ICAP0_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTF_ILIM1_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTF_ILIM1_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTF_IMAT1_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTF_IMAT1_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTF_ICAP1_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTF_ICAP1_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTF_ILIM2_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTF_ILIM2_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTF_IMAT2_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTF_IMAT2_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTF_ICAP2_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTF_ICAP2_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTF_ABORT_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTF_ABORT_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0xffff0000) >> 16
}

// MCPWM.INTF_SET: Interrupt flags set address
func (o *MCPWM_Type) SetINTF_SET_ILIM0_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTF_SET_ILIM0_F_SET() uint32 {
	return volatile.LoadUint32(&o.INTF_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTF_SET_IMAT0_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTF_SET_IMAT0_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTF_SET_ICAP0_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTF_SET_ICAP0_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTF_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTF_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTF_SET_ILIM1_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTF_SET_ILIM1_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTF_SET_IMAT1_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTF_SET_IMAT1_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTF_SET_ICAP1_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTF_SET_ICAP1_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTF_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTF_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTF_SET_ILIM2_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTF_SET_ILIM2_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTF_SET_IMAT2_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTF_SET_IMAT2_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTF_SET_ICAP2_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTF_SET_ICAP2_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTF_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTF_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTF_SET_ABORT_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTF_SET_ABORT_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTF_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTF_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0xffff0000) >> 16
}

// MCPWM.INTF_CLR: Interrupt flags clear address
func (o *MCPWM_Type) SetINTF_CLR_ILIM0_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTF_CLR_ILIM0_F_CLR() uint32 {
	return volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTF_CLR_IMAT0_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTF_CLR_IMAT0_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTF_CLR_ICAP0_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTF_CLR_ICAP0_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTF_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTF_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTF_CLR_ILIM1_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTF_CLR_ILIM1_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTF_CLR_IMAT1_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTF_CLR_IMAT1_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTF_CLR_ICAP1_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTF_CLR_ICAP1_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTF_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTF_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTF_CLR_ILIM2_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTF_CLR_ILIM2_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTF_CLR_IMAT2_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTF_CLR_IMAT2_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTF_CLR_ICAP2_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTF_CLR_ICAP2_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTF_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTF_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTF_CLR_ABORT_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTF_CLR_ABORT_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTF_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTF_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0xffff0000) >> 16
}

// MCPWM.CAP_CLR: Capture clear address
func (o *MCPWM_Type) SetCAP_CLR_CAP_CLR0(value uint32) {
	volatile.StoreUint32(&o.CAP_CLR.Reg, volatile.LoadUint32(&o.CAP_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAP_CLR_CAP_CLR0() uint32 {
	return volatile.LoadUint32(&o.CAP_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAP_CLR_CAP_CLR1(value uint32) {
	volatile.StoreUint32(&o.CAP_CLR.Reg, volatile.LoadUint32(&o.CAP_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAP_CLR_CAP_CLR1() uint32 {
	return (volatile.LoadUint32(&o.CAP_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAP_CLR_CAP_CLR2(value uint32) {
	volatile.StoreUint32(&o.CAP_CLR.Reg, volatile.LoadUint32(&o.CAP_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCAP_CLR_CAP_CLR2() uint32 {
	return (volatile.LoadUint32(&o.CAP_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCAP_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP_CLR.Reg, volatile.LoadUint32(&o.CAP_CLR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *MCPWM_Type) GetCAP_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP_CLR.Reg) & 0xfffffff8) >> 3
}

// I2C-bus interface
type I2C_Type struct {
	CONSET      volatile.Register32 // 0x0
	STAT        volatile.Register32 // 0x4
	DAT         volatile.Register32 // 0x8
	ADR0        volatile.Register32 // 0xC
	SCLH        volatile.Register32 // 0x10
	SCLL        volatile.Register32 // 0x14
	CONCLR      volatile.Register32 // 0x18
	MMCTRL      volatile.Register32 // 0x1C
	ADR1        volatile.Register32 // 0x20
	ADR2        volatile.Register32 // 0x24
	ADR3        volatile.Register32 // 0x28
	DATA_BUFFER volatile.Register32 // 0x2C
	MASK0       volatile.Register32 // 0x30
	MASK1       volatile.Register32 // 0x34
	MASK2       volatile.Register32 // 0x38
	MASK3       volatile.Register32 // 0x3C
}

// I2C.CONSET: I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
func (o *I2C_Type) SetCONSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x3)|value)
}
func (o *I2C_Type) GetCONSET_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CONSET.Reg) & 0x3
}
func (o *I2C_Type) SetCONSET_AA(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCONSET_AA() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCONSET_SI(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCONSET_SI() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCONSET_STO(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCONSET_STO() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCONSET_STA(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCONSET_STA() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCONSET_I2EN(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCONSET_I2EN() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCONSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0xffffff80)|value<<7)
}
func (o *I2C_Type) GetCONSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0xffffff80) >> 7
}

// I2C.STAT: I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
func (o *I2C_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x7)|value)
}
func (o *I2C_Type) GetSTAT_RESERVED() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x7
}
func (o *I2C_Type) SetSTAT_Status(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xf8)|value<<3)
}
func (o *I2C_Type) GetSTAT_Status() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xf8) >> 3
}
func (o *I2C_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xffffff00) >> 8
}

// I2C.DAT: I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
func (o *I2C_Type) SetDAT_Data(value uint32) {
	volatile.StoreUint32(&o.DAT.Reg, volatile.LoadUint32(&o.DAT.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetDAT_Data() uint32 {
	return volatile.LoadUint32(&o.DAT.Reg) & 0xff
}
func (o *I2C_Type) SetDAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DAT.Reg, volatile.LoadUint32(&o.DAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetDAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DAT.Reg) & 0xffffff00) >> 8
}

// I2C.ADR0: I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR0_GC(value uint32) {
	volatile.StoreUint32(&o.ADR0.Reg, volatile.LoadUint32(&o.ADR0.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR0_GC() uint32 {
	return volatile.LoadUint32(&o.ADR0.Reg) & 0x1
}
func (o *I2C_Type) SetADR0_Address(value uint32) {
	volatile.StoreUint32(&o.ADR0.Reg, volatile.LoadUint32(&o.ADR0.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR0_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR0.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR0.Reg, volatile.LoadUint32(&o.ADR0.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR0.Reg) & 0xffffff00) >> 8
}

// I2C.SCLH: SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
func (o *I2C_Type) SetSCLH(value uint32) {
	volatile.StoreUint32(&o.SCLH.Reg, volatile.LoadUint32(&o.SCLH.Reg)&^(0xffff)|value)
}
func (o *I2C_Type) GetSCLH() uint32 {
	return volatile.LoadUint32(&o.SCLH.Reg) & 0xffff
}
func (o *I2C_Type) SetSCLH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCLH.Reg, volatile.LoadUint32(&o.SCLH.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2C_Type) GetSCLH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCLH.Reg) & 0xffff0000) >> 16
}

// I2C.SCLL: SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
func (o *I2C_Type) SetSCLL(value uint32) {
	volatile.StoreUint32(&o.SCLL.Reg, volatile.LoadUint32(&o.SCLL.Reg)&^(0xffff)|value)
}
func (o *I2C_Type) GetSCLL() uint32 {
	return volatile.LoadUint32(&o.SCLL.Reg) & 0xffff
}
func (o *I2C_Type) SetSCLL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCLL.Reg, volatile.LoadUint32(&o.SCLL.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2C_Type) GetSCLL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCLL.Reg) & 0xffff0000) >> 16
}

// I2C.CONCLR: I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x3)|value)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CONCLR.Reg) & 0x3
}
func (o *I2C_Type) SetCONCLR_AAC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCONCLR_AAC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCONCLR_SIC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCONCLR_SIC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCONCLR_STAC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCONCLR_STAC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCONCLR_I2ENC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCONCLR_I2ENC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0xffffff00) >> 8
}

// I2C.MMCTRL: Monitor mode control register.
func (o *I2C_Type) SetMMCTRL_MM_ENA(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMMCTRL_MM_ENA() uint32 {
	return volatile.LoadUint32(&o.MMCTRL.Reg) & 0x1
}
func (o *I2C_Type) SetMMCTRL_ENA_SCL(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetMMCTRL_ENA_SCL() uint32 {
	return (volatile.LoadUint32(&o.MMCTRL.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetMMCTRL_MATCH_ALL(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetMMCTRL_MATCH_ALL() uint32 {
	return (volatile.LoadUint32(&o.MMCTRL.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetMMCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0xfffffff8)|value<<3)
}
func (o *I2C_Type) GetMMCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MMCTRL.Reg) & 0xfffffff8) >> 3
}

// I2C.ADR1: I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR1_GC(value uint32) {
	volatile.StoreUint32(&o.ADR1.Reg, volatile.LoadUint32(&o.ADR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR1_GC() uint32 {
	return volatile.LoadUint32(&o.ADR1.Reg) & 0x1
}
func (o *I2C_Type) SetADR1_Address(value uint32) {
	volatile.StoreUint32(&o.ADR1.Reg, volatile.LoadUint32(&o.ADR1.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR1_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR1.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR1.Reg, volatile.LoadUint32(&o.ADR1.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR1.Reg) & 0xffffff00) >> 8
}

// I2C.ADR2: I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR2_GC(value uint32) {
	volatile.StoreUint32(&o.ADR2.Reg, volatile.LoadUint32(&o.ADR2.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR2_GC() uint32 {
	return volatile.LoadUint32(&o.ADR2.Reg) & 0x1
}
func (o *I2C_Type) SetADR2_Address(value uint32) {
	volatile.StoreUint32(&o.ADR2.Reg, volatile.LoadUint32(&o.ADR2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR2_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR2.Reg, volatile.LoadUint32(&o.ADR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR2.Reg) & 0xffffff00) >> 8
}

// I2C.ADR3: I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR3_GC(value uint32) {
	volatile.StoreUint32(&o.ADR3.Reg, volatile.LoadUint32(&o.ADR3.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR3_GC() uint32 {
	return volatile.LoadUint32(&o.ADR3.Reg) & 0x1
}
func (o *I2C_Type) SetADR3_Address(value uint32) {
	volatile.StoreUint32(&o.ADR3.Reg, volatile.LoadUint32(&o.ADR3.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR3_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR3.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR3.Reg, volatile.LoadUint32(&o.ADR3.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR3.Reg) & 0xffffff00) >> 8
}

// I2C.DATA_BUFFER: Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
func (o *I2C_Type) SetDATA_BUFFER_Data(value uint32) {
	volatile.StoreUint32(&o.DATA_BUFFER.Reg, volatile.LoadUint32(&o.DATA_BUFFER.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetDATA_BUFFER_Data() uint32 {
	return volatile.LoadUint32(&o.DATA_BUFFER.Reg) & 0xff
}
func (o *I2C_Type) SetDATA_BUFFER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DATA_BUFFER.Reg, volatile.LoadUint32(&o.DATA_BUFFER.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetDATA_BUFFER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DATA_BUFFER.Reg) & 0xffffff00) >> 8
}

// I2C.MASK0: I2C Slave address mask register
func (o *I2C_Type) SetMASK0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMASK0_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MASK0.Reg) & 0x1
}
func (o *I2C_Type) SetMASK0_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetMASK0_MASK() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetMASK0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetMASK0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0xffffff00) >> 8
}

// I2C.MASK1: I2C Slave address mask register
func (o *I2C_Type) SetMASK1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMASK1_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MASK1.Reg) & 0x1
}
func (o *I2C_Type) SetMASK1_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetMASK1_MASK() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetMASK1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetMASK1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0xffffff00) >> 8
}

// I2C.MASK2: I2C Slave address mask register
func (o *I2C_Type) SetMASK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMASK2_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MASK2.Reg) & 0x1
}
func (o *I2C_Type) SetMASK2_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetMASK2_MASK() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetMASK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetMASK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0xffffff00) >> 8
}

// I2C.MASK3: I2C Slave address mask register
func (o *I2C_Type) SetMASK3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMASK3_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MASK3.Reg) & 0x1
}
func (o *I2C_Type) SetMASK3_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetMASK3_MASK() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetMASK3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetMASK3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0xffffff00) >> 8
}

// I2S interface
type I2S_Type struct {
	DAO       volatile.Register32 // 0x0
	DAI       volatile.Register32 // 0x4
	TXFIFO    volatile.Register32 // 0x8
	RXFIFO    volatile.Register32 // 0xC
	STATE     volatile.Register32 // 0x10
	DMA1      volatile.Register32 // 0x14
	DMA2      volatile.Register32 // 0x18
	IRQ       volatile.Register32 // 0x1C
	TXRATE    volatile.Register32 // 0x20
	RXRATE    volatile.Register32 // 0x24
	TXBITRATE volatile.Register32 // 0x28
	RXBITRATE volatile.Register32 // 0x2C
	TXMODE    volatile.Register32 // 0x30
	RXMODE    volatile.Register32 // 0x34
}

// I2S.DAO: I2S Digital Audio Output Register. Contains control bits for the I2S transmit channel.
func (o *I2S_Type) SetDAO_WORDWIDTH(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetDAO_WORDWIDTH() uint32 {
	return volatile.LoadUint32(&o.DAO.Reg) & 0x3
}
func (o *I2S_Type) SetDAO_MONO(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetDAO_MONO() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetDAO_STOP(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetDAO_STOP() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetDAO_RESET(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetDAO_RESET() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetDAO_WS_SEL(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetDAO_WS_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetDAO_WS_HALFPERIOD(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x7fc0)|value<<6)
}
func (o *I2S_Type) GetDAO_WS_HALFPERIOD() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x7fc0) >> 6
}
func (o *I2S_Type) SetDAO_MUTE(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetDAO_MUTE() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetDAO_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2S_Type) GetDAO_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0xffff0000) >> 16
}

// I2S.DAI: I2S Digital Audio Input Register. Contains control bits for the I2S receive channel.
func (o *I2S_Type) SetDAI_WORDWIDTH(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetDAI_WORDWIDTH() uint32 {
	return volatile.LoadUint32(&o.DAI.Reg) & 0x3
}
func (o *I2S_Type) SetDAI_MONO(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetDAI_MONO() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetDAI_STOP(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetDAI_STOP() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetDAI_RESET(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetDAI_RESET() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetDAI_WS_SEL(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetDAI_WS_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetDAI_WS_HALFPERIOD(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x7fc0)|value<<6)
}
func (o *I2S_Type) GetDAI_WS_HALFPERIOD() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x7fc0) >> 6
}
func (o *I2S_Type) SetDAI_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0xffff8000)|value<<15)
}
func (o *I2S_Type) GetDAI_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0xffff8000) >> 15
}

// I2S.TXFIFO: I2S Transmit FIFO. Access register for the 8 x 32-bit transmitter FIFO.
func (o *I2S_Type) SetTXFIFO(value uint32) {
	volatile.StoreUint32(&o.TXFIFO.Reg, value)
}
func (o *I2S_Type) GetTXFIFO() uint32 {
	return volatile.LoadUint32(&o.TXFIFO.Reg)
}

// I2S.RXFIFO: I2S Receive FIFO. Access register for the 8 x 32-bit receiver FIFO.
func (o *I2S_Type) SetRXFIFO(value uint32) {
	volatile.StoreUint32(&o.RXFIFO.Reg, value)
}
func (o *I2S_Type) GetRXFIFO() uint32 {
	return volatile.LoadUint32(&o.RXFIFO.Reg)
}

// I2S.STATE: I2S Status Feedback Register. Contains status information about the I2S interface.
func (o *I2S_Type) SetSTATE_IRQ(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetSTATE_IRQ() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x1
}
func (o *I2S_Type) SetSTATE_DMAREQ1(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetSTATE_DMAREQ1() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetSTATE_DMAREQ2(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetSTATE_DMAREQ2() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf8)|value<<3)
}
func (o *I2S_Type) GetSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xf8) >> 3
}
func (o *I2S_Type) SetSTATE_RX_LEVEL(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf00)|value<<8)
}
func (o *I2S_Type) GetSTATE_RX_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xf00) >> 8
}
func (o *I2S_Type) SetSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf000)|value<<12)
}
func (o *I2S_Type) GetSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xf000) >> 12
}
func (o *I2S_Type) SetSTATE_TX_LEVEL(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetSTATE_TX_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xf0000) >> 16
}
func (o *I2S_Type) SetSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xfff00000)|value<<20)
}
func (o *I2S_Type) GetSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xfff00000) >> 20
}

// I2S.DMA1: I2S DMA Configuration Register 1. Contains control information for DMA request 1.
func (o *I2S_Type) SetDMA1_RX_DMA1_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetDMA1_RX_DMA1_ENABLE() uint32 {
	return volatile.LoadUint32(&o.DMA1.Reg) & 0x1
}
func (o *I2S_Type) SetDMA1_TX_DMA1_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetDMA1_TX_DMA1_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetDMA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xfc)|value<<2)
}
func (o *I2S_Type) GetDMA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xfc) >> 2
}
func (o *I2S_Type) SetDMA1_RX_DEPTH_DMA1(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xf00)|value<<8)
}
func (o *I2S_Type) GetDMA1_RX_DEPTH_DMA1() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xf00) >> 8
}
func (o *I2S_Type) SetDMA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xf000)|value<<12)
}
func (o *I2S_Type) GetDMA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xf000) >> 12
}
func (o *I2S_Type) SetDMA1_TX_DEPTH_DMA1(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetDMA1_TX_DEPTH_DMA1() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xf0000) >> 16
}
func (o *I2S_Type) SetDMA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xfff00000)|value<<20)
}
func (o *I2S_Type) GetDMA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xfff00000) >> 20
}

// I2S.DMA2: I2S DMA Configuration Register 2. Contains control information for DMA request 2.
func (o *I2S_Type) SetDMA2_RX_DMA2_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetDMA2_RX_DMA2_ENABLE() uint32 {
	return volatile.LoadUint32(&o.DMA2.Reg) & 0x1
}
func (o *I2S_Type) SetDMA2_TX_DMA2_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetDMA2_TX_DMA2_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetDMA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xfc)|value<<2)
}
func (o *I2S_Type) GetDMA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xfc) >> 2
}
func (o *I2S_Type) SetDMA2_RX_DEPTH_DMA2(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xf00)|value<<8)
}
func (o *I2S_Type) GetDMA2_RX_DEPTH_DMA2() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xf00) >> 8
}
func (o *I2S_Type) SetDMA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xf000)|value<<12)
}
func (o *I2S_Type) GetDMA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xf000) >> 12
}
func (o *I2S_Type) SetDMA2_TX_DEPTH_DMA2(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetDMA2_TX_DEPTH_DMA2() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xf0000) >> 16
}
func (o *I2S_Type) SetDMA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xfff00000)|value<<20)
}
func (o *I2S_Type) GetDMA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xfff00000) >> 20
}

// I2S.IRQ: I2S Interrupt Request Control Register. Contains bits that control how the I2S interrupt request is generated.
func (o *I2S_Type) SetIRQ_RX_IRQ_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetIRQ_RX_IRQ_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IRQ.Reg) & 0x1
}
func (o *I2S_Type) SetIRQ_TX_IRQ_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetIRQ_TX_IRQ_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetIRQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xfc)|value<<2)
}
func (o *I2S_Type) GetIRQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xfc) >> 2
}
func (o *I2S_Type) SetIRQ_RX_DEPTH_IRQ(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xf00)|value<<8)
}
func (o *I2S_Type) GetIRQ_RX_DEPTH_IRQ() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xf00) >> 8
}
func (o *I2S_Type) SetIRQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xf000)|value<<12)
}
func (o *I2S_Type) GetIRQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xf000) >> 12
}
func (o *I2S_Type) SetIRQ_TX_DEPTH_IRQ(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetIRQ_TX_DEPTH_IRQ() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xf0000) >> 16
}
func (o *I2S_Type) SetIRQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xfff00000)|value<<20)
}
func (o *I2S_Type) GetIRQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xfff00000) >> 20
}

// I2S.TXRATE: I2S Transmit MCLK divider. This register determines the I2S TX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
func (o *I2S_Type) SetTXRATE_Y_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.TXRATE.Reg, volatile.LoadUint32(&o.TXRATE.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetTXRATE_Y_DIVIDER() uint32 {
	return volatile.LoadUint32(&o.TXRATE.Reg) & 0xff
}
func (o *I2S_Type) SetTXRATE_X_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.TXRATE.Reg, volatile.LoadUint32(&o.TXRATE.Reg)&^(0xff00)|value<<8)
}
func (o *I2S_Type) GetTXRATE_X_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.TXRATE.Reg) & 0xff00) >> 8
}
func (o *I2S_Type) SetTXRATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXRATE.Reg, volatile.LoadUint32(&o.TXRATE.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2S_Type) GetTXRATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXRATE.Reg) & 0xffff0000) >> 16
}

// I2S.RXRATE: I2S Receive MCLK divider. This register determines the I2S RX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
func (o *I2S_Type) SetRXRATE_Y_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.RXRATE.Reg, volatile.LoadUint32(&o.RXRATE.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetRXRATE_Y_DIVIDER() uint32 {
	return volatile.LoadUint32(&o.RXRATE.Reg) & 0xff
}
func (o *I2S_Type) SetRXRATE_X_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.RXRATE.Reg, volatile.LoadUint32(&o.RXRATE.Reg)&^(0xff00)|value<<8)
}
func (o *I2S_Type) GetRXRATE_X_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.RXRATE.Reg) & 0xff00) >> 8
}
func (o *I2S_Type) SetRXRATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXRATE.Reg, volatile.LoadUint32(&o.RXRATE.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2S_Type) GetRXRATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXRATE.Reg) & 0xffff0000) >> 16
}

// I2S.TXBITRATE: I2S Transmit bit rate divider. This register determines the I2S transmit bit rate by specifying the value to divide TX_MCLK by in order to produce the transmit bit clock.
func (o *I2S_Type) SetTXBITRATE_TX_BITRATE(value uint32) {
	volatile.StoreUint32(&o.TXBITRATE.Reg, volatile.LoadUint32(&o.TXBITRATE.Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetTXBITRATE_TX_BITRATE() uint32 {
	return volatile.LoadUint32(&o.TXBITRATE.Reg) & 0x3f
}
func (o *I2S_Type) SetTXBITRATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXBITRATE.Reg, volatile.LoadUint32(&o.TXBITRATE.Reg)&^(0xffffffc0)|value<<6)
}
func (o *I2S_Type) GetTXBITRATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXBITRATE.Reg) & 0xffffffc0) >> 6
}

// I2S.RXBITRATE: I2S Receive bit rate divider. This register determines the I2S receive bit rate by specifying the value to divide RX_MCLK by in order to produce the receive bit clock.
func (o *I2S_Type) SetRXBITRATE_RX_BITRATE(value uint32) {
	volatile.StoreUint32(&o.RXBITRATE.Reg, volatile.LoadUint32(&o.RXBITRATE.Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetRXBITRATE_RX_BITRATE() uint32 {
	return volatile.LoadUint32(&o.RXBITRATE.Reg) & 0x3f
}
func (o *I2S_Type) SetRXBITRATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXBITRATE.Reg, volatile.LoadUint32(&o.RXBITRATE.Reg)&^(0xffffffc0)|value<<6)
}
func (o *I2S_Type) GetRXBITRATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXBITRATE.Reg) & 0xffffffc0) >> 6
}

// I2S.TXMODE: I2S Transmit mode control.
func (o *I2S_Type) SetTXMODE_TXCLKSEL(value uint32) {
	volatile.StoreUint32(&o.TXMODE.Reg, volatile.LoadUint32(&o.TXMODE.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetTXMODE_TXCLKSEL() uint32 {
	return volatile.LoadUint32(&o.TXMODE.Reg) & 0x3
}
func (o *I2S_Type) SetTXMODE_TX4PIN(value uint32) {
	volatile.StoreUint32(&o.TXMODE.Reg, volatile.LoadUint32(&o.TXMODE.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetTXMODE_TX4PIN() uint32 {
	return (volatile.LoadUint32(&o.TXMODE.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetTXMODE_TXMCENA(value uint32) {
	volatile.StoreUint32(&o.TXMODE.Reg, volatile.LoadUint32(&o.TXMODE.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetTXMODE_TXMCENA() uint32 {
	return (volatile.LoadUint32(&o.TXMODE.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetTXMODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXMODE.Reg, volatile.LoadUint32(&o.TXMODE.Reg)&^(0xfffffff0)|value<<4)
}
func (o *I2S_Type) GetTXMODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXMODE.Reg) & 0xfffffff0) >> 4
}

// I2S.RXMODE: I2S Receive mode control.
func (o *I2S_Type) SetRXMODE_RXCLKSEL(value uint32) {
	volatile.StoreUint32(&o.RXMODE.Reg, volatile.LoadUint32(&o.RXMODE.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetRXMODE_RXCLKSEL() uint32 {
	return volatile.LoadUint32(&o.RXMODE.Reg) & 0x3
}
func (o *I2S_Type) SetRXMODE_RX4PIN(value uint32) {
	volatile.StoreUint32(&o.RXMODE.Reg, volatile.LoadUint32(&o.RXMODE.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetRXMODE_RX4PIN() uint32 {
	return (volatile.LoadUint32(&o.RXMODE.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetRXMODE_RXMCENA(value uint32) {
	volatile.StoreUint32(&o.RXMODE.Reg, volatile.LoadUint32(&o.RXMODE.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetRXMODE_RXMCENA() uint32 {
	return (volatile.LoadUint32(&o.RXMODE.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetRXMODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXMODE.Reg, volatile.LoadUint32(&o.RXMODE.Reg)&^(0xfffffff0)|value<<4)
}
func (o *I2S_Type) GetRXMODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXMODE.Reg) & 0xfffffff0) >> 4
}

// C_CAN
type C_CAN1_Type struct {
	CNTL         volatile.Register32 // 0x0
	STAT         volatile.Register32 // 0x4
	EC           volatile.Register32 // 0x8
	BT           volatile.Register32 // 0xC
	INT          volatile.Register32 // 0x10
	TEST         volatile.Register32 // 0x14
	BRPE         volatile.Register32 // 0x18
	_            [4]byte
	IF1_CMDREQ   volatile.Register32 // 0x20
	IF1_CMDMSK_W volatile.Register32 // 0x24
	IF1_MSK1     volatile.Register32 // 0x28
	IF1_MSK2     volatile.Register32 // 0x2C
	IF1_ARB1     volatile.Register32 // 0x30
	IF1_ARB2     volatile.Register32 // 0x34
	IF1_MCTRL    volatile.Register32 // 0x38
	IF1_DA1      volatile.Register32 // 0x3C
	IF1_DA2      volatile.Register32 // 0x40
	IF1_DB1      volatile.Register32 // 0x44
	IF1_DB2      volatile.Register32 // 0x48
	_            [52]byte
	IF2_CMDREQ   volatile.Register32 // 0x80
	IF2_CMDMSK_W volatile.Register32 // 0x84
	IF2_MSK1     volatile.Register32 // 0x88
	IF2_MSK2     volatile.Register32 // 0x8C
	IF2_ARB1     volatile.Register32 // 0x90
	IF2_ARB2     volatile.Register32 // 0x94
	IF2_MCTRL    volatile.Register32 // 0x98
	IF2_DA1      volatile.Register32 // 0x9C
	IF2_DA2      volatile.Register32 // 0xA0
	IF2_DB1      volatile.Register32 // 0xA4
	IF2_DB2      volatile.Register32 // 0xA8
	_            [84]byte
	TXREQ1       volatile.Register32 // 0x100
	TXREQ2       volatile.Register32 // 0x104
	_            [24]byte
	ND1          volatile.Register32 // 0x120
	ND2          volatile.Register32 // 0x124
	_            [24]byte
	IR1          volatile.Register32 // 0x140
	IR2          volatile.Register32 // 0x144
	_            [24]byte
	MSGV1        volatile.Register32 // 0x160
	MSGV2        volatile.Register32 // 0x164
	_            [24]byte
	CLKDIV       volatile.Register32 // 0x180
}

// C_CAN1.CNTL: CAN control
func (o *C_CAN1_Type) SetCNTL_INIT(value uint32) {
	volatile.StoreUint32(&o.CNTL.Reg, volatile.LoadUint32(&o.CNTL.Reg)&^(0x1)|value)
}
func (o *C_CAN1_Type) GetCNTL_INIT() uint32 {
	return volatile.LoadUint32(&o.CNTL.Reg) & 0x1
}
func (o *C_CAN1_Type) SetCNTL_IE(value uint32) {
	volatile.StoreUint32(&o.CNTL.Reg, volatile.LoadUint32(&o.CNTL.Reg)&^(0x2)|value<<1)
}
func (o *C_CAN1_Type) GetCNTL_IE() uint32 {
	return (volatile.LoadUint32(&o.CNTL.Reg) & 0x2) >> 1
}
func (o *C_CAN1_Type) SetCNTL_SIE(value uint32) {
	volatile.StoreUint32(&o.CNTL.Reg, volatile.LoadUint32(&o.CNTL.Reg)&^(0x4)|value<<2)
}
func (o *C_CAN1_Type) GetCNTL_SIE() uint32 {
	return (volatile.LoadUint32(&o.CNTL.Reg) & 0x4) >> 2
}
func (o *C_CAN1_Type) SetCNTL_EIE(value uint32) {
	volatile.StoreUint32(&o.CNTL.Reg, volatile.LoadUint32(&o.CNTL.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN1_Type) GetCNTL_EIE() uint32 {
	return (volatile.LoadUint32(&o.CNTL.Reg) & 0x8) >> 3
}
func (o *C_CAN1_Type) SetCNTL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTL.Reg, volatile.LoadUint32(&o.CNTL.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN1_Type) GetCNTL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTL.Reg) & 0x10) >> 4
}
func (o *C_CAN1_Type) SetCNTL_DAR(value uint32) {
	volatile.StoreUint32(&o.CNTL.Reg, volatile.LoadUint32(&o.CNTL.Reg)&^(0x20)|value<<5)
}
func (o *C_CAN1_Type) GetCNTL_DAR() uint32 {
	return (volatile.LoadUint32(&o.CNTL.Reg) & 0x20) >> 5
}
func (o *C_CAN1_Type) SetCNTL_CCE(value uint32) {
	volatile.StoreUint32(&o.CNTL.Reg, volatile.LoadUint32(&o.CNTL.Reg)&^(0x40)|value<<6)
}
func (o *C_CAN1_Type) GetCNTL_CCE() uint32 {
	return (volatile.LoadUint32(&o.CNTL.Reg) & 0x40) >> 6
}
func (o *C_CAN1_Type) SetCNTL_TEST(value uint32) {
	volatile.StoreUint32(&o.CNTL.Reg, volatile.LoadUint32(&o.CNTL.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN1_Type) GetCNTL_TEST() uint32 {
	return (volatile.LoadUint32(&o.CNTL.Reg) & 0x80) >> 7
}
func (o *C_CAN1_Type) SetCNTL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTL.Reg, volatile.LoadUint32(&o.CNTL.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN1_Type) GetCNTL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTL.Reg) & 0xffffff00) >> 8
}

// C_CAN1.STAT: Status register
func (o *C_CAN1_Type) SetSTAT_LEC(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x7)|value)
}
func (o *C_CAN1_Type) GetSTAT_LEC() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x7
}
func (o *C_CAN1_Type) SetSTAT_TXOK(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN1_Type) GetSTAT_TXOK() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8) >> 3
}
func (o *C_CAN1_Type) SetSTAT_RXOK(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN1_Type) GetSTAT_RXOK() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10) >> 4
}
func (o *C_CAN1_Type) SetSTAT_EPASS(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20)|value<<5)
}
func (o *C_CAN1_Type) GetSTAT_EPASS() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20) >> 5
}
func (o *C_CAN1_Type) SetSTAT_EWARN(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40)|value<<6)
}
func (o *C_CAN1_Type) GetSTAT_EWARN() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40) >> 6
}
func (o *C_CAN1_Type) SetSTAT_BOFF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN1_Type) GetSTAT_BOFF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80) >> 7
}
func (o *C_CAN1_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN1_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xffffff00) >> 8
}

// C_CAN1.EC: Error counter
func (o *C_CAN1_Type) SetEC_TEC_7_0(value uint32) {
	volatile.StoreUint32(&o.EC.Reg, volatile.LoadUint32(&o.EC.Reg)&^(0xff)|value)
}
func (o *C_CAN1_Type) GetEC_TEC_7_0() uint32 {
	return volatile.LoadUint32(&o.EC.Reg) & 0xff
}
func (o *C_CAN1_Type) SetEC_REC_6_0(value uint32) {
	volatile.StoreUint32(&o.EC.Reg, volatile.LoadUint32(&o.EC.Reg)&^(0x7f00)|value<<8)
}
func (o *C_CAN1_Type) GetEC_REC_6_0() uint32 {
	return (volatile.LoadUint32(&o.EC.Reg) & 0x7f00) >> 8
}
func (o *C_CAN1_Type) SetEC_RP(value uint32) {
	volatile.StoreUint32(&o.EC.Reg, volatile.LoadUint32(&o.EC.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN1_Type) GetEC_RP() uint32 {
	return (volatile.LoadUint32(&o.EC.Reg) & 0x8000) >> 15
}
func (o *C_CAN1_Type) SetEC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EC.Reg, volatile.LoadUint32(&o.EC.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetEC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EC.Reg) & 0xffff0000) >> 16
}

// C_CAN1.BT: Bit timing register
func (o *C_CAN1_Type) SetBT_BRP(value uint32) {
	volatile.StoreUint32(&o.BT.Reg, volatile.LoadUint32(&o.BT.Reg)&^(0x3f)|value)
}
func (o *C_CAN1_Type) GetBT_BRP() uint32 {
	return volatile.LoadUint32(&o.BT.Reg) & 0x3f
}
func (o *C_CAN1_Type) SetBT_SJW(value uint32) {
	volatile.StoreUint32(&o.BT.Reg, volatile.LoadUint32(&o.BT.Reg)&^(0xc0)|value<<6)
}
func (o *C_CAN1_Type) GetBT_SJW() uint32 {
	return (volatile.LoadUint32(&o.BT.Reg) & 0xc0) >> 6
}
func (o *C_CAN1_Type) SetBT_TSEG1(value uint32) {
	volatile.StoreUint32(&o.BT.Reg, volatile.LoadUint32(&o.BT.Reg)&^(0xf00)|value<<8)
}
func (o *C_CAN1_Type) GetBT_TSEG1() uint32 {
	return (volatile.LoadUint32(&o.BT.Reg) & 0xf00) >> 8
}
func (o *C_CAN1_Type) SetBT_TSEG2(value uint32) {
	volatile.StoreUint32(&o.BT.Reg, volatile.LoadUint32(&o.BT.Reg)&^(0x7000)|value<<12)
}
func (o *C_CAN1_Type) GetBT_TSEG2() uint32 {
	return (volatile.LoadUint32(&o.BT.Reg) & 0x7000) >> 12
}
func (o *C_CAN1_Type) SetBT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BT.Reg, volatile.LoadUint32(&o.BT.Reg)&^(0xffff8000)|value<<15)
}
func (o *C_CAN1_Type) GetBT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BT.Reg) & 0xffff8000) >> 15
}

// C_CAN1.INT: Interrupt register
func (o *C_CAN1_Type) SetINT_INTID15_0(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetINT_INTID15_0() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetINT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetINT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0xffff0000) >> 16
}

// C_CAN1.TEST: Test register
func (o *C_CAN1_Type) SetTEST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x3)|value)
}
func (o *C_CAN1_Type) GetTEST_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TEST.Reg) & 0x3
}
func (o *C_CAN1_Type) SetTEST_BASIC(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x4)|value<<2)
}
func (o *C_CAN1_Type) GetTEST_BASIC() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x4) >> 2
}
func (o *C_CAN1_Type) SetTEST_SILENT(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN1_Type) GetTEST_SILENT() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x8) >> 3
}
func (o *C_CAN1_Type) SetTEST_LBACK(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN1_Type) GetTEST_LBACK() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x10) >> 4
}
func (o *C_CAN1_Type) SetTEST_TX1_0(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x60)|value<<5)
}
func (o *C_CAN1_Type) GetTEST_TX1_0() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x60) >> 5
}
func (o *C_CAN1_Type) SetTEST_RX(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN1_Type) GetTEST_RX() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x80) >> 7
}
func (o *C_CAN1_Type) SetTEST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN1_Type) GetTEST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0xffffff00) >> 8
}

// C_CAN1.BRPE: Baud rate prescaler extension register
func (o *C_CAN1_Type) SetBRPE(value uint32) {
	volatile.StoreUint32(&o.BRPE.Reg, volatile.LoadUint32(&o.BRPE.Reg)&^(0xf)|value)
}
func (o *C_CAN1_Type) GetBRPE() uint32 {
	return volatile.LoadUint32(&o.BRPE.Reg) & 0xf
}
func (o *C_CAN1_Type) SetBRPE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BRPE.Reg, volatile.LoadUint32(&o.BRPE.Reg)&^(0xfffffff0)|value<<4)
}
func (o *C_CAN1_Type) GetBRPE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BRPE.Reg) & 0xfffffff0) >> 4
}

// C_CAN1.IF1_CMDREQ: Message interface command request
func (o *C_CAN1_Type) SetIF1_CMDREQ_MESSNUM(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDREQ.Reg, volatile.LoadUint32(&o.IF1_CMDREQ.Reg)&^(0x3f)|value)
}
func (o *C_CAN1_Type) GetIF1_CMDREQ_MESSNUM() uint32 {
	return volatile.LoadUint32(&o.IF1_CMDREQ.Reg) & 0x3f
}
func (o *C_CAN1_Type) SetIF1_CMDREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDREQ.Reg, volatile.LoadUint32(&o.IF1_CMDREQ.Reg)&^(0x7fc0)|value<<6)
}
func (o *C_CAN1_Type) GetIF1_CMDREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDREQ.Reg) & 0x7fc0) >> 6
}
func (o *C_CAN1_Type) SetIF1_CMDREQ_BUSY(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDREQ.Reg, volatile.LoadUint32(&o.IF1_CMDREQ.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN1_Type) GetIF1_CMDREQ_BUSY() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDREQ.Reg) & 0x8000) >> 15
}
func (o *C_CAN1_Type) SetIF1_CMDREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDREQ.Reg, volatile.LoadUint32(&o.IF1_CMDREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_CMDREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDREQ.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF1_CMDMSK_W: Message interface command mask (write direction)
func (o *C_CAN1_Type) SetIF1_CMDMSK_W_DATA_B(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg)&^(0x1)|value)
}
func (o *C_CAN1_Type) GetIF1_CMDMSK_W_DATA_B() uint32 {
	return volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg) & 0x1
}
func (o *C_CAN1_Type) SetIF1_CMDMSK_W_DATA_A(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg)&^(0x2)|value<<1)
}
func (o *C_CAN1_Type) GetIF1_CMDMSK_W_DATA_A() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg) & 0x2) >> 1
}
func (o *C_CAN1_Type) SetIF1_CMDMSK_W_TXRQST(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg)&^(0x4)|value<<2)
}
func (o *C_CAN1_Type) GetIF1_CMDMSK_W_TXRQST() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg) & 0x4) >> 2
}
func (o *C_CAN1_Type) SetIF1_CMDMSK_W_CLRINTPND(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN1_Type) GetIF1_CMDMSK_W_CLRINTPND() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg) & 0x8) >> 3
}
func (o *C_CAN1_Type) SetIF1_CMDMSK_W_CTRL(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN1_Type) GetIF1_CMDMSK_W_CTRL() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg) & 0x10) >> 4
}
func (o *C_CAN1_Type) SetIF1_CMDMSK_W_ARB(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg)&^(0x20)|value<<5)
}
func (o *C_CAN1_Type) GetIF1_CMDMSK_W_ARB() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg) & 0x20) >> 5
}
func (o *C_CAN1_Type) SetIF1_CMDMSK_W_MASK(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg)&^(0x40)|value<<6)
}
func (o *C_CAN1_Type) GetIF1_CMDMSK_W_MASK() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg) & 0x40) >> 6
}
func (o *C_CAN1_Type) SetIF1_CMDMSK_W_WR_RD(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN1_Type) GetIF1_CMDMSK_W_WR_RD() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg) & 0x80) >> 7
}
func (o *C_CAN1_Type) SetIF1_CMDMSK_W_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF1_CMDMSK_W_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_CMDMSK_W.Reg) & 0xffffff00) >> 8
}

// C_CAN1.IF1_MSK1: Message interface mask 1
func (o *C_CAN1_Type) SetIF1_MSK1_MSK15_0(value uint32) {
	volatile.StoreUint32(&o.IF1_MSK1.Reg, volatile.LoadUint32(&o.IF1_MSK1.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetIF1_MSK1_MSK15_0() uint32 {
	return volatile.LoadUint32(&o.IF1_MSK1.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetIF1_MSK1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_MSK1.Reg, volatile.LoadUint32(&o.IF1_MSK1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_MSK1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_MSK1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF1_MSK2: Message interface 1 mask 2
func (o *C_CAN1_Type) SetIF1_MSK2_MSK28_16(value uint32) {
	volatile.StoreUint32(&o.IF1_MSK2.Reg, volatile.LoadUint32(&o.IF1_MSK2.Reg)&^(0x1fff)|value)
}
func (o *C_CAN1_Type) GetIF1_MSK2_MSK28_16() uint32 {
	return volatile.LoadUint32(&o.IF1_MSK2.Reg) & 0x1fff
}
func (o *C_CAN1_Type) SetIF1_MSK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_MSK2.Reg, volatile.LoadUint32(&o.IF1_MSK2.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN1_Type) GetIF1_MSK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_MSK2.Reg) & 0x2000) >> 13
}
func (o *C_CAN1_Type) SetIF1_MSK2_MDIR(value uint32) {
	volatile.StoreUint32(&o.IF1_MSK2.Reg, volatile.LoadUint32(&o.IF1_MSK2.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN1_Type) GetIF1_MSK2_MDIR() uint32 {
	return (volatile.LoadUint32(&o.IF1_MSK2.Reg) & 0x4000) >> 14
}
func (o *C_CAN1_Type) SetIF1_MSK2_MXTD(value uint32) {
	volatile.StoreUint32(&o.IF1_MSK2.Reg, volatile.LoadUint32(&o.IF1_MSK2.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN1_Type) GetIF1_MSK2_MXTD() uint32 {
	return (volatile.LoadUint32(&o.IF1_MSK2.Reg) & 0x8000) >> 15
}
func (o *C_CAN1_Type) SetIF1_MSK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_MSK2.Reg, volatile.LoadUint32(&o.IF1_MSK2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_MSK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_MSK2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF1_ARB1: Message interface 1 arbitration 1
func (o *C_CAN1_Type) SetIF1_ARB1_ID15_0(value uint32) {
	volatile.StoreUint32(&o.IF1_ARB1.Reg, volatile.LoadUint32(&o.IF1_ARB1.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetIF1_ARB1_ID15_0() uint32 {
	return volatile.LoadUint32(&o.IF1_ARB1.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetIF1_ARB1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_ARB1.Reg, volatile.LoadUint32(&o.IF1_ARB1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_ARB1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_ARB1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF1_ARB2: Message interface 1 arbitration 2
func (o *C_CAN1_Type) SetIF1_ARB2_ID28_16(value uint32) {
	volatile.StoreUint32(&o.IF1_ARB2.Reg, volatile.LoadUint32(&o.IF1_ARB2.Reg)&^(0x1fff)|value)
}
func (o *C_CAN1_Type) GetIF1_ARB2_ID28_16() uint32 {
	return volatile.LoadUint32(&o.IF1_ARB2.Reg) & 0x1fff
}
func (o *C_CAN1_Type) SetIF1_ARB2_DIR(value uint32) {
	volatile.StoreUint32(&o.IF1_ARB2.Reg, volatile.LoadUint32(&o.IF1_ARB2.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN1_Type) GetIF1_ARB2_DIR() uint32 {
	return (volatile.LoadUint32(&o.IF1_ARB2.Reg) & 0x2000) >> 13
}
func (o *C_CAN1_Type) SetIF1_ARB2_XTD(value uint32) {
	volatile.StoreUint32(&o.IF1_ARB2.Reg, volatile.LoadUint32(&o.IF1_ARB2.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN1_Type) GetIF1_ARB2_XTD() uint32 {
	return (volatile.LoadUint32(&o.IF1_ARB2.Reg) & 0x4000) >> 14
}
func (o *C_CAN1_Type) SetIF1_ARB2_MSGVAL(value uint32) {
	volatile.StoreUint32(&o.IF1_ARB2.Reg, volatile.LoadUint32(&o.IF1_ARB2.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN1_Type) GetIF1_ARB2_MSGVAL() uint32 {
	return (volatile.LoadUint32(&o.IF1_ARB2.Reg) & 0x8000) >> 15
}
func (o *C_CAN1_Type) SetIF1_ARB2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_ARB2.Reg, volatile.LoadUint32(&o.IF1_ARB2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_ARB2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_ARB2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF1_MCTRL: Message interface 1 message control
func (o *C_CAN1_Type) SetIF1_MCTRL_DLC3_0(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0xf)|value)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_DLC3_0() uint32 {
	return volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0xf
}
func (o *C_CAN1_Type) SetIF1_MCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x70)|value<<4)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x70) >> 4
}
func (o *C_CAN1_Type) SetIF1_MCTRL_EOB(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_EOB() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x80) >> 7
}
func (o *C_CAN1_Type) SetIF1_MCTRL_TXRQST(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x100)|value<<8)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_TXRQST() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x100) >> 8
}
func (o *C_CAN1_Type) SetIF1_MCTRL_RMTEN(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x200)|value<<9)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_RMTEN() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x200) >> 9
}
func (o *C_CAN1_Type) SetIF1_MCTRL_RXIE(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x400)|value<<10)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_RXIE() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x400) >> 10
}
func (o *C_CAN1_Type) SetIF1_MCTRL_TXIE(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x800)|value<<11)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_TXIE() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x800) >> 11
}
func (o *C_CAN1_Type) SetIF1_MCTRL_UMASK(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_UMASK() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x1000) >> 12
}
func (o *C_CAN1_Type) SetIF1_MCTRL_INTPND(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_INTPND() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x2000) >> 13
}
func (o *C_CAN1_Type) SetIF1_MCTRL_MSGLST(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_MSGLST() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x4000) >> 14
}
func (o *C_CAN1_Type) SetIF1_MCTRL_NEWDAT(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_NEWDAT() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0x8000) >> 15
}
func (o *C_CAN1_Type) SetIF1_MCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_MCTRL.Reg, volatile.LoadUint32(&o.IF1_MCTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_MCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_MCTRL.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF1_DA1: Message interface data A1
func (o *C_CAN1_Type) SetIF1_DA1_DATA0(value uint32) {
	volatile.StoreUint32(&o.IF1_DA1.Reg, volatile.LoadUint32(&o.IF1_DA1.Reg)&^(0xff)|value)
}
func (o *C_CAN1_Type) GetIF1_DA1_DATA0() uint32 {
	return volatile.LoadUint32(&o.IF1_DA1.Reg) & 0xff
}
func (o *C_CAN1_Type) SetIF1_DA1_DATA1(value uint32) {
	volatile.StoreUint32(&o.IF1_DA1.Reg, volatile.LoadUint32(&o.IF1_DA1.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF1_DA1_DATA1() uint32 {
	return (volatile.LoadUint32(&o.IF1_DA1.Reg) & 0xff00) >> 8
}
func (o *C_CAN1_Type) SetIF1_DA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_DA1.Reg, volatile.LoadUint32(&o.IF1_DA1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_DA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_DA1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF1_DA2: Message interface 1 data A2
func (o *C_CAN1_Type) SetIF1_DA2_DATA2(value uint32) {
	volatile.StoreUint32(&o.IF1_DA2.Reg, volatile.LoadUint32(&o.IF1_DA2.Reg)&^(0xff)|value)
}
func (o *C_CAN1_Type) GetIF1_DA2_DATA2() uint32 {
	return volatile.LoadUint32(&o.IF1_DA2.Reg) & 0xff
}
func (o *C_CAN1_Type) SetIF1_DA2_DATA3(value uint32) {
	volatile.StoreUint32(&o.IF1_DA2.Reg, volatile.LoadUint32(&o.IF1_DA2.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF1_DA2_DATA3() uint32 {
	return (volatile.LoadUint32(&o.IF1_DA2.Reg) & 0xff00) >> 8
}
func (o *C_CAN1_Type) SetIF1_DA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_DA2.Reg, volatile.LoadUint32(&o.IF1_DA2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_DA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_DA2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF1_DB1: Message interface 1 data B1
func (o *C_CAN1_Type) SetIF1_DB1_DATA4(value uint32) {
	volatile.StoreUint32(&o.IF1_DB1.Reg, volatile.LoadUint32(&o.IF1_DB1.Reg)&^(0xff)|value)
}
func (o *C_CAN1_Type) GetIF1_DB1_DATA4() uint32 {
	return volatile.LoadUint32(&o.IF1_DB1.Reg) & 0xff
}
func (o *C_CAN1_Type) SetIF1_DB1_DATA5(value uint32) {
	volatile.StoreUint32(&o.IF1_DB1.Reg, volatile.LoadUint32(&o.IF1_DB1.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF1_DB1_DATA5() uint32 {
	return (volatile.LoadUint32(&o.IF1_DB1.Reg) & 0xff00) >> 8
}
func (o *C_CAN1_Type) SetIF1_DB1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_DB1.Reg, volatile.LoadUint32(&o.IF1_DB1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_DB1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_DB1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF1_DB2: Message interface 1 data B2
func (o *C_CAN1_Type) SetIF1_DB2_DATA6(value uint32) {
	volatile.StoreUint32(&o.IF1_DB2.Reg, volatile.LoadUint32(&o.IF1_DB2.Reg)&^(0xff)|value)
}
func (o *C_CAN1_Type) GetIF1_DB2_DATA6() uint32 {
	return volatile.LoadUint32(&o.IF1_DB2.Reg) & 0xff
}
func (o *C_CAN1_Type) SetIF1_DB2_DATA7(value uint32) {
	volatile.StoreUint32(&o.IF1_DB2.Reg, volatile.LoadUint32(&o.IF1_DB2.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF1_DB2_DATA7() uint32 {
	return (volatile.LoadUint32(&o.IF1_DB2.Reg) & 0xff00) >> 8
}
func (o *C_CAN1_Type) SetIF1_DB2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF1_DB2.Reg, volatile.LoadUint32(&o.IF1_DB2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF1_DB2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF1_DB2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_CMDREQ: Message interface command request
func (o *C_CAN1_Type) SetIF2_CMDREQ_MESSNUM(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDREQ.Reg, volatile.LoadUint32(&o.IF2_CMDREQ.Reg)&^(0x3f)|value)
}
func (o *C_CAN1_Type) GetIF2_CMDREQ_MESSNUM() uint32 {
	return volatile.LoadUint32(&o.IF2_CMDREQ.Reg) & 0x3f
}
func (o *C_CAN1_Type) SetIF2_CMDREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDREQ.Reg, volatile.LoadUint32(&o.IF2_CMDREQ.Reg)&^(0x7fc0)|value<<6)
}
func (o *C_CAN1_Type) GetIF2_CMDREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDREQ.Reg) & 0x7fc0) >> 6
}
func (o *C_CAN1_Type) SetIF2_CMDREQ_BUSY(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDREQ.Reg, volatile.LoadUint32(&o.IF2_CMDREQ.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN1_Type) GetIF2_CMDREQ_BUSY() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDREQ.Reg) & 0x8000) >> 15
}
func (o *C_CAN1_Type) SetIF2_CMDREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDREQ.Reg, volatile.LoadUint32(&o.IF2_CMDREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_CMDREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDREQ.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_CMDMSK_W: Message interface command mask (write direction)
func (o *C_CAN1_Type) SetIF2_CMDMSK_W_DATA_B(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg)&^(0x1)|value)
}
func (o *C_CAN1_Type) GetIF2_CMDMSK_W_DATA_B() uint32 {
	return volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg) & 0x1
}
func (o *C_CAN1_Type) SetIF2_CMDMSK_W_DATA_A(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg)&^(0x2)|value<<1)
}
func (o *C_CAN1_Type) GetIF2_CMDMSK_W_DATA_A() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg) & 0x2) >> 1
}
func (o *C_CAN1_Type) SetIF2_CMDMSK_W_TXRQST(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg)&^(0x4)|value<<2)
}
func (o *C_CAN1_Type) GetIF2_CMDMSK_W_TXRQST() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg) & 0x4) >> 2
}
func (o *C_CAN1_Type) SetIF2_CMDMSK_W_CLRINTPND(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN1_Type) GetIF2_CMDMSK_W_CLRINTPND() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg) & 0x8) >> 3
}
func (o *C_CAN1_Type) SetIF2_CMDMSK_W_CTRL(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN1_Type) GetIF2_CMDMSK_W_CTRL() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg) & 0x10) >> 4
}
func (o *C_CAN1_Type) SetIF2_CMDMSK_W_ARB(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg)&^(0x20)|value<<5)
}
func (o *C_CAN1_Type) GetIF2_CMDMSK_W_ARB() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg) & 0x20) >> 5
}
func (o *C_CAN1_Type) SetIF2_CMDMSK_W_MASK(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg)&^(0x40)|value<<6)
}
func (o *C_CAN1_Type) GetIF2_CMDMSK_W_MASK() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg) & 0x40) >> 6
}
func (o *C_CAN1_Type) SetIF2_CMDMSK_W_WR_RD(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN1_Type) GetIF2_CMDMSK_W_WR_RD() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg) & 0x80) >> 7
}
func (o *C_CAN1_Type) SetIF2_CMDMSK_W_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF2_CMDMSK_W_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_CMDMSK_W.Reg) & 0xffffff00) >> 8
}

// C_CAN1.IF2_MSK1: Message interface mask 1
func (o *C_CAN1_Type) SetIF2_MSK1_MSK15_0(value uint32) {
	volatile.StoreUint32(&o.IF2_MSK1.Reg, volatile.LoadUint32(&o.IF2_MSK1.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetIF2_MSK1_MSK15_0() uint32 {
	return volatile.LoadUint32(&o.IF2_MSK1.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetIF2_MSK1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_MSK1.Reg, volatile.LoadUint32(&o.IF2_MSK1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_MSK1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_MSK1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_MSK2: Message interface 1 mask 2
func (o *C_CAN1_Type) SetIF2_MSK2_MSK28_16(value uint32) {
	volatile.StoreUint32(&o.IF2_MSK2.Reg, volatile.LoadUint32(&o.IF2_MSK2.Reg)&^(0x1fff)|value)
}
func (o *C_CAN1_Type) GetIF2_MSK2_MSK28_16() uint32 {
	return volatile.LoadUint32(&o.IF2_MSK2.Reg) & 0x1fff
}
func (o *C_CAN1_Type) SetIF2_MSK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_MSK2.Reg, volatile.LoadUint32(&o.IF2_MSK2.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN1_Type) GetIF2_MSK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_MSK2.Reg) & 0x2000) >> 13
}
func (o *C_CAN1_Type) SetIF2_MSK2_MDIR(value uint32) {
	volatile.StoreUint32(&o.IF2_MSK2.Reg, volatile.LoadUint32(&o.IF2_MSK2.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN1_Type) GetIF2_MSK2_MDIR() uint32 {
	return (volatile.LoadUint32(&o.IF2_MSK2.Reg) & 0x4000) >> 14
}
func (o *C_CAN1_Type) SetIF2_MSK2_MXTD(value uint32) {
	volatile.StoreUint32(&o.IF2_MSK2.Reg, volatile.LoadUint32(&o.IF2_MSK2.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN1_Type) GetIF2_MSK2_MXTD() uint32 {
	return (volatile.LoadUint32(&o.IF2_MSK2.Reg) & 0x8000) >> 15
}
func (o *C_CAN1_Type) SetIF2_MSK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_MSK2.Reg, volatile.LoadUint32(&o.IF2_MSK2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_MSK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_MSK2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_ARB1: Message interface 1 arbitration 1
func (o *C_CAN1_Type) SetIF2_ARB1_ID15_0(value uint32) {
	volatile.StoreUint32(&o.IF2_ARB1.Reg, volatile.LoadUint32(&o.IF2_ARB1.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetIF2_ARB1_ID15_0() uint32 {
	return volatile.LoadUint32(&o.IF2_ARB1.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetIF2_ARB1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_ARB1.Reg, volatile.LoadUint32(&o.IF2_ARB1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_ARB1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_ARB1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_ARB2: Message interface 1 arbitration 2
func (o *C_CAN1_Type) SetIF2_ARB2_ID28_16(value uint32) {
	volatile.StoreUint32(&o.IF2_ARB2.Reg, volatile.LoadUint32(&o.IF2_ARB2.Reg)&^(0x1fff)|value)
}
func (o *C_CAN1_Type) GetIF2_ARB2_ID28_16() uint32 {
	return volatile.LoadUint32(&o.IF2_ARB2.Reg) & 0x1fff
}
func (o *C_CAN1_Type) SetIF2_ARB2_DIR(value uint32) {
	volatile.StoreUint32(&o.IF2_ARB2.Reg, volatile.LoadUint32(&o.IF2_ARB2.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN1_Type) GetIF2_ARB2_DIR() uint32 {
	return (volatile.LoadUint32(&o.IF2_ARB2.Reg) & 0x2000) >> 13
}
func (o *C_CAN1_Type) SetIF2_ARB2_XTD(value uint32) {
	volatile.StoreUint32(&o.IF2_ARB2.Reg, volatile.LoadUint32(&o.IF2_ARB2.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN1_Type) GetIF2_ARB2_XTD() uint32 {
	return (volatile.LoadUint32(&o.IF2_ARB2.Reg) & 0x4000) >> 14
}
func (o *C_CAN1_Type) SetIF2_ARB2_MSGVAL(value uint32) {
	volatile.StoreUint32(&o.IF2_ARB2.Reg, volatile.LoadUint32(&o.IF2_ARB2.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN1_Type) GetIF2_ARB2_MSGVAL() uint32 {
	return (volatile.LoadUint32(&o.IF2_ARB2.Reg) & 0x8000) >> 15
}
func (o *C_CAN1_Type) SetIF2_ARB2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_ARB2.Reg, volatile.LoadUint32(&o.IF2_ARB2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_ARB2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_ARB2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_MCTRL: Message interface 1 message control
func (o *C_CAN1_Type) SetIF2_MCTRL_DLC3_0(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0xf)|value)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_DLC3_0() uint32 {
	return volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0xf
}
func (o *C_CAN1_Type) SetIF2_MCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x70)|value<<4)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x70) >> 4
}
func (o *C_CAN1_Type) SetIF2_MCTRL_EOB(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_EOB() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x80) >> 7
}
func (o *C_CAN1_Type) SetIF2_MCTRL_TXRQST(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x100)|value<<8)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_TXRQST() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x100) >> 8
}
func (o *C_CAN1_Type) SetIF2_MCTRL_RMTEN(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x200)|value<<9)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_RMTEN() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x200) >> 9
}
func (o *C_CAN1_Type) SetIF2_MCTRL_RXIE(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x400)|value<<10)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_RXIE() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x400) >> 10
}
func (o *C_CAN1_Type) SetIF2_MCTRL_TXIE(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x800)|value<<11)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_TXIE() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x800) >> 11
}
func (o *C_CAN1_Type) SetIF2_MCTRL_UMASK(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_UMASK() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x1000) >> 12
}
func (o *C_CAN1_Type) SetIF2_MCTRL_INTPND(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_INTPND() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x2000) >> 13
}
func (o *C_CAN1_Type) SetIF2_MCTRL_MSGLST(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_MSGLST() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x4000) >> 14
}
func (o *C_CAN1_Type) SetIF2_MCTRL_NEWDAT(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_NEWDAT() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0x8000) >> 15
}
func (o *C_CAN1_Type) SetIF2_MCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_MCTRL.Reg, volatile.LoadUint32(&o.IF2_MCTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_MCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_MCTRL.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_DA1: Message interface data A1
func (o *C_CAN1_Type) SetIF2_DA1_DATA0(value uint32) {
	volatile.StoreUint32(&o.IF2_DA1.Reg, volatile.LoadUint32(&o.IF2_DA1.Reg)&^(0xff)|value)
}
func (o *C_CAN1_Type) GetIF2_DA1_DATA0() uint32 {
	return volatile.LoadUint32(&o.IF2_DA1.Reg) & 0xff
}
func (o *C_CAN1_Type) SetIF2_DA1_DATA1(value uint32) {
	volatile.StoreUint32(&o.IF2_DA1.Reg, volatile.LoadUint32(&o.IF2_DA1.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF2_DA1_DATA1() uint32 {
	return (volatile.LoadUint32(&o.IF2_DA1.Reg) & 0xff00) >> 8
}
func (o *C_CAN1_Type) SetIF2_DA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_DA1.Reg, volatile.LoadUint32(&o.IF2_DA1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_DA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_DA1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_DA2: Message interface 1 data A2
func (o *C_CAN1_Type) SetIF2_DA2_DATA2(value uint32) {
	volatile.StoreUint32(&o.IF2_DA2.Reg, volatile.LoadUint32(&o.IF2_DA2.Reg)&^(0xff)|value)
}
func (o *C_CAN1_Type) GetIF2_DA2_DATA2() uint32 {
	return volatile.LoadUint32(&o.IF2_DA2.Reg) & 0xff
}
func (o *C_CAN1_Type) SetIF2_DA2_DATA3(value uint32) {
	volatile.StoreUint32(&o.IF2_DA2.Reg, volatile.LoadUint32(&o.IF2_DA2.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF2_DA2_DATA3() uint32 {
	return (volatile.LoadUint32(&o.IF2_DA2.Reg) & 0xff00) >> 8
}
func (o *C_CAN1_Type) SetIF2_DA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_DA2.Reg, volatile.LoadUint32(&o.IF2_DA2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_DA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_DA2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_DB1: Message interface 1 data B1
func (o *C_CAN1_Type) SetIF2_DB1_DATA4(value uint32) {
	volatile.StoreUint32(&o.IF2_DB1.Reg, volatile.LoadUint32(&o.IF2_DB1.Reg)&^(0xff)|value)
}
func (o *C_CAN1_Type) GetIF2_DB1_DATA4() uint32 {
	return volatile.LoadUint32(&o.IF2_DB1.Reg) & 0xff
}
func (o *C_CAN1_Type) SetIF2_DB1_DATA5(value uint32) {
	volatile.StoreUint32(&o.IF2_DB1.Reg, volatile.LoadUint32(&o.IF2_DB1.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF2_DB1_DATA5() uint32 {
	return (volatile.LoadUint32(&o.IF2_DB1.Reg) & 0xff00) >> 8
}
func (o *C_CAN1_Type) SetIF2_DB1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_DB1.Reg, volatile.LoadUint32(&o.IF2_DB1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_DB1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_DB1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IF2_DB2: Message interface 1 data B2
func (o *C_CAN1_Type) SetIF2_DB2_DATA6(value uint32) {
	volatile.StoreUint32(&o.IF2_DB2.Reg, volatile.LoadUint32(&o.IF2_DB2.Reg)&^(0xff)|value)
}
func (o *C_CAN1_Type) GetIF2_DB2_DATA6() uint32 {
	return volatile.LoadUint32(&o.IF2_DB2.Reg) & 0xff
}
func (o *C_CAN1_Type) SetIF2_DB2_DATA7(value uint32) {
	volatile.StoreUint32(&o.IF2_DB2.Reg, volatile.LoadUint32(&o.IF2_DB2.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN1_Type) GetIF2_DB2_DATA7() uint32 {
	return (volatile.LoadUint32(&o.IF2_DB2.Reg) & 0xff00) >> 8
}
func (o *C_CAN1_Type) SetIF2_DB2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IF2_DB2.Reg, volatile.LoadUint32(&o.IF2_DB2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIF2_DB2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IF2_DB2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.TXREQ1: Transmission request 1
func (o *C_CAN1_Type) SetTXREQ1_TXRQST16_1(value uint32) {
	volatile.StoreUint32(&o.TXREQ1.Reg, volatile.LoadUint32(&o.TXREQ1.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetTXREQ1_TXRQST16_1() uint32 {
	return volatile.LoadUint32(&o.TXREQ1.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetTXREQ1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXREQ1.Reg, volatile.LoadUint32(&o.TXREQ1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetTXREQ1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXREQ1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.TXREQ2: Transmission request 2
func (o *C_CAN1_Type) SetTXREQ2_TXRQST32_17(value uint32) {
	volatile.StoreUint32(&o.TXREQ2.Reg, volatile.LoadUint32(&o.TXREQ2.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetTXREQ2_TXRQST32_17() uint32 {
	return volatile.LoadUint32(&o.TXREQ2.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetTXREQ2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXREQ2.Reg, volatile.LoadUint32(&o.TXREQ2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetTXREQ2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXREQ2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.ND1: New data 1
func (o *C_CAN1_Type) SetND1_NEWDAT16_1(value uint32) {
	volatile.StoreUint32(&o.ND1.Reg, volatile.LoadUint32(&o.ND1.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetND1_NEWDAT16_1() uint32 {
	return volatile.LoadUint32(&o.ND1.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetND1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ND1.Reg, volatile.LoadUint32(&o.ND1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetND1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ND1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.ND2: New data 2
func (o *C_CAN1_Type) SetND2_NEWDAT32_17(value uint32) {
	volatile.StoreUint32(&o.ND2.Reg, volatile.LoadUint32(&o.ND2.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetND2_NEWDAT32_17() uint32 {
	return volatile.LoadUint32(&o.ND2.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetND2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ND2.Reg, volatile.LoadUint32(&o.ND2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetND2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ND2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IR1: Interrupt pending 1
func (o *C_CAN1_Type) SetIR1_INTPND16_1(value uint32) {
	volatile.StoreUint32(&o.IR1.Reg, volatile.LoadUint32(&o.IR1.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetIR1_INTPND16_1() uint32 {
	return volatile.LoadUint32(&o.IR1.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetIR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IR1.Reg, volatile.LoadUint32(&o.IR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IR1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.IR2: Interrupt pending 2
func (o *C_CAN1_Type) SetIR2_INTPND32_17(value uint32) {
	volatile.StoreUint32(&o.IR2.Reg, volatile.LoadUint32(&o.IR2.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetIR2_INTPND32_17() uint32 {
	return volatile.LoadUint32(&o.IR2.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetIR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IR2.Reg, volatile.LoadUint32(&o.IR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetIR2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IR2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.MSGV1: Message valid 1
func (o *C_CAN1_Type) SetMSGV1_MSGVAL16_1(value uint32) {
	volatile.StoreUint32(&o.MSGV1.Reg, volatile.LoadUint32(&o.MSGV1.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetMSGV1_MSGVAL16_1() uint32 {
	return volatile.LoadUint32(&o.MSGV1.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetMSGV1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MSGV1.Reg, volatile.LoadUint32(&o.MSGV1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetMSGV1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MSGV1.Reg) & 0xffff0000) >> 16
}

// C_CAN1.MSGV2: Message valid 2
func (o *C_CAN1_Type) SetMSGV2_MSGVAL32_17(value uint32) {
	volatile.StoreUint32(&o.MSGV2.Reg, volatile.LoadUint32(&o.MSGV2.Reg)&^(0xffff)|value)
}
func (o *C_CAN1_Type) GetMSGV2_MSGVAL32_17() uint32 {
	return volatile.LoadUint32(&o.MSGV2.Reg) & 0xffff
}
func (o *C_CAN1_Type) SetMSGV2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MSGV2.Reg, volatile.LoadUint32(&o.MSGV2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN1_Type) GetMSGV2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MSGV2.Reg) & 0xffff0000) >> 16
}

// C_CAN1.CLKDIV: CAN clock divider register
func (o *C_CAN1_Type) SetCLKDIV_CLKDIVVAL(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xf)|value)
}
func (o *C_CAN1_Type) GetCLKDIV_CLKDIVVAL() uint32 {
	return volatile.LoadUint32(&o.CLKDIV.Reg) & 0xf
}
func (o *C_CAN1_Type) SetCLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xfffffff0)|value<<4)
}
func (o *C_CAN1_Type) GetCLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV.Reg) & 0xfffffff0) >> 4
}

// Repetitive Interrupt Timer (RIT)
type RITIMER_Type struct {
	COMPVAL volatile.Register32 // 0x0
	MASK    volatile.Register32 // 0x4
	CTRL    volatile.Register32 // 0x8
	COUNTER volatile.Register32 // 0xC
}

// RITIMER.COMPVAL: Compare register
func (o *RITIMER_Type) SetCOMPVAL(value uint32) {
	volatile.StoreUint32(&o.COMPVAL.Reg, value)
}
func (o *RITIMER_Type) GetCOMPVAL() uint32 {
	return volatile.LoadUint32(&o.COMPVAL.Reg)
}

// RITIMER.MASK: Mask register. This register holds the 32-bit mask value. A 1 written to any bit will force a compare on the corresponding bit of the counter and compare register.
func (o *RITIMER_Type) SetMASK(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, value)
}
func (o *RITIMER_Type) GetMASK() uint32 {
	return volatile.LoadUint32(&o.MASK.Reg)
}

// RITIMER.CTRL: Control register.
func (o *RITIMER_Type) SetCTRL_RITINT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *RITIMER_Type) GetCTRL_RITINT() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *RITIMER_Type) SetCTRL_RITENCLR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *RITIMER_Type) GetCTRL_RITENCLR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *RITIMER_Type) SetCTRL_RITENBR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *RITIMER_Type) GetCTRL_RITENBR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *RITIMER_Type) SetCTRL_RITEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *RITIMER_Type) GetCTRL_RITEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *RITIMER_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RITIMER_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xfffffff0) >> 4
}

// RITIMER.COUNTER: 32-bit counter
func (o *RITIMER_Type) SetCOUNTER(value uint32) {
	volatile.StoreUint32(&o.COUNTER.Reg, value)
}
func (o *RITIMER_Type) GetCOUNTER() uint32 {
	return volatile.LoadUint32(&o.COUNTER.Reg)
}

// Quadrature Encoder Interface (QEI)
type QEI_Type struct {
	CON       volatile.Register32 // 0x0
	STAT      volatile.Register32 // 0x4
	CONF      volatile.Register32 // 0x8
	POS       volatile.Register32 // 0xC
	MAXPOS    volatile.Register32 // 0x10
	CMPOS0    volatile.Register32 // 0x14
	CMPOS1    volatile.Register32 // 0x18
	CMPOS2    volatile.Register32 // 0x1C
	INXCNT    volatile.Register32 // 0x20
	INXCMP0   volatile.Register32 // 0x24
	LOAD      volatile.Register32 // 0x28
	TIME      volatile.Register32 // 0x2C
	VEL       volatile.Register32 // 0x30
	CAP       volatile.Register32 // 0x34
	VELCOMP   volatile.Register32 // 0x38
	FILTERPHA volatile.Register32 // 0x3C
	FILTERPHB volatile.Register32 // 0x40
	FILTERINX volatile.Register32 // 0x44
	WINDOW    volatile.Register32 // 0x48
	INXCMP1   volatile.Register32 // 0x4C
	INXCMP2   volatile.Register32 // 0x50
	_         [3972]byte
	IEC       volatile.Register32 // 0xFD8
	IES       volatile.Register32 // 0xFDC
	INTSTAT   volatile.Register32 // 0xFE0
	IE        volatile.Register32 // 0xFE4
	CLR       volatile.Register32 // 0xFE8
	SET       volatile.Register32 // 0xFEC
}

// QEI.CON: Control register
func (o *QEI_Type) SetCON_RESP(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetCON_RESP() uint32 {
	return volatile.LoadUint32(&o.CON.Reg) & 0x1
}
func (o *QEI_Type) SetCON_RESPI(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetCON_RESPI() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetCON_RESV(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetCON_RESV() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetCON_RESI(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetCON_RESI() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0xfffffff0)|value<<4)
}
func (o *QEI_Type) GetCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0xfffffff0) >> 4
}

// QEI.STAT: Encoder status register
func (o *QEI_Type) SetSTAT_DIR(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetSTAT_DIR() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}
func (o *QEI_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *QEI_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xfffffffe) >> 1
}

// QEI.CONF: Configuration register
func (o *QEI_Type) SetCONF_DIRINV(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetCONF_DIRINV() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x1
}
func (o *QEI_Type) SetCONF_SIGMODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetCONF_SIGMODE() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetCONF_CAPMODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetCONF_CAPMODE() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetCONF_INVINX(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetCONF_INVINX() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetCONF_CRESPI(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetCONF_CRESPI() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetCONF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xffe0)|value<<5)
}
func (o *QEI_Type) GetCONF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xffe0) >> 5
}
func (o *QEI_Type) SetCONF_INXGATE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xf0000)|value<<16)
}
func (o *QEI_Type) GetCONF_INXGATE() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xf0000) >> 16
}
func (o *QEI_Type) SetCONF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xfff00000)|value<<20)
}
func (o *QEI_Type) GetCONF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xfff00000) >> 20
}

// QEI.POS: Position register
func (o *QEI_Type) SetPOS(value uint32) {
	volatile.StoreUint32(&o.POS.Reg, value)
}
func (o *QEI_Type) GetPOS() uint32 {
	return volatile.LoadUint32(&o.POS.Reg)
}

// QEI.MAXPOS: Maximum position register
func (o *QEI_Type) SetMAXPOS(value uint32) {
	volatile.StoreUint32(&o.MAXPOS.Reg, value)
}
func (o *QEI_Type) GetMAXPOS() uint32 {
	return volatile.LoadUint32(&o.MAXPOS.Reg)
}

// QEI.CMPOS0: position compare register 0
func (o *QEI_Type) SetCMPOS0(value uint32) {
	volatile.StoreUint32(&o.CMPOS0.Reg, value)
}
func (o *QEI_Type) GetCMPOS0() uint32 {
	return volatile.LoadUint32(&o.CMPOS0.Reg)
}

// QEI.CMPOS1: position compare register 1
func (o *QEI_Type) SetCMPOS1(value uint32) {
	volatile.StoreUint32(&o.CMPOS1.Reg, value)
}
func (o *QEI_Type) GetCMPOS1() uint32 {
	return volatile.LoadUint32(&o.CMPOS1.Reg)
}

// QEI.CMPOS2: position compare register 2
func (o *QEI_Type) SetCMPOS2(value uint32) {
	volatile.StoreUint32(&o.CMPOS2.Reg, value)
}
func (o *QEI_Type) GetCMPOS2() uint32 {
	return volatile.LoadUint32(&o.CMPOS2.Reg)
}

// QEI.INXCNT: Index count register
func (o *QEI_Type) SetINXCNT(value uint32) {
	volatile.StoreUint32(&o.INXCNT.Reg, value)
}
func (o *QEI_Type) GetINXCNT() uint32 {
	return volatile.LoadUint32(&o.INXCNT.Reg)
}

// QEI.INXCMP0: Index compare register 0
func (o *QEI_Type) SetINXCMP0(value uint32) {
	volatile.StoreUint32(&o.INXCMP0.Reg, value)
}
func (o *QEI_Type) GetINXCMP0() uint32 {
	return volatile.LoadUint32(&o.INXCMP0.Reg)
}

// QEI.LOAD: Velocity timer reload register
func (o *QEI_Type) SetLOAD(value uint32) {
	volatile.StoreUint32(&o.LOAD.Reg, value)
}
func (o *QEI_Type) GetLOAD() uint32 {
	return volatile.LoadUint32(&o.LOAD.Reg)
}

// QEI.TIME: Velocity timer register
func (o *QEI_Type) SetTIME(value uint32) {
	volatile.StoreUint32(&o.TIME.Reg, value)
}
func (o *QEI_Type) GetTIME() uint32 {
	return volatile.LoadUint32(&o.TIME.Reg)
}

// QEI.VEL: Velocity counter register
func (o *QEI_Type) SetVEL(value uint32) {
	volatile.StoreUint32(&o.VEL.Reg, value)
}
func (o *QEI_Type) GetVEL() uint32 {
	return volatile.LoadUint32(&o.VEL.Reg)
}

// QEI.CAP: Velocity capture register
func (o *QEI_Type) SetCAP(value uint32) {
	volatile.StoreUint32(&o.CAP.Reg, value)
}
func (o *QEI_Type) GetCAP() uint32 {
	return volatile.LoadUint32(&o.CAP.Reg)
}

// QEI.VELCOMP: Velocity compare register
func (o *QEI_Type) SetVELCOMP(value uint32) {
	volatile.StoreUint32(&o.VELCOMP.Reg, value)
}
func (o *QEI_Type) GetVELCOMP() uint32 {
	return volatile.LoadUint32(&o.VELCOMP.Reg)
}

// QEI.FILTERPHA: Digital filter register on input phase A (QEI_A)
func (o *QEI_Type) SetFILTERPHA(value uint32) {
	volatile.StoreUint32(&o.FILTERPHA.Reg, value)
}
func (o *QEI_Type) GetFILTERPHA() uint32 {
	return volatile.LoadUint32(&o.FILTERPHA.Reg)
}

// QEI.FILTERPHB: Digital filter register on input phase B (QEI_B)
func (o *QEI_Type) SetFILTERPHB(value uint32) {
	volatile.StoreUint32(&o.FILTERPHB.Reg, value)
}
func (o *QEI_Type) GetFILTERPHB() uint32 {
	return volatile.LoadUint32(&o.FILTERPHB.Reg)
}

// QEI.FILTERINX: Digital filter register on input index (QEI_IDX)
func (o *QEI_Type) SetFILTERINX(value uint32) {
	volatile.StoreUint32(&o.FILTERINX.Reg, value)
}
func (o *QEI_Type) GetFILTERINX() uint32 {
	return volatile.LoadUint32(&o.FILTERINX.Reg)
}

// QEI.WINDOW: Index acceptance window register
func (o *QEI_Type) SetWINDOW(value uint32) {
	volatile.StoreUint32(&o.WINDOW.Reg, value)
}
func (o *QEI_Type) GetWINDOW() uint32 {
	return volatile.LoadUint32(&o.WINDOW.Reg)
}

// QEI.INXCMP1: Index compare register 1
func (o *QEI_Type) SetINXCMP1(value uint32) {
	volatile.StoreUint32(&o.INXCMP1.Reg, value)
}
func (o *QEI_Type) GetINXCMP1() uint32 {
	return volatile.LoadUint32(&o.INXCMP1.Reg)
}

// QEI.INXCMP2: Index compare register 2
func (o *QEI_Type) SetINXCMP2(value uint32) {
	volatile.StoreUint32(&o.INXCMP2.Reg, value)
}
func (o *QEI_Type) GetINXCMP2() uint32 {
	return volatile.LoadUint32(&o.INXCMP2.Reg)
}

// QEI.IEC: Interrupt enable clear register
func (o *QEI_Type) SetIEC_INX_EN(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetIEC_INX_EN() uint32 {
	return volatile.LoadUint32(&o.IEC.Reg) & 0x1
}
func (o *QEI_Type) SetIEC_TIM_EN(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetIEC_TIM_EN() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetIEC_VELC_EN(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetIEC_VELC_EN() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetIEC_DIR_EN(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetIEC_DIR_EN() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetIEC_ERR_EN(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetIEC_ERR_EN() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetIEC_ENCLK_EN(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetIEC_ENCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetIEC_POS0_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetIEC_POS0_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetIEC_POS1_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetIEC_POS1_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetIEC_POS2_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetIEC_POS2_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetIEC_REV_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetIEC_REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetIEC_POS0REV_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetIEC_POS0REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetIEC_POS1REV_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetIEC_POS1REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetIEC_POS2REV_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetIEC_POS2REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetIEC_REV1_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetIEC_REV1_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetIEC_REV2_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetIEC_REV2_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetIEC_MAXPOS_Int(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetIEC_MAXPOS_Int() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetIEC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetIEC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0xffff0000) >> 16
}

// QEI.IES: Interrupt enable set register
func (o *QEI_Type) SetIES_INX_EN(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetIES_INX_EN() uint32 {
	return volatile.LoadUint32(&o.IES.Reg) & 0x1
}
func (o *QEI_Type) SetIES_TIM_EN(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetIES_TIM_EN() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetIES_VELC_EN(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetIES_VELC_EN() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetIES_DIR_EN(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetIES_DIR_EN() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetIES_ERR_EN(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetIES_ERR_EN() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetIES_ENCLK_EN(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetIES_ENCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetIES_POS0_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetIES_POS0_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetIES_POS1_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetIES_POS1_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetIES_POS2_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetIES_POS2_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetIES_REV_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetIES_REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetIES_POS0REV_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetIES_POS0REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetIES_POS1REV_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetIES_POS1REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetIES_POS2REV_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetIES_POS2REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetIES_REV1_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetIES_REV1_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetIES_REV2_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetIES_REV2_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetIES_MAXPOS_Int(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetIES_MAXPOS_Int() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetIES_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetIES_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0xffff0000) >> 16
}

// QEI.INTSTAT: Interrupt status register
func (o *QEI_Type) SetINTSTAT_INX_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetINTSTAT_INX_Int() uint32 {
	return volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1
}
func (o *QEI_Type) SetINTSTAT_TIM_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetINTSTAT_TIM_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetINTSTAT_VELC_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetINTSTAT_VELC_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetINTSTAT_DIR_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetINTSTAT_DIR_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetINTSTAT_ERR_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetINTSTAT_ERR_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetINTSTAT_ENCLK_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetINTSTAT_ENCLK_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetINTSTAT_POS0_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetINTSTAT_POS0_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetINTSTAT_POS1_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetINTSTAT_POS1_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetINTSTAT_POS2_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetINTSTAT_POS2_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetINTSTAT_REV_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetINTSTAT_REV_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetINTSTAT_POS0REV_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetINTSTAT_POS0REV_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetINTSTAT_POS1REV_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetINTSTAT_POS1REV_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetINTSTAT_POS2REV_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetINTSTAT_POS2REV_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetINTSTAT_REV1_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetINTSTAT_REV1_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetINTSTAT_REV2_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetINTSTAT_REV2_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetINTSTAT_MAXPOS_Int(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetINTSTAT_MAXPOS_Int() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetINTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0xffff0000) >> 16
}

// QEI.IE: Interrupt enable register
func (o *QEI_Type) SetIE_INX_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetIE_INX_Int() uint32 {
	return volatile.LoadUint32(&o.IE.Reg) & 0x1
}
func (o *QEI_Type) SetIE_TIM_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetIE_TIM_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetIE_VELC_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetIE_VELC_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetIE_DIR_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetIE_DIR_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetIE_ERR_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetIE_ERR_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetIE_ENCLK_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetIE_ENCLK_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetIE_POS0_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetIE_POS0_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetIE_POS1_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetIE_POS1_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetIE_POS2_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetIE_POS2_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetIE_REV_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetIE_REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetIE_POS0REV_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetIE_POS0REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetIE_POS1REV_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetIE_POS1REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetIE_POS2REV_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetIE_POS2REV_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetIE_REV1_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetIE_REV1_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetIE_REV2_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetIE_REV2_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetIE_MAXPOS_Int(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetIE_MAXPOS_Int() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetIE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetIE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0xffff0000) >> 16
}

// QEI.CLR: Interrupt status clear register
func (o *QEI_Type) SetCLR_INX_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetCLR_INX_Int() uint32 {
	return volatile.LoadUint32(&o.CLR.Reg) & 0x1
}
func (o *QEI_Type) SetCLR_TIM_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetCLR_TIM_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetCLR_VELC_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetCLR_VELC_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetCLR_DIR_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetCLR_DIR_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetCLR_ERR_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetCLR_ERR_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetCLR_ENCLK_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetCLR_ENCLK_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetCLR_POS0_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetCLR_POS0_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetCLR_POS1_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetCLR_POS1_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetCLR_POS2_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetCLR_POS2_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetCLR_REV_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetCLR_REV_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetCLR_POS0REV_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetCLR_POS0REV_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetCLR_POS1REV_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetCLR_POS1REV_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetCLR_REV1_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetCLR_REV1_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetCLR_REV2_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetCLR_REV2_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetCLR_MAXPOS_Int(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetCLR_MAXPOS_Int() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0xffff0000) >> 16
}

// QEI.SET: Interrupt status set register
func (o *QEI_Type) SetSET_INX_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetSET_INX_Int() uint32 {
	return volatile.LoadUint32(&o.SET.Reg) & 0x1
}
func (o *QEI_Type) SetSET_TIM_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetSET_TIM_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetSET_VELC_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetSET_VELC_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetSET_DIR_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetSET_DIR_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetSET_ERR_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetSET_ERR_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetSET_ENCLK_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetSET_ENCLK_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetSET_POS0_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetSET_POS0_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetSET_POS1_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetSET_POS1_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetSET_POS2_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetSET_POS2_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetSET_REV_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetSET_REV_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetSET_POS0REV_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetSET_POS0REV_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetSET_POS1REV_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetSET_POS1REV_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetSET_POS2REV_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetSET_POS2REV_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetSET_REV1_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetSET_REV1_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetSET_REV2_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetSET_REV2_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetSET_MAXPOS_Int(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetSET_MAXPOS_Int() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0xffff0000) >> 16
}

// Global Input Multiplexer Array (GIMA)
type GIMA_Type struct {
	CAP0_0_IN         volatile.Register32 // 0x0
	CAP0_1_IN         volatile.Register32 // 0x4
	CAP0_2_IN         volatile.Register32 // 0x8
	CAP0_3_IN         volatile.Register32 // 0xC
	CAP1_0_IN         volatile.Register32 // 0x10
	CAP1_1_IN         volatile.Register32 // 0x14
	CAP1_2_IN         volatile.Register32 // 0x18
	CAP1_3_IN         volatile.Register32 // 0x1C
	CAP2_0_IN         volatile.Register32 // 0x20
	CAP2_1_IN         volatile.Register32 // 0x24
	CAP2_2_IN         volatile.Register32 // 0x28
	CAP2_3_IN         volatile.Register32 // 0x2C
	CAP3_0_IN         volatile.Register32 // 0x30
	CAP3_1_IN         volatile.Register32 // 0x34
	CAP3_2_IN         volatile.Register32 // 0x38
	CAP3_3_IN         volatile.Register32 // 0x3C
	CTIN_0_IN         volatile.Register32 // 0x40
	CTIN_1_IN         volatile.Register32 // 0x44
	CTIN_2_IN         volatile.Register32 // 0x48
	CTIN_3_IN         volatile.Register32 // 0x4C
	CTIN_4_IN         volatile.Register32 // 0x50
	CTIN_5_IN         volatile.Register32 // 0x54
	CTIN_6_IN         volatile.Register32 // 0x58
	CTIN_7_IN         volatile.Register32 // 0x5C
	_                 [4]byte
	EVENTROUTER_13_IN volatile.Register32 // 0x64
	EVENTROUTER_14_IN volatile.Register32 // 0x68
	EVENTROUTER_16_IN volatile.Register32 // 0x6C
	ADCSTART0_IN      volatile.Register32 // 0x70
	ADCSTART1_IN      volatile.Register32 // 0x74
}

// GIMA.CAP0_0_IN: Timer 0 CAP0_0 capture input multiplexer (GIMA output 0)
func (o *GIMA_Type) SetCAP0_0_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP0_0_IN.Reg, volatile.LoadUint32(&o.CAP0_0_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP0_0_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP0_0_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP0_0_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP0_0_IN.Reg, volatile.LoadUint32(&o.CAP0_0_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP0_0_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP0_0_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP0_0_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP0_0_IN.Reg, volatile.LoadUint32(&o.CAP0_0_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP0_0_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP0_0_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP0_0_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP0_0_IN.Reg, volatile.LoadUint32(&o.CAP0_0_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP0_0_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP0_0_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP0_0_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP0_0_IN.Reg, volatile.LoadUint32(&o.CAP0_0_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP0_0_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP0_0_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP0_0_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP0_0_IN.Reg, volatile.LoadUint32(&o.CAP0_0_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP0_0_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP0_0_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP0_1_IN: Timer 0 CAP0_1 capture input multiplexer (GIMA output 1)
func (o *GIMA_Type) SetCAP0_1_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP0_1_IN.Reg, volatile.LoadUint32(&o.CAP0_1_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP0_1_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP0_1_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP0_1_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP0_1_IN.Reg, volatile.LoadUint32(&o.CAP0_1_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP0_1_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP0_1_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP0_1_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP0_1_IN.Reg, volatile.LoadUint32(&o.CAP0_1_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP0_1_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP0_1_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP0_1_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP0_1_IN.Reg, volatile.LoadUint32(&o.CAP0_1_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP0_1_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP0_1_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP0_1_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP0_1_IN.Reg, volatile.LoadUint32(&o.CAP0_1_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP0_1_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP0_1_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP0_1_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP0_1_IN.Reg, volatile.LoadUint32(&o.CAP0_1_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP0_1_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP0_1_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP0_2_IN: Timer 0 CAP0_2 capture input multiplexer (GIMA output 2)
func (o *GIMA_Type) SetCAP0_2_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP0_2_IN.Reg, volatile.LoadUint32(&o.CAP0_2_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP0_2_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP0_2_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP0_2_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP0_2_IN.Reg, volatile.LoadUint32(&o.CAP0_2_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP0_2_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP0_2_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP0_2_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP0_2_IN.Reg, volatile.LoadUint32(&o.CAP0_2_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP0_2_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP0_2_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP0_2_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP0_2_IN.Reg, volatile.LoadUint32(&o.CAP0_2_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP0_2_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP0_2_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP0_2_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP0_2_IN.Reg, volatile.LoadUint32(&o.CAP0_2_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP0_2_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP0_2_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP0_2_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP0_2_IN.Reg, volatile.LoadUint32(&o.CAP0_2_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP0_2_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP0_2_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP0_3_IN: Timer 0 CAP0_3 capture input multiplexer (GIMA output 3)
func (o *GIMA_Type) SetCAP0_3_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP0_3_IN.Reg, volatile.LoadUint32(&o.CAP0_3_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP0_3_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP0_3_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP0_3_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP0_3_IN.Reg, volatile.LoadUint32(&o.CAP0_3_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP0_3_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP0_3_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP0_3_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP0_3_IN.Reg, volatile.LoadUint32(&o.CAP0_3_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP0_3_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP0_3_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP0_3_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP0_3_IN.Reg, volatile.LoadUint32(&o.CAP0_3_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP0_3_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP0_3_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP0_3_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP0_3_IN.Reg, volatile.LoadUint32(&o.CAP0_3_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP0_3_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP0_3_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP0_3_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP0_3_IN.Reg, volatile.LoadUint32(&o.CAP0_3_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP0_3_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP0_3_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP1_0_IN: Timer 1 CAP1_0 capture input multiplexer (GIMA output 4)
func (o *GIMA_Type) SetCAP1_0_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP1_0_IN.Reg, volatile.LoadUint32(&o.CAP1_0_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP1_0_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP1_0_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP1_0_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP1_0_IN.Reg, volatile.LoadUint32(&o.CAP1_0_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP1_0_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP1_0_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP1_0_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP1_0_IN.Reg, volatile.LoadUint32(&o.CAP1_0_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP1_0_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP1_0_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP1_0_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP1_0_IN.Reg, volatile.LoadUint32(&o.CAP1_0_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP1_0_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP1_0_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP1_0_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP1_0_IN.Reg, volatile.LoadUint32(&o.CAP1_0_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP1_0_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP1_0_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP1_0_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP1_0_IN.Reg, volatile.LoadUint32(&o.CAP1_0_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP1_0_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP1_0_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP1_1_IN: Timer 1 CAP1_1 capture input multiplexer (GIMA output 5)
func (o *GIMA_Type) SetCAP1_1_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP1_1_IN.Reg, volatile.LoadUint32(&o.CAP1_1_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP1_1_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP1_1_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP1_1_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP1_1_IN.Reg, volatile.LoadUint32(&o.CAP1_1_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP1_1_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP1_1_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP1_1_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP1_1_IN.Reg, volatile.LoadUint32(&o.CAP1_1_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP1_1_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP1_1_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP1_1_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP1_1_IN.Reg, volatile.LoadUint32(&o.CAP1_1_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP1_1_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP1_1_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP1_1_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP1_1_IN.Reg, volatile.LoadUint32(&o.CAP1_1_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP1_1_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP1_1_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP1_1_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP1_1_IN.Reg, volatile.LoadUint32(&o.CAP1_1_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP1_1_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP1_1_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP1_2_IN: Timer 1 CAP1_2 capture input multiplexer (GIMA output 6)
func (o *GIMA_Type) SetCAP1_2_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP1_2_IN.Reg, volatile.LoadUint32(&o.CAP1_2_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP1_2_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP1_2_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP1_2_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP1_2_IN.Reg, volatile.LoadUint32(&o.CAP1_2_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP1_2_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP1_2_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP1_2_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP1_2_IN.Reg, volatile.LoadUint32(&o.CAP1_2_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP1_2_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP1_2_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP1_2_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP1_2_IN.Reg, volatile.LoadUint32(&o.CAP1_2_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP1_2_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP1_2_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP1_2_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP1_2_IN.Reg, volatile.LoadUint32(&o.CAP1_2_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP1_2_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP1_2_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP1_2_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP1_2_IN.Reg, volatile.LoadUint32(&o.CAP1_2_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP1_2_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP1_2_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP1_3_IN: Timer 1 CAP1_3 capture input multiplexer (GIMA output 7)
func (o *GIMA_Type) SetCAP1_3_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP1_3_IN.Reg, volatile.LoadUint32(&o.CAP1_3_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP1_3_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP1_3_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP1_3_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP1_3_IN.Reg, volatile.LoadUint32(&o.CAP1_3_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP1_3_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP1_3_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP1_3_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP1_3_IN.Reg, volatile.LoadUint32(&o.CAP1_3_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP1_3_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP1_3_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP1_3_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP1_3_IN.Reg, volatile.LoadUint32(&o.CAP1_3_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP1_3_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP1_3_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP1_3_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP1_3_IN.Reg, volatile.LoadUint32(&o.CAP1_3_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP1_3_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP1_3_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP1_3_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP1_3_IN.Reg, volatile.LoadUint32(&o.CAP1_3_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP1_3_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP1_3_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP2_0_IN: Timer 2 CAP2_0 capture input multiplexer (GIMA output 8)
func (o *GIMA_Type) SetCAP2_0_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP2_0_IN.Reg, volatile.LoadUint32(&o.CAP2_0_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP2_0_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP2_0_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP2_0_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP2_0_IN.Reg, volatile.LoadUint32(&o.CAP2_0_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP2_0_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP2_0_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP2_0_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP2_0_IN.Reg, volatile.LoadUint32(&o.CAP2_0_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP2_0_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP2_0_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP2_0_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP2_0_IN.Reg, volatile.LoadUint32(&o.CAP2_0_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP2_0_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP2_0_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP2_0_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP2_0_IN.Reg, volatile.LoadUint32(&o.CAP2_0_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP2_0_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP2_0_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP2_0_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP2_0_IN.Reg, volatile.LoadUint32(&o.CAP2_0_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP2_0_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP2_0_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP2_1_IN: Timer 2 CAP2_1 capture input multiplexer (GIMA output 9)
func (o *GIMA_Type) SetCAP2_1_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP2_1_IN.Reg, volatile.LoadUint32(&o.CAP2_1_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP2_1_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP2_1_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP2_1_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP2_1_IN.Reg, volatile.LoadUint32(&o.CAP2_1_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP2_1_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP2_1_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP2_1_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP2_1_IN.Reg, volatile.LoadUint32(&o.CAP2_1_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP2_1_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP2_1_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP2_1_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP2_1_IN.Reg, volatile.LoadUint32(&o.CAP2_1_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP2_1_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP2_1_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP2_1_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP2_1_IN.Reg, volatile.LoadUint32(&o.CAP2_1_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP2_1_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP2_1_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP2_1_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP2_1_IN.Reg, volatile.LoadUint32(&o.CAP2_1_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP2_1_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP2_1_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP2_2_IN: Timer 2 CAP2_2 capture input multiplexer (GIMA output 10)
func (o *GIMA_Type) SetCAP2_2_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP2_2_IN.Reg, volatile.LoadUint32(&o.CAP2_2_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP2_2_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP2_2_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP2_2_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP2_2_IN.Reg, volatile.LoadUint32(&o.CAP2_2_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP2_2_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP2_2_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP2_2_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP2_2_IN.Reg, volatile.LoadUint32(&o.CAP2_2_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP2_2_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP2_2_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP2_2_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP2_2_IN.Reg, volatile.LoadUint32(&o.CAP2_2_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP2_2_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP2_2_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP2_2_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP2_2_IN.Reg, volatile.LoadUint32(&o.CAP2_2_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP2_2_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP2_2_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP2_2_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP2_2_IN.Reg, volatile.LoadUint32(&o.CAP2_2_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP2_2_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP2_2_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP2_3_IN: Timer 2 CAP2_3 capture input multiplexer (GIMA output 11)
func (o *GIMA_Type) SetCAP2_3_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP2_3_IN.Reg, volatile.LoadUint32(&o.CAP2_3_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP2_3_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP2_3_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP2_3_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP2_3_IN.Reg, volatile.LoadUint32(&o.CAP2_3_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP2_3_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP2_3_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP2_3_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP2_3_IN.Reg, volatile.LoadUint32(&o.CAP2_3_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP2_3_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP2_3_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP2_3_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP2_3_IN.Reg, volatile.LoadUint32(&o.CAP2_3_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP2_3_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP2_3_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP2_3_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP2_3_IN.Reg, volatile.LoadUint32(&o.CAP2_3_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP2_3_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP2_3_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP2_3_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP2_3_IN.Reg, volatile.LoadUint32(&o.CAP2_3_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP2_3_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP2_3_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP3_0_IN: Timer 3 CAP3_0 capture input multiplexer (GIMA output 12)
func (o *GIMA_Type) SetCAP3_0_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP3_0_IN.Reg, volatile.LoadUint32(&o.CAP3_0_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP3_0_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP3_0_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP3_0_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP3_0_IN.Reg, volatile.LoadUint32(&o.CAP3_0_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP3_0_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP3_0_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP3_0_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP3_0_IN.Reg, volatile.LoadUint32(&o.CAP3_0_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP3_0_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP3_0_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP3_0_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP3_0_IN.Reg, volatile.LoadUint32(&o.CAP3_0_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP3_0_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP3_0_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP3_0_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP3_0_IN.Reg, volatile.LoadUint32(&o.CAP3_0_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP3_0_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP3_0_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP3_0_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP3_0_IN.Reg, volatile.LoadUint32(&o.CAP3_0_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP3_0_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP3_0_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP3_1_IN: Timer 3 CAP3_1 capture input multiplexer (GIMA output 13)
func (o *GIMA_Type) SetCAP3_1_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP3_1_IN.Reg, volatile.LoadUint32(&o.CAP3_1_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP3_1_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP3_1_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP3_1_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP3_1_IN.Reg, volatile.LoadUint32(&o.CAP3_1_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP3_1_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP3_1_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP3_1_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP3_1_IN.Reg, volatile.LoadUint32(&o.CAP3_1_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP3_1_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP3_1_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP3_1_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP3_1_IN.Reg, volatile.LoadUint32(&o.CAP3_1_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP3_1_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP3_1_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP3_1_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP3_1_IN.Reg, volatile.LoadUint32(&o.CAP3_1_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP3_1_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP3_1_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP3_1_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP3_1_IN.Reg, volatile.LoadUint32(&o.CAP3_1_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP3_1_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP3_1_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP3_2_IN: Timer 3 CAP3_2 capture input multiplexer (GIMA output 14)
func (o *GIMA_Type) SetCAP3_2_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP3_2_IN.Reg, volatile.LoadUint32(&o.CAP3_2_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP3_2_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP3_2_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP3_2_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP3_2_IN.Reg, volatile.LoadUint32(&o.CAP3_2_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP3_2_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP3_2_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP3_2_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP3_2_IN.Reg, volatile.LoadUint32(&o.CAP3_2_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP3_2_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP3_2_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP3_2_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP3_2_IN.Reg, volatile.LoadUint32(&o.CAP3_2_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP3_2_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP3_2_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP3_2_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP3_2_IN.Reg, volatile.LoadUint32(&o.CAP3_2_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP3_2_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP3_2_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP3_2_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP3_2_IN.Reg, volatile.LoadUint32(&o.CAP3_2_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP3_2_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP3_2_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CAP3_3_IN: Timer 3 CAP3_3 capture input multiplexer (GIMA output 15)
func (o *GIMA_Type) SetCAP3_3_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CAP3_3_IN.Reg, volatile.LoadUint32(&o.CAP3_3_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCAP3_3_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CAP3_3_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCAP3_3_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CAP3_3_IN.Reg, volatile.LoadUint32(&o.CAP3_3_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCAP3_3_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CAP3_3_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCAP3_3_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CAP3_3_IN.Reg, volatile.LoadUint32(&o.CAP3_3_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCAP3_3_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CAP3_3_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCAP3_3_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CAP3_3_IN.Reg, volatile.LoadUint32(&o.CAP3_3_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCAP3_3_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CAP3_3_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCAP3_3_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CAP3_3_IN.Reg, volatile.LoadUint32(&o.CAP3_3_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCAP3_3_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CAP3_3_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCAP3_3_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP3_3_IN.Reg, volatile.LoadUint32(&o.CAP3_3_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCAP3_3_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP3_3_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CTIN_0_IN: SCT CTIN_0 capture input multiplexer (GIMA output 16)
func (o *GIMA_Type) SetCTIN_0_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CTIN_0_IN.Reg, volatile.LoadUint32(&o.CTIN_0_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCTIN_0_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CTIN_0_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCTIN_0_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CTIN_0_IN.Reg, volatile.LoadUint32(&o.CTIN_0_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCTIN_0_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_0_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCTIN_0_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CTIN_0_IN.Reg, volatile.LoadUint32(&o.CTIN_0_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCTIN_0_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CTIN_0_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCTIN_0_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CTIN_0_IN.Reg, volatile.LoadUint32(&o.CTIN_0_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCTIN_0_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_0_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCTIN_0_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CTIN_0_IN.Reg, volatile.LoadUint32(&o.CTIN_0_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCTIN_0_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CTIN_0_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCTIN_0_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIN_0_IN.Reg, volatile.LoadUint32(&o.CTIN_0_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCTIN_0_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIN_0_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CTIN_1_IN: SCT CTIN_1 capture input multiplexer (GIMA output 17)
func (o *GIMA_Type) SetCTIN_1_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CTIN_1_IN.Reg, volatile.LoadUint32(&o.CTIN_1_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCTIN_1_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CTIN_1_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCTIN_1_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CTIN_1_IN.Reg, volatile.LoadUint32(&o.CTIN_1_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCTIN_1_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_1_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCTIN_1_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CTIN_1_IN.Reg, volatile.LoadUint32(&o.CTIN_1_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCTIN_1_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CTIN_1_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCTIN_1_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CTIN_1_IN.Reg, volatile.LoadUint32(&o.CTIN_1_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCTIN_1_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_1_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCTIN_1_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CTIN_1_IN.Reg, volatile.LoadUint32(&o.CTIN_1_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCTIN_1_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CTIN_1_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCTIN_1_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIN_1_IN.Reg, volatile.LoadUint32(&o.CTIN_1_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCTIN_1_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIN_1_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CTIN_2_IN: SCT CTIN_2 capture input multiplexer (GIMA output 18)
func (o *GIMA_Type) SetCTIN_2_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CTIN_2_IN.Reg, volatile.LoadUint32(&o.CTIN_2_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCTIN_2_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CTIN_2_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCTIN_2_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CTIN_2_IN.Reg, volatile.LoadUint32(&o.CTIN_2_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCTIN_2_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_2_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCTIN_2_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CTIN_2_IN.Reg, volatile.LoadUint32(&o.CTIN_2_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCTIN_2_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CTIN_2_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCTIN_2_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CTIN_2_IN.Reg, volatile.LoadUint32(&o.CTIN_2_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCTIN_2_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_2_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCTIN_2_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CTIN_2_IN.Reg, volatile.LoadUint32(&o.CTIN_2_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCTIN_2_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CTIN_2_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCTIN_2_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIN_2_IN.Reg, volatile.LoadUint32(&o.CTIN_2_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCTIN_2_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIN_2_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CTIN_3_IN: SCT CTIN_3 capture input multiplexer (GIMA output 19)
func (o *GIMA_Type) SetCTIN_3_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CTIN_3_IN.Reg, volatile.LoadUint32(&o.CTIN_3_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCTIN_3_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CTIN_3_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCTIN_3_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CTIN_3_IN.Reg, volatile.LoadUint32(&o.CTIN_3_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCTIN_3_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_3_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCTIN_3_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CTIN_3_IN.Reg, volatile.LoadUint32(&o.CTIN_3_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCTIN_3_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CTIN_3_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCTIN_3_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CTIN_3_IN.Reg, volatile.LoadUint32(&o.CTIN_3_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCTIN_3_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_3_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCTIN_3_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CTIN_3_IN.Reg, volatile.LoadUint32(&o.CTIN_3_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCTIN_3_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CTIN_3_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCTIN_3_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIN_3_IN.Reg, volatile.LoadUint32(&o.CTIN_3_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCTIN_3_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIN_3_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CTIN_4_IN: SCT CTIN_4 capture input multiplexer (GIMA output 20)
func (o *GIMA_Type) SetCTIN_4_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CTIN_4_IN.Reg, volatile.LoadUint32(&o.CTIN_4_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCTIN_4_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CTIN_4_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCTIN_4_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CTIN_4_IN.Reg, volatile.LoadUint32(&o.CTIN_4_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCTIN_4_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_4_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCTIN_4_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CTIN_4_IN.Reg, volatile.LoadUint32(&o.CTIN_4_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCTIN_4_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CTIN_4_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCTIN_4_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CTIN_4_IN.Reg, volatile.LoadUint32(&o.CTIN_4_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCTIN_4_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_4_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCTIN_4_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CTIN_4_IN.Reg, volatile.LoadUint32(&o.CTIN_4_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCTIN_4_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CTIN_4_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCTIN_4_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIN_4_IN.Reg, volatile.LoadUint32(&o.CTIN_4_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCTIN_4_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIN_4_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CTIN_5_IN: SCT CTIN_5 capture input multiplexer (GIMA output 21)
func (o *GIMA_Type) SetCTIN_5_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CTIN_5_IN.Reg, volatile.LoadUint32(&o.CTIN_5_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCTIN_5_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CTIN_5_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCTIN_5_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CTIN_5_IN.Reg, volatile.LoadUint32(&o.CTIN_5_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCTIN_5_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_5_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCTIN_5_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CTIN_5_IN.Reg, volatile.LoadUint32(&o.CTIN_5_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCTIN_5_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CTIN_5_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCTIN_5_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CTIN_5_IN.Reg, volatile.LoadUint32(&o.CTIN_5_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCTIN_5_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_5_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCTIN_5_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CTIN_5_IN.Reg, volatile.LoadUint32(&o.CTIN_5_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCTIN_5_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CTIN_5_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCTIN_5_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIN_5_IN.Reg, volatile.LoadUint32(&o.CTIN_5_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCTIN_5_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIN_5_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CTIN_6_IN: SCT CTIN_6 capture input multiplexer (GIMA output 22)
func (o *GIMA_Type) SetCTIN_6_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CTIN_6_IN.Reg, volatile.LoadUint32(&o.CTIN_6_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCTIN_6_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CTIN_6_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCTIN_6_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CTIN_6_IN.Reg, volatile.LoadUint32(&o.CTIN_6_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCTIN_6_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_6_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCTIN_6_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CTIN_6_IN.Reg, volatile.LoadUint32(&o.CTIN_6_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCTIN_6_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CTIN_6_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCTIN_6_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CTIN_6_IN.Reg, volatile.LoadUint32(&o.CTIN_6_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCTIN_6_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_6_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCTIN_6_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CTIN_6_IN.Reg, volatile.LoadUint32(&o.CTIN_6_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCTIN_6_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CTIN_6_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCTIN_6_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIN_6_IN.Reg, volatile.LoadUint32(&o.CTIN_6_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCTIN_6_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIN_6_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.CTIN_7_IN: SCT CTIN_7 capture input multiplexer (GIMA output 23)
func (o *GIMA_Type) SetCTIN_7_IN_INV(value uint32) {
	volatile.StoreUint32(&o.CTIN_7_IN.Reg, volatile.LoadUint32(&o.CTIN_7_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetCTIN_7_IN_INV() uint32 {
	return volatile.LoadUint32(&o.CTIN_7_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetCTIN_7_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.CTIN_7_IN.Reg, volatile.LoadUint32(&o.CTIN_7_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetCTIN_7_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_7_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetCTIN_7_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.CTIN_7_IN.Reg, volatile.LoadUint32(&o.CTIN_7_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetCTIN_7_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.CTIN_7_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetCTIN_7_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.CTIN_7_IN.Reg, volatile.LoadUint32(&o.CTIN_7_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetCTIN_7_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.CTIN_7_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetCTIN_7_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.CTIN_7_IN.Reg, volatile.LoadUint32(&o.CTIN_7_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetCTIN_7_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.CTIN_7_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetCTIN_7_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIN_7_IN.Reg, volatile.LoadUint32(&o.CTIN_7_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetCTIN_7_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIN_7_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.EVENTROUTER_13_IN: Event router input 13 multiplexer (GIMA output 25)
func (o *GIMA_Type) SetEVENTROUTER_13_IN_INV(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_13_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetEVENTROUTER_13_IN_INV() uint32 {
	return volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetEVENTROUTER_13_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_13_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetEVENTROUTER_13_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetEVENTROUTER_13_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_13_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetEVENTROUTER_13_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetEVENTROUTER_13_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_13_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetEVENTROUTER_13_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetEVENTROUTER_13_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_13_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetEVENTROUTER_13_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetEVENTROUTER_13_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_13_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetEVENTROUTER_13_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_13_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.EVENTROUTER_14_IN: Event router input 14 multiplexer (GIMA output 26)
func (o *GIMA_Type) SetEVENTROUTER_14_IN_INV(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_14_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetEVENTROUTER_14_IN_INV() uint32 {
	return volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetEVENTROUTER_14_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_14_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetEVENTROUTER_14_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetEVENTROUTER_14_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_14_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetEVENTROUTER_14_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetEVENTROUTER_14_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_14_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetEVENTROUTER_14_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetEVENTROUTER_14_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_14_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetEVENTROUTER_14_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetEVENTROUTER_14_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_14_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetEVENTROUTER_14_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_14_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.EVENTROUTER_16_IN: Event router input 16 multiplexer (GIMA output 27)
func (o *GIMA_Type) SetEVENTROUTER_16_IN_INV(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_16_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetEVENTROUTER_16_IN_INV() uint32 {
	return volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetEVENTROUTER_16_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_16_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetEVENTROUTER_16_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetEVENTROUTER_16_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_16_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetEVENTROUTER_16_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetEVENTROUTER_16_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_16_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetEVENTROUTER_16_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetEVENTROUTER_16_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_16_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetEVENTROUTER_16_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetEVENTROUTER_16_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EVENTROUTER_16_IN.Reg, volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetEVENTROUTER_16_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EVENTROUTER_16_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.ADCSTART0_IN: ADC start0 input multiplexer (GIMA output 28)
func (o *GIMA_Type) SetADCSTART0_IN_INV(value uint32) {
	volatile.StoreUint32(&o.ADCSTART0_IN.Reg, volatile.LoadUint32(&o.ADCSTART0_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetADCSTART0_IN_INV() uint32 {
	return volatile.LoadUint32(&o.ADCSTART0_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetADCSTART0_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.ADCSTART0_IN.Reg, volatile.LoadUint32(&o.ADCSTART0_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetADCSTART0_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART0_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetADCSTART0_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.ADCSTART0_IN.Reg, volatile.LoadUint32(&o.ADCSTART0_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetADCSTART0_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART0_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetADCSTART0_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.ADCSTART0_IN.Reg, volatile.LoadUint32(&o.ADCSTART0_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetADCSTART0_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART0_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetADCSTART0_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.ADCSTART0_IN.Reg, volatile.LoadUint32(&o.ADCSTART0_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetADCSTART0_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART0_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetADCSTART0_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADCSTART0_IN.Reg, volatile.LoadUint32(&o.ADCSTART0_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetADCSTART0_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART0_IN.Reg) & 0xffffff00) >> 8
}

// GIMA.ADCSTART1_IN: ADC start1 input multiplexer (GIMA output 29)
func (o *GIMA_Type) SetADCSTART1_IN_INV(value uint32) {
	volatile.StoreUint32(&o.ADCSTART1_IN.Reg, volatile.LoadUint32(&o.ADCSTART1_IN.Reg)&^(0x1)|value)
}
func (o *GIMA_Type) GetADCSTART1_IN_INV() uint32 {
	return volatile.LoadUint32(&o.ADCSTART1_IN.Reg) & 0x1
}
func (o *GIMA_Type) SetADCSTART1_IN_EDGE(value uint32) {
	volatile.StoreUint32(&o.ADCSTART1_IN.Reg, volatile.LoadUint32(&o.ADCSTART1_IN.Reg)&^(0x2)|value<<1)
}
func (o *GIMA_Type) GetADCSTART1_IN_EDGE() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART1_IN.Reg) & 0x2) >> 1
}
func (o *GIMA_Type) SetADCSTART1_IN_SYNCH(value uint32) {
	volatile.StoreUint32(&o.ADCSTART1_IN.Reg, volatile.LoadUint32(&o.ADCSTART1_IN.Reg)&^(0x4)|value<<2)
}
func (o *GIMA_Type) GetADCSTART1_IN_SYNCH() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART1_IN.Reg) & 0x4) >> 2
}
func (o *GIMA_Type) SetADCSTART1_IN_PULSE(value uint32) {
	volatile.StoreUint32(&o.ADCSTART1_IN.Reg, volatile.LoadUint32(&o.ADCSTART1_IN.Reg)&^(0x8)|value<<3)
}
func (o *GIMA_Type) GetADCSTART1_IN_PULSE() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART1_IN.Reg) & 0x8) >> 3
}
func (o *GIMA_Type) SetADCSTART1_IN_SELECT(value uint32) {
	volatile.StoreUint32(&o.ADCSTART1_IN.Reg, volatile.LoadUint32(&o.ADCSTART1_IN.Reg)&^(0xf0)|value<<4)
}
func (o *GIMA_Type) GetADCSTART1_IN_SELECT() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART1_IN.Reg) & 0xf0) >> 4
}
func (o *GIMA_Type) SetADCSTART1_IN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADCSTART1_IN.Reg, volatile.LoadUint32(&o.ADCSTART1_IN.Reg)&^(0xffffff00)|value<<8)
}
func (o *GIMA_Type) GetADCSTART1_IN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADCSTART1_IN.Reg) & 0xffffff00) >> 8
}

// Digital-to-Analog Converter (DAC)
type DAC_Type struct {
	CR     volatile.Register32 // 0x0
	CTRL   volatile.Register32 // 0x4
	CNTVAL volatile.Register32 // 0x8
}

// DAC.CR: DAC register. Holds the conversion data.
func (o *DAC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3f)|value)
}
func (o *DAC_Type) GetCR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x3f
}
func (o *DAC_Type) SetCR_VALUE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xffc0)|value<<6)
}
func (o *DAC_Type) GetCR_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xffc0) >> 6
}
func (o *DAC_Type) SetCR_BIAS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DAC_Type) GetCR_BIAS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DAC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xfffe0000)|value<<17)
}
func (o *DAC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xfffe0000) >> 17
}

// DAC.CTRL: DAC control register.
func (o *DAC_Type) SetCTRL_INT_DMA_REQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCTRL_INT_DMA_REQ() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *DAC_Type) SetCTRL_DBLBUF_ENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetCTRL_DBLBUF_ENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetCTRL_CNT_ENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetCTRL_CNT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetCTRL_DMA_ENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetCTRL_DMA_ENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DAC_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xfffffff0) >> 4
}

// DAC.CNTVAL: DAC counter value register.
func (o *DAC_Type) SetCNTVAL_VALUE(value uint32) {
	volatile.StoreUint32(&o.CNTVAL.Reg, volatile.LoadUint32(&o.CNTVAL.Reg)&^(0xffff)|value)
}
func (o *DAC_Type) GetCNTVAL_VALUE() uint32 {
	return volatile.LoadUint32(&o.CNTVAL.Reg) & 0xffff
}
func (o *DAC_Type) SetCNTVAL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTVAL.Reg, volatile.LoadUint32(&o.CNTVAL.Reg)&^(0xffff0000)|value<<16)
}
func (o *DAC_Type) GetCNTVAL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTVAL.Reg) & 0xffff0000) >> 16
}

// 10-bit Analog-to-Digital Converter (ADC)
type ADC_Type struct {
	CR    volatile.Register32 // 0x0
	GDR   volatile.Register32 // 0x4
	_     [4]byte
	INTEN volatile.Register32    // 0xC
	DR    [8]volatile.Register32 // 0x10
	STAT  volatile.Register32    // 0x30
}

// ADC.CR: A/D Control Register. The AD0CR register must be written to select the operating mode before A/D conversion can occur.
func (o *ADC_Type) SetCR_SEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetCR_SEL() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0xff
}
func (o *ADC_Type) SetCR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff00)|value<<8)
}
func (o *ADC_Type) GetCR_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff00) >> 8
}
func (o *ADC_Type) SetCR_BURST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCR_BURST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCR_CLKS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xe0000)|value<<17)
}
func (o *ADC_Type) GetCR_CLKS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xe0000) >> 17
}
func (o *ADC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetCR_PDN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetCR_PDN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00000)|value<<22)
}
func (o *ADC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00000) >> 22
}
func (o *ADC_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetCR_EDGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *ADC_Type) GetCR_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *ADC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf0000000)|value<<28)
}
func (o *ADC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf0000000) >> 28
}

// ADC.GDR: A/D Global Data Register. Contains the result of the most recent A/D conversion.
func (o *ADC_Type) SetGDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetGDR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.GDR.Reg) & 0x3f
}
func (o *ADC_Type) SetGDR_V_VREF(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetGDR_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetGDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0xff0000)|value<<16)
}
func (o *ADC_Type) GetGDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0xff0000) >> 16
}
func (o *ADC_Type) SetGDR_CHN(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetGDR_CHN() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetGDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x38000000)|value<<27)
}
func (o *ADC_Type) GetGDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x38000000) >> 27
}
func (o *ADC_Type) SetGDR_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetGDR_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetGDR_DONE(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetGDR_DONE() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x80000000) >> 31
}

// ADC.INTEN: A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
func (o *ADC_Type) SetINTEN_ADINTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetINTEN_ADINTEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0xff
}
func (o *ADC_Type) SetINTEN_ADGINTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetINTEN_ADGINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xfffffe00)|value<<9)
}
func (o *ADC_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0xfffffe00) >> 9
}

// ADC.DR: A/D Channel Data Register. This register contains the result of the most recent conversion completed on channel n.
func (o *ADC_Type) SetDR_RESERVED(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetDR_RESERVED(idx int) uint32 {
	return volatile.LoadUint32(&o.DR[idx].Reg) & 0x3f
}
func (o *ADC_Type) SetDR_V_VREF(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetDR_V_VREF(idx int) uint32 {
	return (volatile.LoadUint32(&o.DR[idx].Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetDR_RESERVED(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR_RESERVED(idx int) uint32 {
	return (volatile.LoadUint32(&o.DR[idx].Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR_OVERRUN(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR_OVERRUN(idx int) uint32 {
	return (volatile.LoadUint32(&o.DR[idx].Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR_DONE(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR_DONE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DR[idx].Reg) & 0x80000000) >> 31
}

// ADC.STAT: A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag.
func (o *ADC_Type) SetSTAT_DONE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetSTAT_DONE() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0xff
}
func (o *ADC_Type) SetSTAT_OVERUN(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xff00)|value<<8)
}
func (o *ADC_Type) GetSTAT_OVERUN() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xff00) >> 8
}
func (o *ADC_Type) SetSTAT_ADINT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetSTAT_ADINT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xfffe0000)|value<<17)
}
func (o *ADC_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xfffe0000) >> 17
}

// GPIO port
type GPIO_PORT_Type struct {
	B     [256]volatile.Register8 // 0x0
	_     [3840]byte
	W     [256]volatile.Register32 // 0x1000
	_     [3072]byte
	DIR0  volatile.Register32 // 0x2000
	DIR1  volatile.Register32 // 0x2004
	DIR2  volatile.Register32 // 0x2008
	DIR3  volatile.Register32 // 0x200C
	DIR4  volatile.Register32 // 0x2010
	DIR5  volatile.Register32 // 0x2014
	DIR6  volatile.Register32 // 0x2018
	DIR7  volatile.Register32 // 0x201C
	_     [96]byte
	MASK0 volatile.Register32 // 0x2080
	MASK1 volatile.Register32 // 0x2084
	MASK2 volatile.Register32 // 0x2088
	MASK3 volatile.Register32 // 0x208C
	MASK4 volatile.Register32 // 0x2090
	MASK5 volatile.Register32 // 0x2094
	MASK6 volatile.Register32 // 0x2098
	MASK7 volatile.Register32 // 0x209C
	_     [96]byte
	PIN0  volatile.Register32 // 0x2100
	PIN1  volatile.Register32 // 0x2104
	PIN2  volatile.Register32 // 0x2108
	PIN3  volatile.Register32 // 0x210C
	PIN4  volatile.Register32 // 0x2110
	PIN5  volatile.Register32 // 0x2114
	PIN6  volatile.Register32 // 0x2118
	PIN7  volatile.Register32 // 0x211C
	_     [96]byte
	MPIN0 volatile.Register32 // 0x2180
	MPIN1 volatile.Register32 // 0x2184
	MPIN2 volatile.Register32 // 0x2188
	MPIN3 volatile.Register32 // 0x218C
	MPIN4 volatile.Register32 // 0x2190
	MPIN5 volatile.Register32 // 0x2194
	MPIN6 volatile.Register32 // 0x2198
	MPIN7 volatile.Register32 // 0x219C
	_     [96]byte
	SET0  volatile.Register32 // 0x2200
	SET1  volatile.Register32 // 0x2204
	SET2  volatile.Register32 // 0x2208
	SET3  volatile.Register32 // 0x220C
	SET4  volatile.Register32 // 0x2210
	SET5  volatile.Register32 // 0x2214
	SET6  volatile.Register32 // 0x2218
	SET7  volatile.Register32 // 0x221C
	_     [96]byte
	CLR0  volatile.Register32 // 0x2280
	CLR1  volatile.Register32 // 0x2284
	CLR2  volatile.Register32 // 0x2288
	CLR3  volatile.Register32 // 0x228C
	CLR4  volatile.Register32 // 0x2290
	CLR5  volatile.Register32 // 0x2294
	CLR6  volatile.Register32 // 0x2298
	CLR7  volatile.Register32 // 0x229C
	_     [96]byte
	NOT0  volatile.Register32 // 0x2300
	NOT1  volatile.Register32 // 0x2304
	NOT2  volatile.Register32 // 0x2308
	NOT3  volatile.Register32 // 0x230C
	NOT4  volatile.Register32 // 0x2310
	NOT5  volatile.Register32 // 0x2314
	NOT6  volatile.Register32 // 0x2318
	NOT7  volatile.Register32 // 0x231C
}

// GPIO_PORT.B: Byte pin registers port 0 to 5; pins PIOn_0 to PIOn_31
func (o *GPIO_PORT_Type) SetB_PBYTE(idx int, value uint8) {
	volatile.StoreUint8(&o.B[idx].Reg, volatile.LoadUint8(&o.B[idx].Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetB_PBYTE(idx int) uint8 {
	return volatile.LoadUint8(&o.B[idx].Reg) & 0x1
}

// GPIO_PORT.W: Word pin registers port 0 to 5
func (o *GPIO_PORT_Type) SetW(idx int, value uint32) {
	volatile.StoreUint32(&o.W[idx].Reg, value)
}
func (o *GPIO_PORT_Type) GetW(idx int) uint32 {
	return volatile.LoadUint32(&o.W[idx].Reg)
}

// GPIO_PORT.DIR0: Direction registers port m
func (o *GPIO_PORT_Type) SetDIR0_DIRP0(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP0() uint32 {
	return volatile.LoadUint32(&o.DIR0.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP1(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP1() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP2(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP2() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP3(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP3() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP4(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP4() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP5(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP5() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP6(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP6() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP7(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP7() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP8(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP8() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP9(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP9() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP10(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP10() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP11(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP11() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP12(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP12() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP13(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP13() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP14(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP14() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP15(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP15() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP16(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP16() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP17(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP17() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP18(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP18() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP19(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP19() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP20(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP20() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP21(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP21() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP22(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP22() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP23(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP23() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP24(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP24() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP25(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP25() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP26(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP26() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP27(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP27() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP28(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP28() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP29(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP29() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP30(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP30() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetDIR0_DIRP31(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetDIR0_DIRP31() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.DIR1: Direction registers port m
func (o *GPIO_PORT_Type) SetDIR1_DIRP0(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP0() uint32 {
	return volatile.LoadUint32(&o.DIR1.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP1(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP1() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP2(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP2() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP3(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP3() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP4(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP4() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP5(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP5() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP6(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP6() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP7(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP7() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP8(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP8() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP9(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP9() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP10(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP10() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP11(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP11() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP12(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP12() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP13(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP13() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP14(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP14() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP15(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP15() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP16(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP16() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP17(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP17() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP18(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP18() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP19(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP19() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP20(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP20() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP21(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP21() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP22(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP22() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP23(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP23() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP24(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP24() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP25(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP25() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP26(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP26() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP27(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP27() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP28(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP28() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP29(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP29() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP30(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP30() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetDIR1_DIRP31(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetDIR1_DIRP31() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.DIR2: Direction registers port m
func (o *GPIO_PORT_Type) SetDIR2_DIRP0(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP0() uint32 {
	return volatile.LoadUint32(&o.DIR2.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP1(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP1() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP2(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP2() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP3(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP3() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP4(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP4() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP5(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP5() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP6(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP6() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP7(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP7() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP8(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP8() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP9(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP9() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP10(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP10() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP11(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP11() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP12(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP12() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP13(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP13() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP14(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP14() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP15(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP15() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP16(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP16() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP17(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP17() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP18(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP18() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP19(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP19() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP20(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP20() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP21(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP21() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP22(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP22() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP23(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP23() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP24(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP24() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP25(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP25() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP26(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP26() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP27(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP27() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP28(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP28() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP29(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP29() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP30(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP30() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetDIR2_DIRP31(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetDIR2_DIRP31() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.DIR3: Direction registers port m
func (o *GPIO_PORT_Type) SetDIR3_DIRP0(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP0() uint32 {
	return volatile.LoadUint32(&o.DIR3.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP1(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP1() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP2(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP2() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP3(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP3() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP4(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP4() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP5(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP5() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP6(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP6() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP7(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP7() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP8(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP8() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP9(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP9() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP10(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP10() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP11(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP11() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP12(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP12() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP13(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP13() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP14(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP14() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP15(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP15() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP16(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP16() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP17(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP17() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP18(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP18() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP19(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP19() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP20(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP20() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP21(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP21() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP22(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP22() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP23(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP23() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP24(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP24() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP25(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP25() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP26(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP26() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP27(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP27() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP28(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP28() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP29(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP29() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP30(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP30() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetDIR3_DIRP31(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetDIR3_DIRP31() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.DIR4: Direction registers port m
func (o *GPIO_PORT_Type) SetDIR4_DIRP0(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP0() uint32 {
	return volatile.LoadUint32(&o.DIR4.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP1(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP1() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP2(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP2() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP3(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP3() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP4(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP4() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP5(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP5() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP6(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP6() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP7(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP7() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP8(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP8() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP9(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP9() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP10(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP10() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP11(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP11() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP12(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP12() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP13(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP13() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP14(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP14() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP15(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP15() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP16(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP16() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP17(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP17() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP18(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP18() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP19(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP19() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP20(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP20() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP21(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP21() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP22(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP22() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP23(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP23() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP24(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP24() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP25(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP25() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP26(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP26() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP27(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP27() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP28(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP28() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP29(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP29() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP30(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP30() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetDIR4_DIRP31(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetDIR4_DIRP31() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.DIR5: Direction registers port m
func (o *GPIO_PORT_Type) SetDIR5_DIRP0(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP0() uint32 {
	return volatile.LoadUint32(&o.DIR5.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP1(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP1() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP2(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP2() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP3(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP3() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP4(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP4() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP5(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP5() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP6(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP6() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP7(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP7() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP8(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP8() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP9(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP9() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP10(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP10() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP11(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP11() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP12(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP12() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP13(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP13() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP14(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP14() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP15(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP15() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP16(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP16() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP17(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP17() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP18(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP18() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP19(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP19() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP20(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP20() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP21(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP21() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP22(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP22() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP23(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP23() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP24(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP24() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP25(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP25() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP26(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP26() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP27(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP27() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP28(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP28() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP29(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP29() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP30(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP30() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetDIR5_DIRP31(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetDIR5_DIRP31() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.DIR6: Direction registers port m
func (o *GPIO_PORT_Type) SetDIR6_DIRP0(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP0() uint32 {
	return volatile.LoadUint32(&o.DIR6.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP1(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP1() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP2(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP2() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP3(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP3() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP4(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP4() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP5(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP5() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP6(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP6() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP7(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP7() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP8(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP8() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP9(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP9() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP10(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP10() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP11(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP11() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP12(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP12() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP13(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP13() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP14(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP14() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP15(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP15() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP16(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP16() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP17(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP17() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP18(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP18() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP19(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP19() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP20(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP20() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP21(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP21() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP22(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP22() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP23(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP23() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP24(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP24() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP25(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP25() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP26(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP26() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP27(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP27() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP28(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP28() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP29(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP29() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP30(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP30() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetDIR6_DIRP31(value uint32) {
	volatile.StoreUint32(&o.DIR6.Reg, volatile.LoadUint32(&o.DIR6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetDIR6_DIRP31() uint32 {
	return (volatile.LoadUint32(&o.DIR6.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.DIR7: Direction registers port m
func (o *GPIO_PORT_Type) SetDIR7_DIRP0(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP0() uint32 {
	return volatile.LoadUint32(&o.DIR7.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP1(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP1() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP2(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP2() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP3(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP3() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP4(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP4() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP5(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP5() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP6(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP6() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP7(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP7() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP8(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP8() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP9(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP9() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP10(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP10() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP11(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP11() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP12(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP12() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP13(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP13() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP14(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP14() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP15(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP15() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP16(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP16() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP17(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP17() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP18(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP18() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP19(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP19() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP20(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP20() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP21(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP21() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP22(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP22() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP23(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP23() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP24(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP24() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP25(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP25() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP26(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP26() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP27(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP27() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP28(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP28() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP29(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP29() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP30(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP30() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetDIR7_DIRP31(value uint32) {
	volatile.StoreUint32(&o.DIR7.Reg, volatile.LoadUint32(&o.DIR7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetDIR7_DIRP31() uint32 {
	return (volatile.LoadUint32(&o.DIR7.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MASK0: Mask register port m
func (o *GPIO_PORT_Type) SetMASK0_MASKP0(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP0() uint32 {
	return volatile.LoadUint32(&o.MASK0.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP1(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP1() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP2(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP2() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP3(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP3() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP4(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP4() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP5(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP5() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP6(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP6() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP7(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP7() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP8(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP8() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP9(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP9() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP10(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP10() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP11(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP11() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP12(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP12() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP13(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP13() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP14(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP14() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP15(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP15() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP16(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP16() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP17(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP17() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP18(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP18() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP19(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP19() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP20(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP20() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP21(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP21() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP22(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP22() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP23(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP23() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP24(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP24() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP25(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP25() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP26(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP26() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP27(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP27() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP28(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP28() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP29(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP29() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP30(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP30() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMASK0_MASKP31(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMASK0_MASKP31() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MASK1: Mask register port m
func (o *GPIO_PORT_Type) SetMASK1_MASKP0(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP0() uint32 {
	return volatile.LoadUint32(&o.MASK1.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP1(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP1() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP2(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP2() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP3(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP3() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP4(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP4() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP5(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP5() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP6(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP6() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP7(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP7() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP8(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP8() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP9(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP9() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP10(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP10() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP11(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP11() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP12(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP12() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP13(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP13() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP14(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP14() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP15(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP15() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP16(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP16() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP17(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP17() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP18(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP18() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP19(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP19() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP20(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP20() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP21(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP21() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP22(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP22() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP23(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP23() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP24(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP24() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP25(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP25() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP26(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP26() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP27(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP27() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP28(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP28() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP29(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP29() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP30(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP30() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMASK1_MASKP31(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMASK1_MASKP31() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MASK2: Mask register port m
func (o *GPIO_PORT_Type) SetMASK2_MASKP0(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP0() uint32 {
	return volatile.LoadUint32(&o.MASK2.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP1(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP1() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP2(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP2() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP3(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP3() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP4(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP4() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP5(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP5() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP6(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP6() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP7(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP7() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP8(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP8() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP9(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP9() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP10(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP10() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP11(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP11() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP12(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP12() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP13(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP13() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP14(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP14() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP15(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP15() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP16(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP16() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP17(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP17() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP18(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP18() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP19(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP19() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP20(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP20() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP21(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP21() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP22(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP22() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP23(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP23() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP24(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP24() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP25(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP25() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP26(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP26() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP27(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP27() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP28(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP28() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP29(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP29() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP30(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP30() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMASK2_MASKP31(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMASK2_MASKP31() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MASK3: Mask register port m
func (o *GPIO_PORT_Type) SetMASK3_MASKP0(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP0() uint32 {
	return volatile.LoadUint32(&o.MASK3.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP1(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP1() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP2(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP2() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP3(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP3() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP4(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP4() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP5(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP5() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP6(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP6() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP7(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP7() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP8(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP8() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP9(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP9() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP10(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP10() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP11(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP11() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP12(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP12() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP13(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP13() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP14(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP14() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP15(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP15() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP16(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP16() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP17(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP17() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP18(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP18() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP19(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP19() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP20(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP20() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP21(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP21() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP22(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP22() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP23(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP23() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP24(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP24() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP25(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP25() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP26(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP26() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP27(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP27() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP28(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP28() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP29(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP29() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP30(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP30() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMASK3_MASKP31(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMASK3_MASKP31() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MASK4: Mask register port m
func (o *GPIO_PORT_Type) SetMASK4_MASKP0(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP0() uint32 {
	return volatile.LoadUint32(&o.MASK4.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP1(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP1() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP2(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP2() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP3(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP3() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP4(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP4() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP5(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP5() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP6(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP6() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP7(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP7() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP8(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP8() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP9(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP9() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP10(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP10() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP11(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP11() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP12(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP12() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP13(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP13() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP14(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP14() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP15(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP15() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP16(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP16() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP17(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP17() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP18(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP18() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP19(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP19() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP20(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP20() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP21(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP21() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP22(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP22() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP23(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP23() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP24(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP24() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP25(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP25() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP26(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP26() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP27(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP27() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP28(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP28() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP29(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP29() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP30(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP30() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMASK4_MASKP31(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMASK4_MASKP31() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MASK5: Mask register port m
func (o *GPIO_PORT_Type) SetMASK5_MASKP0(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP0() uint32 {
	return volatile.LoadUint32(&o.MASK5.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP1(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP1() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP2(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP2() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP3(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP3() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP4(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP4() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP5(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP5() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP6(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP6() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP7(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP7() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP8(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP8() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP9(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP9() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP10(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP10() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP11(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP11() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP12(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP12() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP13(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP13() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP14(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP14() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP15(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP15() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP16(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP16() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP17(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP17() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP18(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP18() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP19(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP19() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP20(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP20() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP21(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP21() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP22(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP22() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP23(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP23() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP24(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP24() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP25(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP25() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP26(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP26() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP27(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP27() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP28(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP28() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP29(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP29() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP30(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP30() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMASK5_MASKP31(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMASK5_MASKP31() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MASK6: Mask register port m
func (o *GPIO_PORT_Type) SetMASK6_MASKP0(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP0() uint32 {
	return volatile.LoadUint32(&o.MASK6.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP1(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP1() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP2(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP2() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP3(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP3() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP4(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP4() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP5(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP5() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP6(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP6() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP7(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP7() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP8(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP8() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP9(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP9() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP10(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP10() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP11(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP11() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP12(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP12() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP13(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP13() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP14(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP14() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP15(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP15() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP16(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP16() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP17(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP17() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP18(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP18() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP19(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP19() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP20(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP20() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP21(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP21() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP22(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP22() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP23(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP23() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP24(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP24() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP25(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP25() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP26(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP26() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP27(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP27() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP28(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP28() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP29(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP29() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP30(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP30() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMASK6_MASKP31(value uint32) {
	volatile.StoreUint32(&o.MASK6.Reg, volatile.LoadUint32(&o.MASK6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMASK6_MASKP31() uint32 {
	return (volatile.LoadUint32(&o.MASK6.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MASK7: Mask register port m
func (o *GPIO_PORT_Type) SetMASK7_MASKP0(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP0() uint32 {
	return volatile.LoadUint32(&o.MASK7.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP1(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP1() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP2(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP2() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP3(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP3() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP4(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP4() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP5(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP5() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP6(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP6() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP7(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP7() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP8(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP8() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP9(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP9() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP10(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP10() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP11(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP11() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP12(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP12() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP13(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP13() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP14(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP14() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP15(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP15() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP16(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP16() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP17(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP17() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP18(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP18() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP19(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP19() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP20(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP20() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP21(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP21() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP22(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP22() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP23(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP23() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP24(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP24() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP25(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP25() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP26(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP26() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP27(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP27() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP28(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP28() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP29(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP29() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP30(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP30() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMASK7_MASKP31(value uint32) {
	volatile.StoreUint32(&o.MASK7.Reg, volatile.LoadUint32(&o.MASK7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMASK7_MASKP31() uint32 {
	return (volatile.LoadUint32(&o.MASK7.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.PIN0: Port pin register port m
func (o *GPIO_PORT_Type) SetPIN0_PORT0(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT0() uint32 {
	return volatile.LoadUint32(&o.PIN0.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetPIN0_PORT1(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT1() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetPIN0_PORT2(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT2() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetPIN0_PORT3(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT3() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetPIN0_PORT4(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT4() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetPIN0_PORT5(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT5() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetPIN0_PORT6(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT6() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetPIN0_PORT7(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT7() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetPIN0_PORT8(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT8() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetPIN0_PORT9(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT9() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetPIN0_PORT10(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT10() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetPIN0_PORT11(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT11() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetPIN0_PORT12(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT12() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetPIN0_PORT13(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT13() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetPIN0_PORT14(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT14() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetPIN0_PORT15(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT15() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetPIN0_PORT16(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT16() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetPIN0_PORT17(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT17() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetPIN0_PORT18(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT18() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetPIN0_PORT19(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT19() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetPIN0_PORT20(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT20() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetPIN0_PORT21(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT21() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetPIN0_PORT22(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT22() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetPIN0_PORT23(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT23() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetPIN0_PORT24(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT24() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetPIN0_PORT25(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT25() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetPIN0_PORT26(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT26() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetPIN0_PORT27(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT27() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetPIN0_PORT28(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT28() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetPIN0_PORT29(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT29() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetPIN0_PORT30(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT30() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetPIN0_PORT31(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetPIN0_PORT31() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.PIN1: Port pin register port m
func (o *GPIO_PORT_Type) SetPIN1_PORT0(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT0() uint32 {
	return volatile.LoadUint32(&o.PIN1.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetPIN1_PORT1(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT1() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetPIN1_PORT2(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT2() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetPIN1_PORT3(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT3() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetPIN1_PORT4(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT4() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetPIN1_PORT5(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT5() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetPIN1_PORT6(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT6() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetPIN1_PORT7(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT7() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetPIN1_PORT8(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT8() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetPIN1_PORT9(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT9() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetPIN1_PORT10(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT10() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetPIN1_PORT11(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT11() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetPIN1_PORT12(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT12() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetPIN1_PORT13(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT13() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetPIN1_PORT14(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT14() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetPIN1_PORT15(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT15() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetPIN1_PORT16(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT16() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetPIN1_PORT17(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT17() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetPIN1_PORT18(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT18() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetPIN1_PORT19(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT19() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetPIN1_PORT20(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT20() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetPIN1_PORT21(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT21() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetPIN1_PORT22(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT22() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetPIN1_PORT23(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT23() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetPIN1_PORT24(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT24() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetPIN1_PORT25(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT25() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetPIN1_PORT26(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT26() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetPIN1_PORT27(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT27() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetPIN1_PORT28(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT28() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetPIN1_PORT29(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT29() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetPIN1_PORT30(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT30() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetPIN1_PORT31(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetPIN1_PORT31() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.PIN2: Port pin register port m
func (o *GPIO_PORT_Type) SetPIN2_PORT0(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT0() uint32 {
	return volatile.LoadUint32(&o.PIN2.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetPIN2_PORT1(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT1() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetPIN2_PORT2(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT2() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetPIN2_PORT3(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT3() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetPIN2_PORT4(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT4() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetPIN2_PORT5(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT5() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetPIN2_PORT6(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT6() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetPIN2_PORT7(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT7() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetPIN2_PORT8(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT8() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetPIN2_PORT9(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT9() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetPIN2_PORT10(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT10() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetPIN2_PORT11(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT11() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetPIN2_PORT12(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT12() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetPIN2_PORT13(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT13() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetPIN2_PORT14(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT14() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetPIN2_PORT15(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT15() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetPIN2_PORT16(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT16() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetPIN2_PORT17(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT17() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetPIN2_PORT18(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT18() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetPIN2_PORT19(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT19() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetPIN2_PORT20(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT20() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetPIN2_PORT21(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT21() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetPIN2_PORT22(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT22() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetPIN2_PORT23(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT23() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetPIN2_PORT24(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT24() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetPIN2_PORT25(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT25() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetPIN2_PORT26(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT26() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetPIN2_PORT27(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT27() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetPIN2_PORT28(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT28() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetPIN2_PORT29(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT29() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetPIN2_PORT30(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT30() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetPIN2_PORT31(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetPIN2_PORT31() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.PIN3: Port pin register port m
func (o *GPIO_PORT_Type) SetPIN3_PORT0(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT0() uint32 {
	return volatile.LoadUint32(&o.PIN3.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetPIN3_PORT1(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT1() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetPIN3_PORT2(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT2() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetPIN3_PORT3(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT3() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetPIN3_PORT4(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT4() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetPIN3_PORT5(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT5() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetPIN3_PORT6(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT6() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetPIN3_PORT7(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT7() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetPIN3_PORT8(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT8() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetPIN3_PORT9(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT9() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetPIN3_PORT10(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT10() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetPIN3_PORT11(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT11() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetPIN3_PORT12(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT12() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetPIN3_PORT13(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT13() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetPIN3_PORT14(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT14() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetPIN3_PORT15(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT15() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetPIN3_PORT16(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT16() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetPIN3_PORT17(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT17() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetPIN3_PORT18(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT18() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetPIN3_PORT19(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT19() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetPIN3_PORT20(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT20() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetPIN3_PORT21(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT21() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetPIN3_PORT22(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT22() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetPIN3_PORT23(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT23() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetPIN3_PORT24(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT24() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetPIN3_PORT25(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT25() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetPIN3_PORT26(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT26() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetPIN3_PORT27(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT27() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetPIN3_PORT28(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT28() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetPIN3_PORT29(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT29() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetPIN3_PORT30(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT30() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetPIN3_PORT31(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetPIN3_PORT31() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.PIN4: Port pin register port m
func (o *GPIO_PORT_Type) SetPIN4_PORT0(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT0() uint32 {
	return volatile.LoadUint32(&o.PIN4.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetPIN4_PORT1(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT1() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetPIN4_PORT2(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT2() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetPIN4_PORT3(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT3() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetPIN4_PORT4(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT4() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetPIN4_PORT5(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT5() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetPIN4_PORT6(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT6() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetPIN4_PORT7(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT7() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetPIN4_PORT8(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT8() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetPIN4_PORT9(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT9() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetPIN4_PORT10(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT10() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetPIN4_PORT11(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT11() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetPIN4_PORT12(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT12() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetPIN4_PORT13(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT13() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetPIN4_PORT14(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT14() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetPIN4_PORT15(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT15() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetPIN4_PORT16(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT16() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetPIN4_PORT17(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT17() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetPIN4_PORT18(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT18() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetPIN4_PORT19(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT19() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetPIN4_PORT20(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT20() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetPIN4_PORT21(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT21() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetPIN4_PORT22(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT22() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetPIN4_PORT23(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT23() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetPIN4_PORT24(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT24() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetPIN4_PORT25(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT25() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetPIN4_PORT26(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT26() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetPIN4_PORT27(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT27() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetPIN4_PORT28(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT28() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetPIN4_PORT29(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT29() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetPIN4_PORT30(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT30() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetPIN4_PORT31(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetPIN4_PORT31() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.PIN5: Port pin register port m
func (o *GPIO_PORT_Type) SetPIN5_PORT0(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT0() uint32 {
	return volatile.LoadUint32(&o.PIN5.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetPIN5_PORT1(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT1() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetPIN5_PORT2(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT2() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetPIN5_PORT3(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT3() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetPIN5_PORT4(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT4() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetPIN5_PORT5(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT5() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetPIN5_PORT6(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT6() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetPIN5_PORT7(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT7() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetPIN5_PORT8(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT8() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetPIN5_PORT9(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT9() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetPIN5_PORT10(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT10() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetPIN5_PORT11(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT11() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetPIN5_PORT12(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT12() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetPIN5_PORT13(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT13() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetPIN5_PORT14(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT14() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetPIN5_PORT15(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT15() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetPIN5_PORT16(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT16() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetPIN5_PORT17(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT17() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetPIN5_PORT18(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT18() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetPIN5_PORT19(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT19() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetPIN5_PORT20(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT20() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetPIN5_PORT21(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT21() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetPIN5_PORT22(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT22() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetPIN5_PORT23(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT23() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetPIN5_PORT24(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT24() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetPIN5_PORT25(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT25() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetPIN5_PORT26(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT26() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetPIN5_PORT27(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT27() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetPIN5_PORT28(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT28() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetPIN5_PORT29(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT29() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetPIN5_PORT30(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT30() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetPIN5_PORT31(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetPIN5_PORT31() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.PIN6: Port pin register port m
func (o *GPIO_PORT_Type) SetPIN6_PORT0(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT0() uint32 {
	return volatile.LoadUint32(&o.PIN6.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetPIN6_PORT1(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT1() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetPIN6_PORT2(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT2() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetPIN6_PORT3(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT3() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetPIN6_PORT4(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT4() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetPIN6_PORT5(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT5() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetPIN6_PORT6(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT6() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetPIN6_PORT7(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT7() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetPIN6_PORT8(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT8() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetPIN6_PORT9(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT9() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetPIN6_PORT10(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT10() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetPIN6_PORT11(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT11() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetPIN6_PORT12(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT12() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetPIN6_PORT13(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT13() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetPIN6_PORT14(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT14() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetPIN6_PORT15(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT15() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetPIN6_PORT16(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT16() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetPIN6_PORT17(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT17() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetPIN6_PORT18(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT18() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetPIN6_PORT19(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT19() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetPIN6_PORT20(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT20() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetPIN6_PORT21(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT21() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetPIN6_PORT22(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT22() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetPIN6_PORT23(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT23() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetPIN6_PORT24(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT24() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetPIN6_PORT25(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT25() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetPIN6_PORT26(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT26() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetPIN6_PORT27(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT27() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetPIN6_PORT28(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT28() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetPIN6_PORT29(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT29() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetPIN6_PORT30(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT30() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetPIN6_PORT31(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetPIN6_PORT31() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.PIN7: Port pin register port m
func (o *GPIO_PORT_Type) SetPIN7_PORT0(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT0() uint32 {
	return volatile.LoadUint32(&o.PIN7.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetPIN7_PORT1(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT1() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetPIN7_PORT2(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT2() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetPIN7_PORT3(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT3() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetPIN7_PORT4(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT4() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetPIN7_PORT5(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT5() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetPIN7_PORT6(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT6() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetPIN7_PORT7(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT7() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetPIN7_PORT8(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT8() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetPIN7_PORT9(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT9() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetPIN7_PORT10(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT10() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetPIN7_PORT11(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT11() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetPIN7_PORT12(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT12() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetPIN7_PORT13(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT13() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetPIN7_PORT14(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT14() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetPIN7_PORT15(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT15() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetPIN7_PORT16(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT16() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetPIN7_PORT17(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT17() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetPIN7_PORT18(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT18() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetPIN7_PORT19(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT19() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetPIN7_PORT20(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT20() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetPIN7_PORT21(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT21() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetPIN7_PORT22(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT22() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetPIN7_PORT23(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT23() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetPIN7_PORT24(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT24() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetPIN7_PORT25(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT25() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetPIN7_PORT26(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT26() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetPIN7_PORT27(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT27() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetPIN7_PORT28(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT28() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetPIN7_PORT29(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT29() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetPIN7_PORT30(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT30() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetPIN7_PORT31(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetPIN7_PORT31() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MPIN0: Masked port register port m
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP0(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP0() uint32 {
	return volatile.LoadUint32(&o.MPIN0.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP1(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP1() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP2(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP2() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP3(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP3() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP4(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP4() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP5(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP5() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP6(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP6() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP7(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP7() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP8(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP8() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP9(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP9() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP10(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP10() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP11(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP11() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP12(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP12() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP13(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP13() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP14(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP14() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP15(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP15() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP16(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP16() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP17(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP17() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP18(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP18() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP19(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP19() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP20(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP20() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP21(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP21() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP22(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP22() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP23(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP23() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP24(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP24() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP25(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP25() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP26(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP26() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP27(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP27() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP28(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP28() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP29(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP29() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP30(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP30() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMPIN0_MPORTP31(value uint32) {
	volatile.StoreUint32(&o.MPIN0.Reg, volatile.LoadUint32(&o.MPIN0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMPIN0_MPORTP31() uint32 {
	return (volatile.LoadUint32(&o.MPIN0.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MPIN1: Masked port register port m
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP0(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP0() uint32 {
	return volatile.LoadUint32(&o.MPIN1.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP1(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP1() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP2(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP2() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP3(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP3() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP4(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP4() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP5(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP5() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP6(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP6() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP7(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP7() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP8(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP8() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP9(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP9() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP10(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP10() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP11(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP11() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP12(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP12() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP13(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP13() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP14(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP14() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP15(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP15() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP16(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP16() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP17(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP17() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP18(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP18() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP19(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP19() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP20(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP20() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP21(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP21() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP22(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP22() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP23(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP23() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP24(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP24() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP25(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP25() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP26(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP26() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP27(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP27() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP28(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP28() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP29(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP29() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP30(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP30() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMPIN1_MPORTP31(value uint32) {
	volatile.StoreUint32(&o.MPIN1.Reg, volatile.LoadUint32(&o.MPIN1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMPIN1_MPORTP31() uint32 {
	return (volatile.LoadUint32(&o.MPIN1.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MPIN2: Masked port register port m
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP0(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP0() uint32 {
	return volatile.LoadUint32(&o.MPIN2.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP1(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP1() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP2(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP2() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP3(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP3() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP4(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP4() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP5(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP5() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP6(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP6() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP7(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP7() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP8(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP8() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP9(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP9() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP10(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP10() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP11(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP11() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP12(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP12() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP13(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP13() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP14(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP14() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP15(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP15() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP16(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP16() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP17(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP17() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP18(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP18() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP19(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP19() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP20(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP20() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP21(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP21() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP22(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP22() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP23(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP23() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP24(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP24() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP25(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP25() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP26(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP26() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP27(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP27() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP28(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP28() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP29(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP29() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP30(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP30() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMPIN2_MPORTP31(value uint32) {
	volatile.StoreUint32(&o.MPIN2.Reg, volatile.LoadUint32(&o.MPIN2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMPIN2_MPORTP31() uint32 {
	return (volatile.LoadUint32(&o.MPIN2.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MPIN3: Masked port register port m
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP0(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP0() uint32 {
	return volatile.LoadUint32(&o.MPIN3.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP1(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP1() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP2(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP2() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP3(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP3() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP4(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP4() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP5(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP5() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP6(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP6() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP7(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP7() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP8(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP8() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP9(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP9() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP10(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP10() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP11(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP11() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP12(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP12() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP13(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP13() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP14(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP14() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP15(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP15() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP16(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP16() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP17(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP17() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP18(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP18() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP19(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP19() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP20(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP20() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP21(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP21() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP22(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP22() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP23(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP23() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP24(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP24() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP25(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP25() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP26(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP26() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP27(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP27() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP28(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP28() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP29(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP29() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP30(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP30() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMPIN3_MPORTP31(value uint32) {
	volatile.StoreUint32(&o.MPIN3.Reg, volatile.LoadUint32(&o.MPIN3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMPIN3_MPORTP31() uint32 {
	return (volatile.LoadUint32(&o.MPIN3.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MPIN4: Masked port register port m
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP0(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP0() uint32 {
	return volatile.LoadUint32(&o.MPIN4.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP1(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP1() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP2(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP2() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP3(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP3() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP4(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP4() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP5(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP5() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP6(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP6() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP7(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP7() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP8(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP8() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP9(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP9() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP10(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP10() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP11(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP11() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP12(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP12() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP13(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP13() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP14(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP14() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP15(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP15() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP16(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP16() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP17(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP17() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP18(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP18() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP19(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP19() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP20(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP20() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP21(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP21() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP22(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP22() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP23(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP23() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP24(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP24() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP25(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP25() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP26(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP26() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP27(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP27() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP28(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP28() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP29(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP29() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP30(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP30() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMPIN4_MPORTP31(value uint32) {
	volatile.StoreUint32(&o.MPIN4.Reg, volatile.LoadUint32(&o.MPIN4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMPIN4_MPORTP31() uint32 {
	return (volatile.LoadUint32(&o.MPIN4.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MPIN5: Masked port register port m
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP0(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP0() uint32 {
	return volatile.LoadUint32(&o.MPIN5.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP1(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP1() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP2(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP2() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP3(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP3() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP4(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP4() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP5(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP5() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP6(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP6() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP7(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP7() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP8(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP8() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP9(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP9() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP10(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP10() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP11(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP11() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP12(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP12() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP13(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP13() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP14(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP14() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP15(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP15() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP16(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP16() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP17(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP17() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP18(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP18() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP19(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP19() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP20(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP20() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP21(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP21() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP22(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP22() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP23(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP23() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP24(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP24() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP25(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP25() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP26(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP26() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP27(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP27() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP28(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP28() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP29(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP29() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP30(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP30() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMPIN5_MPORTP31(value uint32) {
	volatile.StoreUint32(&o.MPIN5.Reg, volatile.LoadUint32(&o.MPIN5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMPIN5_MPORTP31() uint32 {
	return (volatile.LoadUint32(&o.MPIN5.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MPIN6: Masked port register port m
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP0(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP0() uint32 {
	return volatile.LoadUint32(&o.MPIN6.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP1(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP1() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP2(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP2() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP3(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP3() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP4(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP4() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP5(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP5() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP6(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP6() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP7(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP7() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP8(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP8() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP9(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP9() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP10(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP10() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP11(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP11() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP12(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP12() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP13(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP13() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP14(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP14() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP15(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP15() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP16(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP16() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP17(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP17() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP18(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP18() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP19(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP19() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP20(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP20() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP21(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP21() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP22(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP22() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP23(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP23() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP24(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP24() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP25(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP25() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP26(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP26() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP27(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP27() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP28(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP28() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP29(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP29() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP30(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP30() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMPIN6_MPORTP31(value uint32) {
	volatile.StoreUint32(&o.MPIN6.Reg, volatile.LoadUint32(&o.MPIN6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMPIN6_MPORTP31() uint32 {
	return (volatile.LoadUint32(&o.MPIN6.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.MPIN7: Masked port register port m
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP0(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP0() uint32 {
	return volatile.LoadUint32(&o.MPIN7.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP1(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP1() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP2(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP2() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP3(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP3() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP4(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP4() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP5(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP5() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP6(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP6() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP7(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP7() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP8(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP8() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP9(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP9() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP10(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP10() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP11(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP11() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP12(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP12() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP13(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP13() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP14(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP14() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP15(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP15() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP16(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP16() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP17(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP17() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP18(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP18() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP19(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP19() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP20(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP20() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP21(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP21() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP22(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP22() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP23(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP23() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP24(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP24() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP25(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP25() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP26(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP26() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP27(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP27() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP28(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP28() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP29(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP29() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP30(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP30() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetMPIN7_MPORTP31(value uint32) {
	volatile.StoreUint32(&o.MPIN7.Reg, volatile.LoadUint32(&o.MPIN7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetMPIN7_MPORTP31() uint32 {
	return (volatile.LoadUint32(&o.MPIN7.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.SET0: Write: Set register for port m Read: output bits for port m
func (o *GPIO_PORT_Type) SetSET0_SETP0(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetSET0_SETP0() uint32 {
	return volatile.LoadUint32(&o.SET0.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetSET0_SETP1(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetSET0_SETP1() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetSET0_SETP2(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetSET0_SETP2() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetSET0_SETP3(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetSET0_SETP3() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetSET0_SETP4(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetSET0_SETP4() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetSET0_SETP5(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetSET0_SETP5() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetSET0_SETP6(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetSET0_SETP6() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetSET0_SETP7(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetSET0_SETP7() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetSET0_SETP8(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetSET0_SETP8() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetSET0_SETP9(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetSET0_SETP9() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetSET0_SETP10(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetSET0_SETP10() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetSET0_SETP11(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetSET0_SETP11() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetSET0_SETP12(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetSET0_SETP12() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetSET0_SETP13(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetSET0_SETP13() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetSET0_SETP14(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetSET0_SETP14() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetSET0_SETP15(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetSET0_SETP15() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetSET0_SETP16(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetSET0_SETP16() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetSET0_SETP17(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetSET0_SETP17() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetSET0_SETP18(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetSET0_SETP18() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetSET0_SETP19(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetSET0_SETP19() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetSET0_SETP20(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetSET0_SETP20() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetSET0_SETP21(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetSET0_SETP21() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetSET0_SETP22(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetSET0_SETP22() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetSET0_SETP23(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetSET0_SETP23() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetSET0_SETP24(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetSET0_SETP24() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetSET0_SETP25(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetSET0_SETP25() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetSET0_SETP26(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetSET0_SETP26() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetSET0_SETP27(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetSET0_SETP27() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetSET0_SETP28(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetSET0_SETP28() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetSET0_SETP29(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetSET0_SETP29() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetSET0_SETP30(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetSET0_SETP30() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetSET0_SETP31(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetSET0_SETP31() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.SET1: Write: Set register for port m Read: output bits for port m
func (o *GPIO_PORT_Type) SetSET1_SETP0(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetSET1_SETP0() uint32 {
	return volatile.LoadUint32(&o.SET1.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetSET1_SETP1(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetSET1_SETP1() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetSET1_SETP2(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetSET1_SETP2() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetSET1_SETP3(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetSET1_SETP3() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetSET1_SETP4(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetSET1_SETP4() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetSET1_SETP5(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetSET1_SETP5() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetSET1_SETP6(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetSET1_SETP6() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetSET1_SETP7(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetSET1_SETP7() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetSET1_SETP8(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetSET1_SETP8() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetSET1_SETP9(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetSET1_SETP9() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetSET1_SETP10(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetSET1_SETP10() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetSET1_SETP11(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetSET1_SETP11() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetSET1_SETP12(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetSET1_SETP12() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetSET1_SETP13(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetSET1_SETP13() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetSET1_SETP14(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetSET1_SETP14() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetSET1_SETP15(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetSET1_SETP15() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetSET1_SETP16(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetSET1_SETP16() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetSET1_SETP17(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetSET1_SETP17() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetSET1_SETP18(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetSET1_SETP18() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetSET1_SETP19(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetSET1_SETP19() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetSET1_SETP20(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetSET1_SETP20() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetSET1_SETP21(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetSET1_SETP21() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetSET1_SETP22(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetSET1_SETP22() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetSET1_SETP23(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetSET1_SETP23() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetSET1_SETP24(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetSET1_SETP24() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetSET1_SETP25(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetSET1_SETP25() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetSET1_SETP26(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetSET1_SETP26() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetSET1_SETP27(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetSET1_SETP27() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetSET1_SETP28(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetSET1_SETP28() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetSET1_SETP29(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetSET1_SETP29() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetSET1_SETP30(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetSET1_SETP30() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetSET1_SETP31(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetSET1_SETP31() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.SET2: Write: Set register for port m Read: output bits for port m
func (o *GPIO_PORT_Type) SetSET2_SETP0(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetSET2_SETP0() uint32 {
	return volatile.LoadUint32(&o.SET2.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetSET2_SETP1(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetSET2_SETP1() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetSET2_SETP2(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetSET2_SETP2() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetSET2_SETP3(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetSET2_SETP3() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetSET2_SETP4(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetSET2_SETP4() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetSET2_SETP5(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetSET2_SETP5() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetSET2_SETP6(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetSET2_SETP6() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetSET2_SETP7(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetSET2_SETP7() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetSET2_SETP8(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetSET2_SETP8() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetSET2_SETP9(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetSET2_SETP9() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetSET2_SETP10(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetSET2_SETP10() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetSET2_SETP11(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetSET2_SETP11() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetSET2_SETP12(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetSET2_SETP12() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetSET2_SETP13(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetSET2_SETP13() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetSET2_SETP14(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetSET2_SETP14() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetSET2_SETP15(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetSET2_SETP15() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetSET2_SETP16(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetSET2_SETP16() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetSET2_SETP17(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetSET2_SETP17() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetSET2_SETP18(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetSET2_SETP18() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetSET2_SETP19(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetSET2_SETP19() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetSET2_SETP20(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetSET2_SETP20() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetSET2_SETP21(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetSET2_SETP21() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetSET2_SETP22(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetSET2_SETP22() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetSET2_SETP23(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetSET2_SETP23() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetSET2_SETP24(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetSET2_SETP24() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetSET2_SETP25(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetSET2_SETP25() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetSET2_SETP26(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetSET2_SETP26() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetSET2_SETP27(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetSET2_SETP27() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetSET2_SETP28(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetSET2_SETP28() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetSET2_SETP29(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetSET2_SETP29() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetSET2_SETP30(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetSET2_SETP30() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetSET2_SETP31(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetSET2_SETP31() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.SET3: Write: Set register for port m Read: output bits for port m
func (o *GPIO_PORT_Type) SetSET3_SETP0(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetSET3_SETP0() uint32 {
	return volatile.LoadUint32(&o.SET3.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetSET3_SETP1(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetSET3_SETP1() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetSET3_SETP2(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetSET3_SETP2() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetSET3_SETP3(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetSET3_SETP3() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetSET3_SETP4(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetSET3_SETP4() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetSET3_SETP5(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetSET3_SETP5() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetSET3_SETP6(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetSET3_SETP6() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetSET3_SETP7(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetSET3_SETP7() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetSET3_SETP8(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetSET3_SETP8() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetSET3_SETP9(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetSET3_SETP9() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetSET3_SETP10(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetSET3_SETP10() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetSET3_SETP11(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetSET3_SETP11() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetSET3_SETP12(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetSET3_SETP12() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetSET3_SETP13(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetSET3_SETP13() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetSET3_SETP14(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetSET3_SETP14() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetSET3_SETP15(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetSET3_SETP15() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetSET3_SETP16(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetSET3_SETP16() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetSET3_SETP17(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetSET3_SETP17() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetSET3_SETP18(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetSET3_SETP18() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetSET3_SETP19(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetSET3_SETP19() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetSET3_SETP20(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetSET3_SETP20() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetSET3_SETP21(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetSET3_SETP21() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetSET3_SETP22(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetSET3_SETP22() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetSET3_SETP23(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetSET3_SETP23() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetSET3_SETP24(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetSET3_SETP24() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetSET3_SETP25(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetSET3_SETP25() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetSET3_SETP26(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetSET3_SETP26() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetSET3_SETP27(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetSET3_SETP27() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetSET3_SETP28(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetSET3_SETP28() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetSET3_SETP29(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetSET3_SETP29() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetSET3_SETP30(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetSET3_SETP30() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetSET3_SETP31(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetSET3_SETP31() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.SET4: Write: Set register for port m Read: output bits for port m
func (o *GPIO_PORT_Type) SetSET4_SETP0(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetSET4_SETP0() uint32 {
	return volatile.LoadUint32(&o.SET4.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetSET4_SETP1(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetSET4_SETP1() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetSET4_SETP2(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetSET4_SETP2() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetSET4_SETP3(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetSET4_SETP3() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetSET4_SETP4(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetSET4_SETP4() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetSET4_SETP5(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetSET4_SETP5() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetSET4_SETP6(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetSET4_SETP6() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetSET4_SETP7(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetSET4_SETP7() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetSET4_SETP8(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetSET4_SETP8() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetSET4_SETP9(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetSET4_SETP9() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetSET4_SETP10(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetSET4_SETP10() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetSET4_SETP11(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetSET4_SETP11() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetSET4_SETP12(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetSET4_SETP12() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetSET4_SETP13(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetSET4_SETP13() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetSET4_SETP14(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetSET4_SETP14() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetSET4_SETP15(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetSET4_SETP15() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetSET4_SETP16(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetSET4_SETP16() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetSET4_SETP17(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetSET4_SETP17() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetSET4_SETP18(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetSET4_SETP18() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetSET4_SETP19(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetSET4_SETP19() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetSET4_SETP20(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetSET4_SETP20() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetSET4_SETP21(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetSET4_SETP21() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetSET4_SETP22(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetSET4_SETP22() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetSET4_SETP23(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetSET4_SETP23() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetSET4_SETP24(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetSET4_SETP24() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetSET4_SETP25(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetSET4_SETP25() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetSET4_SETP26(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetSET4_SETP26() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetSET4_SETP27(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetSET4_SETP27() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetSET4_SETP28(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetSET4_SETP28() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetSET4_SETP29(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetSET4_SETP29() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetSET4_SETP30(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetSET4_SETP30() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetSET4_SETP31(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetSET4_SETP31() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.SET5: Write: Set register for port m Read: output bits for port m
func (o *GPIO_PORT_Type) SetSET5_SETP0(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetSET5_SETP0() uint32 {
	return volatile.LoadUint32(&o.SET5.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetSET5_SETP1(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetSET5_SETP1() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetSET5_SETP2(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetSET5_SETP2() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetSET5_SETP3(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetSET5_SETP3() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetSET5_SETP4(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetSET5_SETP4() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetSET5_SETP5(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetSET5_SETP5() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetSET5_SETP6(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetSET5_SETP6() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetSET5_SETP7(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetSET5_SETP7() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetSET5_SETP8(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetSET5_SETP8() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetSET5_SETP9(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetSET5_SETP9() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetSET5_SETP10(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetSET5_SETP10() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetSET5_SETP11(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetSET5_SETP11() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetSET5_SETP12(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetSET5_SETP12() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetSET5_SETP13(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetSET5_SETP13() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetSET5_SETP14(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetSET5_SETP14() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetSET5_SETP15(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetSET5_SETP15() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetSET5_SETP16(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetSET5_SETP16() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetSET5_SETP17(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetSET5_SETP17() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetSET5_SETP18(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetSET5_SETP18() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetSET5_SETP19(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetSET5_SETP19() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetSET5_SETP20(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetSET5_SETP20() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetSET5_SETP21(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetSET5_SETP21() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetSET5_SETP22(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetSET5_SETP22() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetSET5_SETP23(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetSET5_SETP23() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetSET5_SETP24(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetSET5_SETP24() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetSET5_SETP25(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetSET5_SETP25() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetSET5_SETP26(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetSET5_SETP26() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetSET5_SETP27(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetSET5_SETP27() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetSET5_SETP28(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetSET5_SETP28() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetSET5_SETP29(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetSET5_SETP29() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetSET5_SETP30(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetSET5_SETP30() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetSET5_SETP31(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetSET5_SETP31() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.SET6: Write: Set register for port m Read: output bits for port m
func (o *GPIO_PORT_Type) SetSET6_SETP0(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetSET6_SETP0() uint32 {
	return volatile.LoadUint32(&o.SET6.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetSET6_SETP1(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetSET6_SETP1() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetSET6_SETP2(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetSET6_SETP2() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetSET6_SETP3(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetSET6_SETP3() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetSET6_SETP4(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetSET6_SETP4() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetSET6_SETP5(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetSET6_SETP5() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetSET6_SETP6(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetSET6_SETP6() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetSET6_SETP7(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetSET6_SETP7() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetSET6_SETP8(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetSET6_SETP8() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetSET6_SETP9(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetSET6_SETP9() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetSET6_SETP10(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetSET6_SETP10() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetSET6_SETP11(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetSET6_SETP11() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetSET6_SETP12(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetSET6_SETP12() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetSET6_SETP13(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetSET6_SETP13() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetSET6_SETP14(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetSET6_SETP14() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetSET6_SETP15(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetSET6_SETP15() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetSET6_SETP16(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetSET6_SETP16() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetSET6_SETP17(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetSET6_SETP17() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetSET6_SETP18(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetSET6_SETP18() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetSET6_SETP19(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetSET6_SETP19() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetSET6_SETP20(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetSET6_SETP20() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetSET6_SETP21(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetSET6_SETP21() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetSET6_SETP22(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetSET6_SETP22() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetSET6_SETP23(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetSET6_SETP23() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetSET6_SETP24(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetSET6_SETP24() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetSET6_SETP25(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetSET6_SETP25() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetSET6_SETP26(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetSET6_SETP26() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetSET6_SETP27(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetSET6_SETP27() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetSET6_SETP28(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetSET6_SETP28() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetSET6_SETP29(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetSET6_SETP29() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetSET6_SETP30(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetSET6_SETP30() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetSET6_SETP31(value uint32) {
	volatile.StoreUint32(&o.SET6.Reg, volatile.LoadUint32(&o.SET6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetSET6_SETP31() uint32 {
	return (volatile.LoadUint32(&o.SET6.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.SET7: Write: Set register for port m Read: output bits for port m
func (o *GPIO_PORT_Type) SetSET7_SETP0(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetSET7_SETP0() uint32 {
	return volatile.LoadUint32(&o.SET7.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetSET7_SETP1(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetSET7_SETP1() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetSET7_SETP2(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetSET7_SETP2() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetSET7_SETP3(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetSET7_SETP3() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetSET7_SETP4(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetSET7_SETP4() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetSET7_SETP5(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetSET7_SETP5() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetSET7_SETP6(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetSET7_SETP6() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetSET7_SETP7(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetSET7_SETP7() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetSET7_SETP8(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetSET7_SETP8() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetSET7_SETP9(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetSET7_SETP9() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetSET7_SETP10(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetSET7_SETP10() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetSET7_SETP11(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetSET7_SETP11() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetSET7_SETP12(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetSET7_SETP12() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetSET7_SETP13(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetSET7_SETP13() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetSET7_SETP14(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetSET7_SETP14() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetSET7_SETP15(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetSET7_SETP15() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetSET7_SETP16(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetSET7_SETP16() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetSET7_SETP17(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetSET7_SETP17() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetSET7_SETP18(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetSET7_SETP18() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetSET7_SETP19(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetSET7_SETP19() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetSET7_SETP20(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetSET7_SETP20() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetSET7_SETP21(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetSET7_SETP21() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetSET7_SETP22(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetSET7_SETP22() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetSET7_SETP23(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetSET7_SETP23() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetSET7_SETP24(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetSET7_SETP24() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetSET7_SETP25(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetSET7_SETP25() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetSET7_SETP26(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetSET7_SETP26() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetSET7_SETP27(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetSET7_SETP27() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetSET7_SETP28(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetSET7_SETP28() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetSET7_SETP29(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetSET7_SETP29() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetSET7_SETP30(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetSET7_SETP30() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetSET7_SETP31(value uint32) {
	volatile.StoreUint32(&o.SET7.Reg, volatile.LoadUint32(&o.SET7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetSET7_SETP31() uint32 {
	return (volatile.LoadUint32(&o.SET7.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.CLR0: Clear port m
func (o *GPIO_PORT_Type) SetCLR0_CLRP00(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP00() uint32 {
	return volatile.LoadUint32(&o.CLR0.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP01(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP01() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP02(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP02() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP03(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP03() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP04(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP04() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP05(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP05() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP06(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP06() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP07(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP07() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP08(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP08() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP09(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP09() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP010(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP010() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP011(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP011() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP012(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP012() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP013(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP013() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP014(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP014() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP015(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP015() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP016(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP016() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP017(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP017() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP018(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP018() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP019(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP019() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP020(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP020() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP021(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP021() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP022(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP022() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP023(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP023() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP024(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP024() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP025(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP025() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP026(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP026() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP027(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP027() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP028(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP028() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP029(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP029() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP030(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP030() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetCLR0_CLRP031(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetCLR0_CLRP031() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.CLR1: Clear port m
func (o *GPIO_PORT_Type) SetCLR1_CLRP00(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP00() uint32 {
	return volatile.LoadUint32(&o.CLR1.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP01(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP01() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP02(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP02() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP03(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP03() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP04(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP04() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP05(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP05() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP06(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP06() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP07(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP07() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP08(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP08() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP09(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP09() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP010(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP010() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP011(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP011() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP012(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP012() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP013(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP013() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP014(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP014() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP015(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP015() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP016(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP016() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP017(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP017() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP018(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP018() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP019(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP019() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP020(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP020() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP021(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP021() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP022(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP022() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP023(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP023() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP024(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP024() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP025(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP025() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP026(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP026() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP027(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP027() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP028(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP028() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP029(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP029() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP030(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP030() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetCLR1_CLRP031(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetCLR1_CLRP031() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.CLR2: Clear port m
func (o *GPIO_PORT_Type) SetCLR2_CLRP00(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP00() uint32 {
	return volatile.LoadUint32(&o.CLR2.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP01(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP01() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP02(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP02() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP03(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP03() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP04(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP04() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP05(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP05() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP06(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP06() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP07(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP07() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP08(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP08() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP09(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP09() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP010(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP010() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP011(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP011() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP012(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP012() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP013(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP013() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP014(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP014() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP015(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP015() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP016(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP016() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP017(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP017() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP018(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP018() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP019(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP019() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP020(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP020() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP021(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP021() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP022(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP022() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP023(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP023() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP024(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP024() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP025(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP025() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP026(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP026() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP027(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP027() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP028(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP028() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP029(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP029() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP030(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP030() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetCLR2_CLRP031(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetCLR2_CLRP031() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.CLR3: Clear port m
func (o *GPIO_PORT_Type) SetCLR3_CLRP00(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP00() uint32 {
	return volatile.LoadUint32(&o.CLR3.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP01(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP01() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP02(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP02() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP03(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP03() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP04(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP04() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP05(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP05() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP06(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP06() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP07(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP07() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP08(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP08() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP09(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP09() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP010(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP010() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP011(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP011() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP012(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP012() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP013(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP013() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP014(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP014() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP015(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP015() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP016(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP016() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP017(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP017() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP018(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP018() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP019(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP019() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP020(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP020() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP021(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP021() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP022(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP022() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP023(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP023() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP024(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP024() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP025(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP025() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP026(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP026() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP027(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP027() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP028(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP028() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP029(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP029() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP030(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP030() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetCLR3_CLRP031(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetCLR3_CLRP031() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.CLR4: Clear port m
func (o *GPIO_PORT_Type) SetCLR4_CLRP00(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP00() uint32 {
	return volatile.LoadUint32(&o.CLR4.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP01(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP01() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP02(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP02() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP03(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP03() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP04(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP04() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP05(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP05() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP06(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP06() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP07(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP07() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP08(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP08() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP09(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP09() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP010(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP010() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP011(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP011() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP012(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP012() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP013(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP013() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP014(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP014() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP015(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP015() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP016(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP016() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP017(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP017() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP018(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP018() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP019(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP019() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP020(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP020() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP021(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP021() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP022(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP022() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP023(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP023() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP024(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP024() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP025(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP025() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP026(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP026() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP027(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP027() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP028(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP028() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP029(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP029() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP030(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP030() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetCLR4_CLRP031(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetCLR4_CLRP031() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.CLR5: Clear port m
func (o *GPIO_PORT_Type) SetCLR5_CLRP00(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP00() uint32 {
	return volatile.LoadUint32(&o.CLR5.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP01(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP01() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP02(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP02() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP03(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP03() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP04(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP04() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP05(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP05() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP06(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP06() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP07(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP07() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP08(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP08() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP09(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP09() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP010(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP010() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP011(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP011() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP012(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP012() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP013(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP013() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP014(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP014() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP015(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP015() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP016(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP016() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP017(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP017() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP018(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP018() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP019(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP019() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP020(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP020() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP021(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP021() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP022(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP022() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP023(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP023() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP024(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP024() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP025(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP025() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP026(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP026() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP027(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP027() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP028(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP028() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP029(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP029() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP030(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP030() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetCLR5_CLRP031(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetCLR5_CLRP031() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.CLR6: Clear port m
func (o *GPIO_PORT_Type) SetCLR6_CLRP00(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP00() uint32 {
	return volatile.LoadUint32(&o.CLR6.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP01(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP01() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP02(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP02() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP03(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP03() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP04(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP04() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP05(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP05() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP06(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP06() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP07(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP07() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP08(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP08() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP09(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP09() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP010(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP010() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP011(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP011() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP012(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP012() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP013(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP013() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP014(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP014() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP015(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP015() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP016(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP016() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP017(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP017() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP018(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP018() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP019(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP019() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP020(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP020() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP021(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP021() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP022(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP022() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP023(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP023() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP024(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP024() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP025(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP025() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP026(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP026() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP027(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP027() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP028(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP028() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP029(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP029() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP030(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP030() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetCLR6_CLRP031(value uint32) {
	volatile.StoreUint32(&o.CLR6.Reg, volatile.LoadUint32(&o.CLR6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetCLR6_CLRP031() uint32 {
	return (volatile.LoadUint32(&o.CLR6.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.CLR7: Clear port m
func (o *GPIO_PORT_Type) SetCLR7_CLRP00(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP00() uint32 {
	return volatile.LoadUint32(&o.CLR7.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP01(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP01() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP02(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP02() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP03(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP03() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP04(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP04() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP05(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP05() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP06(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP06() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP07(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP07() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP08(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP08() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP09(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP09() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP010(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP010() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP011(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP011() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP012(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP012() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP013(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP013() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP014(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP014() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP015(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP015() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP016(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP016() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP017(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP017() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP018(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP018() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP019(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP019() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP020(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP020() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP021(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP021() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP022(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP022() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP023(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP023() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP024(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP024() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP025(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP025() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP026(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP026() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP027(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP027() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP028(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP028() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP029(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP029() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP030(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP030() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetCLR7_CLRP031(value uint32) {
	volatile.StoreUint32(&o.CLR7.Reg, volatile.LoadUint32(&o.CLR7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetCLR7_CLRP031() uint32 {
	return (volatile.LoadUint32(&o.CLR7.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.NOT0: Toggle port m
func (o *GPIO_PORT_Type) SetNOT0_NOTP0(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP0() uint32 {
	return volatile.LoadUint32(&o.NOT0.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP1(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP1() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP2(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP2() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP3(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP3() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP4(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP4() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP5(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP5() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP6(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP6() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP7(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP7() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP8(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP8() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP9(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP9() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP10(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP10() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP11(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP11() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP12(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP12() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP13(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP13() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP14(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP14() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP15(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP15() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP16(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP16() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP17(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP17() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP18(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP18() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP19(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP19() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP20(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP20() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP21(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP21() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP22(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP22() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP23(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP23() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP24(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP24() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP25(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP25() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP26(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP26() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP27(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP27() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP28(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP28() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP29(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP29() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP30(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP30() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetNOT0_NOTP31(value uint32) {
	volatile.StoreUint32(&o.NOT0.Reg, volatile.LoadUint32(&o.NOT0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetNOT0_NOTP31() uint32 {
	return (volatile.LoadUint32(&o.NOT0.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.NOT1: Toggle port m
func (o *GPIO_PORT_Type) SetNOT1_NOTP0(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP0() uint32 {
	return volatile.LoadUint32(&o.NOT1.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP1(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP1() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP2(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP2() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP3(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP3() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP4(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP4() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP5(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP5() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP6(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP6() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP7(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP7() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP8(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP8() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP9(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP9() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP10(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP10() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP11(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP11() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP12(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP12() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP13(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP13() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP14(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP14() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP15(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP15() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP16(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP16() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP17(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP17() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP18(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP18() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP19(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP19() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP20(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP20() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP21(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP21() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP22(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP22() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP23(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP23() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP24(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP24() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP25(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP25() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP26(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP26() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP27(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP27() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP28(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP28() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP29(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP29() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP30(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP30() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetNOT1_NOTP31(value uint32) {
	volatile.StoreUint32(&o.NOT1.Reg, volatile.LoadUint32(&o.NOT1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetNOT1_NOTP31() uint32 {
	return (volatile.LoadUint32(&o.NOT1.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.NOT2: Toggle port m
func (o *GPIO_PORT_Type) SetNOT2_NOTP0(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP0() uint32 {
	return volatile.LoadUint32(&o.NOT2.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP1(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP1() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP2(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP2() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP3(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP3() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP4(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP4() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP5(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP5() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP6(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP6() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP7(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP7() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP8(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP8() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP9(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP9() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP10(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP10() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP11(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP11() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP12(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP12() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP13(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP13() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP14(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP14() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP15(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP15() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP16(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP16() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP17(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP17() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP18(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP18() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP19(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP19() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP20(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP20() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP21(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP21() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP22(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP22() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP23(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP23() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP24(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP24() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP25(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP25() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP26(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP26() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP27(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP27() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP28(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP28() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP29(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP29() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP30(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP30() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetNOT2_NOTP31(value uint32) {
	volatile.StoreUint32(&o.NOT2.Reg, volatile.LoadUint32(&o.NOT2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetNOT2_NOTP31() uint32 {
	return (volatile.LoadUint32(&o.NOT2.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.NOT3: Toggle port m
func (o *GPIO_PORT_Type) SetNOT3_NOTP0(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP0() uint32 {
	return volatile.LoadUint32(&o.NOT3.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP1(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP1() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP2(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP2() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP3(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP3() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP4(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP4() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP5(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP5() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP6(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP6() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP7(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP7() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP8(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP8() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP9(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP9() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP10(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP10() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP11(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP11() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP12(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP12() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP13(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP13() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP14(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP14() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP15(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP15() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP16(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP16() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP17(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP17() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP18(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP18() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP19(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP19() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP20(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP20() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP21(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP21() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP22(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP22() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP23(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP23() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP24(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP24() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP25(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP25() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP26(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP26() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP27(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP27() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP28(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP28() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP29(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP29() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP30(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP30() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetNOT3_NOTP31(value uint32) {
	volatile.StoreUint32(&o.NOT3.Reg, volatile.LoadUint32(&o.NOT3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetNOT3_NOTP31() uint32 {
	return (volatile.LoadUint32(&o.NOT3.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.NOT4: Toggle port m
func (o *GPIO_PORT_Type) SetNOT4_NOTP0(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP0() uint32 {
	return volatile.LoadUint32(&o.NOT4.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP1(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP1() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP2(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP2() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP3(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP3() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP4(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP4() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP5(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP5() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP6(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP6() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP7(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP7() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP8(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP8() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP9(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP9() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP10(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP10() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP11(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP11() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP12(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP12() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP13(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP13() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP14(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP14() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP15(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP15() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP16(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP16() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP17(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP17() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP18(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP18() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP19(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP19() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP20(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP20() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP21(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP21() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP22(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP22() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP23(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP23() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP24(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP24() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP25(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP25() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP26(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP26() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP27(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP27() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP28(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP28() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP29(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP29() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP30(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP30() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetNOT4_NOTP31(value uint32) {
	volatile.StoreUint32(&o.NOT4.Reg, volatile.LoadUint32(&o.NOT4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetNOT4_NOTP31() uint32 {
	return (volatile.LoadUint32(&o.NOT4.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.NOT5: Toggle port m
func (o *GPIO_PORT_Type) SetNOT5_NOTP0(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP0() uint32 {
	return volatile.LoadUint32(&o.NOT5.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP1(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP1() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP2(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP2() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP3(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP3() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP4(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP4() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP5(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP5() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP6(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP6() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP7(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP7() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP8(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP8() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP9(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP9() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP10(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP10() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP11(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP11() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP12(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP12() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP13(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP13() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP14(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP14() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP15(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP15() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP16(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP16() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP17(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP17() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP18(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP18() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP19(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP19() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP20(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP20() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP21(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP21() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP22(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP22() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP23(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP23() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP24(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP24() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP25(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP25() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP26(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP26() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP27(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP27() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP28(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP28() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP29(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP29() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP30(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP30() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetNOT5_NOTP31(value uint32) {
	volatile.StoreUint32(&o.NOT5.Reg, volatile.LoadUint32(&o.NOT5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetNOT5_NOTP31() uint32 {
	return (volatile.LoadUint32(&o.NOT5.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.NOT6: Toggle port m
func (o *GPIO_PORT_Type) SetNOT6_NOTP0(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP0() uint32 {
	return volatile.LoadUint32(&o.NOT6.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP1(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP1() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP2(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP2() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP3(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP3() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP4(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP4() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP5(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP5() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP6(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP6() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP7(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP7() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP8(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP8() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP9(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP9() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP10(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP10() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP11(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP11() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP12(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP12() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP13(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP13() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP14(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP14() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP15(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP15() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP16(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP16() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP17(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP17() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP18(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP18() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP19(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP19() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP20(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP20() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP21(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP21() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP22(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP22() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP23(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP23() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP24(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP24() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP25(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP25() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP26(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP26() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP27(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP27() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP28(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP28() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP29(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP29() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP30(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP30() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetNOT6_NOTP31(value uint32) {
	volatile.StoreUint32(&o.NOT6.Reg, volatile.LoadUint32(&o.NOT6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetNOT6_NOTP31() uint32 {
	return (volatile.LoadUint32(&o.NOT6.Reg) & 0x80000000) >> 31
}

// GPIO_PORT.NOT7: Toggle port m
func (o *GPIO_PORT_Type) SetNOT7_NOTP0(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x1)|value)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP0() uint32 {
	return volatile.LoadUint32(&o.NOT7.Reg) & 0x1
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP1(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP1() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x2) >> 1
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP2(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP2() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x4) >> 2
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP3(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP3() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x8) >> 3
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP4(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP4() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x10) >> 4
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP5(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP5() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x20) >> 5
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP6(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP6() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x40) >> 6
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP7(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP7() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x80) >> 7
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP8(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP8() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x100) >> 8
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP9(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP9() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x200) >> 9
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP10(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP10() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x400) >> 10
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP11(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP11() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x800) >> 11
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP12(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP12() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x1000) >> 12
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP13(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP13() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x2000) >> 13
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP14(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP14() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x4000) >> 14
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP15(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP15() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x8000) >> 15
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP16(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP16() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x10000) >> 16
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP17(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP17() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x20000) >> 17
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP18(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP18() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x40000) >> 18
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP19(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP19() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x80000) >> 19
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP20(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP20() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x100000) >> 20
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP21(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP21() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x200000) >> 21
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP22(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP22() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x400000) >> 22
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP23(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP23() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x800000) >> 23
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP24(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP24() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x1000000) >> 24
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP25(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP25() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x2000000) >> 25
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP26(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP26() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x4000000) >> 26
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP27(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP27() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x8000000) >> 27
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP28(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP28() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x10000000) >> 28
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP29(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP29() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x20000000) >> 29
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP30(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP30() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x40000000) >> 30
}
func (o *GPIO_PORT_Type) SetNOT7_NOTP31(value uint32) {
	volatile.StoreUint32(&o.NOT7.Reg, volatile.LoadUint32(&o.NOT7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_PORT_Type) GetNOT7_NOTP31() uint32 {
	return (volatile.LoadUint32(&o.NOT7.Reg) & 0x80000000) >> 31
}

// Constants for SCT: State Configurable Timer (SCT) with dither engine
const (
	// CONFIG: SCT configuration register
	// Position of UNIFY field.
	SCT_CONFIG_UNIFY_Pos = 0x0
	// Bit mask of UNIFY field.
	SCT_CONFIG_UNIFY_Msk = 0x1
	// Bit UNIFY.
	SCT_CONFIG_UNIFY = 0x1
	// 16-bit.The SCT operates as two 16-bit counters named L and H.
	SCT_CONFIG_UNIFY_16_BIT = 0x0
	// 32-bit. The SCT operates as a unified 32-bit counter.
	SCT_CONFIG_UNIFY_32_BIT = 0x1
	// Position of CLKMODE field.
	SCT_CONFIG_CLKMODE_Pos = 0x1
	// Bit mask of CLKMODE field.
	SCT_CONFIG_CLKMODE_Msk = 0x6
	// Bus clock. The bus clock clocks the SCT and prescalers.
	SCT_CONFIG_CLKMODE_BUS_CLOCK = 0x0
	// Prescaled bus clock. The SCT clock is the bus clock, but the prescalers are enabled to count only when sampling of the input selected by the CKSEL field finds the selected edge. The minimum pulse width on the clock input is 1 bus clock period. This mode is the high-performance sampled-clock mode.
	SCT_CONFIG_CLKMODE_PRESCALED_BUS_CLOCK = 0x1
	// SCT Input. The input selected by CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted. The minimum pulse width on the clock input is 1 bus clock period. This mode is the low-power sampled-clock mode.
	SCT_CONFIG_CLKMODE_SCT_INPUT = 0x2
	// Position of CKSEL field.
	SCT_CONFIG_CKSEL_Pos = 0x3
	// Bit mask of CKSEL field.
	SCT_CONFIG_CKSEL_Msk = 0x78
	// Position of NORELAOD_L field.
	SCT_CONFIG_NORELAOD_L_Pos = 0x7
	// Bit mask of NORELAOD_L field.
	SCT_CONFIG_NORELAOD_L_Msk = 0x80
	// Bit NORELAOD_L.
	SCT_CONFIG_NORELAOD_L = 0x80
	// Position of NORELOAD_H field.
	SCT_CONFIG_NORELOAD_H_Pos = 0x8
	// Bit mask of NORELOAD_H field.
	SCT_CONFIG_NORELOAD_H_Msk = 0x100
	// Bit NORELOAD_H.
	SCT_CONFIG_NORELOAD_H = 0x100
	// Position of INSYNC field.
	SCT_CONFIG_INSYNC_Pos = 0x9
	// Bit mask of INSYNC field.
	SCT_CONFIG_INSYNC_Msk = 0x1fe00
	// Position of AUTOLIMIT_L field.
	SCT_CONFIG_AUTOLIMIT_L_Pos = 0x11
	// Bit mask of AUTOLIMIT_L field.
	SCT_CONFIG_AUTOLIMIT_L_Msk = 0x20000
	// Bit AUTOLIMIT_L.
	SCT_CONFIG_AUTOLIMIT_L = 0x20000
	// Position of AUTOLIMIT_H field.
	SCT_CONFIG_AUTOLIMIT_H_Pos = 0x12
	// Bit mask of AUTOLIMIT_H field.
	SCT_CONFIG_AUTOLIMIT_H_Msk = 0x40000
	// Bit AUTOLIMIT_H.
	SCT_CONFIG_AUTOLIMIT_H = 0x40000
	// Position of RESERVED field.
	SCT_CONFIG_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	SCT_CONFIG_RESERVED_Msk = 0xfff80000

	// CTRL: SCT control register
	// Position of DOWN_L field.
	SCT_CTRL_DOWN_L_Pos = 0x0
	// Bit mask of DOWN_L field.
	SCT_CTRL_DOWN_L_Msk = 0x1
	// Bit DOWN_L.
	SCT_CTRL_DOWN_L = 0x1
	// Position of STOP_L field.
	SCT_CTRL_STOP_L_Pos = 0x1
	// Bit mask of STOP_L field.
	SCT_CTRL_STOP_L_Msk = 0x2
	// Bit STOP_L.
	SCT_CTRL_STOP_L = 0x2
	// Position of HALT_L field.
	SCT_CTRL_HALT_L_Pos = 0x2
	// Bit mask of HALT_L field.
	SCT_CTRL_HALT_L_Msk = 0x4
	// Bit HALT_L.
	SCT_CTRL_HALT_L = 0x4
	// Position of CLRCTR_L field.
	SCT_CTRL_CLRCTR_L_Pos = 0x3
	// Bit mask of CLRCTR_L field.
	SCT_CTRL_CLRCTR_L_Msk = 0x8
	// Bit CLRCTR_L.
	SCT_CTRL_CLRCTR_L = 0x8
	// Position of BIDIR_L field.
	SCT_CTRL_BIDIR_L_Pos = 0x4
	// Bit mask of BIDIR_L field.
	SCT_CTRL_BIDIR_L_Msk = 0x10
	// Bit BIDIR_L.
	SCT_CTRL_BIDIR_L = 0x10
	// Up. The counter counts up to its limit condition, then is cleared to zero.
	SCT_CTRL_BIDIR_L_UP = 0x0
	// Up-down. The counter counts up to its limit, then counts down to a limit condition or to 0.
	SCT_CTRL_BIDIR_L_UPDOWN = 0x1
	// Position of PRE_L field.
	SCT_CTRL_PRE_L_Pos = 0x5
	// Bit mask of PRE_L field.
	SCT_CTRL_PRE_L_Msk = 0x1fe0
	// Position of RESERVED field.
	SCT_CTRL_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	SCT_CTRL_RESERVED_Msk = 0xe000
	// Position of DOWN_H field.
	SCT_CTRL_DOWN_H_Pos = 0x10
	// Bit mask of DOWN_H field.
	SCT_CTRL_DOWN_H_Msk = 0x10000
	// Bit DOWN_H.
	SCT_CTRL_DOWN_H = 0x10000
	// Position of STOP_H field.
	SCT_CTRL_STOP_H_Pos = 0x11
	// Bit mask of STOP_H field.
	SCT_CTRL_STOP_H_Msk = 0x20000
	// Bit STOP_H.
	SCT_CTRL_STOP_H = 0x20000
	// Position of HALT_H field.
	SCT_CTRL_HALT_H_Pos = 0x12
	// Bit mask of HALT_H field.
	SCT_CTRL_HALT_H_Msk = 0x40000
	// Bit HALT_H.
	SCT_CTRL_HALT_H = 0x40000
	// Position of CLRCTR_H field.
	SCT_CTRL_CLRCTR_H_Pos = 0x13
	// Bit mask of CLRCTR_H field.
	SCT_CTRL_CLRCTR_H_Msk = 0x80000
	// Bit CLRCTR_H.
	SCT_CTRL_CLRCTR_H = 0x80000
	// Position of BIDIR_H field.
	SCT_CTRL_BIDIR_H_Pos = 0x14
	// Bit mask of BIDIR_H field.
	SCT_CTRL_BIDIR_H_Msk = 0x100000
	// Bit BIDIR_H.
	SCT_CTRL_BIDIR_H = 0x100000
	// Up. The H counter counts up to its limit condition, then is cleared to zero.
	SCT_CTRL_BIDIR_H_UP = 0x0
	// Up-down. The H counter counts up to its limit, then counts down to a limit condition or to 0.
	SCT_CTRL_BIDIR_H_UPDOWN = 0x1
	// Position of PRE_H field.
	SCT_CTRL_PRE_H_Pos = 0x15
	// Bit mask of PRE_H field.
	SCT_CTRL_PRE_H_Msk = 0x1fe00000
	// Position of RESERVED field.
	SCT_CTRL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	SCT_CTRL_RESERVED_Msk = 0xe0000000

	// LIMIT: SCT limit register
	// Position of LIMMSK_L field.
	SCT_LIMIT_LIMMSK_L_Pos = 0x0
	// Bit mask of LIMMSK_L field.
	SCT_LIMIT_LIMMSK_L_Msk = 0xffff
	// Position of LIMMSK_H field.
	SCT_LIMIT_LIMMSK_H_Pos = 0x10
	// Bit mask of LIMMSK_H field.
	SCT_LIMIT_LIMMSK_H_Msk = 0xffff0000

	// HALT: SCT halt condition register
	// Position of HALTMSK_L field.
	SCT_HALT_HALTMSK_L_Pos = 0x0
	// Bit mask of HALTMSK_L field.
	SCT_HALT_HALTMSK_L_Msk = 0xffff
	// Position of HALTMSK_H field.
	SCT_HALT_HALTMSK_H_Pos = 0x10
	// Bit mask of HALTMSK_H field.
	SCT_HALT_HALTMSK_H_Msk = 0xffff0000

	// STOP: SCT stop condition register
	// Position of STOPMSK_L field.
	SCT_STOP_STOPMSK_L_Pos = 0x0
	// Bit mask of STOPMSK_L field.
	SCT_STOP_STOPMSK_L_Msk = 0xffff
	// Position of STOPMSK_H field.
	SCT_STOP_STOPMSK_H_Pos = 0x10
	// Bit mask of STOPMSK_H field.
	SCT_STOP_STOPMSK_H_Msk = 0xffff0000

	// START: SCT start condition register
	// Position of STARTMSK_L field.
	SCT_START_STARTMSK_L_Pos = 0x0
	// Bit mask of STARTMSK_L field.
	SCT_START_STARTMSK_L_Msk = 0xffff
	// Position of STARTMSK_H field.
	SCT_START_STARTMSK_H_Pos = 0x10
	// Bit mask of STARTMSK_H field.
	SCT_START_STARTMSK_H_Msk = 0xffff0000

	// DITHER: SCT dither condition register
	// Position of DITHMSK_L field.
	SCT_DITHER_DITHMSK_L_Pos = 0x0
	// Bit mask of DITHMSK_L field.
	SCT_DITHER_DITHMSK_L_Msk = 0xffff
	// Position of DITHMSK_H field.
	SCT_DITHER_DITHMSK_H_Pos = 0x10
	// Bit mask of DITHMSK_H field.
	SCT_DITHER_DITHMSK_H_Msk = 0xffff0000

	// COUNT: SCT counter register
	// Position of CTR_L field.
	SCT_COUNT_CTR_L_Pos = 0x0
	// Bit mask of CTR_L field.
	SCT_COUNT_CTR_L_Msk = 0xffff
	// Position of CTR_H field.
	SCT_COUNT_CTR_H_Pos = 0x10
	// Bit mask of CTR_H field.
	SCT_COUNT_CTR_H_Msk = 0xffff0000

	// STATE: SCT state register
	// Position of STATE_L field.
	SCT_STATE_STATE_L_Pos = 0x0
	// Bit mask of STATE_L field.
	SCT_STATE_STATE_L_Msk = 0x1f
	// Position of RESERVED field.
	SCT_STATE_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SCT_STATE_RESERVED_Msk = 0xffe0
	// Position of STATE_H field.
	SCT_STATE_STATE_H_Pos = 0x10
	// Bit mask of STATE_H field.
	SCT_STATE_STATE_H_Msk = 0x1f0000
	// Position of RESERVED field.
	SCT_STATE_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	SCT_STATE_RESERVED_Msk = 0xffe00000

	// INPUT: SCT input register
	// Position of AIN0 field.
	SCT_INPUT_AIN0_Pos = 0x0
	// Bit mask of AIN0 field.
	SCT_INPUT_AIN0_Msk = 0x1
	// Bit AIN0.
	SCT_INPUT_AIN0 = 0x1
	// Position of AIN1 field.
	SCT_INPUT_AIN1_Pos = 0x1
	// Bit mask of AIN1 field.
	SCT_INPUT_AIN1_Msk = 0x2
	// Bit AIN1.
	SCT_INPUT_AIN1 = 0x2
	// Position of AIN2 field.
	SCT_INPUT_AIN2_Pos = 0x2
	// Bit mask of AIN2 field.
	SCT_INPUT_AIN2_Msk = 0x4
	// Bit AIN2.
	SCT_INPUT_AIN2 = 0x4
	// Position of AIN3 field.
	SCT_INPUT_AIN3_Pos = 0x3
	// Bit mask of AIN3 field.
	SCT_INPUT_AIN3_Msk = 0x8
	// Bit AIN3.
	SCT_INPUT_AIN3 = 0x8
	// Position of AIN4 field.
	SCT_INPUT_AIN4_Pos = 0x4
	// Bit mask of AIN4 field.
	SCT_INPUT_AIN4_Msk = 0x10
	// Bit AIN4.
	SCT_INPUT_AIN4 = 0x10
	// Position of AIN5 field.
	SCT_INPUT_AIN5_Pos = 0x5
	// Bit mask of AIN5 field.
	SCT_INPUT_AIN5_Msk = 0x20
	// Bit AIN5.
	SCT_INPUT_AIN5 = 0x20
	// Position of AIN6 field.
	SCT_INPUT_AIN6_Pos = 0x6
	// Bit mask of AIN6 field.
	SCT_INPUT_AIN6_Msk = 0x40
	// Bit AIN6.
	SCT_INPUT_AIN6 = 0x40
	// Position of AIN7 field.
	SCT_INPUT_AIN7_Pos = 0x7
	// Bit mask of AIN7 field.
	SCT_INPUT_AIN7_Msk = 0x80
	// Bit AIN7.
	SCT_INPUT_AIN7 = 0x80
	// Position of RESERVED field.
	SCT_INPUT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCT_INPUT_RESERVED_Msk = 0xff00
	// Position of SIN0 field.
	SCT_INPUT_SIN0_Pos = 0x10
	// Bit mask of SIN0 field.
	SCT_INPUT_SIN0_Msk = 0x10000
	// Bit SIN0.
	SCT_INPUT_SIN0 = 0x10000
	// Position of SIN1 field.
	SCT_INPUT_SIN1_Pos = 0x11
	// Bit mask of SIN1 field.
	SCT_INPUT_SIN1_Msk = 0x20000
	// Bit SIN1.
	SCT_INPUT_SIN1 = 0x20000
	// Position of SIN2 field.
	SCT_INPUT_SIN2_Pos = 0x12
	// Bit mask of SIN2 field.
	SCT_INPUT_SIN2_Msk = 0x40000
	// Bit SIN2.
	SCT_INPUT_SIN2 = 0x40000
	// Position of SIN3 field.
	SCT_INPUT_SIN3_Pos = 0x13
	// Bit mask of SIN3 field.
	SCT_INPUT_SIN3_Msk = 0x80000
	// Bit SIN3.
	SCT_INPUT_SIN3 = 0x80000
	// Position of SIN4 field.
	SCT_INPUT_SIN4_Pos = 0x14
	// Bit mask of SIN4 field.
	SCT_INPUT_SIN4_Msk = 0x100000
	// Bit SIN4.
	SCT_INPUT_SIN4 = 0x100000
	// Position of SIN5 field.
	SCT_INPUT_SIN5_Pos = 0x15
	// Bit mask of SIN5 field.
	SCT_INPUT_SIN5_Msk = 0x200000
	// Bit SIN5.
	SCT_INPUT_SIN5 = 0x200000
	// Position of SIN6 field.
	SCT_INPUT_SIN6_Pos = 0x16
	// Bit mask of SIN6 field.
	SCT_INPUT_SIN6_Msk = 0x400000
	// Bit SIN6.
	SCT_INPUT_SIN6 = 0x400000
	// Position of SIN7 field.
	SCT_INPUT_SIN7_Pos = 0x17
	// Bit mask of SIN7 field.
	SCT_INPUT_SIN7_Msk = 0x800000
	// Bit SIN7.
	SCT_INPUT_SIN7 = 0x800000
	// Position of RESERVED field.
	SCT_INPUT_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	SCT_INPUT_RESERVED_Msk = 0xff000000

	// REGMODE: SCT match/capture registers mode register
	// Position of REGMOD_L field.
	SCT_REGMODE_REGMOD_L_Pos = 0x0
	// Bit mask of REGMOD_L field.
	SCT_REGMODE_REGMOD_L_Msk = 0xffff
	// Position of REGMOD_H field.
	SCT_REGMODE_REGMOD_H_Pos = 0x10
	// Bit mask of REGMOD_H field.
	SCT_REGMODE_REGMOD_H_Msk = 0xffff0000

	// OUTPUT: SCT output register
	// Position of OUT field.
	SCT_OUTPUT_OUT_Pos = 0x0
	// Bit mask of OUT field.
	SCT_OUTPUT_OUT_Msk = 0xffff
	// Position of RESERVED field.
	SCT_OUTPUT_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCT_OUTPUT_RESERVED_Msk = 0xffff0000

	// OUTPUTDIRCTRL: SCT output counter direction control register
	// Position of SETCLR0 field.
	SCT_OUTPUTDIRCTRL_SETCLR0_Pos = 0x0
	// Bit mask of SETCLR0 field.
	SCT_OUTPUTDIRCTRL_SETCLR0_Msk = 0x3
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR0_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR0_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR0_H_COUNTER = 0x2
	// Position of SETCLR1 field.
	SCT_OUTPUTDIRCTRL_SETCLR1_Pos = 0x2
	// Bit mask of SETCLR1 field.
	SCT_OUTPUTDIRCTRL_SETCLR1_Msk = 0xc
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR1_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR1_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR1_H_COUNTER = 0x2
	// Position of SETCLR2 field.
	SCT_OUTPUTDIRCTRL_SETCLR2_Pos = 0x4
	// Bit mask of SETCLR2 field.
	SCT_OUTPUTDIRCTRL_SETCLR2_Msk = 0x30
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR2_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR2_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR2_H_COUNTER = 0x2
	// Position of SETCLR3 field.
	SCT_OUTPUTDIRCTRL_SETCLR3_Pos = 0x6
	// Bit mask of SETCLR3 field.
	SCT_OUTPUTDIRCTRL_SETCLR3_Msk = 0xc0
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR3_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR3_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR3_H_COUNTER = 0x2
	// Position of SETCLR4 field.
	SCT_OUTPUTDIRCTRL_SETCLR4_Pos = 0x8
	// Bit mask of SETCLR4 field.
	SCT_OUTPUTDIRCTRL_SETCLR4_Msk = 0x300
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR4_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR4_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR4_H_COUNTER = 0x2
	// Position of SETCLR5 field.
	SCT_OUTPUTDIRCTRL_SETCLR5_Pos = 0xa
	// Bit mask of SETCLR5 field.
	SCT_OUTPUTDIRCTRL_SETCLR5_Msk = 0xc00
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR5_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR5_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR5_H_COUNTER = 0x2
	// Position of SETCLR6 field.
	SCT_OUTPUTDIRCTRL_SETCLR6_Pos = 0xc
	// Bit mask of SETCLR6 field.
	SCT_OUTPUTDIRCTRL_SETCLR6_Msk = 0x3000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR6_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR6_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR6_H_COUNTER = 0x2
	// Position of SETCLR7 field.
	SCT_OUTPUTDIRCTRL_SETCLR7_Pos = 0xe
	// Bit mask of SETCLR7 field.
	SCT_OUTPUTDIRCTRL_SETCLR7_Msk = 0xc000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR7_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR7_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR7_H_COUNTER = 0x2
	// Position of SETCLR8 field.
	SCT_OUTPUTDIRCTRL_SETCLR8_Pos = 0x10
	// Bit mask of SETCLR8 field.
	SCT_OUTPUTDIRCTRL_SETCLR8_Msk = 0x30000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR8_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR8_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR8_H_COUNTER = 0x2
	// Position of SETCLR9 field.
	SCT_OUTPUTDIRCTRL_SETCLR9_Pos = 0x12
	// Bit mask of SETCLR9 field.
	SCT_OUTPUTDIRCTRL_SETCLR9_Msk = 0xc0000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR9_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR9_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR9_H_COUNTER = 0x2
	// Position of SETCLR10 field.
	SCT_OUTPUTDIRCTRL_SETCLR10_Pos = 0x14
	// Bit mask of SETCLR10 field.
	SCT_OUTPUTDIRCTRL_SETCLR10_Msk = 0x300000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR10_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR10_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR10_H_COUNTER = 0x2
	// Position of SETCLR11 field.
	SCT_OUTPUTDIRCTRL_SETCLR11_Pos = 0x16
	// Bit mask of SETCLR11 field.
	SCT_OUTPUTDIRCTRL_SETCLR11_Msk = 0xc00000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR11_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR11_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR11_H_COUNTER = 0x2
	// Position of SETCLR12 field.
	SCT_OUTPUTDIRCTRL_SETCLR12_Pos = 0x18
	// Bit mask of SETCLR12 field.
	SCT_OUTPUTDIRCTRL_SETCLR12_Msk = 0x3000000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR12_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR12_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR12_H_COUNTER = 0x2
	// Position of SETCLR13 field.
	SCT_OUTPUTDIRCTRL_SETCLR13_Pos = 0x1a
	// Bit mask of SETCLR13 field.
	SCT_OUTPUTDIRCTRL_SETCLR13_Msk = 0xc000000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR13_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR13_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR13_H_COUNTER = 0x2
	// Position of SETCLR14 field.
	SCT_OUTPUTDIRCTRL_SETCLR14_Pos = 0x1c
	// Bit mask of SETCLR14 field.
	SCT_OUTPUTDIRCTRL_SETCLR14_Msk = 0x30000000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR14_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR14_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR14_H_COUNTER = 0x2
	// Position of SETCLR15 field.
	SCT_OUTPUTDIRCTRL_SETCLR15_Pos = 0x1e
	// Bit mask of SETCLR15 field.
	SCT_OUTPUTDIRCTRL_SETCLR15_Msk = 0xc0000000
	// Independent. Set and clear do not depend on any counter.
	SCT_OUTPUTDIRCTRL_SETCLR15_INDEPENDENT = 0x0
	// L counter. Set and clear are reversed when counter L or the unified counter is counting down.
	SCT_OUTPUTDIRCTRL_SETCLR15_L_COUNTER = 0x1
	// H counter. Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
	SCT_OUTPUTDIRCTRL_SETCLR15_H_COUNTER = 0x2

	// RES: SCT conflict resolution register
	// Position of O0RES field.
	SCT_RES_O0RES_Pos = 0x0
	// Bit mask of O0RES field.
	SCT_RES_O0RES_Msk = 0x3
	// No change.
	SCT_RES_O0RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR0 field).
	SCT_RES_O0RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR0 field).
	SCT_RES_O0RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O0RES_TOGGLE_OUTPUT = 0x3
	// Position of O1RES field.
	SCT_RES_O1RES_Pos = 0x2
	// Bit mask of O1RES field.
	SCT_RES_O1RES_Msk = 0xc
	// No change.
	SCT_RES_O1RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR1 field).
	SCT_RES_O1RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR1 field).
	SCT_RES_O1RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O1RES_TOGGLE_OUTPUT = 0x3
	// Position of O2RES field.
	SCT_RES_O2RES_Pos = 0x4
	// Bit mask of O2RES field.
	SCT_RES_O2RES_Msk = 0x30
	// No change.
	SCT_RES_O2RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR2 field).
	SCT_RES_O2RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output n (or set based on the SETCLR2 field).
	SCT_RES_O2RES_CLEAR_OUTPUT_N_OR_S = 0x2
	// Toggle output.
	SCT_RES_O2RES_TOGGLE_OUTPUT = 0x3
	// Position of O3RES field.
	SCT_RES_O3RES_Pos = 0x6
	// Bit mask of O3RES field.
	SCT_RES_O3RES_Msk = 0xc0
	// No change.
	SCT_RES_O3RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR3 field).
	SCT_RES_O3RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR3 field).
	SCT_RES_O3RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O3RES_TOGGLE_OUTPUT = 0x3
	// Position of O4RES field.
	SCT_RES_O4RES_Pos = 0x8
	// Bit mask of O4RES field.
	SCT_RES_O4RES_Msk = 0x300
	// No change.
	SCT_RES_O4RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR4 field).
	SCT_RES_O4RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR4 field).
	SCT_RES_O4RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O4RES_TOGGLE_OUTPUT = 0x3
	// Position of O5RES field.
	SCT_RES_O5RES_Pos = 0xa
	// Bit mask of O5RES field.
	SCT_RES_O5RES_Msk = 0xc00
	// No change.
	SCT_RES_O5RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR5 field).
	SCT_RES_O5RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR5 field).
	SCT_RES_O5RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O5RES_TOGGLE_OUTPUT = 0x3
	// Position of O6RES field.
	SCT_RES_O6RES_Pos = 0xc
	// Bit mask of O6RES field.
	SCT_RES_O6RES_Msk = 0x3000
	// No change.
	SCT_RES_O6RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR6 field).
	SCT_RES_O6RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR6 field).
	SCT_RES_O6RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O6RES_TOGGLE_OUTPUT = 0x3
	// Position of O7RES field.
	SCT_RES_O7RES_Pos = 0xe
	// Bit mask of O7RES field.
	SCT_RES_O7RES_Msk = 0xc000
	// No change.
	SCT_RES_O7RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR7 field).
	SCT_RES_O7RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR7 field).
	SCT_RES_O7RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O7RES_TOGGLE_OUTPUT = 0x3
	// Position of O8RES field.
	SCT_RES_O8RES_Pos = 0x10
	// Bit mask of O8RES field.
	SCT_RES_O8RES_Msk = 0x30000
	// No change.
	SCT_RES_O8RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR8 field).
	SCT_RES_O8RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR8 field).
	SCT_RES_O8RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O8RES_TOGGLE_OUTPUT = 0x3
	// Position of O9RES field.
	SCT_RES_O9RES_Pos = 0x12
	// Bit mask of O9RES field.
	SCT_RES_O9RES_Msk = 0xc0000
	// No change.
	SCT_RES_O9RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR9 field).
	SCT_RES_O9RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR9 field).
	SCT_RES_O9RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O9RES_TOGGLE_OUTPUT = 0x3
	// Position of O10RES field.
	SCT_RES_O10RES_Pos = 0x14
	// Bit mask of O10RES field.
	SCT_RES_O10RES_Msk = 0x300000
	// No change.
	SCT_RES_O10RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR10 field).
	SCT_RES_O10RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR10 field).
	SCT_RES_O10RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O10RES_TOGGLE_OUTPUT = 0x3
	// Position of O11RES field.
	SCT_RES_O11RES_Pos = 0x16
	// Bit mask of O11RES field.
	SCT_RES_O11RES_Msk = 0xc00000
	// No change.
	SCT_RES_O11RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR11 field).
	SCT_RES_O11RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR11 field).
	SCT_RES_O11RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O11RES_TOGGLE_OUTPUT = 0x3
	// Position of O12RES field.
	SCT_RES_O12RES_Pos = 0x18
	// Bit mask of O12RES field.
	SCT_RES_O12RES_Msk = 0x3000000
	// No change.
	SCT_RES_O12RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR12 field).
	SCT_RES_O12RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR12 field).
	SCT_RES_O12RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O12RES_TOGGLE_OUTPUT = 0x3
	// Position of O13RES field.
	SCT_RES_O13RES_Pos = 0x1a
	// Bit mask of O13RES field.
	SCT_RES_O13RES_Msk = 0xc000000
	// No change.
	SCT_RES_O13RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR13 field).
	SCT_RES_O13RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR13 field).
	SCT_RES_O13RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O13RES_TOGGLE_OUTPUT = 0x3
	// Position of O14RES field.
	SCT_RES_O14RES_Pos = 0x1c
	// Bit mask of O14RES field.
	SCT_RES_O14RES_Msk = 0x30000000
	// No change.
	SCT_RES_O14RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR14 field).
	SCT_RES_O14RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR14 field).
	SCT_RES_O14RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O14RES_TOGGLE_OUTPUT = 0x3
	// Position of O15RES field.
	SCT_RES_O15RES_Pos = 0x1e
	// Bit mask of O15RES field.
	SCT_RES_O15RES_Msk = 0xc0000000
	// No change.
	SCT_RES_O15RES_NO_CHANGE = 0x0
	// Set output (or clear based on the SETCLR15 field).
	SCT_RES_O15RES_SET_OUTPUT_OR_CLEAR = 0x1
	// Clear output (or set based on the SETCLR15 field).
	SCT_RES_O15RES_CLEAR_OUTPUT_OR_SET = 0x2
	// Toggle output.
	SCT_RES_O15RES_TOGGLE_OUTPUT = 0x3

	// DMAREQ0: SCT DMA request 0 register
	// Position of DEV_00 field.
	SCT_DMAREQ0_DEV_00_Pos = 0x0
	// Bit mask of DEV_00 field.
	SCT_DMAREQ0_DEV_00_Msk = 0x1
	// Bit DEV_00.
	SCT_DMAREQ0_DEV_00 = 0x1
	// Position of DEV_01 field.
	SCT_DMAREQ0_DEV_01_Pos = 0x1
	// Bit mask of DEV_01 field.
	SCT_DMAREQ0_DEV_01_Msk = 0x2
	// Bit DEV_01.
	SCT_DMAREQ0_DEV_01 = 0x2
	// Position of DEV_02 field.
	SCT_DMAREQ0_DEV_02_Pos = 0x2
	// Bit mask of DEV_02 field.
	SCT_DMAREQ0_DEV_02_Msk = 0x4
	// Bit DEV_02.
	SCT_DMAREQ0_DEV_02 = 0x4
	// Position of DEV_03 field.
	SCT_DMAREQ0_DEV_03_Pos = 0x3
	// Bit mask of DEV_03 field.
	SCT_DMAREQ0_DEV_03_Msk = 0x8
	// Bit DEV_03.
	SCT_DMAREQ0_DEV_03 = 0x8
	// Position of DEV_04 field.
	SCT_DMAREQ0_DEV_04_Pos = 0x4
	// Bit mask of DEV_04 field.
	SCT_DMAREQ0_DEV_04_Msk = 0x10
	// Bit DEV_04.
	SCT_DMAREQ0_DEV_04 = 0x10
	// Position of DEV_05 field.
	SCT_DMAREQ0_DEV_05_Pos = 0x5
	// Bit mask of DEV_05 field.
	SCT_DMAREQ0_DEV_05_Msk = 0x20
	// Bit DEV_05.
	SCT_DMAREQ0_DEV_05 = 0x20
	// Position of DEV_06 field.
	SCT_DMAREQ0_DEV_06_Pos = 0x6
	// Bit mask of DEV_06 field.
	SCT_DMAREQ0_DEV_06_Msk = 0x40
	// Bit DEV_06.
	SCT_DMAREQ0_DEV_06 = 0x40
	// Position of DEV_07 field.
	SCT_DMAREQ0_DEV_07_Pos = 0x7
	// Bit mask of DEV_07 field.
	SCT_DMAREQ0_DEV_07_Msk = 0x80
	// Bit DEV_07.
	SCT_DMAREQ0_DEV_07 = 0x80
	// Position of DEV_08 field.
	SCT_DMAREQ0_DEV_08_Pos = 0x8
	// Bit mask of DEV_08 field.
	SCT_DMAREQ0_DEV_08_Msk = 0x100
	// Bit DEV_08.
	SCT_DMAREQ0_DEV_08 = 0x100
	// Position of DEV_09 field.
	SCT_DMAREQ0_DEV_09_Pos = 0x9
	// Bit mask of DEV_09 field.
	SCT_DMAREQ0_DEV_09_Msk = 0x200
	// Bit DEV_09.
	SCT_DMAREQ0_DEV_09 = 0x200
	// Position of DEV_010 field.
	SCT_DMAREQ0_DEV_010_Pos = 0xa
	// Bit mask of DEV_010 field.
	SCT_DMAREQ0_DEV_010_Msk = 0x400
	// Bit DEV_010.
	SCT_DMAREQ0_DEV_010 = 0x400
	// Position of DEV_011 field.
	SCT_DMAREQ0_DEV_011_Pos = 0xb
	// Bit mask of DEV_011 field.
	SCT_DMAREQ0_DEV_011_Msk = 0x800
	// Bit DEV_011.
	SCT_DMAREQ0_DEV_011 = 0x800
	// Position of DEV_012 field.
	SCT_DMAREQ0_DEV_012_Pos = 0xc
	// Bit mask of DEV_012 field.
	SCT_DMAREQ0_DEV_012_Msk = 0x1000
	// Bit DEV_012.
	SCT_DMAREQ0_DEV_012 = 0x1000
	// Position of DEV_013 field.
	SCT_DMAREQ0_DEV_013_Pos = 0xd
	// Bit mask of DEV_013 field.
	SCT_DMAREQ0_DEV_013_Msk = 0x2000
	// Bit DEV_013.
	SCT_DMAREQ0_DEV_013 = 0x2000
	// Position of DEV_014 field.
	SCT_DMAREQ0_DEV_014_Pos = 0xe
	// Bit mask of DEV_014 field.
	SCT_DMAREQ0_DEV_014_Msk = 0x4000
	// Bit DEV_014.
	SCT_DMAREQ0_DEV_014 = 0x4000
	// Position of DEV_015 field.
	SCT_DMAREQ0_DEV_015_Pos = 0xf
	// Bit mask of DEV_015 field.
	SCT_DMAREQ0_DEV_015_Msk = 0x8000
	// Bit DEV_015.
	SCT_DMAREQ0_DEV_015 = 0x8000
	// Position of RESERVED field.
	SCT_DMAREQ0_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCT_DMAREQ0_RESERVED_Msk = 0x3fff0000
	// Position of DRL0 field.
	SCT_DMAREQ0_DRL0_Pos = 0x1e
	// Bit mask of DRL0 field.
	SCT_DMAREQ0_DRL0_Msk = 0x40000000
	// Bit DRL0.
	SCT_DMAREQ0_DRL0 = 0x40000000
	// Position of DRQ0 field.
	SCT_DMAREQ0_DRQ0_Pos = 0x1f
	// Bit mask of DRQ0 field.
	SCT_DMAREQ0_DRQ0_Msk = 0x80000000
	// Bit DRQ0.
	SCT_DMAREQ0_DRQ0 = 0x80000000

	// DMAREQ1: SCT DMA request 1 register
	// Position of DEV_10 field.
	SCT_DMAREQ1_DEV_10_Pos = 0x0
	// Bit mask of DEV_10 field.
	SCT_DMAREQ1_DEV_10_Msk = 0x1
	// Bit DEV_10.
	SCT_DMAREQ1_DEV_10 = 0x1
	// Position of DEV_11 field.
	SCT_DMAREQ1_DEV_11_Pos = 0x1
	// Bit mask of DEV_11 field.
	SCT_DMAREQ1_DEV_11_Msk = 0x2
	// Bit DEV_11.
	SCT_DMAREQ1_DEV_11 = 0x2
	// Position of DEV_12 field.
	SCT_DMAREQ1_DEV_12_Pos = 0x2
	// Bit mask of DEV_12 field.
	SCT_DMAREQ1_DEV_12_Msk = 0x4
	// Bit DEV_12.
	SCT_DMAREQ1_DEV_12 = 0x4
	// Position of DEV_13 field.
	SCT_DMAREQ1_DEV_13_Pos = 0x3
	// Bit mask of DEV_13 field.
	SCT_DMAREQ1_DEV_13_Msk = 0x8
	// Bit DEV_13.
	SCT_DMAREQ1_DEV_13 = 0x8
	// Position of DEV_14 field.
	SCT_DMAREQ1_DEV_14_Pos = 0x4
	// Bit mask of DEV_14 field.
	SCT_DMAREQ1_DEV_14_Msk = 0x10
	// Bit DEV_14.
	SCT_DMAREQ1_DEV_14 = 0x10
	// Position of DEV_15 field.
	SCT_DMAREQ1_DEV_15_Pos = 0x5
	// Bit mask of DEV_15 field.
	SCT_DMAREQ1_DEV_15_Msk = 0x20
	// Bit DEV_15.
	SCT_DMAREQ1_DEV_15 = 0x20
	// Position of DEV_16 field.
	SCT_DMAREQ1_DEV_16_Pos = 0x6
	// Bit mask of DEV_16 field.
	SCT_DMAREQ1_DEV_16_Msk = 0x40
	// Bit DEV_16.
	SCT_DMAREQ1_DEV_16 = 0x40
	// Position of DEV_17 field.
	SCT_DMAREQ1_DEV_17_Pos = 0x7
	// Bit mask of DEV_17 field.
	SCT_DMAREQ1_DEV_17_Msk = 0x80
	// Bit DEV_17.
	SCT_DMAREQ1_DEV_17 = 0x80
	// Position of DEV_18 field.
	SCT_DMAREQ1_DEV_18_Pos = 0x8
	// Bit mask of DEV_18 field.
	SCT_DMAREQ1_DEV_18_Msk = 0x100
	// Bit DEV_18.
	SCT_DMAREQ1_DEV_18 = 0x100
	// Position of DEV_19 field.
	SCT_DMAREQ1_DEV_19_Pos = 0x9
	// Bit mask of DEV_19 field.
	SCT_DMAREQ1_DEV_19_Msk = 0x200
	// Bit DEV_19.
	SCT_DMAREQ1_DEV_19 = 0x200
	// Position of DEV_110 field.
	SCT_DMAREQ1_DEV_110_Pos = 0xa
	// Bit mask of DEV_110 field.
	SCT_DMAREQ1_DEV_110_Msk = 0x400
	// Bit DEV_110.
	SCT_DMAREQ1_DEV_110 = 0x400
	// Position of DEV_111 field.
	SCT_DMAREQ1_DEV_111_Pos = 0xb
	// Bit mask of DEV_111 field.
	SCT_DMAREQ1_DEV_111_Msk = 0x800
	// Bit DEV_111.
	SCT_DMAREQ1_DEV_111 = 0x800
	// Position of DEV_112 field.
	SCT_DMAREQ1_DEV_112_Pos = 0xc
	// Bit mask of DEV_112 field.
	SCT_DMAREQ1_DEV_112_Msk = 0x1000
	// Bit DEV_112.
	SCT_DMAREQ1_DEV_112 = 0x1000
	// Position of DEV_113 field.
	SCT_DMAREQ1_DEV_113_Pos = 0xd
	// Bit mask of DEV_113 field.
	SCT_DMAREQ1_DEV_113_Msk = 0x2000
	// Bit DEV_113.
	SCT_DMAREQ1_DEV_113 = 0x2000
	// Position of DEV_114 field.
	SCT_DMAREQ1_DEV_114_Pos = 0xe
	// Bit mask of DEV_114 field.
	SCT_DMAREQ1_DEV_114_Msk = 0x4000
	// Bit DEV_114.
	SCT_DMAREQ1_DEV_114 = 0x4000
	// Position of DEV_115 field.
	SCT_DMAREQ1_DEV_115_Pos = 0xf
	// Bit mask of DEV_115 field.
	SCT_DMAREQ1_DEV_115_Msk = 0x8000
	// Bit DEV_115.
	SCT_DMAREQ1_DEV_115 = 0x8000
	// Position of RESERVED field.
	SCT_DMAREQ1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCT_DMAREQ1_RESERVED_Msk = 0x3fff0000
	// Position of DRL1 field.
	SCT_DMAREQ1_DRL1_Pos = 0x1e
	// Bit mask of DRL1 field.
	SCT_DMAREQ1_DRL1_Msk = 0x40000000
	// Bit DRL1.
	SCT_DMAREQ1_DRL1 = 0x40000000
	// Position of DRQ1 field.
	SCT_DMAREQ1_DRQ1_Pos = 0x1f
	// Bit mask of DRQ1 field.
	SCT_DMAREQ1_DRQ1_Msk = 0x80000000
	// Bit DRQ1.
	SCT_DMAREQ1_DRQ1 = 0x80000000

	// EVEN: SCT event enable register
	// Position of IEN0 field.
	SCT_EVEN_IEN0_Pos = 0x0
	// Bit mask of IEN0 field.
	SCT_EVEN_IEN0_Msk = 0x1
	// Bit IEN0.
	SCT_EVEN_IEN0 = 0x1
	// Position of IEN1 field.
	SCT_EVEN_IEN1_Pos = 0x1
	// Bit mask of IEN1 field.
	SCT_EVEN_IEN1_Msk = 0x2
	// Bit IEN1.
	SCT_EVEN_IEN1 = 0x2
	// Position of IEN2 field.
	SCT_EVEN_IEN2_Pos = 0x2
	// Bit mask of IEN2 field.
	SCT_EVEN_IEN2_Msk = 0x4
	// Bit IEN2.
	SCT_EVEN_IEN2 = 0x4
	// Position of IEN3 field.
	SCT_EVEN_IEN3_Pos = 0x3
	// Bit mask of IEN3 field.
	SCT_EVEN_IEN3_Msk = 0x8
	// Bit IEN3.
	SCT_EVEN_IEN3 = 0x8
	// Position of IEN4 field.
	SCT_EVEN_IEN4_Pos = 0x4
	// Bit mask of IEN4 field.
	SCT_EVEN_IEN4_Msk = 0x10
	// Bit IEN4.
	SCT_EVEN_IEN4 = 0x10
	// Position of IEN5 field.
	SCT_EVEN_IEN5_Pos = 0x5
	// Bit mask of IEN5 field.
	SCT_EVEN_IEN5_Msk = 0x20
	// Bit IEN5.
	SCT_EVEN_IEN5 = 0x20
	// Position of IEN6 field.
	SCT_EVEN_IEN6_Pos = 0x6
	// Bit mask of IEN6 field.
	SCT_EVEN_IEN6_Msk = 0x40
	// Bit IEN6.
	SCT_EVEN_IEN6 = 0x40
	// Position of IEN7 field.
	SCT_EVEN_IEN7_Pos = 0x7
	// Bit mask of IEN7 field.
	SCT_EVEN_IEN7_Msk = 0x80
	// Bit IEN7.
	SCT_EVEN_IEN7 = 0x80
	// Position of IEN8 field.
	SCT_EVEN_IEN8_Pos = 0x8
	// Bit mask of IEN8 field.
	SCT_EVEN_IEN8_Msk = 0x100
	// Bit IEN8.
	SCT_EVEN_IEN8 = 0x100
	// Position of IEN9 field.
	SCT_EVEN_IEN9_Pos = 0x9
	// Bit mask of IEN9 field.
	SCT_EVEN_IEN9_Msk = 0x200
	// Bit IEN9.
	SCT_EVEN_IEN9 = 0x200
	// Position of IEN10 field.
	SCT_EVEN_IEN10_Pos = 0xa
	// Bit mask of IEN10 field.
	SCT_EVEN_IEN10_Msk = 0x400
	// Bit IEN10.
	SCT_EVEN_IEN10 = 0x400
	// Position of IEN11 field.
	SCT_EVEN_IEN11_Pos = 0xb
	// Bit mask of IEN11 field.
	SCT_EVEN_IEN11_Msk = 0x800
	// Bit IEN11.
	SCT_EVEN_IEN11 = 0x800
	// Position of IEN12 field.
	SCT_EVEN_IEN12_Pos = 0xc
	// Bit mask of IEN12 field.
	SCT_EVEN_IEN12_Msk = 0x1000
	// Bit IEN12.
	SCT_EVEN_IEN12 = 0x1000
	// Position of IEN13 field.
	SCT_EVEN_IEN13_Pos = 0xd
	// Bit mask of IEN13 field.
	SCT_EVEN_IEN13_Msk = 0x2000
	// Bit IEN13.
	SCT_EVEN_IEN13 = 0x2000
	// Position of IEN14 field.
	SCT_EVEN_IEN14_Pos = 0xe
	// Bit mask of IEN14 field.
	SCT_EVEN_IEN14_Msk = 0x4000
	// Bit IEN14.
	SCT_EVEN_IEN14 = 0x4000
	// Position of IEN15 field.
	SCT_EVEN_IEN15_Pos = 0xf
	// Bit mask of IEN15 field.
	SCT_EVEN_IEN15_Msk = 0x8000
	// Bit IEN15.
	SCT_EVEN_IEN15 = 0x8000
	// Position of RESERVED field.
	SCT_EVEN_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCT_EVEN_RESERVED_Msk = 0xffff0000

	// EVFLAG: SCT event flag register
	// Position of FLAG0 field.
	SCT_EVFLAG_FLAG0_Pos = 0x0
	// Bit mask of FLAG0 field.
	SCT_EVFLAG_FLAG0_Msk = 0x1
	// Bit FLAG0.
	SCT_EVFLAG_FLAG0 = 0x1
	// Position of FLAG1 field.
	SCT_EVFLAG_FLAG1_Pos = 0x1
	// Bit mask of FLAG1 field.
	SCT_EVFLAG_FLAG1_Msk = 0x2
	// Bit FLAG1.
	SCT_EVFLAG_FLAG1 = 0x2
	// Position of FLAG2 field.
	SCT_EVFLAG_FLAG2_Pos = 0x2
	// Bit mask of FLAG2 field.
	SCT_EVFLAG_FLAG2_Msk = 0x4
	// Bit FLAG2.
	SCT_EVFLAG_FLAG2 = 0x4
	// Position of FLAG3 field.
	SCT_EVFLAG_FLAG3_Pos = 0x3
	// Bit mask of FLAG3 field.
	SCT_EVFLAG_FLAG3_Msk = 0x8
	// Bit FLAG3.
	SCT_EVFLAG_FLAG3 = 0x8
	// Position of FLAG4 field.
	SCT_EVFLAG_FLAG4_Pos = 0x4
	// Bit mask of FLAG4 field.
	SCT_EVFLAG_FLAG4_Msk = 0x10
	// Bit FLAG4.
	SCT_EVFLAG_FLAG4 = 0x10
	// Position of FLAG5 field.
	SCT_EVFLAG_FLAG5_Pos = 0x5
	// Bit mask of FLAG5 field.
	SCT_EVFLAG_FLAG5_Msk = 0x20
	// Bit FLAG5.
	SCT_EVFLAG_FLAG5 = 0x20
	// Position of FLAG6 field.
	SCT_EVFLAG_FLAG6_Pos = 0x6
	// Bit mask of FLAG6 field.
	SCT_EVFLAG_FLAG6_Msk = 0x40
	// Bit FLAG6.
	SCT_EVFLAG_FLAG6 = 0x40
	// Position of FLAG7 field.
	SCT_EVFLAG_FLAG7_Pos = 0x7
	// Bit mask of FLAG7 field.
	SCT_EVFLAG_FLAG7_Msk = 0x80
	// Bit FLAG7.
	SCT_EVFLAG_FLAG7 = 0x80
	// Position of FLAG8 field.
	SCT_EVFLAG_FLAG8_Pos = 0x8
	// Bit mask of FLAG8 field.
	SCT_EVFLAG_FLAG8_Msk = 0x100
	// Bit FLAG8.
	SCT_EVFLAG_FLAG8 = 0x100
	// Position of FLAG9 field.
	SCT_EVFLAG_FLAG9_Pos = 0x9
	// Bit mask of FLAG9 field.
	SCT_EVFLAG_FLAG9_Msk = 0x200
	// Bit FLAG9.
	SCT_EVFLAG_FLAG9 = 0x200
	// Position of FLAG10 field.
	SCT_EVFLAG_FLAG10_Pos = 0xa
	// Bit mask of FLAG10 field.
	SCT_EVFLAG_FLAG10_Msk = 0x400
	// Bit FLAG10.
	SCT_EVFLAG_FLAG10 = 0x400
	// Position of FLAG11 field.
	SCT_EVFLAG_FLAG11_Pos = 0xb
	// Bit mask of FLAG11 field.
	SCT_EVFLAG_FLAG11_Msk = 0x800
	// Bit FLAG11.
	SCT_EVFLAG_FLAG11 = 0x800
	// Position of FLAG12 field.
	SCT_EVFLAG_FLAG12_Pos = 0xc
	// Bit mask of FLAG12 field.
	SCT_EVFLAG_FLAG12_Msk = 0x1000
	// Bit FLAG12.
	SCT_EVFLAG_FLAG12 = 0x1000
	// Position of FLAG13 field.
	SCT_EVFLAG_FLAG13_Pos = 0xd
	// Bit mask of FLAG13 field.
	SCT_EVFLAG_FLAG13_Msk = 0x2000
	// Bit FLAG13.
	SCT_EVFLAG_FLAG13 = 0x2000
	// Position of FLAG14 field.
	SCT_EVFLAG_FLAG14_Pos = 0xe
	// Bit mask of FLAG14 field.
	SCT_EVFLAG_FLAG14_Msk = 0x4000
	// Bit FLAG14.
	SCT_EVFLAG_FLAG14 = 0x4000
	// Position of FLAG15 field.
	SCT_EVFLAG_FLAG15_Pos = 0xf
	// Bit mask of FLAG15 field.
	SCT_EVFLAG_FLAG15_Msk = 0x8000
	// Bit FLAG15.
	SCT_EVFLAG_FLAG15 = 0x8000
	// Position of RESERVED field.
	SCT_EVFLAG_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCT_EVFLAG_RESERVED_Msk = 0xffff0000

	// CONEN: SCT conflict enable register
	// Position of NCEN0 field.
	SCT_CONEN_NCEN0_Pos = 0x0
	// Bit mask of NCEN0 field.
	SCT_CONEN_NCEN0_Msk = 0x1
	// Bit NCEN0.
	SCT_CONEN_NCEN0 = 0x1
	// Position of NCEN1 field.
	SCT_CONEN_NCEN1_Pos = 0x1
	// Bit mask of NCEN1 field.
	SCT_CONEN_NCEN1_Msk = 0x2
	// Bit NCEN1.
	SCT_CONEN_NCEN1 = 0x2
	// Position of NCEN2 field.
	SCT_CONEN_NCEN2_Pos = 0x2
	// Bit mask of NCEN2 field.
	SCT_CONEN_NCEN2_Msk = 0x4
	// Bit NCEN2.
	SCT_CONEN_NCEN2 = 0x4
	// Position of NCEN3 field.
	SCT_CONEN_NCEN3_Pos = 0x3
	// Bit mask of NCEN3 field.
	SCT_CONEN_NCEN3_Msk = 0x8
	// Bit NCEN3.
	SCT_CONEN_NCEN3 = 0x8
	// Position of NCEN4 field.
	SCT_CONEN_NCEN4_Pos = 0x4
	// Bit mask of NCEN4 field.
	SCT_CONEN_NCEN4_Msk = 0x10
	// Bit NCEN4.
	SCT_CONEN_NCEN4 = 0x10
	// Position of NCEN5 field.
	SCT_CONEN_NCEN5_Pos = 0x5
	// Bit mask of NCEN5 field.
	SCT_CONEN_NCEN5_Msk = 0x20
	// Bit NCEN5.
	SCT_CONEN_NCEN5 = 0x20
	// Position of NCEN6 field.
	SCT_CONEN_NCEN6_Pos = 0x6
	// Bit mask of NCEN6 field.
	SCT_CONEN_NCEN6_Msk = 0x40
	// Bit NCEN6.
	SCT_CONEN_NCEN6 = 0x40
	// Position of NCEN7 field.
	SCT_CONEN_NCEN7_Pos = 0x7
	// Bit mask of NCEN7 field.
	SCT_CONEN_NCEN7_Msk = 0x80
	// Bit NCEN7.
	SCT_CONEN_NCEN7 = 0x80
	// Position of NCEN8 field.
	SCT_CONEN_NCEN8_Pos = 0x8
	// Bit mask of NCEN8 field.
	SCT_CONEN_NCEN8_Msk = 0x100
	// Bit NCEN8.
	SCT_CONEN_NCEN8 = 0x100
	// Position of NCEN9 field.
	SCT_CONEN_NCEN9_Pos = 0x9
	// Bit mask of NCEN9 field.
	SCT_CONEN_NCEN9_Msk = 0x200
	// Bit NCEN9.
	SCT_CONEN_NCEN9 = 0x200
	// Position of NCEN10 field.
	SCT_CONEN_NCEN10_Pos = 0xa
	// Bit mask of NCEN10 field.
	SCT_CONEN_NCEN10_Msk = 0x400
	// Bit NCEN10.
	SCT_CONEN_NCEN10 = 0x400
	// Position of NCEN11 field.
	SCT_CONEN_NCEN11_Pos = 0xb
	// Bit mask of NCEN11 field.
	SCT_CONEN_NCEN11_Msk = 0x800
	// Bit NCEN11.
	SCT_CONEN_NCEN11 = 0x800
	// Position of NCEN12 field.
	SCT_CONEN_NCEN12_Pos = 0xc
	// Bit mask of NCEN12 field.
	SCT_CONEN_NCEN12_Msk = 0x1000
	// Bit NCEN12.
	SCT_CONEN_NCEN12 = 0x1000
	// Position of NCEN13 field.
	SCT_CONEN_NCEN13_Pos = 0xd
	// Bit mask of NCEN13 field.
	SCT_CONEN_NCEN13_Msk = 0x2000
	// Bit NCEN13.
	SCT_CONEN_NCEN13 = 0x2000
	// Position of NCEN14 field.
	SCT_CONEN_NCEN14_Pos = 0xe
	// Bit mask of NCEN14 field.
	SCT_CONEN_NCEN14_Msk = 0x4000
	// Bit NCEN14.
	SCT_CONEN_NCEN14 = 0x4000
	// Position of NCEN15 field.
	SCT_CONEN_NCEN15_Pos = 0xf
	// Bit mask of NCEN15 field.
	SCT_CONEN_NCEN15_Msk = 0x8000
	// Bit NCEN15.
	SCT_CONEN_NCEN15 = 0x8000
	// Position of RESERVED field.
	SCT_CONEN_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCT_CONEN_RESERVED_Msk = 0xffff0000

	// CONFLAG: SCT conflict flag register
	// Position of NCFLAG0 field.
	SCT_CONFLAG_NCFLAG0_Pos = 0x0
	// Bit mask of NCFLAG0 field.
	SCT_CONFLAG_NCFLAG0_Msk = 0x1
	// Bit NCFLAG0.
	SCT_CONFLAG_NCFLAG0 = 0x1
	// Position of NCFLAG1 field.
	SCT_CONFLAG_NCFLAG1_Pos = 0x1
	// Bit mask of NCFLAG1 field.
	SCT_CONFLAG_NCFLAG1_Msk = 0x2
	// Bit NCFLAG1.
	SCT_CONFLAG_NCFLAG1 = 0x2
	// Position of NCFLAG2 field.
	SCT_CONFLAG_NCFLAG2_Pos = 0x2
	// Bit mask of NCFLAG2 field.
	SCT_CONFLAG_NCFLAG2_Msk = 0x4
	// Bit NCFLAG2.
	SCT_CONFLAG_NCFLAG2 = 0x4
	// Position of NCFLAG3 field.
	SCT_CONFLAG_NCFLAG3_Pos = 0x3
	// Bit mask of NCFLAG3 field.
	SCT_CONFLAG_NCFLAG3_Msk = 0x8
	// Bit NCFLAG3.
	SCT_CONFLAG_NCFLAG3 = 0x8
	// Position of NCFLAG4 field.
	SCT_CONFLAG_NCFLAG4_Pos = 0x4
	// Bit mask of NCFLAG4 field.
	SCT_CONFLAG_NCFLAG4_Msk = 0x10
	// Bit NCFLAG4.
	SCT_CONFLAG_NCFLAG4 = 0x10
	// Position of NCFLAG5 field.
	SCT_CONFLAG_NCFLAG5_Pos = 0x5
	// Bit mask of NCFLAG5 field.
	SCT_CONFLAG_NCFLAG5_Msk = 0x20
	// Bit NCFLAG5.
	SCT_CONFLAG_NCFLAG5 = 0x20
	// Position of NCFLAG6 field.
	SCT_CONFLAG_NCFLAG6_Pos = 0x6
	// Bit mask of NCFLAG6 field.
	SCT_CONFLAG_NCFLAG6_Msk = 0x40
	// Bit NCFLAG6.
	SCT_CONFLAG_NCFLAG6 = 0x40
	// Position of NCFLAG7 field.
	SCT_CONFLAG_NCFLAG7_Pos = 0x7
	// Bit mask of NCFLAG7 field.
	SCT_CONFLAG_NCFLAG7_Msk = 0x80
	// Bit NCFLAG7.
	SCT_CONFLAG_NCFLAG7 = 0x80
	// Position of NCFLAG8 field.
	SCT_CONFLAG_NCFLAG8_Pos = 0x8
	// Bit mask of NCFLAG8 field.
	SCT_CONFLAG_NCFLAG8_Msk = 0x100
	// Bit NCFLAG8.
	SCT_CONFLAG_NCFLAG8 = 0x100
	// Position of NCFLAG9 field.
	SCT_CONFLAG_NCFLAG9_Pos = 0x9
	// Bit mask of NCFLAG9 field.
	SCT_CONFLAG_NCFLAG9_Msk = 0x200
	// Bit NCFLAG9.
	SCT_CONFLAG_NCFLAG9 = 0x200
	// Position of NCFLAG10 field.
	SCT_CONFLAG_NCFLAG10_Pos = 0xa
	// Bit mask of NCFLAG10 field.
	SCT_CONFLAG_NCFLAG10_Msk = 0x400
	// Bit NCFLAG10.
	SCT_CONFLAG_NCFLAG10 = 0x400
	// Position of NCFLAG11 field.
	SCT_CONFLAG_NCFLAG11_Pos = 0xb
	// Bit mask of NCFLAG11 field.
	SCT_CONFLAG_NCFLAG11_Msk = 0x800
	// Bit NCFLAG11.
	SCT_CONFLAG_NCFLAG11 = 0x800
	// Position of NCFLAG12 field.
	SCT_CONFLAG_NCFLAG12_Pos = 0xc
	// Bit mask of NCFLAG12 field.
	SCT_CONFLAG_NCFLAG12_Msk = 0x1000
	// Bit NCFLAG12.
	SCT_CONFLAG_NCFLAG12 = 0x1000
	// Position of NCFLAG13 field.
	SCT_CONFLAG_NCFLAG13_Pos = 0xd
	// Bit mask of NCFLAG13 field.
	SCT_CONFLAG_NCFLAG13_Msk = 0x2000
	// Bit NCFLAG13.
	SCT_CONFLAG_NCFLAG13 = 0x2000
	// Position of NCFLAG14 field.
	SCT_CONFLAG_NCFLAG14_Pos = 0xe
	// Bit mask of NCFLAG14 field.
	SCT_CONFLAG_NCFLAG14_Msk = 0x4000
	// Bit NCFLAG14.
	SCT_CONFLAG_NCFLAG14 = 0x4000
	// Position of NCFLAG15 field.
	SCT_CONFLAG_NCFLAG15_Pos = 0xf
	// Bit mask of NCFLAG15 field.
	SCT_CONFLAG_NCFLAG15_Msk = 0x8000
	// Bit NCFLAG15.
	SCT_CONFLAG_NCFLAG15 = 0x8000
	// Position of RESERVED field.
	SCT_CONFLAG_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCT_CONFLAG_RESERVED_Msk = 0x3fff0000
	// Position of BUSERRL field.
	SCT_CONFLAG_BUSERRL_Pos = 0x1e
	// Bit mask of BUSERRL field.
	SCT_CONFLAG_BUSERRL_Msk = 0x40000000
	// Bit BUSERRL.
	SCT_CONFLAG_BUSERRL = 0x40000000
	// Position of BUSERRH field.
	SCT_CONFLAG_BUSERRH_Pos = 0x1f
	// Bit mask of BUSERRH field.
	SCT_CONFLAG_BUSERRH_Msk = 0x80000000
	// Bit BUSERRH.
	SCT_CONFLAG_BUSERRH = 0x80000000

	// MATCH0: SCT match value register of match channels 0 to 15; REGMOD0 to REGMODE15 = 0
	// Position of MATCH_L field.
	SCT_MATCH_MATCH_L_Pos = 0x0
	// Bit mask of MATCH_L field.
	SCT_MATCH_MATCH_L_Msk = 0xffff
	// Position of MATCH_H field.
	SCT_MATCH_MATCH_H_Pos = 0x10
	// Bit mask of MATCH_H field.
	SCT_MATCH_MATCH_H_Msk = 0xffff0000

	// CAP0: SCT capture register of capture channel 0 to 15; REGMOD0 to REGMODE15 = 1
	// Position of CAP_L field.
	SCT_CAP_CAP_L_Pos = 0x0
	// Bit mask of CAP_L field.
	SCT_CAP_CAP_L_Msk = 0xffff
	// Position of CAP_H field.
	SCT_CAP_CAP_H_Pos = 0x10
	// Bit mask of CAP_H field.
	SCT_CAP_CAP_H_Msk = 0xffff0000

	// FRACMAT0: Fractional match registers 0 to 5 for SCT match value registers 0 to 5.
	// Position of FRACMAT_L field.
	SCT_FRACMAT_FRACMAT_L_Pos = 0x0
	// Bit mask of FRACMAT_L field.
	SCT_FRACMAT_FRACMAT_L_Msk = 0xf
	// Position of RESERVED field.
	SCT_FRACMAT_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SCT_FRACMAT_RESERVED_Msk = 0xfff0
	// Position of FRACMAT_H field.
	SCT_FRACMAT_FRACMAT_H_Pos = 0x10
	// Bit mask of FRACMAT_H field.
	SCT_FRACMAT_FRACMAT_H_Msk = 0xf0000
	// Position of RESERVED field.
	SCT_FRACMAT_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	SCT_FRACMAT_RESERVED_Msk = 0xfff00000

	// MATCHREL0: SCT match reload value register 0 to 15; REGMOD0 = 0 to REGMODE15 = 0
	// Position of RELOAD_L field.
	SCT_MATCHREL_RELOAD_L_Pos = 0x0
	// Bit mask of RELOAD_L field.
	SCT_MATCHREL_RELOAD_L_Msk = 0xffff
	// Position of RELOAD_H field.
	SCT_MATCHREL_RELOAD_H_Pos = 0x10
	// Bit mask of RELOAD_H field.
	SCT_MATCHREL_RELOAD_H_Msk = 0xffff0000

	// CAPCTRL0: SCT capture control register 0 to 15; REGMOD0 = 1 to REGMODE15 = 1
	// Position of CAPCON_L field.
	SCT_CAPCTRL_CAPCON_L_Pos = 0x0
	// Bit mask of CAPCON_L field.
	SCT_CAPCTRL_CAPCON_L_Msk = 0xffff
	// Position of CAPCON_H field.
	SCT_CAPCTRL_CAPCON_H_Pos = 0x10
	// Bit mask of CAPCON_H field.
	SCT_CAPCTRL_CAPCON_H_Msk = 0xffff0000

	// FRACMATREL0: Fractional match reload registers 0 to 5 for SCT match value registers 0 to 5.
	// Position of RELFRAC_L field.
	SCT_FRACMATREL_RELFRAC_L_Pos = 0x0
	// Bit mask of RELFRAC_L field.
	SCT_FRACMATREL_RELFRAC_L_Msk = 0xf
	// Position of RESERVED field.
	SCT_FRACMATREL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SCT_FRACMATREL_RESERVED_Msk = 0xfff0
	// Position of RELFRAC_H field.
	SCT_FRACMATREL_RELFRAC_H_Pos = 0x10
	// Bit mask of RELFRAC_H field.
	SCT_FRACMATREL_RELFRAC_H_Msk = 0xf0000
	// Position of RESERVED field.
	SCT_FRACMATREL_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	SCT_FRACMATREL_RESERVED_Msk = 0xfff00000

	// EV0_STATE: SCT event state register 0
	// Position of STATEMSK0 field.
	SCT_EV_STATE_STATEMSK0_Pos = 0x0
	// Bit mask of STATEMSK0 field.
	SCT_EV_STATE_STATEMSK0_Msk = 0x1
	// Bit STATEMSK0.
	SCT_EV_STATE_STATEMSK0 = 0x1
	// Position of STATEMSK1 field.
	SCT_EV_STATE_STATEMSK1_Pos = 0x1
	// Bit mask of STATEMSK1 field.
	SCT_EV_STATE_STATEMSK1_Msk = 0x2
	// Bit STATEMSK1.
	SCT_EV_STATE_STATEMSK1 = 0x2
	// Position of STATEMSK2 field.
	SCT_EV_STATE_STATEMSK2_Pos = 0x2
	// Bit mask of STATEMSK2 field.
	SCT_EV_STATE_STATEMSK2_Msk = 0x4
	// Bit STATEMSK2.
	SCT_EV_STATE_STATEMSK2 = 0x4
	// Position of STATEMSK3 field.
	SCT_EV_STATE_STATEMSK3_Pos = 0x3
	// Bit mask of STATEMSK3 field.
	SCT_EV_STATE_STATEMSK3_Msk = 0x8
	// Bit STATEMSK3.
	SCT_EV_STATE_STATEMSK3 = 0x8
	// Position of STATEMSK4 field.
	SCT_EV_STATE_STATEMSK4_Pos = 0x4
	// Bit mask of STATEMSK4 field.
	SCT_EV_STATE_STATEMSK4_Msk = 0x10
	// Bit STATEMSK4.
	SCT_EV_STATE_STATEMSK4 = 0x10
	// Position of STATEMSK5 field.
	SCT_EV_STATE_STATEMSK5_Pos = 0x5
	// Bit mask of STATEMSK5 field.
	SCT_EV_STATE_STATEMSK5_Msk = 0x20
	// Bit STATEMSK5.
	SCT_EV_STATE_STATEMSK5 = 0x20
	// Position of STATEMSK6 field.
	SCT_EV_STATE_STATEMSK6_Pos = 0x6
	// Bit mask of STATEMSK6 field.
	SCT_EV_STATE_STATEMSK6_Msk = 0x40
	// Bit STATEMSK6.
	SCT_EV_STATE_STATEMSK6 = 0x40
	// Position of STATEMSK7 field.
	SCT_EV_STATE_STATEMSK7_Pos = 0x7
	// Bit mask of STATEMSK7 field.
	SCT_EV_STATE_STATEMSK7_Msk = 0x80
	// Bit STATEMSK7.
	SCT_EV_STATE_STATEMSK7 = 0x80
	// Position of STATEMSK8 field.
	SCT_EV_STATE_STATEMSK8_Pos = 0x8
	// Bit mask of STATEMSK8 field.
	SCT_EV_STATE_STATEMSK8_Msk = 0x100
	// Bit STATEMSK8.
	SCT_EV_STATE_STATEMSK8 = 0x100
	// Position of STATEMSK9 field.
	SCT_EV_STATE_STATEMSK9_Pos = 0x9
	// Bit mask of STATEMSK9 field.
	SCT_EV_STATE_STATEMSK9_Msk = 0x200
	// Bit STATEMSK9.
	SCT_EV_STATE_STATEMSK9 = 0x200
	// Position of STATEMSK10 field.
	SCT_EV_STATE_STATEMSK10_Pos = 0xa
	// Bit mask of STATEMSK10 field.
	SCT_EV_STATE_STATEMSK10_Msk = 0x400
	// Bit STATEMSK10.
	SCT_EV_STATE_STATEMSK10 = 0x400
	// Position of STATEMSK11 field.
	SCT_EV_STATE_STATEMSK11_Pos = 0xb
	// Bit mask of STATEMSK11 field.
	SCT_EV_STATE_STATEMSK11_Msk = 0x800
	// Bit STATEMSK11.
	SCT_EV_STATE_STATEMSK11 = 0x800
	// Position of STATEMSK12 field.
	SCT_EV_STATE_STATEMSK12_Pos = 0xc
	// Bit mask of STATEMSK12 field.
	SCT_EV_STATE_STATEMSK12_Msk = 0x1000
	// Bit STATEMSK12.
	SCT_EV_STATE_STATEMSK12 = 0x1000
	// Position of STATEMSK13 field.
	SCT_EV_STATE_STATEMSK13_Pos = 0xd
	// Bit mask of STATEMSK13 field.
	SCT_EV_STATE_STATEMSK13_Msk = 0x2000
	// Bit STATEMSK13.
	SCT_EV_STATE_STATEMSK13 = 0x2000
	// Position of STATEMSK14 field.
	SCT_EV_STATE_STATEMSK14_Pos = 0xe
	// Bit mask of STATEMSK14 field.
	SCT_EV_STATE_STATEMSK14_Msk = 0x4000
	// Bit STATEMSK14.
	SCT_EV_STATE_STATEMSK14 = 0x4000
	// Position of STATEMSK15 field.
	SCT_EV_STATE_STATEMSK15_Pos = 0xf
	// Bit mask of STATEMSK15 field.
	SCT_EV_STATE_STATEMSK15_Msk = 0x8000
	// Bit STATEMSK15.
	SCT_EV_STATE_STATEMSK15 = 0x8000
	// Position of STATEMSK16 field.
	SCT_EV_STATE_STATEMSK16_Pos = 0x10
	// Bit mask of STATEMSK16 field.
	SCT_EV_STATE_STATEMSK16_Msk = 0x10000
	// Bit STATEMSK16.
	SCT_EV_STATE_STATEMSK16 = 0x10000
	// Position of STATEMSK17 field.
	SCT_EV_STATE_STATEMSK17_Pos = 0x11
	// Bit mask of STATEMSK17 field.
	SCT_EV_STATE_STATEMSK17_Msk = 0x20000
	// Bit STATEMSK17.
	SCT_EV_STATE_STATEMSK17 = 0x20000
	// Position of STATEMSK18 field.
	SCT_EV_STATE_STATEMSK18_Pos = 0x12
	// Bit mask of STATEMSK18 field.
	SCT_EV_STATE_STATEMSK18_Msk = 0x40000
	// Bit STATEMSK18.
	SCT_EV_STATE_STATEMSK18 = 0x40000
	// Position of STATEMSK19 field.
	SCT_EV_STATE_STATEMSK19_Pos = 0x13
	// Bit mask of STATEMSK19 field.
	SCT_EV_STATE_STATEMSK19_Msk = 0x80000
	// Bit STATEMSK19.
	SCT_EV_STATE_STATEMSK19 = 0x80000
	// Position of STATEMSK20 field.
	SCT_EV_STATE_STATEMSK20_Pos = 0x14
	// Bit mask of STATEMSK20 field.
	SCT_EV_STATE_STATEMSK20_Msk = 0x100000
	// Bit STATEMSK20.
	SCT_EV_STATE_STATEMSK20 = 0x100000
	// Position of STATEMSK21 field.
	SCT_EV_STATE_STATEMSK21_Pos = 0x15
	// Bit mask of STATEMSK21 field.
	SCT_EV_STATE_STATEMSK21_Msk = 0x200000
	// Bit STATEMSK21.
	SCT_EV_STATE_STATEMSK21 = 0x200000
	// Position of STATEMSK22 field.
	SCT_EV_STATE_STATEMSK22_Pos = 0x16
	// Bit mask of STATEMSK22 field.
	SCT_EV_STATE_STATEMSK22_Msk = 0x400000
	// Bit STATEMSK22.
	SCT_EV_STATE_STATEMSK22 = 0x400000
	// Position of STATEMSK23 field.
	SCT_EV_STATE_STATEMSK23_Pos = 0x17
	// Bit mask of STATEMSK23 field.
	SCT_EV_STATE_STATEMSK23_Msk = 0x800000
	// Bit STATEMSK23.
	SCT_EV_STATE_STATEMSK23 = 0x800000
	// Position of STATEMSK24 field.
	SCT_EV_STATE_STATEMSK24_Pos = 0x18
	// Bit mask of STATEMSK24 field.
	SCT_EV_STATE_STATEMSK24_Msk = 0x1000000
	// Bit STATEMSK24.
	SCT_EV_STATE_STATEMSK24 = 0x1000000
	// Position of STATEMSK25 field.
	SCT_EV_STATE_STATEMSK25_Pos = 0x19
	// Bit mask of STATEMSK25 field.
	SCT_EV_STATE_STATEMSK25_Msk = 0x2000000
	// Bit STATEMSK25.
	SCT_EV_STATE_STATEMSK25 = 0x2000000
	// Position of STATEMSK26 field.
	SCT_EV_STATE_STATEMSK26_Pos = 0x1a
	// Bit mask of STATEMSK26 field.
	SCT_EV_STATE_STATEMSK26_Msk = 0x4000000
	// Bit STATEMSK26.
	SCT_EV_STATE_STATEMSK26 = 0x4000000
	// Position of STATEMSK27 field.
	SCT_EV_STATE_STATEMSK27_Pos = 0x1b
	// Bit mask of STATEMSK27 field.
	SCT_EV_STATE_STATEMSK27_Msk = 0x8000000
	// Bit STATEMSK27.
	SCT_EV_STATE_STATEMSK27 = 0x8000000
	// Position of STATEMSK28 field.
	SCT_EV_STATE_STATEMSK28_Pos = 0x1c
	// Bit mask of STATEMSK28 field.
	SCT_EV_STATE_STATEMSK28_Msk = 0x10000000
	// Bit STATEMSK28.
	SCT_EV_STATE_STATEMSK28 = 0x10000000
	// Position of STATEMSK29 field.
	SCT_EV_STATE_STATEMSK29_Pos = 0x1d
	// Bit mask of STATEMSK29 field.
	SCT_EV_STATE_STATEMSK29_Msk = 0x20000000
	// Bit STATEMSK29.
	SCT_EV_STATE_STATEMSK29 = 0x20000000
	// Position of STATEMSK30 field.
	SCT_EV_STATE_STATEMSK30_Pos = 0x1e
	// Bit mask of STATEMSK30 field.
	SCT_EV_STATE_STATEMSK30_Msk = 0x40000000
	// Bit STATEMSK30.
	SCT_EV_STATE_STATEMSK30 = 0x40000000
	// Position of STATEMSK31 field.
	SCT_EV_STATE_STATEMSK31_Pos = 0x1f
	// Bit mask of STATEMSK31 field.
	SCT_EV_STATE_STATEMSK31_Msk = 0x80000000
	// Bit STATEMSK31.
	SCT_EV_STATE_STATEMSK31 = 0x80000000

	// EV0_CTRL: SCT event control register 0
	// Position of MATCHSEL field.
	SCT_EV_CTRL_MATCHSEL_Pos = 0x0
	// Bit mask of MATCHSEL field.
	SCT_EV_CTRL_MATCHSEL_Msk = 0xf
	// Position of HEVENT field.
	SCT_EV_CTRL_HEVENT_Pos = 0x4
	// Bit mask of HEVENT field.
	SCT_EV_CTRL_HEVENT_Msk = 0x10
	// Bit HEVENT.
	SCT_EV_CTRL_HEVENT = 0x10
	// L state. Selects the L state and the L match register selected by MATCHSEL.
	SCT_EV_CTRL_HEVENT_L_STATE = 0x0
	// H state. Selects the H state and the H match register selected by MATCHSEL.
	SCT_EV_CTRL_HEVENT_H_STATE = 0x1
	// Position of OUTSEL field.
	SCT_EV_CTRL_OUTSEL_Pos = 0x5
	// Bit mask of OUTSEL field.
	SCT_EV_CTRL_OUTSEL_Msk = 0x20
	// Bit OUTSEL.
	SCT_EV_CTRL_OUTSEL = 0x20
	// Input. Selects the input selected by IOSEL.
	SCT_EV_CTRL_OUTSEL_INPUT = 0x0
	// Output. Selects the output selected by IOSEL.
	SCT_EV_CTRL_OUTSEL_OUTPUT = 0x1
	// Position of IOSEL field.
	SCT_EV_CTRL_IOSEL_Pos = 0x6
	// Bit mask of IOSEL field.
	SCT_EV_CTRL_IOSEL_Msk = 0x3c0
	// Position of IOCOND field.
	SCT_EV_CTRL_IOCOND_Pos = 0xa
	// Bit mask of IOCOND field.
	SCT_EV_CTRL_IOCOND_Msk = 0xc00
	// LOW
	SCT_EV_CTRL_IOCOND_LOW = 0x0
	// Rise
	SCT_EV_CTRL_IOCOND_RISE = 0x1
	// Fall
	SCT_EV_CTRL_IOCOND_FALL = 0x2
	// HIGH
	SCT_EV_CTRL_IOCOND_HIGH = 0x3
	// Position of COMBMODE field.
	SCT_EV_CTRL_COMBMODE_Pos = 0xc
	// Bit mask of COMBMODE field.
	SCT_EV_CTRL_COMBMODE_Msk = 0x3000
	// OR. The event occurs when either the specified match or I/O condition occurs.
	SCT_EV_CTRL_COMBMODE_OR = 0x0
	// MATCH. Uses the specified match only.
	SCT_EV_CTRL_COMBMODE_MATCH = 0x1
	// IO. Uses the specified I/O condition only.
	SCT_EV_CTRL_COMBMODE_IO = 0x2
	// AND. The event occurs when the specified match and I/O condition occur simultaneously.
	SCT_EV_CTRL_COMBMODE_AND = 0x3
	// Position of STATELD field.
	SCT_EV_CTRL_STATELD_Pos = 0xe
	// Bit mask of STATELD field.
	SCT_EV_CTRL_STATELD_Msk = 0x4000
	// Bit STATELD.
	SCT_EV_CTRL_STATELD = 0x4000
	// STATEV value is added into STATE (the carry-out is ignored).
	SCT_EV_CTRL_STATELD_STATEV_VALUE_IS_ADDE = 0x0
	// STATEV value is loaded into STATE.
	SCT_EV_CTRL_STATELD_STATEV_VALUE_IS_LOAD = 0x1
	// Position of STATEV field.
	SCT_EV_CTRL_STATEV_Pos = 0xf
	// Bit mask of STATEV field.
	SCT_EV_CTRL_STATEV_Msk = 0xf8000
	// Position of MATCHMEM field.
	SCT_EV_CTRL_MATCHMEM_Pos = 0x14
	// Bit mask of MATCHMEM field.
	SCT_EV_CTRL_MATCHMEM_Msk = 0x100000
	// Bit MATCHMEM.
	SCT_EV_CTRL_MATCHMEM = 0x100000
	// Position of DIRECTION field.
	SCT_EV_CTRL_DIRECTION_Pos = 0x15
	// Bit mask of DIRECTION field.
	SCT_EV_CTRL_DIRECTION_Msk = 0x600000
	// Direction independent. This event is triggered regardless of the count direction.
	SCT_EV_CTRL_DIRECTION_DIRECTION_INDEPENDEN = 0x0
	// Counting up. This event is triggered only during up-counting when BIDIR = 1.
	SCT_EV_CTRL_DIRECTION_COUNTING_UP = 0x1
	// Counting down. This event is triggered only during down-counting when BIDIR = 1.
	SCT_EV_CTRL_DIRECTION_COUNTING_DOWN = 0x2
	// Position of RESERVED field.
	SCT_EV_CTRL_RESERVED_Pos = 0x17
	// Bit mask of RESERVED field.
	SCT_EV_CTRL_RESERVED_Msk = 0xff800000

	// OUT0_SET: SCT output 0 set register
	// Position of SET0 field.
	SCT_OUT_SET_SET0_Pos = 0x0
	// Bit mask of SET0 field.
	SCT_OUT_SET_SET0_Msk = 0x1
	// Bit SET0.
	SCT_OUT_SET_SET0 = 0x1
	// Position of SET1 field.
	SCT_OUT_SET_SET1_Pos = 0x1
	// Bit mask of SET1 field.
	SCT_OUT_SET_SET1_Msk = 0x2
	// Bit SET1.
	SCT_OUT_SET_SET1 = 0x2
	// Position of SET2 field.
	SCT_OUT_SET_SET2_Pos = 0x2
	// Bit mask of SET2 field.
	SCT_OUT_SET_SET2_Msk = 0x4
	// Bit SET2.
	SCT_OUT_SET_SET2 = 0x4
	// Position of SET3 field.
	SCT_OUT_SET_SET3_Pos = 0x3
	// Bit mask of SET3 field.
	SCT_OUT_SET_SET3_Msk = 0x8
	// Bit SET3.
	SCT_OUT_SET_SET3 = 0x8
	// Position of SET4 field.
	SCT_OUT_SET_SET4_Pos = 0x4
	// Bit mask of SET4 field.
	SCT_OUT_SET_SET4_Msk = 0x10
	// Bit SET4.
	SCT_OUT_SET_SET4 = 0x10
	// Position of SET5 field.
	SCT_OUT_SET_SET5_Pos = 0x5
	// Bit mask of SET5 field.
	SCT_OUT_SET_SET5_Msk = 0x20
	// Bit SET5.
	SCT_OUT_SET_SET5 = 0x20
	// Position of SET6 field.
	SCT_OUT_SET_SET6_Pos = 0x6
	// Bit mask of SET6 field.
	SCT_OUT_SET_SET6_Msk = 0x40
	// Bit SET6.
	SCT_OUT_SET_SET6 = 0x40
	// Position of SET7 field.
	SCT_OUT_SET_SET7_Pos = 0x7
	// Bit mask of SET7 field.
	SCT_OUT_SET_SET7_Msk = 0x80
	// Bit SET7.
	SCT_OUT_SET_SET7 = 0x80
	// Position of SET8 field.
	SCT_OUT_SET_SET8_Pos = 0x8
	// Bit mask of SET8 field.
	SCT_OUT_SET_SET8_Msk = 0x100
	// Bit SET8.
	SCT_OUT_SET_SET8 = 0x100
	// Position of SET9 field.
	SCT_OUT_SET_SET9_Pos = 0x9
	// Bit mask of SET9 field.
	SCT_OUT_SET_SET9_Msk = 0x200
	// Bit SET9.
	SCT_OUT_SET_SET9 = 0x200
	// Position of SET10 field.
	SCT_OUT_SET_SET10_Pos = 0xa
	// Bit mask of SET10 field.
	SCT_OUT_SET_SET10_Msk = 0x400
	// Bit SET10.
	SCT_OUT_SET_SET10 = 0x400
	// Position of SET11 field.
	SCT_OUT_SET_SET11_Pos = 0xb
	// Bit mask of SET11 field.
	SCT_OUT_SET_SET11_Msk = 0x800
	// Bit SET11.
	SCT_OUT_SET_SET11 = 0x800
	// Position of SET12 field.
	SCT_OUT_SET_SET12_Pos = 0xc
	// Bit mask of SET12 field.
	SCT_OUT_SET_SET12_Msk = 0x1000
	// Bit SET12.
	SCT_OUT_SET_SET12 = 0x1000
	// Position of SET13 field.
	SCT_OUT_SET_SET13_Pos = 0xd
	// Bit mask of SET13 field.
	SCT_OUT_SET_SET13_Msk = 0x2000
	// Bit SET13.
	SCT_OUT_SET_SET13 = 0x2000
	// Position of SET14 field.
	SCT_OUT_SET_SET14_Pos = 0xe
	// Bit mask of SET14 field.
	SCT_OUT_SET_SET14_Msk = 0x4000
	// Bit SET14.
	SCT_OUT_SET_SET14 = 0x4000
	// Position of SET15 field.
	SCT_OUT_SET_SET15_Pos = 0xf
	// Bit mask of SET15 field.
	SCT_OUT_SET_SET15_Msk = 0x8000
	// Bit SET15.
	SCT_OUT_SET_SET15 = 0x8000
	// Position of RESERVED field.
	SCT_OUT_SET_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCT_OUT_SET_RESERVED_Msk = 0xffff0000

	// OUT0_CLR: SCT output 0 clear register
	// Position of CLR0 field.
	SCT_OUT_CLR_CLR0_Pos = 0x0
	// Bit mask of CLR0 field.
	SCT_OUT_CLR_CLR0_Msk = 0x1
	// Bit CLR0.
	SCT_OUT_CLR_CLR0 = 0x1
	// Position of CLR1 field.
	SCT_OUT_CLR_CLR1_Pos = 0x1
	// Bit mask of CLR1 field.
	SCT_OUT_CLR_CLR1_Msk = 0x2
	// Bit CLR1.
	SCT_OUT_CLR_CLR1 = 0x2
	// Position of CLR2 field.
	SCT_OUT_CLR_CLR2_Pos = 0x2
	// Bit mask of CLR2 field.
	SCT_OUT_CLR_CLR2_Msk = 0x4
	// Bit CLR2.
	SCT_OUT_CLR_CLR2 = 0x4
	// Position of CLR3 field.
	SCT_OUT_CLR_CLR3_Pos = 0x3
	// Bit mask of CLR3 field.
	SCT_OUT_CLR_CLR3_Msk = 0x8
	// Bit CLR3.
	SCT_OUT_CLR_CLR3 = 0x8
	// Position of CLR4 field.
	SCT_OUT_CLR_CLR4_Pos = 0x4
	// Bit mask of CLR4 field.
	SCT_OUT_CLR_CLR4_Msk = 0x10
	// Bit CLR4.
	SCT_OUT_CLR_CLR4 = 0x10
	// Position of CLR5 field.
	SCT_OUT_CLR_CLR5_Pos = 0x5
	// Bit mask of CLR5 field.
	SCT_OUT_CLR_CLR5_Msk = 0x20
	// Bit CLR5.
	SCT_OUT_CLR_CLR5 = 0x20
	// Position of CLR6 field.
	SCT_OUT_CLR_CLR6_Pos = 0x6
	// Bit mask of CLR6 field.
	SCT_OUT_CLR_CLR6_Msk = 0x40
	// Bit CLR6.
	SCT_OUT_CLR_CLR6 = 0x40
	// Position of CLR7 field.
	SCT_OUT_CLR_CLR7_Pos = 0x7
	// Bit mask of CLR7 field.
	SCT_OUT_CLR_CLR7_Msk = 0x80
	// Bit CLR7.
	SCT_OUT_CLR_CLR7 = 0x80
	// Position of CLR8 field.
	SCT_OUT_CLR_CLR8_Pos = 0x8
	// Bit mask of CLR8 field.
	SCT_OUT_CLR_CLR8_Msk = 0x100
	// Bit CLR8.
	SCT_OUT_CLR_CLR8 = 0x100
	// Position of CLR9 field.
	SCT_OUT_CLR_CLR9_Pos = 0x9
	// Bit mask of CLR9 field.
	SCT_OUT_CLR_CLR9_Msk = 0x200
	// Bit CLR9.
	SCT_OUT_CLR_CLR9 = 0x200
	// Position of CLR10 field.
	SCT_OUT_CLR_CLR10_Pos = 0xa
	// Bit mask of CLR10 field.
	SCT_OUT_CLR_CLR10_Msk = 0x400
	// Bit CLR10.
	SCT_OUT_CLR_CLR10 = 0x400
	// Position of CLR11 field.
	SCT_OUT_CLR_CLR11_Pos = 0xb
	// Bit mask of CLR11 field.
	SCT_OUT_CLR_CLR11_Msk = 0x800
	// Bit CLR11.
	SCT_OUT_CLR_CLR11 = 0x800
	// Position of CLR12 field.
	SCT_OUT_CLR_CLR12_Pos = 0xc
	// Bit mask of CLR12 field.
	SCT_OUT_CLR_CLR12_Msk = 0x1000
	// Bit CLR12.
	SCT_OUT_CLR_CLR12 = 0x1000
	// Position of CLR13 field.
	SCT_OUT_CLR_CLR13_Pos = 0xd
	// Bit mask of CLR13 field.
	SCT_OUT_CLR_CLR13_Msk = 0x2000
	// Bit CLR13.
	SCT_OUT_CLR_CLR13 = 0x2000
	// Position of CLR14 field.
	SCT_OUT_CLR_CLR14_Pos = 0xe
	// Bit mask of CLR14 field.
	SCT_OUT_CLR_CLR14_Msk = 0x4000
	// Bit CLR14.
	SCT_OUT_CLR_CLR14 = 0x4000
	// Position of CLR15 field.
	SCT_OUT_CLR_CLR15_Pos = 0xf
	// Bit mask of CLR15 field.
	SCT_OUT_CLR_CLR15_Msk = 0x8000
	// Bit CLR15.
	SCT_OUT_CLR_CLR15 = 0x8000
	// Position of RESERVED field.
	SCT_OUT_CLR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCT_OUT_CLR_RESERVED_Msk = 0xffff0000
)

// Constants for GPDMA: General Purpose DMA (GPDMA)
const (
	// INTSTAT: DMA Interrupt Status Register
	// Position of INTSTAT0 field.
	GPDMA_INTSTAT_INTSTAT0_Pos = 0x0
	// Bit mask of INTSTAT0 field.
	GPDMA_INTSTAT_INTSTAT0_Msk = 0x1
	// Bit INTSTAT0.
	GPDMA_INTSTAT_INTSTAT0 = 0x1
	// Position of INTSTAT1 field.
	GPDMA_INTSTAT_INTSTAT1_Pos = 0x1
	// Bit mask of INTSTAT1 field.
	GPDMA_INTSTAT_INTSTAT1_Msk = 0x2
	// Bit INTSTAT1.
	GPDMA_INTSTAT_INTSTAT1 = 0x2
	// Position of INTSTAT2 field.
	GPDMA_INTSTAT_INTSTAT2_Pos = 0x2
	// Bit mask of INTSTAT2 field.
	GPDMA_INTSTAT_INTSTAT2_Msk = 0x4
	// Bit INTSTAT2.
	GPDMA_INTSTAT_INTSTAT2 = 0x4
	// Position of INTSTAT3 field.
	GPDMA_INTSTAT_INTSTAT3_Pos = 0x3
	// Bit mask of INTSTAT3 field.
	GPDMA_INTSTAT_INTSTAT3_Msk = 0x8
	// Bit INTSTAT3.
	GPDMA_INTSTAT_INTSTAT3 = 0x8
	// Position of INTSTAT4 field.
	GPDMA_INTSTAT_INTSTAT4_Pos = 0x4
	// Bit mask of INTSTAT4 field.
	GPDMA_INTSTAT_INTSTAT4_Msk = 0x10
	// Bit INTSTAT4.
	GPDMA_INTSTAT_INTSTAT4 = 0x10
	// Position of INTSTAT5 field.
	GPDMA_INTSTAT_INTSTAT5_Pos = 0x5
	// Bit mask of INTSTAT5 field.
	GPDMA_INTSTAT_INTSTAT5_Msk = 0x20
	// Bit INTSTAT5.
	GPDMA_INTSTAT_INTSTAT5 = 0x20
	// Position of INTSTAT6 field.
	GPDMA_INTSTAT_INTSTAT6_Pos = 0x6
	// Bit mask of INTSTAT6 field.
	GPDMA_INTSTAT_INTSTAT6_Msk = 0x40
	// Bit INTSTAT6.
	GPDMA_INTSTAT_INTSTAT6 = 0x40
	// Position of INTSTAT7 field.
	GPDMA_INTSTAT_INTSTAT7_Pos = 0x7
	// Bit mask of INTSTAT7 field.
	GPDMA_INTSTAT_INTSTAT7_Msk = 0x80
	// Bit INTSTAT7.
	GPDMA_INTSTAT_INTSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTSTAT_RESERVED_Msk = 0xffffff00

	// INTTCSTAT: DMA Interrupt Terminal Count Request Status Register
	// Position of INTTCSTAT0 field.
	GPDMA_INTTCSTAT_INTTCSTAT0_Pos = 0x0
	// Bit mask of INTTCSTAT0 field.
	GPDMA_INTTCSTAT_INTTCSTAT0_Msk = 0x1
	// Bit INTTCSTAT0.
	GPDMA_INTTCSTAT_INTTCSTAT0 = 0x1
	// Position of INTTCSTAT1 field.
	GPDMA_INTTCSTAT_INTTCSTAT1_Pos = 0x1
	// Bit mask of INTTCSTAT1 field.
	GPDMA_INTTCSTAT_INTTCSTAT1_Msk = 0x2
	// Bit INTTCSTAT1.
	GPDMA_INTTCSTAT_INTTCSTAT1 = 0x2
	// Position of INTTCSTAT2 field.
	GPDMA_INTTCSTAT_INTTCSTAT2_Pos = 0x2
	// Bit mask of INTTCSTAT2 field.
	GPDMA_INTTCSTAT_INTTCSTAT2_Msk = 0x4
	// Bit INTTCSTAT2.
	GPDMA_INTTCSTAT_INTTCSTAT2 = 0x4
	// Position of INTTCSTAT3 field.
	GPDMA_INTTCSTAT_INTTCSTAT3_Pos = 0x3
	// Bit mask of INTTCSTAT3 field.
	GPDMA_INTTCSTAT_INTTCSTAT3_Msk = 0x8
	// Bit INTTCSTAT3.
	GPDMA_INTTCSTAT_INTTCSTAT3 = 0x8
	// Position of INTTCSTAT4 field.
	GPDMA_INTTCSTAT_INTTCSTAT4_Pos = 0x4
	// Bit mask of INTTCSTAT4 field.
	GPDMA_INTTCSTAT_INTTCSTAT4_Msk = 0x10
	// Bit INTTCSTAT4.
	GPDMA_INTTCSTAT_INTTCSTAT4 = 0x10
	// Position of INTTCSTAT5 field.
	GPDMA_INTTCSTAT_INTTCSTAT5_Pos = 0x5
	// Bit mask of INTTCSTAT5 field.
	GPDMA_INTTCSTAT_INTTCSTAT5_Msk = 0x20
	// Bit INTTCSTAT5.
	GPDMA_INTTCSTAT_INTTCSTAT5 = 0x20
	// Position of INTTCSTAT6 field.
	GPDMA_INTTCSTAT_INTTCSTAT6_Pos = 0x6
	// Bit mask of INTTCSTAT6 field.
	GPDMA_INTTCSTAT_INTTCSTAT6_Msk = 0x40
	// Bit INTTCSTAT6.
	GPDMA_INTTCSTAT_INTTCSTAT6 = 0x40
	// Position of INTTCSTAT7 field.
	GPDMA_INTTCSTAT_INTTCSTAT7_Pos = 0x7
	// Bit mask of INTTCSTAT7 field.
	GPDMA_INTTCSTAT_INTTCSTAT7_Msk = 0x80
	// Bit INTTCSTAT7.
	GPDMA_INTTCSTAT_INTTCSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTTCSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTTCSTAT_RESERVED_Msk = 0xffffff00

	// INTTCCLEAR: DMA Interrupt Terminal Count Request Clear Register
	// Position of INTTCCLEAR0 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR0_Pos = 0x0
	// Bit mask of INTTCCLEAR0 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR0_Msk = 0x1
	// Bit INTTCCLEAR0.
	GPDMA_INTTCCLEAR_INTTCCLEAR0 = 0x1
	// Position of INTTCCLEAR1 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR1_Pos = 0x1
	// Bit mask of INTTCCLEAR1 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR1_Msk = 0x2
	// Bit INTTCCLEAR1.
	GPDMA_INTTCCLEAR_INTTCCLEAR1 = 0x2
	// Position of INTTCCLEAR2 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR2_Pos = 0x2
	// Bit mask of INTTCCLEAR2 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR2_Msk = 0x4
	// Bit INTTCCLEAR2.
	GPDMA_INTTCCLEAR_INTTCCLEAR2 = 0x4
	// Position of INTTCCLEAR3 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR3_Pos = 0x3
	// Bit mask of INTTCCLEAR3 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR3_Msk = 0x8
	// Bit INTTCCLEAR3.
	GPDMA_INTTCCLEAR_INTTCCLEAR3 = 0x8
	// Position of INTTCCLEAR4 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR4_Pos = 0x4
	// Bit mask of INTTCCLEAR4 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR4_Msk = 0x10
	// Bit INTTCCLEAR4.
	GPDMA_INTTCCLEAR_INTTCCLEAR4 = 0x10
	// Position of INTTCCLEAR5 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR5_Pos = 0x5
	// Bit mask of INTTCCLEAR5 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR5_Msk = 0x20
	// Bit INTTCCLEAR5.
	GPDMA_INTTCCLEAR_INTTCCLEAR5 = 0x20
	// Position of INTTCCLEAR6 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR6_Pos = 0x6
	// Bit mask of INTTCCLEAR6 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR6_Msk = 0x40
	// Bit INTTCCLEAR6.
	GPDMA_INTTCCLEAR_INTTCCLEAR6 = 0x40
	// Position of INTTCCLEAR7 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR7_Pos = 0x7
	// Bit mask of INTTCCLEAR7 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR7_Msk = 0x80
	// Bit INTTCCLEAR7.
	GPDMA_INTTCCLEAR_INTTCCLEAR7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTTCCLEAR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTTCCLEAR_RESERVED_Msk = 0xffffff00

	// INTERRSTAT: DMA Interrupt Error Status Register
	// Position of INTERRSTAT0 field.
	GPDMA_INTERRSTAT_INTERRSTAT0_Pos = 0x0
	// Bit mask of INTERRSTAT0 field.
	GPDMA_INTERRSTAT_INTERRSTAT0_Msk = 0x1
	// Bit INTERRSTAT0.
	GPDMA_INTERRSTAT_INTERRSTAT0 = 0x1
	// Position of INTERRSTAT1 field.
	GPDMA_INTERRSTAT_INTERRSTAT1_Pos = 0x1
	// Bit mask of INTERRSTAT1 field.
	GPDMA_INTERRSTAT_INTERRSTAT1_Msk = 0x2
	// Bit INTERRSTAT1.
	GPDMA_INTERRSTAT_INTERRSTAT1 = 0x2
	// Position of INTERRSTAT2 field.
	GPDMA_INTERRSTAT_INTERRSTAT2_Pos = 0x2
	// Bit mask of INTERRSTAT2 field.
	GPDMA_INTERRSTAT_INTERRSTAT2_Msk = 0x4
	// Bit INTERRSTAT2.
	GPDMA_INTERRSTAT_INTERRSTAT2 = 0x4
	// Position of INTERRSTAT3 field.
	GPDMA_INTERRSTAT_INTERRSTAT3_Pos = 0x3
	// Bit mask of INTERRSTAT3 field.
	GPDMA_INTERRSTAT_INTERRSTAT3_Msk = 0x8
	// Bit INTERRSTAT3.
	GPDMA_INTERRSTAT_INTERRSTAT3 = 0x8
	// Position of INTERRSTAT4 field.
	GPDMA_INTERRSTAT_INTERRSTAT4_Pos = 0x4
	// Bit mask of INTERRSTAT4 field.
	GPDMA_INTERRSTAT_INTERRSTAT4_Msk = 0x10
	// Bit INTERRSTAT4.
	GPDMA_INTERRSTAT_INTERRSTAT4 = 0x10
	// Position of INTERRSTAT5 field.
	GPDMA_INTERRSTAT_INTERRSTAT5_Pos = 0x5
	// Bit mask of INTERRSTAT5 field.
	GPDMA_INTERRSTAT_INTERRSTAT5_Msk = 0x20
	// Bit INTERRSTAT5.
	GPDMA_INTERRSTAT_INTERRSTAT5 = 0x20
	// Position of INTERRSTAT6 field.
	GPDMA_INTERRSTAT_INTERRSTAT6_Pos = 0x6
	// Bit mask of INTERRSTAT6 field.
	GPDMA_INTERRSTAT_INTERRSTAT6_Msk = 0x40
	// Bit INTERRSTAT6.
	GPDMA_INTERRSTAT_INTERRSTAT6 = 0x40
	// Position of INTERRSTAT7 field.
	GPDMA_INTERRSTAT_INTERRSTAT7_Pos = 0x7
	// Bit mask of INTERRSTAT7 field.
	GPDMA_INTERRSTAT_INTERRSTAT7_Msk = 0x80
	// Bit INTERRSTAT7.
	GPDMA_INTERRSTAT_INTERRSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTERRSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTERRSTAT_RESERVED_Msk = 0xffffff00

	// INTERRCLR: DMA Interrupt Error Clear Register
	// Position of INTERRCLR0 field.
	GPDMA_INTERRCLR_INTERRCLR0_Pos = 0x0
	// Bit mask of INTERRCLR0 field.
	GPDMA_INTERRCLR_INTERRCLR0_Msk = 0x1
	// Bit INTERRCLR0.
	GPDMA_INTERRCLR_INTERRCLR0 = 0x1
	// Position of INTERRCLR1 field.
	GPDMA_INTERRCLR_INTERRCLR1_Pos = 0x1
	// Bit mask of INTERRCLR1 field.
	GPDMA_INTERRCLR_INTERRCLR1_Msk = 0x2
	// Bit INTERRCLR1.
	GPDMA_INTERRCLR_INTERRCLR1 = 0x2
	// Position of INTERRCLR2 field.
	GPDMA_INTERRCLR_INTERRCLR2_Pos = 0x2
	// Bit mask of INTERRCLR2 field.
	GPDMA_INTERRCLR_INTERRCLR2_Msk = 0x4
	// Bit INTERRCLR2.
	GPDMA_INTERRCLR_INTERRCLR2 = 0x4
	// Position of INTERRCLR3 field.
	GPDMA_INTERRCLR_INTERRCLR3_Pos = 0x3
	// Bit mask of INTERRCLR3 field.
	GPDMA_INTERRCLR_INTERRCLR3_Msk = 0x8
	// Bit INTERRCLR3.
	GPDMA_INTERRCLR_INTERRCLR3 = 0x8
	// Position of INTERRCLR4 field.
	GPDMA_INTERRCLR_INTERRCLR4_Pos = 0x4
	// Bit mask of INTERRCLR4 field.
	GPDMA_INTERRCLR_INTERRCLR4_Msk = 0x10
	// Bit INTERRCLR4.
	GPDMA_INTERRCLR_INTERRCLR4 = 0x10
	// Position of INTERRCLR5 field.
	GPDMA_INTERRCLR_INTERRCLR5_Pos = 0x5
	// Bit mask of INTERRCLR5 field.
	GPDMA_INTERRCLR_INTERRCLR5_Msk = 0x20
	// Bit INTERRCLR5.
	GPDMA_INTERRCLR_INTERRCLR5 = 0x20
	// Position of INTERRCLR6 field.
	GPDMA_INTERRCLR_INTERRCLR6_Pos = 0x6
	// Bit mask of INTERRCLR6 field.
	GPDMA_INTERRCLR_INTERRCLR6_Msk = 0x40
	// Bit INTERRCLR6.
	GPDMA_INTERRCLR_INTERRCLR6 = 0x40
	// Position of INTERRCLR7 field.
	GPDMA_INTERRCLR_INTERRCLR7_Pos = 0x7
	// Bit mask of INTERRCLR7 field.
	GPDMA_INTERRCLR_INTERRCLR7_Msk = 0x80
	// Bit INTERRCLR7.
	GPDMA_INTERRCLR_INTERRCLR7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTERRCLR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTERRCLR_RESERVED_Msk = 0xffffff00

	// RAWINTTCSTAT: DMA Raw Interrupt Terminal Count Status Register
	// Position of RAWINTTCSTAT0 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT0_Pos = 0x0
	// Bit mask of RAWINTTCSTAT0 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT0_Msk = 0x1
	// Bit RAWINTTCSTAT0.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT0 = 0x1
	// Position of RAWINTTCSTAT1 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT1_Pos = 0x1
	// Bit mask of RAWINTTCSTAT1 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT1_Msk = 0x2
	// Bit RAWINTTCSTAT1.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT1 = 0x2
	// Position of RAWINTTCSTAT2 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT2_Pos = 0x2
	// Bit mask of RAWINTTCSTAT2 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT2_Msk = 0x4
	// Bit RAWINTTCSTAT2.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT2 = 0x4
	// Position of RAWINTTCSTAT3 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT3_Pos = 0x3
	// Bit mask of RAWINTTCSTAT3 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT3_Msk = 0x8
	// Bit RAWINTTCSTAT3.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT3 = 0x8
	// Position of RAWINTTCSTAT4 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT4_Pos = 0x4
	// Bit mask of RAWINTTCSTAT4 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT4_Msk = 0x10
	// Bit RAWINTTCSTAT4.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT4 = 0x10
	// Position of RAWINTTCSTAT5 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT5_Pos = 0x5
	// Bit mask of RAWINTTCSTAT5 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT5_Msk = 0x20
	// Bit RAWINTTCSTAT5.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT5 = 0x20
	// Position of RAWINTTCSTAT6 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT6_Pos = 0x6
	// Bit mask of RAWINTTCSTAT6 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT6_Msk = 0x40
	// Bit RAWINTTCSTAT6.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT6 = 0x40
	// Position of RAWINTTCSTAT7 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT7_Pos = 0x7
	// Bit mask of RAWINTTCSTAT7 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT7_Msk = 0x80
	// Bit RAWINTTCSTAT7.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_RAWINTTCSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_RAWINTTCSTAT_RESERVED_Msk = 0xffffff00

	// RAWINTERRSTAT: DMA Raw Error Interrupt Status Register
	// Position of RAWINTERRSTAT0 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT0_Pos = 0x0
	// Bit mask of RAWINTERRSTAT0 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT0_Msk = 0x1
	// Bit RAWINTERRSTAT0.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT0 = 0x1
	// Position of RAWINTERRSTAT1 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT1_Pos = 0x1
	// Bit mask of RAWINTERRSTAT1 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT1_Msk = 0x2
	// Bit RAWINTERRSTAT1.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT1 = 0x2
	// Position of RAWINTERRSTAT2 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT2_Pos = 0x2
	// Bit mask of RAWINTERRSTAT2 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT2_Msk = 0x4
	// Bit RAWINTERRSTAT2.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT2 = 0x4
	// Position of RAWINTERRSTAT3 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT3_Pos = 0x3
	// Bit mask of RAWINTERRSTAT3 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT3_Msk = 0x8
	// Bit RAWINTERRSTAT3.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT3 = 0x8
	// Position of RAWINTERRSTAT4 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT4_Pos = 0x4
	// Bit mask of RAWINTERRSTAT4 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT4_Msk = 0x10
	// Bit RAWINTERRSTAT4.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT4 = 0x10
	// Position of RAWINTERRSTAT5 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT5_Pos = 0x5
	// Bit mask of RAWINTERRSTAT5 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT5_Msk = 0x20
	// Bit RAWINTERRSTAT5.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT5 = 0x20
	// Position of RAWINTERRSTAT6 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT6_Pos = 0x6
	// Bit mask of RAWINTERRSTAT6 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT6_Msk = 0x40
	// Bit RAWINTERRSTAT6.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT6 = 0x40
	// Position of RAWINTERRSTAT7 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT7_Pos = 0x7
	// Bit mask of RAWINTERRSTAT7 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT7_Msk = 0x80
	// Bit RAWINTERRSTAT7.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_RAWINTERRSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_RAWINTERRSTAT_RESERVED_Msk = 0xffffff00

	// ENBLDCHNS: DMA Enabled Channel Register
	// Position of ENABLEDCHANNELS0 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS0_Pos = 0x0
	// Bit mask of ENABLEDCHANNELS0 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS0_Msk = 0x1
	// Bit ENABLEDCHANNELS0.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS0 = 0x1
	// Position of ENABLEDCHANNELS1 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS1_Pos = 0x1
	// Bit mask of ENABLEDCHANNELS1 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS1_Msk = 0x2
	// Bit ENABLEDCHANNELS1.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS1 = 0x2
	// Position of ENABLEDCHANNELS2 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS2_Pos = 0x2
	// Bit mask of ENABLEDCHANNELS2 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS2_Msk = 0x4
	// Bit ENABLEDCHANNELS2.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS2 = 0x4
	// Position of ENABLEDCHANNELS3 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS3_Pos = 0x3
	// Bit mask of ENABLEDCHANNELS3 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS3_Msk = 0x8
	// Bit ENABLEDCHANNELS3.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS3 = 0x8
	// Position of ENABLEDCHANNELS4 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS4_Pos = 0x4
	// Bit mask of ENABLEDCHANNELS4 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS4_Msk = 0x10
	// Bit ENABLEDCHANNELS4.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS4 = 0x10
	// Position of ENABLEDCHANNELS5 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS5_Pos = 0x5
	// Bit mask of ENABLEDCHANNELS5 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS5_Msk = 0x20
	// Bit ENABLEDCHANNELS5.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS5 = 0x20
	// Position of ENABLEDCHANNELS6 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS6_Pos = 0x6
	// Bit mask of ENABLEDCHANNELS6 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS6_Msk = 0x40
	// Bit ENABLEDCHANNELS6.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS6 = 0x40
	// Position of ENABLEDCHANNELS7 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS7_Pos = 0x7
	// Bit mask of ENABLEDCHANNELS7 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS7_Msk = 0x80
	// Bit ENABLEDCHANNELS7.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS7 = 0x80
	// Position of RESERVED field.
	GPDMA_ENBLDCHNS_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_ENBLDCHNS_RESERVED_Msk = 0xffffff00

	// SOFTBREQ: DMA Software Burst Request Register
	// Position of SOFTBREQ0 field.
	GPDMA_SOFTBREQ_SOFTBREQ0_Pos = 0x0
	// Bit mask of SOFTBREQ0 field.
	GPDMA_SOFTBREQ_SOFTBREQ0_Msk = 0x1
	// Bit SOFTBREQ0.
	GPDMA_SOFTBREQ_SOFTBREQ0 = 0x1
	// Position of SOFTBREQ1 field.
	GPDMA_SOFTBREQ_SOFTBREQ1_Pos = 0x1
	// Bit mask of SOFTBREQ1 field.
	GPDMA_SOFTBREQ_SOFTBREQ1_Msk = 0x2
	// Bit SOFTBREQ1.
	GPDMA_SOFTBREQ_SOFTBREQ1 = 0x2
	// Position of SOFTBREQ2 field.
	GPDMA_SOFTBREQ_SOFTBREQ2_Pos = 0x2
	// Bit mask of SOFTBREQ2 field.
	GPDMA_SOFTBREQ_SOFTBREQ2_Msk = 0x4
	// Bit SOFTBREQ2.
	GPDMA_SOFTBREQ_SOFTBREQ2 = 0x4
	// Position of SOFTBREQ3 field.
	GPDMA_SOFTBREQ_SOFTBREQ3_Pos = 0x3
	// Bit mask of SOFTBREQ3 field.
	GPDMA_SOFTBREQ_SOFTBREQ3_Msk = 0x8
	// Bit SOFTBREQ3.
	GPDMA_SOFTBREQ_SOFTBREQ3 = 0x8
	// Position of SOFTBREQ4 field.
	GPDMA_SOFTBREQ_SOFTBREQ4_Pos = 0x4
	// Bit mask of SOFTBREQ4 field.
	GPDMA_SOFTBREQ_SOFTBREQ4_Msk = 0x10
	// Bit SOFTBREQ4.
	GPDMA_SOFTBREQ_SOFTBREQ4 = 0x10
	// Position of SOFTBREQ5 field.
	GPDMA_SOFTBREQ_SOFTBREQ5_Pos = 0x5
	// Bit mask of SOFTBREQ5 field.
	GPDMA_SOFTBREQ_SOFTBREQ5_Msk = 0x20
	// Bit SOFTBREQ5.
	GPDMA_SOFTBREQ_SOFTBREQ5 = 0x20
	// Position of SOFTBREQ6 field.
	GPDMA_SOFTBREQ_SOFTBREQ6_Pos = 0x6
	// Bit mask of SOFTBREQ6 field.
	GPDMA_SOFTBREQ_SOFTBREQ6_Msk = 0x40
	// Bit SOFTBREQ6.
	GPDMA_SOFTBREQ_SOFTBREQ6 = 0x40
	// Position of SOFTBREQ7 field.
	GPDMA_SOFTBREQ_SOFTBREQ7_Pos = 0x7
	// Bit mask of SOFTBREQ7 field.
	GPDMA_SOFTBREQ_SOFTBREQ7_Msk = 0x80
	// Bit SOFTBREQ7.
	GPDMA_SOFTBREQ_SOFTBREQ7 = 0x80
	// Position of SOFTBREQ8 field.
	GPDMA_SOFTBREQ_SOFTBREQ8_Pos = 0x8
	// Bit mask of SOFTBREQ8 field.
	GPDMA_SOFTBREQ_SOFTBREQ8_Msk = 0x100
	// Bit SOFTBREQ8.
	GPDMA_SOFTBREQ_SOFTBREQ8 = 0x100
	// Position of SOFTBREQ9 field.
	GPDMA_SOFTBREQ_SOFTBREQ9_Pos = 0x9
	// Bit mask of SOFTBREQ9 field.
	GPDMA_SOFTBREQ_SOFTBREQ9_Msk = 0x200
	// Bit SOFTBREQ9.
	GPDMA_SOFTBREQ_SOFTBREQ9 = 0x200
	// Position of SOFTBREQ10 field.
	GPDMA_SOFTBREQ_SOFTBREQ10_Pos = 0xa
	// Bit mask of SOFTBREQ10 field.
	GPDMA_SOFTBREQ_SOFTBREQ10_Msk = 0x400
	// Bit SOFTBREQ10.
	GPDMA_SOFTBREQ_SOFTBREQ10 = 0x400
	// Position of SOFTBREQ11 field.
	GPDMA_SOFTBREQ_SOFTBREQ11_Pos = 0xb
	// Bit mask of SOFTBREQ11 field.
	GPDMA_SOFTBREQ_SOFTBREQ11_Msk = 0x800
	// Bit SOFTBREQ11.
	GPDMA_SOFTBREQ_SOFTBREQ11 = 0x800
	// Position of SOFTBREQ12 field.
	GPDMA_SOFTBREQ_SOFTBREQ12_Pos = 0xc
	// Bit mask of SOFTBREQ12 field.
	GPDMA_SOFTBREQ_SOFTBREQ12_Msk = 0x1000
	// Bit SOFTBREQ12.
	GPDMA_SOFTBREQ_SOFTBREQ12 = 0x1000
	// Position of SOFTBREQ13 field.
	GPDMA_SOFTBREQ_SOFTBREQ13_Pos = 0xd
	// Bit mask of SOFTBREQ13 field.
	GPDMA_SOFTBREQ_SOFTBREQ13_Msk = 0x2000
	// Bit SOFTBREQ13.
	GPDMA_SOFTBREQ_SOFTBREQ13 = 0x2000
	// Position of SOFTBREQ14 field.
	GPDMA_SOFTBREQ_SOFTBREQ14_Pos = 0xe
	// Bit mask of SOFTBREQ14 field.
	GPDMA_SOFTBREQ_SOFTBREQ14_Msk = 0x4000
	// Bit SOFTBREQ14.
	GPDMA_SOFTBREQ_SOFTBREQ14 = 0x4000
	// Position of SOFTBREQ15 field.
	GPDMA_SOFTBREQ_SOFTBREQ15_Pos = 0xf
	// Bit mask of SOFTBREQ15 field.
	GPDMA_SOFTBREQ_SOFTBREQ15_Msk = 0x8000
	// Bit SOFTBREQ15.
	GPDMA_SOFTBREQ_SOFTBREQ15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SOFTBREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SOFTBREQ_RESERVED_Msk = 0xffff0000

	// SOFTSREQ: DMA Software Single Request Register
	// Position of SOFTSREQ0 field.
	GPDMA_SOFTSREQ_SOFTSREQ0_Pos = 0x0
	// Bit mask of SOFTSREQ0 field.
	GPDMA_SOFTSREQ_SOFTSREQ0_Msk = 0x1
	// Bit SOFTSREQ0.
	GPDMA_SOFTSREQ_SOFTSREQ0 = 0x1
	// Position of SOFTSREQ1 field.
	GPDMA_SOFTSREQ_SOFTSREQ1_Pos = 0x1
	// Bit mask of SOFTSREQ1 field.
	GPDMA_SOFTSREQ_SOFTSREQ1_Msk = 0x2
	// Bit SOFTSREQ1.
	GPDMA_SOFTSREQ_SOFTSREQ1 = 0x2
	// Position of SOFTSREQ2 field.
	GPDMA_SOFTSREQ_SOFTSREQ2_Pos = 0x2
	// Bit mask of SOFTSREQ2 field.
	GPDMA_SOFTSREQ_SOFTSREQ2_Msk = 0x4
	// Bit SOFTSREQ2.
	GPDMA_SOFTSREQ_SOFTSREQ2 = 0x4
	// Position of SOFTSREQ3 field.
	GPDMA_SOFTSREQ_SOFTSREQ3_Pos = 0x3
	// Bit mask of SOFTSREQ3 field.
	GPDMA_SOFTSREQ_SOFTSREQ3_Msk = 0x8
	// Bit SOFTSREQ3.
	GPDMA_SOFTSREQ_SOFTSREQ3 = 0x8
	// Position of SOFTSREQ4 field.
	GPDMA_SOFTSREQ_SOFTSREQ4_Pos = 0x4
	// Bit mask of SOFTSREQ4 field.
	GPDMA_SOFTSREQ_SOFTSREQ4_Msk = 0x10
	// Bit SOFTSREQ4.
	GPDMA_SOFTSREQ_SOFTSREQ4 = 0x10
	// Position of SOFTSREQ5 field.
	GPDMA_SOFTSREQ_SOFTSREQ5_Pos = 0x5
	// Bit mask of SOFTSREQ5 field.
	GPDMA_SOFTSREQ_SOFTSREQ5_Msk = 0x20
	// Bit SOFTSREQ5.
	GPDMA_SOFTSREQ_SOFTSREQ5 = 0x20
	// Position of SOFTSREQ6 field.
	GPDMA_SOFTSREQ_SOFTSREQ6_Pos = 0x6
	// Bit mask of SOFTSREQ6 field.
	GPDMA_SOFTSREQ_SOFTSREQ6_Msk = 0x40
	// Bit SOFTSREQ6.
	GPDMA_SOFTSREQ_SOFTSREQ6 = 0x40
	// Position of SOFTSREQ7 field.
	GPDMA_SOFTSREQ_SOFTSREQ7_Pos = 0x7
	// Bit mask of SOFTSREQ7 field.
	GPDMA_SOFTSREQ_SOFTSREQ7_Msk = 0x80
	// Bit SOFTSREQ7.
	GPDMA_SOFTSREQ_SOFTSREQ7 = 0x80
	// Position of SOFTSREQ8 field.
	GPDMA_SOFTSREQ_SOFTSREQ8_Pos = 0x8
	// Bit mask of SOFTSREQ8 field.
	GPDMA_SOFTSREQ_SOFTSREQ8_Msk = 0x100
	// Bit SOFTSREQ8.
	GPDMA_SOFTSREQ_SOFTSREQ8 = 0x100
	// Position of SOFTSREQ9 field.
	GPDMA_SOFTSREQ_SOFTSREQ9_Pos = 0x9
	// Bit mask of SOFTSREQ9 field.
	GPDMA_SOFTSREQ_SOFTSREQ9_Msk = 0x200
	// Bit SOFTSREQ9.
	GPDMA_SOFTSREQ_SOFTSREQ9 = 0x200
	// Position of SOFTSREQ10 field.
	GPDMA_SOFTSREQ_SOFTSREQ10_Pos = 0xa
	// Bit mask of SOFTSREQ10 field.
	GPDMA_SOFTSREQ_SOFTSREQ10_Msk = 0x400
	// Bit SOFTSREQ10.
	GPDMA_SOFTSREQ_SOFTSREQ10 = 0x400
	// Position of SOFTSREQ11 field.
	GPDMA_SOFTSREQ_SOFTSREQ11_Pos = 0xb
	// Bit mask of SOFTSREQ11 field.
	GPDMA_SOFTSREQ_SOFTSREQ11_Msk = 0x800
	// Bit SOFTSREQ11.
	GPDMA_SOFTSREQ_SOFTSREQ11 = 0x800
	// Position of SOFTSREQ12 field.
	GPDMA_SOFTSREQ_SOFTSREQ12_Pos = 0xc
	// Bit mask of SOFTSREQ12 field.
	GPDMA_SOFTSREQ_SOFTSREQ12_Msk = 0x1000
	// Bit SOFTSREQ12.
	GPDMA_SOFTSREQ_SOFTSREQ12 = 0x1000
	// Position of SOFTSREQ13 field.
	GPDMA_SOFTSREQ_SOFTSREQ13_Pos = 0xd
	// Bit mask of SOFTSREQ13 field.
	GPDMA_SOFTSREQ_SOFTSREQ13_Msk = 0x2000
	// Bit SOFTSREQ13.
	GPDMA_SOFTSREQ_SOFTSREQ13 = 0x2000
	// Position of SOFTSREQ14 field.
	GPDMA_SOFTSREQ_SOFTSREQ14_Pos = 0xe
	// Bit mask of SOFTSREQ14 field.
	GPDMA_SOFTSREQ_SOFTSREQ14_Msk = 0x4000
	// Bit SOFTSREQ14.
	GPDMA_SOFTSREQ_SOFTSREQ14 = 0x4000
	// Position of SOFTSREQ15 field.
	GPDMA_SOFTSREQ_SOFTSREQ15_Pos = 0xf
	// Bit mask of SOFTSREQ15 field.
	GPDMA_SOFTSREQ_SOFTSREQ15_Msk = 0x8000
	// Bit SOFTSREQ15.
	GPDMA_SOFTSREQ_SOFTSREQ15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SOFTSREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SOFTSREQ_RESERVED_Msk = 0xffff0000

	// SOFTLBREQ: DMA Software Last Burst Request Register
	// Position of SOFTLBREQ0 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ0_Pos = 0x0
	// Bit mask of SOFTLBREQ0 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ0_Msk = 0x1
	// Bit SOFTLBREQ0.
	GPDMA_SOFTLBREQ_SOFTLBREQ0 = 0x1
	// Position of SOFTLBREQ1 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ1_Pos = 0x1
	// Bit mask of SOFTLBREQ1 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ1_Msk = 0x2
	// Bit SOFTLBREQ1.
	GPDMA_SOFTLBREQ_SOFTLBREQ1 = 0x2
	// Position of SOFTLBREQ2 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ2_Pos = 0x2
	// Bit mask of SOFTLBREQ2 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ2_Msk = 0x4
	// Bit SOFTLBREQ2.
	GPDMA_SOFTLBREQ_SOFTLBREQ2 = 0x4
	// Position of SOFTLBREQ3 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ3_Pos = 0x3
	// Bit mask of SOFTLBREQ3 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ3_Msk = 0x8
	// Bit SOFTLBREQ3.
	GPDMA_SOFTLBREQ_SOFTLBREQ3 = 0x8
	// Position of SOFTLBREQ4 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ4_Pos = 0x4
	// Bit mask of SOFTLBREQ4 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ4_Msk = 0x10
	// Bit SOFTLBREQ4.
	GPDMA_SOFTLBREQ_SOFTLBREQ4 = 0x10
	// Position of SOFTLBREQ5 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ5_Pos = 0x5
	// Bit mask of SOFTLBREQ5 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ5_Msk = 0x20
	// Bit SOFTLBREQ5.
	GPDMA_SOFTLBREQ_SOFTLBREQ5 = 0x20
	// Position of SOFTLBREQ6 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ6_Pos = 0x6
	// Bit mask of SOFTLBREQ6 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ6_Msk = 0x40
	// Bit SOFTLBREQ6.
	GPDMA_SOFTLBREQ_SOFTLBREQ6 = 0x40
	// Position of SOFTLBREQ7 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ7_Pos = 0x7
	// Bit mask of SOFTLBREQ7 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ7_Msk = 0x80
	// Bit SOFTLBREQ7.
	GPDMA_SOFTLBREQ_SOFTLBREQ7 = 0x80
	// Position of SOFTLBREQ8 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ8_Pos = 0x8
	// Bit mask of SOFTLBREQ8 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ8_Msk = 0x100
	// Bit SOFTLBREQ8.
	GPDMA_SOFTLBREQ_SOFTLBREQ8 = 0x100
	// Position of SOFTLBREQ9 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ9_Pos = 0x9
	// Bit mask of SOFTLBREQ9 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ9_Msk = 0x200
	// Bit SOFTLBREQ9.
	GPDMA_SOFTLBREQ_SOFTLBREQ9 = 0x200
	// Position of SOFTLBREQ10 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ10_Pos = 0xa
	// Bit mask of SOFTLBREQ10 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ10_Msk = 0x400
	// Bit SOFTLBREQ10.
	GPDMA_SOFTLBREQ_SOFTLBREQ10 = 0x400
	// Position of SOFTLBREQ11 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ11_Pos = 0xb
	// Bit mask of SOFTLBREQ11 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ11_Msk = 0x800
	// Bit SOFTLBREQ11.
	GPDMA_SOFTLBREQ_SOFTLBREQ11 = 0x800
	// Position of SOFTLBREQ12 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ12_Pos = 0xc
	// Bit mask of SOFTLBREQ12 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ12_Msk = 0x1000
	// Bit SOFTLBREQ12.
	GPDMA_SOFTLBREQ_SOFTLBREQ12 = 0x1000
	// Position of SOFTLBREQ13 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ13_Pos = 0xd
	// Bit mask of SOFTLBREQ13 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ13_Msk = 0x2000
	// Bit SOFTLBREQ13.
	GPDMA_SOFTLBREQ_SOFTLBREQ13 = 0x2000
	// Position of SOFTLBREQ14 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ14_Pos = 0xe
	// Bit mask of SOFTLBREQ14 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ14_Msk = 0x4000
	// Bit SOFTLBREQ14.
	GPDMA_SOFTLBREQ_SOFTLBREQ14 = 0x4000
	// Position of SOFTLBREQ15 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ15_Pos = 0xf
	// Bit mask of SOFTLBREQ15 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ15_Msk = 0x8000
	// Bit SOFTLBREQ15.
	GPDMA_SOFTLBREQ_SOFTLBREQ15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SOFTLBREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SOFTLBREQ_RESERVED_Msk = 0xffff0000

	// SOFTLSREQ: DMA Software Last Single Request Register
	// Position of SOFTLSREQ0 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ0_Pos = 0x0
	// Bit mask of SOFTLSREQ0 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ0_Msk = 0x1
	// Bit SOFTLSREQ0.
	GPDMA_SOFTLSREQ_SOFTLSREQ0 = 0x1
	// Position of SOFTLSREQ1 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ1_Pos = 0x1
	// Bit mask of SOFTLSREQ1 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ1_Msk = 0x2
	// Bit SOFTLSREQ1.
	GPDMA_SOFTLSREQ_SOFTLSREQ1 = 0x2
	// Position of SOFTLSREQ2 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ2_Pos = 0x2
	// Bit mask of SOFTLSREQ2 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ2_Msk = 0x4
	// Bit SOFTLSREQ2.
	GPDMA_SOFTLSREQ_SOFTLSREQ2 = 0x4
	// Position of SOFTLSREQ3 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ3_Pos = 0x3
	// Bit mask of SOFTLSREQ3 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ3_Msk = 0x8
	// Bit SOFTLSREQ3.
	GPDMA_SOFTLSREQ_SOFTLSREQ3 = 0x8
	// Position of SOFTLSREQ4 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ4_Pos = 0x4
	// Bit mask of SOFTLSREQ4 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ4_Msk = 0x10
	// Bit SOFTLSREQ4.
	GPDMA_SOFTLSREQ_SOFTLSREQ4 = 0x10
	// Position of SOFTLSREQ5 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ5_Pos = 0x5
	// Bit mask of SOFTLSREQ5 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ5_Msk = 0x20
	// Bit SOFTLSREQ5.
	GPDMA_SOFTLSREQ_SOFTLSREQ5 = 0x20
	// Position of SOFTLSREQ6 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ6_Pos = 0x6
	// Bit mask of SOFTLSREQ6 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ6_Msk = 0x40
	// Bit SOFTLSREQ6.
	GPDMA_SOFTLSREQ_SOFTLSREQ6 = 0x40
	// Position of SOFTLSREQ7 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ7_Pos = 0x7
	// Bit mask of SOFTLSREQ7 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ7_Msk = 0x80
	// Bit SOFTLSREQ7.
	GPDMA_SOFTLSREQ_SOFTLSREQ7 = 0x80
	// Position of SOFTLSREQ8 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ8_Pos = 0x8
	// Bit mask of SOFTLSREQ8 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ8_Msk = 0x100
	// Bit SOFTLSREQ8.
	GPDMA_SOFTLSREQ_SOFTLSREQ8 = 0x100
	// Position of SOFTLSREQ9 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ9_Pos = 0x9
	// Bit mask of SOFTLSREQ9 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ9_Msk = 0x200
	// Bit SOFTLSREQ9.
	GPDMA_SOFTLSREQ_SOFTLSREQ9 = 0x200
	// Position of SOFTLSREQ10 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ10_Pos = 0xa
	// Bit mask of SOFTLSREQ10 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ10_Msk = 0x400
	// Bit SOFTLSREQ10.
	GPDMA_SOFTLSREQ_SOFTLSREQ10 = 0x400
	// Position of SOFTLSREQ11 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ11_Pos = 0xb
	// Bit mask of SOFTLSREQ11 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ11_Msk = 0x800
	// Bit SOFTLSREQ11.
	GPDMA_SOFTLSREQ_SOFTLSREQ11 = 0x800
	// Position of SOFTLSREQ12 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ12_Pos = 0xc
	// Bit mask of SOFTLSREQ12 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ12_Msk = 0x1000
	// Bit SOFTLSREQ12.
	GPDMA_SOFTLSREQ_SOFTLSREQ12 = 0x1000
	// Position of SOFTLSREQ13 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ13_Pos = 0xd
	// Bit mask of SOFTLSREQ13 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ13_Msk = 0x2000
	// Bit SOFTLSREQ13.
	GPDMA_SOFTLSREQ_SOFTLSREQ13 = 0x2000
	// Position of SOFTLSREQ14 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ14_Pos = 0xe
	// Bit mask of SOFTLSREQ14 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ14_Msk = 0x4000
	// Bit SOFTLSREQ14.
	GPDMA_SOFTLSREQ_SOFTLSREQ14 = 0x4000
	// Position of SOFTLSREQ15 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ15_Pos = 0xf
	// Bit mask of SOFTLSREQ15 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ15_Msk = 0x8000
	// Bit SOFTLSREQ15.
	GPDMA_SOFTLSREQ_SOFTLSREQ15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SOFTLSREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SOFTLSREQ_RESERVED_Msk = 0xffff0000

	// CONFIG: DMA Configuration Register
	// Position of E field.
	GPDMA_CONFIG_E_Pos = 0x0
	// Bit mask of E field.
	GPDMA_CONFIG_E_Msk = 0x1
	// Bit E.
	GPDMA_CONFIG_E = 0x1
	// Disabled (default). Disabling the DMA Controller reduces power consumption.
	GPDMA_CONFIG_E_DISABLED__DEFAULT_ = 0x0
	// Enabled
	GPDMA_CONFIG_E_ENABLED = 0x1
	// Position of M0 field.
	GPDMA_CONFIG_M0_Pos = 0x1
	// Bit mask of M0 field.
	GPDMA_CONFIG_M0_Msk = 0x2
	// Bit M0.
	GPDMA_CONFIG_M0 = 0x2
	// Little-endian mode (default).
	GPDMA_CONFIG_M0_LITTLE_ENDIAN_MODE = 0x0
	// Big-endian mode.
	GPDMA_CONFIG_M0_BIG_ENDIAN_MODE_ = 0x1
	// Position of M1 field.
	GPDMA_CONFIG_M1_Pos = 0x2
	// Bit mask of M1 field.
	GPDMA_CONFIG_M1_Msk = 0x4
	// Bit M1.
	GPDMA_CONFIG_M1 = 0x4
	// Little-endian mode (default).
	GPDMA_CONFIG_M1_LITTLE_ENDIAN_MODE = 0x0
	// Big-endian mode.
	GPDMA_CONFIG_M1_BIG_ENDIAN_MODE_ = 0x1
	// Position of RESERVED field.
	GPDMA_CONFIG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	GPDMA_CONFIG_RESERVED_Msk = 0xfffffff8

	// SYNC: DMA Synchronization Register
	// Position of DMACSYNC0 field.
	GPDMA_SYNC_DMACSYNC0_Pos = 0x0
	// Bit mask of DMACSYNC0 field.
	GPDMA_SYNC_DMACSYNC0_Msk = 0x1
	// Bit DMACSYNC0.
	GPDMA_SYNC_DMACSYNC0 = 0x1
	// Position of DMACSYNC1 field.
	GPDMA_SYNC_DMACSYNC1_Pos = 0x1
	// Bit mask of DMACSYNC1 field.
	GPDMA_SYNC_DMACSYNC1_Msk = 0x2
	// Bit DMACSYNC1.
	GPDMA_SYNC_DMACSYNC1 = 0x2
	// Position of DMACSYNC2 field.
	GPDMA_SYNC_DMACSYNC2_Pos = 0x2
	// Bit mask of DMACSYNC2 field.
	GPDMA_SYNC_DMACSYNC2_Msk = 0x4
	// Bit DMACSYNC2.
	GPDMA_SYNC_DMACSYNC2 = 0x4
	// Position of DMACSYNC3 field.
	GPDMA_SYNC_DMACSYNC3_Pos = 0x3
	// Bit mask of DMACSYNC3 field.
	GPDMA_SYNC_DMACSYNC3_Msk = 0x8
	// Bit DMACSYNC3.
	GPDMA_SYNC_DMACSYNC3 = 0x8
	// Position of DMACSYNC4 field.
	GPDMA_SYNC_DMACSYNC4_Pos = 0x4
	// Bit mask of DMACSYNC4 field.
	GPDMA_SYNC_DMACSYNC4_Msk = 0x10
	// Bit DMACSYNC4.
	GPDMA_SYNC_DMACSYNC4 = 0x10
	// Position of DMACSYNC5 field.
	GPDMA_SYNC_DMACSYNC5_Pos = 0x5
	// Bit mask of DMACSYNC5 field.
	GPDMA_SYNC_DMACSYNC5_Msk = 0x20
	// Bit DMACSYNC5.
	GPDMA_SYNC_DMACSYNC5 = 0x20
	// Position of DMACSYNC6 field.
	GPDMA_SYNC_DMACSYNC6_Pos = 0x6
	// Bit mask of DMACSYNC6 field.
	GPDMA_SYNC_DMACSYNC6_Msk = 0x40
	// Bit DMACSYNC6.
	GPDMA_SYNC_DMACSYNC6 = 0x40
	// Position of DMACSYNC7 field.
	GPDMA_SYNC_DMACSYNC7_Pos = 0x7
	// Bit mask of DMACSYNC7 field.
	GPDMA_SYNC_DMACSYNC7_Msk = 0x80
	// Bit DMACSYNC7.
	GPDMA_SYNC_DMACSYNC7 = 0x80
	// Position of DMACSYNC8 field.
	GPDMA_SYNC_DMACSYNC8_Pos = 0x8
	// Bit mask of DMACSYNC8 field.
	GPDMA_SYNC_DMACSYNC8_Msk = 0x100
	// Bit DMACSYNC8.
	GPDMA_SYNC_DMACSYNC8 = 0x100
	// Position of DMACSYNC9 field.
	GPDMA_SYNC_DMACSYNC9_Pos = 0x9
	// Bit mask of DMACSYNC9 field.
	GPDMA_SYNC_DMACSYNC9_Msk = 0x200
	// Bit DMACSYNC9.
	GPDMA_SYNC_DMACSYNC9 = 0x200
	// Position of DMACSYNC10 field.
	GPDMA_SYNC_DMACSYNC10_Pos = 0xa
	// Bit mask of DMACSYNC10 field.
	GPDMA_SYNC_DMACSYNC10_Msk = 0x400
	// Bit DMACSYNC10.
	GPDMA_SYNC_DMACSYNC10 = 0x400
	// Position of DMACSYNC11 field.
	GPDMA_SYNC_DMACSYNC11_Pos = 0xb
	// Bit mask of DMACSYNC11 field.
	GPDMA_SYNC_DMACSYNC11_Msk = 0x800
	// Bit DMACSYNC11.
	GPDMA_SYNC_DMACSYNC11 = 0x800
	// Position of DMACSYNC12 field.
	GPDMA_SYNC_DMACSYNC12_Pos = 0xc
	// Bit mask of DMACSYNC12 field.
	GPDMA_SYNC_DMACSYNC12_Msk = 0x1000
	// Bit DMACSYNC12.
	GPDMA_SYNC_DMACSYNC12 = 0x1000
	// Position of DMACSYNC13 field.
	GPDMA_SYNC_DMACSYNC13_Pos = 0xd
	// Bit mask of DMACSYNC13 field.
	GPDMA_SYNC_DMACSYNC13_Msk = 0x2000
	// Bit DMACSYNC13.
	GPDMA_SYNC_DMACSYNC13 = 0x2000
	// Position of DMACSYNC14 field.
	GPDMA_SYNC_DMACSYNC14_Pos = 0xe
	// Bit mask of DMACSYNC14 field.
	GPDMA_SYNC_DMACSYNC14_Msk = 0x4000
	// Bit DMACSYNC14.
	GPDMA_SYNC_DMACSYNC14 = 0x4000
	// Position of DMACSYNC15 field.
	GPDMA_SYNC_DMACSYNC15_Pos = 0xf
	// Bit mask of DMACSYNC15 field.
	GPDMA_SYNC_DMACSYNC15_Msk = 0x8000
	// Bit DMACSYNC15.
	GPDMA_SYNC_DMACSYNC15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SYNC_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SYNC_RESERVED_Msk = 0xffff0000

	// C0SRCADDR: DMA Channel Source Address Register
	// Position of SRCADDR field.
	GPDMA_CSRCADDR_SRCADDR_Pos = 0x0
	// Bit mask of SRCADDR field.
	GPDMA_CSRCADDR_SRCADDR_Msk = 0xffffffff

	// C0DESTADDR: DMA Channel Destination Address Register
	// Position of DESTADDR field.
	GPDMA_CDESTADDR_DESTADDR_Pos = 0x0
	// Bit mask of DESTADDR field.
	GPDMA_CDESTADDR_DESTADDR_Msk = 0xffffffff

	// C0LLI: DMA Channel Linked List Item Register
	// Position of LM field.
	GPDMA_CLLI_LM_Pos = 0x0
	// Bit mask of LM field.
	GPDMA_CLLI_LM_Msk = 0x1
	// Bit LM.
	GPDMA_CLLI_LM = 0x1
	// AHB Master 0.
	GPDMA_CLLI_LM_AHB_MASTER_0_ = 0x0
	// AHB Master 1.
	GPDMA_CLLI_LM_AHB_MASTER_1_ = 0x1
	// Position of R field.
	GPDMA_CLLI_R_Pos = 0x1
	// Bit mask of R field.
	GPDMA_CLLI_R_Msk = 0x2
	// Bit R.
	GPDMA_CLLI_R = 0x2
	// Position of LLI field.
	GPDMA_CLLI_LLI_Pos = 0x2
	// Bit mask of LLI field.
	GPDMA_CLLI_LLI_Msk = 0xfffffffc

	// C0CONTROL: DMA Channel Control Register
	// Position of TRANSFERSIZE field.
	GPDMA_CCONTROL_TRANSFERSIZE_Pos = 0x0
	// Bit mask of TRANSFERSIZE field.
	GPDMA_CCONTROL_TRANSFERSIZE_Msk = 0xfff
	// Position of SBSIZE field.
	GPDMA_CCONTROL_SBSIZE_Pos = 0xc
	// Bit mask of SBSIZE field.
	GPDMA_CCONTROL_SBSIZE_Msk = 0x7000
	// Source burst size = 1
	GPDMA_CCONTROL_SBSIZE_SOURCE_BURST_1 = 0x0
	// Source burst size = 4
	GPDMA_CCONTROL_SBSIZE_SOURCE_BURST_4 = 0x1
	// Source burst size = 8
	GPDMA_CCONTROL_SBSIZE_SOURCE_BURST_8 = 0x2
	// Source burst size = 16
	GPDMA_CCONTROL_SBSIZE_SOURCE_BURST_16 = 0x3
	// Source burst size = 32
	GPDMA_CCONTROL_SBSIZE_SOURCE_BURST_32 = 0x4
	// Source burst size = 64
	GPDMA_CCONTROL_SBSIZE_SOURCE_BURST_64 = 0x5
	// Source burst size = 128
	GPDMA_CCONTROL_SBSIZE_SOURCE_BURST_128 = 0x6
	// Source burst size = 256
	GPDMA_CCONTROL_SBSIZE_SOURCE_BURST_256 = 0x7
	// Position of DBSIZE field.
	GPDMA_CCONTROL_DBSIZE_Pos = 0xf
	// Bit mask of DBSIZE field.
	GPDMA_CCONTROL_DBSIZE_Msk = 0x38000
	// Destination burst size = 1
	GPDMA_CCONTROL_DBSIZE_DESTINATION_BURST_1 = 0x0
	// Destination burst size = 4
	GPDMA_CCONTROL_DBSIZE_DESTINATION_BURST_4 = 0x1
	// Destination burst size = 8
	GPDMA_CCONTROL_DBSIZE_DESTINATION_BURST_8 = 0x2
	// Destination burst size = 16
	GPDMA_CCONTROL_DBSIZE_DESTINATION_BURST_16 = 0x3
	// Destination burst size = 32
	GPDMA_CCONTROL_DBSIZE_DESTINATION_BURST_32 = 0x4
	// Destination burst size = 64
	GPDMA_CCONTROL_DBSIZE_DESTINATION_BURST_64 = 0x5
	// Destination burst size = 128
	GPDMA_CCONTROL_DBSIZE_DESTINATION_BURST_128 = 0x6
	// Destination burst size = 256
	GPDMA_CCONTROL_DBSIZE_DESTINATION_BURST_256 = 0x7
	// Position of SWIDTH field.
	GPDMA_CCONTROL_SWIDTH_Pos = 0x12
	// Bit mask of SWIDTH field.
	GPDMA_CCONTROL_SWIDTH_Msk = 0x1c0000
	// Byte (8-bit)
	GPDMA_CCONTROL_SWIDTH_BYTE_8_BIT = 0x0
	// Halfword (16-bit)
	GPDMA_CCONTROL_SWIDTH_HALFWORD_16_BIT = 0x1
	// Word (32-bit)
	GPDMA_CCONTROL_SWIDTH_WORD_32_BIT = 0x2
	// Position of DWIDTH field.
	GPDMA_CCONTROL_DWIDTH_Pos = 0x15
	// Bit mask of DWIDTH field.
	GPDMA_CCONTROL_DWIDTH_Msk = 0xe00000
	// Byte (8-bit)
	GPDMA_CCONTROL_DWIDTH_BYTE_8_BIT = 0x0
	// Halfword (16-bit)
	GPDMA_CCONTROL_DWIDTH_HALFWORD_16_BIT = 0x1
	// Word (32-bit)
	GPDMA_CCONTROL_DWIDTH_WORD_32_BIT = 0x2
	// Position of S field.
	GPDMA_CCONTROL_S_Pos = 0x18
	// Bit mask of S field.
	GPDMA_CCONTROL_S_Msk = 0x1000000
	// Bit S.
	GPDMA_CCONTROL_S = 0x1000000
	// AHB Master 0 selected for source transfer.
	GPDMA_CCONTROL_S_AHB_MASTER_0_SELECTE = 0x0
	// AHB Master 1 selected for source transfer.
	GPDMA_CCONTROL_S_AHB_MASTER_1_SELECTE = 0x1
	// Position of D field.
	GPDMA_CCONTROL_D_Pos = 0x19
	// Bit mask of D field.
	GPDMA_CCONTROL_D_Msk = 0x2000000
	// Bit D.
	GPDMA_CCONTROL_D = 0x2000000
	// AHB Master 0 selected for destination transfer.
	GPDMA_CCONTROL_D_AHB_MASTER_0_SELECTE = 0x0
	// AHB Master 1 selected for destination transfer.
	GPDMA_CCONTROL_D_AHB_MASTER_1_SELECTE = 0x1
	// Position of SI field.
	GPDMA_CCONTROL_SI_Pos = 0x1a
	// Bit mask of SI field.
	GPDMA_CCONTROL_SI_Msk = 0x4000000
	// Bit SI.
	GPDMA_CCONTROL_SI = 0x4000000
	// The source address is not incremented after each transfer.
	GPDMA_CCONTROL_SI_NOT_INCREMENT = 0x0
	// The source address is incremented after each transfer.
	GPDMA_CCONTROL_SI_INCREMENT = 0x1
	// Position of DI field.
	GPDMA_CCONTROL_DI_Pos = 0x1b
	// Bit mask of DI field.
	GPDMA_CCONTROL_DI_Msk = 0x8000000
	// Bit DI.
	GPDMA_CCONTROL_DI = 0x8000000
	// Position of PROT1 field.
	GPDMA_CCONTROL_PROT1_Pos = 0x1c
	// Bit mask of PROT1 field.
	GPDMA_CCONTROL_PROT1_Msk = 0x10000000
	// Bit PROT1.
	GPDMA_CCONTROL_PROT1 = 0x10000000
	// Access is in user mode
	GPDMA_CCONTROL_PROT1_ACCESS_IS_IN_USER_MO = 0x0
	// Access is in privileged mode.
	GPDMA_CCONTROL_PROT1_ACCESS_IS_IN_PRIVILE = 0x1
	// Position of PROT2 field.
	GPDMA_CCONTROL_PROT2_Pos = 0x1d
	// Bit mask of PROT2 field.
	GPDMA_CCONTROL_PROT2_Msk = 0x20000000
	// Bit PROT2.
	GPDMA_CCONTROL_PROT2 = 0x20000000
	// Access is not bufferable.
	GPDMA_CCONTROL_PROT2_ACCESS_IS_NOT_BUFFER = 0x0
	// Access is bufferable.
	GPDMA_CCONTROL_PROT2_ACCESS_IS_BUFFERABLE = 0x1
	// Position of PROT3 field.
	GPDMA_CCONTROL_PROT3_Pos = 0x1e
	// Bit mask of PROT3 field.
	GPDMA_CCONTROL_PROT3_Msk = 0x40000000
	// Bit PROT3.
	GPDMA_CCONTROL_PROT3 = 0x40000000
	// Access is not cacheable.
	GPDMA_CCONTROL_PROT3_ACCESS_IS_NOT_CACHEA = 0x0
	// Access is cacheable.
	GPDMA_CCONTROL_PROT3_ACCESS_IS_CACHEABLE_ = 0x1
	// Position of I field.
	GPDMA_CCONTROL_I_Pos = 0x1f
	// Bit mask of I field.
	GPDMA_CCONTROL_I_Msk = 0x80000000
	// Bit I.
	GPDMA_CCONTROL_I = 0x80000000

	// C0CONFIG: DMA Channel Configuration Register
	// Position of E field.
	GPDMA_CCONFIG_E_Pos = 0x0
	// Bit mask of E field.
	GPDMA_CCONFIG_E_Msk = 0x1
	// Bit E.
	GPDMA_CCONFIG_E = 0x1
	// Channel disabled.
	GPDMA_CCONFIG_E_CHANNEL_DISABLED_ = 0x0
	// Channel enabled.
	GPDMA_CCONFIG_E_CHANNEL_ENABLED_ = 0x1
	// Position of SRCPERIPHERAL field.
	GPDMA_CCONFIG_SRCPERIPHERAL_Pos = 0x1
	// Bit mask of SRCPERIPHERAL field.
	GPDMA_CCONFIG_SRCPERIPHERAL_Msk = 0x3e
	// Source = SPIFI
	GPDMA_CCONFIG_SRCPERIPHERAL_SOURCE_EQ_SPIFI = 0x0
	// Source = SSP0 receive/I2S channel 0
	GPDMA_CCONFIG_SRCPERIPHERAL_SOURCE_EQ_SSP0_RECEIV = 0x9
	// Source = SSP0 transmit/I2S channel 1
	GPDMA_CCONFIG_SRCPERIPHERAL_SOURCE_EQ_SSP0_TRANSM = 0xa
	// Source = SSP1 receive
	GPDMA_CCONFIG_SRCPERIPHERAL_SOURCE_EQ_SSP1_RECEIV = 0xb
	// Source = SSP1 transmit
	GPDMA_CCONFIG_SRCPERIPHERAL_SOURCE_EQ_SSP1_TRANSM = 0xc
	// Source = ADC0
	GPDMA_CCONFIG_SRCPERIPHERAL_SOURCE_EQ_ADC0 = 0xd
	// Source = ADC1
	GPDMA_CCONFIG_SRCPERIPHERAL_SOURCE_EQ_ADC1 = 0xe
	// Source = DAC
	GPDMA_CCONFIG_SRCPERIPHERAL_SOURCE_EQ_DAC = 0xf
	// Position of DESTPERIPHERAL field.
	GPDMA_CCONFIG_DESTPERIPHERAL_Pos = 0x6
	// Bit mask of DESTPERIPHERAL field.
	GPDMA_CCONFIG_DESTPERIPHERAL_Msk = 0x7c0
	// Destination = SPIFI
	GPDMA_CCONFIG_DESTPERIPHERAL_DESTINATION_EQ_SPIFI = 0x0
	// Destination = SSP0 receive/I2S channel 0
	GPDMA_CCONFIG_DESTPERIPHERAL_DESTINATION_EQ_SSP0_R = 0x9
	// Destination = SSP0 transmit/I2S channel 1
	GPDMA_CCONFIG_DESTPERIPHERAL_DESTINATION_EQ_SSP0_T = 0xa
	// Destination = SSP1 receive
	GPDMA_CCONFIG_DESTPERIPHERAL_DESTINATION_EQ_SSP1_R = 0xb
	// Destination = SSP1 transmit
	GPDMA_CCONFIG_DESTPERIPHERAL_DESTINATION_EQ_SSP1_T = 0xc
	// Destination = ADC0
	GPDMA_CCONFIG_DESTPERIPHERAL_DESTINATION_EQ_ADC0 = 0xd
	// Destination = ADC1
	GPDMA_CCONFIG_DESTPERIPHERAL_DESTINATION_EQ_ADC1 = 0xe
	// Destination = DAC
	GPDMA_CCONFIG_DESTPERIPHERAL_DESTINATION_EQ_DAC = 0xf
	// Position of FLOWCNTRL field.
	GPDMA_CCONFIG_FLOWCNTRL_Pos = 0xb
	// Bit mask of FLOWCNTRL field.
	GPDMA_CCONFIG_FLOWCNTRL_Msk = 0x3800
	// Memory to memory (DMA control)
	GPDMA_CCONFIG_FLOWCNTRL_MEMORY_TO_MEMORY = 0x0
	// Position of IE field.
	GPDMA_CCONFIG_IE_Pos = 0xe
	// Bit mask of IE field.
	GPDMA_CCONFIG_IE_Msk = 0x4000
	// Bit IE.
	GPDMA_CCONFIG_IE = 0x4000
	// Position of ITC field.
	GPDMA_CCONFIG_ITC_Pos = 0xf
	// Bit mask of ITC field.
	GPDMA_CCONFIG_ITC_Msk = 0x8000
	// Bit ITC.
	GPDMA_CCONFIG_ITC = 0x8000
	// Position of L field.
	GPDMA_CCONFIG_L_Pos = 0x10
	// Bit mask of L field.
	GPDMA_CCONFIG_L_Msk = 0x10000
	// Bit L.
	GPDMA_CCONFIG_L = 0x10000
	// Position of A field.
	GPDMA_CCONFIG_A_Pos = 0x11
	// Bit mask of A field.
	GPDMA_CCONFIG_A_Msk = 0x20000
	// Bit A.
	GPDMA_CCONFIG_A = 0x20000
	// Position of H field.
	GPDMA_CCONFIG_H_Pos = 0x12
	// Bit mask of H field.
	GPDMA_CCONFIG_H_Msk = 0x40000
	// Bit H.
	GPDMA_CCONFIG_H = 0x40000
	// Enable DMA requests.
	GPDMA_CCONFIG_H_ENABLE_DMA_REQUESTS_ = 0x0
	// Ignore further source DMA requests.
	GPDMA_CCONFIG_H_IGNORE_FURTHER_SOURC = 0x1
	// Position of RESERVED field.
	GPDMA_CCONFIG_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	GPDMA_CCONFIG_RESERVED_Msk = 0xfff80000
)

// Constants for SPIFI: SPI Flash Interface (SPIFI)
const (
	// CTRL: SPIFI control register
	// Position of TIMEOUT field.
	SPIFI_CTRL_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	SPIFI_CTRL_TIMEOUT_Msk = 0xffff
	// Position of CSHIGH field.
	SPIFI_CTRL_CSHIGH_Pos = 0x10
	// Bit mask of CSHIGH field.
	SPIFI_CTRL_CSHIGH_Msk = 0xf0000
	// Position of RESERVED field.
	SPIFI_CTRL_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	SPIFI_CTRL_RESERVED_Msk = 0x100000
	// Bit RESERVED.
	SPIFI_CTRL_RESERVED = 0x100000
	// Position of D_PRFTCH_DIS field.
	SPIFI_CTRL_D_PRFTCH_DIS_Pos = 0x15
	// Bit mask of D_PRFTCH_DIS field.
	SPIFI_CTRL_D_PRFTCH_DIS_Msk = 0x200000
	// Bit D_PRFTCH_DIS.
	SPIFI_CTRL_D_PRFTCH_DIS = 0x200000
	// Position of INTEN field.
	SPIFI_CTRL_INTEN_Pos = 0x16
	// Bit mask of INTEN field.
	SPIFI_CTRL_INTEN_Msk = 0x400000
	// Bit INTEN.
	SPIFI_CTRL_INTEN = 0x400000
	// Position of MODE3 field.
	SPIFI_CTRL_MODE3_Pos = 0x17
	// Bit mask of MODE3 field.
	SPIFI_CTRL_MODE3_Msk = 0x800000
	// Bit MODE3.
	SPIFI_CTRL_MODE3 = 0x800000
	// SCK LOW. The SPIFI drives SCK low after the rising edge at which the last bit of each command is captured, and keeps it low while CS is HIGH.
	SPIFI_CTRL_MODE3_SCK_LOW = 0x0
	// SCK HIGH. the SPIFI keeps SCK high after the rising edge for the last bit of each command and while CS is HIGH, and drives it low after it drives CS LOW. (Known serial flash devices can handle either mode, but some devices may require a particular mode for proper operation.) MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final rising edge on SCK on which to sample the last data bit of the frame.
	SPIFI_CTRL_MODE3_SCK_HIGH = 0x1
	// Position of RESERVED field.
	SPIFI_CTRL_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	SPIFI_CTRL_RESERVED_Msk = 0x7000000
	// Position of PRFTCH_DIS field.
	SPIFI_CTRL_PRFTCH_DIS_Pos = 0x1b
	// Bit mask of PRFTCH_DIS field.
	SPIFI_CTRL_PRFTCH_DIS_Msk = 0x8000000
	// Bit PRFTCH_DIS.
	SPIFI_CTRL_PRFTCH_DIS = 0x8000000
	// Enable. Cache prefetching enabled.
	SPIFI_CTRL_PRFTCH_DIS_ENABLE = 0x0
	// Disable. Disables prefetching of cache lines.
	SPIFI_CTRL_PRFTCH_DIS_DISABLE = 0x1
	// Position of DUAL field.
	SPIFI_CTRL_DUAL_Pos = 0x1c
	// Bit mask of DUAL field.
	SPIFI_CTRL_DUAL_Msk = 0x10000000
	// Bit DUAL.
	SPIFI_CTRL_DUAL = 0x10000000
	// Quad protocol. This protocol uses IO3:0.
	SPIFI_CTRL_DUAL_QUAD_PROTOCOL = 0x0
	// Dual protocol. This protocol uses IO1:0.
	SPIFI_CTRL_DUAL_DUAL_PROTOCOL = 0x1
	// Position of RFCLK field.
	SPIFI_CTRL_RFCLK_Pos = 0x1d
	// Bit mask of RFCLK field.
	SPIFI_CTRL_RFCLK_Msk = 0x20000000
	// Bit RFCLK.
	SPIFI_CTRL_RFCLK = 0x20000000
	// Rising edge. Read data is sampled on rising edges on the clock, as in classic SPI operation.
	SPIFI_CTRL_RFCLK_RISING_EDGE = 0x0
	// Falling edge. Read data is sampled on falling edges of the clock, allowing a full serial clock of of time in order to maximize the serial clock frequency. MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final rising edge on SCK on which to sample the last data bit of the frame.
	SPIFI_CTRL_RFCLK_FALLING_EDGE = 0x1
	// Position of FBCLK field.
	SPIFI_CTRL_FBCLK_Pos = 0x1e
	// Bit mask of FBCLK field.
	SPIFI_CTRL_FBCLK_Msk = 0x40000000
	// Bit FBCLK.
	SPIFI_CTRL_FBCLK = 0x40000000
	// Internal clock. The SPIFI samples read data using an internal clock.
	SPIFI_CTRL_FBCLK_INTERNAL_CLOCK = 0x0
	// Feedback clock. Read data is sampled using a feedback clock from the SCK pin. This allows slightly more time for each received bit. MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final rising edge on SCK on which to sample the last data bit of the frame.
	SPIFI_CTRL_FBCLK_FEEDBACK_CLOCK = 0x1
	// Position of DMAEN field.
	SPIFI_CTRL_DMAEN_Pos = 0x1f
	// Bit mask of DMAEN field.
	SPIFI_CTRL_DMAEN_Msk = 0x80000000
	// Bit DMAEN.
	SPIFI_CTRL_DMAEN = 0x80000000

	// CMD: SPIFI command register
	// Position of DATALEN field.
	SPIFI_CMD_DATALEN_Pos = 0x0
	// Bit mask of DATALEN field.
	SPIFI_CMD_DATALEN_Msk = 0x3fff
	// Position of POLL field.
	SPIFI_CMD_POLL_Pos = 0xe
	// Bit mask of POLL field.
	SPIFI_CMD_POLL_Msk = 0x4000
	// Bit POLL.
	SPIFI_CMD_POLL = 0x4000
	// Position of DOUT field.
	SPIFI_CMD_DOUT_Pos = 0xf
	// Bit mask of DOUT field.
	SPIFI_CMD_DOUT_Msk = 0x8000
	// Bit DOUT.
	SPIFI_CMD_DOUT = 0x8000
	// Input from serial flash.
	SPIFI_CMD_DOUT_INPUT_FROM_SERIAL_FL = 0x0
	// Output to serial flash.
	SPIFI_CMD_DOUT_OUTPUT_TO_SERIAL_FLA = 0x1
	// Position of INTLEN field.
	SPIFI_CMD_INTLEN_Pos = 0x10
	// Bit mask of INTLEN field.
	SPIFI_CMD_INTLEN_Msk = 0x70000
	// Position of FIELDFORM field.
	SPIFI_CMD_FIELDFORM_Pos = 0x13
	// Bit mask of FIELDFORM field.
	SPIFI_CMD_FIELDFORM_Msk = 0x180000
	// All serial. All fields of the command are serial.
	SPIFI_CMD_FIELDFORM_ALL_SERIAL = 0x0
	// Quad/dual data. Data field is quad/dual, other fields are serial.
	SPIFI_CMD_FIELDFORM_QUADDUAL_DATA = 0x1
	// Serial opcode. Opcode field is serial. Other fields are quad/dual.
	SPIFI_CMD_FIELDFORM_SERIAL_OPCODE = 0x2
	// All quad/dual. All fields of the command are in quad/dual format.
	SPIFI_CMD_FIELDFORM_ALL_QUADDUAL = 0x3
	// Position of FRAMEFORM field.
	SPIFI_CMD_FRAMEFORM_Pos = 0x15
	// Bit mask of FRAMEFORM field.
	SPIFI_CMD_FRAMEFORM_Msk = 0xe00000
	// Opcode. Opcode only, no address.
	SPIFI_CMD_FRAMEFORM_OPCODE = 0x1
	// Opcode one byte. Opcode, least significant byte of address.
	SPIFI_CMD_FRAMEFORM_OPCODE_ONE_BYTE = 0x2
	// Opcode two bytes. Opcode, two least significant bytes of address.
	SPIFI_CMD_FRAMEFORM_OPCODE_TWO_BYTES = 0x3
	// Opcode three bytes. Opcode, three least significant bytes of address.
	SPIFI_CMD_FRAMEFORM_OPCODE_THREE_BYTES = 0x4
	// Opcode four bytes. Opcode, 4 bytes of address.
	SPIFI_CMD_FRAMEFORM_OPCODE_FOUR_BYTES = 0x5
	// No opcode three bytes. No opcode, 3 least significant bytes of address.
	SPIFI_CMD_FRAMEFORM_NO_OPCODE_THREE_BYTE = 0x6
	// No opcode four bytes. No opcode, 4 bytes of address.
	SPIFI_CMD_FRAMEFORM_NO_OPCODE_FOUR_BYTES = 0x7
	// Position of OPCODE field.
	SPIFI_CMD_OPCODE_Pos = 0x18
	// Bit mask of OPCODE field.
	SPIFI_CMD_OPCODE_Msk = 0xff000000

	// ADDR: SPIFI address register
	// Position of ADDRESS field.
	SPIFI_ADDR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SPIFI_ADDR_ADDRESS_Msk = 0xffffffff

	// IDATA: SPIFI intermediate data register
	// Position of IDATA field.
	SPIFI_IDATA_IDATA_Pos = 0x0
	// Bit mask of IDATA field.
	SPIFI_IDATA_IDATA_Msk = 0xffffffff

	// CLIMIT: SPIFI cache limit register
	// Position of CLIMIT field.
	SPIFI_CLIMIT_CLIMIT_Pos = 0x0
	// Bit mask of CLIMIT field.
	SPIFI_CLIMIT_CLIMIT_Msk = 0xffffffff

	// DATA: SPIFI data register
	// Position of DATA field.
	SPIFI_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SPIFI_DATA_DATA_Msk = 0xffffffff

	// MCMD: SPIFI memory command register
	// Position of RESERVED field.
	SPIFI_MCMD_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	SPIFI_MCMD_RESERVED_Msk = 0x3fff
	// Position of POLL field.
	SPIFI_MCMD_POLL_Pos = 0xe
	// Bit mask of POLL field.
	SPIFI_MCMD_POLL_Msk = 0x4000
	// Bit POLL.
	SPIFI_MCMD_POLL = 0x4000
	// Position of DOUT field.
	SPIFI_MCMD_DOUT_Pos = 0xf
	// Bit mask of DOUT field.
	SPIFI_MCMD_DOUT_Msk = 0x8000
	// Bit DOUT.
	SPIFI_MCMD_DOUT = 0x8000
	// Position of INTLEN field.
	SPIFI_MCMD_INTLEN_Pos = 0x10
	// Bit mask of INTLEN field.
	SPIFI_MCMD_INTLEN_Msk = 0x70000
	// Position of FIELDFORM field.
	SPIFI_MCMD_FIELDFORM_Pos = 0x13
	// Bit mask of FIELDFORM field.
	SPIFI_MCMD_FIELDFORM_Msk = 0x180000
	// All serial. All fields of the command are serial.
	SPIFI_MCMD_FIELDFORM_ALL_SERIAL = 0x0
	// Quad/dual data. Data field is quad/dual, other fields are serial.
	SPIFI_MCMD_FIELDFORM_QUADDUAL_DATA = 0x1
	// Serial opcode. Opcode field is serial. Other fields are quad/dual.
	SPIFI_MCMD_FIELDFORM_SERIAL_OPCODE = 0x2
	// All quad/dual. All fields of the command are in quad/dual format.
	SPIFI_MCMD_FIELDFORM_ALL_QUADDUAL = 0x3
	// Position of FRAMEFORM field.
	SPIFI_MCMD_FRAMEFORM_Pos = 0x15
	// Bit mask of FRAMEFORM field.
	SPIFI_MCMD_FRAMEFORM_Msk = 0xe00000
	// Opcode one byte. Opcode, least-significant byte of address.
	SPIFI_MCMD_FRAMEFORM_OPCODE_ONE_BYTE = 0x2
	// Opcode two bytes. Opcode, 2 least-significant bytes of address.
	SPIFI_MCMD_FRAMEFORM_OPCODE_TWO_BYTES = 0x3
	// Opcode three bytes. Opcode, 3 least-significant bytes of address.
	SPIFI_MCMD_FRAMEFORM_OPCODE_THREE_BYTES = 0x4
	// Opcode four bytes. Opcode, 4 bytes of address.
	SPIFI_MCMD_FRAMEFORM_OPCODE_FOUR_BYTES = 0x5
	// No opcode three bytes. No opcode, 3 least-significant bytes of address.
	SPIFI_MCMD_FRAMEFORM_NO_OPCODE_THREE_BYTE = 0x6
	// No opcode, 4 bytes of address.
	SPIFI_MCMD_FRAMEFORM_NO_OPCODE_FOUR_BYTES = 0x7
	// Position of OPCODE field.
	SPIFI_MCMD_OPCODE_Pos = 0x18
	// Bit mask of OPCODE field.
	SPIFI_MCMD_OPCODE_Msk = 0xff000000

	// STAT: SPIFI status register
	// Position of MCINIT field.
	SPIFI_STAT_MCINIT_Pos = 0x0
	// Bit mask of MCINIT field.
	SPIFI_STAT_MCINIT_Msk = 0x1
	// Bit MCINIT.
	SPIFI_STAT_MCINIT = 0x1
	// Position of CMD field.
	SPIFI_STAT_CMD_Pos = 0x1
	// Bit mask of CMD field.
	SPIFI_STAT_CMD_Msk = 0x2
	// Bit CMD.
	SPIFI_STAT_CMD = 0x2
	// Position of RESET field.
	SPIFI_STAT_RESET_Pos = 0x4
	// Bit mask of RESET field.
	SPIFI_STAT_RESET_Msk = 0x10
	// Bit RESET.
	SPIFI_STAT_RESET = 0x10
	// Position of INTRQ field.
	SPIFI_STAT_INTRQ_Pos = 0x5
	// Bit mask of INTRQ field.
	SPIFI_STAT_INTRQ_Msk = 0x20
	// Bit INTRQ.
	SPIFI_STAT_INTRQ = 0x20
	// Position of RESERVED field.
	SPIFI_STAT_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	SPIFI_STAT_RESERVED_Msk = 0xffffc0
	// Position of VERSION field.
	SPIFI_STAT_VERSION_Pos = 0x18
	// Bit mask of VERSION field.
	SPIFI_STAT_VERSION_Msk = 0xff000000
)

// Constants for SDMMC: SD/MMC
const (
	// CTRL: Control Register
	// Position of CONTROLLER_RESET field.
	SDMMC_CTRL_CONTROLLER_RESET_Pos = 0x0
	// Bit mask of CONTROLLER_RESET field.
	SDMMC_CTRL_CONTROLLER_RESET_Msk = 0x1
	// Bit CONTROLLER_RESET.
	SDMMC_CTRL_CONTROLLER_RESET = 0x1
	// No change.
	SDMMC_CTRL_CONTROLLER_RESET_NO_CHANGE = 0x0
	// Reset. Reset SD/MMC controller
	SDMMC_CTRL_CONTROLLER_RESET_RESET = 0x1
	// Position of FIFO_RESET field.
	SDMMC_CTRL_FIFO_RESET_Pos = 0x1
	// Bit mask of FIFO_RESET field.
	SDMMC_CTRL_FIFO_RESET_Msk = 0x2
	// Bit FIFO_RESET.
	SDMMC_CTRL_FIFO_RESET = 0x2
	// No change.
	SDMMC_CTRL_FIFO_RESET_NO_CHANGE = 0x0
	// Reset. Reset to data FIFO To reset FIFO pointers
	SDMMC_CTRL_FIFO_RESET_RESET = 0x1
	// Position of DMA_RESET field.
	SDMMC_CTRL_DMA_RESET_Pos = 0x2
	// Bit mask of DMA_RESET field.
	SDMMC_CTRL_DMA_RESET_Msk = 0x4
	// Bit DMA_RESET.
	SDMMC_CTRL_DMA_RESET = 0x4
	// No change.
	SDMMC_CTRL_DMA_RESET_NO_CHANGE = 0x0
	// Reset. Reset internal DMA interface control logic
	SDMMC_CTRL_DMA_RESET_RESET = 0x1
	// Position of RESERVED field.
	SDMMC_CTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	SDMMC_CTRL_RESERVED_Msk = 0x8
	// Bit RESERVED.
	SDMMC_CTRL_RESERVED = 0x8
	// Position of INT_ENABLE field.
	SDMMC_CTRL_INT_ENABLE_Pos = 0x4
	// Bit mask of INT_ENABLE field.
	SDMMC_CTRL_INT_ENABLE_Msk = 0x10
	// Bit INT_ENABLE.
	SDMMC_CTRL_INT_ENABLE = 0x10
	// Disable interrupts
	SDMMC_CTRL_INT_ENABLE_DISABLE_INTERRUPTS = 0x0
	// Enable interrupts
	SDMMC_CTRL_INT_ENABLE_ENABLE_INTERRUPTS = 0x1
	// Position of RESERVED field.
	SDMMC_CTRL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SDMMC_CTRL_RESERVED_Msk = 0x20
	// Bit RESERVED.
	SDMMC_CTRL_RESERVED = 0x20
	// Position of READ_WAIT field.
	SDMMC_CTRL_READ_WAIT_Pos = 0x6
	// Bit mask of READ_WAIT field.
	SDMMC_CTRL_READ_WAIT_Msk = 0x40
	// Bit READ_WAIT.
	SDMMC_CTRL_READ_WAIT = 0x40
	// Clear read wait
	SDMMC_CTRL_READ_WAIT_CLEAR_READ_WAIT = 0x0
	// Assert read wait
	SDMMC_CTRL_READ_WAIT_ASSERT_READ_WAIT = 0x1
	// Position of SEND_IRQ_RESPONSE field.
	SDMMC_CTRL_SEND_IRQ_RESPONSE_Pos = 0x7
	// Bit mask of SEND_IRQ_RESPONSE field.
	SDMMC_CTRL_SEND_IRQ_RESPONSE_Msk = 0x80
	// Bit SEND_IRQ_RESPONSE.
	SDMMC_CTRL_SEND_IRQ_RESPONSE = 0x80
	// No change
	SDMMC_CTRL_SEND_IRQ_RESPONSE_NO_CHANGE = 0x0
	// Send auto IRQ response
	SDMMC_CTRL_SEND_IRQ_RESPONSE_SEND_AUTO_IRQ_RESPON = 0x1
	// Position of ABORT_READ_DATA field.
	SDMMC_CTRL_ABORT_READ_DATA_Pos = 0x8
	// Bit mask of ABORT_READ_DATA field.
	SDMMC_CTRL_ABORT_READ_DATA_Msk = 0x100
	// Bit ABORT_READ_DATA.
	SDMMC_CTRL_ABORT_READ_DATA = 0x100
	// No change
	SDMMC_CTRL_ABORT_READ_DATA_NO_CHANGE = 0x0
	// Abort. After suspend command is issued during read-transfer, software polls card to find when suspend happened. Once suspend occurs, software sets bit to reset data state-machine, which is waiting for next block of data. This bit automatically clears once data state machine resets to idle. Used in SDIO card suspend sequence.
	SDMMC_CTRL_ABORT_READ_DATA_ABORT = 0x1
	// Position of SEND_CCSD field.
	SDMMC_CTRL_SEND_CCSD_Pos = 0x9
	// Bit mask of SEND_CCSD field.
	SDMMC_CTRL_SEND_CCSD_Msk = 0x200
	// Bit SEND_CCSD.
	SDMMC_CTRL_SEND_CCSD = 0x200
	// Clear bit if the SD/MMC controller does not reset the bit.
	SDMMC_CTRL_SEND_CCSD_CLEAR_BIT = 0x0
	// Send Command Completion Signal Disable (CCSD) to CE-ATA device
	SDMMC_CTRL_SEND_CCSD_SEND_COMMAND_COMPLET = 0x1
	// Position of SEND_AUTO_STOP field.
	SDMMC_CTRL_SEND_AUTO_STOP_Pos = 0xa
	// Bit mask of SEND_AUTO_STOP field.
	SDMMC_CTRL_SEND_AUTO_STOP_Msk = 0x400
	// Bit SEND_AUTO_STOP.
	SDMMC_CTRL_SEND_AUTO_STOP = 0x400
	// Clear this bit if the SD/MMC controller does not reset the bit.
	SDMMC_CTRL_SEND_AUTO_STOP_CLEAR_THIS_BIT_IF_TH = 0x0
	// Send internally generated STOP after sending CCSD to CE-ATA device.
	SDMMC_CTRL_SEND_AUTO_STOP_SEND_INTERNALLY_GENE = 0x1
	// Position of CEATA_DEVICE_INTERRUPT_STATUS field.
	SDMMC_CTRL_CEATA_DEVICE_INTERRUPT_STATUS_Pos = 0xb
	// Bit mask of CEATA_DEVICE_INTERRUPT_STATUS field.
	SDMMC_CTRL_CEATA_DEVICE_INTERRUPT_STATUS_Msk = 0x800
	// Bit CEATA_DEVICE_INTERRUPT_STATUS.
	SDMMC_CTRL_CEATA_DEVICE_INTERRUPT_STATUS = 0x800
	// Disabled. Interrupts not enabled in CE-ATA device (nIEN = 1 in ATA control register)
	SDMMC_CTRL_CEATA_DEVICE_INTERRUPT_STATUS_DISABLED = 0x0
	// Enabled. Interrupts are enabled in CE-ATA device (nIEN = 0 in ATA control register)
	SDMMC_CTRL_CEATA_DEVICE_INTERRUPT_STATUS_ENABLED = 0x1
	// Position of RESERVED field.
	SDMMC_CTRL_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	SDMMC_CTRL_RESERVED_Msk = 0xf000
	// Position of CARD_VOLTAGE_A0 field.
	SDMMC_CTRL_CARD_VOLTAGE_A0_Pos = 0x10
	// Bit mask of CARD_VOLTAGE_A0 field.
	SDMMC_CTRL_CARD_VOLTAGE_A0_Msk = 0x10000
	// Bit CARD_VOLTAGE_A0.
	SDMMC_CTRL_CARD_VOLTAGE_A0 = 0x10000
	// Position of CARD_VOLTAGE_A1 field.
	SDMMC_CTRL_CARD_VOLTAGE_A1_Pos = 0x11
	// Bit mask of CARD_VOLTAGE_A1 field.
	SDMMC_CTRL_CARD_VOLTAGE_A1_Msk = 0x20000
	// Bit CARD_VOLTAGE_A1.
	SDMMC_CTRL_CARD_VOLTAGE_A1 = 0x20000
	// Position of CARD_VOLTAGE_A2 field.
	SDMMC_CTRL_CARD_VOLTAGE_A2_Pos = 0x12
	// Bit mask of CARD_VOLTAGE_A2 field.
	SDMMC_CTRL_CARD_VOLTAGE_A2_Msk = 0x40000
	// Bit CARD_VOLTAGE_A2.
	SDMMC_CTRL_CARD_VOLTAGE_A2 = 0x40000
	// Position of RESERVED field.
	SDMMC_CTRL_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	SDMMC_CTRL_RESERVED_Msk = 0xf80000
	// Position of RESERVED field.
	SDMMC_CTRL_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	SDMMC_CTRL_RESERVED_Msk = 0x1000000
	// Bit RESERVED.
	SDMMC_CTRL_RESERVED = 0x1000000
	// Position of USE_INTERNAL_DMAC field.
	SDMMC_CTRL_USE_INTERNAL_DMAC_Pos = 0x19
	// Bit mask of USE_INTERNAL_DMAC field.
	SDMMC_CTRL_USE_INTERNAL_DMAC_Msk = 0x2000000
	// Bit USE_INTERNAL_DMAC.
	SDMMC_CTRL_USE_INTERNAL_DMAC = 0x2000000
	// Host. The host performs data transfers through the slave interface
	SDMMC_CTRL_USE_INTERNAL_DMAC_HOST = 0x0
	// DMA. Internal DMA used for data transfer
	SDMMC_CTRL_USE_INTERNAL_DMAC_DMA = 0x1
	// Position of RESERVED field.
	SDMMC_CTRL_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	SDMMC_CTRL_RESERVED_Msk = 0xfc000000

	// PWREN: Power Enable Register
	// Position of POWER_ENABLE field.
	SDMMC_PWREN_POWER_ENABLE_Pos = 0x0
	// Bit mask of POWER_ENABLE field.
	SDMMC_PWREN_POWER_ENABLE_Msk = 0x1
	// Bit POWER_ENABLE.
	SDMMC_PWREN_POWER_ENABLE = 0x1
	// Position of RESERVED field.
	SDMMC_PWREN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SDMMC_PWREN_RESERVED_Msk = 0xfffffffe

	// CLKDIV: Clock Divider Register
	// Position of CLK_DIVIDER0 field.
	SDMMC_CLKDIV_CLK_DIVIDER0_Pos = 0x0
	// Bit mask of CLK_DIVIDER0 field.
	SDMMC_CLKDIV_CLK_DIVIDER0_Msk = 0xff
	// Position of CLK_DIVIDER1 field.
	SDMMC_CLKDIV_CLK_DIVIDER1_Pos = 0x8
	// Bit mask of CLK_DIVIDER1 field.
	SDMMC_CLKDIV_CLK_DIVIDER1_Msk = 0xff00
	// Position of CLK_DIVIDER2 field.
	SDMMC_CLKDIV_CLK_DIVIDER2_Pos = 0x10
	// Bit mask of CLK_DIVIDER2 field.
	SDMMC_CLKDIV_CLK_DIVIDER2_Msk = 0xff0000
	// Position of CLK_DIVIDER3 field.
	SDMMC_CLKDIV_CLK_DIVIDER3_Pos = 0x18
	// Bit mask of CLK_DIVIDER3 field.
	SDMMC_CLKDIV_CLK_DIVIDER3_Msk = 0xff000000

	// CLKSRC: SD Clock Source Register
	// Position of CLK_SOURCE field.
	SDMMC_CLKSRC_CLK_SOURCE_Pos = 0x0
	// Bit mask of CLK_SOURCE field.
	SDMMC_CLKSRC_CLK_SOURCE_Msk = 0x3
	// Position of RESERVED field.
	SDMMC_CLKSRC_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SDMMC_CLKSRC_RESERVED_Msk = 0xfffffffe

	// CLKENA: Clock Enable Register
	// Position of CCLK_ENABLE field.
	SDMMC_CLKENA_CCLK_ENABLE_Pos = 0x0
	// Bit mask of CCLK_ENABLE field.
	SDMMC_CLKENA_CCLK_ENABLE_Msk = 0x1
	// Bit CCLK_ENABLE.
	SDMMC_CLKENA_CCLK_ENABLE = 0x1
	// Position of RESERVED field.
	SDMMC_CLKENA_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SDMMC_CLKENA_RESERVED_Msk = 0xfffe
	// Position of CCLK_LOW_POWER field.
	SDMMC_CLKENA_CCLK_LOW_POWER_Pos = 0x10
	// Bit mask of CCLK_LOW_POWER field.
	SDMMC_CLKENA_CCLK_LOW_POWER_Msk = 0x10000
	// Bit CCLK_LOW_POWER.
	SDMMC_CLKENA_CCLK_LOW_POWER = 0x10000
	// Position of RESERVED field.
	SDMMC_CLKENA_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	SDMMC_CLKENA_RESERVED_Msk = 0xfffe0000

	// TMOUT: Time-out Register
	// Position of RESPONSE_TIMEOUT field.
	SDMMC_TMOUT_RESPONSE_TIMEOUT_Pos = 0x0
	// Bit mask of RESPONSE_TIMEOUT field.
	SDMMC_TMOUT_RESPONSE_TIMEOUT_Msk = 0xff
	// Position of DATA_TIMEOUT field.
	SDMMC_TMOUT_DATA_TIMEOUT_Pos = 0x8
	// Bit mask of DATA_TIMEOUT field.
	SDMMC_TMOUT_DATA_TIMEOUT_Msk = 0xffffff00

	// CTYPE: Card Type Register
	// Position of CARD_WIDTH0 field.
	SDMMC_CTYPE_CARD_WIDTH0_Pos = 0x0
	// Bit mask of CARD_WIDTH0 field.
	SDMMC_CTYPE_CARD_WIDTH0_Msk = 0x1
	// Bit CARD_WIDTH0.
	SDMMC_CTYPE_CARD_WIDTH0 = 0x1
	// Position of RESERVED field.
	SDMMC_CTYPE_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SDMMC_CTYPE_RESERVED_Msk = 0xfffe
	// Position of CARD_WIDTH1 field.
	SDMMC_CTYPE_CARD_WIDTH1_Pos = 0x10
	// Bit mask of CARD_WIDTH1 field.
	SDMMC_CTYPE_CARD_WIDTH1_Msk = 0x10000
	// Bit CARD_WIDTH1.
	SDMMC_CTYPE_CARD_WIDTH1 = 0x10000
	// Position of RESERVED field.
	SDMMC_CTYPE_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	SDMMC_CTYPE_RESERVED_Msk = 0xfffe0000

	// BLKSIZ: Block Size Register
	// Position of BLOCK_SIZE field.
	SDMMC_BLKSIZ_BLOCK_SIZE_Pos = 0x0
	// Bit mask of BLOCK_SIZE field.
	SDMMC_BLKSIZ_BLOCK_SIZE_Msk = 0xffff
	// Position of RESERVED field.
	SDMMC_BLKSIZ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SDMMC_BLKSIZ_RESERVED_Msk = 0xffff0000

	// BYTCNT: Byte Count Register
	// Position of BYTE_COUNT field.
	SDMMC_BYTCNT_BYTE_COUNT_Pos = 0x0
	// Bit mask of BYTE_COUNT field.
	SDMMC_BYTCNT_BYTE_COUNT_Msk = 0xffffffff

	// INTMASK: Interrupt Mask Register
	// Position of CDET field.
	SDMMC_INTMASK_CDET_Pos = 0x0
	// Bit mask of CDET field.
	SDMMC_INTMASK_CDET_Msk = 0x1
	// Bit CDET.
	SDMMC_INTMASK_CDET = 0x1
	// Position of RE field.
	SDMMC_INTMASK_RE_Pos = 0x1
	// Bit mask of RE field.
	SDMMC_INTMASK_RE_Msk = 0x2
	// Bit RE.
	SDMMC_INTMASK_RE = 0x2
	// Position of CDONE field.
	SDMMC_INTMASK_CDONE_Pos = 0x2
	// Bit mask of CDONE field.
	SDMMC_INTMASK_CDONE_Msk = 0x4
	// Bit CDONE.
	SDMMC_INTMASK_CDONE = 0x4
	// Position of DTO field.
	SDMMC_INTMASK_DTO_Pos = 0x3
	// Bit mask of DTO field.
	SDMMC_INTMASK_DTO_Msk = 0x8
	// Bit DTO.
	SDMMC_INTMASK_DTO = 0x8
	// Position of TXDR field.
	SDMMC_INTMASK_TXDR_Pos = 0x4
	// Bit mask of TXDR field.
	SDMMC_INTMASK_TXDR_Msk = 0x10
	// Bit TXDR.
	SDMMC_INTMASK_TXDR = 0x10
	// Position of RXDR field.
	SDMMC_INTMASK_RXDR_Pos = 0x5
	// Bit mask of RXDR field.
	SDMMC_INTMASK_RXDR_Msk = 0x20
	// Bit RXDR.
	SDMMC_INTMASK_RXDR = 0x20
	// Position of RCRC field.
	SDMMC_INTMASK_RCRC_Pos = 0x6
	// Bit mask of RCRC field.
	SDMMC_INTMASK_RCRC_Msk = 0x40
	// Bit RCRC.
	SDMMC_INTMASK_RCRC = 0x40
	// Position of DCRC field.
	SDMMC_INTMASK_DCRC_Pos = 0x7
	// Bit mask of DCRC field.
	SDMMC_INTMASK_DCRC_Msk = 0x80
	// Bit DCRC.
	SDMMC_INTMASK_DCRC = 0x80
	// Position of RTO field.
	SDMMC_INTMASK_RTO_Pos = 0x8
	// Bit mask of RTO field.
	SDMMC_INTMASK_RTO_Msk = 0x100
	// Bit RTO.
	SDMMC_INTMASK_RTO = 0x100
	// Position of DRTO field.
	SDMMC_INTMASK_DRTO_Pos = 0x9
	// Bit mask of DRTO field.
	SDMMC_INTMASK_DRTO_Msk = 0x200
	// Bit DRTO.
	SDMMC_INTMASK_DRTO = 0x200
	// Position of HTO field.
	SDMMC_INTMASK_HTO_Pos = 0xa
	// Bit mask of HTO field.
	SDMMC_INTMASK_HTO_Msk = 0x400
	// Bit HTO.
	SDMMC_INTMASK_HTO = 0x400
	// Position of FRUN field.
	SDMMC_INTMASK_FRUN_Pos = 0xb
	// Bit mask of FRUN field.
	SDMMC_INTMASK_FRUN_Msk = 0x800
	// Bit FRUN.
	SDMMC_INTMASK_FRUN = 0x800
	// Position of HLE field.
	SDMMC_INTMASK_HLE_Pos = 0xc
	// Bit mask of HLE field.
	SDMMC_INTMASK_HLE_Msk = 0x1000
	// Bit HLE.
	SDMMC_INTMASK_HLE = 0x1000
	// Position of SBE field.
	SDMMC_INTMASK_SBE_Pos = 0xd
	// Bit mask of SBE field.
	SDMMC_INTMASK_SBE_Msk = 0x2000
	// Bit SBE.
	SDMMC_INTMASK_SBE = 0x2000
	// Position of ACD field.
	SDMMC_INTMASK_ACD_Pos = 0xe
	// Bit mask of ACD field.
	SDMMC_INTMASK_ACD_Msk = 0x4000
	// Bit ACD.
	SDMMC_INTMASK_ACD = 0x4000
	// Position of EBE field.
	SDMMC_INTMASK_EBE_Pos = 0xf
	// Bit mask of EBE field.
	SDMMC_INTMASK_EBE_Msk = 0x8000
	// Bit EBE.
	SDMMC_INTMASK_EBE = 0x8000
	// Position of SDIO_INT_MASK field.
	SDMMC_INTMASK_SDIO_INT_MASK_Pos = 0x10
	// Bit mask of SDIO_INT_MASK field.
	SDMMC_INTMASK_SDIO_INT_MASK_Msk = 0x10000
	// Bit SDIO_INT_MASK.
	SDMMC_INTMASK_SDIO_INT_MASK = 0x10000
	// Position of RESERVED field.
	SDMMC_INTMASK_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	SDMMC_INTMASK_RESERVED_Msk = 0xfffe0000

	// CMDARG: Command Argument Register
	// Position of CMD_ARG field.
	SDMMC_CMDARG_CMD_ARG_Pos = 0x0
	// Bit mask of CMD_ARG field.
	SDMMC_CMDARG_CMD_ARG_Msk = 0xffffffff

	// CMD: Command Register
	// Position of CMD_INDEX field.
	SDMMC_CMD_CMD_INDEX_Pos = 0x0
	// Bit mask of CMD_INDEX field.
	SDMMC_CMD_CMD_INDEX_Msk = 0x3f
	// Position of RESPONSE_EXPECT field.
	SDMMC_CMD_RESPONSE_EXPECT_Pos = 0x6
	// Bit mask of RESPONSE_EXPECT field.
	SDMMC_CMD_RESPONSE_EXPECT_Msk = 0x40
	// Bit RESPONSE_EXPECT.
	SDMMC_CMD_RESPONSE_EXPECT = 0x40
	// None. No response expected from card
	SDMMC_CMD_RESPONSE_EXPECT_NONE = 0x0
	// Expected. Response expected from card
	SDMMC_CMD_RESPONSE_EXPECT_EXPECTED = 0x1
	// Position of RESPONSE_LENGTH field.
	SDMMC_CMD_RESPONSE_LENGTH_Pos = 0x7
	// Bit mask of RESPONSE_LENGTH field.
	SDMMC_CMD_RESPONSE_LENGTH_Msk = 0x80
	// Bit RESPONSE_LENGTH.
	SDMMC_CMD_RESPONSE_LENGTH = 0x80
	// Short. Short response expected from card
	SDMMC_CMD_RESPONSE_LENGTH_SHORT = 0x0
	// Long. Long response expected from card
	SDMMC_CMD_RESPONSE_LENGTH_LONG = 0x1
	// Position of CHECK_RESPONSE_CRC field.
	SDMMC_CMD_CHECK_RESPONSE_CRC_Pos = 0x8
	// Bit mask of CHECK_RESPONSE_CRC field.
	SDMMC_CMD_CHECK_RESPONSE_CRC_Msk = 0x100
	// Bit CHECK_RESPONSE_CRC.
	SDMMC_CMD_CHECK_RESPONSE_CRC = 0x100
	// Do not check response CRC
	SDMMC_CMD_CHECK_RESPONSE_CRC_DO_NOT_CHECK_RESPONS = 0x0
	// Check response CRC
	SDMMC_CMD_CHECK_RESPONSE_CRC_CHECK_RESPONSE_CRC = 0x1
	// Position of DATA_EXPECTED field.
	SDMMC_CMD_DATA_EXPECTED_Pos = 0x9
	// Bit mask of DATA_EXPECTED field.
	SDMMC_CMD_DATA_EXPECTED_Msk = 0x200
	// Bit DATA_EXPECTED.
	SDMMC_CMD_DATA_EXPECTED = 0x200
	// None. No data transfer expected (read/write)
	SDMMC_CMD_DATA_EXPECTED_NONE = 0x0
	// Data. Data transfer expected (read/write)
	SDMMC_CMD_DATA_EXPECTED_DATA = 0x1
	// Position of READ_WRITE field.
	SDMMC_CMD_READ_WRITE_Pos = 0xa
	// Bit mask of READ_WRITE field.
	SDMMC_CMD_READ_WRITE_Msk = 0x400
	// Bit READ_WRITE.
	SDMMC_CMD_READ_WRITE = 0x400
	// Read from card
	SDMMC_CMD_READ_WRITE_READ_FROM_CARD = 0x0
	// Write to card
	SDMMC_CMD_READ_WRITE_WRITE_TO_CARD = 0x1
	// Position of TRANSFER_MODE field.
	SDMMC_CMD_TRANSFER_MODE_Pos = 0xb
	// Bit mask of TRANSFER_MODE field.
	SDMMC_CMD_TRANSFER_MODE_Msk = 0x800
	// Bit TRANSFER_MODE.
	SDMMC_CMD_TRANSFER_MODE = 0x800
	// Block data transfer command
	SDMMC_CMD_TRANSFER_MODE_BLOCK_DATA_TRANSFER = 0x0
	// Stream data transfer command
	SDMMC_CMD_TRANSFER_MODE_STREAM_DATA_TRANSFER = 0x1
	// Position of SEND_AUTO_STOP field.
	SDMMC_CMD_SEND_AUTO_STOP_Pos = 0xc
	// Bit mask of SEND_AUTO_STOP field.
	SDMMC_CMD_SEND_AUTO_STOP_Msk = 0x1000
	// Bit SEND_AUTO_STOP.
	SDMMC_CMD_SEND_AUTO_STOP = 0x1000
	// No stop command sent at end of data transfer
	SDMMC_CMD_SEND_AUTO_STOP_NO_STOP_COMMAND_SENT = 0x0
	// Send stop command at end of data transfer
	SDMMC_CMD_SEND_AUTO_STOP_SEND_STOP_COMMAND_AT = 0x1
	// Position of WAIT_PRVDATA_COMPLETE field.
	SDMMC_CMD_WAIT_PRVDATA_COMPLETE_Pos = 0xd
	// Bit mask of WAIT_PRVDATA_COMPLETE field.
	SDMMC_CMD_WAIT_PRVDATA_COMPLETE_Msk = 0x2000
	// Bit WAIT_PRVDATA_COMPLETE.
	SDMMC_CMD_WAIT_PRVDATA_COMPLETE = 0x2000
	// Send. Send command at once, even if previous data transfer has not completed.
	SDMMC_CMD_WAIT_PRVDATA_COMPLETE_SEND = 0x0
	// Wait. Wait for previous data transfer completion before sending command.
	SDMMC_CMD_WAIT_PRVDATA_COMPLETE_WAIT = 0x1
	// Position of STOP_ABORT_CMD field.
	SDMMC_CMD_STOP_ABORT_CMD_Pos = 0xe
	// Bit mask of STOP_ABORT_CMD field.
	SDMMC_CMD_STOP_ABORT_CMD_Msk = 0x4000
	// Bit STOP_ABORT_CMD.
	SDMMC_CMD_STOP_ABORT_CMD = 0x4000
	// Disabled. Neither stop nor abort command to stop current data transfer in progress. If abort is sent to function-number currently selected or not in data-transfer mode, then bit should be set to 0.
	SDMMC_CMD_STOP_ABORT_CMD_DISABLED = 0x0
	// Enabled. Stop or abort command intended to stop current data transfer in progress.
	SDMMC_CMD_STOP_ABORT_CMD_ENABLED = 0x1
	// Position of SEND_INITIALIZATION field.
	SDMMC_CMD_SEND_INITIALIZATION_Pos = 0xf
	// Bit mask of SEND_INITIALIZATION field.
	SDMMC_CMD_SEND_INITIALIZATION_Msk = 0x8000
	// Bit SEND_INITIALIZATION.
	SDMMC_CMD_SEND_INITIALIZATION = 0x8000
	// No. Do not send initialization sequence (80 clocks of 1) before sending this command.
	SDMMC_CMD_SEND_INITIALIZATION_NO = 0x0
	// Send. Send initialization sequence before sending this command.
	SDMMC_CMD_SEND_INITIALIZATION_SEND = 0x1
	// Position of RESERVED field.
	SDMMC_CMD_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SDMMC_CMD_RESERVED_Msk = 0x1f0000
	// Position of UPDATE_CLOCK_REGISTERS_ONLY field.
	SDMMC_CMD_UPDATE_CLOCK_REGISTERS_ONLY_Pos = 0x15
	// Bit mask of UPDATE_CLOCK_REGISTERS_ONLY field.
	SDMMC_CMD_UPDATE_CLOCK_REGISTERS_ONLY_Msk = 0x200000
	// Bit UPDATE_CLOCK_REGISTERS_ONLY.
	SDMMC_CMD_UPDATE_CLOCK_REGISTERS_ONLY = 0x200000
	// Normal. Normal command sequence
	SDMMC_CMD_UPDATE_CLOCK_REGISTERS_ONLY_NORMAL = 0x0
	// No. Do not send commands, just update clock register value into card clock domain
	SDMMC_CMD_UPDATE_CLOCK_REGISTERS_ONLY_NO = 0x1
	// Position of READ_CEATA_DEVICE field.
	SDMMC_CMD_READ_CEATA_DEVICE_Pos = 0x16
	// Bit mask of READ_CEATA_DEVICE field.
	SDMMC_CMD_READ_CEATA_DEVICE_Msk = 0x400000
	// Bit READ_CEATA_DEVICE.
	SDMMC_CMD_READ_CEATA_DEVICE = 0x400000
	// No read. Host is not performing read access (RW_REG or RW_BLK) towards CE-ATA device.
	SDMMC_CMD_READ_CEATA_DEVICE_NO_READ = 0x0
	// Read. Host is performing read access (RW_REG or RW_BLK) towards CE-ATA device.
	SDMMC_CMD_READ_CEATA_DEVICE_READ = 0x1
	// Position of CCS_EXPECTED field.
	SDMMC_CMD_CCS_EXPECTED_Pos = 0x17
	// Bit mask of CCS_EXPECTED field.
	SDMMC_CMD_CCS_EXPECTED_Msk = 0x800000
	// Bit CCS_EXPECTED.
	SDMMC_CMD_CCS_EXPECTED = 0x800000
	// Disabled. Interrupts are not enabled in CE-ATA device (nIEN = 1 in ATA control register), or command does not expect CCS from device.
	SDMMC_CMD_CCS_EXPECTED_DISABLED = 0x0
	// Enabled. Interrupts are enabled in CE-ATA device (nIEN = 0), and RW_BLK command expects command completion signal from CE-ATA device.
	SDMMC_CMD_CCS_EXPECTED_ENABLED = 0x1
	// Position of ENABLE_BOOT field.
	SDMMC_CMD_ENABLE_BOOT_Pos = 0x18
	// Bit mask of ENABLE_BOOT field.
	SDMMC_CMD_ENABLE_BOOT_Msk = 0x1000000
	// Bit ENABLE_BOOT.
	SDMMC_CMD_ENABLE_BOOT = 0x1000000
	// Position of EXPECT_BOOT_ACK field.
	SDMMC_CMD_EXPECT_BOOT_ACK_Pos = 0x19
	// Bit mask of EXPECT_BOOT_ACK field.
	SDMMC_CMD_EXPECT_BOOT_ACK_Msk = 0x2000000
	// Bit EXPECT_BOOT_ACK.
	SDMMC_CMD_EXPECT_BOOT_ACK = 0x2000000
	// Position of DISABLE_BOOT field.
	SDMMC_CMD_DISABLE_BOOT_Pos = 0x1a
	// Bit mask of DISABLE_BOOT field.
	SDMMC_CMD_DISABLE_BOOT_Msk = 0x4000000
	// Bit DISABLE_BOOT.
	SDMMC_CMD_DISABLE_BOOT = 0x4000000
	// Position of BOOT_MODE field.
	SDMMC_CMD_BOOT_MODE_Pos = 0x1b
	// Bit mask of BOOT_MODE field.
	SDMMC_CMD_BOOT_MODE_Msk = 0x8000000
	// Bit BOOT_MODE.
	SDMMC_CMD_BOOT_MODE = 0x8000000
	// Mandatory Boot operation
	SDMMC_CMD_BOOT_MODE_MANDATORY_BOOT_OPERA = 0x0
	// Alternate Boot operation
	SDMMC_CMD_BOOT_MODE_ALTERNATE_BOOT_OPERA = 0x1
	// Position of VOLT_SWITCH field.
	SDMMC_CMD_VOLT_SWITCH_Pos = 0x1c
	// Bit mask of VOLT_SWITCH field.
	SDMMC_CMD_VOLT_SWITCH_Msk = 0x10000000
	// Bit VOLT_SWITCH.
	SDMMC_CMD_VOLT_SWITCH = 0x10000000
	// Disabled. No voltage switching
	SDMMC_CMD_VOLT_SWITCH_DISABLED = 0x0
	// Enabled. Voltage switching enabled; must be set for CMD11 only
	SDMMC_CMD_VOLT_SWITCH_ENABLED = 0x1
	// Position of RESERVED field.
	SDMMC_CMD_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	SDMMC_CMD_RESERVED_Msk = 0x60000000
	// Position of START_CMD field.
	SDMMC_CMD_START_CMD_Pos = 0x1f
	// Bit mask of START_CMD field.
	SDMMC_CMD_START_CMD_Msk = 0x80000000
	// Bit START_CMD.
	SDMMC_CMD_START_CMD = 0x80000000

	// RESP0: Response Register 0
	// Position of RESPONSE0 field.
	SDMMC_RESP0_RESPONSE0_Pos = 0x0
	// Bit mask of RESPONSE0 field.
	SDMMC_RESP0_RESPONSE0_Msk = 0xffffffff

	// RESP1: Response Register 1
	// Position of RESPONSE1 field.
	SDMMC_RESP1_RESPONSE1_Pos = 0x0
	// Bit mask of RESPONSE1 field.
	SDMMC_RESP1_RESPONSE1_Msk = 0xffffffff

	// RESP2: Response Register 2
	// Position of RESPONSE2 field.
	SDMMC_RESP2_RESPONSE2_Pos = 0x0
	// Bit mask of RESPONSE2 field.
	SDMMC_RESP2_RESPONSE2_Msk = 0xffffffff

	// RESP3: Response Register 3
	// Position of RESPONSE3 field.
	SDMMC_RESP3_RESPONSE3_Pos = 0x0
	// Bit mask of RESPONSE3 field.
	SDMMC_RESP3_RESPONSE3_Msk = 0xffffffff

	// MINTSTS: Masked Interrupt Status Register
	// Position of CDET field.
	SDMMC_MINTSTS_CDET_Pos = 0x0
	// Bit mask of CDET field.
	SDMMC_MINTSTS_CDET_Msk = 0x1
	// Bit CDET.
	SDMMC_MINTSTS_CDET = 0x1
	// Position of RE field.
	SDMMC_MINTSTS_RE_Pos = 0x1
	// Bit mask of RE field.
	SDMMC_MINTSTS_RE_Msk = 0x2
	// Bit RE.
	SDMMC_MINTSTS_RE = 0x2
	// Position of CDONE field.
	SDMMC_MINTSTS_CDONE_Pos = 0x2
	// Bit mask of CDONE field.
	SDMMC_MINTSTS_CDONE_Msk = 0x4
	// Bit CDONE.
	SDMMC_MINTSTS_CDONE = 0x4
	// Position of DTO field.
	SDMMC_MINTSTS_DTO_Pos = 0x3
	// Bit mask of DTO field.
	SDMMC_MINTSTS_DTO_Msk = 0x8
	// Bit DTO.
	SDMMC_MINTSTS_DTO = 0x8
	// Position of TXDR field.
	SDMMC_MINTSTS_TXDR_Pos = 0x4
	// Bit mask of TXDR field.
	SDMMC_MINTSTS_TXDR_Msk = 0x10
	// Bit TXDR.
	SDMMC_MINTSTS_TXDR = 0x10
	// Position of RXDR field.
	SDMMC_MINTSTS_RXDR_Pos = 0x5
	// Bit mask of RXDR field.
	SDMMC_MINTSTS_RXDR_Msk = 0x20
	// Bit RXDR.
	SDMMC_MINTSTS_RXDR = 0x20
	// Position of RCRC field.
	SDMMC_MINTSTS_RCRC_Pos = 0x6
	// Bit mask of RCRC field.
	SDMMC_MINTSTS_RCRC_Msk = 0x40
	// Bit RCRC.
	SDMMC_MINTSTS_RCRC = 0x40
	// Position of DCRC field.
	SDMMC_MINTSTS_DCRC_Pos = 0x7
	// Bit mask of DCRC field.
	SDMMC_MINTSTS_DCRC_Msk = 0x80
	// Bit DCRC.
	SDMMC_MINTSTS_DCRC = 0x80
	// Position of RTO field.
	SDMMC_MINTSTS_RTO_Pos = 0x8
	// Bit mask of RTO field.
	SDMMC_MINTSTS_RTO_Msk = 0x100
	// Bit RTO.
	SDMMC_MINTSTS_RTO = 0x100
	// Position of DRTO field.
	SDMMC_MINTSTS_DRTO_Pos = 0x9
	// Bit mask of DRTO field.
	SDMMC_MINTSTS_DRTO_Msk = 0x200
	// Bit DRTO.
	SDMMC_MINTSTS_DRTO = 0x200
	// Position of HTO field.
	SDMMC_MINTSTS_HTO_Pos = 0xa
	// Bit mask of HTO field.
	SDMMC_MINTSTS_HTO_Msk = 0x400
	// Bit HTO.
	SDMMC_MINTSTS_HTO = 0x400
	// Position of FRUN field.
	SDMMC_MINTSTS_FRUN_Pos = 0xb
	// Bit mask of FRUN field.
	SDMMC_MINTSTS_FRUN_Msk = 0x800
	// Bit FRUN.
	SDMMC_MINTSTS_FRUN = 0x800
	// Position of HLE field.
	SDMMC_MINTSTS_HLE_Pos = 0xc
	// Bit mask of HLE field.
	SDMMC_MINTSTS_HLE_Msk = 0x1000
	// Bit HLE.
	SDMMC_MINTSTS_HLE = 0x1000
	// Position of SBE field.
	SDMMC_MINTSTS_SBE_Pos = 0xd
	// Bit mask of SBE field.
	SDMMC_MINTSTS_SBE_Msk = 0x2000
	// Bit SBE.
	SDMMC_MINTSTS_SBE = 0x2000
	// Position of ACD field.
	SDMMC_MINTSTS_ACD_Pos = 0xe
	// Bit mask of ACD field.
	SDMMC_MINTSTS_ACD_Msk = 0x4000
	// Bit ACD.
	SDMMC_MINTSTS_ACD = 0x4000
	// Position of EBE field.
	SDMMC_MINTSTS_EBE_Pos = 0xf
	// Bit mask of EBE field.
	SDMMC_MINTSTS_EBE_Msk = 0x8000
	// Bit EBE.
	SDMMC_MINTSTS_EBE = 0x8000
	// Position of SDIO_INTERRUPT field.
	SDMMC_MINTSTS_SDIO_INTERRUPT_Pos = 0x10
	// Bit mask of SDIO_INTERRUPT field.
	SDMMC_MINTSTS_SDIO_INTERRUPT_Msk = 0x10000
	// Bit SDIO_INTERRUPT.
	SDMMC_MINTSTS_SDIO_INTERRUPT = 0x10000
	// Position of RESERVED field.
	SDMMC_MINTSTS_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	SDMMC_MINTSTS_RESERVED_Msk = 0xfffe0000

	// RINTSTS: Raw Interrupt Status Register
	// Position of CDET field.
	SDMMC_RINTSTS_CDET_Pos = 0x0
	// Bit mask of CDET field.
	SDMMC_RINTSTS_CDET_Msk = 0x1
	// Bit CDET.
	SDMMC_RINTSTS_CDET = 0x1
	// Position of RE field.
	SDMMC_RINTSTS_RE_Pos = 0x1
	// Bit mask of RE field.
	SDMMC_RINTSTS_RE_Msk = 0x2
	// Bit RE.
	SDMMC_RINTSTS_RE = 0x2
	// Position of CDONE field.
	SDMMC_RINTSTS_CDONE_Pos = 0x2
	// Bit mask of CDONE field.
	SDMMC_RINTSTS_CDONE_Msk = 0x4
	// Bit CDONE.
	SDMMC_RINTSTS_CDONE = 0x4
	// Position of DTO field.
	SDMMC_RINTSTS_DTO_Pos = 0x3
	// Bit mask of DTO field.
	SDMMC_RINTSTS_DTO_Msk = 0x8
	// Bit DTO.
	SDMMC_RINTSTS_DTO = 0x8
	// Position of TXDR field.
	SDMMC_RINTSTS_TXDR_Pos = 0x4
	// Bit mask of TXDR field.
	SDMMC_RINTSTS_TXDR_Msk = 0x10
	// Bit TXDR.
	SDMMC_RINTSTS_TXDR = 0x10
	// Position of RXDR field.
	SDMMC_RINTSTS_RXDR_Pos = 0x5
	// Bit mask of RXDR field.
	SDMMC_RINTSTS_RXDR_Msk = 0x20
	// Bit RXDR.
	SDMMC_RINTSTS_RXDR = 0x20
	// Position of RCRC field.
	SDMMC_RINTSTS_RCRC_Pos = 0x6
	// Bit mask of RCRC field.
	SDMMC_RINTSTS_RCRC_Msk = 0x40
	// Bit RCRC.
	SDMMC_RINTSTS_RCRC = 0x40
	// Position of DCRC field.
	SDMMC_RINTSTS_DCRC_Pos = 0x7
	// Bit mask of DCRC field.
	SDMMC_RINTSTS_DCRC_Msk = 0x80
	// Bit DCRC.
	SDMMC_RINTSTS_DCRC = 0x80
	// Position of RTO_BAR field.
	SDMMC_RINTSTS_RTO_BAR_Pos = 0x8
	// Bit mask of RTO_BAR field.
	SDMMC_RINTSTS_RTO_BAR_Msk = 0x100
	// Bit RTO_BAR.
	SDMMC_RINTSTS_RTO_BAR = 0x100
	// Position of DRTO_BDS field.
	SDMMC_RINTSTS_DRTO_BDS_Pos = 0x9
	// Bit mask of DRTO_BDS field.
	SDMMC_RINTSTS_DRTO_BDS_Msk = 0x200
	// Bit DRTO_BDS.
	SDMMC_RINTSTS_DRTO_BDS = 0x200
	// Position of HTO field.
	SDMMC_RINTSTS_HTO_Pos = 0xa
	// Bit mask of HTO field.
	SDMMC_RINTSTS_HTO_Msk = 0x400
	// Bit HTO.
	SDMMC_RINTSTS_HTO = 0x400
	// Position of FRUN field.
	SDMMC_RINTSTS_FRUN_Pos = 0xb
	// Bit mask of FRUN field.
	SDMMC_RINTSTS_FRUN_Msk = 0x800
	// Bit FRUN.
	SDMMC_RINTSTS_FRUN = 0x800
	// Position of HLE field.
	SDMMC_RINTSTS_HLE_Pos = 0xc
	// Bit mask of HLE field.
	SDMMC_RINTSTS_HLE_Msk = 0x1000
	// Bit HLE.
	SDMMC_RINTSTS_HLE = 0x1000
	// Position of SBE field.
	SDMMC_RINTSTS_SBE_Pos = 0xd
	// Bit mask of SBE field.
	SDMMC_RINTSTS_SBE_Msk = 0x2000
	// Bit SBE.
	SDMMC_RINTSTS_SBE = 0x2000
	// Position of ACD field.
	SDMMC_RINTSTS_ACD_Pos = 0xe
	// Bit mask of ACD field.
	SDMMC_RINTSTS_ACD_Msk = 0x4000
	// Bit ACD.
	SDMMC_RINTSTS_ACD = 0x4000
	// Position of EBE field.
	SDMMC_RINTSTS_EBE_Pos = 0xf
	// Bit mask of EBE field.
	SDMMC_RINTSTS_EBE_Msk = 0x8000
	// Bit EBE.
	SDMMC_RINTSTS_EBE = 0x8000
	// Position of SDIO_INTERRUPT field.
	SDMMC_RINTSTS_SDIO_INTERRUPT_Pos = 0x10
	// Bit mask of SDIO_INTERRUPT field.
	SDMMC_RINTSTS_SDIO_INTERRUPT_Msk = 0x10000
	// Bit SDIO_INTERRUPT.
	SDMMC_RINTSTS_SDIO_INTERRUPT = 0x10000
	// Position of RESERVED field.
	SDMMC_RINTSTS_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	SDMMC_RINTSTS_RESERVED_Msk = 0xfffe0000

	// STATUS: Status Register
	// Position of FIFO_RX_WATERMARK field.
	SDMMC_STATUS_FIFO_RX_WATERMARK_Pos = 0x0
	// Bit mask of FIFO_RX_WATERMARK field.
	SDMMC_STATUS_FIFO_RX_WATERMARK_Msk = 0x1
	// Bit FIFO_RX_WATERMARK.
	SDMMC_STATUS_FIFO_RX_WATERMARK = 0x1
	// Position of FIFO_TX_WATERMARK field.
	SDMMC_STATUS_FIFO_TX_WATERMARK_Pos = 0x1
	// Bit mask of FIFO_TX_WATERMARK field.
	SDMMC_STATUS_FIFO_TX_WATERMARK_Msk = 0x2
	// Bit FIFO_TX_WATERMARK.
	SDMMC_STATUS_FIFO_TX_WATERMARK = 0x2
	// Position of FIFO_EMPTY field.
	SDMMC_STATUS_FIFO_EMPTY_Pos = 0x2
	// Bit mask of FIFO_EMPTY field.
	SDMMC_STATUS_FIFO_EMPTY_Msk = 0x4
	// Bit FIFO_EMPTY.
	SDMMC_STATUS_FIFO_EMPTY = 0x4
	// Position of FIFO_FULL field.
	SDMMC_STATUS_FIFO_FULL_Pos = 0x3
	// Bit mask of FIFO_FULL field.
	SDMMC_STATUS_FIFO_FULL_Msk = 0x8
	// Bit FIFO_FULL.
	SDMMC_STATUS_FIFO_FULL = 0x8
	// Position of CMDFSMSTATES field.
	SDMMC_STATUS_CMDFSMSTATES_Pos = 0x4
	// Bit mask of CMDFSMSTATES field.
	SDMMC_STATUS_CMDFSMSTATES_Msk = 0xf0
	// Position of DATA_3_STATUS field.
	SDMMC_STATUS_DATA_3_STATUS_Pos = 0x8
	// Bit mask of DATA_3_STATUS field.
	SDMMC_STATUS_DATA_3_STATUS_Msk = 0x100
	// Bit DATA_3_STATUS.
	SDMMC_STATUS_DATA_3_STATUS = 0x100
	// Position of DATA_BUSY field.
	SDMMC_STATUS_DATA_BUSY_Pos = 0x9
	// Bit mask of DATA_BUSY field.
	SDMMC_STATUS_DATA_BUSY_Msk = 0x200
	// Bit DATA_BUSY.
	SDMMC_STATUS_DATA_BUSY = 0x200
	// Position of DATA_STATE_MC_BUSY field.
	SDMMC_STATUS_DATA_STATE_MC_BUSY_Pos = 0xa
	// Bit mask of DATA_STATE_MC_BUSY field.
	SDMMC_STATUS_DATA_STATE_MC_BUSY_Msk = 0x400
	// Bit DATA_STATE_MC_BUSY.
	SDMMC_STATUS_DATA_STATE_MC_BUSY = 0x400
	// Position of RESPONSE_INDEX field.
	SDMMC_STATUS_RESPONSE_INDEX_Pos = 0xb
	// Bit mask of RESPONSE_INDEX field.
	SDMMC_STATUS_RESPONSE_INDEX_Msk = 0x1f800
	// Position of FIFO_COUNT field.
	SDMMC_STATUS_FIFO_COUNT_Pos = 0x11
	// Bit mask of FIFO_COUNT field.
	SDMMC_STATUS_FIFO_COUNT_Msk = 0x3ffe0000
	// Position of DMA_ACK field.
	SDMMC_STATUS_DMA_ACK_Pos = 0x1e
	// Bit mask of DMA_ACK field.
	SDMMC_STATUS_DMA_ACK_Msk = 0x40000000
	// Bit DMA_ACK.
	SDMMC_STATUS_DMA_ACK = 0x40000000
	// Position of DMA_REQ field.
	SDMMC_STATUS_DMA_REQ_Pos = 0x1f
	// Bit mask of DMA_REQ field.
	SDMMC_STATUS_DMA_REQ_Msk = 0x80000000
	// Bit DMA_REQ.
	SDMMC_STATUS_DMA_REQ = 0x80000000

	// FIFOTH: FIFO Threshold Watermark Register
	// Position of TX_WMARK field.
	SDMMC_FIFOTH_TX_WMARK_Pos = 0x0
	// Bit mask of TX_WMARK field.
	SDMMC_FIFOTH_TX_WMARK_Msk = 0xfff
	// Position of RESERVED field.
	SDMMC_FIFOTH_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	SDMMC_FIFOTH_RESERVED_Msk = 0xf000
	// Position of RX_WMARK field.
	SDMMC_FIFOTH_RX_WMARK_Pos = 0x10
	// Bit mask of RX_WMARK field.
	SDMMC_FIFOTH_RX_WMARK_Msk = 0xfff0000
	// Position of DMA_MTS field.
	SDMMC_FIFOTH_DMA_MTS_Pos = 0x1c
	// Bit mask of DMA_MTS field.
	SDMMC_FIFOTH_DMA_MTS_Msk = 0x70000000
	// 1 transfer
	SDMMC_FIFOTH_DMA_MTS_1_TRANSFER = 0x0
	// 4 transfers
	SDMMC_FIFOTH_DMA_MTS_4_TRANSFERS = 0x1
	// 8 transfers
	SDMMC_FIFOTH_DMA_MTS_8_TRANSFERS = 0x2
	// 16 transfers
	SDMMC_FIFOTH_DMA_MTS_16_TRANSFERS = 0x3
	// 32 transfers
	SDMMC_FIFOTH_DMA_MTS_32_TRANSFERS = 0x4
	// 64 transfers
	SDMMC_FIFOTH_DMA_MTS_64_TRANSFERS = 0x5
	// 128 transfers
	SDMMC_FIFOTH_DMA_MTS_128_TRANSFERS = 0x6
	// 256 transfers
	SDMMC_FIFOTH_DMA_MTS_256_TRANSFERS = 0x7
	// Position of RESERVED field.
	SDMMC_FIFOTH_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	SDMMC_FIFOTH_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	SDMMC_FIFOTH_RESERVED = 0x80000000

	// CDETECT: Card Detect Register
	// Position of CARD_DETECT field.
	SDMMC_CDETECT_CARD_DETECT_Pos = 0x0
	// Bit mask of CARD_DETECT field.
	SDMMC_CDETECT_CARD_DETECT_Msk = 0x1
	// Bit CARD_DETECT.
	SDMMC_CDETECT_CARD_DETECT = 0x1
	// Position of RESERVED field.
	SDMMC_CDETECT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SDMMC_CDETECT_RESERVED_Msk = 0xfffffffe

	// WRTPRT: Write Protect Register
	// Position of WRITE_PROTECT field.
	SDMMC_WRTPRT_WRITE_PROTECT_Pos = 0x0
	// Bit mask of WRITE_PROTECT field.
	SDMMC_WRTPRT_WRITE_PROTECT_Msk = 0x1
	// Bit WRITE_PROTECT.
	SDMMC_WRTPRT_WRITE_PROTECT = 0x1
	// Position of RESERVED field.
	SDMMC_WRTPRT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SDMMC_WRTPRT_RESERVED_Msk = 0xfffffffe

	// TCBCNT: Transferred CIU Card Byte Count Register
	// Position of TRANS_CARD_BYTE_COUNT field.
	SDMMC_TCBCNT_TRANS_CARD_BYTE_COUNT_Pos = 0x0
	// Bit mask of TRANS_CARD_BYTE_COUNT field.
	SDMMC_TCBCNT_TRANS_CARD_BYTE_COUNT_Msk = 0xffffffff

	// TBBCNT: Transferred Host to BIU-FIFO Byte Count Register
	// Position of TRANS_FIFO_BYTE_COUNT field.
	SDMMC_TBBCNT_TRANS_FIFO_BYTE_COUNT_Pos = 0x0
	// Bit mask of TRANS_FIFO_BYTE_COUNT field.
	SDMMC_TBBCNT_TRANS_FIFO_BYTE_COUNT_Msk = 0xffffffff

	// DEBNCE: Debounce Count Register
	// Position of DEBOUNCE_COUNT field.
	SDMMC_DEBNCE_DEBOUNCE_COUNT_Pos = 0x0
	// Bit mask of DEBOUNCE_COUNT field.
	SDMMC_DEBNCE_DEBOUNCE_COUNT_Msk = 0xffffff
	// Position of RESERVED field.
	SDMMC_DEBNCE_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	SDMMC_DEBNCE_RESERVED_Msk = 0xff000000

	// RST_N: Hardware Reset
	// Position of CARD_RESET field.
	SDMMC_RST_N_CARD_RESET_Pos = 0x0
	// Bit mask of CARD_RESET field.
	SDMMC_RST_N_CARD_RESET_Msk = 0x1
	// Bit CARD_RESET.
	SDMMC_RST_N_CARD_RESET = 0x1
	// Position of RESERVED field.
	SDMMC_RST_N_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SDMMC_RST_N_RESERVED_Msk = 0xfffffffe

	// BMOD: Bus Mode Register
	// Position of SWR field.
	SDMMC_BMOD_SWR_Pos = 0x0
	// Bit mask of SWR field.
	SDMMC_BMOD_SWR_Msk = 0x1
	// Bit SWR.
	SDMMC_BMOD_SWR = 0x1
	// Position of FB field.
	SDMMC_BMOD_FB_Pos = 0x1
	// Bit mask of FB field.
	SDMMC_BMOD_FB_Msk = 0x2
	// Bit FB.
	SDMMC_BMOD_FB = 0x2
	// Position of DSL field.
	SDMMC_BMOD_DSL_Pos = 0x2
	// Bit mask of DSL field.
	SDMMC_BMOD_DSL_Msk = 0x7c
	// Position of DE field.
	SDMMC_BMOD_DE_Pos = 0x7
	// Bit mask of DE field.
	SDMMC_BMOD_DE_Msk = 0x80
	// Bit DE.
	SDMMC_BMOD_DE = 0x80
	// Position of PBL field.
	SDMMC_BMOD_PBL_Pos = 0x8
	// Bit mask of PBL field.
	SDMMC_BMOD_PBL_Msk = 0x700
	// 1 transfer
	SDMMC_BMOD_PBL_1_TRANSFER = 0x0
	// 4 transfers
	SDMMC_BMOD_PBL_4_TRANSFERS = 0x1
	// 8 transfers
	SDMMC_BMOD_PBL_8_TRANSFERS = 0x2
	// 16 transfers
	SDMMC_BMOD_PBL_16_TRANSFERS = 0x3
	// 32 transfers
	SDMMC_BMOD_PBL_32_TRANSFERS = 0x4
	// 64 transfers
	SDMMC_BMOD_PBL_64_TRANSFERS = 0x5
	// 128 transfers
	SDMMC_BMOD_PBL_128_TRANSFERS = 0x6
	// 256 transfers
	SDMMC_BMOD_PBL_256_TRANSFERS = 0x7
	// Position of RESERVED field.
	SDMMC_BMOD_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	SDMMC_BMOD_RESERVED_Msk = 0xfffff800

	// PLDMND: Poll Demand Register
	// Position of PD field.
	SDMMC_PLDMND_PD_Pos = 0x0
	// Bit mask of PD field.
	SDMMC_PLDMND_PD_Msk = 0xffffffff

	// DBADDR: Descriptor List Base Address Register
	// Position of SDL field.
	SDMMC_DBADDR_SDL_Pos = 0x0
	// Bit mask of SDL field.
	SDMMC_DBADDR_SDL_Msk = 0xffffffff

	// IDSTS: Internal DMAC Status Register
	// Position of TI field.
	SDMMC_IDSTS_TI_Pos = 0x0
	// Bit mask of TI field.
	SDMMC_IDSTS_TI_Msk = 0x1
	// Bit TI.
	SDMMC_IDSTS_TI = 0x1
	// Position of RI field.
	SDMMC_IDSTS_RI_Pos = 0x1
	// Bit mask of RI field.
	SDMMC_IDSTS_RI_Msk = 0x2
	// Bit RI.
	SDMMC_IDSTS_RI = 0x2
	// Position of FBE field.
	SDMMC_IDSTS_FBE_Pos = 0x2
	// Bit mask of FBE field.
	SDMMC_IDSTS_FBE_Msk = 0x4
	// Bit FBE.
	SDMMC_IDSTS_FBE = 0x4
	// Position of RESERVED field.
	SDMMC_IDSTS_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	SDMMC_IDSTS_RESERVED_Msk = 0x8
	// Bit RESERVED.
	SDMMC_IDSTS_RESERVED = 0x8
	// Position of DU field.
	SDMMC_IDSTS_DU_Pos = 0x4
	// Bit mask of DU field.
	SDMMC_IDSTS_DU_Msk = 0x10
	// Bit DU.
	SDMMC_IDSTS_DU = 0x10
	// Position of CES field.
	SDMMC_IDSTS_CES_Pos = 0x5
	// Bit mask of CES field.
	SDMMC_IDSTS_CES_Msk = 0x20
	// Bit CES.
	SDMMC_IDSTS_CES = 0x20
	// Position of RESERVED field.
	SDMMC_IDSTS_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	SDMMC_IDSTS_RESERVED_Msk = 0xc0
	// Position of NIS field.
	SDMMC_IDSTS_NIS_Pos = 0x8
	// Bit mask of NIS field.
	SDMMC_IDSTS_NIS_Msk = 0x100
	// Bit NIS.
	SDMMC_IDSTS_NIS = 0x100
	// Position of AIS field.
	SDMMC_IDSTS_AIS_Pos = 0x9
	// Bit mask of AIS field.
	SDMMC_IDSTS_AIS_Msk = 0x200
	// Bit AIS.
	SDMMC_IDSTS_AIS = 0x200
	// Position of EB field.
	SDMMC_IDSTS_EB_Pos = 0xa
	// Bit mask of EB field.
	SDMMC_IDSTS_EB_Msk = 0x1c00
	// Position of FSM field.
	SDMMC_IDSTS_FSM_Pos = 0xd
	// Bit mask of FSM field.
	SDMMC_IDSTS_FSM_Msk = 0x1e000
	// Position of RESERVED field.
	SDMMC_IDSTS_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	SDMMC_IDSTS_RESERVED_Msk = 0xfffe0000

	// IDINTEN: Internal DMAC Interrupt Enable Register
	// Position of TI field.
	SDMMC_IDINTEN_TI_Pos = 0x0
	// Bit mask of TI field.
	SDMMC_IDINTEN_TI_Msk = 0x1
	// Bit TI.
	SDMMC_IDINTEN_TI = 0x1
	// Position of RI field.
	SDMMC_IDINTEN_RI_Pos = 0x1
	// Bit mask of RI field.
	SDMMC_IDINTEN_RI_Msk = 0x2
	// Bit RI.
	SDMMC_IDINTEN_RI = 0x2
	// Position of FBE field.
	SDMMC_IDINTEN_FBE_Pos = 0x2
	// Bit mask of FBE field.
	SDMMC_IDINTEN_FBE_Msk = 0x4
	// Bit FBE.
	SDMMC_IDINTEN_FBE = 0x4
	// Position of RESERVED field.
	SDMMC_IDINTEN_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	SDMMC_IDINTEN_RESERVED_Msk = 0x8
	// Bit RESERVED.
	SDMMC_IDINTEN_RESERVED = 0x8
	// Position of DU field.
	SDMMC_IDINTEN_DU_Pos = 0x4
	// Bit mask of DU field.
	SDMMC_IDINTEN_DU_Msk = 0x10
	// Bit DU.
	SDMMC_IDINTEN_DU = 0x10
	// Position of CES field.
	SDMMC_IDINTEN_CES_Pos = 0x5
	// Bit mask of CES field.
	SDMMC_IDINTEN_CES_Msk = 0x20
	// Bit CES.
	SDMMC_IDINTEN_CES = 0x20
	// Position of RESERVED field.
	SDMMC_IDINTEN_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	SDMMC_IDINTEN_RESERVED_Msk = 0xc0
	// Position of NIS field.
	SDMMC_IDINTEN_NIS_Pos = 0x8
	// Bit mask of NIS field.
	SDMMC_IDINTEN_NIS_Msk = 0x100
	// Bit NIS.
	SDMMC_IDINTEN_NIS = 0x100
	// Position of AIS field.
	SDMMC_IDINTEN_AIS_Pos = 0x9
	// Bit mask of AIS field.
	SDMMC_IDINTEN_AIS_Msk = 0x200
	// Bit AIS.
	SDMMC_IDINTEN_AIS = 0x200
	// Position of RESERVED field.
	SDMMC_IDINTEN_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	SDMMC_IDINTEN_RESERVED_Msk = 0xfffffc00

	// DSCADDR: Current Host Descriptor Address Register
	// Position of HDA field.
	SDMMC_DSCADDR_HDA_Pos = 0x0
	// Bit mask of HDA field.
	SDMMC_DSCADDR_HDA_Msk = 0xffffffff

	// BUFADDR: Current Buffer Descriptor Address Register
	// Position of HBA field.
	SDMMC_BUFADDR_HBA_Pos = 0x0
	// Bit mask of HBA field.
	SDMMC_BUFADDR_HBA_Msk = 0xffffffff
)

// Constants for EMC: External Memory Controller (EMC)
const (
	// CONTROL: Controls operation of the memory controller.
	// Position of E field.
	EMC_CONTROL_E_Pos = 0x0
	// Bit mask of E field.
	EMC_CONTROL_E_Msk = 0x1
	// Bit E.
	EMC_CONTROL_E = 0x1
	// Disabled
	EMC_CONTROL_E_DISABLED = 0x0
	// Enabled. (POR and warm reset value).
	EMC_CONTROL_E_ENABLED = 0x1
	// Position of M field.
	EMC_CONTROL_M_Pos = 0x1
	// Bit mask of M field.
	EMC_CONTROL_M_Msk = 0x2
	// Bit M.
	EMC_CONTROL_M = 0x2
	// Normal. Normal memory map.
	EMC_CONTROL_M_NORMAL = 0x0
	// Reset. Reset memory map. Static memory CS1 is mirrored onto CS0 and DYCS0 (POR reset value).
	EMC_CONTROL_M_RESET = 0x1
	// Position of L field.
	EMC_CONTROL_L_Pos = 0x2
	// Bit mask of L field.
	EMC_CONTROL_L_Msk = 0x4
	// Bit L.
	EMC_CONTROL_L = 0x4
	// Normal. Normal mode (warm reset value).
	EMC_CONTROL_L_NORMAL = 0x0
	// Low-power mode.
	EMC_CONTROL_L_LOW_POWER_MODE = 0x1
	// Position of RESERVED field.
	EMC_CONTROL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EMC_CONTROL_RESERVED_Msk = 0xfffffff8

	// STATUS: Provides EMC status information.
	// Position of B field.
	EMC_STATUS_B_Pos = 0x0
	// Bit mask of B field.
	EMC_STATUS_B_Msk = 0x1
	// Bit B.
	EMC_STATUS_B = 0x1
	// Idle. EMC is idle (warm reset value).
	EMC_STATUS_B_IDLE = 0x0
	// Busy. EMC is busy performing memory transactions, commands, auto-refresh cycles, or is in self-refresh mode (POR reset value).
	EMC_STATUS_B_BUSY = 0x1
	// Position of S field.
	EMC_STATUS_S_Pos = 0x1
	// Bit mask of S field.
	EMC_STATUS_S_Msk = 0x2
	// Bit S.
	EMC_STATUS_S = 0x2
	// Empty. Write buffers empty (POR reset value)
	EMC_STATUS_S_EMPTY = 0x0
	// Data. Write buffers contain data.
	EMC_STATUS_S_DATA = 0x1
	// Position of SA field.
	EMC_STATUS_SA_Pos = 0x2
	// Bit mask of SA field.
	EMC_STATUS_SA_Msk = 0x4
	// Bit SA.
	EMC_STATUS_SA = 0x4
	// Normal mode.
	EMC_STATUS_SA_NORMAL_MODE = 0x0
	// Self-refresh mode. (POR reset value.)
	EMC_STATUS_SA_SELF_REFRESH_MODE = 0x1
	// Position of RESERVED field.
	EMC_STATUS_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EMC_STATUS_RESERVED_Msk = 0xfffffff8

	// CONFIG: Configures operation of the memory controller.
	// Position of EM field.
	EMC_CONFIG_EM_Pos = 0x0
	// Bit mask of EM field.
	EMC_CONFIG_EM_Msk = 0x1
	// Bit EM.
	EMC_CONFIG_EM = 0x1
	// Little-endian mode. (POR reset value.)
	EMC_CONFIG_EM_LITTLE_ENDIAN_MODE = 0x0
	// Big-endian mode.
	EMC_CONFIG_EM_BIG_ENDIAN_MODE = 0x1
	// Position of RESERVED field.
	EMC_CONFIG_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	EMC_CONFIG_RESERVED_Msk = 0xfe
	// Position of RESERVED field.
	EMC_CONFIG_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	EMC_CONFIG_RESERVED_Msk = 0x100
	// Bit RESERVED.
	EMC_CONFIG_RESERVED = 0x100
	// Position of RESERVED field.
	EMC_CONFIG_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	EMC_CONFIG_RESERVED_Msk = 0xfffffe00

	// DYNAMICCONTROL: Controls dynamic memory operation.
	// Position of CE field.
	EMC_DYNAMICCONTROL_CE_Pos = 0x0
	// Bit mask of CE field.
	EMC_DYNAMICCONTROL_CE_Msk = 0x1
	// Bit CE.
	EMC_DYNAMICCONTROL_CE = 0x1
	// Disabled. Clock enable of idle devices are deasserted to save power (POR reset value).
	EMC_DYNAMICCONTROL_CE_DISABLED = 0x0
	// Enabled. All clock enables are driven HIGH continuously.[1]
	EMC_DYNAMICCONTROL_CE_ENABLED = 0x1
	// Position of CS field.
	EMC_DYNAMICCONTROL_CS_Pos = 0x1
	// Bit mask of CS field.
	EMC_DYNAMICCONTROL_CS_Msk = 0x2
	// Bit CS.
	EMC_DYNAMICCONTROL_CS = 0x2
	// Stop. CLKOUT stops when all SDRAMs are idle and during self-refresh mode.
	EMC_DYNAMICCONTROL_CS_STOP = 0x0
	// Run. CLKOUT runs continuously (POR reset value).
	EMC_DYNAMICCONTROL_CS_RUN = 0x1
	// Position of SR field.
	EMC_DYNAMICCONTROL_SR_Pos = 0x2
	// Bit mask of SR field.
	EMC_DYNAMICCONTROL_SR_Msk = 0x4
	// Bit SR.
	EMC_DYNAMICCONTROL_SR = 0x4
	// Normal mode.
	EMC_DYNAMICCONTROL_SR_NORMAL_MODE = 0x0
	// Self-refresh. Enter self-refresh mode (POR reset value).
	EMC_DYNAMICCONTROL_SR_SELF_REFRESH = 0x1
	// Position of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Msk = 0x18
	// Position of MMC field.
	EMC_DYNAMICCONTROL_MMC_Pos = 0x5
	// Bit mask of MMC field.
	EMC_DYNAMICCONTROL_MMC_Msk = 0x20
	// Bit MMC.
	EMC_DYNAMICCONTROL_MMC = 0x20
	// Enabled. CLKOUT enabled (POR reset value).
	EMC_DYNAMICCONTROL_MMC_ENABLED = 0x0
	// Disabled. CLKOUT disabled.[3]
	EMC_DYNAMICCONTROL_MMC_DISABLED = 0x1
	// Position of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Msk = 0x40
	// Bit RESERVED.
	EMC_DYNAMICCONTROL_RESERVED = 0x40
	// Position of I field.
	EMC_DYNAMICCONTROL_I_Pos = 0x7
	// Bit mask of I field.
	EMC_DYNAMICCONTROL_I_Msk = 0x180
	// Normal. Issue SDRAM NORMAL operation command (POR reset value).
	EMC_DYNAMICCONTROL_I_NORMAL = 0x0
	// Mode. Issue SDRAM MODE command.
	EMC_DYNAMICCONTROL_I_MODE = 0x1
	// PALL. Issue SDRAM PALL (precharge all) command.
	EMC_DYNAMICCONTROL_I_PALL = 0x2
	// NOP. Issue SDRAM NOP (no operation) command)
	EMC_DYNAMICCONTROL_I_NOP = 0x3
	// Position of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Msk = 0x3e00
	// Position of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Msk = 0xffffc000

	// DYNAMICREFRESH: Configures dynamic memory refresh operation.
	// Position of REFRESH field.
	EMC_DYNAMICREFRESH_REFRESH_Pos = 0x0
	// Bit mask of REFRESH field.
	EMC_DYNAMICREFRESH_REFRESH_Msk = 0x7ff
	// Position of RESERVED field.
	EMC_DYNAMICREFRESH_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	EMC_DYNAMICREFRESH_RESERVED_Msk = 0xfffff800

	// DYNAMICREADCONFIG: Configures the dynamic memory read strategy.
	// Position of RD field.
	EMC_DYNAMICREADCONFIG_RD_Pos = 0x0
	// Bit mask of RD field.
	EMC_DYNAMICREADCONFIG_RD_Msk = 0x3
	// Do not use. POR reset value.
	EMC_DYNAMICREADCONFIG_RD_DO_NOT_USE = 0x0
	// Command delayed by 1/2 EMC_CCLK.
	EMC_DYNAMICREADCONFIG_RD_HALF = 0x1
	// Command delayed by 1/2 EMC_CCLK plus one clock cycle.
	EMC_DYNAMICREADCONFIG_RD_HALFPLUSONE = 0x2
	// Command delayed by1/2 EMC_CCLK plus two clock cycles,
	EMC_DYNAMICREADCONFIG_RD_HALFPLUSTWO = 0x3
	// Position of RESERVED field.
	EMC_DYNAMICREADCONFIG_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	EMC_DYNAMICREADCONFIG_RESERVED_Msk = 0xfffffffc

	// DYNAMICRP: Selects the precharge command period.
	// Position of TRP field.
	EMC_DYNAMICRP_TRP_Pos = 0x0
	// Bit mask of TRP field.
	EMC_DYNAMICRP_TRP_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICRP_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICRP_RESERVED_Msk = 0xfffffff0

	// DYNAMICRAS: Selects the active to precharge command period.
	// Position of TRAS field.
	EMC_DYNAMICRAS_TRAS_Pos = 0x0
	// Bit mask of TRAS field.
	EMC_DYNAMICRAS_TRAS_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICRAS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICRAS_RESERVED_Msk = 0xfffffff0

	// DYNAMICSREX: Selects the self-refresh exit time.
	// Position of TSREX field.
	EMC_DYNAMICSREX_TSREX_Pos = 0x0
	// Bit mask of TSREX field.
	EMC_DYNAMICSREX_TSREX_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICSREX_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICSREX_RESERVED_Msk = 0xfffffff0

	// DYNAMICAPR: Selects the last-data-out to active command time.
	// Position of TAPR field.
	EMC_DYNAMICAPR_TAPR_Pos = 0x0
	// Bit mask of TAPR field.
	EMC_DYNAMICAPR_TAPR_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICAPR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICAPR_RESERVED_Msk = 0xfffffff0

	// DYNAMICDAL: Selects the data-in to active command time.
	// Position of TDAL field.
	EMC_DYNAMICDAL_TDAL_Pos = 0x0
	// Bit mask of TDAL field.
	EMC_DYNAMICDAL_TDAL_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICDAL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICDAL_RESERVED_Msk = 0xfffffff0

	// DYNAMICWR: Selects the write recovery time.
	// Position of TWR field.
	EMC_DYNAMICWR_TWR_Pos = 0x0
	// Bit mask of TWR field.
	EMC_DYNAMICWR_TWR_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICWR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICWR_RESERVED_Msk = 0xfffffff0

	// DYNAMICRC: Selects the active to active command period.
	// Position of TRC field.
	EMC_DYNAMICRC_TRC_Pos = 0x0
	// Bit mask of TRC field.
	EMC_DYNAMICRC_TRC_Msk = 0x1f
	// Position of RESERVED field.
	EMC_DYNAMICRC_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_DYNAMICRC_RESERVED_Msk = 0xffffffe0

	// DYNAMICRFC: Selects the auto-refresh period.
	// Position of TRFC field.
	EMC_DYNAMICRFC_TRFC_Pos = 0x0
	// Bit mask of TRFC field.
	EMC_DYNAMICRFC_TRFC_Msk = 0x1f
	// Position of RESERVED field.
	EMC_DYNAMICRFC_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_DYNAMICRFC_RESERVED_Msk = 0xffffffe0

	// DYNAMICXSR: Selects the exit self-refresh to active command time.
	// Position of TXSR field.
	EMC_DYNAMICXSR_TXSR_Pos = 0x0
	// Bit mask of TXSR field.
	EMC_DYNAMICXSR_TXSR_Msk = 0x1f
	// Position of RESERVED field.
	EMC_DYNAMICXSR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_DYNAMICXSR_RESERVED_Msk = 0xffffffe0

	// DYNAMICRRD: Selects the active bank A to active bank B latency.
	// Position of TRRD field.
	EMC_DYNAMICRRD_TRRD_Pos = 0x0
	// Bit mask of TRRD field.
	EMC_DYNAMICRRD_TRRD_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICRRD_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICRRD_RESERVED_Msk = 0xfffffff0

	// DYNAMICMRD: Selects the load mode register to active command time.
	// Position of TMRD field.
	EMC_DYNAMICMRD_TMRD_Pos = 0x0
	// Bit mask of TMRD field.
	EMC_DYNAMICMRD_TMRD_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICMRD_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICMRD_RESERVED_Msk = 0xfffffff0

	// STATICEXTENDEDWAIT: Selects time for long static memory read and write transfers.
	// Position of EXTENDEDWAIT field.
	EMC_STATICEXTENDEDWAIT_EXTENDEDWAIT_Pos = 0x0
	// Bit mask of EXTENDEDWAIT field.
	EMC_STATICEXTENDEDWAIT_EXTENDEDWAIT_Msk = 0x3ff
	// Position of RESERVED field.
	EMC_STATICEXTENDEDWAIT_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	EMC_STATICEXTENDEDWAIT_RESERVED_Msk = 0xfffffc00

	// DYNAMICCONFIG0: Selects the configuration information for dynamic memory chip select 0.
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0x7
	// Position of MD field.
	EMC_DYNAMICCONFIG_MD_Pos = 0x3
	// Bit mask of MD field.
	EMC_DYNAMICCONFIG_MD_Msk = 0x18
	// SDRAM (POR reset value).
	EMC_DYNAMICCONFIG_MD_SDRAM = 0x0
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0x60
	// Position of AM0 field.
	EMC_DYNAMICCONFIG_AM0_Pos = 0x7
	// Bit mask of AM0 field.
	EMC_DYNAMICCONFIG_AM0_Msk = 0x1f80
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	EMC_DYNAMICCONFIG_RESERVED = 0x2000
	// Position of AM1 field.
	EMC_DYNAMICCONFIG_AM1_Pos = 0xe
	// Bit mask of AM1 field.
	EMC_DYNAMICCONFIG_AM1_Msk = 0x4000
	// Bit AM1.
	EMC_DYNAMICCONFIG_AM1 = 0x4000
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0x78000
	// Position of B field.
	EMC_DYNAMICCONFIG_B_Pos = 0x13
	// Bit mask of B field.
	EMC_DYNAMICCONFIG_B_Msk = 0x80000
	// Bit B.
	EMC_DYNAMICCONFIG_B = 0x80000
	// Disabled. Buffer disabled for accesses to this chip select (POR reset value).
	EMC_DYNAMICCONFIG_B_DISABLED = 0x0
	// Enabled. Buffer enabled for accesses to this chip select. After configuration of the dynamic memory, the buffer must be enabled for normal operation. [2]
	EMC_DYNAMICCONFIG_B_ENABLED = 0x1
	// Position of P field.
	EMC_DYNAMICCONFIG_P_Pos = 0x14
	// Bit mask of P field.
	EMC_DYNAMICCONFIG_P_Msk = 0x100000
	// Bit P.
	EMC_DYNAMICCONFIG_P = 0x100000
	// None. Writes not protected (POR reset value).
	EMC_DYNAMICCONFIG_P_NONE = 0x0
	// Protected. Writes protected.
	EMC_DYNAMICCONFIG_P_PROTECTED = 0x1
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0xffe00000

	// DYNAMICRASCAS0: Selects the RAS and CAS latencies for dynamic memory chip select 0.
	// Position of RAS field.
	EMC_DYNAMICRASCAS_RAS_Pos = 0x0
	// Bit mask of RAS field.
	EMC_DYNAMICRASCAS_RAS_Msk = 0x3
	// One EMC_CCLK cycle.
	EMC_DYNAMICRASCAS_RAS_ONE_EMC_CCLK_CYCLE = 0x1
	// Two EMC_CCLK cycles.
	EMC_DYNAMICRASCAS_RAS_TWO_EMC_CCLK_CYCLES = 0x2
	// Three EMC_CCLK cycles (POR reset value).
	EMC_DYNAMICRASCAS_RAS_THREE_EMC_CCLK_CYCLE = 0x3
	// Position of RESERVED field.
	EMC_DYNAMICRASCAS_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	EMC_DYNAMICRASCAS_RESERVED_Msk = 0xfc
	// Position of CAS field.
	EMC_DYNAMICRASCAS_CAS_Pos = 0x8
	// Bit mask of CAS field.
	EMC_DYNAMICRASCAS_CAS_Msk = 0x300
	// One EMC_CCLK cycle.
	EMC_DYNAMICRASCAS_CAS_ONE_EMC_CCLK_CYCLE = 0x1
	// Two EMC_CCLK cycles.
	EMC_DYNAMICRASCAS_CAS_TWO_EMC_CCLK_CYCLES = 0x2
	// Three EMC_CCLK cycles (POR reset value).
	EMC_DYNAMICRASCAS_CAS_THREE_EMC_CCLK_CYCLE = 0x3
	// Position of RESERVED field.
	EMC_DYNAMICRASCAS_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	EMC_DYNAMICRASCAS_RESERVED_Msk = 0xfffffc00

	// STATICCONFIG0: Selects the memory configuration for static chip select 0.
	// Position of MW field.
	EMC_STATICCONFIG_MW_Pos = 0x0
	// Bit mask of MW field.
	EMC_STATICCONFIG_MW_Msk = 0x3
	// 8 bit (POR reset value).
	EMC_STATICCONFIG_MW_8_BIT = 0x0
	// 16 bit.
	EMC_STATICCONFIG_MW_16_BIT = 0x1
	// 32 bit.
	EMC_STATICCONFIG_MW_32_BIT = 0x2
	// Position of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Msk = 0x4
	// Bit RESERVED.
	EMC_STATICCONFIG_RESERVED = 0x4
	// Position of PM field.
	EMC_STATICCONFIG_PM_Pos = 0x3
	// Bit mask of PM field.
	EMC_STATICCONFIG_PM_Msk = 0x8
	// Bit PM.
	EMC_STATICCONFIG_PM = 0x8
	// Disabled. (POR reset value.)
	EMC_STATICCONFIG_PM_DISABLED = 0x0
	// Enabled. Async page mode enabled (page length four).
	EMC_STATICCONFIG_PM_ENABLED = 0x1
	// Position of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Msk = 0x30
	// Position of PC field.
	EMC_STATICCONFIG_PC_Pos = 0x6
	// Bit mask of PC field.
	EMC_STATICCONFIG_PC_Msk = 0x40
	// Bit PC.
	EMC_STATICCONFIG_PC = 0x40
	// Active LOW chip select.
	EMC_STATICCONFIG_PC_ACTIVE_LOW = 0x0
	// Active HIGH chip select.
	EMC_STATICCONFIG_PC_ACTIVE_HIGH = 0x1
	// Position of PB field.
	EMC_STATICCONFIG_PB_Pos = 0x7
	// Bit mask of PB field.
	EMC_STATICCONFIG_PB_Msk = 0x80
	// Bit PB.
	EMC_STATICCONFIG_PB = 0x80
	// High. For reads all the bits in BLSn[3:0] are HIGH. For writes the respective active bits in BLSn[3:0] are LOW (POR reset value).
	EMC_STATICCONFIG_PB_HIGH = 0x0
	// Low. For reads the respective active bits in BLSn[3:0] are LOW. For writes the respective active bits in BLSn[3:0] are LOW.
	EMC_STATICCONFIG_PB_LOW = 0x1
	// Position of EW field.
	EMC_STATICCONFIG_EW_Pos = 0x8
	// Bit mask of EW field.
	EMC_STATICCONFIG_EW_Msk = 0x100
	// Bit EW.
	EMC_STATICCONFIG_EW = 0x100
	// Disabled. Extended wait disabled (POR reset value).
	EMC_STATICCONFIG_EW_DISABLED = 0x0
	// Enabled. Extended wait enabled.
	EMC_STATICCONFIG_EW_ENABLED = 0x1
	// Position of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Msk = 0x7fe00
	// Position of B field.
	EMC_STATICCONFIG_B_Pos = 0x13
	// Bit mask of B field.
	EMC_STATICCONFIG_B_Msk = 0x80000
	// Bit B.
	EMC_STATICCONFIG_B = 0x80000
	// Disabled. Buffer disabled (POR reset value).
	EMC_STATICCONFIG_B_DISABLED = 0x0
	// Enabled. Buffer enabled.
	EMC_STATICCONFIG_B_ENABLED = 0x1
	// Position of P field.
	EMC_STATICCONFIG_P_Pos = 0x14
	// Bit mask of P field.
	EMC_STATICCONFIG_P_Msk = 0x100000
	// Bit P.
	EMC_STATICCONFIG_P = 0x100000
	// None. Writes not protected (POR reset value).
	EMC_STATICCONFIG_P_NONE = 0x0
	// Protect. Write protected.
	EMC_STATICCONFIG_P_PROTECT = 0x1
	// Position of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Msk = 0xffe00000

	// STATICWAITWEN0: Selects the delay from chip select 0 to write enable.
	// Position of WAITWEN field.
	EMC_STATICWAITWEN_WAITWEN_Pos = 0x0
	// Bit mask of WAITWEN field.
	EMC_STATICWAITWEN_WAITWEN_Msk = 0xf
	// Position of RESERVED field.
	EMC_STATICWAITWEN_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_STATICWAITWEN_RESERVED_Msk = 0xfffffff0

	// STATICWAITOEN0: Selects the delay from chip select 0 or address change, whichever is later, to output enable.
	// Position of WAITOEN field.
	EMC_STATICWAITOEN_WAITOEN_Pos = 0x0
	// Bit mask of WAITOEN field.
	EMC_STATICWAITOEN_WAITOEN_Msk = 0xf
	// Position of RESERVED field.
	EMC_STATICWAITOEN_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_STATICWAITOEN_RESERVED_Msk = 0xfffffff0

	// STATICWAITRD0: Selects the delay from chip select 0 to a read access.
	// Position of WAITRD field.
	EMC_STATICWAITRD_WAITRD_Pos = 0x0
	// Bit mask of WAITRD field.
	EMC_STATICWAITRD_WAITRD_Msk = 0x1f
	// Position of RESERVED field.
	EMC_STATICWAITRD_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_STATICWAITRD_RESERVED_Msk = 0xffffffe0

	// STATICWAITPAGE0: Selects the delay for asynchronous page mode sequential accesses for chip select 0.
	// Position of WAITPAGE field.
	EMC_STATICWAITPAGE_WAITPAGE_Pos = 0x0
	// Bit mask of WAITPAGE field.
	EMC_STATICWAITPAGE_WAITPAGE_Msk = 0x1f
	// Position of RESERVED field.
	EMC_STATICWAITPAGE_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_STATICWAITPAGE_RESERVED_Msk = 0xffffffe0

	// STATICWAITWR0: Selects the delay from chip select 0 to a write access.
	// Position of WAITWR field.
	EMC_STATICWAITWR_WAITWR_Pos = 0x0
	// Bit mask of WAITWR field.
	EMC_STATICWAITWR_WAITWR_Msk = 0x1f
	// Position of RESERVED field.
	EMC_STATICWAITWR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_STATICWAITWR_RESERVED_Msk = 0xffffffe0

	// STATICWAITTURN0: Selects the number of bus turnaround cycles for chip select 0.
	// Position of WAITTURN field.
	EMC_STATICWAITTURN_WAITTURN_Pos = 0x0
	// Bit mask of WAITTURN field.
	EMC_STATICWAITTURN_WAITTURN_Msk = 0xf
	// Position of RESERVED field.
	EMC_STATICWAITTURN_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_STATICWAITTURN_RESERVED_Msk = 0xfffffff0
)

// Constants for USB0: USB0 Host/Device/OTG controller
const (
	// CAPLENGTH: Capability register length
	// Position of CAPLENGTH field.
	USB0_CAPLENGTH_CAPLENGTH_Pos = 0x0
	// Bit mask of CAPLENGTH field.
	USB0_CAPLENGTH_CAPLENGTH_Msk = 0xff
	// Position of HCIVERSION field.
	USB0_CAPLENGTH_HCIVERSION_Pos = 0x8
	// Bit mask of HCIVERSION field.
	USB0_CAPLENGTH_HCIVERSION_Msk = 0xffff00
	// Position of RESERVED field.
	USB0_CAPLENGTH_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB0_CAPLENGTH_RESERVED_Msk = 0xff000000

	// HCSPARAMS: Host controller structural parameters
	// Position of N_PORTS field.
	USB0_HCSPARAMS_N_PORTS_Pos = 0x0
	// Bit mask of N_PORTS field.
	USB0_HCSPARAMS_N_PORTS_Msk = 0xf
	// Position of PPC field.
	USB0_HCSPARAMS_PPC_Pos = 0x4
	// Bit mask of PPC field.
	USB0_HCSPARAMS_PPC_Msk = 0x10
	// Bit PPC.
	USB0_HCSPARAMS_PPC = 0x10
	// Position of RESERVED field.
	USB0_HCSPARAMS_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB0_HCSPARAMS_RESERVED_Msk = 0xe0
	// Position of N_PCC field.
	USB0_HCSPARAMS_N_PCC_Pos = 0x8
	// Bit mask of N_PCC field.
	USB0_HCSPARAMS_N_PCC_Msk = 0xf00
	// Position of N_CC field.
	USB0_HCSPARAMS_N_CC_Pos = 0xc
	// Bit mask of N_CC field.
	USB0_HCSPARAMS_N_CC_Msk = 0xf000
	// Position of PI field.
	USB0_HCSPARAMS_PI_Pos = 0x10
	// Bit mask of PI field.
	USB0_HCSPARAMS_PI_Msk = 0x10000
	// Bit PI.
	USB0_HCSPARAMS_PI = 0x10000
	// Position of RESERVED field.
	USB0_HCSPARAMS_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB0_HCSPARAMS_RESERVED_Msk = 0xe0000
	// Position of N_PTT field.
	USB0_HCSPARAMS_N_PTT_Pos = 0x14
	// Bit mask of N_PTT field.
	USB0_HCSPARAMS_N_PTT_Msk = 0xf00000
	// Position of N_TT field.
	USB0_HCSPARAMS_N_TT_Pos = 0x18
	// Bit mask of N_TT field.
	USB0_HCSPARAMS_N_TT_Msk = 0xf000000
	// Position of RESERVED field.
	USB0_HCSPARAMS_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	USB0_HCSPARAMS_RESERVED_Msk = 0xf0000000

	// HCCPARAMS: Host controller capability parameters
	// Position of ADC field.
	USB0_HCCPARAMS_ADC_Pos = 0x0
	// Bit mask of ADC field.
	USB0_HCCPARAMS_ADC_Msk = 0x1
	// Bit ADC.
	USB0_HCCPARAMS_ADC = 0x1
	// Position of PFL field.
	USB0_HCCPARAMS_PFL_Pos = 0x1
	// Bit mask of PFL field.
	USB0_HCCPARAMS_PFL_Msk = 0x2
	// Bit PFL.
	USB0_HCCPARAMS_PFL = 0x2
	// Position of ASP field.
	USB0_HCCPARAMS_ASP_Pos = 0x2
	// Bit mask of ASP field.
	USB0_HCCPARAMS_ASP_Msk = 0x4
	// Bit ASP.
	USB0_HCCPARAMS_ASP = 0x4
	// Position of IST field.
	USB0_HCCPARAMS_IST_Pos = 0x4
	// Bit mask of IST field.
	USB0_HCCPARAMS_IST_Msk = 0xf0
	// Position of EECP field.
	USB0_HCCPARAMS_EECP_Pos = 0x8
	// Bit mask of EECP field.
	USB0_HCCPARAMS_EECP_Msk = 0xff00
	// Position of RESERVED field.
	USB0_HCCPARAMS_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB0_HCCPARAMS_RESERVED_Msk = 0xffff0000

	// DCIVERSION: Device interface version number
	// Position of DCIVERSION field.
	USB0_DCIVERSION_DCIVERSION_Pos = 0x0
	// Bit mask of DCIVERSION field.
	USB0_DCIVERSION_DCIVERSION_Msk = 0xffff

	// USBCMD_D: USB command (device mode)
	// Position of RS field.
	USB0_USBCMD_D_RS_Pos = 0x0
	// Bit mask of RS field.
	USB0_USBCMD_D_RS_Msk = 0x1
	// Bit RS.
	USB0_USBCMD_D_RS = 0x1
	// Writing a 0 to this bit will cause a detach event.
	USB0_USBCMD_D_RS_DETACH = 0x0
	// Writing a one to this bit will cause the device controller to enable a pull-up on USB_DP and initiate an attach event. This control bit is not directly connected to the pull-up enable, as the pull-up will become disabled upon transitioning into high-speed mode. Software should use this bit to prevent an attach event before the device controller has been properly initialized.
	USB0_USBCMD_D_RS_ATTACH = 0x1
	// Position of RST field.
	USB0_USBCMD_D_RST_Pos = 0x1
	// Bit mask of RST field.
	USB0_USBCMD_D_RST_Msk = 0x2
	// Bit RST.
	USB0_USBCMD_D_RST = 0x2
	// Set to 0 by hardware when the reset process is complete.
	USB0_USBCMD_D_RST_RESETCOMPLETE = 0x0
	// When software writes a one to this bit, the Device Controller resets its internal pipelines, timers, counters, state machines etc. to their initial values. Writing a one to this bit when the device is in the attached state is not recommended, since the effect on an attached host is undefined. In order to ensure that the device is not in an attached state before initiating a device controller reset, all primed endpoints should be flushed and the USBCMD Run/Stop bit should be set to 0.
	USB0_USBCMD_D_RST_RESET = 0x1
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0xc
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB0_USBCMD_D_RESERVED = 0x10
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0x20
	// Bit RESERVED.
	USB0_USBCMD_D_RESERVED = 0x20
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0x40
	// Bit RESERVED.
	USB0_USBCMD_D_RESERVED = 0x40
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0x80
	// Bit RESERVED.
	USB0_USBCMD_D_RESERVED = 0x80
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0x300
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0x400
	// Bit RESERVED.
	USB0_USBCMD_D_RESERVED = 0x400
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0x800
	// Bit RESERVED.
	USB0_USBCMD_D_RESERVED = 0x800
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0x1000
	// Bit RESERVED.
	USB0_USBCMD_D_RESERVED = 0x1000
	// Position of SUTW field.
	USB0_USBCMD_D_SUTW_Pos = 0xd
	// Bit mask of SUTW field.
	USB0_USBCMD_D_SUTW_Msk = 0x2000
	// Bit SUTW.
	USB0_USBCMD_D_SUTW = 0x2000
	// Position of ATDTW field.
	USB0_USBCMD_D_ATDTW_Pos = 0xe
	// Bit mask of ATDTW field.
	USB0_USBCMD_D_ATDTW_Msk = 0x4000
	// Bit ATDTW.
	USB0_USBCMD_D_ATDTW = 0x4000
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0x8000
	// Bit RESERVED.
	USB0_USBCMD_D_RESERVED = 0x8000
	// Position of ITC field.
	USB0_USBCMD_D_ITC_Pos = 0x10
	// Bit mask of ITC field.
	USB0_USBCMD_D_ITC_Msk = 0xff0000
	// Position of RESERVED field.
	USB0_USBCMD_D_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB0_USBCMD_D_RESERVED_Msk = 0xff000000

	// USBCMD_H: USB command (host mode)
	// Position of RS field.
	USB0_USBCMD_H_RS_Pos = 0x0
	// Bit mask of RS field.
	USB0_USBCMD_H_RS_Msk = 0x1
	// Bit RS.
	USB0_USBCMD_H_RS = 0x1
	// When this bit is set to 0, the Host Controller completes the current transaction on the USB and then halts. The HC Halted bit in the status register indicates when the Host Controller has finished the transaction and has entered the stopped state. Software should not write a one to this field unless the host controller is in the Halted state (i.e. HCHalted in the USBSTS register is a one).
	USB0_USBCMD_H_RS_HALT = 0x0
	// When set to a 1, the Host Controller proceeds with the execution of the schedule. The Host Controller continues execution as long as this bit is set to a one.
	USB0_USBCMD_H_RS_PROCEED = 0x1
	// Position of RST field.
	USB0_USBCMD_H_RST_Pos = 0x1
	// Bit mask of RST field.
	USB0_USBCMD_H_RST_Msk = 0x2
	// Bit RST.
	USB0_USBCMD_H_RST = 0x2
	// This bit is set to zero by hardware when the reset process is complete.
	USB0_USBCMD_H_RST_RESETCOMPLETE = 0x0
	// When software writes a one to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value. Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports. Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero. Attempting to reset an actively running host controller will result in undefined behavior.
	USB0_USBCMD_H_RST_RESET = 0x1
	// Position of FS0 field.
	USB0_USBCMD_H_FS0_Pos = 0x2
	// Bit mask of FS0 field.
	USB0_USBCMD_H_FS0_Msk = 0x4
	// Bit FS0.
	USB0_USBCMD_H_FS0 = 0x4
	// Position of FS1 field.
	USB0_USBCMD_H_FS1_Pos = 0x3
	// Bit mask of FS1 field.
	USB0_USBCMD_H_FS1_Msk = 0x8
	// Bit FS1.
	USB0_USBCMD_H_FS1 = 0x8
	// Position of PSE field.
	USB0_USBCMD_H_PSE_Pos = 0x4
	// Bit mask of PSE field.
	USB0_USBCMD_H_PSE_Msk = 0x10
	// Bit PSE.
	USB0_USBCMD_H_PSE = 0x10
	// Do not process the periodic schedule.
	USB0_USBCMD_H_PSE_DO_NOT_PROCESS_THE_P = 0x0
	// Use the PERIODICLISTBASE register to access the periodic schedule.
	USB0_USBCMD_H_PSE_USE_THE_PERIODICLIST = 0x1
	// Position of ASE field.
	USB0_USBCMD_H_ASE_Pos = 0x5
	// Bit mask of ASE field.
	USB0_USBCMD_H_ASE_Msk = 0x20
	// Bit ASE.
	USB0_USBCMD_H_ASE = 0x20
	// Do not process the asynchronous schedule.
	USB0_USBCMD_H_ASE_DO_NOT_PROCESS_THE_A = 0x0
	// Use the ASYNCLISTADDR to access the asynchronous schedule.
	USB0_USBCMD_H_ASE_USE_THE_ASYNCLISTADD = 0x1
	// Position of IAA field.
	USB0_USBCMD_H_IAA_Pos = 0x6
	// Bit mask of IAA field.
	USB0_USBCMD_H_IAA_Msk = 0x40
	// Bit IAA.
	USB0_USBCMD_H_IAA = 0x40
	// The host controller sets this bit to zero after it has set the Interrupt on Sync Advance status bit in the USBSTS register to one.
	USB0_USBCMD_H_IAA_THE_HOST_CONTROLLER_ = 0x0
	// Software must write a 1 to this bit to ring the doorbell. When the host controller has evicted all appropriate cached schedule states, it sets the Interrupt on Async Advance status bit in the USBSTS register. If the Interrupt on Sync Advance Enable bit in the USBINTR register is one, then the host controller will assert an interrupt at the next interrupt threshold. Software should not write a one to this bit when the asynchronous schedule is inactive. Doing so will yield undefined results.
	USB0_USBCMD_H_IAA_SOFTWARE_MUST_WRITE_ = 0x1
	// Position of RESERVED field.
	USB0_USBCMD_H_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	USB0_USBCMD_H_RESERVED_Msk = 0x80
	// Bit RESERVED.
	USB0_USBCMD_H_RESERVED = 0x80
	// Position of ASP1_0 field.
	USB0_USBCMD_H_ASP1_0_Pos = 0x8
	// Bit mask of ASP1_0 field.
	USB0_USBCMD_H_ASP1_0_Msk = 0x300
	// Position of RESERVED field.
	USB0_USBCMD_H_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB0_USBCMD_H_RESERVED_Msk = 0x400
	// Bit RESERVED.
	USB0_USBCMD_H_RESERVED = 0x400
	// Position of ASPE field.
	USB0_USBCMD_H_ASPE_Pos = 0xb
	// Bit mask of ASPE field.
	USB0_USBCMD_H_ASPE_Msk = 0x800
	// Bit ASPE.
	USB0_USBCMD_H_ASPE = 0x800
	// Park mode is disabled.
	USB0_USBCMD_H_ASPE_PARK_MODE_IS_DISABLE = 0x0
	// Park mode is enabled.
	USB0_USBCMD_H_ASPE_PARK_MODE_IS_ENABLED = 0x1
	// Position of RESERVED field.
	USB0_USBCMD_H_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	USB0_USBCMD_H_RESERVED_Msk = 0x1000
	// Bit RESERVED.
	USB0_USBCMD_H_RESERVED = 0x1000
	// Position of RESERVED field.
	USB0_USBCMD_H_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB0_USBCMD_H_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	USB0_USBCMD_H_RESERVED = 0x2000
	// Position of RESERVED field.
	USB0_USBCMD_H_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	USB0_USBCMD_H_RESERVED_Msk = 0x4000
	// Bit RESERVED.
	USB0_USBCMD_H_RESERVED = 0x4000
	// Position of FS2 field.
	USB0_USBCMD_H_FS2_Pos = 0xf
	// Bit mask of FS2 field.
	USB0_USBCMD_H_FS2_Msk = 0x8000
	// Bit FS2.
	USB0_USBCMD_H_FS2 = 0x8000
	// Position of ITC field.
	USB0_USBCMD_H_ITC_Pos = 0x10
	// Bit mask of ITC field.
	USB0_USBCMD_H_ITC_Msk = 0xff0000
	// Position of RESERVED field.
	USB0_USBCMD_H_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB0_USBCMD_H_RESERVED_Msk = 0xff000000

	// USBSTS_D: USB status (device mode)
	// Position of UI field.
	USB0_USBSTS_D_UI_Pos = 0x0
	// Bit mask of UI field.
	USB0_USBSTS_D_UI_Msk = 0x1
	// Bit UI.
	USB0_USBSTS_D_UI = 0x1
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_D_UI_ST = 0x0
	// This bit is set by the Host/Device Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set. This bit is also set by the Host/Device Controller when a short packet is detected. A short packet is when the actual number of bytes received was less than the expected number of bytes.
	USB0_USBSTS_D_UI_CLEAR = 0x1
	// Position of UEI field.
	USB0_USBSTS_D_UEI_Pos = 0x1
	// Bit mask of UEI field.
	USB0_USBSTS_D_UEI_Msk = 0x2
	// Bit UEI.
	USB0_USBSTS_D_UEI = 0x2
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_D_UEI_ST = 0x0
	// When completion of a USB transaction results in an error condition, this bit is set by the Host/Device Controller. This bit is set along with the USBINT bit, if the TD on which the error interrupt occurred also had its interrupt on complete (IOC) bit set. The device controller detects resume signaling only (see Section 18.10.11.6).
	USB0_USBSTS_D_UEI_CLEAR = 0x1
	// Position of PCI field.
	USB0_USBSTS_D_PCI_Pos = 0x2
	// Bit mask of PCI field.
	USB0_USBSTS_D_PCI_Msk = 0x4
	// Bit PCI.
	USB0_USBSTS_D_PCI = 0x4
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_D_PCI_ST = 0x0
	// The Device Controller sets this bit to a one when the port controller enters the full or high-speed operational state. When the port controller exits the full or high-speed operation states due to Reset or Suspend events, the notification mechanisms are the USB Reset Received bit (URI) and the DCSuspend bits (SLI) respectively.
	USB0_USBSTS_D_PCI_CLEAR = 0x1
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0x8
	// Bit RESERVED.
	USB0_USBSTS_D_RESERVED = 0x8
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB0_USBSTS_D_RESERVED = 0x10
	// Position of AAI field.
	USB0_USBSTS_D_AAI_Pos = 0x5
	// Bit mask of AAI field.
	USB0_USBSTS_D_AAI_Msk = 0x20
	// Bit AAI.
	USB0_USBSTS_D_AAI = 0x20
	// Position of URI field.
	USB0_USBSTS_D_URI_Pos = 0x6
	// Bit mask of URI field.
	USB0_USBSTS_D_URI_Msk = 0x40
	// Bit URI.
	USB0_USBSTS_D_URI = 0x40
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_D_URI_ST = 0x0
	// When the device controller detects a USB Reset and enters the default state, this bit will be set to a one.
	USB0_USBSTS_D_URI_CLEAR = 0x1
	// Position of SRI field.
	USB0_USBSTS_D_SRI_Pos = 0x7
	// Bit mask of SRI field.
	USB0_USBSTS_D_SRI_Msk = 0x80
	// Bit SRI.
	USB0_USBSTS_D_SRI = 0x80
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_D_SRI_ST = 0x0
	// When the device controller detects a Start Of (micro) Frame, this bit will be set to a one. When a SOF is extremely late, the device controller will automatically set this bit to indicate that an SOF was expected. Therefore, this bit will be set roughly every 1 ms in device FS mode and every 125 ms in HS mode and will be synchronized to the actual SOF that is received. Since the device controller is initialized to FS before connect, this bit will be set at an interval of 1ms during the prelude to connect and chirp.
	USB0_USBSTS_D_SRI_CLEAR = 0x1
	// Position of SLI field.
	USB0_USBSTS_D_SLI_Pos = 0x8
	// Bit mask of SLI field.
	USB0_USBSTS_D_SLI_Msk = 0x100
	// Bit SLI.
	USB0_USBSTS_D_SLI = 0x100
	// The device controller clears the bit upon exiting from a suspend state. This bit is cleared by software writing a one to it.
	USB0_USBSTS_D_SLI_ST = 0x0
	// When a device controller enters a suspend state from an active state, this bit will be set to a one.
	USB0_USBSTS_D_SLI_CLEAR = 0x1
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0xe00
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0x1000
	// Bit RESERVED.
	USB0_USBSTS_D_RESERVED = 0x1000
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	USB0_USBSTS_D_RESERVED = 0x2000
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0x4000
	// Bit RESERVED.
	USB0_USBSTS_D_RESERVED = 0x4000
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0x8000
	// Bit RESERVED.
	USB0_USBSTS_D_RESERVED = 0x8000
	// Position of NAKI field.
	USB0_USBSTS_D_NAKI_Pos = 0x10
	// Bit mask of NAKI field.
	USB0_USBSTS_D_NAKI_Msk = 0x10000
	// Bit NAKI.
	USB0_USBSTS_D_NAKI = 0x10000
	// This bit is automatically cleared by hardware when the all the enabled TX/RX Endpoint NAK bits are cleared.
	USB0_USBSTS_D_NAKI_ST = 0x0
	// It is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and the corresponding TX/RX Endpoint NAK Enable bit are set.
	USB0_USBSTS_D_NAKI_CLEAR = 0x1
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB0_USBSTS_D_RESERVED = 0x20000
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0x40000
	// Bit RESERVED.
	USB0_USBSTS_D_RESERVED = 0x40000
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0x80000
	// Bit RESERVED.
	USB0_USBSTS_D_RESERVED = 0x80000
	// Position of RESERVED field.
	USB0_USBSTS_D_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB0_USBSTS_D_RESERVED_Msk = 0xfff00000

	// USBSTS_H: USB status (host mode)
	// Position of UI field.
	USB0_USBSTS_H_UI_Pos = 0x0
	// Bit mask of UI field.
	USB0_USBSTS_H_UI_Msk = 0x1
	// Bit UI.
	USB0_USBSTS_H_UI = 0x1
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_H_UI_ST = 0x0
	// This bit is set by the Host/Device Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set. This bit is also set by the Host/Device Controller when a short packet is detected. A short packet is when the actual number of bytes received was less than the expected number of bytes.
	USB0_USBSTS_H_UI_CLEAR = 0x1
	// Position of UEI field.
	USB0_USBSTS_H_UEI_Pos = 0x1
	// Bit mask of UEI field.
	USB0_USBSTS_H_UEI_Msk = 0x2
	// Bit UEI.
	USB0_USBSTS_H_UEI = 0x2
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_H_UEI_ST = 0x0
	// When completion of a USB transaction results in an error condition, this bit is set by the Host/Device Controller. This bit is set along with the USBINT bit, if the TD on which the error interrupt occurred also had its interrupt on complete (IOC) bit set.
	USB0_USBSTS_H_UEI_CLEAR = 0x1
	// Position of PCI field.
	USB0_USBSTS_H_PCI_Pos = 0x2
	// Bit mask of PCI field.
	USB0_USBSTS_H_PCI_Msk = 0x4
	// Bit PCI.
	USB0_USBSTS_H_PCI = 0x4
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_H_PCI_ST = 0x0
	// The Host Controller sets this bit to a one when on any port a Connect Status occurs, a Port Enable/Disable Change occurs, or the Force Port Resume bit is set as the result of a J-K transition on the suspended port.
	USB0_USBSTS_H_PCI_CLEAR = 0x1
	// Position of FRI field.
	USB0_USBSTS_H_FRI_Pos = 0x3
	// Bit mask of FRI field.
	USB0_USBSTS_H_FRI_Msk = 0x8
	// Bit FRI.
	USB0_USBSTS_H_FRI = 0x8
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_H_FRI_ST = 0x0
	// The Host Controller sets this bit to a one when the Frame List Index rolls over from its maximum value to zero. The exact value at which the rollover occurs depends on the frame list size. For example, if the frame list size (as programmed in the Frame List Size field of the USBCMD register) is 1024, the Frame Index Register rolls over every time FRINDEX bit 13 toggles. Similarly, if the size is 512, the Host Controller sets this bit to a one every time FRINDEX bit 12 toggles (see Section 18.6.6).
	USB0_USBSTS_H_FRI_CLEAR = 0x1
	// Position of RESERVED field.
	USB0_USBSTS_H_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB0_USBSTS_H_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB0_USBSTS_H_RESERVED = 0x10
	// Position of AAI field.
	USB0_USBSTS_H_AAI_Pos = 0x5
	// Bit mask of AAI field.
	USB0_USBSTS_H_AAI_Msk = 0x20
	// Bit AAI.
	USB0_USBSTS_H_AAI = 0x20
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_H_AAI_ST = 0x0
	// System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing a one to the Interrupt on Async Advance Doorbell bit in the USBCMD register. This status bit indicates the assertion of that interrupt source.
	USB0_USBSTS_H_AAI_CLEAR = 0x1
	// Position of RESERVED field.
	USB0_USBSTS_H_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_USBSTS_H_RESERVED_Msk = 0x40
	// Bit RESERVED.
	USB0_USBSTS_H_RESERVED = 0x40
	// Position of SRI field.
	USB0_USBSTS_H_SRI_Pos = 0x7
	// Bit mask of SRI field.
	USB0_USBSTS_H_SRI_Msk = 0x80
	// Bit SRI.
	USB0_USBSTS_H_SRI = 0x80
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_H_SRI_ST = 0x0
	// In host mode, this bit will be set every 125 ms and can be used by host controller driver as a time base.
	USB0_USBSTS_H_SRI_CLEAR = 0x1
	// Position of RESERVED field.
	USB0_USBSTS_H_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB0_USBSTS_H_RESERVED_Msk = 0x100
	// Bit RESERVED.
	USB0_USBSTS_H_RESERVED = 0x100
	// Position of RESERVED field.
	USB0_USBSTS_H_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USB0_USBSTS_H_RESERVED_Msk = 0xe00
	// Position of HCH field.
	USB0_USBSTS_H_HCH_Pos = 0xc
	// Bit mask of HCH field.
	USB0_USBSTS_H_HCH_Msk = 0x1000
	// Bit HCH.
	USB0_USBSTS_H_HCH = 0x1000
	// The RS bit in USBCMD is set to zero. Set by the host controller.
	USB0_USBSTS_H_HCH_RS = 0x0
	// The Host Controller sets this bit to one after it has stopped executing because of the Run/Stop bit being set to 0, either by software or by the Host Controller hardware (e.g. because of an internal error).
	USB0_USBSTS_H_HCH_HALT = 0x1
	// Position of RCL field.
	USB0_USBSTS_H_RCL_Pos = 0xd
	// Bit mask of RCL field.
	USB0_USBSTS_H_RCL_Msk = 0x2000
	// Bit RCL.
	USB0_USBSTS_H_RCL = 0x2000
	// No empty asynchronous schedule detected.
	USB0_USBSTS_H_RCL_NO_EMPTY_ASYNCHRONOU = 0x0
	// An empty asynchronous schedule is detected. Set by the host controller.
	USB0_USBSTS_H_RCL_EMPTY_ASYNCHRONOU = 0x1
	// Position of PS field.
	USB0_USBSTS_H_PS_Pos = 0xe
	// Bit mask of PS field.
	USB0_USBSTS_H_PS_Msk = 0x4000
	// Bit PS.
	USB0_USBSTS_H_PS = 0x4000
	// Position of AS field.
	USB0_USBSTS_H_AS_Pos = 0xf
	// Bit mask of AS field.
	USB0_USBSTS_H_AS_Msk = 0x8000
	// Bit AS.
	USB0_USBSTS_H_AS = 0x8000
	// Position of RESERVED field.
	USB0_USBSTS_H_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB0_USBSTS_H_RESERVED_Msk = 0x10000
	// Bit RESERVED.
	USB0_USBSTS_H_RESERVED = 0x10000
	// Position of RESERVED field.
	USB0_USBSTS_H_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB0_USBSTS_H_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB0_USBSTS_H_RESERVED = 0x20000
	// Position of UAI field.
	USB0_USBSTS_H_UAI_Pos = 0x12
	// Bit mask of UAI field.
	USB0_USBSTS_H_UAI_Msk = 0x40000
	// Bit UAI.
	USB0_USBSTS_H_UAI = 0x40000
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_H_UAI_ST = 0x0
	// This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the asynchronous schedule. This bit is also set by the Host when a short packet is detected and the packet is on the asynchronous schedule. A short packet is when the actual number of bytes received was less than the expected number of bytes.
	USB0_USBSTS_H_UAI_CLEAR = 0x1
	// Position of UPI field.
	USB0_USBSTS_H_UPI_Pos = 0x13
	// Bit mask of UPI field.
	USB0_USBSTS_H_UPI_Msk = 0x80000
	// Bit UPI.
	USB0_USBSTS_H_UPI = 0x80000
	// This bit is cleared by software writing a one to it.
	USB0_USBSTS_H_UPI_ST = 0x0
	// This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule. This bit is also set by the Host Controller when a short packet is detected and the packet is on the periodic schedule. A short packet is when the actual number of bytes received was less than the expected number of bytes.
	USB0_USBSTS_H_UPI_CLEAR = 0x1
	// Position of RESERVED field.
	USB0_USBSTS_H_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB0_USBSTS_H_RESERVED_Msk = 0xfff00000

	// USBINTR_D: USB interrupt enable (device mode)
	// Position of UE field.
	USB0_USBINTR_D_UE_Pos = 0x0
	// Bit mask of UE field.
	USB0_USBINTR_D_UE_Msk = 0x1
	// Bit UE.
	USB0_USBINTR_D_UE = 0x1
	// Position of UEE field.
	USB0_USBINTR_D_UEE_Pos = 0x1
	// Bit mask of UEE field.
	USB0_USBINTR_D_UEE_Msk = 0x2
	// Bit UEE.
	USB0_USBINTR_D_UEE = 0x2
	// Position of PCE field.
	USB0_USBINTR_D_PCE_Pos = 0x2
	// Bit mask of PCE field.
	USB0_USBINTR_D_PCE_Msk = 0x4
	// Bit PCE.
	USB0_USBINTR_D_PCE = 0x4
	// Position of RESERVED field.
	USB0_USBINTR_D_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USB0_USBINTR_D_RESERVED_Msk = 0x8
	// Bit RESERVED.
	USB0_USBINTR_D_RESERVED = 0x8
	// Position of RESERVED field.
	USB0_USBINTR_D_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB0_USBINTR_D_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB0_USBINTR_D_RESERVED = 0x10
	// Position of RESERVED field.
	USB0_USBINTR_D_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB0_USBINTR_D_RESERVED_Msk = 0x20
	// Bit RESERVED.
	USB0_USBINTR_D_RESERVED = 0x20
	// Position of URE field.
	USB0_USBINTR_D_URE_Pos = 0x6
	// Bit mask of URE field.
	USB0_USBINTR_D_URE_Msk = 0x40
	// Bit URE.
	USB0_USBINTR_D_URE = 0x40
	// Position of SRE field.
	USB0_USBINTR_D_SRE_Pos = 0x7
	// Bit mask of SRE field.
	USB0_USBINTR_D_SRE_Msk = 0x80
	// Bit SRE.
	USB0_USBINTR_D_SRE = 0x80
	// Position of SLE field.
	USB0_USBINTR_D_SLE_Pos = 0x8
	// Bit mask of SLE field.
	USB0_USBINTR_D_SLE_Msk = 0x100
	// Bit SLE.
	USB0_USBINTR_D_SLE = 0x100
	// Position of RESERVED field.
	USB0_USBINTR_D_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USB0_USBINTR_D_RESERVED_Msk = 0xfe00
	// Position of NAKE field.
	USB0_USBINTR_D_NAKE_Pos = 0x10
	// Bit mask of NAKE field.
	USB0_USBINTR_D_NAKE_Msk = 0x10000
	// Bit NAKE.
	USB0_USBINTR_D_NAKE = 0x10000
	// Position of RESERVED field.
	USB0_USBINTR_D_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB0_USBINTR_D_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB0_USBINTR_D_RESERVED = 0x20000
	// Position of RESERVED field.
	USB0_USBINTR_D_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	USB0_USBINTR_D_RESERVED_Msk = 0x40000
	// Bit RESERVED.
	USB0_USBINTR_D_RESERVED = 0x40000
	// Position of RESERVED field.
	USB0_USBINTR_D_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	USB0_USBINTR_D_RESERVED_Msk = 0x80000
	// Bit RESERVED.
	USB0_USBINTR_D_RESERVED = 0x80000
	// Position of RESERVED field.
	USB0_USBINTR_D_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB0_USBINTR_D_RESERVED_Msk = 0xfff00000

	// USBINTR_H: USB interrupt enable (host mode)
	// Position of UE field.
	USB0_USBINTR_H_UE_Pos = 0x0
	// Bit mask of UE field.
	USB0_USBINTR_H_UE_Msk = 0x1
	// Bit UE.
	USB0_USBINTR_H_UE = 0x1
	// Position of UEE field.
	USB0_USBINTR_H_UEE_Pos = 0x1
	// Bit mask of UEE field.
	USB0_USBINTR_H_UEE_Msk = 0x2
	// Bit UEE.
	USB0_USBINTR_H_UEE = 0x2
	// Position of PCE field.
	USB0_USBINTR_H_PCE_Pos = 0x2
	// Bit mask of PCE field.
	USB0_USBINTR_H_PCE_Msk = 0x4
	// Bit PCE.
	USB0_USBINTR_H_PCE = 0x4
	// Position of FRE field.
	USB0_USBINTR_H_FRE_Pos = 0x3
	// Bit mask of FRE field.
	USB0_USBINTR_H_FRE_Msk = 0x8
	// Bit FRE.
	USB0_USBINTR_H_FRE = 0x8
	// Position of RESERVED field.
	USB0_USBINTR_H_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB0_USBINTR_H_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB0_USBINTR_H_RESERVED = 0x10
	// Position of AAE field.
	USB0_USBINTR_H_AAE_Pos = 0x5
	// Bit mask of AAE field.
	USB0_USBINTR_H_AAE_Msk = 0x20
	// Bit AAE.
	USB0_USBINTR_H_AAE = 0x20
	// Position of RESERVED field.
	USB0_USBINTR_H_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_USBINTR_H_RESERVED_Msk = 0x40
	// Bit RESERVED.
	USB0_USBINTR_H_RESERVED = 0x40
	// Position of SRE field.
	USB0_USBINTR_H_SRE_Pos = 0x7
	// Bit mask of SRE field.
	USB0_USBINTR_H_SRE_Msk = 0x80
	// Bit SRE.
	USB0_USBINTR_H_SRE = 0x80
	// Position of RESERVED field.
	USB0_USBINTR_H_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB0_USBINTR_H_RESERVED_Msk = 0x100
	// Bit RESERVED.
	USB0_USBINTR_H_RESERVED = 0x100
	// Position of RESERVED field.
	USB0_USBINTR_H_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USB0_USBINTR_H_RESERVED_Msk = 0xfe00
	// Position of RESERVED field.
	USB0_USBINTR_H_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB0_USBINTR_H_RESERVED_Msk = 0x10000
	// Bit RESERVED.
	USB0_USBINTR_H_RESERVED = 0x10000
	// Position of RESERVED field.
	USB0_USBINTR_H_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB0_USBINTR_H_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB0_USBINTR_H_RESERVED = 0x20000
	// Position of UAIE field.
	USB0_USBINTR_H_UAIE_Pos = 0x12
	// Bit mask of UAIE field.
	USB0_USBINTR_H_UAIE_Msk = 0x40000
	// Bit UAIE.
	USB0_USBINTR_H_UAIE = 0x40000
	// Position of UPIA field.
	USB0_USBINTR_H_UPIA_Pos = 0x13
	// Bit mask of UPIA field.
	USB0_USBINTR_H_UPIA_Msk = 0x80000
	// Bit UPIA.
	USB0_USBINTR_H_UPIA = 0x80000
	// Position of RESERVED field.
	USB0_USBINTR_H_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB0_USBINTR_H_RESERVED_Msk = 0xfff00000

	// FRINDEX_D: USB frame index (device mode)
	// Position of FRINDEX2_0 field.
	USB0_FRINDEX_D_FRINDEX2_0_Pos = 0x0
	// Bit mask of FRINDEX2_0 field.
	USB0_FRINDEX_D_FRINDEX2_0_Msk = 0x7
	// Position of FRINDEX13_3 field.
	USB0_FRINDEX_D_FRINDEX13_3_Pos = 0x3
	// Bit mask of FRINDEX13_3 field.
	USB0_FRINDEX_D_FRINDEX13_3_Msk = 0x3ff8
	// Position of RESERVED field.
	USB0_FRINDEX_D_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	USB0_FRINDEX_D_RESERVED_Msk = 0xffffc000

	// FRINDEX_H: USB frame index (host mode)
	// Position of FRINDEX2_0 field.
	USB0_FRINDEX_H_FRINDEX2_0_Pos = 0x0
	// Bit mask of FRINDEX2_0 field.
	USB0_FRINDEX_H_FRINDEX2_0_Msk = 0x7
	// Position of FRINDEX12_3 field.
	USB0_FRINDEX_H_FRINDEX12_3_Pos = 0x3
	// Bit mask of FRINDEX12_3 field.
	USB0_FRINDEX_H_FRINDEX12_3_Msk = 0x1ff8
	// Position of RESERVED field.
	USB0_FRINDEX_H_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB0_FRINDEX_H_RESERVED_Msk = 0xffffe000

	// DEVICEADDR: USB device address (device mode)
	// Position of RESERVED field.
	USB0_DEVICEADDR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB0_DEVICEADDR_RESERVED_Msk = 0xffffff
	// Position of USBADRA field.
	USB0_DEVICEADDR_USBADRA_Pos = 0x18
	// Bit mask of USBADRA field.
	USB0_DEVICEADDR_USBADRA_Msk = 0x1000000
	// Bit USBADRA.
	USB0_DEVICEADDR_USBADRA = 0x1000000
	// Any write to USBADR are instantaneous.
	USB0_DEVICEADDR_USBADRA_INSTANTANEOUS = 0x0
	// When the user writes a one to this bit at the same time or before USBADR is written, the write to USBADR fields is staged and held in a hidden register. After an IN occurs on endpoint 0 and is acknowledged, USBADR will be loaded from the holding register. Hardware will automatically clear this bit on the following conditions: IN is ACKed to endpoint 0. USBADR is updated from the staging register. OUT/SETUP occurs on endpoint 0. USBADR is not updated. Device reset occurs. USBADR is set to 0. After the status phase of the SET_ADDRESS descriptor, the DCD has 2 ms to program the USBADR field. This mechanism will ensure this specification is met when the DCD can not write the device address within 2 ms from the SET_ADDRESS status phase. If the DCD writes the USBADR with USBADRA=1 after the SET_ADDRESS data phase (before the prime of the status phase), the USBADR will be programmed instantly at the correct time and meet the 2 ms USB requirement.
	USB0_DEVICEADDR_USBADRA_DELAYED = 0x1
	// Position of USBADR field.
	USB0_DEVICEADDR_USBADR_Pos = 0x19
	// Bit mask of USBADR field.
	USB0_DEVICEADDR_USBADR_Msk = 0xfe000000

	// PERIODICLISTBASE: Frame list base address (host mode)
	// Position of RESERVED field.
	USB0_PERIODICLISTBASE_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB0_PERIODICLISTBASE_RESERVED_Msk = 0xfff
	// Position of PERBASE31_12 field.
	USB0_PERIODICLISTBASE_PERBASE31_12_Pos = 0xc
	// Bit mask of PERBASE31_12 field.
	USB0_PERIODICLISTBASE_PERBASE31_12_Msk = 0xfffff000

	// ENDPOINTLISTADDR: Address of endpoint list in memory
	// Position of RESERVED field.
	USB0_ENDPOINTLISTADDR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB0_ENDPOINTLISTADDR_RESERVED_Msk = 0x7ff
	// Position of EPBASE31_11 field.
	USB0_ENDPOINTLISTADDR_EPBASE31_11_Pos = 0xb
	// Bit mask of EPBASE31_11 field.
	USB0_ENDPOINTLISTADDR_EPBASE31_11_Msk = 0xfffff800

	// ASYNCLISTADDR: Address of endpoint list in memory
	// Position of RESERVED field.
	USB0_ASYNCLISTADDR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB0_ASYNCLISTADDR_RESERVED_Msk = 0x1f
	// Position of ASYBASE31_5 field.
	USB0_ASYNCLISTADDR_ASYBASE31_5_Pos = 0x5
	// Bit mask of ASYBASE31_5 field.
	USB0_ASYNCLISTADDR_ASYBASE31_5_Msk = 0xffffffe0

	// TTCTRL: Asynchronous buffer status for embedded TT (host mode)
	// Position of RESERVED field.
	USB0_TTCTRL_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB0_TTCTRL_RESERVED_Msk = 0xffffff
	// Position of TTHA field.
	USB0_TTCTRL_TTHA_Pos = 0x18
	// Bit mask of TTHA field.
	USB0_TTCTRL_TTHA_Msk = 0x7f000000
	// Position of RESERVED field.
	USB0_TTCTRL_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	USB0_TTCTRL_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	USB0_TTCTRL_RESERVED = 0x80000000

	// BURSTSIZE: Programmable burst size
	// Position of RXPBURST field.
	USB0_BURSTSIZE_RXPBURST_Pos = 0x0
	// Bit mask of RXPBURST field.
	USB0_BURSTSIZE_RXPBURST_Msk = 0xff
	// Position of TXPBURST field.
	USB0_BURSTSIZE_TXPBURST_Pos = 0x8
	// Bit mask of TXPBURST field.
	USB0_BURSTSIZE_TXPBURST_Msk = 0xff00
	// Position of RESERVED field.
	USB0_BURSTSIZE_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB0_BURSTSIZE_RESERVED_Msk = 0xffff0000

	// TXFILLTUNING: Host transmit pre-buffer packet tuning (host mode)
	// Position of TXSCHOH field.
	USB0_TXFILLTUNING_TXSCHOH_Pos = 0x0
	// Bit mask of TXSCHOH field.
	USB0_TXFILLTUNING_TXSCHOH_Msk = 0xff
	// Position of TXSCHEATLTH field.
	USB0_TXFILLTUNING_TXSCHEATLTH_Pos = 0x8
	// Bit mask of TXSCHEATLTH field.
	USB0_TXFILLTUNING_TXSCHEATLTH_Msk = 0x1f00
	// Position of RESERVED field.
	USB0_TXFILLTUNING_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB0_TXFILLTUNING_RESERVED_Msk = 0xe000
	// Position of TXFIFOTHRES field.
	USB0_TXFILLTUNING_TXFIFOTHRES_Pos = 0x10
	// Bit mask of TXFIFOTHRES field.
	USB0_TXFILLTUNING_TXFIFOTHRES_Msk = 0x3f0000
	// Position of RESERVED field.
	USB0_TXFILLTUNING_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB0_TXFILLTUNING_RESERVED_Msk = 0xffc00000

	// BINTERVAL: Length of virtual frame
	// Position of BINT field.
	USB0_BINTERVAL_BINT_Pos = 0x0
	// Bit mask of BINT field.
	USB0_BINTERVAL_BINT_Msk = 0xf
	// Position of RESERVED field.
	USB0_BINTERVAL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB0_BINTERVAL_RESERVED_Msk = 0xfffffff0

	// ENDPTNAK: Endpoint NAK (device mode)
	// Position of EPRN0 field.
	USB0_ENDPTNAK_EPRN0_Pos = 0x0
	// Bit mask of EPRN0 field.
	USB0_ENDPTNAK_EPRN0_Msk = 0x1
	// Bit EPRN0.
	USB0_ENDPTNAK_EPRN0 = 0x1
	// Position of EPRN1 field.
	USB0_ENDPTNAK_EPRN1_Pos = 0x1
	// Bit mask of EPRN1 field.
	USB0_ENDPTNAK_EPRN1_Msk = 0x2
	// Bit EPRN1.
	USB0_ENDPTNAK_EPRN1 = 0x2
	// Position of EPRN2 field.
	USB0_ENDPTNAK_EPRN2_Pos = 0x2
	// Bit mask of EPRN2 field.
	USB0_ENDPTNAK_EPRN2_Msk = 0x4
	// Bit EPRN2.
	USB0_ENDPTNAK_EPRN2 = 0x4
	// Position of EPRN3 field.
	USB0_ENDPTNAK_EPRN3_Pos = 0x3
	// Bit mask of EPRN3 field.
	USB0_ENDPTNAK_EPRN3_Msk = 0x8
	// Bit EPRN3.
	USB0_ENDPTNAK_EPRN3 = 0x8
	// Position of EPRN4 field.
	USB0_ENDPTNAK_EPRN4_Pos = 0x4
	// Bit mask of EPRN4 field.
	USB0_ENDPTNAK_EPRN4_Msk = 0x10
	// Bit EPRN4.
	USB0_ENDPTNAK_EPRN4 = 0x10
	// Position of EPRN5 field.
	USB0_ENDPTNAK_EPRN5_Pos = 0x5
	// Bit mask of EPRN5 field.
	USB0_ENDPTNAK_EPRN5_Msk = 0x20
	// Bit EPRN5.
	USB0_ENDPTNAK_EPRN5 = 0x20
	// Position of RESERVED field.
	USB0_ENDPTNAK_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_ENDPTNAK_RESERVED_Msk = 0xffc0
	// Position of EPTN0 field.
	USB0_ENDPTNAK_EPTN0_Pos = 0x10
	// Bit mask of EPTN0 field.
	USB0_ENDPTNAK_EPTN0_Msk = 0x10000
	// Bit EPTN0.
	USB0_ENDPTNAK_EPTN0 = 0x10000
	// Position of EPTN1 field.
	USB0_ENDPTNAK_EPTN1_Pos = 0x11
	// Bit mask of EPTN1 field.
	USB0_ENDPTNAK_EPTN1_Msk = 0x20000
	// Bit EPTN1.
	USB0_ENDPTNAK_EPTN1 = 0x20000
	// Position of EPTN2 field.
	USB0_ENDPTNAK_EPTN2_Pos = 0x12
	// Bit mask of EPTN2 field.
	USB0_ENDPTNAK_EPTN2_Msk = 0x40000
	// Bit EPTN2.
	USB0_ENDPTNAK_EPTN2 = 0x40000
	// Position of EPTN3 field.
	USB0_ENDPTNAK_EPTN3_Pos = 0x13
	// Bit mask of EPTN3 field.
	USB0_ENDPTNAK_EPTN3_Msk = 0x80000
	// Bit EPTN3.
	USB0_ENDPTNAK_EPTN3 = 0x80000
	// Position of EPTN4 field.
	USB0_ENDPTNAK_EPTN4_Pos = 0x14
	// Bit mask of EPTN4 field.
	USB0_ENDPTNAK_EPTN4_Msk = 0x100000
	// Bit EPTN4.
	USB0_ENDPTNAK_EPTN4 = 0x100000
	// Position of EPTN5 field.
	USB0_ENDPTNAK_EPTN5_Pos = 0x15
	// Bit mask of EPTN5 field.
	USB0_ENDPTNAK_EPTN5_Msk = 0x200000
	// Bit EPTN5.
	USB0_ENDPTNAK_EPTN5 = 0x200000
	// Position of RESERVED field.
	USB0_ENDPTNAK_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB0_ENDPTNAK_RESERVED_Msk = 0xffc00000

	// ENDPTNAKEN: Endpoint NAK Enable (device mode)
	// Position of EPRNE0 field.
	USB0_ENDPTNAKEN_EPRNE0_Pos = 0x0
	// Bit mask of EPRNE0 field.
	USB0_ENDPTNAKEN_EPRNE0_Msk = 0x1
	// Bit EPRNE0.
	USB0_ENDPTNAKEN_EPRNE0 = 0x1
	// Position of EPRNE1 field.
	USB0_ENDPTNAKEN_EPRNE1_Pos = 0x1
	// Bit mask of EPRNE1 field.
	USB0_ENDPTNAKEN_EPRNE1_Msk = 0x2
	// Bit EPRNE1.
	USB0_ENDPTNAKEN_EPRNE1 = 0x2
	// Position of EPRNE2 field.
	USB0_ENDPTNAKEN_EPRNE2_Pos = 0x2
	// Bit mask of EPRNE2 field.
	USB0_ENDPTNAKEN_EPRNE2_Msk = 0x4
	// Bit EPRNE2.
	USB0_ENDPTNAKEN_EPRNE2 = 0x4
	// Position of EPRNE3 field.
	USB0_ENDPTNAKEN_EPRNE3_Pos = 0x3
	// Bit mask of EPRNE3 field.
	USB0_ENDPTNAKEN_EPRNE3_Msk = 0x8
	// Bit EPRNE3.
	USB0_ENDPTNAKEN_EPRNE3 = 0x8
	// Position of EPRNE4 field.
	USB0_ENDPTNAKEN_EPRNE4_Pos = 0x4
	// Bit mask of EPRNE4 field.
	USB0_ENDPTNAKEN_EPRNE4_Msk = 0x10
	// Bit EPRNE4.
	USB0_ENDPTNAKEN_EPRNE4 = 0x10
	// Position of EPRNE5 field.
	USB0_ENDPTNAKEN_EPRNE5_Pos = 0x5
	// Bit mask of EPRNE5 field.
	USB0_ENDPTNAKEN_EPRNE5_Msk = 0x20
	// Bit EPRNE5.
	USB0_ENDPTNAKEN_EPRNE5 = 0x20
	// Position of RESERVED field.
	USB0_ENDPTNAKEN_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_ENDPTNAKEN_RESERVED_Msk = 0xffc0
	// Position of EPTNE0 field.
	USB0_ENDPTNAKEN_EPTNE0_Pos = 0x10
	// Bit mask of EPTNE0 field.
	USB0_ENDPTNAKEN_EPTNE0_Msk = 0x10000
	// Bit EPTNE0.
	USB0_ENDPTNAKEN_EPTNE0 = 0x10000
	// Position of EPTNE1 field.
	USB0_ENDPTNAKEN_EPTNE1_Pos = 0x11
	// Bit mask of EPTNE1 field.
	USB0_ENDPTNAKEN_EPTNE1_Msk = 0x20000
	// Bit EPTNE1.
	USB0_ENDPTNAKEN_EPTNE1 = 0x20000
	// Position of EPTNE2 field.
	USB0_ENDPTNAKEN_EPTNE2_Pos = 0x12
	// Bit mask of EPTNE2 field.
	USB0_ENDPTNAKEN_EPTNE2_Msk = 0x40000
	// Bit EPTNE2.
	USB0_ENDPTNAKEN_EPTNE2 = 0x40000
	// Position of EPTNE3 field.
	USB0_ENDPTNAKEN_EPTNE3_Pos = 0x13
	// Bit mask of EPTNE3 field.
	USB0_ENDPTNAKEN_EPTNE3_Msk = 0x80000
	// Bit EPTNE3.
	USB0_ENDPTNAKEN_EPTNE3 = 0x80000
	// Position of EPTNE4 field.
	USB0_ENDPTNAKEN_EPTNE4_Pos = 0x14
	// Bit mask of EPTNE4 field.
	USB0_ENDPTNAKEN_EPTNE4_Msk = 0x100000
	// Bit EPTNE4.
	USB0_ENDPTNAKEN_EPTNE4 = 0x100000
	// Position of EPTNE5 field.
	USB0_ENDPTNAKEN_EPTNE5_Pos = 0x15
	// Bit mask of EPTNE5 field.
	USB0_ENDPTNAKEN_EPTNE5_Msk = 0x200000
	// Bit EPTNE5.
	USB0_ENDPTNAKEN_EPTNE5 = 0x200000
	// Position of RESERVED field.
	USB0_ENDPTNAKEN_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB0_ENDPTNAKEN_RESERVED_Msk = 0xffc00000

	// PORTSC1_D: Port 1 status/control (device mode)
	// Position of CCS field.
	USB0_PORTSC1_D_CCS_Pos = 0x0
	// Bit mask of CCS field.
	USB0_PORTSC1_D_CCS_Msk = 0x1
	// Bit CCS.
	USB0_PORTSC1_D_CCS = 0x1
	// Device not attached A zero indicates that the device did not attach successfully or was forcibly disconnected by the software writing a zero to the Run bit in the USBCMD register. It does not state the device being disconnected or suspended.
	USB0_PORTSC1_D_CCS_DEVICE_NOT_ATTACHED_ = 0x0
	// Device attached. A one indicates that the device successfully attached and is operating in either high-speed mode or full-speed mode as indicated by the High Speed Port bit in this register.
	USB0_PORTSC1_D_CCS_DEVICE_ATTACHED__A_ = 0x1
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0x2
	// Bit RESERVED.
	USB0_PORTSC1_D_RESERVED = 0x2
	// Position of PE field.
	USB0_PORTSC1_D_PE_Pos = 0x2
	// Bit mask of PE field.
	USB0_PORTSC1_D_PE_Msk = 0x4
	// Bit PE.
	USB0_PORTSC1_D_PE = 0x4
	// Position of PEC field.
	USB0_PORTSC1_D_PEC_Pos = 0x3
	// Bit mask of PEC field.
	USB0_PORTSC1_D_PEC_Msk = 0x8
	// Bit PEC.
	USB0_PORTSC1_D_PEC = 0x8
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0x30
	// Position of FPR field.
	USB0_PORTSC1_D_FPR_Pos = 0x6
	// Bit mask of FPR field.
	USB0_PORTSC1_D_FPR_Msk = 0x40
	// Bit FPR.
	USB0_PORTSC1_D_FPR = 0x40
	// No resume (K-state) detected/driven on port.
	USB0_PORTSC1_D_FPR_NO_RESUME = 0x0
	// Resume detected/driven on port.
	USB0_PORTSC1_D_FPR_RESUME_DETECTED = 0x1
	// Position of SUSP field.
	USB0_PORTSC1_D_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	USB0_PORTSC1_D_SUSP_Msk = 0x80
	// Bit SUSP.
	USB0_PORTSC1_D_SUSP = 0x80
	// Port not in suspend state
	USB0_PORTSC1_D_SUSP_PORT_NOT_IN_SUSPEND_ = 0x0
	// Port in suspend state
	USB0_PORTSC1_D_SUSP_PORT_IN_SUSPEND_STAT = 0x1
	// Position of PR field.
	USB0_PORTSC1_D_PR_Pos = 0x8
	// Bit mask of PR field.
	USB0_PORTSC1_D_PR_Msk = 0x100
	// Bit PR.
	USB0_PORTSC1_D_PR = 0x100
	// Port is not in the reset state.
	USB0_PORTSC1_D_PR_PORT_IS_NOT_IN_THE_R = 0x0
	// Port is in the reset state.
	USB0_PORTSC1_D_PR_PORT_IS_IN_THE_RESET = 0x1
	// Position of HSP field.
	USB0_PORTSC1_D_HSP_Pos = 0x9
	// Bit mask of HSP field.
	USB0_PORTSC1_D_HSP_Msk = 0x200
	// Bit HSP.
	USB0_PORTSC1_D_HSP = 0x200
	// Host/device connected to the port is not in High-speed mode.
	USB0_PORTSC1_D_HSP_NOT_HIGHSSPEED = 0x0
	// Host/device connected to the port is in High-speed mode.
	USB0_PORTSC1_D_HSP_HIGHSPEED = 0x1
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0xc00
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0x1000
	// Bit RESERVED.
	USB0_PORTSC1_D_RESERVED = 0x1000
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	USB0_PORTSC1_D_RESERVED = 0x2000
	// Position of PIC1_0 field.
	USB0_PORTSC1_D_PIC1_0_Pos = 0xe
	// Bit mask of PIC1_0 field.
	USB0_PORTSC1_D_PIC1_0_Msk = 0xc000
	// Port indicators are off.
	USB0_PORTSC1_D_PIC1_0_OFF = 0x0
	// amber
	USB0_PORTSC1_D_PIC1_0_AMBER = 0x1
	// green
	USB0_PORTSC1_D_PIC1_0_GREEN = 0x2
	// undefined
	USB0_PORTSC1_D_PIC1_0_UNDEFINED = 0x3
	// Position of PTC3_0 field.
	USB0_PORTSC1_D_PTC3_0_Pos = 0x10
	// Bit mask of PTC3_0 field.
	USB0_PORTSC1_D_PTC3_0_Msk = 0xf0000
	// TEST_MODE_DISABLE
	USB0_PORTSC1_D_PTC3_0_TEST_MODE_DISABLE = 0x0
	// J_STATE
	USB0_PORTSC1_D_PTC3_0_J_STATE = 0x1
	// K_STATE
	USB0_PORTSC1_D_PTC3_0_K_STATE = 0x2
	// SE0 (host)/NAK (device)
	USB0_PORTSC1_D_PTC3_0_SE0_NAK = 0x3
	// Packet
	USB0_PORTSC1_D_PTC3_0_PACKET = 0x4
	// FORCE_ENABLE_HS
	USB0_PORTSC1_D_PTC3_0_FORCE_ENABLE_HS = 0x5
	// FORCE_ENABLE_FS
	USB0_PORTSC1_D_PTC3_0_FORCE_ENABLE_FS = 0x6
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0x100000
	// Bit RESERVED.
	USB0_PORTSC1_D_RESERVED = 0x100000
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0x200000
	// Bit RESERVED.
	USB0_PORTSC1_D_RESERVED = 0x200000
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0x400000
	// Bit RESERVED.
	USB0_PORTSC1_D_RESERVED = 0x400000
	// Position of PHCD field.
	USB0_PORTSC1_D_PHCD_Pos = 0x17
	// Bit mask of PHCD field.
	USB0_PORTSC1_D_PHCD_Msk = 0x800000
	// Bit PHCD.
	USB0_PORTSC1_D_PHCD = 0x800000
	// Writing a 0 enables the PHY clock. Reading a 0 indicates the status of the PHY clock (enabled).
	USB0_PORTSC1_D_PHCD_ENABLE = 0x0
	// Writing a 1 disables the PHY clock. Reading a 1 indicates the status of the PHY clock (disabled).
	USB0_PORTSC1_D_PHCD_DISABLE = 0x1
	// Position of PFSC field.
	USB0_PORTSC1_D_PFSC_Pos = 0x18
	// Bit mask of PFSC field.
	USB0_PORTSC1_D_PFSC_Msk = 0x1000000
	// Bit PFSC.
	USB0_PORTSC1_D_PFSC = 0x1000000
	// Port connects at any speed.
	USB0_PORTSC1_D_PFSC_ANYSPEED = 0x0
	// Writing this bit to a 1 will force the port to only connect at full speed. It disables the chirp sequence that allows the port to identify itself as High-speed. This is useful for testing FS configurations with a HS host, hub or device.
	USB0_PORTSC1_D_PFSC_FULLSPEED = 0x1
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0x19
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0x2000000
	// Bit RESERVED.
	USB0_PORTSC1_D_RESERVED = 0x2000000
	// Position of PSPD field.
	USB0_PORTSC1_D_PSPD_Pos = 0x1a
	// Bit mask of PSPD field.
	USB0_PORTSC1_D_PSPD_Msk = 0xc000000
	// Full-speed
	USB0_PORTSC1_D_PSPD_FULL_SPEED = 0x0
	// invalid in device mode
	USB0_PORTSC1_D_PSPD_INVALID_IN_DEVICE_MO = 0x1
	// High-speed
	USB0_PORTSC1_D_PSPD_HIGH_SPEED = 0x2
	// Position of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	USB0_PORTSC1_D_RESERVED_Msk = 0xf0000000

	// PORTSC1_H: Port 1 status/control (host mode)
	// Position of CCS field.
	USB0_PORTSC1_H_CCS_Pos = 0x0
	// Bit mask of CCS field.
	USB0_PORTSC1_H_CCS_Msk = 0x1
	// Bit CCS.
	USB0_PORTSC1_H_CCS = 0x1
	// No device is present.
	USB0_PORTSC1_H_CCS_NO_DEVICE_IS_PRESENT = 0x0
	// Device is present on the port.
	USB0_PORTSC1_H_CCS_DEVICE_IS_PRESENT_ON = 0x1
	// Position of CSC field.
	USB0_PORTSC1_H_CSC_Pos = 0x1
	// Bit mask of CSC field.
	USB0_PORTSC1_H_CSC_Msk = 0x2
	// Bit CSC.
	USB0_PORTSC1_H_CSC = 0x2
	// No change in current status.
	USB0_PORTSC1_H_CSC_NO_CHANGE_IN_CURRENT = 0x0
	// Change in current status.
	USB0_PORTSC1_H_CSC_CHANGE_IN_CURRENT_ST = 0x1
	// Position of PE field.
	USB0_PORTSC1_H_PE_Pos = 0x2
	// Bit mask of PE field.
	USB0_PORTSC1_H_PE_Msk = 0x4
	// Bit PE.
	USB0_PORTSC1_H_PE = 0x4
	// Port disabled.
	USB0_PORTSC1_H_PE_PORT_DISABLED_ = 0x0
	// Port enabled.
	USB0_PORTSC1_H_PE_PORT_ENABLED_ = 0x1
	// Position of PEC field.
	USB0_PORTSC1_H_PEC_Pos = 0x3
	// Bit mask of PEC field.
	USB0_PORTSC1_H_PEC_Msk = 0x8
	// Bit PEC.
	USB0_PORTSC1_H_PEC = 0x8
	// No change.
	USB0_PORTSC1_H_PEC_NO_CHANGE_ = 0x0
	// Port enabled/disabled status has changed.
	USB0_PORTSC1_H_PEC_CHANGED = 0x1
	// Position of OCA field.
	USB0_PORTSC1_H_OCA_Pos = 0x4
	// Bit mask of OCA field.
	USB0_PORTSC1_H_OCA_Msk = 0x10
	// Bit OCA.
	USB0_PORTSC1_H_OCA = 0x10
	// The port does not have an over-current condition.
	USB0_PORTSC1_H_OCA_THE_PORT_DOES_NOT_HA = 0x0
	// The port has currently an over-current condition.
	USB0_PORTSC1_H_OCA_THE_PORT_HAS_CURRENT = 0x1
	// Position of OCC field.
	USB0_PORTSC1_H_OCC_Pos = 0x5
	// Bit mask of OCC field.
	USB0_PORTSC1_H_OCC_Msk = 0x20
	// Bit OCC.
	USB0_PORTSC1_H_OCC = 0x20
	// Position of FPR field.
	USB0_PORTSC1_H_FPR_Pos = 0x6
	// Bit mask of FPR field.
	USB0_PORTSC1_H_FPR_Msk = 0x40
	// Bit FPR.
	USB0_PORTSC1_H_FPR = 0x40
	// No resume (K-state) detected/driven on port.
	USB0_PORTSC1_H_FPR_NO_RESUME = 0x0
	// Resume detected/driven on port.
	USB0_PORTSC1_H_FPR_RESUME_DETECTED = 0x1
	// Position of SUSP field.
	USB0_PORTSC1_H_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	USB0_PORTSC1_H_SUSP_Msk = 0x80
	// Bit SUSP.
	USB0_PORTSC1_H_SUSP = 0x80
	// Port not in suspend state
	USB0_PORTSC1_H_SUSP_PORT_NOT_IN_SUSPEND_ = 0x0
	// Port in suspend state When in suspend state, downstream propagation of data is blocked on this port, except for port reset. The blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1. In the suspend state, the port is sensitive to resume detection. Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB.
	USB0_PORTSC1_H_SUSP_PORT_IN_SUSPEND_STAT = 0x1
	// Position of PR field.
	USB0_PORTSC1_H_PR_Pos = 0x8
	// Bit mask of PR field.
	USB0_PORTSC1_H_PR_Msk = 0x100
	// Bit PR.
	USB0_PORTSC1_H_PR = 0x100
	// Port is not in the reset state.
	USB0_PORTSC1_H_PR_PORT_IS_NOT_IN_THE_R = 0x0
	// Port is in the reset state.
	USB0_PORTSC1_H_PR_PORT_IS_IN_THE_RESET = 0x1
	// Position of HSP field.
	USB0_PORTSC1_H_HSP_Pos = 0x9
	// Bit mask of HSP field.
	USB0_PORTSC1_H_HSP_Msk = 0x200
	// Bit HSP.
	USB0_PORTSC1_H_HSP = 0x200
	// Host/device connected to the port is not in High-speed mode.
	USB0_PORTSC1_H_HSP_NO_HISPEED = 0x0
	// Host/device connected to the port is in High-speed mode.
	USB0_PORTSC1_H_HSP_HISPEED = 0x1
	// Position of LS field.
	USB0_PORTSC1_H_LS_Pos = 0xa
	// Bit mask of LS field.
	USB0_PORTSC1_H_LS_Msk = 0xc00
	// SE0 (USB_DP and USB_DM LOW)
	USB0_PORTSC1_H_LS_SE0 = 0x0
	// J-state (USB_DP HIGH and USB_DM LOW)
	USB0_PORTSC1_H_LS_J_STATE = 0x1
	// K-state (USB_DP LOW and USB_DM HIGH)
	USB0_PORTSC1_H_LS_K_STATE = 0x2
	// Undefined
	USB0_PORTSC1_H_LS_UNDEFINED = 0x3
	// Position of PP field.
	USB0_PORTSC1_H_PP_Pos = 0xc
	// Bit mask of PP field.
	USB0_PORTSC1_H_PP_Msk = 0x1000
	// Bit PP.
	USB0_PORTSC1_H_PP = 0x1000
	// Port power off.
	USB0_PORTSC1_H_PP_PORT_POWER_OFF_ = 0x0
	// Port power on.
	USB0_PORTSC1_H_PP_PORT_POWER_ON_ = 0x1
	// Position of RESERVED field.
	USB0_PORTSC1_H_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB0_PORTSC1_H_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	USB0_PORTSC1_H_RESERVED = 0x2000
	// Position of PIC1_0 field.
	USB0_PORTSC1_H_PIC1_0_Pos = 0xe
	// Bit mask of PIC1_0 field.
	USB0_PORTSC1_H_PIC1_0_Msk = 0xc000
	// Port indicators are off.
	USB0_PORTSC1_H_PIC1_0_PORT_INDICATORS_ARE_ = 0x0
	// Amber
	USB0_PORTSC1_H_PIC1_0_AMBER = 0x1
	// Green
	USB0_PORTSC1_H_PIC1_0_GREEN = 0x2
	// Undefined
	USB0_PORTSC1_H_PIC1_0_UNDEFINED = 0x3
	// Position of PTC3_0 field.
	USB0_PORTSC1_H_PTC3_0_Pos = 0x10
	// Bit mask of PTC3_0 field.
	USB0_PORTSC1_H_PTC3_0_Msk = 0xf0000
	// TEST_MODE_DISABLE
	USB0_PORTSC1_H_PTC3_0_TEST_MODE_DISABLE = 0x0
	// J_STATE
	USB0_PORTSC1_H_PTC3_0_J_STATE = 0x1
	// K_STATE
	USB0_PORTSC1_H_PTC3_0_K_STATE = 0x2
	// SE0 (host)/NAK (device)
	USB0_PORTSC1_H_PTC3_0_SE0_NAK = 0x3
	// Packet
	USB0_PORTSC1_H_PTC3_0_PACKET = 0x4
	// FORCE_ENABLE_HS
	USB0_PORTSC1_H_PTC3_0_FORCE_ENABLE_HS = 0x5
	// FORCE_ENABLE_FS
	USB0_PORTSC1_H_PTC3_0_FORCE_ENABLE_FS = 0x6
	// FORCE_ENABLE_LS
	USB0_PORTSC1_H_PTC3_0_FORCE_ENABLE_LS = 0x7
	// Position of WKCN field.
	USB0_PORTSC1_H_WKCN_Pos = 0x14
	// Bit mask of WKCN field.
	USB0_PORTSC1_H_WKCN_Msk = 0x100000
	// Bit WKCN.
	USB0_PORTSC1_H_WKCN = 0x100000
	// Disables the port to wake up on device connects.
	USB0_PORTSC1_H_WKCN_DISABLES_THE_PORT_TO = 0x0
	// Writing this bit to a one enables the port to be sensitive to device connects as wake-up events.
	USB0_PORTSC1_H_WKCN_WRITING_THIS_BIT_TO_ = 0x1
	// Position of WKDC field.
	USB0_PORTSC1_H_WKDC_Pos = 0x15
	// Bit mask of WKDC field.
	USB0_PORTSC1_H_WKDC_Msk = 0x200000
	// Bit WKDC.
	USB0_PORTSC1_H_WKDC = 0x200000
	// Disables the port to wake up on device disconnects.
	USB0_PORTSC1_H_WKDC_DISABLES_THE_PORT_TO = 0x0
	// Writing this bit to a one enables the port to be sensitive to device disconnects as wake-up events.
	USB0_PORTSC1_H_WKDC_WRITING_THIS_BIT_TO_ = 0x1
	// Position of WKOC field.
	USB0_PORTSC1_H_WKOC_Pos = 0x16
	// Bit mask of WKOC field.
	USB0_PORTSC1_H_WKOC_Msk = 0x400000
	// Bit WKOC.
	USB0_PORTSC1_H_WKOC = 0x400000
	// Disables the port to wake up on over-current events.
	USB0_PORTSC1_H_WKOC_DISABLES_THE_PORT_TO = 0x0
	// Writing a one to this bit enabled the port to be sensitive to over-current conditions as wake-up events.
	USB0_PORTSC1_H_WKOC_WRITING_A_ONE_TO_THI = 0x1
	// Position of PHCD field.
	USB0_PORTSC1_H_PHCD_Pos = 0x17
	// Bit mask of PHCD field.
	USB0_PORTSC1_H_PHCD_Msk = 0x800000
	// Bit PHCD.
	USB0_PORTSC1_H_PHCD = 0x800000
	// Writing a 0 enables the PHY clock. Reading a 0 indicates the status of the PHY clock (enabled).
	USB0_PORTSC1_H_PHCD_WRITING_A_0_ENABLES_ = 0x0
	// Writing a 1 disables the PHY clock. Reading a 1 indicates the status of the PHY clock (disabled).
	USB0_PORTSC1_H_PHCD_WRITING_A_1_DISABLES = 0x1
	// Position of PFSC field.
	USB0_PORTSC1_H_PFSC_Pos = 0x18
	// Bit mask of PFSC field.
	USB0_PORTSC1_H_PFSC_Msk = 0x1000000
	// Bit PFSC.
	USB0_PORTSC1_H_PFSC = 0x1000000
	// Port connects at any speed.
	USB0_PORTSC1_H_PFSC_PORT_CONNECTS_AT_ANY = 0x0
	// Writing this bit to a 1 will force the port to only connect at Full Speed. It disables the chirp sequence that allows the port to identify itself as High Speed. This is useful for testing FS configurations with a HS host, hub or device.
	USB0_PORTSC1_H_PFSC_WRITING_THIS_BIT_TO_ = 0x1
	// Position of RESERVED field.
	USB0_PORTSC1_H_RESERVED_Pos = 0x19
	// Bit mask of RESERVED field.
	USB0_PORTSC1_H_RESERVED_Msk = 0x2000000
	// Bit RESERVED.
	USB0_PORTSC1_H_RESERVED = 0x2000000
	// Position of PSPD field.
	USB0_PORTSC1_H_PSPD_Pos = 0x1a
	// Bit mask of PSPD field.
	USB0_PORTSC1_H_PSPD_Msk = 0xc000000
	// Full-speed
	USB0_PORTSC1_H_PSPD_FULL_SPEED = 0x0
	// Low-speed
	USB0_PORTSC1_H_PSPD_LOW_SPEED = 0x1
	// High-speed
	USB0_PORTSC1_H_PSPD_HIGH_SPEED = 0x2

	// OTGSC: OTG status and control
	// Position of VD field.
	USB0_OTGSC_VD_Pos = 0x0
	// Bit mask of VD field.
	USB0_OTGSC_VD_Msk = 0x1
	// Bit VD.
	USB0_OTGSC_VD = 0x1
	// Position of VC field.
	USB0_OTGSC_VC_Pos = 0x1
	// Bit mask of VC field.
	USB0_OTGSC_VC_Msk = 0x2
	// Bit VC.
	USB0_OTGSC_VC = 0x2
	// Position of HAAR field.
	USB0_OTGSC_HAAR_Pos = 0x2
	// Bit mask of HAAR field.
	USB0_OTGSC_HAAR_Msk = 0x4
	// Bit HAAR.
	USB0_OTGSC_HAAR = 0x4
	// Disabled
	USB0_OTGSC_HAAR_DISABLED = 0x0
	// Enable automatic reset after connect on host port.
	USB0_OTGSC_HAAR_ENABLE_AUTOMATIC_RES = 0x1
	// Position of OT field.
	USB0_OTGSC_OT_Pos = 0x3
	// Bit mask of OT field.
	USB0_OTGSC_OT_Msk = 0x8
	// Bit OT.
	USB0_OTGSC_OT = 0x8
	// Position of DP field.
	USB0_OTGSC_DP_Pos = 0x4
	// Bit mask of DP field.
	USB0_OTGSC_DP_Msk = 0x10
	// Bit DP.
	USB0_OTGSC_DP = 0x10
	// Position of IDPU field.
	USB0_OTGSC_IDPU_Pos = 0x5
	// Bit mask of IDPU field.
	USB0_OTGSC_IDPU_Msk = 0x20
	// Bit IDPU.
	USB0_OTGSC_IDPU = 0x20
	// Pull-up off. The ID bit will not be sampled.
	USB0_OTGSC_IDPU_PULL_UP_OFF_THE_ID_ = 0x0
	// Pull-up on.
	USB0_OTGSC_IDPU_PULL_UP_ON_ = 0x1
	// Position of HADP field.
	USB0_OTGSC_HADP_Pos = 0x6
	// Bit mask of HADP field.
	USB0_OTGSC_HADP_Msk = 0x40
	// Bit HADP.
	USB0_OTGSC_HADP = 0x40
	// Position of HABA field.
	USB0_OTGSC_HABA_Pos = 0x7
	// Bit mask of HABA field.
	USB0_OTGSC_HABA_Msk = 0x80
	// Bit HABA.
	USB0_OTGSC_HABA = 0x80
	// Disabled.
	USB0_OTGSC_HABA_DISABLED_ = 0x0
	// Enable automatic B-disconnect to A-connect sequence.
	USB0_OTGSC_HABA_ENABLE_AUTOMATIC_B_D = 0x1
	// Position of ID field.
	USB0_OTGSC_ID_Pos = 0x8
	// Bit mask of ID field.
	USB0_OTGSC_ID_Msk = 0x100
	// Bit ID.
	USB0_OTGSC_ID = 0x100
	// A-device
	USB0_OTGSC_ID_A_DEVICE = 0x0
	// B-device
	USB0_OTGSC_ID_B_DEVICE = 0x1
	// Position of AVV field.
	USB0_OTGSC_AVV_Pos = 0x9
	// Bit mask of AVV field.
	USB0_OTGSC_AVV_Msk = 0x200
	// Bit AVV.
	USB0_OTGSC_AVV = 0x200
	// Position of ASV field.
	USB0_OTGSC_ASV_Pos = 0xa
	// Bit mask of ASV field.
	USB0_OTGSC_ASV_Msk = 0x400
	// Bit ASV.
	USB0_OTGSC_ASV = 0x400
	// Position of BSV field.
	USB0_OTGSC_BSV_Pos = 0xb
	// Bit mask of BSV field.
	USB0_OTGSC_BSV_Msk = 0x800
	// Bit BSV.
	USB0_OTGSC_BSV = 0x800
	// Position of BSE field.
	USB0_OTGSC_BSE_Pos = 0xc
	// Bit mask of BSE field.
	USB0_OTGSC_BSE_Msk = 0x1000
	// Bit BSE.
	USB0_OTGSC_BSE = 0x1000
	// Position of MS1T field.
	USB0_OTGSC_MS1T_Pos = 0xd
	// Bit mask of MS1T field.
	USB0_OTGSC_MS1T_Msk = 0x2000
	// Bit MS1T.
	USB0_OTGSC_MS1T = 0x2000
	// Position of DPS field.
	USB0_OTGSC_DPS_Pos = 0xe
	// Bit mask of DPS field.
	USB0_OTGSC_DPS_Msk = 0x4000
	// Bit DPS.
	USB0_OTGSC_DPS = 0x4000
	// Position of RESERVED field.
	USB0_OTGSC_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	USB0_OTGSC_RESERVED_Msk = 0x8000
	// Bit RESERVED.
	USB0_OTGSC_RESERVED = 0x8000
	// Position of IDIS field.
	USB0_OTGSC_IDIS_Pos = 0x10
	// Bit mask of IDIS field.
	USB0_OTGSC_IDIS_Msk = 0x10000
	// Bit IDIS.
	USB0_OTGSC_IDIS = 0x10000
	// Position of AVVIS field.
	USB0_OTGSC_AVVIS_Pos = 0x11
	// Bit mask of AVVIS field.
	USB0_OTGSC_AVVIS_Msk = 0x20000
	// Bit AVVIS.
	USB0_OTGSC_AVVIS = 0x20000
	// Position of ASVIS field.
	USB0_OTGSC_ASVIS_Pos = 0x12
	// Bit mask of ASVIS field.
	USB0_OTGSC_ASVIS_Msk = 0x40000
	// Bit ASVIS.
	USB0_OTGSC_ASVIS = 0x40000
	// Position of BSVIS field.
	USB0_OTGSC_BSVIS_Pos = 0x13
	// Bit mask of BSVIS field.
	USB0_OTGSC_BSVIS_Msk = 0x80000
	// Bit BSVIS.
	USB0_OTGSC_BSVIS = 0x80000
	// Position of BSEIS field.
	USB0_OTGSC_BSEIS_Pos = 0x14
	// Bit mask of BSEIS field.
	USB0_OTGSC_BSEIS_Msk = 0x100000
	// Bit BSEIS.
	USB0_OTGSC_BSEIS = 0x100000
	// Position of MS1S field.
	USB0_OTGSC_MS1S_Pos = 0x15
	// Bit mask of MS1S field.
	USB0_OTGSC_MS1S_Msk = 0x200000
	// Bit MS1S.
	USB0_OTGSC_MS1S = 0x200000
	// Position of DPIS field.
	USB0_OTGSC_DPIS_Pos = 0x16
	// Bit mask of DPIS field.
	USB0_OTGSC_DPIS_Msk = 0x400000
	// Bit DPIS.
	USB0_OTGSC_DPIS = 0x400000
	// Position of RESERVED field.
	USB0_OTGSC_RESERVED_Pos = 0x17
	// Bit mask of RESERVED field.
	USB0_OTGSC_RESERVED_Msk = 0x800000
	// Bit RESERVED.
	USB0_OTGSC_RESERVED = 0x800000
	// Position of IDIE field.
	USB0_OTGSC_IDIE_Pos = 0x18
	// Bit mask of IDIE field.
	USB0_OTGSC_IDIE_Msk = 0x1000000
	// Bit IDIE.
	USB0_OTGSC_IDIE = 0x1000000
	// Position of AVVIE field.
	USB0_OTGSC_AVVIE_Pos = 0x19
	// Bit mask of AVVIE field.
	USB0_OTGSC_AVVIE_Msk = 0x2000000
	// Bit AVVIE.
	USB0_OTGSC_AVVIE = 0x2000000
	// Position of ASVIE field.
	USB0_OTGSC_ASVIE_Pos = 0x1a
	// Bit mask of ASVIE field.
	USB0_OTGSC_ASVIE_Msk = 0x4000000
	// Bit ASVIE.
	USB0_OTGSC_ASVIE = 0x4000000
	// Position of BSVIE field.
	USB0_OTGSC_BSVIE_Pos = 0x1b
	// Bit mask of BSVIE field.
	USB0_OTGSC_BSVIE_Msk = 0x8000000
	// Bit BSVIE.
	USB0_OTGSC_BSVIE = 0x8000000
	// Position of BSEIE field.
	USB0_OTGSC_BSEIE_Pos = 0x1c
	// Bit mask of BSEIE field.
	USB0_OTGSC_BSEIE_Msk = 0x10000000
	// Bit BSEIE.
	USB0_OTGSC_BSEIE = 0x10000000
	// Position of MS1E field.
	USB0_OTGSC_MS1E_Pos = 0x1d
	// Bit mask of MS1E field.
	USB0_OTGSC_MS1E_Msk = 0x20000000
	// Bit MS1E.
	USB0_OTGSC_MS1E = 0x20000000
	// Position of DPIE field.
	USB0_OTGSC_DPIE_Pos = 0x1e
	// Bit mask of DPIE field.
	USB0_OTGSC_DPIE_Msk = 0x40000000
	// Bit DPIE.
	USB0_OTGSC_DPIE = 0x40000000
	// Position of RESERVED field.
	USB0_OTGSC_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	USB0_OTGSC_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	USB0_OTGSC_RESERVED = 0x80000000

	// USBMODE_D: USB device mode (device mode)
	// Position of CM1_0 field.
	USB0_USBMODE_D_CM1_0_Pos = 0x0
	// Bit mask of CM1_0 field.
	USB0_USBMODE_D_CM1_0_Msk = 0x3
	// Idle
	USB0_USBMODE_D_CM1_0_IDLE = 0x0
	// Device controller
	USB0_USBMODE_D_CM1_0_DEVICE_CONTROLLER = 0x2
	// Host controller
	USB0_USBMODE_D_CM1_0_HOST_CONTROLLER = 0x3
	// Position of ES field.
	USB0_USBMODE_D_ES_Pos = 0x2
	// Bit mask of ES field.
	USB0_USBMODE_D_ES_Msk = 0x4
	// Bit ES.
	USB0_USBMODE_D_ES = 0x4
	// Little endian: first byte referenced in least significant byte of 32-bit word.
	USB0_USBMODE_D_ES_LITTLE_ENDIAN_FIRST = 0x0
	// Big endian: first byte referenced in most significant byte of 32-bit word.
	USB0_USBMODE_D_ES_BIG_ENDIAN_FIRST_BY = 0x1
	// Position of SLOM field.
	USB0_USBMODE_D_SLOM_Pos = 0x3
	// Bit mask of SLOM field.
	USB0_USBMODE_D_SLOM_Msk = 0x8
	// Bit SLOM.
	USB0_USBMODE_D_SLOM = 0x8
	// Setup Lockouts on
	USB0_USBMODE_D_SLOM_SETUP_LOCKOUTS_ON = 0x0
	// Setup Lockouts Off (DCD requires the use of Setup Buffer Tripwire in USBCMD)
	USB0_USBMODE_D_SLOM_SETUP_LOCKOUTS_OFF = 0x1
	// Position of SDIS field.
	USB0_USBMODE_D_SDIS_Pos = 0x4
	// Bit mask of SDIS field.
	USB0_USBMODE_D_SDIS_Msk = 0x10
	// Bit SDIS.
	USB0_USBMODE_D_SDIS = 0x10
	// Not disabled
	USB0_USBMODE_D_SDIS_NOT_DISABLED = 0x0
	// Disabled. Setting this bit to one disables double priming on both RX and TX for low bandwidth systems. This mode ensures that when the RX and TX buffers are sufficient to contain an entire packet that the standard double buffering scheme is disabled to prevent overruns/underruns in bandwidth limited systems. Note: In High Speed Mode, all packets received will be responded to with a NYET handshake when stream disable is active.
	USB0_USBMODE_D_SDIS_DISABLED_SETTING_TH = 0x1
	// Position of RESERVED field.
	USB0_USBMODE_D_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB0_USBMODE_D_RESERVED_Msk = 0x20
	// Bit RESERVED.
	USB0_USBMODE_D_RESERVED = 0x20
	// Position of RESERVED field.
	USB0_USBMODE_D_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_USBMODE_D_RESERVED_Msk = 0xffffffc0

	// USBMODE_H: USB mode (host mode)
	// Position of CM field.
	USB0_USBMODE_H_CM_Pos = 0x0
	// Bit mask of CM field.
	USB0_USBMODE_H_CM_Msk = 0x3
	// Idle
	USB0_USBMODE_H_CM_IDLE = 0x0
	// Device controller
	USB0_USBMODE_H_CM_DEVICE_CONTROLLER = 0x2
	// Host controller
	USB0_USBMODE_H_CM_HOST_CONTROLLER = 0x3
	// Position of ES field.
	USB0_USBMODE_H_ES_Pos = 0x2
	// Bit mask of ES field.
	USB0_USBMODE_H_ES_Msk = 0x4
	// Bit ES.
	USB0_USBMODE_H_ES = 0x4
	// Little endian: first byte referenced in least significant byte of 32-bit word.
	USB0_USBMODE_H_ES_LITTLE_ENDIAN_FIRST = 0x0
	// Big endian: first byte referenced in most significant byte of 32-bit word.
	USB0_USBMODE_H_ES_BIG_ENDIAN_FIRST_BY = 0x1
	// Position of RESERVED field.
	USB0_USBMODE_H_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USB0_USBMODE_H_RESERVED_Msk = 0x8
	// Bit RESERVED.
	USB0_USBMODE_H_RESERVED = 0x8
	// Position of SDIS field.
	USB0_USBMODE_H_SDIS_Pos = 0x4
	// Bit mask of SDIS field.
	USB0_USBMODE_H_SDIS_Msk = 0x10
	// Bit SDIS.
	USB0_USBMODE_H_SDIS = 0x10
	// Not disabled
	USB0_USBMODE_H_SDIS_NOT_DISABLED = 0x0
	// Disabled. Setting to a 1 ensures that overruns/underruns of the latency FIFO are eliminated for low bandwidth systems where the RX and TX buffers are sufficient to contain the entire packet. Enabling stream disable also has the effect of ensuring the the TX latency is filled to capacity before the packet is launched onto the USB. Note: Time duration to pre-fill the FIFO becomes significant when stream disable is active. See TXFILLTUNING to characterize the adjustments needed for the scheduler when using this feature.
	USB0_USBMODE_H_SDIS_DISABLED_SETTING_TO = 0x1
	// Position of VBPS field.
	USB0_USBMODE_H_VBPS_Pos = 0x5
	// Bit mask of VBPS field.
	USB0_USBMODE_H_VBPS_Msk = 0x20
	// Bit VBPS.
	USB0_USBMODE_H_VBPS = 0x20
	// vbus_pwr_select is set LOW.
	USB0_USBMODE_H_VBPS_LOW = 0x0
	// vbus_pwr_select is set HIGH
	USB0_USBMODE_H_VBPS_HIGH = 0x1
	// Position of RESERVED field.
	USB0_USBMODE_H_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_USBMODE_H_RESERVED_Msk = 0xffffffc0

	// ENDPTSETUPSTAT: Endpoint setup status
	// Position of ENDPTSETUPSTAT0 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT0_Pos = 0x0
	// Bit mask of ENDPTSETUPSTAT0 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT0_Msk = 0x1
	// Bit ENDPTSETUPSTAT0.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT0 = 0x1
	// Position of ENDPTSETUPSTAT1 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT1_Pos = 0x1
	// Bit mask of ENDPTSETUPSTAT1 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT1_Msk = 0x2
	// Bit ENDPTSETUPSTAT1.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT1 = 0x2
	// Position of ENDPTSETUPSTAT2 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT2_Pos = 0x2
	// Bit mask of ENDPTSETUPSTAT2 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT2_Msk = 0x4
	// Bit ENDPTSETUPSTAT2.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT2 = 0x4
	// Position of ENDPTSETUPSTAT3 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT3_Pos = 0x3
	// Bit mask of ENDPTSETUPSTAT3 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT3_Msk = 0x8
	// Bit ENDPTSETUPSTAT3.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT3 = 0x8
	// Position of ENDPTSETUPSTAT4 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT4_Pos = 0x4
	// Bit mask of ENDPTSETUPSTAT4 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT4_Msk = 0x10
	// Bit ENDPTSETUPSTAT4.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT4 = 0x10
	// Position of ENDPTSETUPSTAT5 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT5_Pos = 0x5
	// Bit mask of ENDPTSETUPSTAT5 field.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT5_Msk = 0x20
	// Bit ENDPTSETUPSTAT5.
	USB0_ENDPTSETUPSTAT_ENDPTSETUPSTAT5 = 0x20
	// Position of RESERVED field.
	USB0_ENDPTSETUPSTAT_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_ENDPTSETUPSTAT_RESERVED_Msk = 0xffffffc0

	// ENDPTPRIME: Endpoint initialization
	// Position of PERB0 field.
	USB0_ENDPTPRIME_PERB0_Pos = 0x0
	// Bit mask of PERB0 field.
	USB0_ENDPTPRIME_PERB0_Msk = 0x1
	// Bit PERB0.
	USB0_ENDPTPRIME_PERB0 = 0x1
	// Position of PERB1 field.
	USB0_ENDPTPRIME_PERB1_Pos = 0x1
	// Bit mask of PERB1 field.
	USB0_ENDPTPRIME_PERB1_Msk = 0x2
	// Bit PERB1.
	USB0_ENDPTPRIME_PERB1 = 0x2
	// Position of PERB2 field.
	USB0_ENDPTPRIME_PERB2_Pos = 0x2
	// Bit mask of PERB2 field.
	USB0_ENDPTPRIME_PERB2_Msk = 0x4
	// Bit PERB2.
	USB0_ENDPTPRIME_PERB2 = 0x4
	// Position of PERB3 field.
	USB0_ENDPTPRIME_PERB3_Pos = 0x3
	// Bit mask of PERB3 field.
	USB0_ENDPTPRIME_PERB3_Msk = 0x8
	// Bit PERB3.
	USB0_ENDPTPRIME_PERB3 = 0x8
	// Position of PERB4 field.
	USB0_ENDPTPRIME_PERB4_Pos = 0x4
	// Bit mask of PERB4 field.
	USB0_ENDPTPRIME_PERB4_Msk = 0x10
	// Bit PERB4.
	USB0_ENDPTPRIME_PERB4 = 0x10
	// Position of PERB5 field.
	USB0_ENDPTPRIME_PERB5_Pos = 0x5
	// Bit mask of PERB5 field.
	USB0_ENDPTPRIME_PERB5_Msk = 0x20
	// Bit PERB5.
	USB0_ENDPTPRIME_PERB5 = 0x20
	// Position of RESERVED field.
	USB0_ENDPTPRIME_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_ENDPTPRIME_RESERVED_Msk = 0xffc0
	// Position of PETB0 field.
	USB0_ENDPTPRIME_PETB0_Pos = 0x10
	// Bit mask of PETB0 field.
	USB0_ENDPTPRIME_PETB0_Msk = 0x10000
	// Bit PETB0.
	USB0_ENDPTPRIME_PETB0 = 0x10000
	// Position of PETB1 field.
	USB0_ENDPTPRIME_PETB1_Pos = 0x11
	// Bit mask of PETB1 field.
	USB0_ENDPTPRIME_PETB1_Msk = 0x20000
	// Bit PETB1.
	USB0_ENDPTPRIME_PETB1 = 0x20000
	// Position of PETB2 field.
	USB0_ENDPTPRIME_PETB2_Pos = 0x12
	// Bit mask of PETB2 field.
	USB0_ENDPTPRIME_PETB2_Msk = 0x40000
	// Bit PETB2.
	USB0_ENDPTPRIME_PETB2 = 0x40000
	// Position of PETB3 field.
	USB0_ENDPTPRIME_PETB3_Pos = 0x13
	// Bit mask of PETB3 field.
	USB0_ENDPTPRIME_PETB3_Msk = 0x80000
	// Bit PETB3.
	USB0_ENDPTPRIME_PETB3 = 0x80000
	// Position of PETB4 field.
	USB0_ENDPTPRIME_PETB4_Pos = 0x14
	// Bit mask of PETB4 field.
	USB0_ENDPTPRIME_PETB4_Msk = 0x100000
	// Bit PETB4.
	USB0_ENDPTPRIME_PETB4 = 0x100000
	// Position of PETB5 field.
	USB0_ENDPTPRIME_PETB5_Pos = 0x15
	// Bit mask of PETB5 field.
	USB0_ENDPTPRIME_PETB5_Msk = 0x200000
	// Bit PETB5.
	USB0_ENDPTPRIME_PETB5 = 0x200000
	// Position of RESERVED field.
	USB0_ENDPTPRIME_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB0_ENDPTPRIME_RESERVED_Msk = 0xffc00000

	// ENDPTFLUSH: Endpoint de-initialization
	// Position of FERB0 field.
	USB0_ENDPTFLUSH_FERB0_Pos = 0x0
	// Bit mask of FERB0 field.
	USB0_ENDPTFLUSH_FERB0_Msk = 0x1
	// Bit FERB0.
	USB0_ENDPTFLUSH_FERB0 = 0x1
	// Position of FERB1 field.
	USB0_ENDPTFLUSH_FERB1_Pos = 0x1
	// Bit mask of FERB1 field.
	USB0_ENDPTFLUSH_FERB1_Msk = 0x2
	// Bit FERB1.
	USB0_ENDPTFLUSH_FERB1 = 0x2
	// Position of FERB2 field.
	USB0_ENDPTFLUSH_FERB2_Pos = 0x2
	// Bit mask of FERB2 field.
	USB0_ENDPTFLUSH_FERB2_Msk = 0x4
	// Bit FERB2.
	USB0_ENDPTFLUSH_FERB2 = 0x4
	// Position of FERB3 field.
	USB0_ENDPTFLUSH_FERB3_Pos = 0x3
	// Bit mask of FERB3 field.
	USB0_ENDPTFLUSH_FERB3_Msk = 0x8
	// Bit FERB3.
	USB0_ENDPTFLUSH_FERB3 = 0x8
	// Position of FERB4 field.
	USB0_ENDPTFLUSH_FERB4_Pos = 0x4
	// Bit mask of FERB4 field.
	USB0_ENDPTFLUSH_FERB4_Msk = 0x10
	// Bit FERB4.
	USB0_ENDPTFLUSH_FERB4 = 0x10
	// Position of FERB5 field.
	USB0_ENDPTFLUSH_FERB5_Pos = 0x5
	// Bit mask of FERB5 field.
	USB0_ENDPTFLUSH_FERB5_Msk = 0x20
	// Bit FERB5.
	USB0_ENDPTFLUSH_FERB5 = 0x20
	// Position of RESERVED field.
	USB0_ENDPTFLUSH_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_ENDPTFLUSH_RESERVED_Msk = 0xffc0
	// Position of FETB0 field.
	USB0_ENDPTFLUSH_FETB0_Pos = 0x10
	// Bit mask of FETB0 field.
	USB0_ENDPTFLUSH_FETB0_Msk = 0x10000
	// Bit FETB0.
	USB0_ENDPTFLUSH_FETB0 = 0x10000
	// Position of FETB1 field.
	USB0_ENDPTFLUSH_FETB1_Pos = 0x11
	// Bit mask of FETB1 field.
	USB0_ENDPTFLUSH_FETB1_Msk = 0x20000
	// Bit FETB1.
	USB0_ENDPTFLUSH_FETB1 = 0x20000
	// Position of FETB2 field.
	USB0_ENDPTFLUSH_FETB2_Pos = 0x12
	// Bit mask of FETB2 field.
	USB0_ENDPTFLUSH_FETB2_Msk = 0x40000
	// Bit FETB2.
	USB0_ENDPTFLUSH_FETB2 = 0x40000
	// Position of FETB3 field.
	USB0_ENDPTFLUSH_FETB3_Pos = 0x13
	// Bit mask of FETB3 field.
	USB0_ENDPTFLUSH_FETB3_Msk = 0x80000
	// Bit FETB3.
	USB0_ENDPTFLUSH_FETB3 = 0x80000
	// Position of FETB4 field.
	USB0_ENDPTFLUSH_FETB4_Pos = 0x14
	// Bit mask of FETB4 field.
	USB0_ENDPTFLUSH_FETB4_Msk = 0x100000
	// Bit FETB4.
	USB0_ENDPTFLUSH_FETB4 = 0x100000
	// Position of FETB5 field.
	USB0_ENDPTFLUSH_FETB5_Pos = 0x15
	// Bit mask of FETB5 field.
	USB0_ENDPTFLUSH_FETB5_Msk = 0x200000
	// Bit FETB5.
	USB0_ENDPTFLUSH_FETB5 = 0x200000
	// Position of RESERVED field.
	USB0_ENDPTFLUSH_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB0_ENDPTFLUSH_RESERVED_Msk = 0xffc00000

	// ENDPTSTAT: Endpoint status
	// Position of ERBR0 field.
	USB0_ENDPTSTAT_ERBR0_Pos = 0x0
	// Bit mask of ERBR0 field.
	USB0_ENDPTSTAT_ERBR0_Msk = 0x1
	// Bit ERBR0.
	USB0_ENDPTSTAT_ERBR0 = 0x1
	// Position of ERBR1 field.
	USB0_ENDPTSTAT_ERBR1_Pos = 0x1
	// Bit mask of ERBR1 field.
	USB0_ENDPTSTAT_ERBR1_Msk = 0x2
	// Bit ERBR1.
	USB0_ENDPTSTAT_ERBR1 = 0x2
	// Position of ERBR2 field.
	USB0_ENDPTSTAT_ERBR2_Pos = 0x2
	// Bit mask of ERBR2 field.
	USB0_ENDPTSTAT_ERBR2_Msk = 0x4
	// Bit ERBR2.
	USB0_ENDPTSTAT_ERBR2 = 0x4
	// Position of ERBR3 field.
	USB0_ENDPTSTAT_ERBR3_Pos = 0x3
	// Bit mask of ERBR3 field.
	USB0_ENDPTSTAT_ERBR3_Msk = 0x8
	// Bit ERBR3.
	USB0_ENDPTSTAT_ERBR3 = 0x8
	// Position of ERBR4 field.
	USB0_ENDPTSTAT_ERBR4_Pos = 0x4
	// Bit mask of ERBR4 field.
	USB0_ENDPTSTAT_ERBR4_Msk = 0x10
	// Bit ERBR4.
	USB0_ENDPTSTAT_ERBR4 = 0x10
	// Position of ERBR5 field.
	USB0_ENDPTSTAT_ERBR5_Pos = 0x5
	// Bit mask of ERBR5 field.
	USB0_ENDPTSTAT_ERBR5_Msk = 0x20
	// Bit ERBR5.
	USB0_ENDPTSTAT_ERBR5 = 0x20
	// Position of RESERVED field.
	USB0_ENDPTSTAT_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_ENDPTSTAT_RESERVED_Msk = 0xffc0
	// Position of ETBR0 field.
	USB0_ENDPTSTAT_ETBR0_Pos = 0x10
	// Bit mask of ETBR0 field.
	USB0_ENDPTSTAT_ETBR0_Msk = 0x10000
	// Bit ETBR0.
	USB0_ENDPTSTAT_ETBR0 = 0x10000
	// Position of ETBR1 field.
	USB0_ENDPTSTAT_ETBR1_Pos = 0x11
	// Bit mask of ETBR1 field.
	USB0_ENDPTSTAT_ETBR1_Msk = 0x20000
	// Bit ETBR1.
	USB0_ENDPTSTAT_ETBR1 = 0x20000
	// Position of ETBR2 field.
	USB0_ENDPTSTAT_ETBR2_Pos = 0x12
	// Bit mask of ETBR2 field.
	USB0_ENDPTSTAT_ETBR2_Msk = 0x40000
	// Bit ETBR2.
	USB0_ENDPTSTAT_ETBR2 = 0x40000
	// Position of ETBR3 field.
	USB0_ENDPTSTAT_ETBR3_Pos = 0x13
	// Bit mask of ETBR3 field.
	USB0_ENDPTSTAT_ETBR3_Msk = 0x80000
	// Bit ETBR3.
	USB0_ENDPTSTAT_ETBR3 = 0x80000
	// Position of ETBR4 field.
	USB0_ENDPTSTAT_ETBR4_Pos = 0x14
	// Bit mask of ETBR4 field.
	USB0_ENDPTSTAT_ETBR4_Msk = 0x100000
	// Bit ETBR4.
	USB0_ENDPTSTAT_ETBR4 = 0x100000
	// Position of ETBR5 field.
	USB0_ENDPTSTAT_ETBR5_Pos = 0x15
	// Bit mask of ETBR5 field.
	USB0_ENDPTSTAT_ETBR5_Msk = 0x200000
	// Bit ETBR5.
	USB0_ENDPTSTAT_ETBR5 = 0x200000
	// Position of RESERVED field.
	USB0_ENDPTSTAT_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB0_ENDPTSTAT_RESERVED_Msk = 0xffc00000

	// ENDPTCOMPLETE: Endpoint complete
	// Position of ERCE0 field.
	USB0_ENDPTCOMPLETE_ERCE0_Pos = 0x0
	// Bit mask of ERCE0 field.
	USB0_ENDPTCOMPLETE_ERCE0_Msk = 0x1
	// Bit ERCE0.
	USB0_ENDPTCOMPLETE_ERCE0 = 0x1
	// Position of ERCE1 field.
	USB0_ENDPTCOMPLETE_ERCE1_Pos = 0x1
	// Bit mask of ERCE1 field.
	USB0_ENDPTCOMPLETE_ERCE1_Msk = 0x2
	// Bit ERCE1.
	USB0_ENDPTCOMPLETE_ERCE1 = 0x2
	// Position of ERCE2 field.
	USB0_ENDPTCOMPLETE_ERCE2_Pos = 0x2
	// Bit mask of ERCE2 field.
	USB0_ENDPTCOMPLETE_ERCE2_Msk = 0x4
	// Bit ERCE2.
	USB0_ENDPTCOMPLETE_ERCE2 = 0x4
	// Position of ERCE3 field.
	USB0_ENDPTCOMPLETE_ERCE3_Pos = 0x3
	// Bit mask of ERCE3 field.
	USB0_ENDPTCOMPLETE_ERCE3_Msk = 0x8
	// Bit ERCE3.
	USB0_ENDPTCOMPLETE_ERCE3 = 0x8
	// Position of ERCE4 field.
	USB0_ENDPTCOMPLETE_ERCE4_Pos = 0x4
	// Bit mask of ERCE4 field.
	USB0_ENDPTCOMPLETE_ERCE4_Msk = 0x10
	// Bit ERCE4.
	USB0_ENDPTCOMPLETE_ERCE4 = 0x10
	// Position of ERCE5 field.
	USB0_ENDPTCOMPLETE_ERCE5_Pos = 0x5
	// Bit mask of ERCE5 field.
	USB0_ENDPTCOMPLETE_ERCE5_Msk = 0x20
	// Bit ERCE5.
	USB0_ENDPTCOMPLETE_ERCE5 = 0x20
	// Position of RESERVED field.
	USB0_ENDPTCOMPLETE_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB0_ENDPTCOMPLETE_RESERVED_Msk = 0xffc0
	// Position of ETCE0 field.
	USB0_ENDPTCOMPLETE_ETCE0_Pos = 0x10
	// Bit mask of ETCE0 field.
	USB0_ENDPTCOMPLETE_ETCE0_Msk = 0x10000
	// Bit ETCE0.
	USB0_ENDPTCOMPLETE_ETCE0 = 0x10000
	// Position of ETCE1 field.
	USB0_ENDPTCOMPLETE_ETCE1_Pos = 0x11
	// Bit mask of ETCE1 field.
	USB0_ENDPTCOMPLETE_ETCE1_Msk = 0x20000
	// Bit ETCE1.
	USB0_ENDPTCOMPLETE_ETCE1 = 0x20000
	// Position of ETCE2 field.
	USB0_ENDPTCOMPLETE_ETCE2_Pos = 0x12
	// Bit mask of ETCE2 field.
	USB0_ENDPTCOMPLETE_ETCE2_Msk = 0x40000
	// Bit ETCE2.
	USB0_ENDPTCOMPLETE_ETCE2 = 0x40000
	// Position of ETCE3 field.
	USB0_ENDPTCOMPLETE_ETCE3_Pos = 0x13
	// Bit mask of ETCE3 field.
	USB0_ENDPTCOMPLETE_ETCE3_Msk = 0x80000
	// Bit ETCE3.
	USB0_ENDPTCOMPLETE_ETCE3 = 0x80000
	// Position of ETCE4 field.
	USB0_ENDPTCOMPLETE_ETCE4_Pos = 0x14
	// Bit mask of ETCE4 field.
	USB0_ENDPTCOMPLETE_ETCE4_Msk = 0x100000
	// Bit ETCE4.
	USB0_ENDPTCOMPLETE_ETCE4 = 0x100000
	// Position of ETCE5 field.
	USB0_ENDPTCOMPLETE_ETCE5_Pos = 0x15
	// Bit mask of ETCE5 field.
	USB0_ENDPTCOMPLETE_ETCE5_Msk = 0x200000
	// Bit ETCE5.
	USB0_ENDPTCOMPLETE_ETCE5 = 0x200000
	// Position of RESERVED field.
	USB0_ENDPTCOMPLETE_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB0_ENDPTCOMPLETE_RESERVED_Msk = 0xffc00000

	// ENDPTCTRL0: Endpoint control 0
	// Position of RXS field.
	USB0_ENDPTCTRL0_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB0_ENDPTCTRL0_RXS_Msk = 0x1
	// Bit RXS.
	USB0_ENDPTCTRL0_RXS = 0x1
	// Endpoint ok.
	USB0_ENDPTCTRL0_RXS_ENDPOINT_OK_ = 0x0
	// Endpoint stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software, or it will automatically be cleared upon receipt of a new SETUP request. After receiving a SETUP request, this bit will continue to be cleared by hardware until the associated ENDSETUPSTAT bit is cleared.[1]
	USB0_ENDPTCTRL0_RXS_ENDPOINT_STALLED_SOF = 0x1
	// Position of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Msk = 0x2
	// Bit RESERVED.
	USB0_ENDPTCTRL0_RESERVED = 0x2
	// Position of RXT1_0 field.
	USB0_ENDPTCTRL0_RXT1_0_Pos = 0x2
	// Bit mask of RXT1_0 field.
	USB0_ENDPTCTRL0_RXT1_0_Msk = 0xc
	// Position of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Msk = 0x70
	// Position of RXE field.
	USB0_ENDPTCTRL0_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB0_ENDPTCTRL0_RXE_Msk = 0x80
	// Bit RXE.
	USB0_ENDPTCTRL0_RXE = 0x80
	// Position of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Msk = 0xff00
	// Position of TXS field.
	USB0_ENDPTCTRL0_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB0_ENDPTCTRL0_TXS_Msk = 0x10000
	// Bit TXS.
	USB0_ENDPTCTRL0_TXS = 0x10000
	// Endpoint ok.
	USB0_ENDPTCTRL0_TXS_ENDPOINT_OK_ = 0x0
	// Endpoint stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software, or it will automatically be cleared upon receipt of a new SETUP request. After receiving a SETUP request, this bit will continue to be cleared by hardware until the associated ENDSETUPSTAT bit is cleared.[1]
	USB0_ENDPTCTRL0_TXS_ENDPOINT_STALLED_SOF = 0x1
	// Position of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB0_ENDPTCTRL0_RESERVED = 0x20000
	// Position of TXT1_0 field.
	USB0_ENDPTCTRL0_TXT1_0_Pos = 0x12
	// Bit mask of TXT1_0 field.
	USB0_ENDPTCTRL0_TXT1_0_Msk = 0xc0000
	// Position of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Msk = 0x700000
	// Position of TXE field.
	USB0_ENDPTCTRL0_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB0_ENDPTCTRL0_TXE_Msk = 0x800000
	// Bit TXE.
	USB0_ENDPTCTRL0_TXE = 0x800000
	// Position of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL0_RESERVED_Msk = 0xff000000

	// ENDPTCTRL1: Endpoint control
	// Position of RXS field.
	USB0_ENDPTCTRL_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB0_ENDPTCTRL_RXS_Msk = 0x1
	// Bit RXS.
	USB0_ENDPTCTRL_RXS = 0x1
	// Endpoint ok. This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared.
	USB0_ENDPTCTRL_RXS_ENDPOINT_OK_THIS_BI = 0x0
	// Endpoint stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software, or it will automatically be cleared upon receipt of a new SETUP request.
	USB0_ENDPTCTRL_RXS_ENDPOINT_STALLED_SOF = 0x1
	// Position of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Msk = 0x2
	// Bit RESERVED.
	USB0_ENDPTCTRL_RESERVED = 0x2
	// Position of RXT field.
	USB0_ENDPTCTRL_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB0_ENDPTCTRL_RXT_Msk = 0xc
	// Control
	USB0_ENDPTCTRL_RXT_CONTROL = 0x0
	// Isochronous
	USB0_ENDPTCTRL_RXT_ISOCHRONOUS = 0x1
	// Bulk
	USB0_ENDPTCTRL_RXT_BULK = 0x2
	// Position of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB0_ENDPTCTRL_RESERVED = 0x10
	// Position of RXI field.
	USB0_ENDPTCTRL_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB0_ENDPTCTRL_RXI_Msk = 0x20
	// Bit RXI.
	USB0_ENDPTCTRL_RXI = 0x20
	// Disabled
	USB0_ENDPTCTRL_RXI_DISABLED = 0x0
	// Enabled
	USB0_ENDPTCTRL_RXI_ENABLED = 0x1
	// Position of RXR field.
	USB0_ENDPTCTRL_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB0_ENDPTCTRL_RXR_Msk = 0x40
	// Bit RXR.
	USB0_ENDPTCTRL_RXR = 0x40
	// Position of RXE field.
	USB0_ENDPTCTRL_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB0_ENDPTCTRL_RXE_Msk = 0x80
	// Bit RXE.
	USB0_ENDPTCTRL_RXE = 0x80
	// Endpoint disabled.
	USB0_ENDPTCTRL_RXE_ENDPOINT_DISABLED_ = 0x0
	// Endpoint enabled.
	USB0_ENDPTCTRL_RXE_ENDPOINT_ENABLED_ = 0x1
	// Position of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Msk = 0xff00
	// Position of TXS field.
	USB0_ENDPTCTRL_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB0_ENDPTCTRL_TXS_Msk = 0x10000
	// Bit TXS.
	USB0_ENDPTCTRL_TXS = 0x10000
	// Endpoint ok. This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint, and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared.
	USB0_ENDPTCTRL_TXS_ENDPOINT_OK_THIS_BI = 0x0
	// Endpoint stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software, or it will automatically be cleared upon receipt of a new SETUP request.
	USB0_ENDPTCTRL_TXS_ENDPOINT_STALLED_SOF = 0x1
	// Position of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB0_ENDPTCTRL_RESERVED = 0x20000
	// Position of TXT1_0 field.
	USB0_ENDPTCTRL_TXT1_0_Pos = 0x12
	// Bit mask of TXT1_0 field.
	USB0_ENDPTCTRL_TXT1_0_Msk = 0xc0000
	// Control
	USB0_ENDPTCTRL_TXT1_0_CONTROL = 0x0
	// Isochronous
	USB0_ENDPTCTRL_TXT1_0_ISOCHRONOUS = 0x1
	// Bulk
	USB0_ENDPTCTRL_TXT1_0_BULK = 0x2
	// Interrupt
	USB0_ENDPTCTRL_TXT1_0_INTERRUPT = 0x3
	// Position of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Msk = 0x100000
	// Bit RESERVED.
	USB0_ENDPTCTRL_RESERVED = 0x100000
	// Position of TXI field.
	USB0_ENDPTCTRL_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB0_ENDPTCTRL_TXI_Msk = 0x200000
	// Bit TXI.
	USB0_ENDPTCTRL_TXI = 0x200000
	// Enabled
	USB0_ENDPTCTRL_TXI_ENABLED = 0x0
	// Disabled
	USB0_ENDPTCTRL_TXI_DISABLED = 0x1
	// Position of TXR field.
	USB0_ENDPTCTRL_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB0_ENDPTCTRL_TXR_Msk = 0x400000
	// Bit TXR.
	USB0_ENDPTCTRL_TXR = 0x400000
	// Position of TXE field.
	USB0_ENDPTCTRL_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB0_ENDPTCTRL_TXE_Msk = 0x800000
	// Bit TXE.
	USB0_ENDPTCTRL_TXE = 0x800000
	// Endpoint disabled.
	USB0_ENDPTCTRL_TXE_ENDPOINT_DISABLED_ = 0x0
	// Endpoint enabled.
	USB0_ENDPTCTRL_TXE_ENDPOINT_ENABLED_ = 0x1
	// Position of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB0_ENDPTCTRL_RESERVED_Msk = 0xff000000
)

// Constants for USB1: USB1 Host/Device controller
const (
	// CAPLENGTH: Capability register length
	// Position of CAPLENGTH field.
	USB1_CAPLENGTH_CAPLENGTH_Pos = 0x0
	// Bit mask of CAPLENGTH field.
	USB1_CAPLENGTH_CAPLENGTH_Msk = 0xff
	// Position of HCIVERSION field.
	USB1_CAPLENGTH_HCIVERSION_Pos = 0x8
	// Bit mask of HCIVERSION field.
	USB1_CAPLENGTH_HCIVERSION_Msk = 0xffff00
	// Position of RESERVED field.
	USB1_CAPLENGTH_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB1_CAPLENGTH_RESERVED_Msk = 0xff000000

	// HCSPARAMS: Host controller structural parameters
	// Position of N_PORTS field.
	USB1_HCSPARAMS_N_PORTS_Pos = 0x0
	// Bit mask of N_PORTS field.
	USB1_HCSPARAMS_N_PORTS_Msk = 0xf
	// Position of PPC field.
	USB1_HCSPARAMS_PPC_Pos = 0x4
	// Bit mask of PPC field.
	USB1_HCSPARAMS_PPC_Msk = 0x10
	// Bit PPC.
	USB1_HCSPARAMS_PPC = 0x10
	// Position of RESERVED field.
	USB1_HCSPARAMS_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB1_HCSPARAMS_RESERVED_Msk = 0xe0
	// Position of N_PCC field.
	USB1_HCSPARAMS_N_PCC_Pos = 0x8
	// Bit mask of N_PCC field.
	USB1_HCSPARAMS_N_PCC_Msk = 0xf00
	// Position of N_CC field.
	USB1_HCSPARAMS_N_CC_Pos = 0xc
	// Bit mask of N_CC field.
	USB1_HCSPARAMS_N_CC_Msk = 0xf000
	// Position of PI field.
	USB1_HCSPARAMS_PI_Pos = 0x10
	// Bit mask of PI field.
	USB1_HCSPARAMS_PI_Msk = 0x10000
	// Bit PI.
	USB1_HCSPARAMS_PI = 0x10000
	// Position of RESERVED field.
	USB1_HCSPARAMS_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB1_HCSPARAMS_RESERVED_Msk = 0xe0000
	// Position of N_PTT field.
	USB1_HCSPARAMS_N_PTT_Pos = 0x14
	// Bit mask of N_PTT field.
	USB1_HCSPARAMS_N_PTT_Msk = 0xf00000
	// Position of N_TT field.
	USB1_HCSPARAMS_N_TT_Pos = 0x18
	// Bit mask of N_TT field.
	USB1_HCSPARAMS_N_TT_Msk = 0xf000000
	// Position of RESERVED field.
	USB1_HCSPARAMS_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	USB1_HCSPARAMS_RESERVED_Msk = 0xf0000000

	// HCCPARAMS: Host controller capability parameters
	// Position of ADC field.
	USB1_HCCPARAMS_ADC_Pos = 0x0
	// Bit mask of ADC field.
	USB1_HCCPARAMS_ADC_Msk = 0x1
	// Bit ADC.
	USB1_HCCPARAMS_ADC = 0x1
	// Position of PFL field.
	USB1_HCCPARAMS_PFL_Pos = 0x1
	// Bit mask of PFL field.
	USB1_HCCPARAMS_PFL_Msk = 0x2
	// Bit PFL.
	USB1_HCCPARAMS_PFL = 0x2
	// Position of ASP field.
	USB1_HCCPARAMS_ASP_Pos = 0x2
	// Bit mask of ASP field.
	USB1_HCCPARAMS_ASP_Msk = 0x4
	// Bit ASP.
	USB1_HCCPARAMS_ASP = 0x4
	// Position of IST field.
	USB1_HCCPARAMS_IST_Pos = 0x4
	// Bit mask of IST field.
	USB1_HCCPARAMS_IST_Msk = 0xf0
	// Position of EECP field.
	USB1_HCCPARAMS_EECP_Pos = 0x8
	// Bit mask of EECP field.
	USB1_HCCPARAMS_EECP_Msk = 0xff00
	// Position of RESERVED field.
	USB1_HCCPARAMS_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB1_HCCPARAMS_RESERVED_Msk = 0xffff0000

	// DCIVERSION: Device interface version number
	// Position of DCIVERSION field.
	USB1_DCIVERSION_DCIVERSION_Pos = 0x0
	// Bit mask of DCIVERSION field.
	USB1_DCIVERSION_DCIVERSION_Msk = 0xffff
	// Position of RESERVED field.
	USB1_DCIVERSION_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB1_DCIVERSION_RESERVED_Msk = 0xffff0000

	// USBCMD_D: USB command (device mode)
	// Position of RS field.
	USB1_USBCMD_D_RS_Pos = 0x0
	// Bit mask of RS field.
	USB1_USBCMD_D_RS_Msk = 0x1
	// Bit RS.
	USB1_USBCMD_D_RS = 0x1
	// Writing a 0 to this bit will cause a detach event.
	USB1_USBCMD_D_RS_DETACH = 0x0
	// Writing a one to this bit will cause the device controller to enable a pull-up on USB_DP and initiate an attach event. This control bit is not directly connected to the pull-up enable, as the pull-up will become disabled upon transitioning into high-speed mode. Software should use this bit to prevent an attach event before the device controller has been properly initialized.
	USB1_USBCMD_D_RS_ATACH = 0x1
	// Position of RST field.
	USB1_USBCMD_D_RST_Pos = 0x1
	// Bit mask of RST field.
	USB1_USBCMD_D_RST_Msk = 0x2
	// Bit RST.
	USB1_USBCMD_D_RST = 0x2
	// Set to 0 by hardware when the reset process is complete.
	USB1_USBCMD_D_RST_RESETCOMPLETE = 0x0
	// When software writes a one to this bit, the Device Controller resets its internal pipelines, timers, counters, state machines etc. to their initial values. Writing a one to this bit when the device is in the attached state is not recommended, since the effect on an attached host is undefined. In order to ensure that the device is not in an attached state before initiating a device controller reset, all primed endpoints should be flushed and the USBCMD Run/Stop bit should be set to 0.
	USB1_USBCMD_D_RST_RESET = 0x1
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0xc
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB1_USBCMD_D_RESERVED = 0x10
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0x20
	// Bit RESERVED.
	USB1_USBCMD_D_RESERVED = 0x20
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0x40
	// Bit RESERVED.
	USB1_USBCMD_D_RESERVED = 0x40
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0x80
	// Bit RESERVED.
	USB1_USBCMD_D_RESERVED = 0x80
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0x300
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0x400
	// Bit RESERVED.
	USB1_USBCMD_D_RESERVED = 0x400
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0x800
	// Bit RESERVED.
	USB1_USBCMD_D_RESERVED = 0x800
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0x1000
	// Bit RESERVED.
	USB1_USBCMD_D_RESERVED = 0x1000
	// Position of SUTW field.
	USB1_USBCMD_D_SUTW_Pos = 0xd
	// Bit mask of SUTW field.
	USB1_USBCMD_D_SUTW_Msk = 0x2000
	// Bit SUTW.
	USB1_USBCMD_D_SUTW = 0x2000
	// Position of ATDTW field.
	USB1_USBCMD_D_ATDTW_Pos = 0xe
	// Bit mask of ATDTW field.
	USB1_USBCMD_D_ATDTW_Msk = 0x4000
	// Bit ATDTW.
	USB1_USBCMD_D_ATDTW = 0x4000
	// Position of FS2 field.
	USB1_USBCMD_D_FS2_Pos = 0xf
	// Bit mask of FS2 field.
	USB1_USBCMD_D_FS2_Msk = 0x8000
	// Bit FS2.
	USB1_USBCMD_D_FS2 = 0x8000
	// Position of ITC field.
	USB1_USBCMD_D_ITC_Pos = 0x10
	// Bit mask of ITC field.
	USB1_USBCMD_D_ITC_Msk = 0xff0000
	// Position of RESERVED field.
	USB1_USBCMD_D_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB1_USBCMD_D_RESERVED_Msk = 0xff000000

	// USBCMD_H: USB command (host mode)
	// Position of RS field.
	USB1_USBCMD_H_RS_Pos = 0x0
	// Bit mask of RS field.
	USB1_USBCMD_H_RS_Msk = 0x1
	// Bit RS.
	USB1_USBCMD_H_RS = 0x1
	// When this bit is set to 0, the Host Controller completes the current transaction on the USB and then halts. The HC Halted bit in the status register indicates when the Host Controller has finished the transaction and has entered the stopped state. Software should not write a one to this field unless the host controller is in the Halted state (i.e. HCHalted in the USBSTS register is a one).
	USB1_USBCMD_H_RS_HALT = 0x0
	// When set to a 1, the Host Controller proceeds with the execution of the schedule. The Host Controller continues execution as long as this bit is set to a one.
	USB1_USBCMD_H_RS_PROCEED = 0x1
	// Position of RST field.
	USB1_USBCMD_H_RST_Pos = 0x1
	// Bit mask of RST field.
	USB1_USBCMD_H_RST_Msk = 0x2
	// Bit RST.
	USB1_USBCMD_H_RST = 0x2
	// This bit is set to zero by hardware when the reset process is complete.
	USB1_USBCMD_H_RST_RESETCOMPLETE = 0x0
	// When software writes a one to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value. Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports. Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero. Attempting to reset an actively running host controller will result in undefined behavior.
	USB1_USBCMD_H_RST_RESET = 0x1
	// Position of FS0 field.
	USB1_USBCMD_H_FS0_Pos = 0x2
	// Bit mask of FS0 field.
	USB1_USBCMD_H_FS0_Msk = 0x4
	// Bit FS0.
	USB1_USBCMD_H_FS0 = 0x4
	// Position of FS1 field.
	USB1_USBCMD_H_FS1_Pos = 0x3
	// Bit mask of FS1 field.
	USB1_USBCMD_H_FS1_Msk = 0x8
	// Bit FS1.
	USB1_USBCMD_H_FS1 = 0x8
	// Position of PSE field.
	USB1_USBCMD_H_PSE_Pos = 0x4
	// Bit mask of PSE field.
	USB1_USBCMD_H_PSE_Msk = 0x10
	// Bit PSE.
	USB1_USBCMD_H_PSE = 0x10
	// Do not process the periodic schedule.
	USB1_USBCMD_H_PSE_DO_NOT_PROCESS_THE_P = 0x0
	// Use the PERIODICLISTBASE register to access the periodic schedule.
	USB1_USBCMD_H_PSE_USE_THE_PERIODICLIST = 0x1
	// Position of ASE field.
	USB1_USBCMD_H_ASE_Pos = 0x5
	// Bit mask of ASE field.
	USB1_USBCMD_H_ASE_Msk = 0x20
	// Bit ASE.
	USB1_USBCMD_H_ASE = 0x20
	// Do not process the asynchronous schedule.
	USB1_USBCMD_H_ASE_DO_NOT_PROCESS_THE_A = 0x0
	// Use the ASYNCLISTADDR to access the asynchronous schedule.
	USB1_USBCMD_H_ASE_USE_THE_ASYNCLISTADD = 0x1
	// Position of IAA field.
	USB1_USBCMD_H_IAA_Pos = 0x6
	// Bit mask of IAA field.
	USB1_USBCMD_H_IAA_Msk = 0x40
	// Bit IAA.
	USB1_USBCMD_H_IAA = 0x40
	// The host controller sets this bit to zero after it has set the Interrupt on Sync Advance status bit in the USBSTS register to one.
	USB1_USBCMD_H_IAA_ST = 0x0
	// Software must write a 1 to this bit to ring the doorbell. When the host controller has evicted all appropriate cached schedule states, it sets the Interrupt on Async Advance status bit in the USBSTS register. If the Interrupt on Sync Advance Enable bit in the USBINTR register is one, then the host controller will assert an interrupt at the next interrupt threshold. Software should not write a one to this bit when the asynchronous schedule is inactive. Doing so will yield undefined results.
	USB1_USBCMD_H_IAA_DOORBELL = 0x1
	// Position of RESERVED field.
	USB1_USBCMD_H_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	USB1_USBCMD_H_RESERVED_Msk = 0x80
	// Bit RESERVED.
	USB1_USBCMD_H_RESERVED = 0x80
	// Position of ASP1_0 field.
	USB1_USBCMD_H_ASP1_0_Pos = 0x8
	// Bit mask of ASP1_0 field.
	USB1_USBCMD_H_ASP1_0_Msk = 0x300
	// Position of RESERVED field.
	USB1_USBCMD_H_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB1_USBCMD_H_RESERVED_Msk = 0x400
	// Bit RESERVED.
	USB1_USBCMD_H_RESERVED = 0x400
	// Position of ASPE field.
	USB1_USBCMD_H_ASPE_Pos = 0xb
	// Bit mask of ASPE field.
	USB1_USBCMD_H_ASPE_Msk = 0x800
	// Bit ASPE.
	USB1_USBCMD_H_ASPE = 0x800
	// Park mode is disabled.
	USB1_USBCMD_H_ASPE_PARK_MODE_IS_DISABLE = 0x0
	// Park mode is enabled.
	USB1_USBCMD_H_ASPE_PARK_MODE_IS_ENABLED = 0x1
	// Position of RESERVED field.
	USB1_USBCMD_H_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	USB1_USBCMD_H_RESERVED_Msk = 0x1000
	// Bit RESERVED.
	USB1_USBCMD_H_RESERVED = 0x1000
	// Position of RESERVED field.
	USB1_USBCMD_H_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB1_USBCMD_H_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	USB1_USBCMD_H_RESERVED = 0x2000
	// Position of RESERVED field.
	USB1_USBCMD_H_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	USB1_USBCMD_H_RESERVED_Msk = 0x4000
	// Bit RESERVED.
	USB1_USBCMD_H_RESERVED = 0x4000
	// Position of FS2 field.
	USB1_USBCMD_H_FS2_Pos = 0xf
	// Bit mask of FS2 field.
	USB1_USBCMD_H_FS2_Msk = 0x8000
	// Bit FS2.
	USB1_USBCMD_H_FS2 = 0x8000
	// Position of ITC field.
	USB1_USBCMD_H_ITC_Pos = 0x10
	// Bit mask of ITC field.
	USB1_USBCMD_H_ITC_Msk = 0xff0000
	// Position of RESERVED field.
	USB1_USBCMD_H_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB1_USBCMD_H_RESERVED_Msk = 0xff000000

	// USBSTS_D: USB status (device mode)
	// Position of UI field.
	USB1_USBSTS_D_UI_Pos = 0x0
	// Bit mask of UI field.
	USB1_USBSTS_D_UI_Msk = 0x1
	// Bit UI.
	USB1_USBSTS_D_UI = 0x1
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_D_UI_ST = 0x0
	// This bit is set by the Host/Device Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set. This bit is also set by the Host/Device Controller when a short packet is detected. A short packet is when the actual number of bytes received was less than the expected number of bytes.
	USB1_USBSTS_D_UI_CLEAR = 0x1
	// Position of UEI field.
	USB1_USBSTS_D_UEI_Pos = 0x1
	// Bit mask of UEI field.
	USB1_USBSTS_D_UEI_Msk = 0x2
	// Bit UEI.
	USB1_USBSTS_D_UEI = 0x2
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_D_UEI_ST = 0x0
	// When completion of a USB transaction results in an error condition, this bit is set by the Host/Device Controller. This bit is set along with the USBINT bit, if the TD on which the error interrupt occurred also had its interrupt on complete (IOC) bit set. The device controller detects resume signaling only (see Section 18.10.11.6).
	USB1_USBSTS_D_UEI_CLEAR = 0x1
	// Position of PCI field.
	USB1_USBSTS_D_PCI_Pos = 0x2
	// Bit mask of PCI field.
	USB1_USBSTS_D_PCI_Msk = 0x4
	// Bit PCI.
	USB1_USBSTS_D_PCI = 0x4
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_D_PCI_ST = 0x0
	// The Device Controller sets this bit to a one when the port controller enters the full or high-speed operational state. When the port controller exits the full or high-speed operation states due to Reset or Suspend events, the notification mechanisms are the USB Reset Received bit (URI) and the DCSuspend bits (SLI) respectively.
	USB1_USBSTS_D_PCI_CLEAR = 0x1
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x8
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x8
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x10
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x20
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x20
	// Position of URI field.
	USB1_USBSTS_D_URI_Pos = 0x6
	// Bit mask of URI field.
	USB1_USBSTS_D_URI_Msk = 0x40
	// Bit URI.
	USB1_USBSTS_D_URI = 0x40
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_D_URI_ST = 0x0
	// When the device controller detects a USB Reset and enters the default state, this bit will be set to a one.
	USB1_USBSTS_D_URI_CLEAR = 0x1
	// Position of SRI field.
	USB1_USBSTS_D_SRI_Pos = 0x7
	// Bit mask of SRI field.
	USB1_USBSTS_D_SRI_Msk = 0x80
	// Bit SRI.
	USB1_USBSTS_D_SRI = 0x80
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_D_SRI_ST = 0x0
	// When the device controller detects a Start Of (micro) Frame, this bit will be set to a one. When a SOF is extremely late, the device controller will automatically set this bit to indicate that an SOF was expected. Therefore, this bit will be set roughly every 1 ms in device FS mode and every 125 ms in HS mode and will be synchronized to the actual SOF that is received. Since the device controller is initialized to FS before connect, this bit will be set at an interval of 1ms during the prelude to connect and chirp.
	USB1_USBSTS_D_SRI_CLEAR = 0x1
	// Position of SLI field.
	USB1_USBSTS_D_SLI_Pos = 0x8
	// Bit mask of SLI field.
	USB1_USBSTS_D_SLI_Msk = 0x100
	// Bit SLI.
	USB1_USBSTS_D_SLI = 0x100
	// The device controller clears the bit upon exiting from a suspend state. This bit is cleared by software writing a one to it.
	USB1_USBSTS_D_SLI_ST = 0x0
	// When a device controller enters a suspend state from an active state, this bit will be set to a one.
	USB1_USBSTS_D_SLI_CLEAR = 0x1
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0xe00
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x1000
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x1000
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x2000
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x4000
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x4000
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x8000
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x8000
	// Position of NAKI field.
	USB1_USBSTS_D_NAKI_Pos = 0x10
	// Bit mask of NAKI field.
	USB1_USBSTS_D_NAKI_Msk = 0x10000
	// Bit NAKI.
	USB1_USBSTS_D_NAKI = 0x10000
	// This bit is automatically cleared by hardware when the all the enabled TX/RX Endpoint NAK bits are cleared.
	USB1_USBSTS_D_NAKI_ENDPCLEAR = 0x0
	// It is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and the corresponding TX/RX Endpoint NAK Enable bit are set.
	USB1_USBSTS_D_NAKI_SET = 0x1
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x20000
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x40000
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x40000
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0x80000
	// Bit RESERVED.
	USB1_USBSTS_D_RESERVED = 0x80000
	// Position of RESERVED field.
	USB1_USBSTS_D_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_USBSTS_D_RESERVED_Msk = 0xfff00000

	// USBSTS_H: USB status (host mode)
	// Position of UI field.
	USB1_USBSTS_H_UI_Pos = 0x0
	// Bit mask of UI field.
	USB1_USBSTS_H_UI_Msk = 0x1
	// Bit UI.
	USB1_USBSTS_H_UI = 0x1
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_H_UI_ST = 0x0
	// This bit is set by the Host/Device Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set. This bit is also set by the Host/Device Controller when a short packet is detected. A short packet is when the actual number of bytes received was less than the expected number of bytes.
	USB1_USBSTS_H_UI_CLEAR = 0x1
	// Position of UEI field.
	USB1_USBSTS_H_UEI_Pos = 0x1
	// Bit mask of UEI field.
	USB1_USBSTS_H_UEI_Msk = 0x2
	// Bit UEI.
	USB1_USBSTS_H_UEI = 0x2
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_H_UEI_ST = 0x0
	// When completion of a USB transaction results in an error condition, this bit is set by the Host/Device Controller. This bit is set along with the USBINT bit, if the TD on which the error interrupt occurred also had its interrupt on complete (IOC) bit set.
	USB1_USBSTS_H_UEI_CLEAR = 0x1
	// Position of PCI field.
	USB1_USBSTS_H_PCI_Pos = 0x2
	// Bit mask of PCI field.
	USB1_USBSTS_H_PCI_Msk = 0x4
	// Bit PCI.
	USB1_USBSTS_H_PCI = 0x4
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_H_PCI_ST = 0x0
	// The Host Controller sets this bit to a one when on any port a Connect Status occurs, a Port Enable/Disable Change occurs, or the Force Port Resume bit is set as the result of a J-K transition on the suspended port.
	USB1_USBSTS_H_PCI_CLEAR = 0x1
	// Position of FRI field.
	USB1_USBSTS_H_FRI_Pos = 0x3
	// Bit mask of FRI field.
	USB1_USBSTS_H_FRI_Msk = 0x8
	// Bit FRI.
	USB1_USBSTS_H_FRI = 0x8
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_H_FRI_ST = 0x0
	// The Host Controller sets this bit to a one when the Frame List Index rolls over from its maximum value to zero. The exact value at which the rollover occurs depends on the frame list size. For example, if the frame list size (as programmed in the Frame List Size field of the USBCMD register) is 1024, the Frame Index Register rolls over every time FRINDEX [13] toggles. Similarly, if the size is 512, the Host Controller sets this bit to a one every time FRINDEX bit 12 toggles (see Section 19.6.5).
	USB1_USBSTS_H_FRI_CLEAR = 0x1
	// Position of RESERVED field.
	USB1_USBSTS_H_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_USBSTS_H_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB1_USBSTS_H_RESERVED = 0x10
	// Position of AAI field.
	USB1_USBSTS_H_AAI_Pos = 0x5
	// Bit mask of AAI field.
	USB1_USBSTS_H_AAI_Msk = 0x20
	// Bit AAI.
	USB1_USBSTS_H_AAI = 0x20
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_H_AAI_ST = 0x0
	// System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing a one to the Interrupt on Async Advance Doorbell bit in the USBCMD register. This status bit indicates the assertion of that interrupt source.
	USB1_USBSTS_H_AAI_CLEAR = 0x1
	// Position of RESERVED field.
	USB1_USBSTS_H_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB1_USBSTS_H_RESERVED_Msk = 0x40
	// Bit RESERVED.
	USB1_USBSTS_H_RESERVED = 0x40
	// Position of SRI field.
	USB1_USBSTS_H_SRI_Pos = 0x7
	// Bit mask of SRI field.
	USB1_USBSTS_H_SRI_Msk = 0x80
	// Bit SRI.
	USB1_USBSTS_H_SRI = 0x80
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_H_SRI_ST = 0x0
	// In host mode, this bit will be set every 125 ms and can be used by host controller driver as a time base.
	USB1_USBSTS_H_SRI_CLEAR = 0x1
	// Position of SLI field.
	USB1_USBSTS_H_SLI_Pos = 0x8
	// Bit mask of SLI field.
	USB1_USBSTS_H_SLI_Msk = 0x100
	// Bit SLI.
	USB1_USBSTS_H_SLI = 0x100
	// Position of RESERVED field.
	USB1_USBSTS_H_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USB1_USBSTS_H_RESERVED_Msk = 0xe00
	// Position of HCH field.
	USB1_USBSTS_H_HCH_Pos = 0xc
	// Bit mask of HCH field.
	USB1_USBSTS_H_HCH_Msk = 0x1000
	// Bit HCH.
	USB1_USBSTS_H_HCH = 0x1000
	// The RS bit in USBCMD is set to zero. Set by the host controller.
	USB1_USBSTS_H_HCH_RS = 0x0
	// The Host Controller sets this bit to one after it has stopped executing because of the Run/Stop bit being set to 0, either by software or by the Host Controller hardware (e.g. because of an internal error).
	USB1_USBSTS_H_HCH_STOP = 0x1
	// Position of RCL field.
	USB1_USBSTS_H_RCL_Pos = 0xd
	// Bit mask of RCL field.
	USB1_USBSTS_H_RCL_Msk = 0x2000
	// Bit RCL.
	USB1_USBSTS_H_RCL = 0x2000
	// No empty asynchronous schedule detected.
	USB1_USBSTS_H_RCL_NO_EMPTY_ASYNCHRONOU = 0x0
	// An empty asynchronous schedule is detected. Set by the host controller.
	USB1_USBSTS_H_RCL_EMPTY_ASYNCHRONOU = 0x1
	// Position of PS field.
	USB1_USBSTS_H_PS_Pos = 0xe
	// Bit mask of PS field.
	USB1_USBSTS_H_PS_Msk = 0x4000
	// Bit PS.
	USB1_USBSTS_H_PS = 0x4000
	// The periodic schedule status is disabled.
	USB1_USBSTS_H_PS_DISABLED = 0x0
	// The periodic schedule status is enabled.
	USB1_USBSTS_H_PS_ENABLED = 0x1
	// Position of AS field.
	USB1_USBSTS_H_AS_Pos = 0xf
	// Bit mask of AS field.
	USB1_USBSTS_H_AS_Msk = 0x8000
	// Bit AS.
	USB1_USBSTS_H_AS = 0x8000
	// Asynchronous schedule status is disabled.
	USB1_USBSTS_H_AS_DISABLED = 0x0
	// Asynchronous schedule status is enabled.
	USB1_USBSTS_H_AS_ENABLED = 0x1
	// Position of RESERVED field.
	USB1_USBSTS_H_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB1_USBSTS_H_RESERVED_Msk = 0x10000
	// Bit RESERVED.
	USB1_USBSTS_H_RESERVED = 0x10000
	// Position of RESERVED field.
	USB1_USBSTS_H_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB1_USBSTS_H_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB1_USBSTS_H_RESERVED = 0x20000
	// Position of UAI field.
	USB1_USBSTS_H_UAI_Pos = 0x12
	// Bit mask of UAI field.
	USB1_USBSTS_H_UAI_Msk = 0x40000
	// Bit UAI.
	USB1_USBSTS_H_UAI = 0x40000
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_H_UAI_ST = 0x0
	// This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the asynchronous schedule. This bit is also set by the Host when a short packet is detected and the packet is on the asynchronous schedule. A short packet is when the actual number of bytes received was less than the expected number of bytes.
	USB1_USBSTS_H_UAI_CLEAR = 0x1
	// Position of UPI field.
	USB1_USBSTS_H_UPI_Pos = 0x13
	// Bit mask of UPI field.
	USB1_USBSTS_H_UPI_Msk = 0x80000
	// Bit UPI.
	USB1_USBSTS_H_UPI = 0x80000
	// This bit is cleared by software writing a one to it.
	USB1_USBSTS_H_UPI_ST = 0x0
	// This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule. This bit is also set by the Host Controller when a short packet is detected and the packet is on the periodic schedule. A short packet is when the actual number of bytes received was less than the expected number of bytes.
	USB1_USBSTS_H_UPI_CLEAR = 0x1
	// Position of RESERVED field.
	USB1_USBSTS_H_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_USBSTS_H_RESERVED_Msk = 0xfff00000

	// USBINTR_D: USB interrupt enable (device mode)
	// Position of UE field.
	USB1_USBINTR_D_UE_Pos = 0x0
	// Bit mask of UE field.
	USB1_USBINTR_D_UE_Msk = 0x1
	// Bit UE.
	USB1_USBINTR_D_UE = 0x1
	// Position of UEE field.
	USB1_USBINTR_D_UEE_Pos = 0x1
	// Bit mask of UEE field.
	USB1_USBINTR_D_UEE_Msk = 0x2
	// Bit UEE.
	USB1_USBINTR_D_UEE = 0x2
	// Position of PCE field.
	USB1_USBINTR_D_PCE_Pos = 0x2
	// Bit mask of PCE field.
	USB1_USBINTR_D_PCE_Msk = 0x4
	// Bit PCE.
	USB1_USBINTR_D_PCE = 0x4
	// Position of RESERVED field.
	USB1_USBINTR_D_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USB1_USBINTR_D_RESERVED_Msk = 0x8
	// Bit RESERVED.
	USB1_USBINTR_D_RESERVED = 0x8
	// Position of RESERVED field.
	USB1_USBINTR_D_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_USBINTR_D_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB1_USBINTR_D_RESERVED = 0x10
	// Position of RESERVED field.
	USB1_USBINTR_D_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB1_USBINTR_D_RESERVED_Msk = 0x20
	// Bit RESERVED.
	USB1_USBINTR_D_RESERVED = 0x20
	// Position of URE field.
	USB1_USBINTR_D_URE_Pos = 0x6
	// Bit mask of URE field.
	USB1_USBINTR_D_URE_Msk = 0x40
	// Bit URE.
	USB1_USBINTR_D_URE = 0x40
	// Position of SRE field.
	USB1_USBINTR_D_SRE_Pos = 0x7
	// Bit mask of SRE field.
	USB1_USBINTR_D_SRE_Msk = 0x80
	// Bit SRE.
	USB1_USBINTR_D_SRE = 0x80
	// Position of SLE field.
	USB1_USBINTR_D_SLE_Pos = 0x8
	// Bit mask of SLE field.
	USB1_USBINTR_D_SLE_Msk = 0x100
	// Bit SLE.
	USB1_USBINTR_D_SLE = 0x100
	// Position of RESERVED field.
	USB1_USBINTR_D_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USB1_USBINTR_D_RESERVED_Msk = 0xfe00
	// Position of NAKE field.
	USB1_USBINTR_D_NAKE_Pos = 0x10
	// Bit mask of NAKE field.
	USB1_USBINTR_D_NAKE_Msk = 0x10000
	// Bit NAKE.
	USB1_USBINTR_D_NAKE = 0x10000
	// Position of RESERVED field.
	USB1_USBINTR_D_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB1_USBINTR_D_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB1_USBINTR_D_RESERVED = 0x20000
	// Position of UAIE field.
	USB1_USBINTR_D_UAIE_Pos = 0x12
	// Bit mask of UAIE field.
	USB1_USBINTR_D_UAIE_Msk = 0x40000
	// Bit UAIE.
	USB1_USBINTR_D_UAIE = 0x40000
	// Position of UPIA field.
	USB1_USBINTR_D_UPIA_Pos = 0x13
	// Bit mask of UPIA field.
	USB1_USBINTR_D_UPIA_Msk = 0x80000
	// Bit UPIA.
	USB1_USBINTR_D_UPIA = 0x80000
	// Position of RESERVED field.
	USB1_USBINTR_D_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_USBINTR_D_RESERVED_Msk = 0xfff00000

	// USBINTR_H: USB interrupt enable (host mode)
	// Position of UE field.
	USB1_USBINTR_H_UE_Pos = 0x0
	// Bit mask of UE field.
	USB1_USBINTR_H_UE_Msk = 0x1
	// Bit UE.
	USB1_USBINTR_H_UE = 0x1
	// Position of UEE field.
	USB1_USBINTR_H_UEE_Pos = 0x1
	// Bit mask of UEE field.
	USB1_USBINTR_H_UEE_Msk = 0x2
	// Bit UEE.
	USB1_USBINTR_H_UEE = 0x2
	// Position of PCE field.
	USB1_USBINTR_H_PCE_Pos = 0x2
	// Bit mask of PCE field.
	USB1_USBINTR_H_PCE_Msk = 0x4
	// Bit PCE.
	USB1_USBINTR_H_PCE = 0x4
	// Position of FRE field.
	USB1_USBINTR_H_FRE_Pos = 0x3
	// Bit mask of FRE field.
	USB1_USBINTR_H_FRE_Msk = 0x8
	// Bit FRE.
	USB1_USBINTR_H_FRE = 0x8
	// Position of RESERVED field.
	USB1_USBINTR_H_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_USBINTR_H_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB1_USBINTR_H_RESERVED = 0x10
	// Position of AAE field.
	USB1_USBINTR_H_AAE_Pos = 0x5
	// Bit mask of AAE field.
	USB1_USBINTR_H_AAE_Msk = 0x20
	// Bit AAE.
	USB1_USBINTR_H_AAE = 0x20
	// Position of RESERVED field.
	USB1_USBINTR_H_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB1_USBINTR_H_RESERVED_Msk = 0x40
	// Bit RESERVED.
	USB1_USBINTR_H_RESERVED = 0x40
	// Position of SRE field.
	USB1_USBINTR_H_SRE_Pos = 0x7
	// Bit mask of SRE field.
	USB1_USBINTR_H_SRE_Msk = 0x80
	// Bit SRE.
	USB1_USBINTR_H_SRE = 0x80
	// Position of RESERVED field.
	USB1_USBINTR_H_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB1_USBINTR_H_RESERVED_Msk = 0x100
	// Bit RESERVED.
	USB1_USBINTR_H_RESERVED = 0x100
	// Position of RESERVED field.
	USB1_USBINTR_H_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USB1_USBINTR_H_RESERVED_Msk = 0xfe00
	// Position of RESERVED field.
	USB1_USBINTR_H_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB1_USBINTR_H_RESERVED_Msk = 0x10000
	// Bit RESERVED.
	USB1_USBINTR_H_RESERVED = 0x10000
	// Position of RESERVED field.
	USB1_USBINTR_H_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB1_USBINTR_H_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB1_USBINTR_H_RESERVED = 0x20000
	// Position of UAIE field.
	USB1_USBINTR_H_UAIE_Pos = 0x12
	// Bit mask of UAIE field.
	USB1_USBINTR_H_UAIE_Msk = 0x40000
	// Bit UAIE.
	USB1_USBINTR_H_UAIE = 0x40000
	// Position of UPIA field.
	USB1_USBINTR_H_UPIA_Pos = 0x13
	// Bit mask of UPIA field.
	USB1_USBINTR_H_UPIA_Msk = 0x80000
	// Bit UPIA.
	USB1_USBINTR_H_UPIA = 0x80000
	// Position of RESERVED field.
	USB1_USBINTR_H_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_USBINTR_H_RESERVED_Msk = 0xfff00000

	// FRINDEX_D: USB frame index (device mode)
	// Position of FRINDEX2_0 field.
	USB1_FRINDEX_D_FRINDEX2_0_Pos = 0x0
	// Bit mask of FRINDEX2_0 field.
	USB1_FRINDEX_D_FRINDEX2_0_Msk = 0x7
	// Position of FRINDEX13_3 field.
	USB1_FRINDEX_D_FRINDEX13_3_Pos = 0x3
	// Bit mask of FRINDEX13_3 field.
	USB1_FRINDEX_D_FRINDEX13_3_Msk = 0x3ff8
	// Position of RESERVED field.
	USB1_FRINDEX_D_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	USB1_FRINDEX_D_RESERVED_Msk = 0xffffc000

	// FRINDEX_H: USB frame index (host mode)
	// Position of FRINDEX2_0 field.
	USB1_FRINDEX_H_FRINDEX2_0_Pos = 0x0
	// Bit mask of FRINDEX2_0 field.
	USB1_FRINDEX_H_FRINDEX2_0_Msk = 0x7
	// Position of FRINDEX12_3 field.
	USB1_FRINDEX_H_FRINDEX12_3_Pos = 0x3
	// Bit mask of FRINDEX12_3 field.
	USB1_FRINDEX_H_FRINDEX12_3_Msk = 0x1ff8
	// Position of RESERVED field.
	USB1_FRINDEX_H_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB1_FRINDEX_H_RESERVED_Msk = 0xffffe000

	// DEVICEADDR: USB device address
	// Position of RESERVED field.
	USB1_DEVICEADDR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB1_DEVICEADDR_RESERVED_Msk = 0xffffff
	// Position of USBADRA field.
	USB1_DEVICEADDR_USBADRA_Pos = 0x18
	// Bit mask of USBADRA field.
	USB1_DEVICEADDR_USBADRA_Msk = 0x1000000
	// Bit USBADRA.
	USB1_DEVICEADDR_USBADRA = 0x1000000
	// Any write to USBADR are instantaneous.
	USB1_DEVICEADDR_USBADRA_ADVANCE = 0x0
	// When the user writes a one to this bit at the same time or before USBADR is written, the write to USBADR fields is staged and held in a hidden register. After an IN occurs on endpoint 0 and is acknowledged, USBADR will be loaded from the holding register. Hardware will automatically clear this bit on the following conditions: IN is ACKed to endpoint 0. USBADR is updated from the staging register. OUT/SETUP occurs on endpoint 0. USBADR is not updated. Device reset occurs. USBADR is set to 0. After the status phase of the SET_ADDRESS descriptor, the DCD has 2 ms to program the USBADR field. This mechanism will ensure this specification is met when the DCD can not write the device address within 2 ms from the SET_ADDRESS status phase. If the DCD writes the USBADR with USBADRA=1 after the SET_ADDRESS data phase (before the prime of the status phase), the USBADR will be programmed instantly at the correct time and meet the 2 ms USB requirement.
	USB1_DEVICEADDR_USBADRA_HOLD = 0x1
	// Position of USBADR field.
	USB1_DEVICEADDR_USBADR_Pos = 0x19
	// Bit mask of USBADR field.
	USB1_DEVICEADDR_USBADR_Msk = 0xfe000000

	// PERIODICLISTBASE: Frame list base address
	// Position of RESERVED field.
	USB1_PERIODICLISTBASE_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB1_PERIODICLISTBASE_RESERVED_Msk = 0xfff
	// Position of PERBASE31_12 field.
	USB1_PERIODICLISTBASE_PERBASE31_12_Pos = 0xc
	// Bit mask of PERBASE31_12 field.
	USB1_PERIODICLISTBASE_PERBASE31_12_Msk = 0xfffff000

	// ENDPOINTLISTADDR: Address of endpoint list in memory (device mode)
	// Position of RESERVED field.
	USB1_ENDPOINTLISTADDR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB1_ENDPOINTLISTADDR_RESERVED_Msk = 0x7ff
	// Position of EPBASE31_11 field.
	USB1_ENDPOINTLISTADDR_EPBASE31_11_Pos = 0xb
	// Bit mask of EPBASE31_11 field.
	USB1_ENDPOINTLISTADDR_EPBASE31_11_Msk = 0xfffff800

	// ASYNCLISTADDR: Address of endpoint list in memory (host mode)
	// Position of RESERVED field.
	USB1_ASYNCLISTADDR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB1_ASYNCLISTADDR_RESERVED_Msk = 0x1f
	// Position of ASYBASE31_5 field.
	USB1_ASYNCLISTADDR_ASYBASE31_5_Pos = 0x5
	// Bit mask of ASYBASE31_5 field.
	USB1_ASYNCLISTADDR_ASYBASE31_5_Msk = 0xffffffe0

	// TTCTRL: Asynchronous buffer status for embedded TT (host mode)
	// Position of RESERVED field.
	USB1_TTCTRL_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB1_TTCTRL_RESERVED_Msk = 0xffffff
	// Position of TTHA field.
	USB1_TTCTRL_TTHA_Pos = 0x18
	// Bit mask of TTHA field.
	USB1_TTCTRL_TTHA_Msk = 0x7f000000
	// Position of RESERVED field.
	USB1_TTCTRL_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	USB1_TTCTRL_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	USB1_TTCTRL_RESERVED = 0x80000000

	// BURSTSIZE: Programmable burst size
	// Position of RXPBURST field.
	USB1_BURSTSIZE_RXPBURST_Pos = 0x0
	// Bit mask of RXPBURST field.
	USB1_BURSTSIZE_RXPBURST_Msk = 0xff
	// Position of TXPBURST field.
	USB1_BURSTSIZE_TXPBURST_Pos = 0x8
	// Bit mask of TXPBURST field.
	USB1_BURSTSIZE_TXPBURST_Msk = 0xff00
	// Position of RESERVED field.
	USB1_BURSTSIZE_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB1_BURSTSIZE_RESERVED_Msk = 0xffff0000

	// TXFILLTUNING: Host transmit pre-buffer packet tuning (host mode)
	// Position of TXSCHOH field.
	USB1_TXFILLTUNING_TXSCHOH_Pos = 0x0
	// Bit mask of TXSCHOH field.
	USB1_TXFILLTUNING_TXSCHOH_Msk = 0xff
	// Position of TXSCHEATLTH field.
	USB1_TXFILLTUNING_TXSCHEATLTH_Pos = 0x8
	// Bit mask of TXSCHEATLTH field.
	USB1_TXFILLTUNING_TXSCHEATLTH_Msk = 0x1f00
	// Position of RESERVED field.
	USB1_TXFILLTUNING_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB1_TXFILLTUNING_RESERVED_Msk = 0xe000
	// Position of TXFIFOTHRES field.
	USB1_TXFILLTUNING_TXFIFOTHRES_Pos = 0x10
	// Bit mask of TXFIFOTHRES field.
	USB1_TXFILLTUNING_TXFIFOTHRES_Msk = 0x3f0000
	// Position of RESERVED field.
	USB1_TXFILLTUNING_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB1_TXFILLTUNING_RESERVED_Msk = 0xffc00000

	// ULPIVIEWPORT: ULPI viewport
	// Position of ULPIDATWR field.
	USB1_ULPIVIEWPORT_ULPIDATWR_Pos = 0x0
	// Bit mask of ULPIDATWR field.
	USB1_ULPIVIEWPORT_ULPIDATWR_Msk = 0xff
	// Position of ULPIDATRD field.
	USB1_ULPIVIEWPORT_ULPIDATRD_Pos = 0x8
	// Bit mask of ULPIDATRD field.
	USB1_ULPIVIEWPORT_ULPIDATRD_Msk = 0xff00
	// Position of ULPIADDR field.
	USB1_ULPIVIEWPORT_ULPIADDR_Pos = 0x10
	// Bit mask of ULPIADDR field.
	USB1_ULPIVIEWPORT_ULPIADDR_Msk = 0xff0000
	// Position of ULPIPORT field.
	USB1_ULPIVIEWPORT_ULPIPORT_Pos = 0x18
	// Bit mask of ULPIPORT field.
	USB1_ULPIVIEWPORT_ULPIPORT_Msk = 0x7000000
	// Position of ULPISS field.
	USB1_ULPIVIEWPORT_ULPISS_Pos = 0x1b
	// Bit mask of ULPISS field.
	USB1_ULPIVIEWPORT_ULPISS_Msk = 0x8000000
	// Bit ULPISS.
	USB1_ULPIVIEWPORT_ULPISS = 0x8000000
	// In another state (ie. carkit, serial, low power)
	USB1_ULPIVIEWPORT_ULPISS_IN_ANOTHER_STATE = 0x0
	// Normal Sync. State.
	USB1_ULPIVIEWPORT_ULPISS_NORMAL_SYNC_STATE_ = 0x1
	// Position of RESERVED field.
	USB1_ULPIVIEWPORT_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	USB1_ULPIVIEWPORT_RESERVED_Msk = 0x10000000
	// Bit RESERVED.
	USB1_ULPIVIEWPORT_RESERVED = 0x10000000
	// Position of ULPIRW field.
	USB1_ULPIVIEWPORT_ULPIRW_Pos = 0x1d
	// Bit mask of ULPIRW field.
	USB1_ULPIVIEWPORT_ULPIRW_Msk = 0x20000000
	// Bit ULPIRW.
	USB1_ULPIVIEWPORT_ULPIRW = 0x20000000
	// Read
	USB1_ULPIVIEWPORT_ULPIRW_READ = 0x0
	// Write
	USB1_ULPIVIEWPORT_ULPIRW_WRITE = 0x1
	// Position of ULPIRUN field.
	USB1_ULPIVIEWPORT_ULPIRUN_Pos = 0x1e
	// Bit mask of ULPIRUN field.
	USB1_ULPIVIEWPORT_ULPIRUN_Msk = 0x40000000
	// Bit ULPIRUN.
	USB1_ULPIVIEWPORT_ULPIRUN = 0x40000000
	// Position of ULPIWU field.
	USB1_ULPIVIEWPORT_ULPIWU_Pos = 0x1f
	// Bit mask of ULPIWU field.
	USB1_ULPIVIEWPORT_ULPIWU_Msk = 0x80000000
	// Bit ULPIWU.
	USB1_ULPIVIEWPORT_ULPIWU = 0x80000000

	// BINTERVAL: Length of virtual frame
	// Position of BINT field.
	USB1_BINTERVAL_BINT_Pos = 0x0
	// Bit mask of BINT field.
	USB1_BINTERVAL_BINT_Msk = 0xf
	// Position of RESERVED field.
	USB1_BINTERVAL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_BINTERVAL_RESERVED_Msk = 0xfffffff0

	// ENDPTNAK: Endpoint NAK (device mode)
	// Position of EPRN0 field.
	USB1_ENDPTNAK_EPRN0_Pos = 0x0
	// Bit mask of EPRN0 field.
	USB1_ENDPTNAK_EPRN0_Msk = 0x1
	// Bit EPRN0.
	USB1_ENDPTNAK_EPRN0 = 0x1
	// Position of EPRN1 field.
	USB1_ENDPTNAK_EPRN1_Pos = 0x1
	// Bit mask of EPRN1 field.
	USB1_ENDPTNAK_EPRN1_Msk = 0x2
	// Bit EPRN1.
	USB1_ENDPTNAK_EPRN1 = 0x2
	// Position of EPRN2 field.
	USB1_ENDPTNAK_EPRN2_Pos = 0x2
	// Bit mask of EPRN2 field.
	USB1_ENDPTNAK_EPRN2_Msk = 0x4
	// Bit EPRN2.
	USB1_ENDPTNAK_EPRN2 = 0x4
	// Position of EPRN3 field.
	USB1_ENDPTNAK_EPRN3_Pos = 0x3
	// Bit mask of EPRN3 field.
	USB1_ENDPTNAK_EPRN3_Msk = 0x8
	// Bit EPRN3.
	USB1_ENDPTNAK_EPRN3 = 0x8
	// Position of RESERVED field.
	USB1_ENDPTNAK_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_ENDPTNAK_RESERVED_Msk = 0xfff0
	// Position of EPTN16 field.
	USB1_ENDPTNAK_EPTN16_Pos = 0x10
	// Bit mask of EPTN16 field.
	USB1_ENDPTNAK_EPTN16_Msk = 0x10000
	// Bit EPTN16.
	USB1_ENDPTNAK_EPTN16 = 0x10000
	// Position of EPTN17 field.
	USB1_ENDPTNAK_EPTN17_Pos = 0x11
	// Bit mask of EPTN17 field.
	USB1_ENDPTNAK_EPTN17_Msk = 0x20000
	// Bit EPTN17.
	USB1_ENDPTNAK_EPTN17 = 0x20000
	// Position of EPTN18 field.
	USB1_ENDPTNAK_EPTN18_Pos = 0x12
	// Bit mask of EPTN18 field.
	USB1_ENDPTNAK_EPTN18_Msk = 0x40000
	// Bit EPTN18.
	USB1_ENDPTNAK_EPTN18 = 0x40000
	// Position of EPTN19 field.
	USB1_ENDPTNAK_EPTN19_Pos = 0x13
	// Bit mask of EPTN19 field.
	USB1_ENDPTNAK_EPTN19_Msk = 0x80000
	// Bit EPTN19.
	USB1_ENDPTNAK_EPTN19 = 0x80000
	// Position of RESERVED field.
	USB1_ENDPTNAK_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_ENDPTNAK_RESERVED_Msk = 0xfff00000

	// ENDPTNAKEN: Endpoint NAK Enable (device mode)
	// Position of EPRNE0 field.
	USB1_ENDPTNAKEN_EPRNE0_Pos = 0x0
	// Bit mask of EPRNE0 field.
	USB1_ENDPTNAKEN_EPRNE0_Msk = 0x1
	// Bit EPRNE0.
	USB1_ENDPTNAKEN_EPRNE0 = 0x1
	// Position of EPRNE1 field.
	USB1_ENDPTNAKEN_EPRNE1_Pos = 0x1
	// Bit mask of EPRNE1 field.
	USB1_ENDPTNAKEN_EPRNE1_Msk = 0x2
	// Bit EPRNE1.
	USB1_ENDPTNAKEN_EPRNE1 = 0x2
	// Position of EPRNE2 field.
	USB1_ENDPTNAKEN_EPRNE2_Pos = 0x2
	// Bit mask of EPRNE2 field.
	USB1_ENDPTNAKEN_EPRNE2_Msk = 0x4
	// Bit EPRNE2.
	USB1_ENDPTNAKEN_EPRNE2 = 0x4
	// Position of EPRNE3 field.
	USB1_ENDPTNAKEN_EPRNE3_Pos = 0x3
	// Bit mask of EPRNE3 field.
	USB1_ENDPTNAKEN_EPRNE3_Msk = 0x8
	// Bit EPRNE3.
	USB1_ENDPTNAKEN_EPRNE3 = 0x8
	// Position of RESERVED field.
	USB1_ENDPTNAKEN_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_ENDPTNAKEN_RESERVED_Msk = 0xfff0
	// Position of EPTNE16 field.
	USB1_ENDPTNAKEN_EPTNE16_Pos = 0x10
	// Bit mask of EPTNE16 field.
	USB1_ENDPTNAKEN_EPTNE16_Msk = 0x10000
	// Bit EPTNE16.
	USB1_ENDPTNAKEN_EPTNE16 = 0x10000
	// Position of EPTNE17 field.
	USB1_ENDPTNAKEN_EPTNE17_Pos = 0x11
	// Bit mask of EPTNE17 field.
	USB1_ENDPTNAKEN_EPTNE17_Msk = 0x20000
	// Bit EPTNE17.
	USB1_ENDPTNAKEN_EPTNE17 = 0x20000
	// Position of EPTNE18 field.
	USB1_ENDPTNAKEN_EPTNE18_Pos = 0x12
	// Bit mask of EPTNE18 field.
	USB1_ENDPTNAKEN_EPTNE18_Msk = 0x40000
	// Bit EPTNE18.
	USB1_ENDPTNAKEN_EPTNE18 = 0x40000
	// Position of EPTNE19 field.
	USB1_ENDPTNAKEN_EPTNE19_Pos = 0x13
	// Bit mask of EPTNE19 field.
	USB1_ENDPTNAKEN_EPTNE19_Msk = 0x80000
	// Bit EPTNE19.
	USB1_ENDPTNAKEN_EPTNE19 = 0x80000
	// Position of RESERVED field.
	USB1_ENDPTNAKEN_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_ENDPTNAKEN_RESERVED_Msk = 0xfff00000

	// PORTSC1_D: Port 1 status/control (device mode)
	// Position of CCS field.
	USB1_PORTSC1_D_CCS_Pos = 0x0
	// Bit mask of CCS field.
	USB1_PORTSC1_D_CCS_Msk = 0x1
	// Bit CCS.
	USB1_PORTSC1_D_CCS = 0x1
	// Device not attached A zero indicates that the device did not attach successfully or was forcibly disconnected by the software writing a zero to the Run bit in the USBCMD register. It does not state the device being disconnected or suspended.
	USB1_PORTSC1_D_CCS_DEVICE_NOT_ATTACHED_ = 0x0
	// Device attached. A one indicates that the device successfully attached and is operating in either high-speed mode or full-speed mode as indicated by the High Speed Port bit in this register.
	USB1_PORTSC1_D_CCS_DEVICE_ATTACHED__A_ = 0x1
	// Position of CSC field.
	USB1_PORTSC1_D_CSC_Pos = 0x1
	// Bit mask of CSC field.
	USB1_PORTSC1_D_CSC_Msk = 0x2
	// Bit CSC.
	USB1_PORTSC1_D_CSC = 0x2
	// Position of PE field.
	USB1_PORTSC1_D_PE_Pos = 0x2
	// Bit mask of PE field.
	USB1_PORTSC1_D_PE_Msk = 0x4
	// Bit PE.
	USB1_PORTSC1_D_PE = 0x4
	// Position of PEC field.
	USB1_PORTSC1_D_PEC_Pos = 0x3
	// Bit mask of PEC field.
	USB1_PORTSC1_D_PEC_Msk = 0x8
	// Bit PEC.
	USB1_PORTSC1_D_PEC = 0x8
	// Position of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Msk = 0x30
	// Position of FPR field.
	USB1_PORTSC1_D_FPR_Pos = 0x6
	// Bit mask of FPR field.
	USB1_PORTSC1_D_FPR_Msk = 0x40
	// Bit FPR.
	USB1_PORTSC1_D_FPR = 0x40
	// No resume (K-state) detected/driven on port.
	USB1_PORTSC1_D_FPR_NO_RESUME = 0x0
	// Resume detected/driven on port.
	USB1_PORTSC1_D_FPR_RESUME_DETECTED = 0x1
	// Position of SUSP field.
	USB1_PORTSC1_D_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	USB1_PORTSC1_D_SUSP_Msk = 0x80
	// Bit SUSP.
	USB1_PORTSC1_D_SUSP = 0x80
	// Port not in suspend state
	USB1_PORTSC1_D_SUSP_PORT_NOT_IN_SUSPEND_ = 0x0
	// Port in suspend state
	USB1_PORTSC1_D_SUSP_PORT_IN_SUSPEND_STAT = 0x1
	// Position of PR field.
	USB1_PORTSC1_D_PR_Pos = 0x8
	// Bit mask of PR field.
	USB1_PORTSC1_D_PR_Msk = 0x100
	// Bit PR.
	USB1_PORTSC1_D_PR = 0x100
	// Port is not in the reset state.
	USB1_PORTSC1_D_PR_PORT_IS_NOT_IN_THE_R = 0x0
	// Port is in the reset state.
	USB1_PORTSC1_D_PR_PORT_IS_IN_THE_RESET = 0x1
	// Position of HSP field.
	USB1_PORTSC1_D_HSP_Pos = 0x9
	// Bit mask of HSP field.
	USB1_PORTSC1_D_HSP_Msk = 0x200
	// Bit HSP.
	USB1_PORTSC1_D_HSP = 0x200
	// Host/device connected to the port is not in High-speed mode.
	USB1_PORTSC1_D_HSP_NOHISPEED = 0x0
	// Host/device connected to the port is in High-speed mode.
	USB1_PORTSC1_D_HSP_HISPEED = 0x1
	// Position of LS field.
	USB1_PORTSC1_D_LS_Pos = 0xa
	// Bit mask of LS field.
	USB1_PORTSC1_D_LS_Msk = 0xc00
	// Position of PP field.
	USB1_PORTSC1_D_PP_Pos = 0xc
	// Bit mask of PP field.
	USB1_PORTSC1_D_PP_Msk = 0x1000
	// Bit PP.
	USB1_PORTSC1_D_PP = 0x1000
	// Position of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	USB1_PORTSC1_D_RESERVED = 0x2000
	// Position of PIC1_0 field.
	USB1_PORTSC1_D_PIC1_0_Pos = 0xe
	// Bit mask of PIC1_0 field.
	USB1_PORTSC1_D_PIC1_0_Msk = 0xc000
	// Port indicators are off.
	USB1_PORTSC1_D_PIC1_0_OFF = 0x0
	// amber
	USB1_PORTSC1_D_PIC1_0_AMBER = 0x1
	// green
	USB1_PORTSC1_D_PIC1_0_GREEN = 0x2
	// undefined
	USB1_PORTSC1_D_PIC1_0_UNDEFINED = 0x3
	// Position of PTC3_0 field.
	USB1_PORTSC1_D_PTC3_0_Pos = 0x10
	// Bit mask of PTC3_0 field.
	USB1_PORTSC1_D_PTC3_0_Msk = 0xf0000
	// TEST_MODE_DISABLE
	USB1_PORTSC1_D_PTC3_0_TEST_MODE_DISABLE = 0x0
	// J_STATE
	USB1_PORTSC1_D_PTC3_0_J_STATE = 0x1
	// K_STATE
	USB1_PORTSC1_D_PTC3_0_K_STATE = 0x2
	// SE0 (host)/NAK (device)
	USB1_PORTSC1_D_PTC3_0_SE0 = 0x3
	// Packet
	USB1_PORTSC1_D_PTC3_0_PACKET = 0x4
	// FORCE_ENABLE_HS
	USB1_PORTSC1_D_PTC3_0_FORCE_ENABLE_HS = 0x5
	// FORCE_ENABLE_FS
	USB1_PORTSC1_D_PTC3_0_FORCE_ENABLE_FS = 0x6
	// Position of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Msk = 0x100000
	// Bit RESERVED.
	USB1_PORTSC1_D_RESERVED = 0x100000
	// Position of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Msk = 0x200000
	// Bit RESERVED.
	USB1_PORTSC1_D_RESERVED = 0x200000
	// Position of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Msk = 0x400000
	// Bit RESERVED.
	USB1_PORTSC1_D_RESERVED = 0x400000
	// Position of PHCD field.
	USB1_PORTSC1_D_PHCD_Pos = 0x17
	// Bit mask of PHCD field.
	USB1_PORTSC1_D_PHCD_Msk = 0x800000
	// Bit PHCD.
	USB1_PORTSC1_D_PHCD = 0x800000
	// Writing a 0 enables the PHY clock. Reading a 0 indicates the status of the PHY clock (enabled).
	USB1_PORTSC1_D_PHCD_ENABLED = 0x0
	// Writing a 1 disables the PHY clock. Reading a 1 indicates the status of the PHY clock (disabled).
	USB1_PORTSC1_D_PHCD_DISABLED = 0x1
	// Position of PFSC field.
	USB1_PORTSC1_D_PFSC_Pos = 0x18
	// Bit mask of PFSC field.
	USB1_PORTSC1_D_PFSC_Msk = 0x1000000
	// Bit PFSC.
	USB1_PORTSC1_D_PFSC = 0x1000000
	// Port connects at any speed.
	USB1_PORTSC1_D_PFSC_ANYSPEED = 0x0
	// Writing this bit to a 1 will force the port to only connect at full speed. It disables the chirp sequence that allows the port to identify itself as High-speed. This is useful for testing FS configurations with a HS host, hub or device.
	USB1_PORTSC1_D_PFSC_FULLSPEED = 0x1
	// Position of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Pos = 0x19
	// Bit mask of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Msk = 0x2000000
	// Bit RESERVED.
	USB1_PORTSC1_D_RESERVED = 0x2000000
	// Position of PSPD field.
	USB1_PORTSC1_D_PSPD_Pos = 0x1a
	// Bit mask of PSPD field.
	USB1_PORTSC1_D_PSPD_Msk = 0xc000000
	// Full-speed
	USB1_PORTSC1_D_PSPD_FULL_SPEED = 0x1
	// invalid in device mode
	USB1_PORTSC1_D_PSPD_INVALID_IN_DEVICE_MO = 0x2
	// High-speed
	USB1_PORTSC1_D_PSPD_HIGH_SPEED = 0x3
	// Position of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	USB1_PORTSC1_D_RESERVED_Msk = 0x30000000
	// Position of PTS field.
	USB1_PORTSC1_D_PTS_Pos = 0x1e
	// Bit mask of PTS field.
	USB1_PORTSC1_D_PTS_Msk = 0xc0000000
	// ULPI
	USB1_PORTSC1_D_PTS_ULPI = 0x2
	// Serial/ 1.1 PHY (Full-speed only)
	USB1_PORTSC1_D_PTS_SERIAL = 0x3

	// PORTSC1_H: Port 1 status/control (host mode)
	// Position of CCS field.
	USB1_PORTSC1_H_CCS_Pos = 0x0
	// Bit mask of CCS field.
	USB1_PORTSC1_H_CCS_Msk = 0x1
	// Bit CCS.
	USB1_PORTSC1_H_CCS = 0x1
	// No device is present.
	USB1_PORTSC1_H_CCS_NO_DEVICE_IS_PRESENT = 0x0
	// Device is present on the port.
	USB1_PORTSC1_H_CCS_DEVICE_IS_PRESENT_ON = 0x1
	// Position of CSC field.
	USB1_PORTSC1_H_CSC_Pos = 0x1
	// Bit mask of CSC field.
	USB1_PORTSC1_H_CSC_Msk = 0x2
	// Bit CSC.
	USB1_PORTSC1_H_CSC = 0x2
	// No change in current status.
	USB1_PORTSC1_H_CSC_NO_CHANGE_IN_CURRENT = 0x0
	// Change in current status.
	USB1_PORTSC1_H_CSC_CHANGE_IN_CURRENT_ST = 0x1
	// Position of PE field.
	USB1_PORTSC1_H_PE_Pos = 0x2
	// Bit mask of PE field.
	USB1_PORTSC1_H_PE_Msk = 0x4
	// Bit PE.
	USB1_PORTSC1_H_PE = 0x4
	// Port disabled.
	USB1_PORTSC1_H_PE_PORT_DISABLED_ = 0x0
	// Port enabled.
	USB1_PORTSC1_H_PE_PORT_ENABLED_ = 0x1
	// Position of PEC field.
	USB1_PORTSC1_H_PEC_Pos = 0x3
	// Bit mask of PEC field.
	USB1_PORTSC1_H_PEC_Msk = 0x8
	// Bit PEC.
	USB1_PORTSC1_H_PEC = 0x8
	// No change.
	USB1_PORTSC1_H_PEC_NO_CHANGE_ = 0x0
	// Port enabled/disabled status has changed.
	USB1_PORTSC1_H_PEC_CHANGED = 0x1
	// Position of OCA field.
	USB1_PORTSC1_H_OCA_Pos = 0x4
	// Bit mask of OCA field.
	USB1_PORTSC1_H_OCA_Msk = 0x10
	// Bit OCA.
	USB1_PORTSC1_H_OCA = 0x10
	// The port does not have an over-current condition.
	USB1_PORTSC1_H_OCA_THE_PORT_DOES_NOT_HA = 0x0
	// The port has currently an over-current condition.
	USB1_PORTSC1_H_OCA_THE_PORT_HAS_CURRENT = 0x1
	// Position of OCC field.
	USB1_PORTSC1_H_OCC_Pos = 0x5
	// Bit mask of OCC field.
	USB1_PORTSC1_H_OCC_Msk = 0x20
	// Bit OCC.
	USB1_PORTSC1_H_OCC = 0x20
	// Position of FPR field.
	USB1_PORTSC1_H_FPR_Pos = 0x6
	// Bit mask of FPR field.
	USB1_PORTSC1_H_FPR_Msk = 0x40
	// Bit FPR.
	USB1_PORTSC1_H_FPR = 0x40
	// No resume (K-state) detected/driven on port.
	USB1_PORTSC1_H_FPR_NO_RESUME = 0x0
	// Resume detected/driven on port.
	USB1_PORTSC1_H_FPR_RESUME_DETECTED = 0x1
	// Position of SUSP field.
	USB1_PORTSC1_H_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	USB1_PORTSC1_H_SUSP_Msk = 0x80
	// Bit SUSP.
	USB1_PORTSC1_H_SUSP = 0x80
	// Port not in suspend state
	USB1_PORTSC1_H_SUSP_PORT_NOT_IN_SUSPEND_ = 0x0
	// Port in suspend state When in suspend state, downstream propagation of data is blocked on this port, except for port reset. The blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1. In the suspend state, the port is sensitive to resume detection. Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB.
	USB1_PORTSC1_H_SUSP_PORT_IN_SUSPEND_STAT = 0x1
	// Position of PR field.
	USB1_PORTSC1_H_PR_Pos = 0x8
	// Bit mask of PR field.
	USB1_PORTSC1_H_PR_Msk = 0x100
	// Bit PR.
	USB1_PORTSC1_H_PR = 0x100
	// Port is not in the reset state.
	USB1_PORTSC1_H_PR_NOT_IN_RESET = 0x0
	// Port is in the reset state.
	USB1_PORTSC1_H_PR_PORT_IS_IN_THE_RESET = 0x1
	// Position of HSP field.
	USB1_PORTSC1_H_HSP_Pos = 0x9
	// Bit mask of HSP field.
	USB1_PORTSC1_H_HSP_Msk = 0x200
	// Bit HSP.
	USB1_PORTSC1_H_HSP = 0x200
	// Host/device connected to the port is not in High-speed mode.
	USB1_PORTSC1_H_HSP_NOHIGHSPEED = 0x0
	// Host/device connected to the port is in High-speed mode.
	USB1_PORTSC1_H_HSP_HIGHSPEED = 0x1
	// Position of LS field.
	USB1_PORTSC1_H_LS_Pos = 0xa
	// Bit mask of LS field.
	USB1_PORTSC1_H_LS_Msk = 0xc00
	// SE0 (USB_DP and USB_DM LOW)
	USB1_PORTSC1_H_LS_SE0 = 0x0
	// J-state (USB_DP HIGH and USB_DM LOW)
	USB1_PORTSC1_H_LS_J_STATE = 0x1
	// K-state (USB_DP LOW and USB_DM HIGH)
	USB1_PORTSC1_H_LS_K_STATE = 0x2
	// Undefined
	USB1_PORTSC1_H_LS_UNDEFINED = 0x3
	// Position of PP field.
	USB1_PORTSC1_H_PP_Pos = 0xc
	// Bit mask of PP field.
	USB1_PORTSC1_H_PP_Msk = 0x1000
	// Bit PP.
	USB1_PORTSC1_H_PP = 0x1000
	// Port power off.
	USB1_PORTSC1_H_PP_PORT_POWER_OFF_ = 0x0
	// Port power on.
	USB1_PORTSC1_H_PP_PORT_POWER_ON_ = 0x1
	// Position of RESERVED field.
	USB1_PORTSC1_H_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	USB1_PORTSC1_H_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	USB1_PORTSC1_H_RESERVED = 0x2000
	// Position of PIC1_0 field.
	USB1_PORTSC1_H_PIC1_0_Pos = 0xe
	// Bit mask of PIC1_0 field.
	USB1_PORTSC1_H_PIC1_0_Msk = 0xc000
	// Port indicators are off.
	USB1_PORTSC1_H_PIC1_0_OFF = 0x0
	// Amber
	USB1_PORTSC1_H_PIC1_0_AMBER = 0x1
	// Green
	USB1_PORTSC1_H_PIC1_0_GREEN = 0x2
	// Undefined
	USB1_PORTSC1_H_PIC1_0_UNDEFINED = 0x3
	// Position of PTC3_0 field.
	USB1_PORTSC1_H_PTC3_0_Pos = 0x10
	// Bit mask of PTC3_0 field.
	USB1_PORTSC1_H_PTC3_0_Msk = 0xf0000
	// TEST_MODE_DISABLE
	USB1_PORTSC1_H_PTC3_0_TEST_MODE_DISABLE = 0x0
	// J_STATE
	USB1_PORTSC1_H_PTC3_0_J_STATE = 0x1
	// K_STATE
	USB1_PORTSC1_H_PTC3_0_K_STATE = 0x2
	// SE0 (host)/NAK (device)
	USB1_PORTSC1_H_PTC3_0_SE0_NAK = 0x3
	// Packet
	USB1_PORTSC1_H_PTC3_0_PACKET = 0x4
	// FORCE_ENABLE_HS
	USB1_PORTSC1_H_PTC3_0_FORCE_ENABLE_HS = 0x5
	// FORCE_ENABLE_FS
	USB1_PORTSC1_H_PTC3_0_FORCE_ENABLE_FS = 0x6
	// FORCE_ENABLE_LS
	USB1_PORTSC1_H_PTC3_0_FORCE_ENABLE_LS = 0x7
	// Position of WKCN field.
	USB1_PORTSC1_H_WKCN_Pos = 0x14
	// Bit mask of WKCN field.
	USB1_PORTSC1_H_WKCN_Msk = 0x100000
	// Bit WKCN.
	USB1_PORTSC1_H_WKCN = 0x100000
	// Disables the port to wake up on device connects.
	USB1_PORTSC1_H_WKCN_DISABLES_THE_PORT_TO = 0x0
	// Writing this bit to a one enables the port to be sensitive to device connects as wake-up events.
	USB1_PORTSC1_H_WKCN_ENABLE_DEVICE_CON = 0x1
	// Position of WKDC field.
	USB1_PORTSC1_H_WKDC_Pos = 0x15
	// Bit mask of WKDC field.
	USB1_PORTSC1_H_WKDC_Msk = 0x200000
	// Bit WKDC.
	USB1_PORTSC1_H_WKDC = 0x200000
	// Disables the port to wake up on device disconnects.
	USB1_PORTSC1_H_WKDC_DISABLES_THE_PORT_TO = 0x0
	// Writing this bit to a one enables the port to be sensitive to device disconnects as wake-up events.
	USB1_PORTSC1_H_WKDC_ENABLE_DEVICE_CON = 0x1
	// Position of WKOC field.
	USB1_PORTSC1_H_WKOC_Pos = 0x16
	// Bit mask of WKOC field.
	USB1_PORTSC1_H_WKOC_Msk = 0x400000
	// Bit WKOC.
	USB1_PORTSC1_H_WKOC = 0x400000
	// Disables the port to wake up on over-current events.
	USB1_PORTSC1_H_WKOC_DISABLES_OVERCURRENT = 0x0
	// Writing a one to this bit enabled the port to be sensitive to over-current conditions as wake-up events.
	USB1_PORTSC1_H_WKOC_ENABLE_OVERCURRENT = 0x1
	// Position of PHCD field.
	USB1_PORTSC1_H_PHCD_Pos = 0x17
	// Bit mask of PHCD field.
	USB1_PORTSC1_H_PHCD_Msk = 0x800000
	// Bit PHCD.
	USB1_PORTSC1_H_PHCD = 0x800000
	// Writing a 0 enables the PHY clock. Reading a 0 indicates the status of the PHY clock (enabled).
	USB1_PORTSC1_H_PHCD_ENABLE_PHY_CLK = 0x0
	// Writing a 1 disables the PHY clock. Reading a 1 indicates the status of the PHY clock (disabled).
	USB1_PORTSC1_H_PHCD_DISABLE_PHY_CLK = 0x1
	// Position of PFSC field.
	USB1_PORTSC1_H_PFSC_Pos = 0x18
	// Bit mask of PFSC field.
	USB1_PORTSC1_H_PFSC_Msk = 0x1000000
	// Bit PFSC.
	USB1_PORTSC1_H_PFSC = 0x1000000
	// Port connects at any speed.
	USB1_PORTSC1_H_PFSC_ANYSPEED = 0x0
	// Writing this bit to a 1 will force the port to only connect at Full Speed. It disables the chirp sequence that allows the port to identify itself as High Speed. This is useful for testing FS configurations with a HS host, hub or device.
	USB1_PORTSC1_H_PFSC_FULLSPEED = 0x1
	// Position of RESERVED field.
	USB1_PORTSC1_H_RESERVED_Pos = 0x19
	// Bit mask of RESERVED field.
	USB1_PORTSC1_H_RESERVED_Msk = 0x2000000
	// Bit RESERVED.
	USB1_PORTSC1_H_RESERVED = 0x2000000
	// Position of PSPD field.
	USB1_PORTSC1_H_PSPD_Pos = 0x1a
	// Bit mask of PSPD field.
	USB1_PORTSC1_H_PSPD_Msk = 0xc000000
	// Full-speed
	USB1_PORTSC1_H_PSPD_FULL_SPEED = 0x0
	// Low-speed
	USB1_PORTSC1_H_PSPD_LOW_SPEED = 0x1
	// High-speed
	USB1_PORTSC1_H_PSPD_HIGH_SPEED = 0x2
	// Position of RESERVED field.
	USB1_PORTSC1_H_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	USB1_PORTSC1_H_RESERVED_Msk = 0x30000000
	// Position of PTS field.
	USB1_PORTSC1_H_PTS_Pos = 0x1e
	// Bit mask of PTS field.
	USB1_PORTSC1_H_PTS_Msk = 0xc0000000
	// ULPI
	USB1_PORTSC1_H_PTS_ULPI = 0x2
	// Serial/ 1.1 PHY (Full-speed only)
	USB1_PORTSC1_H_PTS_SERIAL = 0x3

	// USBMODE_D: USB mode (device mode)
	// Position of CM1_0 field.
	USB1_USBMODE_D_CM1_0_Pos = 0x0
	// Bit mask of CM1_0 field.
	USB1_USBMODE_D_CM1_0_Msk = 0x3
	// Idle
	USB1_USBMODE_D_CM1_0_IDLE = 0x0
	// Device controller
	USB1_USBMODE_D_CM1_0_DEVICE_CONTROLLER = 0x2
	// Host controller
	USB1_USBMODE_D_CM1_0_HOST_CONTROLLER = 0x3
	// Position of ES field.
	USB1_USBMODE_D_ES_Pos = 0x2
	// Bit mask of ES field.
	USB1_USBMODE_D_ES_Msk = 0x4
	// Bit ES.
	USB1_USBMODE_D_ES = 0x4
	// Little endian: first byte referenced in least significant byte of 32-bit word.
	USB1_USBMODE_D_ES_LITTLE_ENDIAN_FIRST = 0x0
	// Big endian: first byte referenced in most significant byte of 32-bit word.
	USB1_USBMODE_D_ES_BIG_ENDIAN_FIRST_BY = 0x1
	// Position of SLOM field.
	USB1_USBMODE_D_SLOM_Pos = 0x3
	// Bit mask of SLOM field.
	USB1_USBMODE_D_SLOM_Msk = 0x8
	// Bit SLOM.
	USB1_USBMODE_D_SLOM = 0x8
	// Setup Lockouts on
	USB1_USBMODE_D_SLOM_SETUP_LOCKOUTS_ON = 0x0
	// Setup Lockouts Off (DCD requires the use of Setup Buffer Tripwire in USBCMD)
	USB1_USBMODE_D_SLOM_SETUP_LOCKOUTS_OFF = 0x1
	// Position of SDIS field.
	USB1_USBMODE_D_SDIS_Pos = 0x4
	// Bit mask of SDIS field.
	USB1_USBMODE_D_SDIS_Msk = 0x10
	// Bit SDIS.
	USB1_USBMODE_D_SDIS = 0x10
	// Not disabled
	USB1_USBMODE_D_SDIS_NOT_DISABLED = 0x0
	// Disabled. Setting this bit to one disables double priming on both RX and TX for low bandwidth systems. This mode ensures that when the RX and TX buffers are sufficient to contain an entire packet that the standard double buffering scheme is disabled to prevent overruns/underruns in bandwidth limited systems. Note: In High Speed Mode, all packets received will be responded to with a NYET handshake when stream disable is active.
	USB1_USBMODE_D_SDIS_DISABLED_SETTING_TH = 0x1
	// Position of RESERVED field.
	USB1_USBMODE_D_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB1_USBMODE_D_RESERVED_Msk = 0x20
	// Bit RESERVED.
	USB1_USBMODE_D_RESERVED = 0x20
	// Position of RESERVED field.
	USB1_USBMODE_D_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB1_USBMODE_D_RESERVED_Msk = 0xffffffc0

	// USBMODE_H: USB mode (host mode)
	// Position of CM1_0 field.
	USB1_USBMODE_H_CM1_0_Pos = 0x0
	// Bit mask of CM1_0 field.
	USB1_USBMODE_H_CM1_0_Msk = 0x3
	// Idle
	USB1_USBMODE_H_CM1_0_IDLE = 0x0
	// Device controller
	USB1_USBMODE_H_CM1_0_DEVICE_CONTROLLER = 0x2
	// Host controller
	USB1_USBMODE_H_CM1_0_HOST_CONTROLLER = 0x3
	// Position of ES field.
	USB1_USBMODE_H_ES_Pos = 0x2
	// Bit mask of ES field.
	USB1_USBMODE_H_ES_Msk = 0x4
	// Bit ES.
	USB1_USBMODE_H_ES = 0x4
	// Little endian: first byte referenced in least significant byte of 32-bit word.
	USB1_USBMODE_H_ES_LITTLE_ENDIAN_FIRST = 0x0
	// Big endian: first byte referenced in most significant byte of 32-bit word.
	USB1_USBMODE_H_ES_BIG_ENDIAN_FIRST_BY = 0x1
	// Position of RESERVED field.
	USB1_USBMODE_H_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USB1_USBMODE_H_RESERVED_Msk = 0x8
	// Bit RESERVED.
	USB1_USBMODE_H_RESERVED = 0x8
	// Position of SDIS field.
	USB1_USBMODE_H_SDIS_Pos = 0x4
	// Bit mask of SDIS field.
	USB1_USBMODE_H_SDIS_Msk = 0x10
	// Bit SDIS.
	USB1_USBMODE_H_SDIS = 0x10
	// Not disabled
	USB1_USBMODE_H_SDIS_NOT_DISABLED = 0x0
	// Disabled. Setting to a 1 ensures that overruns/underruns of the latency FIFO are eliminated for low bandwidth systems where the RX and TX buffers are sufficient to contain the entire packet. Enabling stream disable also has the effect of ensuring the the TX latency is filled to capacity before the packet is launched onto the USB. Note: Time duration to pre-fill the FIFO becomes significant when stream disable is active. See TXFILLTUNING to characterize the adjustments needed for the scheduler when using this feature.
	USB1_USBMODE_H_SDIS_DISABLED_SETTING_TO = 0x1
	// Position of VBPS field.
	USB1_USBMODE_H_VBPS_Pos = 0x5
	// Bit mask of VBPS field.
	USB1_USBMODE_H_VBPS_Msk = 0x20
	// Bit VBPS.
	USB1_USBMODE_H_VBPS = 0x20
	// vbus_pwr_select is set LOW.
	USB1_USBMODE_H_VBPS_LOW = 0x0
	// vbus_pwr_select is set HIGH
	USB1_USBMODE_H_VBPS_HIGH = 0x1
	// Position of RESERVED field.
	USB1_USBMODE_H_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB1_USBMODE_H_RESERVED_Msk = 0xffffffc0

	// ENDPTSETUPSTAT: Endpoint setup status
	// Position of ENDPTSETUPSTAT0 field.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT0_Pos = 0x0
	// Bit mask of ENDPTSETUPSTAT0 field.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT0_Msk = 0x1
	// Bit ENDPTSETUPSTAT0.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT0 = 0x1
	// Position of ENDPTSETUPSTAT1 field.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT1_Pos = 0x1
	// Bit mask of ENDPTSETUPSTAT1 field.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT1_Msk = 0x2
	// Bit ENDPTSETUPSTAT1.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT1 = 0x2
	// Position of ENDPTSETUPSTAT2 field.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT2_Pos = 0x2
	// Bit mask of ENDPTSETUPSTAT2 field.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT2_Msk = 0x4
	// Bit ENDPTSETUPSTAT2.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT2 = 0x4
	// Position of ENDPTSETUPSTAT3 field.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT3_Pos = 0x3
	// Bit mask of ENDPTSETUPSTAT3 field.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT3_Msk = 0x8
	// Bit ENDPTSETUPSTAT3.
	USB1_ENDPTSETUPSTAT_ENDPTSETUPSTAT3 = 0x8
	// Position of RESERVED field.
	USB1_ENDPTSETUPSTAT_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_ENDPTSETUPSTAT_RESERVED_Msk = 0xfffffff0

	// ENDPTPRIME: Endpoint initialization
	// Position of PERB0 field.
	USB1_ENDPTPRIME_PERB0_Pos = 0x0
	// Bit mask of PERB0 field.
	USB1_ENDPTPRIME_PERB0_Msk = 0x1
	// Bit PERB0.
	USB1_ENDPTPRIME_PERB0 = 0x1
	// Position of PERB1 field.
	USB1_ENDPTPRIME_PERB1_Pos = 0x1
	// Bit mask of PERB1 field.
	USB1_ENDPTPRIME_PERB1_Msk = 0x2
	// Bit PERB1.
	USB1_ENDPTPRIME_PERB1 = 0x2
	// Position of PERB2 field.
	USB1_ENDPTPRIME_PERB2_Pos = 0x2
	// Bit mask of PERB2 field.
	USB1_ENDPTPRIME_PERB2_Msk = 0x4
	// Bit PERB2.
	USB1_ENDPTPRIME_PERB2 = 0x4
	// Position of PERB3 field.
	USB1_ENDPTPRIME_PERB3_Pos = 0x3
	// Bit mask of PERB3 field.
	USB1_ENDPTPRIME_PERB3_Msk = 0x8
	// Bit PERB3.
	USB1_ENDPTPRIME_PERB3 = 0x8
	// Position of RESERVED field.
	USB1_ENDPTPRIME_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_ENDPTPRIME_RESERVED_Msk = 0xfff0
	// Position of PETB0 field.
	USB1_ENDPTPRIME_PETB0_Pos = 0x10
	// Bit mask of PETB0 field.
	USB1_ENDPTPRIME_PETB0_Msk = 0x10000
	// Bit PETB0.
	USB1_ENDPTPRIME_PETB0 = 0x10000
	// Position of PETB1 field.
	USB1_ENDPTPRIME_PETB1_Pos = 0x11
	// Bit mask of PETB1 field.
	USB1_ENDPTPRIME_PETB1_Msk = 0x20000
	// Bit PETB1.
	USB1_ENDPTPRIME_PETB1 = 0x20000
	// Position of PETB2 field.
	USB1_ENDPTPRIME_PETB2_Pos = 0x12
	// Bit mask of PETB2 field.
	USB1_ENDPTPRIME_PETB2_Msk = 0x40000
	// Bit PETB2.
	USB1_ENDPTPRIME_PETB2 = 0x40000
	// Position of PETB3 field.
	USB1_ENDPTPRIME_PETB3_Pos = 0x13
	// Bit mask of PETB3 field.
	USB1_ENDPTPRIME_PETB3_Msk = 0x80000
	// Bit PETB3.
	USB1_ENDPTPRIME_PETB3 = 0x80000
	// Position of RESERVED field.
	USB1_ENDPTPRIME_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_ENDPTPRIME_RESERVED_Msk = 0xfff00000

	// ENDPTFLUSH: Endpoint de-initialization
	// Position of FERB0 field.
	USB1_ENDPTFLUSH_FERB0_Pos = 0x0
	// Bit mask of FERB0 field.
	USB1_ENDPTFLUSH_FERB0_Msk = 0x1
	// Bit FERB0.
	USB1_ENDPTFLUSH_FERB0 = 0x1
	// Position of FERB1 field.
	USB1_ENDPTFLUSH_FERB1_Pos = 0x1
	// Bit mask of FERB1 field.
	USB1_ENDPTFLUSH_FERB1_Msk = 0x2
	// Bit FERB1.
	USB1_ENDPTFLUSH_FERB1 = 0x2
	// Position of FERB2 field.
	USB1_ENDPTFLUSH_FERB2_Pos = 0x2
	// Bit mask of FERB2 field.
	USB1_ENDPTFLUSH_FERB2_Msk = 0x4
	// Bit FERB2.
	USB1_ENDPTFLUSH_FERB2 = 0x4
	// Position of FERB3 field.
	USB1_ENDPTFLUSH_FERB3_Pos = 0x3
	// Bit mask of FERB3 field.
	USB1_ENDPTFLUSH_FERB3_Msk = 0x8
	// Bit FERB3.
	USB1_ENDPTFLUSH_FERB3 = 0x8
	// Position of RESERVED field.
	USB1_ENDPTFLUSH_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_ENDPTFLUSH_RESERVED_Msk = 0xfff0
	// Position of FETB0 field.
	USB1_ENDPTFLUSH_FETB0_Pos = 0x10
	// Bit mask of FETB0 field.
	USB1_ENDPTFLUSH_FETB0_Msk = 0x10000
	// Bit FETB0.
	USB1_ENDPTFLUSH_FETB0 = 0x10000
	// Position of FETB1 field.
	USB1_ENDPTFLUSH_FETB1_Pos = 0x11
	// Bit mask of FETB1 field.
	USB1_ENDPTFLUSH_FETB1_Msk = 0x20000
	// Bit FETB1.
	USB1_ENDPTFLUSH_FETB1 = 0x20000
	// Position of FETB2 field.
	USB1_ENDPTFLUSH_FETB2_Pos = 0x12
	// Bit mask of FETB2 field.
	USB1_ENDPTFLUSH_FETB2_Msk = 0x40000
	// Bit FETB2.
	USB1_ENDPTFLUSH_FETB2 = 0x40000
	// Position of FETB3 field.
	USB1_ENDPTFLUSH_FETB3_Pos = 0x13
	// Bit mask of FETB3 field.
	USB1_ENDPTFLUSH_FETB3_Msk = 0x80000
	// Bit FETB3.
	USB1_ENDPTFLUSH_FETB3 = 0x80000
	// Position of RESERVED field.
	USB1_ENDPTFLUSH_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_ENDPTFLUSH_RESERVED_Msk = 0xfff00000

	// ENDPTSTAT: Endpoint status
	// Position of ERBR0 field.
	USB1_ENDPTSTAT_ERBR0_Pos = 0x0
	// Bit mask of ERBR0 field.
	USB1_ENDPTSTAT_ERBR0_Msk = 0x1
	// Bit ERBR0.
	USB1_ENDPTSTAT_ERBR0 = 0x1
	// Position of ERBR1 field.
	USB1_ENDPTSTAT_ERBR1_Pos = 0x1
	// Bit mask of ERBR1 field.
	USB1_ENDPTSTAT_ERBR1_Msk = 0x2
	// Bit ERBR1.
	USB1_ENDPTSTAT_ERBR1 = 0x2
	// Position of ERBR2 field.
	USB1_ENDPTSTAT_ERBR2_Pos = 0x2
	// Bit mask of ERBR2 field.
	USB1_ENDPTSTAT_ERBR2_Msk = 0x4
	// Bit ERBR2.
	USB1_ENDPTSTAT_ERBR2 = 0x4
	// Position of ERBR3 field.
	USB1_ENDPTSTAT_ERBR3_Pos = 0x3
	// Bit mask of ERBR3 field.
	USB1_ENDPTSTAT_ERBR3_Msk = 0x8
	// Bit ERBR3.
	USB1_ENDPTSTAT_ERBR3 = 0x8
	// Position of RESERVED field.
	USB1_ENDPTSTAT_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_ENDPTSTAT_RESERVED_Msk = 0xfff0
	// Position of ETBR0 field.
	USB1_ENDPTSTAT_ETBR0_Pos = 0x10
	// Bit mask of ETBR0 field.
	USB1_ENDPTSTAT_ETBR0_Msk = 0x10000
	// Bit ETBR0.
	USB1_ENDPTSTAT_ETBR0 = 0x10000
	// Position of ETBR1 field.
	USB1_ENDPTSTAT_ETBR1_Pos = 0x11
	// Bit mask of ETBR1 field.
	USB1_ENDPTSTAT_ETBR1_Msk = 0x20000
	// Bit ETBR1.
	USB1_ENDPTSTAT_ETBR1 = 0x20000
	// Position of ETBR2 field.
	USB1_ENDPTSTAT_ETBR2_Pos = 0x12
	// Bit mask of ETBR2 field.
	USB1_ENDPTSTAT_ETBR2_Msk = 0x40000
	// Bit ETBR2.
	USB1_ENDPTSTAT_ETBR2 = 0x40000
	// Position of ETBR3 field.
	USB1_ENDPTSTAT_ETBR3_Pos = 0x13
	// Bit mask of ETBR3 field.
	USB1_ENDPTSTAT_ETBR3_Msk = 0x80000
	// Bit ETBR3.
	USB1_ENDPTSTAT_ETBR3 = 0x80000
	// Position of RESERVED field.
	USB1_ENDPTSTAT_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_ENDPTSTAT_RESERVED_Msk = 0xfff00000

	// ENDPTCOMPLETE: Endpoint complete
	// Position of ERCE0 field.
	USB1_ENDPTCOMPLETE_ERCE0_Pos = 0x0
	// Bit mask of ERCE0 field.
	USB1_ENDPTCOMPLETE_ERCE0_Msk = 0x1
	// Bit ERCE0.
	USB1_ENDPTCOMPLETE_ERCE0 = 0x1
	// Position of ERCE1 field.
	USB1_ENDPTCOMPLETE_ERCE1_Pos = 0x1
	// Bit mask of ERCE1 field.
	USB1_ENDPTCOMPLETE_ERCE1_Msk = 0x2
	// Bit ERCE1.
	USB1_ENDPTCOMPLETE_ERCE1 = 0x2
	// Position of ERCE2 field.
	USB1_ENDPTCOMPLETE_ERCE2_Pos = 0x2
	// Bit mask of ERCE2 field.
	USB1_ENDPTCOMPLETE_ERCE2_Msk = 0x4
	// Bit ERCE2.
	USB1_ENDPTCOMPLETE_ERCE2 = 0x4
	// Position of ERCE3 field.
	USB1_ENDPTCOMPLETE_ERCE3_Pos = 0x3
	// Bit mask of ERCE3 field.
	USB1_ENDPTCOMPLETE_ERCE3_Msk = 0x8
	// Bit ERCE3.
	USB1_ENDPTCOMPLETE_ERCE3 = 0x8
	// Position of RESERVED field.
	USB1_ENDPTCOMPLETE_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_ENDPTCOMPLETE_RESERVED_Msk = 0xfff0
	// Position of ETCE0 field.
	USB1_ENDPTCOMPLETE_ETCE0_Pos = 0x10
	// Bit mask of ETCE0 field.
	USB1_ENDPTCOMPLETE_ETCE0_Msk = 0x10000
	// Bit ETCE0.
	USB1_ENDPTCOMPLETE_ETCE0 = 0x10000
	// Position of ETCE1 field.
	USB1_ENDPTCOMPLETE_ETCE1_Pos = 0x11
	// Bit mask of ETCE1 field.
	USB1_ENDPTCOMPLETE_ETCE1_Msk = 0x20000
	// Bit ETCE1.
	USB1_ENDPTCOMPLETE_ETCE1 = 0x20000
	// Position of ETCE2 field.
	USB1_ENDPTCOMPLETE_ETCE2_Pos = 0x12
	// Bit mask of ETCE2 field.
	USB1_ENDPTCOMPLETE_ETCE2_Msk = 0x40000
	// Bit ETCE2.
	USB1_ENDPTCOMPLETE_ETCE2 = 0x40000
	// Position of ETCE3 field.
	USB1_ENDPTCOMPLETE_ETCE3_Pos = 0x13
	// Bit mask of ETCE3 field.
	USB1_ENDPTCOMPLETE_ETCE3_Msk = 0x80000
	// Bit ETCE3.
	USB1_ENDPTCOMPLETE_ETCE3 = 0x80000
	// Position of RESERVED field.
	USB1_ENDPTCOMPLETE_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_ENDPTCOMPLETE_RESERVED_Msk = 0xfff00000

	// ENDPTCTRL0: Endpoint control 0
	// Position of RXS field.
	USB1_ENDPTCTRL0_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB1_ENDPTCTRL0_RXS_Msk = 0x1
	// Bit RXS.
	USB1_ENDPTCTRL0_RXS = 0x1
	// Endpoint ok.
	USB1_ENDPTCTRL0_RXS_ENDPOINT_OK_ = 0x0
	// Endpoint stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software, or it will automatically be cleared upon receipt of a new SETUP request. After receiving a SETUP request, this bit will continue to be cleared by hardware until the associated ENDSETUPSTAT bit is cleared.[1]
	USB1_ENDPTCTRL0_RXS_ENDPOINT_STALLED_SOF = 0x1
	// Position of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Msk = 0x2
	// Bit RESERVED.
	USB1_ENDPTCTRL0_RESERVED = 0x2
	// Position of RXT field.
	USB1_ENDPTCTRL0_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB1_ENDPTCTRL0_RXT_Msk = 0xc
	// Position of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Msk = 0x70
	// Position of RXE field.
	USB1_ENDPTCTRL0_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB1_ENDPTCTRL0_RXE_Msk = 0x80
	// Bit RXE.
	USB1_ENDPTCTRL0_RXE = 0x80
	// Position of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Msk = 0xff00
	// Position of TXS field.
	USB1_ENDPTCTRL0_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB1_ENDPTCTRL0_TXS_Msk = 0x10000
	// Bit TXS.
	USB1_ENDPTCTRL0_TXS = 0x10000
	// Endpoint ok.
	USB1_ENDPTCTRL0_TXS_ENDPOINT_OK_ = 0x0
	// Endpoint stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software, or it will automatically be cleared upon receipt of a new SETUP request. After receiving a SETUP request, this bit will continue to be cleared by hardware until the associated ENDSETUPSTAT bit is cleared.[1]
	USB1_ENDPTCTRL0_TXS_ENDPOINT_STALLED_SOF = 0x1
	// Position of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB1_ENDPTCTRL0_RESERVED = 0x20000
	// Position of TXT field.
	USB1_ENDPTCTRL0_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB1_ENDPTCTRL0_TXT_Msk = 0xc0000
	// Position of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Msk = 0x700000
	// Position of TXE field.
	USB1_ENDPTCTRL0_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB1_ENDPTCTRL0_TXE_Msk = 0x800000
	// Bit TXE.
	USB1_ENDPTCTRL0_TXE = 0x800000
	// Position of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL0_RESERVED_Msk = 0xff000000

	// ENDPTCTRL1: Endpoint control
	// Position of RXS field.
	USB1_ENDPTCTRL_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB1_ENDPTCTRL_RXS_Msk = 0x1
	// Bit RXS.
	USB1_ENDPTCTRL_RXS = 0x1
	// Endpoint ok. This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared.
	USB1_ENDPTCTRL_RXS_ENDPOINT_OK_THIS_BI = 0x0
	// Endpoint stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software, or it will automatically be cleared upon receipt of a new SETUP request.[1]
	USB1_ENDPTCTRL_RXS_ENDPOINT_STALLED_SOF = 0x1
	// Position of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Msk = 0x2
	// Bit RESERVED.
	USB1_ENDPTCTRL_RESERVED = 0x2
	// Position of RXT field.
	USB1_ENDPTCTRL_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB1_ENDPTCTRL_RXT_Msk = 0xc
	// Control
	USB1_ENDPTCTRL_RXT_CONTROL = 0x0
	// Isochronous
	USB1_ENDPTCTRL_RXT_ISOCHRONOUS = 0x1
	// Bulk
	USB1_ENDPTCTRL_RXT_BULK = 0x2
	// Position of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Msk = 0x10
	// Bit RESERVED.
	USB1_ENDPTCTRL_RESERVED = 0x10
	// Position of RXI field.
	USB1_ENDPTCTRL_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB1_ENDPTCTRL_RXI_Msk = 0x20
	// Bit RXI.
	USB1_ENDPTCTRL_RXI = 0x20
	// Disabled
	USB1_ENDPTCTRL_RXI_DISABLED = 0x0
	// Enabled
	USB1_ENDPTCTRL_RXI_ENABLED = 0x1
	// Position of RXR field.
	USB1_ENDPTCTRL_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB1_ENDPTCTRL_RXR_Msk = 0x40
	// Bit RXR.
	USB1_ENDPTCTRL_RXR = 0x40
	// Position of RXE field.
	USB1_ENDPTCTRL_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB1_ENDPTCTRL_RXE_Msk = 0x80
	// Bit RXE.
	USB1_ENDPTCTRL_RXE = 0x80
	// Endpoint disabled.
	USB1_ENDPTCTRL_RXE_ENDPOINT_DISABLED_ = 0x0
	// Endpoint enabled.
	USB1_ENDPTCTRL_RXE_ENDPOINT_ENABLED_ = 0x1
	// Position of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Msk = 0xff00
	// Position of TXS field.
	USB1_ENDPTCTRL_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB1_ENDPTCTRL_TXS_Msk = 0x10000
	// Bit TXS.
	USB1_ENDPTCTRL_TXS = 0x10000
	// Endpoint ok. This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured as a Control Endpoint, and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared.
	USB1_ENDPTCTRL_TXS_ENDPOINT_OK_THIS_BI = 0x0
	// Endpoint stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. It will continue returning STALL until the bit is cleared by software, or it will automatically be cleared upon receipt of a new SETUP request.[1]
	USB1_ENDPTCTRL_TXS_ENDPOINT_STALLED_SOF = 0x1
	// Position of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Msk = 0x20000
	// Bit RESERVED.
	USB1_ENDPTCTRL_RESERVED = 0x20000
	// Position of TXT field.
	USB1_ENDPTCTRL_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB1_ENDPTCTRL_TXT_Msk = 0xc0000
	// Control
	USB1_ENDPTCTRL_TXT_CONTROL = 0x0
	// Isochronous
	USB1_ENDPTCTRL_TXT_ISOCHRONOUS = 0x1
	// Bulk
	USB1_ENDPTCTRL_TXT_BULK = 0x2
	// Interrupt
	USB1_ENDPTCTRL_TXT_INTERRUPT = 0x3
	// Position of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Msk = 0x100000
	// Bit RESERVED.
	USB1_ENDPTCTRL_RESERVED = 0x100000
	// Position of TXI field.
	USB1_ENDPTCTRL_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB1_ENDPTCTRL_TXI_Msk = 0x200000
	// Bit TXI.
	USB1_ENDPTCTRL_TXI = 0x200000
	// Enabled
	USB1_ENDPTCTRL_TXI_ENABLED = 0x0
	// Disabled
	USB1_ENDPTCTRL_TXI_DISABLED = 0x1
	// Position of TXR field.
	USB1_ENDPTCTRL_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB1_ENDPTCTRL_TXR_Msk = 0x400000
	// Bit TXR.
	USB1_ENDPTCTRL_TXR = 0x400000
	// Position of TXE field.
	USB1_ENDPTCTRL_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB1_ENDPTCTRL_TXE_Msk = 0x800000
	// Bit TXE.
	USB1_ENDPTCTRL_TXE = 0x800000
	// Endpoint disabled.
	USB1_ENDPTCTRL_TXE_ENDPOINT_DISABLED_ = 0x0
	// Endpoint enabled.
	USB1_ENDPTCTRL_TXE_ENDPOINT_ENABLED_ = 0x1
	// Position of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB1_ENDPTCTRL_RESERVED_Msk = 0xff000000
)

// Constants for LCD: LCD controller
const (
	// TIMH: Horizontal Timing Control register
	// Position of RESERVED field.
	LCD_TIMH_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_TIMH_RESERVED_Msk = 0x3
	// Position of PPL field.
	LCD_TIMH_PPL_Pos = 0x2
	// Bit mask of PPL field.
	LCD_TIMH_PPL_Msk = 0xfc
	// Position of HSW field.
	LCD_TIMH_HSW_Pos = 0x8
	// Bit mask of HSW field.
	LCD_TIMH_HSW_Msk = 0xff00
	// Position of HFP field.
	LCD_TIMH_HFP_Pos = 0x10
	// Bit mask of HFP field.
	LCD_TIMH_HFP_Msk = 0xff0000
	// Position of HBP field.
	LCD_TIMH_HBP_Pos = 0x18
	// Bit mask of HBP field.
	LCD_TIMH_HBP_Msk = 0xff000000

	// TIMV: Vertical Timing Control register
	// Position of LPP field.
	LCD_TIMV_LPP_Pos = 0x0
	// Bit mask of LPP field.
	LCD_TIMV_LPP_Msk = 0x3ff
	// Position of VSW field.
	LCD_TIMV_VSW_Pos = 0xa
	// Bit mask of VSW field.
	LCD_TIMV_VSW_Msk = 0xfc00
	// Position of VFP field.
	LCD_TIMV_VFP_Pos = 0x10
	// Bit mask of VFP field.
	LCD_TIMV_VFP_Msk = 0xff0000
	// Position of VBP field.
	LCD_TIMV_VBP_Pos = 0x18
	// Bit mask of VBP field.
	LCD_TIMV_VBP_Msk = 0xff000000

	// POL: Clock and Signal Polarity Control register
	// Position of PCD_LO field.
	LCD_POL_PCD_LO_Pos = 0x0
	// Bit mask of PCD_LO field.
	LCD_POL_PCD_LO_Msk = 0x1f
	// Position of CLKSEL field.
	LCD_POL_CLKSEL_Pos = 0x5
	// Bit mask of CLKSEL field.
	LCD_POL_CLKSEL_Msk = 0x20
	// Bit CLKSEL.
	LCD_POL_CLKSEL = 0x20
	// Position of ACB field.
	LCD_POL_ACB_Pos = 0x6
	// Bit mask of ACB field.
	LCD_POL_ACB_Msk = 0x7c0
	// Position of IVS field.
	LCD_POL_IVS_Pos = 0xb
	// Bit mask of IVS field.
	LCD_POL_IVS_Msk = 0x800
	// Bit IVS.
	LCD_POL_IVS = 0x800
	// Position of IHS field.
	LCD_POL_IHS_Pos = 0xc
	// Bit mask of IHS field.
	LCD_POL_IHS_Msk = 0x1000
	// Bit IHS.
	LCD_POL_IHS = 0x1000
	// Position of IPC field.
	LCD_POL_IPC_Pos = 0xd
	// Bit mask of IPC field.
	LCD_POL_IPC_Msk = 0x2000
	// Bit IPC.
	LCD_POL_IPC = 0x2000
	// Position of IOE field.
	LCD_POL_IOE_Pos = 0xe
	// Bit mask of IOE field.
	LCD_POL_IOE_Msk = 0x4000
	// Bit IOE.
	LCD_POL_IOE = 0x4000
	// Position of RESERVED field.
	LCD_POL_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	LCD_POL_RESERVED_Msk = 0x8000
	// Bit RESERVED.
	LCD_POL_RESERVED = 0x8000
	// Position of CPL field.
	LCD_POL_CPL_Pos = 0x10
	// Bit mask of CPL field.
	LCD_POL_CPL_Msk = 0x3ff0000
	// Position of BCD field.
	LCD_POL_BCD_Pos = 0x1a
	// Bit mask of BCD field.
	LCD_POL_BCD_Msk = 0x4000000
	// Bit BCD.
	LCD_POL_BCD = 0x4000000
	// Position of PCD_HI field.
	LCD_POL_PCD_HI_Pos = 0x1b
	// Bit mask of PCD_HI field.
	LCD_POL_PCD_HI_Msk = 0xf8000000

	// LE: Line End Control register
	// Position of LED field.
	LCD_LE_LED_Pos = 0x0
	// Bit mask of LED field.
	LCD_LE_LED_Msk = 0x7f
	// Position of RESERVED field.
	LCD_LE_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	LCD_LE_RESERVED_Msk = 0xff80
	// Position of LEE field.
	LCD_LE_LEE_Pos = 0x10
	// Bit mask of LEE field.
	LCD_LE_LEE_Msk = 0x10000
	// Bit LEE.
	LCD_LE_LEE = 0x10000
	// Position of RESERVED field.
	LCD_LE_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	LCD_LE_RESERVED_Msk = 0xfffe0000

	// UPBASE: Upper Panel Frame Base Address register
	// Position of RESERVED field.
	LCD_UPBASE_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_UPBASE_RESERVED_Msk = 0x7
	// Position of LCDUPBASE field.
	LCD_UPBASE_LCDUPBASE_Pos = 0x3
	// Bit mask of LCDUPBASE field.
	LCD_UPBASE_LCDUPBASE_Msk = 0xfffffff8

	// LPBASE: Lower Panel Frame Base Address register
	// Position of RESERVED field.
	LCD_LPBASE_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_LPBASE_RESERVED_Msk = 0x7
	// Position of LCDLPBASE field.
	LCD_LPBASE_LCDLPBASE_Pos = 0x3
	// Bit mask of LCDLPBASE field.
	LCD_LPBASE_LCDLPBASE_Msk = 0xfffffff8

	// CTRL: LCD Control register
	// Position of LCDEN field.
	LCD_CTRL_LCDEN_Pos = 0x0
	// Bit mask of LCDEN field.
	LCD_CTRL_LCDEN_Msk = 0x1
	// Bit LCDEN.
	LCD_CTRL_LCDEN = 0x1
	// Position of LCDBPP field.
	LCD_CTRL_LCDBPP_Pos = 0x1
	// Bit mask of LCDBPP field.
	LCD_CTRL_LCDBPP_Msk = 0xe
	// Position of LCDBW field.
	LCD_CTRL_LCDBW_Pos = 0x4
	// Bit mask of LCDBW field.
	LCD_CTRL_LCDBW_Msk = 0x10
	// Bit LCDBW.
	LCD_CTRL_LCDBW = 0x10
	// Position of LCDTFT field.
	LCD_CTRL_LCDTFT_Pos = 0x5
	// Bit mask of LCDTFT field.
	LCD_CTRL_LCDTFT_Msk = 0x20
	// Bit LCDTFT.
	LCD_CTRL_LCDTFT = 0x20
	// Position of LCDMONO8 field.
	LCD_CTRL_LCDMONO8_Pos = 0x6
	// Bit mask of LCDMONO8 field.
	LCD_CTRL_LCDMONO8_Msk = 0x40
	// Bit LCDMONO8.
	LCD_CTRL_LCDMONO8 = 0x40
	// Position of LCDDUAL field.
	LCD_CTRL_LCDDUAL_Pos = 0x7
	// Bit mask of LCDDUAL field.
	LCD_CTRL_LCDDUAL_Msk = 0x80
	// Bit LCDDUAL.
	LCD_CTRL_LCDDUAL = 0x80
	// Position of BGR field.
	LCD_CTRL_BGR_Pos = 0x8
	// Bit mask of BGR field.
	LCD_CTRL_BGR_Msk = 0x100
	// Bit BGR.
	LCD_CTRL_BGR = 0x100
	// Position of BEBO field.
	LCD_CTRL_BEBO_Pos = 0x9
	// Bit mask of BEBO field.
	LCD_CTRL_BEBO_Msk = 0x200
	// Bit BEBO.
	LCD_CTRL_BEBO = 0x200
	// Position of BEPO field.
	LCD_CTRL_BEPO_Pos = 0xa
	// Bit mask of BEPO field.
	LCD_CTRL_BEPO_Msk = 0x400
	// Bit BEPO.
	LCD_CTRL_BEPO = 0x400
	// Position of LCDPWR field.
	LCD_CTRL_LCDPWR_Pos = 0xb
	// Bit mask of LCDPWR field.
	LCD_CTRL_LCDPWR_Msk = 0x800
	// Bit LCDPWR.
	LCD_CTRL_LCDPWR = 0x800
	// Position of LCDVCOMP field.
	LCD_CTRL_LCDVCOMP_Pos = 0xc
	// Bit mask of LCDVCOMP field.
	LCD_CTRL_LCDVCOMP_Msk = 0x3000
	// Position of RESERVED field.
	LCD_CTRL_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	LCD_CTRL_RESERVED_Msk = 0xc000
	// Position of WATERMARK field.
	LCD_CTRL_WATERMARK_Pos = 0x10
	// Bit mask of WATERMARK field.
	LCD_CTRL_WATERMARK_Msk = 0x10000
	// Bit WATERMARK.
	LCD_CTRL_WATERMARK = 0x10000
	// Position of RESERVED field.
	LCD_CTRL_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	LCD_CTRL_RESERVED_Msk = 0xfffe0000

	// INTMSK: Interrupt Mask register
	// Position of RESERVED field.
	LCD_INTMSK_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_INTMSK_RESERVED_Msk = 0x1
	// Bit RESERVED.
	LCD_INTMSK_RESERVED = 0x1
	// Position of FUFIM field.
	LCD_INTMSK_FUFIM_Pos = 0x1
	// Bit mask of FUFIM field.
	LCD_INTMSK_FUFIM_Msk = 0x2
	// Bit FUFIM.
	LCD_INTMSK_FUFIM = 0x2
	// Position of LNBUIM field.
	LCD_INTMSK_LNBUIM_Pos = 0x2
	// Bit mask of LNBUIM field.
	LCD_INTMSK_LNBUIM_Msk = 0x4
	// Bit LNBUIM.
	LCD_INTMSK_LNBUIM = 0x4
	// Position of VCOMPIM field.
	LCD_INTMSK_VCOMPIM_Pos = 0x3
	// Bit mask of VCOMPIM field.
	LCD_INTMSK_VCOMPIM_Msk = 0x8
	// Bit VCOMPIM.
	LCD_INTMSK_VCOMPIM = 0x8
	// Position of BERIM field.
	LCD_INTMSK_BERIM_Pos = 0x4
	// Bit mask of BERIM field.
	LCD_INTMSK_BERIM_Msk = 0x10
	// Bit BERIM.
	LCD_INTMSK_BERIM = 0x10
	// Position of RESERVED field.
	LCD_INTMSK_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	LCD_INTMSK_RESERVED_Msk = 0xffffffe0

	// INTRAW: Raw Interrupt Status register
	// Position of RESERVED field.
	LCD_INTRAW_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_INTRAW_RESERVED_Msk = 0x1
	// Bit RESERVED.
	LCD_INTRAW_RESERVED = 0x1
	// Position of FUFRIS field.
	LCD_INTRAW_FUFRIS_Pos = 0x1
	// Bit mask of FUFRIS field.
	LCD_INTRAW_FUFRIS_Msk = 0x2
	// Bit FUFRIS.
	LCD_INTRAW_FUFRIS = 0x2
	// Position of LNBURIS field.
	LCD_INTRAW_LNBURIS_Pos = 0x2
	// Bit mask of LNBURIS field.
	LCD_INTRAW_LNBURIS_Msk = 0x4
	// Bit LNBURIS.
	LCD_INTRAW_LNBURIS = 0x4
	// Position of VCOMPRIS field.
	LCD_INTRAW_VCOMPRIS_Pos = 0x3
	// Bit mask of VCOMPRIS field.
	LCD_INTRAW_VCOMPRIS_Msk = 0x8
	// Bit VCOMPRIS.
	LCD_INTRAW_VCOMPRIS = 0x8
	// Position of BERRAW field.
	LCD_INTRAW_BERRAW_Pos = 0x4
	// Bit mask of BERRAW field.
	LCD_INTRAW_BERRAW_Msk = 0x10
	// Bit BERRAW.
	LCD_INTRAW_BERRAW = 0x10
	// Position of RESERVED field.
	LCD_INTRAW_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	LCD_INTRAW_RESERVED_Msk = 0xffffffe0

	// INTSTAT: Masked Interrupt Status register
	// Position of RESERVED field.
	LCD_INTSTAT_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_INTSTAT_RESERVED_Msk = 0x1
	// Bit RESERVED.
	LCD_INTSTAT_RESERVED = 0x1
	// Position of FUFMIS field.
	LCD_INTSTAT_FUFMIS_Pos = 0x1
	// Bit mask of FUFMIS field.
	LCD_INTSTAT_FUFMIS_Msk = 0x2
	// Bit FUFMIS.
	LCD_INTSTAT_FUFMIS = 0x2
	// Position of LNBUMIS field.
	LCD_INTSTAT_LNBUMIS_Pos = 0x2
	// Bit mask of LNBUMIS field.
	LCD_INTSTAT_LNBUMIS_Msk = 0x4
	// Bit LNBUMIS.
	LCD_INTSTAT_LNBUMIS = 0x4
	// Position of VCOMPMIS field.
	LCD_INTSTAT_VCOMPMIS_Pos = 0x3
	// Bit mask of VCOMPMIS field.
	LCD_INTSTAT_VCOMPMIS_Msk = 0x8
	// Bit VCOMPMIS.
	LCD_INTSTAT_VCOMPMIS = 0x8
	// Position of BERMIS field.
	LCD_INTSTAT_BERMIS_Pos = 0x4
	// Bit mask of BERMIS field.
	LCD_INTSTAT_BERMIS_Msk = 0x10
	// Bit BERMIS.
	LCD_INTSTAT_BERMIS = 0x10
	// Position of RESERVED field.
	LCD_INTSTAT_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	LCD_INTSTAT_RESERVED_Msk = 0xffffffe0

	// INTCLR: Interrupt Clear register
	// Position of RESERVED field.
	LCD_INTCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_INTCLR_RESERVED_Msk = 0x1
	// Bit RESERVED.
	LCD_INTCLR_RESERVED = 0x1
	// Position of FUFIC field.
	LCD_INTCLR_FUFIC_Pos = 0x1
	// Bit mask of FUFIC field.
	LCD_INTCLR_FUFIC_Msk = 0x2
	// Bit FUFIC.
	LCD_INTCLR_FUFIC = 0x2
	// Position of LNBUIC field.
	LCD_INTCLR_LNBUIC_Pos = 0x2
	// Bit mask of LNBUIC field.
	LCD_INTCLR_LNBUIC_Msk = 0x4
	// Bit LNBUIC.
	LCD_INTCLR_LNBUIC = 0x4
	// Position of VCOMPIC field.
	LCD_INTCLR_VCOMPIC_Pos = 0x3
	// Bit mask of VCOMPIC field.
	LCD_INTCLR_VCOMPIC_Msk = 0x8
	// Bit VCOMPIC.
	LCD_INTCLR_VCOMPIC = 0x8
	// Position of BERIC field.
	LCD_INTCLR_BERIC_Pos = 0x4
	// Bit mask of BERIC field.
	LCD_INTCLR_BERIC_Msk = 0x10
	// Bit BERIC.
	LCD_INTCLR_BERIC = 0x10
	// Position of RESERVED field.
	LCD_INTCLR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	LCD_INTCLR_RESERVED_Msk = 0xffffffe0

	// UPCURR: Upper Panel Current Address Value register
	// Position of LCDUPCURR field.
	LCD_UPCURR_LCDUPCURR_Pos = 0x0
	// Bit mask of LCDUPCURR field.
	LCD_UPCURR_LCDUPCURR_Msk = 0xffffffff

	// LPCURR: Lower Panel Current Address Value register
	// Position of LCDLPCURR field.
	LCD_LPCURR_LCDLPCURR_Pos = 0x0
	// Bit mask of LCDLPCURR field.
	LCD_LPCURR_LCDLPCURR_Msk = 0xffffffff

	// PAL: 256x16-bit Color Palette registers
	// Position of R04_0 field.
	LCD_PAL_R04_0_Pos = 0x0
	// Bit mask of R04_0 field.
	LCD_PAL_R04_0_Msk = 0x1f
	// Position of G04_0 field.
	LCD_PAL_G04_0_Pos = 0x5
	// Bit mask of G04_0 field.
	LCD_PAL_G04_0_Msk = 0x3e0
	// Position of B04_0 field.
	LCD_PAL_B04_0_Pos = 0xa
	// Bit mask of B04_0 field.
	LCD_PAL_B04_0_Msk = 0x7c00
	// Position of I0 field.
	LCD_PAL_I0_Pos = 0xf
	// Bit mask of I0 field.
	LCD_PAL_I0_Msk = 0x8000
	// Bit I0.
	LCD_PAL_I0 = 0x8000
	// Position of R14_0 field.
	LCD_PAL_R14_0_Pos = 0x10
	// Bit mask of R14_0 field.
	LCD_PAL_R14_0_Msk = 0x1f0000
	// Position of G14_0 field.
	LCD_PAL_G14_0_Pos = 0x15
	// Bit mask of G14_0 field.
	LCD_PAL_G14_0_Msk = 0x3e00000
	// Position of B14_0 field.
	LCD_PAL_B14_0_Pos = 0x1a
	// Bit mask of B14_0 field.
	LCD_PAL_B14_0_Msk = 0x7c000000
	// Position of I1 field.
	LCD_PAL_I1_Pos = 0x1f
	// Bit mask of I1 field.
	LCD_PAL_I1_Msk = 0x80000000
	// Bit I1.
	LCD_PAL_I1 = 0x80000000

	// CRSR_IMG: Cursor Image registers
	// Position of CRSR_IMG field.
	LCD_CRSR_IMG_CRSR_IMG_Pos = 0x0
	// Bit mask of CRSR_IMG field.
	LCD_CRSR_IMG_CRSR_IMG_Msk = 0xffffffff

	// CRSR_CTRL: Cursor Control register
	// Position of CrsrOn field.
	LCD_CRSR_CTRL_CrsrOn_Pos = 0x0
	// Bit mask of CrsrOn field.
	LCD_CRSR_CTRL_CrsrOn_Msk = 0x1
	// Bit CrsrOn.
	LCD_CRSR_CTRL_CrsrOn = 0x1
	// Position of RESERVED field.
	LCD_CRSR_CTRL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_CTRL_RESERVED_Msk = 0xe
	// Position of CRSRNUM1_0 field.
	LCD_CRSR_CTRL_CRSRNUM1_0_Pos = 0x4
	// Bit mask of CRSRNUM1_0 field.
	LCD_CRSR_CTRL_CRSRNUM1_0_Msk = 0x30
	// Position of RESERVED field.
	LCD_CRSR_CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	LCD_CRSR_CTRL_RESERVED_Msk = 0xffffffc0

	// CRSR_CFG: Cursor Configuration register
	// Position of CrsrSize field.
	LCD_CRSR_CFG_CrsrSize_Pos = 0x0
	// Bit mask of CrsrSize field.
	LCD_CRSR_CFG_CrsrSize_Msk = 0x1
	// Bit CrsrSize.
	LCD_CRSR_CFG_CrsrSize = 0x1
	// Position of FRAMESYNC field.
	LCD_CRSR_CFG_FRAMESYNC_Pos = 0x1
	// Bit mask of FRAMESYNC field.
	LCD_CRSR_CFG_FRAMESYNC_Msk = 0x2
	// Bit FRAMESYNC.
	LCD_CRSR_CFG_FRAMESYNC = 0x2
	// Position of RESERVED field.
	LCD_CRSR_CFG_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	LCD_CRSR_CFG_RESERVED_Msk = 0xfffffffc

	// CRSR_PAL0: Cursor Palette register 0
	// Position of RED field.
	LCD_CRSR_PAL0_RED_Pos = 0x0
	// Bit mask of RED field.
	LCD_CRSR_PAL0_RED_Msk = 0xff
	// Position of GREEN field.
	LCD_CRSR_PAL0_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	LCD_CRSR_PAL0_GREEN_Msk = 0xff00
	// Position of BLUE field.
	LCD_CRSR_PAL0_BLUE_Pos = 0x10
	// Bit mask of BLUE field.
	LCD_CRSR_PAL0_BLUE_Msk = 0xff0000
	// Position of RESERVED field.
	LCD_CRSR_PAL0_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	LCD_CRSR_PAL0_RESERVED_Msk = 0xff000000

	// CRSR_PAL1: Cursor Palette register 1
	// Position of RED field.
	LCD_CRSR_PAL1_RED_Pos = 0x0
	// Bit mask of RED field.
	LCD_CRSR_PAL1_RED_Msk = 0xff
	// Position of GREEN field.
	LCD_CRSR_PAL1_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	LCD_CRSR_PAL1_GREEN_Msk = 0xff00
	// Position of BLUE field.
	LCD_CRSR_PAL1_BLUE_Pos = 0x10
	// Bit mask of BLUE field.
	LCD_CRSR_PAL1_BLUE_Msk = 0xff0000
	// Position of RESERVED field.
	LCD_CRSR_PAL1_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	LCD_CRSR_PAL1_RESERVED_Msk = 0xff000000

	// CRSR_XY: Cursor XY Position register
	// Position of CRSRX field.
	LCD_CRSR_XY_CRSRX_Pos = 0x0
	// Bit mask of CRSRX field.
	LCD_CRSR_XY_CRSRX_Msk = 0x3ff
	// Position of RESERVED field.
	LCD_CRSR_XY_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	LCD_CRSR_XY_RESERVED_Msk = 0xfc00
	// Position of CRSRY field.
	LCD_CRSR_XY_CRSRY_Pos = 0x10
	// Bit mask of CRSRY field.
	LCD_CRSR_XY_CRSRY_Msk = 0x3ff0000
	// Position of RESERVED field.
	LCD_CRSR_XY_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	LCD_CRSR_XY_RESERVED_Msk = 0xfc000000

	// CRSR_CLIP: Cursor Clip Position register
	// Position of CRSRCLIPX field.
	LCD_CRSR_CLIP_CRSRCLIPX_Pos = 0x0
	// Bit mask of CRSRCLIPX field.
	LCD_CRSR_CLIP_CRSRCLIPX_Msk = 0x3f
	// Position of RESERVED field.
	LCD_CRSR_CLIP_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	LCD_CRSR_CLIP_RESERVED_Msk = 0xc0
	// Position of CRSRCLIPY field.
	LCD_CRSR_CLIP_CRSRCLIPY_Pos = 0x8
	// Bit mask of CRSRCLIPY field.
	LCD_CRSR_CLIP_CRSRCLIPY_Msk = 0x3f00
	// Position of RESERVED field.
	LCD_CRSR_CLIP_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	LCD_CRSR_CLIP_RESERVED_Msk = 0xffffc000

	// CRSR_INTMSK: Cursor Interrupt Mask register
	// Position of CRSRIM field.
	LCD_CRSR_INTMSK_CRSRIM_Pos = 0x0
	// Bit mask of CRSRIM field.
	LCD_CRSR_INTMSK_CRSRIM_Msk = 0x1
	// Bit CRSRIM.
	LCD_CRSR_INTMSK_CRSRIM = 0x1
	// Position of RESERVED field.
	LCD_CRSR_INTMSK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_INTMSK_RESERVED_Msk = 0xfffffffe

	// CRSR_INTCLR: Cursor Interrupt Clear register
	// Position of CRSRIC field.
	LCD_CRSR_INTCLR_CRSRIC_Pos = 0x0
	// Bit mask of CRSRIC field.
	LCD_CRSR_INTCLR_CRSRIC_Msk = 0x1
	// Bit CRSRIC.
	LCD_CRSR_INTCLR_CRSRIC = 0x1
	// Position of RESERVED field.
	LCD_CRSR_INTCLR_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_INTCLR_RESERVED_Msk = 0xfffffffe

	// CRSR_INTRAW: Cursor Raw Interrupt Status register
	// Position of CRSRRIS field.
	LCD_CRSR_INTRAW_CRSRRIS_Pos = 0x0
	// Bit mask of CRSRRIS field.
	LCD_CRSR_INTRAW_CRSRRIS_Msk = 0x1
	// Bit CRSRRIS.
	LCD_CRSR_INTRAW_CRSRRIS = 0x1
	// Position of RESERVED field.
	LCD_CRSR_INTRAW_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_INTRAW_RESERVED_Msk = 0xfffffffe

	// CRSR_INTSTAT: Cursor Masked Interrupt Status register
	// Position of CRSRMIS field.
	LCD_CRSR_INTSTAT_CRSRMIS_Pos = 0x0
	// Bit mask of CRSRMIS field.
	LCD_CRSR_INTSTAT_CRSRMIS_Msk = 0x1
	// Bit CRSRMIS.
	LCD_CRSR_INTSTAT_CRSRMIS = 0x1
	// Position of RESERVED field.
	LCD_CRSR_INTSTAT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_INTSTAT_RESERVED_Msk = 0xfffffffe
)

// Constants for EEPROM: EEPROM
const (
	// CMD: EEPROM command register
	// Position of CMD field.
	EEPROM_CMD_CMD_Pos = 0x0
	// Bit mask of CMD field.
	EEPROM_CMD_CMD_Msk = 0x7
	// Position of RESERVED field.
	EEPROM_CMD_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EEPROM_CMD_RESERVED_Msk = 0xfffffff8

	// RWSTATE: EEPROM read wait state register
	// Position of RPHASE2 field.
	EEPROM_RWSTATE_RPHASE2_Pos = 0x0
	// Bit mask of RPHASE2 field.
	EEPROM_RWSTATE_RPHASE2_Msk = 0xff
	// Position of RPHASE1 field.
	EEPROM_RWSTATE_RPHASE1_Pos = 0x8
	// Bit mask of RPHASE1 field.
	EEPROM_RWSTATE_RPHASE1_Msk = 0xff00
	// Position of RESERVED field.
	EEPROM_RWSTATE_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	EEPROM_RWSTATE_RESERVED_Msk = 0xffff0000

	// AUTOPROG: EEPROM auto programming register
	// Position of AUTOPROG field.
	EEPROM_AUTOPROG_AUTOPROG_Pos = 0x0
	// Bit mask of AUTOPROG field.
	EEPROM_AUTOPROG_AUTOPROG_Msk = 0x3
	// Position of RESERVED field.
	EEPROM_AUTOPROG_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	EEPROM_AUTOPROG_RESERVED_Msk = 0xfffffffc

	// WSTATE: EEPROM wait state register
	// Position of PHASE3 field.
	EEPROM_WSTATE_PHASE3_Pos = 0x0
	// Bit mask of PHASE3 field.
	EEPROM_WSTATE_PHASE3_Msk = 0xff
	// Position of PHASE2 field.
	EEPROM_WSTATE_PHASE2_Pos = 0x8
	// Bit mask of PHASE2 field.
	EEPROM_WSTATE_PHASE2_Msk = 0xff00
	// Position of PHASE1 field.
	EEPROM_WSTATE_PHASE1_Pos = 0x10
	// Bit mask of PHASE1 field.
	EEPROM_WSTATE_PHASE1_Msk = 0xff0000
	// Position of RESERVED field.
	EEPROM_WSTATE_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	EEPROM_WSTATE_RESERVED_Msk = 0x7f000000
	// Position of LCK_PARWEP field.
	EEPROM_WSTATE_LCK_PARWEP_Pos = 0x1f
	// Bit mask of LCK_PARWEP field.
	EEPROM_WSTATE_LCK_PARWEP_Msk = 0x80000000
	// Bit LCK_PARWEP.
	EEPROM_WSTATE_LCK_PARWEP = 0x80000000

	// CLKDIV: EEPROM clock divider register
	// Position of CLKDIV field.
	EEPROM_CLKDIV_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	EEPROM_CLKDIV_CLKDIV_Msk = 0xffff
	// Position of RESERVED field.
	EEPROM_CLKDIV_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	EEPROM_CLKDIV_RESERVED_Msk = 0xffff0000

	// PWRDWN: EEPROM power-down register
	// Position of PWRDWN field.
	EEPROM_PWRDWN_PWRDWN_Pos = 0x0
	// Bit mask of PWRDWN field.
	EEPROM_PWRDWN_PWRDWN_Msk = 0x1
	// Bit PWRDWN.
	EEPROM_PWRDWN_PWRDWN = 0x1
	// Position of RESERVED field.
	EEPROM_PWRDWN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	EEPROM_PWRDWN_RESERVED_Msk = 0xfffffffe

	// INTENCLR: EEPROM interrupt enable clear
	// Position of RESERVED field.
	EEPROM_INTENCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	EEPROM_INTENCLR_RESERVED_Msk = 0x3
	// Position of PROG_CLR_EN field.
	EEPROM_INTENCLR_PROG_CLR_EN_Pos = 0x2
	// Bit mask of PROG_CLR_EN field.
	EEPROM_INTENCLR_PROG_CLR_EN_Msk = 0x4
	// Bit PROG_CLR_EN.
	EEPROM_INTENCLR_PROG_CLR_EN = 0x4
	// Position of RESERVED field.
	EEPROM_INTENCLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EEPROM_INTENCLR_RESERVED_Msk = 0xfffffff8

	// INTENSET: EEPROM interrupt enable set
	// Position of RESERVED field.
	EEPROM_INTENSET_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	EEPROM_INTENSET_RESERVED_Msk = 0x3
	// Position of PROG_SET_EN field.
	EEPROM_INTENSET_PROG_SET_EN_Pos = 0x2
	// Bit mask of PROG_SET_EN field.
	EEPROM_INTENSET_PROG_SET_EN_Msk = 0x4
	// Bit PROG_SET_EN.
	EEPROM_INTENSET_PROG_SET_EN = 0x4
	// Position of RESERVED field.
	EEPROM_INTENSET_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EEPROM_INTENSET_RESERVED_Msk = 0xfffffff8

	// INTSTAT: EEPROM interrupt status
	// Position of RESERVED field.
	EEPROM_INTSTAT_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	EEPROM_INTSTAT_RESERVED_Msk = 0x3
	// Position of END_OF_PROG field.
	EEPROM_INTSTAT_END_OF_PROG_Pos = 0x2
	// Bit mask of END_OF_PROG field.
	EEPROM_INTSTAT_END_OF_PROG_Msk = 0x4
	// Bit END_OF_PROG.
	EEPROM_INTSTAT_END_OF_PROG = 0x4
	// Position of RESERVED field.
	EEPROM_INTSTAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EEPROM_INTSTAT_RESERVED_Msk = 0xfffffff8

	// INTEN: EEPROM interrupt enable
	// Position of RESERVED field.
	EEPROM_INTEN_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	EEPROM_INTEN_RESERVED_Msk = 0x3
	// Position of EE_PROG_DONE field.
	EEPROM_INTEN_EE_PROG_DONE_Pos = 0x2
	// Bit mask of EE_PROG_DONE field.
	EEPROM_INTEN_EE_PROG_DONE_Msk = 0x4
	// Bit EE_PROG_DONE.
	EEPROM_INTEN_EE_PROG_DONE = 0x4
	// Position of RESERVED field.
	EEPROM_INTEN_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EEPROM_INTEN_RESERVED_Msk = 0xfffffff8

	// INTSTATCLR: EEPROM interrupt status clear
	// Position of RESERVED field.
	EEPROM_INTSTATCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	EEPROM_INTSTATCLR_RESERVED_Msk = 0x3
	// Position of PROG_CLR_ST field.
	EEPROM_INTSTATCLR_PROG_CLR_ST_Pos = 0x2
	// Bit mask of PROG_CLR_ST field.
	EEPROM_INTSTATCLR_PROG_CLR_ST_Msk = 0x4
	// Bit PROG_CLR_ST.
	EEPROM_INTSTATCLR_PROG_CLR_ST = 0x4
	// Position of RESERVED field.
	EEPROM_INTSTATCLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EEPROM_INTSTATCLR_RESERVED_Msk = 0xfffffff8

	// INTSTATSET: EEPROM interrupt status set
	// Position of RESERVED field.
	EEPROM_INTSTATSET_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	EEPROM_INTSTATSET_RESERVED_Msk = 0x3
	// Position of PROG_SET_ST field.
	EEPROM_INTSTATSET_PROG_SET_ST_Pos = 0x2
	// Bit mask of PROG_SET_ST field.
	EEPROM_INTSTATSET_PROG_SET_ST_Msk = 0x4
	// Bit PROG_SET_ST.
	EEPROM_INTSTATSET_PROG_SET_ST = 0x4
	// Position of RESERVED field.
	EEPROM_INTSTATSET_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EEPROM_INTSTATSET_RESERVED_Msk = 0xfffffff8
)

// Constants for ETHERNET: Ethernet
const (
	// MAC_CONFIG: MAC configuration register
	// Position of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Msk = 0x3
	// Position of RE field.
	ETHERNET_MAC_CONFIG_RE_Pos = 0x2
	// Bit mask of RE field.
	ETHERNET_MAC_CONFIG_RE_Msk = 0x4
	// Bit RE.
	ETHERNET_MAC_CONFIG_RE = 0x4
	// Position of TE field.
	ETHERNET_MAC_CONFIG_TE_Pos = 0x3
	// Bit mask of TE field.
	ETHERNET_MAC_CONFIG_TE_Msk = 0x8
	// Bit TE.
	ETHERNET_MAC_CONFIG_TE = 0x8
	// Position of DF field.
	ETHERNET_MAC_CONFIG_DF_Pos = 0x4
	// Bit mask of DF field.
	ETHERNET_MAC_CONFIG_DF_Msk = 0x10
	// Bit DF.
	ETHERNET_MAC_CONFIG_DF = 0x10
	// Position of BL field.
	ETHERNET_MAC_CONFIG_BL_Pos = 0x5
	// Bit mask of BL field.
	ETHERNET_MAC_CONFIG_BL_Msk = 0x60
	// Position of ACS field.
	ETHERNET_MAC_CONFIG_ACS_Pos = 0x7
	// Bit mask of ACS field.
	ETHERNET_MAC_CONFIG_ACS_Msk = 0x80
	// Bit ACS.
	ETHERNET_MAC_CONFIG_ACS = 0x80
	// Position of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Msk = 0x100
	// Bit RESERVED.
	ETHERNET_MAC_CONFIG_RESERVED = 0x100
	// Position of DR field.
	ETHERNET_MAC_CONFIG_DR_Pos = 0x9
	// Bit mask of DR field.
	ETHERNET_MAC_CONFIG_DR_Msk = 0x200
	// Bit DR.
	ETHERNET_MAC_CONFIG_DR = 0x200
	// Position of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Msk = 0x400
	// Bit RESERVED.
	ETHERNET_MAC_CONFIG_RESERVED = 0x400
	// Position of DM field.
	ETHERNET_MAC_CONFIG_DM_Pos = 0xb
	// Bit mask of DM field.
	ETHERNET_MAC_CONFIG_DM_Msk = 0x800
	// Bit DM.
	ETHERNET_MAC_CONFIG_DM = 0x800
	// Position of LM field.
	ETHERNET_MAC_CONFIG_LM_Pos = 0xc
	// Bit mask of LM field.
	ETHERNET_MAC_CONFIG_LM_Msk = 0x1000
	// Bit LM.
	ETHERNET_MAC_CONFIG_LM = 0x1000
	// Position of DO field.
	ETHERNET_MAC_CONFIG_DO_Pos = 0xd
	// Bit mask of DO field.
	ETHERNET_MAC_CONFIG_DO_Msk = 0x2000
	// Bit DO.
	ETHERNET_MAC_CONFIG_DO = 0x2000
	// Position of FES field.
	ETHERNET_MAC_CONFIG_FES_Pos = 0xe
	// Bit mask of FES field.
	ETHERNET_MAC_CONFIG_FES_Msk = 0x4000
	// Bit FES.
	ETHERNET_MAC_CONFIG_FES = 0x4000
	// Position of PS field.
	ETHERNET_MAC_CONFIG_PS_Pos = 0xf
	// Bit mask of PS field.
	ETHERNET_MAC_CONFIG_PS_Msk = 0x8000
	// Bit PS.
	ETHERNET_MAC_CONFIG_PS = 0x8000
	// Position of DCRS field.
	ETHERNET_MAC_CONFIG_DCRS_Pos = 0x10
	// Bit mask of DCRS field.
	ETHERNET_MAC_CONFIG_DCRS_Msk = 0x10000
	// Bit DCRS.
	ETHERNET_MAC_CONFIG_DCRS = 0x10000
	// Position of IFG field.
	ETHERNET_MAC_CONFIG_IFG_Pos = 0x11
	// Bit mask of IFG field.
	ETHERNET_MAC_CONFIG_IFG_Msk = 0xe0000
	// Position of JE field.
	ETHERNET_MAC_CONFIG_JE_Pos = 0x14
	// Bit mask of JE field.
	ETHERNET_MAC_CONFIG_JE_Msk = 0x100000
	// Bit JE.
	ETHERNET_MAC_CONFIG_JE = 0x100000
	// Position of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Msk = 0x200000
	// Bit RESERVED.
	ETHERNET_MAC_CONFIG_RESERVED = 0x200000
	// Position of JD field.
	ETHERNET_MAC_CONFIG_JD_Pos = 0x16
	// Bit mask of JD field.
	ETHERNET_MAC_CONFIG_JD_Msk = 0x400000
	// Bit JD.
	ETHERNET_MAC_CONFIG_JD = 0x400000
	// Position of WD field.
	ETHERNET_MAC_CONFIG_WD_Pos = 0x17
	// Bit mask of WD field.
	ETHERNET_MAC_CONFIG_WD_Msk = 0x800000
	// Bit WD.
	ETHERNET_MAC_CONFIG_WD = 0x800000
	// Position of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	ETHERNET_MAC_CONFIG_RESERVED_Msk = 0xff000000

	// MAC_FRAME_FILTER: MAC frame filter
	// Position of PR field.
	ETHERNET_MAC_FRAME_FILTER_PR_Pos = 0x0
	// Bit mask of PR field.
	ETHERNET_MAC_FRAME_FILTER_PR_Msk = 0x1
	// Bit PR.
	ETHERNET_MAC_FRAME_FILTER_PR = 0x1
	// Position of HUC field.
	ETHERNET_MAC_FRAME_FILTER_HUC_Pos = 0x1
	// Bit mask of HUC field.
	ETHERNET_MAC_FRAME_FILTER_HUC_Msk = 0x2
	// Bit HUC.
	ETHERNET_MAC_FRAME_FILTER_HUC = 0x2
	// Position of HMC field.
	ETHERNET_MAC_FRAME_FILTER_HMC_Pos = 0x2
	// Bit mask of HMC field.
	ETHERNET_MAC_FRAME_FILTER_HMC_Msk = 0x4
	// Bit HMC.
	ETHERNET_MAC_FRAME_FILTER_HMC = 0x4
	// Position of DAIF field.
	ETHERNET_MAC_FRAME_FILTER_DAIF_Pos = 0x3
	// Bit mask of DAIF field.
	ETHERNET_MAC_FRAME_FILTER_DAIF_Msk = 0x8
	// Bit DAIF.
	ETHERNET_MAC_FRAME_FILTER_DAIF = 0x8
	// Position of PM field.
	ETHERNET_MAC_FRAME_FILTER_PM_Pos = 0x4
	// Bit mask of PM field.
	ETHERNET_MAC_FRAME_FILTER_PM_Msk = 0x10
	// Bit PM.
	ETHERNET_MAC_FRAME_FILTER_PM = 0x10
	// Position of DBF field.
	ETHERNET_MAC_FRAME_FILTER_DBF_Pos = 0x5
	// Bit mask of DBF field.
	ETHERNET_MAC_FRAME_FILTER_DBF_Msk = 0x20
	// Bit DBF.
	ETHERNET_MAC_FRAME_FILTER_DBF = 0x20
	// Position of PCF field.
	ETHERNET_MAC_FRAME_FILTER_PCF_Pos = 0x6
	// Bit mask of PCF field.
	ETHERNET_MAC_FRAME_FILTER_PCF_Msk = 0xc0
	// Position of RESERVED field.
	ETHERNET_MAC_FRAME_FILTER_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_MAC_FRAME_FILTER_RESERVED_Msk = 0x100
	// Bit RESERVED.
	ETHERNET_MAC_FRAME_FILTER_RESERVED = 0x100
	// Position of RESERVED field.
	ETHERNET_MAC_FRAME_FILTER_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	ETHERNET_MAC_FRAME_FILTER_RESERVED_Msk = 0x200
	// Bit RESERVED.
	ETHERNET_MAC_FRAME_FILTER_RESERVED = 0x200
	// Position of HPF field.
	ETHERNET_MAC_FRAME_FILTER_HPF_Pos = 0xa
	// Bit mask of HPF field.
	ETHERNET_MAC_FRAME_FILTER_HPF_Msk = 0x400
	// Bit HPF.
	ETHERNET_MAC_FRAME_FILTER_HPF = 0x400
	// Position of RESERVED field.
	ETHERNET_MAC_FRAME_FILTER_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	ETHERNET_MAC_FRAME_FILTER_RESERVED_Msk = 0x7ffff800
	// Position of RA field.
	ETHERNET_MAC_FRAME_FILTER_RA_Pos = 0x1f
	// Bit mask of RA field.
	ETHERNET_MAC_FRAME_FILTER_RA_Msk = 0x80000000
	// Bit RA.
	ETHERNET_MAC_FRAME_FILTER_RA = 0x80000000

	// MAC_HASHTABLE_HIGH: Hash table high register
	// Position of HTH field.
	ETHERNET_MAC_HASHTABLE_HIGH_HTH_Pos = 0x0
	// Bit mask of HTH field.
	ETHERNET_MAC_HASHTABLE_HIGH_HTH_Msk = 0xffffffff

	// MAC_HASHTABLE_LOW: Hash table low register
	// Position of HTL field.
	ETHERNET_MAC_HASHTABLE_LOW_HTL_Pos = 0x0
	// Bit mask of HTL field.
	ETHERNET_MAC_HASHTABLE_LOW_HTL_Msk = 0xffffffff

	// MAC_MII_ADDR: MII address register
	// Position of GB field.
	ETHERNET_MAC_MII_ADDR_GB_Pos = 0x0
	// Bit mask of GB field.
	ETHERNET_MAC_MII_ADDR_GB_Msk = 0x1
	// Bit GB.
	ETHERNET_MAC_MII_ADDR_GB = 0x1
	// Position of W field.
	ETHERNET_MAC_MII_ADDR_W_Pos = 0x1
	// Bit mask of W field.
	ETHERNET_MAC_MII_ADDR_W_Msk = 0x2
	// Bit W.
	ETHERNET_MAC_MII_ADDR_W = 0x2
	// Position of CR field.
	ETHERNET_MAC_MII_ADDR_CR_Pos = 0x2
	// Bit mask of CR field.
	ETHERNET_MAC_MII_ADDR_CR_Msk = 0x3c
	// Position of GR field.
	ETHERNET_MAC_MII_ADDR_GR_Pos = 0x6
	// Bit mask of GR field.
	ETHERNET_MAC_MII_ADDR_GR_Msk = 0x7c0
	// Position of PA field.
	ETHERNET_MAC_MII_ADDR_PA_Pos = 0xb
	// Bit mask of PA field.
	ETHERNET_MAC_MII_ADDR_PA_Msk = 0xf800
	// Position of RESERVED field.
	ETHERNET_MAC_MII_ADDR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_MAC_MII_ADDR_RESERVED_Msk = 0xffff0000

	// MAC_MII_DATA: MII data register
	// Position of GD field.
	ETHERNET_MAC_MII_DATA_GD_Pos = 0x0
	// Bit mask of GD field.
	ETHERNET_MAC_MII_DATA_GD_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_MAC_MII_DATA_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_MAC_MII_DATA_RESERVED_Msk = 0xffff0000

	// MAC_FLOW_CTRL: Flow control register
	// Position of FCB field.
	ETHERNET_MAC_FLOW_CTRL_FCB_Pos = 0x0
	// Bit mask of FCB field.
	ETHERNET_MAC_FLOW_CTRL_FCB_Msk = 0x1
	// Bit FCB.
	ETHERNET_MAC_FLOW_CTRL_FCB = 0x1
	// Position of TFE field.
	ETHERNET_MAC_FLOW_CTRL_TFE_Pos = 0x1
	// Bit mask of TFE field.
	ETHERNET_MAC_FLOW_CTRL_TFE_Msk = 0x2
	// Bit TFE.
	ETHERNET_MAC_FLOW_CTRL_TFE = 0x2
	// Position of RFE field.
	ETHERNET_MAC_FLOW_CTRL_RFE_Pos = 0x2
	// Bit mask of RFE field.
	ETHERNET_MAC_FLOW_CTRL_RFE_Msk = 0x4
	// Bit RFE.
	ETHERNET_MAC_FLOW_CTRL_RFE = 0x4
	// Position of UP field.
	ETHERNET_MAC_FLOW_CTRL_UP_Pos = 0x3
	// Bit mask of UP field.
	ETHERNET_MAC_FLOW_CTRL_UP_Msk = 0x8
	// Bit UP.
	ETHERNET_MAC_FLOW_CTRL_UP = 0x8
	// Position of PLT field.
	ETHERNET_MAC_FLOW_CTRL_PLT_Pos = 0x4
	// Bit mask of PLT field.
	ETHERNET_MAC_FLOW_CTRL_PLT_Msk = 0x30
	// Position of RESERVED field.
	ETHERNET_MAC_FLOW_CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	ETHERNET_MAC_FLOW_CTRL_RESERVED_Msk = 0x40
	// Bit RESERVED.
	ETHERNET_MAC_FLOW_CTRL_RESERVED = 0x40
	// Position of DZPQ field.
	ETHERNET_MAC_FLOW_CTRL_DZPQ_Pos = 0x7
	// Bit mask of DZPQ field.
	ETHERNET_MAC_FLOW_CTRL_DZPQ_Msk = 0x80
	// Bit DZPQ.
	ETHERNET_MAC_FLOW_CTRL_DZPQ = 0x80
	// Position of RESERVED field.
	ETHERNET_MAC_FLOW_CTRL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_MAC_FLOW_CTRL_RESERVED_Msk = 0xff00
	// Position of PT field.
	ETHERNET_MAC_FLOW_CTRL_PT_Pos = 0x10
	// Bit mask of PT field.
	ETHERNET_MAC_FLOW_CTRL_PT_Msk = 0xffff0000

	// MAC_VLAN_TAG: VLAN tag register
	// Position of VL field.
	ETHERNET_MAC_VLAN_TAG_VL_Pos = 0x0
	// Bit mask of VL field.
	ETHERNET_MAC_VLAN_TAG_VL_Msk = 0xffff
	// Position of ETV field.
	ETHERNET_MAC_VLAN_TAG_ETV_Pos = 0x10
	// Bit mask of ETV field.
	ETHERNET_MAC_VLAN_TAG_ETV_Msk = 0x10000
	// Bit ETV.
	ETHERNET_MAC_VLAN_TAG_ETV = 0x10000
	// Position of RESERVED field.
	ETHERNET_MAC_VLAN_TAG_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	ETHERNET_MAC_VLAN_TAG_RESERVED_Msk = 0xfffe0000

	// MAC_DEBUG: Debug register
	// Position of RXIDLESTAT field.
	ETHERNET_MAC_DEBUG_RXIDLESTAT_Pos = 0x0
	// Bit mask of RXIDLESTAT field.
	ETHERNET_MAC_DEBUG_RXIDLESTAT_Msk = 0x1
	// Bit RXIDLESTAT.
	ETHERNET_MAC_DEBUG_RXIDLESTAT = 0x1
	// Position of FIFOSTAT0 field.
	ETHERNET_MAC_DEBUG_FIFOSTAT0_Pos = 0x1
	// Bit mask of FIFOSTAT0 field.
	ETHERNET_MAC_DEBUG_FIFOSTAT0_Msk = 0x6
	// Position of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Msk = 0x8
	// Bit RESERVED.
	ETHERNET_MAC_DEBUG_RESERVED = 0x8
	// Position of RXFIFOSTAT1 field.
	ETHERNET_MAC_DEBUG_RXFIFOSTAT1_Pos = 0x4
	// Bit mask of RXFIFOSTAT1 field.
	ETHERNET_MAC_DEBUG_RXFIFOSTAT1_Msk = 0x10
	// Bit RXFIFOSTAT1.
	ETHERNET_MAC_DEBUG_RXFIFOSTAT1 = 0x10
	// Position of RXFIFOSTAT field.
	ETHERNET_MAC_DEBUG_RXFIFOSTAT_Pos = 0x5
	// Bit mask of RXFIFOSTAT field.
	ETHERNET_MAC_DEBUG_RXFIFOSTAT_Msk = 0x60
	// Position of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Msk = 0x80
	// Bit RESERVED.
	ETHERNET_MAC_DEBUG_RESERVED = 0x80
	// Position of RXFIFOLVL field.
	ETHERNET_MAC_DEBUG_RXFIFOLVL_Pos = 0x8
	// Bit mask of RXFIFOLVL field.
	ETHERNET_MAC_DEBUG_RXFIFOLVL_Msk = 0x300
	// Position of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Msk = 0xfc00
	// Position of TXIDLESTAT field.
	ETHERNET_MAC_DEBUG_TXIDLESTAT_Pos = 0x10
	// Bit mask of TXIDLESTAT field.
	ETHERNET_MAC_DEBUG_TXIDLESTAT_Msk = 0x10000
	// Bit TXIDLESTAT.
	ETHERNET_MAC_DEBUG_TXIDLESTAT = 0x10000
	// Position of TXSTAT field.
	ETHERNET_MAC_DEBUG_TXSTAT_Pos = 0x11
	// Bit mask of TXSTAT field.
	ETHERNET_MAC_DEBUG_TXSTAT_Msk = 0x60000
	// Position of PAUSE field.
	ETHERNET_MAC_DEBUG_PAUSE_Pos = 0x13
	// Bit mask of PAUSE field.
	ETHERNET_MAC_DEBUG_PAUSE_Msk = 0x80000
	// Bit PAUSE.
	ETHERNET_MAC_DEBUG_PAUSE = 0x80000
	// Position of TXFIFOSTAT field.
	ETHERNET_MAC_DEBUG_TXFIFOSTAT_Pos = 0x14
	// Bit mask of TXFIFOSTAT field.
	ETHERNET_MAC_DEBUG_TXFIFOSTAT_Msk = 0x300000
	// Position of TXFIFOSTAT1 field.
	ETHERNET_MAC_DEBUG_TXFIFOSTAT1_Pos = 0x16
	// Bit mask of TXFIFOSTAT1 field.
	ETHERNET_MAC_DEBUG_TXFIFOSTAT1_Msk = 0x400000
	// Bit TXFIFOSTAT1.
	ETHERNET_MAC_DEBUG_TXFIFOSTAT1 = 0x400000
	// Position of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Pos = 0x17
	// Bit mask of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Msk = 0x800000
	// Bit RESERVED.
	ETHERNET_MAC_DEBUG_RESERVED = 0x800000
	// Position of TXFIFOLVL field.
	ETHERNET_MAC_DEBUG_TXFIFOLVL_Pos = 0x18
	// Bit mask of TXFIFOLVL field.
	ETHERNET_MAC_DEBUG_TXFIFOLVL_Msk = 0x1000000
	// Bit TXFIFOLVL.
	ETHERNET_MAC_DEBUG_TXFIFOLVL = 0x1000000
	// Position of TXFIFOFULL field.
	ETHERNET_MAC_DEBUG_TXFIFOFULL_Pos = 0x19
	// Bit mask of TXFIFOFULL field.
	ETHERNET_MAC_DEBUG_TXFIFOFULL_Msk = 0x2000000
	// Bit TXFIFOFULL.
	ETHERNET_MAC_DEBUG_TXFIFOFULL = 0x2000000
	// Position of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	ETHERNET_MAC_DEBUG_RESERVED_Msk = 0xfc000000

	// MAC_RWAKE_FRFLT: Remote wake-up frame filter
	// Position of ADDR field.
	ETHERNET_MAC_RWAKE_FRFLT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ETHERNET_MAC_RWAKE_FRFLT_ADDR_Msk = 0xffffffff

	// MAC_PMT_CTRL_STAT: PMT control and status
	// Position of PD field.
	ETHERNET_MAC_PMT_CTRL_STAT_PD_Pos = 0x0
	// Bit mask of PD field.
	ETHERNET_MAC_PMT_CTRL_STAT_PD_Msk = 0x1
	// Bit PD.
	ETHERNET_MAC_PMT_CTRL_STAT_PD = 0x1
	// Position of MPE field.
	ETHERNET_MAC_PMT_CTRL_STAT_MPE_Pos = 0x1
	// Bit mask of MPE field.
	ETHERNET_MAC_PMT_CTRL_STAT_MPE_Msk = 0x2
	// Bit MPE.
	ETHERNET_MAC_PMT_CTRL_STAT_MPE = 0x2
	// Position of WFE field.
	ETHERNET_MAC_PMT_CTRL_STAT_WFE_Pos = 0x2
	// Bit mask of WFE field.
	ETHERNET_MAC_PMT_CTRL_STAT_WFE_Msk = 0x4
	// Bit WFE.
	ETHERNET_MAC_PMT_CTRL_STAT_WFE = 0x4
	// Position of RESERVED field.
	ETHERNET_MAC_PMT_CTRL_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	ETHERNET_MAC_PMT_CTRL_STAT_RESERVED_Msk = 0x18
	// Position of MPR field.
	ETHERNET_MAC_PMT_CTRL_STAT_MPR_Pos = 0x5
	// Bit mask of MPR field.
	ETHERNET_MAC_PMT_CTRL_STAT_MPR_Msk = 0x20
	// Bit MPR.
	ETHERNET_MAC_PMT_CTRL_STAT_MPR = 0x20
	// Position of WFR field.
	ETHERNET_MAC_PMT_CTRL_STAT_WFR_Pos = 0x6
	// Bit mask of WFR field.
	ETHERNET_MAC_PMT_CTRL_STAT_WFR_Msk = 0x40
	// Bit WFR.
	ETHERNET_MAC_PMT_CTRL_STAT_WFR = 0x40
	// Position of RESERVED field.
	ETHERNET_MAC_PMT_CTRL_STAT_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	ETHERNET_MAC_PMT_CTRL_STAT_RESERVED_Msk = 0x180
	// Position of GU field.
	ETHERNET_MAC_PMT_CTRL_STAT_GU_Pos = 0x9
	// Bit mask of GU field.
	ETHERNET_MAC_PMT_CTRL_STAT_GU_Msk = 0x200
	// Bit GU.
	ETHERNET_MAC_PMT_CTRL_STAT_GU = 0x200
	// Position of RESERVED field.
	ETHERNET_MAC_PMT_CTRL_STAT_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	ETHERNET_MAC_PMT_CTRL_STAT_RESERVED_Msk = 0x7ffffc00
	// Position of WFFRPR field.
	ETHERNET_MAC_PMT_CTRL_STAT_WFFRPR_Pos = 0x1f
	// Bit mask of WFFRPR field.
	ETHERNET_MAC_PMT_CTRL_STAT_WFFRPR_Msk = 0x80000000
	// Bit WFFRPR.
	ETHERNET_MAC_PMT_CTRL_STAT_WFFRPR = 0x80000000

	// MAC_INTR: Interrupt status register
	// Position of RESERVED field.
	ETHERNET_MAC_INTR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_MAC_INTR_RESERVED_Msk = 0x7
	// Position of PMT field.
	ETHERNET_MAC_INTR_PMT_Pos = 0x3
	// Bit mask of PMT field.
	ETHERNET_MAC_INTR_PMT_Msk = 0x8
	// Bit PMT.
	ETHERNET_MAC_INTR_PMT = 0x8
	// Position of RESERVED field.
	ETHERNET_MAC_INTR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	ETHERNET_MAC_INTR_RESERVED_Msk = 0x1f0
	// Position of TS field.
	ETHERNET_MAC_INTR_TS_Pos = 0x9
	// Bit mask of TS field.
	ETHERNET_MAC_INTR_TS_Msk = 0x200
	// Bit TS.
	ETHERNET_MAC_INTR_TS = 0x200
	// Position of RESERVED field.
	ETHERNET_MAC_INTR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	ETHERNET_MAC_INTR_RESERVED_Msk = 0x400
	// Bit RESERVED.
	ETHERNET_MAC_INTR_RESERVED = 0x400
	// Position of RESERVED field.
	ETHERNET_MAC_INTR_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	ETHERNET_MAC_INTR_RESERVED_Msk = 0xfffff800

	// MAC_INTR_MASK: Interrupt mask register
	// Position of RESERVED field.
	ETHERNET_MAC_INTR_MASK_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_MAC_INTR_MASK_RESERVED_Msk = 0x7
	// Position of PMTIM field.
	ETHERNET_MAC_INTR_MASK_PMTIM_Pos = 0x3
	// Bit mask of PMTIM field.
	ETHERNET_MAC_INTR_MASK_PMTIM_Msk = 0x8
	// Bit PMTIM.
	ETHERNET_MAC_INTR_MASK_PMTIM = 0x8
	// Position of RESERVED field.
	ETHERNET_MAC_INTR_MASK_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	ETHERNET_MAC_INTR_MASK_RESERVED_Msk = 0x1f0
	// Position of TSIM field.
	ETHERNET_MAC_INTR_MASK_TSIM_Pos = 0x9
	// Bit mask of TSIM field.
	ETHERNET_MAC_INTR_MASK_TSIM_Msk = 0x200
	// Bit TSIM.
	ETHERNET_MAC_INTR_MASK_TSIM = 0x200
	// Position of RESERVED field.
	ETHERNET_MAC_INTR_MASK_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	ETHERNET_MAC_INTR_MASK_RESERVED_Msk = 0x400
	// Bit RESERVED.
	ETHERNET_MAC_INTR_MASK_RESERVED = 0x400

	// MAC_ADDR0_HIGH: MAC address 0 high register
	// Position of A47_32 field.
	ETHERNET_MAC_ADDR0_HIGH_A47_32_Pos = 0x0
	// Bit mask of A47_32 field.
	ETHERNET_MAC_ADDR0_HIGH_A47_32_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_MAC_ADDR0_HIGH_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_MAC_ADDR0_HIGH_RESERVED_Msk = 0x7fff0000
	// Position of MO field.
	ETHERNET_MAC_ADDR0_HIGH_MO_Pos = 0x1f
	// Bit mask of MO field.
	ETHERNET_MAC_ADDR0_HIGH_MO_Msk = 0x80000000
	// Bit MO.
	ETHERNET_MAC_ADDR0_HIGH_MO = 0x80000000

	// MAC_ADDR0_LOW: MAC address 0 low register
	// Position of A31_0 field.
	ETHERNET_MAC_ADDR0_LOW_A31_0_Pos = 0x0
	// Bit mask of A31_0 field.
	ETHERNET_MAC_ADDR0_LOW_A31_0_Msk = 0xffffffff

	// MAC_TIMESTP_CTRL: Time stamp control register
	// Position of TSENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSENA_Pos = 0x0
	// Bit mask of TSENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSENA_Msk = 0x1
	// Bit TSENA.
	ETHERNET_MAC_TIMESTP_CTRL_TSENA = 0x1
	// Position of TSCFUPDT field.
	ETHERNET_MAC_TIMESTP_CTRL_TSCFUPDT_Pos = 0x1
	// Bit mask of TSCFUPDT field.
	ETHERNET_MAC_TIMESTP_CTRL_TSCFUPDT_Msk = 0x2
	// Bit TSCFUPDT.
	ETHERNET_MAC_TIMESTP_CTRL_TSCFUPDT = 0x2
	// Position of TSINIT field.
	ETHERNET_MAC_TIMESTP_CTRL_TSINIT_Pos = 0x2
	// Bit mask of TSINIT field.
	ETHERNET_MAC_TIMESTP_CTRL_TSINIT_Msk = 0x4
	// Bit TSINIT.
	ETHERNET_MAC_TIMESTP_CTRL_TSINIT = 0x4
	// Position of TSUPDT field.
	ETHERNET_MAC_TIMESTP_CTRL_TSUPDT_Pos = 0x3
	// Bit mask of TSUPDT field.
	ETHERNET_MAC_TIMESTP_CTRL_TSUPDT_Msk = 0x8
	// Bit TSUPDT.
	ETHERNET_MAC_TIMESTP_CTRL_TSUPDT = 0x8
	// Position of TSTRIG field.
	ETHERNET_MAC_TIMESTP_CTRL_TSTRIG_Pos = 0x4
	// Bit mask of TSTRIG field.
	ETHERNET_MAC_TIMESTP_CTRL_TSTRIG_Msk = 0x10
	// Bit TSTRIG.
	ETHERNET_MAC_TIMESTP_CTRL_TSTRIG = 0x10
	// Position of TSADDREG field.
	ETHERNET_MAC_TIMESTP_CTRL_TSADDREG_Pos = 0x5
	// Bit mask of TSADDREG field.
	ETHERNET_MAC_TIMESTP_CTRL_TSADDREG_Msk = 0x20
	// Bit TSADDREG.
	ETHERNET_MAC_TIMESTP_CTRL_TSADDREG = 0x20
	// Position of RESERVED field.
	ETHERNET_MAC_TIMESTP_CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	ETHERNET_MAC_TIMESTP_CTRL_RESERVED_Msk = 0xc0
	// Position of TSENALL field.
	ETHERNET_MAC_TIMESTP_CTRL_TSENALL_Pos = 0x8
	// Bit mask of TSENALL field.
	ETHERNET_MAC_TIMESTP_CTRL_TSENALL_Msk = 0x100
	// Bit TSENALL.
	ETHERNET_MAC_TIMESTP_CTRL_TSENALL = 0x100
	// Position of TSCTRLSSR field.
	ETHERNET_MAC_TIMESTP_CTRL_TSCTRLSSR_Pos = 0x9
	// Bit mask of TSCTRLSSR field.
	ETHERNET_MAC_TIMESTP_CTRL_TSCTRLSSR_Msk = 0x200
	// Bit TSCTRLSSR.
	ETHERNET_MAC_TIMESTP_CTRL_TSCTRLSSR = 0x200
	// Position of TSVER2ENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSVER2ENA_Pos = 0xa
	// Bit mask of TSVER2ENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSVER2ENA_Msk = 0x400
	// Bit TSVER2ENA.
	ETHERNET_MAC_TIMESTP_CTRL_TSVER2ENA = 0x400
	// Position of TSIPENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSIPENA_Pos = 0xb
	// Bit mask of TSIPENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSIPENA_Msk = 0x800
	// Bit TSIPENA.
	ETHERNET_MAC_TIMESTP_CTRL_TSIPENA = 0x800
	// Position of TSIPV6ENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSIPV6ENA_Pos = 0xc
	// Bit mask of TSIPV6ENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSIPV6ENA_Msk = 0x1000
	// Bit TSIPV6ENA.
	ETHERNET_MAC_TIMESTP_CTRL_TSIPV6ENA = 0x1000
	// Position of TSIPV4ENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSIPV4ENA_Pos = 0xd
	// Bit mask of TSIPV4ENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSIPV4ENA_Msk = 0x2000
	// Bit TSIPV4ENA.
	ETHERNET_MAC_TIMESTP_CTRL_TSIPV4ENA = 0x2000
	// Position of TSEVNTENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSEVNTENA_Pos = 0xe
	// Bit mask of TSEVNTENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSEVNTENA_Msk = 0x4000
	// Bit TSEVNTENA.
	ETHERNET_MAC_TIMESTP_CTRL_TSEVNTENA = 0x4000
	// Position of TSMSTRENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSMSTRENA_Pos = 0xf
	// Bit mask of TSMSTRENA field.
	ETHERNET_MAC_TIMESTP_CTRL_TSMSTRENA_Msk = 0x8000
	// Bit TSMSTRENA.
	ETHERNET_MAC_TIMESTP_CTRL_TSMSTRENA = 0x8000
	// Position of TSCLKTYPE field.
	ETHERNET_MAC_TIMESTP_CTRL_TSCLKTYPE_Pos = 0x10
	// Bit mask of TSCLKTYPE field.
	ETHERNET_MAC_TIMESTP_CTRL_TSCLKTYPE_Msk = 0x30000
	// Position of TSENMACADDR field.
	ETHERNET_MAC_TIMESTP_CTRL_TSENMACADDR_Pos = 0x12
	// Bit mask of TSENMACADDR field.
	ETHERNET_MAC_TIMESTP_CTRL_TSENMACADDR_Msk = 0x40000
	// Bit TSENMACADDR.
	ETHERNET_MAC_TIMESTP_CTRL_TSENMACADDR = 0x40000

	// SUBSECOND_INCR: Sub-second increment register
	// Position of SSINC field.
	ETHERNET_SUBSECOND_INCR_SSINC_Pos = 0x0
	// Bit mask of SSINC field.
	ETHERNET_SUBSECOND_INCR_SSINC_Msk = 0xff
	// Position of RESERVED field.
	ETHERNET_SUBSECOND_INCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_SUBSECOND_INCR_RESERVED_Msk = 0xffffff00

	// SECONDS: System time seconds register
	// Position of TSS field.
	ETHERNET_SECONDS_TSS_Pos = 0x0
	// Bit mask of TSS field.
	ETHERNET_SECONDS_TSS_Msk = 0xffffffff

	// NANOSECONDS: System time nanoseconds register
	// Position of TSSS field.
	ETHERNET_NANOSECONDS_TSSS_Pos = 0x0
	// Bit mask of TSSS field.
	ETHERNET_NANOSECONDS_TSSS_Msk = 0x7fffffff
	// Position of PSNT field.
	ETHERNET_NANOSECONDS_PSNT_Pos = 0x1f
	// Bit mask of PSNT field.
	ETHERNET_NANOSECONDS_PSNT_Msk = 0x80000000
	// Bit PSNT.
	ETHERNET_NANOSECONDS_PSNT = 0x80000000

	// SECONDSUPDATE: System time seconds update register
	// Position of TSS field.
	ETHERNET_SECONDSUPDATE_TSS_Pos = 0x0
	// Bit mask of TSS field.
	ETHERNET_SECONDSUPDATE_TSS_Msk = 0xffffffff

	// NANOSECONDSUPDATE: System time nanoseconds update register
	// Position of TSSS field.
	ETHERNET_NANOSECONDSUPDATE_TSSS_Pos = 0x0
	// Bit mask of TSSS field.
	ETHERNET_NANOSECONDSUPDATE_TSSS_Msk = 0x7fffffff
	// Position of ADDSUB field.
	ETHERNET_NANOSECONDSUPDATE_ADDSUB_Pos = 0x1f
	// Bit mask of ADDSUB field.
	ETHERNET_NANOSECONDSUPDATE_ADDSUB_Msk = 0x80000000
	// Bit ADDSUB.
	ETHERNET_NANOSECONDSUPDATE_ADDSUB = 0x80000000

	// ADDEND: Time stamp addend register
	// Position of TSAR field.
	ETHERNET_ADDEND_TSAR_Pos = 0x0
	// Bit mask of TSAR field.
	ETHERNET_ADDEND_TSAR_Msk = 0xffffffff

	// TARGETSECONDS: Target time seconds register
	// Position of TSTR field.
	ETHERNET_TARGETSECONDS_TSTR_Pos = 0x0
	// Bit mask of TSTR field.
	ETHERNET_TARGETSECONDS_TSTR_Msk = 0xffffffff

	// TARGETNANOSECONDS: Target time nanoseconds register
	// Position of TSTR field.
	ETHERNET_TARGETNANOSECONDS_TSTR_Pos = 0x0
	// Bit mask of TSTR field.
	ETHERNET_TARGETNANOSECONDS_TSTR_Msk = 0x7fffffff
	// Position of RESERVED field.
	ETHERNET_TARGETNANOSECONDS_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	ETHERNET_TARGETNANOSECONDS_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	ETHERNET_TARGETNANOSECONDS_RESERVED = 0x80000000

	// HIGHWORD: System time higher word seconds register
	// Position of TSHWR field.
	ETHERNET_HIGHWORD_TSHWR_Pos = 0x0
	// Bit mask of TSHWR field.
	ETHERNET_HIGHWORD_TSHWR_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_HIGHWORD_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_HIGHWORD_RESERVED_Msk = 0xffff0000

	// TIMESTAMPSTAT: Time stamp status register
	// Position of TSSOVF field.
	ETHERNET_TIMESTAMPSTAT_TSSOVF_Pos = 0x0
	// Bit mask of TSSOVF field.
	ETHERNET_TIMESTAMPSTAT_TSSOVF_Msk = 0x1
	// Bit TSSOVF.
	ETHERNET_TIMESTAMPSTAT_TSSOVF = 0x1
	// Position of TSTARGT field.
	ETHERNET_TIMESTAMPSTAT_TSTARGT_Pos = 0x1
	// Bit mask of TSTARGT field.
	ETHERNET_TIMESTAMPSTAT_TSTARGT_Msk = 0x2
	// Bit TSTARGT.
	ETHERNET_TIMESTAMPSTAT_TSTARGT = 0x2
	// Position of RESERVED field.
	ETHERNET_TIMESTAMPSTAT_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	ETHERNET_TIMESTAMPSTAT_RESERVED_Msk = 0xfffffffc

	// DMA_BUS_MODE: Bus Mode Register
	// Position of SWR field.
	ETHERNET_DMA_BUS_MODE_SWR_Pos = 0x0
	// Bit mask of SWR field.
	ETHERNET_DMA_BUS_MODE_SWR_Msk = 0x1
	// Bit SWR.
	ETHERNET_DMA_BUS_MODE_SWR = 0x1
	// Position of DA field.
	ETHERNET_DMA_BUS_MODE_DA_Pos = 0x1
	// Bit mask of DA field.
	ETHERNET_DMA_BUS_MODE_DA_Msk = 0x2
	// Bit DA.
	ETHERNET_DMA_BUS_MODE_DA = 0x2
	// Position of DSL field.
	ETHERNET_DMA_BUS_MODE_DSL_Pos = 0x2
	// Bit mask of DSL field.
	ETHERNET_DMA_BUS_MODE_DSL_Msk = 0x7c
	// Position of ATDS field.
	ETHERNET_DMA_BUS_MODE_ATDS_Pos = 0x7
	// Bit mask of ATDS field.
	ETHERNET_DMA_BUS_MODE_ATDS_Msk = 0x80
	// Bit ATDS.
	ETHERNET_DMA_BUS_MODE_ATDS = 0x80
	// Position of PBL field.
	ETHERNET_DMA_BUS_MODE_PBL_Pos = 0x8
	// Bit mask of PBL field.
	ETHERNET_DMA_BUS_MODE_PBL_Msk = 0x3f00
	// Position of PR field.
	ETHERNET_DMA_BUS_MODE_PR_Pos = 0xe
	// Bit mask of PR field.
	ETHERNET_DMA_BUS_MODE_PR_Msk = 0xc000
	// Position of FB field.
	ETHERNET_DMA_BUS_MODE_FB_Pos = 0x10
	// Bit mask of FB field.
	ETHERNET_DMA_BUS_MODE_FB_Msk = 0x10000
	// Bit FB.
	ETHERNET_DMA_BUS_MODE_FB = 0x10000
	// Position of RPBL field.
	ETHERNET_DMA_BUS_MODE_RPBL_Pos = 0x11
	// Bit mask of RPBL field.
	ETHERNET_DMA_BUS_MODE_RPBL_Msk = 0x7e0000
	// Position of USP field.
	ETHERNET_DMA_BUS_MODE_USP_Pos = 0x17
	// Bit mask of USP field.
	ETHERNET_DMA_BUS_MODE_USP_Msk = 0x800000
	// Bit USP.
	ETHERNET_DMA_BUS_MODE_USP = 0x800000
	// Position of PBL8X field.
	ETHERNET_DMA_BUS_MODE_PBL8X_Pos = 0x18
	// Bit mask of PBL8X field.
	ETHERNET_DMA_BUS_MODE_PBL8X_Msk = 0x1000000
	// Bit PBL8X.
	ETHERNET_DMA_BUS_MODE_PBL8X = 0x1000000
	// Position of AAL field.
	ETHERNET_DMA_BUS_MODE_AAL_Pos = 0x19
	// Bit mask of AAL field.
	ETHERNET_DMA_BUS_MODE_AAL_Msk = 0x2000000
	// Bit AAL.
	ETHERNET_DMA_BUS_MODE_AAL = 0x2000000
	// Position of MB field.
	ETHERNET_DMA_BUS_MODE_MB_Pos = 0x1a
	// Bit mask of MB field.
	ETHERNET_DMA_BUS_MODE_MB_Msk = 0x4000000
	// Bit MB.
	ETHERNET_DMA_BUS_MODE_MB = 0x4000000
	// Position of TXPR field.
	ETHERNET_DMA_BUS_MODE_TXPR_Pos = 0x1b
	// Bit mask of TXPR field.
	ETHERNET_DMA_BUS_MODE_TXPR_Msk = 0x8000000
	// Bit TXPR.
	ETHERNET_DMA_BUS_MODE_TXPR = 0x8000000
	// Position of RESERVED field.
	ETHERNET_DMA_BUS_MODE_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	ETHERNET_DMA_BUS_MODE_RESERVED_Msk = 0xf0000000

	// DMA_TRANS_POLL_DEMAND: Transmit poll demand register
	// Position of TPD field.
	ETHERNET_DMA_TRANS_POLL_DEMAND_TPD_Pos = 0x0
	// Bit mask of TPD field.
	ETHERNET_DMA_TRANS_POLL_DEMAND_TPD_Msk = 0xffffffff

	// DMA_REC_POLL_DEMAND: Receive poll demand register
	// Position of RPD field.
	ETHERNET_DMA_REC_POLL_DEMAND_RPD_Pos = 0x0
	// Bit mask of RPD field.
	ETHERNET_DMA_REC_POLL_DEMAND_RPD_Msk = 0xffffffff

	// DMA_REC_DES_ADDR: Receive descriptor list address register
	// Position of SRL field.
	ETHERNET_DMA_REC_DES_ADDR_SRL_Pos = 0x0
	// Bit mask of SRL field.
	ETHERNET_DMA_REC_DES_ADDR_SRL_Msk = 0xffffffff

	// DMA_TRANS_DES_ADDR: Transmit descriptor list address register
	// Position of SRL field.
	ETHERNET_DMA_TRANS_DES_ADDR_SRL_Pos = 0x0
	// Bit mask of SRL field.
	ETHERNET_DMA_TRANS_DES_ADDR_SRL_Msk = 0xffffffff

	// DMA_STAT: Status register
	// Position of TI field.
	ETHERNET_DMA_STAT_TI_Pos = 0x0
	// Bit mask of TI field.
	ETHERNET_DMA_STAT_TI_Msk = 0x1
	// Bit TI.
	ETHERNET_DMA_STAT_TI = 0x1
	// Position of TPS field.
	ETHERNET_DMA_STAT_TPS_Pos = 0x1
	// Bit mask of TPS field.
	ETHERNET_DMA_STAT_TPS_Msk = 0x2
	// Bit TPS.
	ETHERNET_DMA_STAT_TPS = 0x2
	// Position of TU field.
	ETHERNET_DMA_STAT_TU_Pos = 0x2
	// Bit mask of TU field.
	ETHERNET_DMA_STAT_TU_Msk = 0x4
	// Bit TU.
	ETHERNET_DMA_STAT_TU = 0x4
	// Position of TJT field.
	ETHERNET_DMA_STAT_TJT_Pos = 0x3
	// Bit mask of TJT field.
	ETHERNET_DMA_STAT_TJT_Msk = 0x8
	// Bit TJT.
	ETHERNET_DMA_STAT_TJT = 0x8
	// Position of OVF field.
	ETHERNET_DMA_STAT_OVF_Pos = 0x4
	// Bit mask of OVF field.
	ETHERNET_DMA_STAT_OVF_Msk = 0x10
	// Bit OVF.
	ETHERNET_DMA_STAT_OVF = 0x10
	// Position of UNF field.
	ETHERNET_DMA_STAT_UNF_Pos = 0x5
	// Bit mask of UNF field.
	ETHERNET_DMA_STAT_UNF_Msk = 0x20
	// Bit UNF.
	ETHERNET_DMA_STAT_UNF = 0x20
	// Position of RI field.
	ETHERNET_DMA_STAT_RI_Pos = 0x6
	// Bit mask of RI field.
	ETHERNET_DMA_STAT_RI_Msk = 0x40
	// Bit RI.
	ETHERNET_DMA_STAT_RI = 0x40
	// Position of RU field.
	ETHERNET_DMA_STAT_RU_Pos = 0x7
	// Bit mask of RU field.
	ETHERNET_DMA_STAT_RU_Msk = 0x80
	// Bit RU.
	ETHERNET_DMA_STAT_RU = 0x80
	// Position of RPS field.
	ETHERNET_DMA_STAT_RPS_Pos = 0x8
	// Bit mask of RPS field.
	ETHERNET_DMA_STAT_RPS_Msk = 0x100
	// Bit RPS.
	ETHERNET_DMA_STAT_RPS = 0x100
	// Position of RWT field.
	ETHERNET_DMA_STAT_RWT_Pos = 0x9
	// Bit mask of RWT field.
	ETHERNET_DMA_STAT_RWT_Msk = 0x200
	// Bit RWT.
	ETHERNET_DMA_STAT_RWT = 0x200
	// Position of ETI field.
	ETHERNET_DMA_STAT_ETI_Pos = 0xa
	// Bit mask of ETI field.
	ETHERNET_DMA_STAT_ETI_Msk = 0x400
	// Bit ETI.
	ETHERNET_DMA_STAT_ETI = 0x400
	// Position of RESERVED field.
	ETHERNET_DMA_STAT_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	ETHERNET_DMA_STAT_RESERVED_Msk = 0x1800
	// Position of FBI field.
	ETHERNET_DMA_STAT_FBI_Pos = 0xd
	// Bit mask of FBI field.
	ETHERNET_DMA_STAT_FBI_Msk = 0x2000
	// Bit FBI.
	ETHERNET_DMA_STAT_FBI = 0x2000
	// Position of ERI field.
	ETHERNET_DMA_STAT_ERI_Pos = 0xe
	// Bit mask of ERI field.
	ETHERNET_DMA_STAT_ERI_Msk = 0x4000
	// Bit ERI.
	ETHERNET_DMA_STAT_ERI = 0x4000
	// Position of AIE field.
	ETHERNET_DMA_STAT_AIE_Pos = 0xf
	// Bit mask of AIE field.
	ETHERNET_DMA_STAT_AIE_Msk = 0x8000
	// Bit AIE.
	ETHERNET_DMA_STAT_AIE = 0x8000
	// Position of NIS field.
	ETHERNET_DMA_STAT_NIS_Pos = 0x10
	// Bit mask of NIS field.
	ETHERNET_DMA_STAT_NIS_Msk = 0x10000
	// Bit NIS.
	ETHERNET_DMA_STAT_NIS = 0x10000
	// Position of RS field.
	ETHERNET_DMA_STAT_RS_Pos = 0x11
	// Bit mask of RS field.
	ETHERNET_DMA_STAT_RS_Msk = 0xe0000
	// Position of TS field.
	ETHERNET_DMA_STAT_TS_Pos = 0x14
	// Bit mask of TS field.
	ETHERNET_DMA_STAT_TS_Msk = 0x700000
	// Position of EB1 field.
	ETHERNET_DMA_STAT_EB1_Pos = 0x17
	// Bit mask of EB1 field.
	ETHERNET_DMA_STAT_EB1_Msk = 0x800000
	// Bit EB1.
	ETHERNET_DMA_STAT_EB1 = 0x800000
	// Position of EB2 field.
	ETHERNET_DMA_STAT_EB2_Pos = 0x18
	// Bit mask of EB2 field.
	ETHERNET_DMA_STAT_EB2_Msk = 0x1000000
	// Bit EB2.
	ETHERNET_DMA_STAT_EB2 = 0x1000000
	// Position of EB3 field.
	ETHERNET_DMA_STAT_EB3_Pos = 0x19
	// Bit mask of EB3 field.
	ETHERNET_DMA_STAT_EB3_Msk = 0x2000000
	// Bit EB3.
	ETHERNET_DMA_STAT_EB3 = 0x2000000
	// Position of RESERVED field.
	ETHERNET_DMA_STAT_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	ETHERNET_DMA_STAT_RESERVED_Msk = 0xfc000000

	// DMA_OP_MODE: Operation mode register
	// Position of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Msk = 0x1
	// Bit RESERVED.
	ETHERNET_DMA_OP_MODE_RESERVED = 0x1
	// Position of SR field.
	ETHERNET_DMA_OP_MODE_SR_Pos = 0x1
	// Bit mask of SR field.
	ETHERNET_DMA_OP_MODE_SR_Msk = 0x2
	// Bit SR.
	ETHERNET_DMA_OP_MODE_SR = 0x2
	// Position of OSF field.
	ETHERNET_DMA_OP_MODE_OSF_Pos = 0x2
	// Bit mask of OSF field.
	ETHERNET_DMA_OP_MODE_OSF_Msk = 0x4
	// Bit OSF.
	ETHERNET_DMA_OP_MODE_OSF = 0x4
	// Position of RTC field.
	ETHERNET_DMA_OP_MODE_RTC_Pos = 0x3
	// Bit mask of RTC field.
	ETHERNET_DMA_OP_MODE_RTC_Msk = 0x18
	// Position of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Msk = 0x20
	// Bit RESERVED.
	ETHERNET_DMA_OP_MODE_RESERVED = 0x20
	// Position of FUF field.
	ETHERNET_DMA_OP_MODE_FUF_Pos = 0x6
	// Bit mask of FUF field.
	ETHERNET_DMA_OP_MODE_FUF_Msk = 0x40
	// Bit FUF.
	ETHERNET_DMA_OP_MODE_FUF = 0x40
	// Position of FEF field.
	ETHERNET_DMA_OP_MODE_FEF_Pos = 0x7
	// Bit mask of FEF field.
	ETHERNET_DMA_OP_MODE_FEF_Msk = 0x80
	// Bit FEF.
	ETHERNET_DMA_OP_MODE_FEF = 0x80
	// Position of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Msk = 0x1f00
	// Position of ST field.
	ETHERNET_DMA_OP_MODE_ST_Pos = 0xd
	// Bit mask of ST field.
	ETHERNET_DMA_OP_MODE_ST_Msk = 0x2000
	// Bit ST.
	ETHERNET_DMA_OP_MODE_ST = 0x2000
	// Position of TTC field.
	ETHERNET_DMA_OP_MODE_TTC_Pos = 0xe
	// Bit mask of TTC field.
	ETHERNET_DMA_OP_MODE_TTC_Msk = 0x1c000
	// Position of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Msk = 0xe0000
	// Position of FTF field.
	ETHERNET_DMA_OP_MODE_FTF_Pos = 0x14
	// Bit mask of FTF field.
	ETHERNET_DMA_OP_MODE_FTF_Msk = 0x100000
	// Bit FTF.
	ETHERNET_DMA_OP_MODE_FTF = 0x100000
	// Position of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Msk = 0x200000
	// Bit RESERVED.
	ETHERNET_DMA_OP_MODE_RESERVED = 0x200000
	// Position of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Msk = 0xc00000
	// Position of DFF field.
	ETHERNET_DMA_OP_MODE_DFF_Pos = 0x18
	// Bit mask of DFF field.
	ETHERNET_DMA_OP_MODE_DFF_Msk = 0x1000000
	// Bit DFF.
	ETHERNET_DMA_OP_MODE_DFF = 0x1000000
	// Position of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Pos = 0x19
	// Bit mask of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Msk = 0x2000000
	// Bit RESERVED.
	ETHERNET_DMA_OP_MODE_RESERVED = 0x2000000
	// Position of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Msk = 0x4000000
	// Bit RESERVED.
	ETHERNET_DMA_OP_MODE_RESERVED = 0x4000000
	// Position of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	ETHERNET_DMA_OP_MODE_RESERVED_Msk = 0xf8000000

	// DMA_INT_EN: Interrupt enable register
	// Position of TIE field.
	ETHERNET_DMA_INT_EN_TIE_Pos = 0x0
	// Bit mask of TIE field.
	ETHERNET_DMA_INT_EN_TIE_Msk = 0x1
	// Bit TIE.
	ETHERNET_DMA_INT_EN_TIE = 0x1
	// Position of TSE field.
	ETHERNET_DMA_INT_EN_TSE_Pos = 0x1
	// Bit mask of TSE field.
	ETHERNET_DMA_INT_EN_TSE_Msk = 0x2
	// Bit TSE.
	ETHERNET_DMA_INT_EN_TSE = 0x2
	// Position of TUE field.
	ETHERNET_DMA_INT_EN_TUE_Pos = 0x2
	// Bit mask of TUE field.
	ETHERNET_DMA_INT_EN_TUE_Msk = 0x4
	// Bit TUE.
	ETHERNET_DMA_INT_EN_TUE = 0x4
	// Position of TJE field.
	ETHERNET_DMA_INT_EN_TJE_Pos = 0x3
	// Bit mask of TJE field.
	ETHERNET_DMA_INT_EN_TJE_Msk = 0x8
	// Bit TJE.
	ETHERNET_DMA_INT_EN_TJE = 0x8
	// Position of OVE field.
	ETHERNET_DMA_INT_EN_OVE_Pos = 0x4
	// Bit mask of OVE field.
	ETHERNET_DMA_INT_EN_OVE_Msk = 0x10
	// Bit OVE.
	ETHERNET_DMA_INT_EN_OVE = 0x10
	// Position of UNE field.
	ETHERNET_DMA_INT_EN_UNE_Pos = 0x5
	// Bit mask of UNE field.
	ETHERNET_DMA_INT_EN_UNE_Msk = 0x20
	// Bit UNE.
	ETHERNET_DMA_INT_EN_UNE = 0x20
	// Position of RIE field.
	ETHERNET_DMA_INT_EN_RIE_Pos = 0x6
	// Bit mask of RIE field.
	ETHERNET_DMA_INT_EN_RIE_Msk = 0x40
	// Bit RIE.
	ETHERNET_DMA_INT_EN_RIE = 0x40
	// Position of RUE field.
	ETHERNET_DMA_INT_EN_RUE_Pos = 0x7
	// Bit mask of RUE field.
	ETHERNET_DMA_INT_EN_RUE_Msk = 0x80
	// Bit RUE.
	ETHERNET_DMA_INT_EN_RUE = 0x80
	// Position of RSE field.
	ETHERNET_DMA_INT_EN_RSE_Pos = 0x8
	// Bit mask of RSE field.
	ETHERNET_DMA_INT_EN_RSE_Msk = 0x100
	// Bit RSE.
	ETHERNET_DMA_INT_EN_RSE = 0x100
	// Position of RWE field.
	ETHERNET_DMA_INT_EN_RWE_Pos = 0x9
	// Bit mask of RWE field.
	ETHERNET_DMA_INT_EN_RWE_Msk = 0x200
	// Bit RWE.
	ETHERNET_DMA_INT_EN_RWE = 0x200
	// Position of ETE field.
	ETHERNET_DMA_INT_EN_ETE_Pos = 0xa
	// Bit mask of ETE field.
	ETHERNET_DMA_INT_EN_ETE_Msk = 0x400
	// Bit ETE.
	ETHERNET_DMA_INT_EN_ETE = 0x400
	// Position of RESERVED field.
	ETHERNET_DMA_INT_EN_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	ETHERNET_DMA_INT_EN_RESERVED_Msk = 0x1800
	// Position of FBE field.
	ETHERNET_DMA_INT_EN_FBE_Pos = 0xd
	// Bit mask of FBE field.
	ETHERNET_DMA_INT_EN_FBE_Msk = 0x2000
	// Bit FBE.
	ETHERNET_DMA_INT_EN_FBE = 0x2000
	// Position of ERE field.
	ETHERNET_DMA_INT_EN_ERE_Pos = 0xe
	// Bit mask of ERE field.
	ETHERNET_DMA_INT_EN_ERE_Msk = 0x4000
	// Bit ERE.
	ETHERNET_DMA_INT_EN_ERE = 0x4000
	// Position of AIE field.
	ETHERNET_DMA_INT_EN_AIE_Pos = 0xf
	// Bit mask of AIE field.
	ETHERNET_DMA_INT_EN_AIE_Msk = 0x8000
	// Bit AIE.
	ETHERNET_DMA_INT_EN_AIE = 0x8000
	// Position of NIE field.
	ETHERNET_DMA_INT_EN_NIE_Pos = 0x10
	// Bit mask of NIE field.
	ETHERNET_DMA_INT_EN_NIE_Msk = 0x10000
	// Bit NIE.
	ETHERNET_DMA_INT_EN_NIE = 0x10000
	// Position of RESERVED field.
	ETHERNET_DMA_INT_EN_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	ETHERNET_DMA_INT_EN_RESERVED_Msk = 0xfffe0000

	// DMA_MFRM_BUFOF: Missed frame and buffer overflow register
	// Position of FMC field.
	ETHERNET_DMA_MFRM_BUFOF_FMC_Pos = 0x0
	// Bit mask of FMC field.
	ETHERNET_DMA_MFRM_BUFOF_FMC_Msk = 0xffff
	// Position of OC field.
	ETHERNET_DMA_MFRM_BUFOF_OC_Pos = 0x10
	// Bit mask of OC field.
	ETHERNET_DMA_MFRM_BUFOF_OC_Msk = 0x10000
	// Bit OC.
	ETHERNET_DMA_MFRM_BUFOF_OC = 0x10000
	// Position of FMA field.
	ETHERNET_DMA_MFRM_BUFOF_FMA_Pos = 0x11
	// Bit mask of FMA field.
	ETHERNET_DMA_MFRM_BUFOF_FMA_Msk = 0xffe0000
	// Position of OF field.
	ETHERNET_DMA_MFRM_BUFOF_OF_Pos = 0x1c
	// Bit mask of OF field.
	ETHERNET_DMA_MFRM_BUFOF_OF_Msk = 0x10000000
	// Bit OF.
	ETHERNET_DMA_MFRM_BUFOF_OF = 0x10000000
	// Position of RESERVED field.
	ETHERNET_DMA_MFRM_BUFOF_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	ETHERNET_DMA_MFRM_BUFOF_RESERVED_Msk = 0xe0000000

	// DMA_REC_INT_WDT: Receive interrupt watchdog timer register
	// Position of RIWT field.
	ETHERNET_DMA_REC_INT_WDT_RIWT_Pos = 0x0
	// Bit mask of RIWT field.
	ETHERNET_DMA_REC_INT_WDT_RIWT_Msk = 0xff
	// Position of RESERVED field.
	ETHERNET_DMA_REC_INT_WDT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_DMA_REC_INT_WDT_RESERVED_Msk = 0xffffff00

	// DMA_CURHOST_TRANS_DES: Current host transmit descriptor register
	// Position of HTD field.
	ETHERNET_DMA_CURHOST_TRANS_DES_HTD_Pos = 0x0
	// Bit mask of HTD field.
	ETHERNET_DMA_CURHOST_TRANS_DES_HTD_Msk = 0xffffffff

	// DMA_CURHOST_REC_DES: Current host receive descriptor register
	// Position of HRD field.
	ETHERNET_DMA_CURHOST_REC_DES_HRD_Pos = 0x0
	// Bit mask of HRD field.
	ETHERNET_DMA_CURHOST_REC_DES_HRD_Msk = 0xffffffff

	// DMA_CURHOST_TRANS_BUF: Current host transmit buffer address register
	// Position of HTB field.
	ETHERNET_DMA_CURHOST_TRANS_BUF_HTB_Pos = 0x0
	// Bit mask of HTB field.
	ETHERNET_DMA_CURHOST_TRANS_BUF_HTB_Msk = 0xffffffff

	// DMA_CURHOST_REC_BUF: Current host receive buffer address register
	// Position of HRB field.
	ETHERNET_DMA_CURHOST_REC_BUF_HRB_Pos = 0x0
	// Bit mask of HRB field.
	ETHERNET_DMA_CURHOST_REC_BUF_HRB_Msk = 0xffffffff
)

// Constants for ATIMER: Alarm timer
const (
	// DOWNCOUNTER: Downcounter register
	// Position of CVAL field.
	ATIMER_DOWNCOUNTER_CVAL_Pos = 0x0
	// Bit mask of CVAL field.
	ATIMER_DOWNCOUNTER_CVAL_Msk = 0xffff
	// Position of RESERVED field.
	ATIMER_DOWNCOUNTER_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ATIMER_DOWNCOUNTER_RESERVED_Msk = 0xffff0000

	// PRESET: Preset value register
	// Position of PRESETVAL field.
	ATIMER_PRESET_PRESETVAL_Pos = 0x0
	// Bit mask of PRESETVAL field.
	ATIMER_PRESET_PRESETVAL_Msk = 0xffff
	// Position of RESERVED field.
	ATIMER_PRESET_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ATIMER_PRESET_RESERVED_Msk = 0xffff0000

	// CLR_EN: Interrupt clear enable register
	// Position of CLR_EN field.
	ATIMER_CLR_EN_CLR_EN_Pos = 0x0
	// Bit mask of CLR_EN field.
	ATIMER_CLR_EN_CLR_EN_Msk = 0x1
	// Bit CLR_EN.
	ATIMER_CLR_EN_CLR_EN = 0x1
	// Position of RESERVED field.
	ATIMER_CLR_EN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	ATIMER_CLR_EN_RESERVED_Msk = 0xfffffffe

	// SET_EN: Interrupt set enable register
	// Position of SET_EN field.
	ATIMER_SET_EN_SET_EN_Pos = 0x0
	// Bit mask of SET_EN field.
	ATIMER_SET_EN_SET_EN_Msk = 0x1
	// Bit SET_EN.
	ATIMER_SET_EN_SET_EN = 0x1
	// Position of RESERVED field.
	ATIMER_SET_EN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	ATIMER_SET_EN_RESERVED_Msk = 0xfffffffe

	// STATUS: Status register
	// Position of STAT field.
	ATIMER_STATUS_STAT_Pos = 0x0
	// Bit mask of STAT field.
	ATIMER_STATUS_STAT_Msk = 0x1
	// Bit STAT.
	ATIMER_STATUS_STAT = 0x1
	// Position of RESERVED field.
	ATIMER_STATUS_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	ATIMER_STATUS_RESERVED_Msk = 0xfffffffe

	// ENABLE: Enable register
	// Position of EN field.
	ATIMER_ENABLE_EN_Pos = 0x0
	// Bit mask of EN field.
	ATIMER_ENABLE_EN_Msk = 0x1
	// Bit EN.
	ATIMER_ENABLE_EN = 0x1
	// Position of RESERVED field.
	ATIMER_ENABLE_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	ATIMER_ENABLE_RESERVED_Msk = 0xfffffffe

	// CLR_STAT: Clear register
	// Position of CSTAT field.
	ATIMER_CLR_STAT_CSTAT_Pos = 0x0
	// Bit mask of CSTAT field.
	ATIMER_CLR_STAT_CSTAT_Msk = 0x1
	// Bit CSTAT.
	ATIMER_CLR_STAT_CSTAT = 0x1
	// Position of RESERVED field.
	ATIMER_CLR_STAT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	ATIMER_CLR_STAT_RESERVED_Msk = 0xfffffffe

	// SET_STAT: Set register
	// Position of SSTAT field.
	ATIMER_SET_STAT_SSTAT_Pos = 0x0
	// Bit mask of SSTAT field.
	ATIMER_SET_STAT_SSTAT_Msk = 0x1
	// Bit SSTAT.
	ATIMER_SET_STAT_SSTAT = 0x1
	// Position of RESERVED field.
	ATIMER_SET_STAT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	ATIMER_SET_STAT_RESERVED_Msk = 0xfffffffe
)

// Constants for REGFILE: RTC REGFILE
const (
	// REGFILE: General purpose storage register
	// Position of REGVAL field.
	REGFILE_REGFILE_REGVAL_Pos = 0x0
	// Bit mask of REGVAL field.
	REGFILE_REGFILE_REGVAL_Msk = 0xffffffff
)

// Constants for PMC: Power Management Controller (PMC)
const (
	// PD0_SLEEP0_HW_ENA: Hardware sleep event enable register
	// Position of ENA_EVENT0 field.
	PMC_PD0_SLEEP0_HW_ENA_ENA_EVENT0_Pos = 0x0
	// Bit mask of ENA_EVENT0 field.
	PMC_PD0_SLEEP0_HW_ENA_ENA_EVENT0_Msk = 0x1
	// Bit ENA_EVENT0.
	PMC_PD0_SLEEP0_HW_ENA_ENA_EVENT0 = 0x1
	// Position of RESERVED field.
	PMC_PD0_SLEEP0_HW_ENA_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	PMC_PD0_SLEEP0_HW_ENA_RESERVED_Msk = 0xfffffffe

	// PD0_SLEEP0_MODE: Sleep power mode register
	// Position of PWR_STATE field.
	PMC_PD0_SLEEP0_MODE_PWR_STATE_Pos = 0x0
	// Bit mask of PWR_STATE field.
	PMC_PD0_SLEEP0_MODE_PWR_STATE_Msk = 0xffffffff
)

// Constants for CREG: Configuration Registers (CREG)
const (
	// CREG0: Chip configuration register 32 kHz oscillator output and BOD control register.
	// Position of EN1KHZ field.
	CREG_CREG0_EN1KHZ_Pos = 0x0
	// Bit mask of EN1KHZ field.
	CREG_CREG0_EN1KHZ_Msk = 0x1
	// Bit EN1KHZ.
	CREG_CREG0_EN1KHZ = 0x1
	// 1 kHz output disabled.
	CREG_CREG0_EN1KHZ_1_KHZ_OUTPUT_DISABLE = 0x0
	// 1 kHz output enabled.
	CREG_CREG0_EN1KHZ_1_KHZ_OUTPUT_ENABLED = 0x1
	// Position of EN32KHZ field.
	CREG_CREG0_EN32KHZ_Pos = 0x1
	// Bit mask of EN32KHZ field.
	CREG_CREG0_EN32KHZ_Msk = 0x2
	// Bit EN32KHZ.
	CREG_CREG0_EN32KHZ = 0x2
	// 32 kHz output disabled.
	CREG_CREG0_EN32KHZ_32_KHZ_OUTPUT_DISABL = 0x0
	// 32 kHz output enabled.
	CREG_CREG0_EN32KHZ_32_KHZ_OUTPUT_ENABLE = 0x1
	// Position of RESET32KHZ field.
	CREG_CREG0_RESET32KHZ_Pos = 0x2
	// Bit mask of RESET32KHZ field.
	CREG_CREG0_RESET32KHZ_Msk = 0x4
	// Bit RESET32KHZ.
	CREG_CREG0_RESET32KHZ = 0x4
	// Clear reset.
	CREG_CREG0_RESET32KHZ_CLEAR_RESET = 0x0
	// Reset active.
	CREG_CREG0_RESET32KHZ_RESET_ACTIVE = 0x1
	// Position of PD32KHZ field.
	CREG_CREG0_PD32KHZ_Pos = 0x3
	// Bit mask of PD32KHZ field.
	CREG_CREG0_PD32KHZ_Msk = 0x8
	// Bit PD32KHZ.
	CREG_CREG0_PD32KHZ = 0x8
	// Powered.
	CREG_CREG0_PD32KHZ_POWERED = 0x0
	// Powered-down.
	CREG_CREG0_PD32KHZ_POWERED_DOWN = 0x1
	// Position of RESERVED field.
	CREG_CREG0_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	CREG_CREG0_RESERVED_Msk = 0x10
	// Bit RESERVED.
	CREG_CREG0_RESERVED = 0x10
	// Position of USB0PHY field.
	CREG_CREG0_USB0PHY_Pos = 0x5
	// Bit mask of USB0PHY field.
	CREG_CREG0_USB0PHY_Msk = 0x20
	// Bit USB0PHY.
	CREG_CREG0_USB0PHY = 0x20
	// Enable USB0 PHY power.
	CREG_CREG0_USB0PHY_ENABLE_USB0_PHY_POWE = 0x0
	// Disable USB0 PHY. PHY powered down.
	CREG_CREG0_USB0PHY_DISABLE_USB0_PHY = 0x1
	// Position of ALARMCTRL field.
	CREG_CREG0_ALARMCTRL_Pos = 0x6
	// Bit mask of ALARMCTRL field.
	CREG_CREG0_ALARMCTRL_Msk = 0xc0
	// RTC alarm.
	CREG_CREG0_ALARMCTRL_RTC_ALARM = 0x0
	// Event router event.
	CREG_CREG0_ALARMCTRL_EVENT_ROUTER_EVENT = 0x1
	// Inactive.
	CREG_CREG0_ALARMCTRL_INACTIVE = 0x3
	// Position of BODLVL1 field.
	CREG_CREG0_BODLVL1_Pos = 0x8
	// Bit mask of BODLVL1 field.
	CREG_CREG0_BODLVL1_Msk = 0x300
	// Level 0 interrupt
	CREG_CREG0_BODLVL1_LEVEL_0_INTERRUPT = 0x0
	// Level 1 interrupt
	CREG_CREG0_BODLVL1_LEVEL_1_INTERRUPT = 0x1
	// Level 2 interrupt
	CREG_CREG0_BODLVL1_LEVEL_2_INTERRUPT = 0x2
	// Level 3 interrupt
	CREG_CREG0_BODLVL1_LEVEL_3_INTERRUPT = 0x3
	// Position of BODLVL2 field.
	CREG_CREG0_BODLVL2_Pos = 0xa
	// Bit mask of BODLVL2 field.
	CREG_CREG0_BODLVL2_Msk = 0xc00
	// Level 0 reset
	CREG_CREG0_BODLVL2_LEVEL_0_RESET = 0x0
	// Level 1 reset
	CREG_CREG0_BODLVL2_LEVEL_1_RESET = 0x1
	// Level 2 reset
	CREG_CREG0_BODLVL2_LEVEL_2_RESET = 0x2
	// Level 3 reset
	CREG_CREG0_BODLVL2_LEVEL_3_RESET = 0x3
	// Position of SAMPLECTRL field.
	CREG_CREG0_SAMPLECTRL_Pos = 0xc
	// Bit mask of SAMPLECTRL field.
	CREG_CREG0_SAMPLECTRL_Msk = 0x3000
	// Sample output from the event monitor/recorder.
	CREG_CREG0_SAMPLECTRL_SAMPLE_OUTPUT_FROM_T = 0x1
	// Output from the event router.
	CREG_CREG0_SAMPLECTRL_OUTPUT_FROM_THE_EVEN = 0x2
	// Position of WAKEUP0CTRL field.
	CREG_CREG0_WAKEUP0CTRL_Pos = 0xe
	// Bit mask of WAKEUP0CTRL field.
	CREG_CREG0_WAKEUP0CTRL_Msk = 0xc000
	// Output from the event router.
	CREG_CREG0_WAKEUP0CTRL_OUTPUT_FROM_THE_EVEN = 0x1
	// Position of WAKEUP1CTRL field.
	CREG_CREG0_WAKEUP1CTRL_Pos = 0x10
	// Bit mask of WAKEUP1CTRL field.
	CREG_CREG0_WAKEUP1CTRL_Msk = 0x30000
	// Output from the event router.
	CREG_CREG0_WAKEUP1CTRL_OUTPUT_FROM_THE_EVEN = 0x1
	// Position of RESERVED field.
	CREG_CREG0_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	CREG_CREG0_RESERVED_Msk = 0xfffc0000

	// M3MEMMAP: ARM Cortex-M3 memory mapping
	// Position of M3MAP field.
	CREG_M3MEMMAP_M3MAP_Pos = 0xc
	// Bit mask of M3MAP field.
	CREG_M3MEMMAP_M3MAP_Msk = 0xfffff000

	// CREG5: Chip configuration register 5. Controls JTAG access.
	// Position of RESERVED field.
	CREG_CREG5_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CREG_CREG5_RESERVED_Msk = 0x7ff
	// Position of M3TAPSEL field.
	CREG_CREG5_M3TAPSEL_Pos = 0xb
	// Bit mask of M3TAPSEL field.
	CREG_CREG5_M3TAPSEL_Msk = 0x800
	// Bit M3TAPSEL.
	CREG_CREG5_M3TAPSEL = 0x800
	// No effect.
	CREG_CREG5_M3TAPSEL_NO_EFFECT = 0x0
	// Disable JTAG debug. Once JTAG is disabled, JTAG access remains disabled until the chip is reset by any source.
	CREG_CREG5_M3TAPSEL_DISABLE_JTAG_DEBUG = 0x1
	// Position of RESERVED field.
	CREG_CREG5_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CREG_CREG5_RESERVED_Msk = 0xfffff000

	// DMAMUX: DMA mux control
	// Position of DMAMUXPER0 field.
	CREG_DMAMUX_DMAMUXPER0_Pos = 0x0
	// Bit mask of DMAMUXPER0 field.
	CREG_DMAMUX_DMAMUXPER0_Msk = 0x3
	// SPIFI
	CREG_DMAMUX_DMAMUXPER0_SPIFI = 0x0
	// SCT CTOUT_2
	CREG_DMAMUX_DMAMUXPER0_SCT_CTOUT_2 = 0x1
	// Timer3 match 1
	CREG_DMAMUX_DMAMUXPER0_TIMER3_MATCH_1 = 0x3
	// Position of DMAMUXPER1 field.
	CREG_DMAMUX_DMAMUXPER1_Pos = 0x2
	// Bit mask of DMAMUXPER1 field.
	CREG_DMAMUX_DMAMUXPER1_Msk = 0xc
	// Timer0 match 0
	CREG_DMAMUX_DMAMUXPER1_TIMER0_MATCH_0 = 0x0
	// USART0 transmit
	CREG_DMAMUX_DMAMUXPER1_USART0_TRANSMIT = 0x1
	// Position of DMAMUXPER2 field.
	CREG_DMAMUX_DMAMUXPER2_Pos = 0x4
	// Bit mask of DMAMUXPER2 field.
	CREG_DMAMUX_DMAMUXPER2_Msk = 0x30
	// Timer0 match 1
	CREG_DMAMUX_DMAMUXPER2_TIMER0_MATCH_1 = 0x0
	// USART0 receive
	CREG_DMAMUX_DMAMUXPER2_USART0_RECEIVE = 0x1
	// Position of DMAMUXPER3 field.
	CREG_DMAMUX_DMAMUXPER3_Pos = 0x6
	// Bit mask of DMAMUXPER3 field.
	CREG_DMAMUX_DMAMUXPER3_Msk = 0xc0
	// Timer1 match 0
	CREG_DMAMUX_DMAMUXPER3_TIMER1_MATCH_0 = 0x0
	// UART1 transmit
	CREG_DMAMUX_DMAMUXPER3_UART1_TRANSMIT = 0x1
	// I2S1 DMA request 1
	CREG_DMAMUX_DMAMUXPER3_I2S1_DMA_REQUEST_1 = 0x2
	// SSP1 transmit
	CREG_DMAMUX_DMAMUXPER3_SSP1_TRANSMIT = 0x3
	// Position of DMAMUXPER4 field.
	CREG_DMAMUX_DMAMUXPER4_Pos = 0x8
	// Bit mask of DMAMUXPER4 field.
	CREG_DMAMUX_DMAMUXPER4_Msk = 0x300
	// Timer1 match 1
	CREG_DMAMUX_DMAMUXPER4_TIMER1_MATCH_1 = 0x0
	// UART1 receive
	CREG_DMAMUX_DMAMUXPER4_UART1_RECEIVE = 0x1
	// I2S1 DMA request 2
	CREG_DMAMUX_DMAMUXPER4_I2S1_DMA_REQUEST_2 = 0x2
	// SSP1 receive
	CREG_DMAMUX_DMAMUXPER4_SSP1_RECEIVE = 0x3
	// Position of DMAMUXPER5 field.
	CREG_DMAMUX_DMAMUXPER5_Pos = 0xa
	// Bit mask of DMAMUXPER5 field.
	CREG_DMAMUX_DMAMUXPER5_Msk = 0xc00
	// Timer2 match 0
	CREG_DMAMUX_DMAMUXPER5_TIMER2_MATCH_0 = 0x0
	// USART2 transmit
	CREG_DMAMUX_DMAMUXPER5_USART2_TRANSMIT = 0x1
	// SSP1 transmit
	CREG_DMAMUX_DMAMUXPER5_SSP1_TRANSMIT = 0x2
	// Position of DMAMUXPER6 field.
	CREG_DMAMUX_DMAMUXPER6_Pos = 0xc
	// Bit mask of DMAMUXPER6 field.
	CREG_DMAMUX_DMAMUXPER6_Msk = 0x3000
	// Timer2 match 1
	CREG_DMAMUX_DMAMUXPER6_TIMER2_MATCH_1 = 0x0
	// USART2 receive
	CREG_DMAMUX_DMAMUXPER6_USART2_RECEIVE = 0x1
	// SSP1 receive
	CREG_DMAMUX_DMAMUXPER6_SSP1_RECEIVE = 0x2
	// Position of DMAMUXPER7 field.
	CREG_DMAMUX_DMAMUXPER7_Pos = 0xe
	// Bit mask of DMAMUXPER7 field.
	CREG_DMAMUX_DMAMUXPER7_Msk = 0xc000
	// Timer3 match 0
	CREG_DMAMUX_DMAMUXPER7_TIMER3_MATCH_0 = 0x0
	// USART3 transmit
	CREG_DMAMUX_DMAMUXPER7_USART3_TRANSMIT = 0x1
	// SCT DMA request 0
	CREG_DMAMUX_DMAMUXPER7_SCT_DMA_REQUEST_0 = 0x2
	// Position of DMAMUXPER8 field.
	CREG_DMAMUX_DMAMUXPER8_Pos = 0x10
	// Bit mask of DMAMUXPER8 field.
	CREG_DMAMUX_DMAMUXPER8_Msk = 0x30000
	// Timer3 match 1
	CREG_DMAMUX_DMAMUXPER8_TIMER3_MATCH_1 = 0x0
	// USART3 receive
	CREG_DMAMUX_DMAMUXPER8_USART3_RECEIVE = 0x1
	// SCT DMA request 1
	CREG_DMAMUX_DMAMUXPER8_SCT_DMA_REQUEST_1 = 0x2
	// Position of DMAMUXPER9 field.
	CREG_DMAMUX_DMAMUXPER9_Pos = 0x12
	// Bit mask of DMAMUXPER9 field.
	CREG_DMAMUX_DMAMUXPER9_Msk = 0xc0000
	// SSP0 receive
	CREG_DMAMUX_DMAMUXPER9_SSP0_RECEIVE = 0x0
	// I2S0 DMA request 1
	CREG_DMAMUX_DMAMUXPER9_I2S0_DMA_REQUEST_1 = 0x1
	// SCT DMA request 1
	CREG_DMAMUX_DMAMUXPER9_SCT_DMA_REQUEST_1 = 0x2
	// Position of DMAMUXPER10 field.
	CREG_DMAMUX_DMAMUXPER10_Pos = 0x14
	// Bit mask of DMAMUXPER10 field.
	CREG_DMAMUX_DMAMUXPER10_Msk = 0x300000
	// SSP0 transmit
	CREG_DMAMUX_DMAMUXPER10_SSP0_TRANSMIT = 0x0
	// I2S0 DMA request 2
	CREG_DMAMUX_DMAMUXPER10_I2S0_DMA_REQUEST_2 = 0x1
	// SCT DMA request 0
	CREG_DMAMUX_DMAMUXPER10_SCT_DMA_REQUEST_0 = 0x2
	// Position of DMAMUXPER11 field.
	CREG_DMAMUX_DMAMUXPER11_Pos = 0x16
	// Bit mask of DMAMUXPER11 field.
	CREG_DMAMUX_DMAMUXPER11_Msk = 0xc00000
	// SSP1 receive
	CREG_DMAMUX_DMAMUXPER11_SSP1_RECEIVE = 0x0
	// USART0 transmit
	CREG_DMAMUX_DMAMUXPER11_USART0_TRANSMIT = 0x2
	// Position of DMAMUXPER12 field.
	CREG_DMAMUX_DMAMUXPER12_Pos = 0x18
	// Bit mask of DMAMUXPER12 field.
	CREG_DMAMUX_DMAMUXPER12_Msk = 0x3000000
	// SSP1 transmit
	CREG_DMAMUX_DMAMUXPER12_SSP1_TRANSMIT = 0x0
	// USART0 receive
	CREG_DMAMUX_DMAMUXPER12_USART0_RECEIVE = 0x2
	// Position of DMAMUXPER13 field.
	CREG_DMAMUX_DMAMUXPER13_Pos = 0x1a
	// Bit mask of DMAMUXPER13 field.
	CREG_DMAMUX_DMAMUXPER13_Msk = 0xc000000
	// ADC0
	CREG_DMAMUX_DMAMUXPER13_ADC0 = 0x0
	// SSP1 receive
	CREG_DMAMUX_DMAMUXPER13_SSP1_RECEIVE = 0x2
	// USART3 receive
	CREG_DMAMUX_DMAMUXPER13_USART3_RECEIVE = 0x3
	// Position of DMAMUXPER14 field.
	CREG_DMAMUX_DMAMUXPER14_Pos = 0x1c
	// Bit mask of DMAMUXPER14 field.
	CREG_DMAMUX_DMAMUXPER14_Msk = 0x30000000
	// ADC1
	CREG_DMAMUX_DMAMUXPER14_ADC1 = 0x0
	// SSP1 transmit
	CREG_DMAMUX_DMAMUXPER14_SSP1_TRANSMIT = 0x2
	// USART3 transmit
	CREG_DMAMUX_DMAMUXPER14_USART3_TRANSMIT = 0x3
	// Position of DMAMUXPER15 field.
	CREG_DMAMUX_DMAMUXPER15_Pos = 0x1e
	// Bit mask of DMAMUXPER15 field.
	CREG_DMAMUX_DMAMUXPER15_Msk = 0xc0000000
	// DAC
	CREG_DMAMUX_DMAMUXPER15_DAC = 0x0
	// SCT CTOUT_3
	CREG_DMAMUX_DMAMUXPER15_SCT_CTOUT_3 = 0x1
	// Timer3 match 0
	CREG_DMAMUX_DMAMUXPER15_TIMER3_MATCH_0 = 0x3

	// FLASHCFGA: Flash accelerator configuration register for flash bank A
	// Position of RESERVED field.
	CREG_FLASHCFGA_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CREG_FLASHCFGA_RESERVED_Msk = 0xfff
	// Position of FLASHTIM field.
	CREG_FLASHCFGA_FLASHTIM_Pos = 0xc
	// Bit mask of FLASHTIM field.
	CREG_FLASHCFGA_FLASHTIM_Msk = 0xf000
	// 1 BASE_M3_CLK clock. Use for BASE_M3_CLK up to 21 MHz.
	CREG_FLASHCFGA_FLASHTIM_1_BASE_M3_CLK_CLOCK = 0x0
	// 2 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 43 MHz.
	CREG_FLASHCFGA_FLASHTIM_2_BASE_M3_CLK_CLOCKS = 0x1
	// 3 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 64 MHz.
	CREG_FLASHCFGA_FLASHTIM_3_BASE_M3_CLK_CLOCKS = 0x2
	// 4 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 86 MHz.
	CREG_FLASHCFGA_FLASHTIM_4_BASE_M3_CLK_CLOCKS = 0x3
	// 5 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 107 MHz.
	CREG_FLASHCFGA_FLASHTIM_5_BASE_M3_CLK_CLOCKS = 0x4
	// 6 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 129 MHz.
	CREG_FLASHCFGA_FLASHTIM_6_BASE_M3_CLK_CLOCKS = 0x5
	// 7 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 150 MHz.
	CREG_FLASHCFGA_FLASHTIM_7_BASE_M3_CLK_CLOCKS = 0x6
	// 8 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 172 MHz.
	CREG_FLASHCFGA_FLASHTIM_8_BASE_M3_CLK_CLOCKS = 0x7
	// 9 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 180 MHz.
	CREG_FLASHCFGA_FLASHTIM_9_BASE_M3_CLK_CLOCKS = 0x8
	// Position of RESERVED field.
	CREG_FLASHCFGA_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	CREG_FLASHCFGA_RESERVED_Msk = 0x7fff0000
	// Position of POW field.
	CREG_FLASHCFGA_POW_Pos = 0x1f
	// Bit mask of POW field.
	CREG_FLASHCFGA_POW_Msk = 0x80000000
	// Bit POW.
	CREG_FLASHCFGA_POW = 0x80000000
	// Power-down
	CREG_FLASHCFGA_POW_POWER_DOWN = 0x0
	// Active (Default)
	CREG_FLASHCFGA_POW_ACTIVE = 0x1

	// FLASHCFGB: Flash accelerator configuration register for flash bank B
	// Position of RESERVED field.
	CREG_FLASHCFGB_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CREG_FLASHCFGB_RESERVED_Msk = 0xfff
	// Position of FLASHTIM field.
	CREG_FLASHCFGB_FLASHTIM_Pos = 0xc
	// Bit mask of FLASHTIM field.
	CREG_FLASHCFGB_FLASHTIM_Msk = 0xf000
	// 1 BASE_M3_CLK clock. Use for BASE_M3_CLK up to 21 MHz.
	CREG_FLASHCFGB_FLASHTIM_1_BASE_M3_CLK_CLOCK = 0x0
	// 2 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 43 MHz.
	CREG_FLASHCFGB_FLASHTIM_2_BASE_M3_CLK_CLOCKS = 0x1
	// 3 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 64 MHz.
	CREG_FLASHCFGB_FLASHTIM_3_BASE_M3_CLK_CLOCKS = 0x2
	// 4 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 86 MHz.
	CREG_FLASHCFGB_FLASHTIM_4_BASE_M3_CLK_CLOCKS = 0x3
	// 5 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 107 MHz.
	CREG_FLASHCFGB_FLASHTIM_5_BASE_M3_CLK_CLOCKS = 0x4
	// 6 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 129 MHz.
	CREG_FLASHCFGB_FLASHTIM_6_BASE_M3_CLK_CLOCKS = 0x5
	// 7 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 150 MHz.
	CREG_FLASHCFGB_FLASHTIM_7_BASE_M3_CLK_CLOCKS = 0x6
	// 8 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 172 MHz.
	CREG_FLASHCFGB_FLASHTIM_8_BASE_M3_CLK_CLOCKS = 0x7
	// 9 BASE_M3_CLK clocks. Use for BASE_M3_CLK up to 180 MHz.
	CREG_FLASHCFGB_FLASHTIM_9_BASE_M3_CLK_CLOCKS = 0x8
	// Position of RESERVED field.
	CREG_FLASHCFGB_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	CREG_FLASHCFGB_RESERVED_Msk = 0x7fff0000
	// Position of POW field.
	CREG_FLASHCFGB_POW_Pos = 0x1f
	// Bit mask of POW field.
	CREG_FLASHCFGB_POW_Msk = 0x80000000
	// Bit POW.
	CREG_FLASHCFGB_POW = 0x80000000
	// Power-down
	CREG_FLASHCFGB_POW_POWER_DOWN = 0x0
	// Active (Default)
	CREG_FLASHCFGB_POW_ACTIVE = 0x1

	// ETBCFG: ETB RAM configuration
	// Position of ETB field.
	CREG_ETBCFG_ETB_Pos = 0x0
	// Bit mask of ETB field.
	CREG_ETBCFG_ETB_Msk = 0x1
	// Bit ETB.
	CREG_ETBCFG_ETB = 0x1
	// ETB accesses SRAM at address 0x2000 C000.
	CREG_ETBCFG_ETB_ETB_ACCESSES_SRAM_AT = 0x0
	// AHB accesses SRAM at address 0x2000 C000.
	CREG_ETBCFG_ETB_AHB_ACCESSES_SRAM_AT = 0x1
	// Position of RESERVED field.
	CREG_ETBCFG_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CREG_ETBCFG_RESERVED_Msk = 0xfffffffe

	// CREG6: Chip configuration register 6. Controls multiple functions : Ethernet interface, SCT output, I2S0/1 inputs, EMC clock.
	// Position of ETHMODE field.
	CREG_CREG6_ETHMODE_Pos = 0x0
	// Bit mask of ETHMODE field.
	CREG_CREG6_ETHMODE_Msk = 0x7
	// MII
	CREG_CREG6_ETHMODE_MII = 0x0
	// RMII
	CREG_CREG6_ETHMODE_RMII = 0x4
	// Position of RESERVED field.
	CREG_CREG6_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CREG_CREG6_RESERVED_Msk = 0x8
	// Bit RESERVED.
	CREG_CREG6_RESERVED = 0x8
	// Position of CTOUTCTRL field.
	CREG_CREG6_CTOUTCTRL_Pos = 0x4
	// Bit mask of CTOUTCTRL field.
	CREG_CREG6_CTOUTCTRL_Msk = 0x10
	// Bit CTOUTCTRL.
	CREG_CREG6_CTOUTCTRL = 0x10
	// Combine SCT and timer match outputs. SCT outputs are Red with timer outputs.
	CREG_CREG6_CTOUTCTRL_COMBINE_SCT_AND_TIME = 0x0
	// SCT outputs only. SCT outputs are used without timer match outputs.
	CREG_CREG6_CTOUTCTRL_SCT_OUTPUTS_ONLY = 0x1
	// Position of RESERVED field.
	CREG_CREG6_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	CREG_CREG6_RESERVED_Msk = 0xfe0
	// Position of I2S0_TX_SCK_IN_SEL field.
	CREG_CREG6_I2S0_TX_SCK_IN_SEL_Pos = 0xc
	// Bit mask of I2S0_TX_SCK_IN_SEL field.
	CREG_CREG6_I2S0_TX_SCK_IN_SEL_Msk = 0x1000
	// Bit I2S0_TX_SCK_IN_SEL.
	CREG_CREG6_I2S0_TX_SCK_IN_SEL = 0x1000
	// I2S Register. I2S clock selected as defined by the I2S transmit mode register Table 960.
	CREG_CREG6_I2S0_TX_SCK_IN_SEL_I2S_REGISTER = 0x0
	// BASE_AUDIO_CLK for I2S transmit clock MCLK input and MCLK output. The I2S must be configured in slave mode.
	CREG_CREG6_I2S0_TX_SCK_IN_SEL_BASE_AUDIO_CLK_FOR_I = 0x1
	// Position of I2S0_RX_SCK_IN_SEL field.
	CREG_CREG6_I2S0_RX_SCK_IN_SEL_Pos = 0xd
	// Bit mask of I2S0_RX_SCK_IN_SEL field.
	CREG_CREG6_I2S0_RX_SCK_IN_SEL_Msk = 0x2000
	// Bit I2S0_RX_SCK_IN_SEL.
	CREG_CREG6_I2S0_RX_SCK_IN_SEL = 0x2000
	// I2S Register. I2S clock selected as defined by the I2S receive mode register Table 961.
	CREG_CREG6_I2S0_RX_SCK_IN_SEL_I2S_REGISTER = 0x0
	// BASE_AUDIO_CLK for I2S receive clock MCLK input and MCLK output. The I2S must be configured in slave mode.
	CREG_CREG6_I2S0_RX_SCK_IN_SEL_BASE_AUDIO_CLK_FOR_I = 0x1
	// Position of I2S1_TX_SCK_IN_SEL field.
	CREG_CREG6_I2S1_TX_SCK_IN_SEL_Pos = 0xe
	// Bit mask of I2S1_TX_SCK_IN_SEL field.
	CREG_CREG6_I2S1_TX_SCK_IN_SEL_Msk = 0x4000
	// Bit I2S1_TX_SCK_IN_SEL.
	CREG_CREG6_I2S1_TX_SCK_IN_SEL = 0x4000
	// I2S register. I2S clock selected as defined by the I2S transmit mode register Table 960.
	CREG_CREG6_I2S1_TX_SCK_IN_SEL_I2S_REGISTER = 0x0
	// BASE_AUDIO_CLK for I2S transmit clock MCLK input and MCLK output. The I2S must be configured in slave mode.
	CREG_CREG6_I2S1_TX_SCK_IN_SEL_BASE_AUDIO_CLK_FOR_I = 0x1
	// Position of I2S1_RX_SCK_IN_SEL field.
	CREG_CREG6_I2S1_RX_SCK_IN_SEL_Pos = 0xf
	// Bit mask of I2S1_RX_SCK_IN_SEL field.
	CREG_CREG6_I2S1_RX_SCK_IN_SEL_Msk = 0x8000
	// Bit I2S1_RX_SCK_IN_SEL.
	CREG_CREG6_I2S1_RX_SCK_IN_SEL = 0x8000
	// I2S register. I2S clock selected as defined by the I2S receive mode register Table 961.
	CREG_CREG6_I2S1_RX_SCK_IN_SEL_I2S_REGISTER = 0x0
	// BASE_AUDIO_CLK for I2S receive clock MCLK input and MCLK output. The I2S must be configured in slave mode.
	CREG_CREG6_I2S1_RX_SCK_IN_SEL_BASE_AUDIO_CLK_FOR_I = 0x1
	// Position of EMC_CLK_SEL field.
	CREG_CREG6_EMC_CLK_SEL_Pos = 0x10
	// Bit mask of EMC_CLK_SEL field.
	CREG_CREG6_EMC_CLK_SEL_Msk = 0x10000
	// Bit EMC_CLK_SEL.
	CREG_CREG6_EMC_CLK_SEL = 0x10000
	// Divide by 1. EMC_CLK_DIV not divided.
	CREG_CREG6_EMC_CLK_SEL_DIVIDE_BY_1 = 0x0
	// Divide by 2. EMC_CLK_DIV divided by 2.
	CREG_CREG6_EMC_CLK_SEL_DIVIDE_BY_2 = 0x1
	// Position of RESERVED field.
	CREG_CREG6_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	CREG_CREG6_RESERVED_Msk = 0xfffe0000

	// CHIPID: Part ID
	// Position of ID field.
	CREG_CHIPID_ID_Pos = 0x0
	// Bit mask of ID field.
	CREG_CHIPID_ID_Msk = 0xffffffff

	// USB0FLADJ: USB0 frame length adjust register
	// Position of FLTV field.
	CREG_USB0FLADJ_FLTV_Pos = 0x0
	// Bit mask of FLTV field.
	CREG_USB0FLADJ_FLTV_Msk = 0x3f
	// Position of RESERVED field.
	CREG_USB0FLADJ_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CREG_USB0FLADJ_RESERVED_Msk = 0xffffffc0

	// USB1FLADJ: USB1 frame length adjust register
	// Position of FLTV field.
	CREG_USB1FLADJ_FLTV_Pos = 0x0
	// Bit mask of FLTV field.
	CREG_USB1FLADJ_FLTV_Msk = 0x3f
	// Position of RESERVED field.
	CREG_USB1FLADJ_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CREG_USB1FLADJ_RESERVED_Msk = 0xffffffc0
)

// Constants for EVENTROUTER: Event router
const (
	// HILO: Level configuration register
	// Position of WAKEUP0_L field.
	EVENTROUTER_HILO_WAKEUP0_L_Pos = 0x0
	// Bit mask of WAKEUP0_L field.
	EVENTROUTER_HILO_WAKEUP0_L_Msk = 0x1
	// Bit WAKEUP0_L.
	EVENTROUTER_HILO_WAKEUP0_L = 0x1
	// Detect LOW level on the WAKEUP0 pin if bit 0 in the EDGE register is 0. Detect falling edge if bit 0 in the EDGE register is 1.
	EVENTROUTER_HILO_WAKEUP0_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level on the WAKEUP0 pin if bit 0 in the EDGE register is 0. Detect rising edge if bit 0 in the EDGE register is 1.
	EVENTROUTER_HILO_WAKEUP0_L_DETECT_HIGH_LEVEL = 0x1
	// Position of WAKEUP1_L field.
	EVENTROUTER_HILO_WAKEUP1_L_Pos = 0x1
	// Bit mask of WAKEUP1_L field.
	EVENTROUTER_HILO_WAKEUP1_L_Msk = 0x2
	// Bit WAKEUP1_L.
	EVENTROUTER_HILO_WAKEUP1_L = 0x2
	// Detect LOW level on the WAKEUP1 pin if bit 1 in the EDGE register is 0.
	EVENTROUTER_HILO_WAKEUP1_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level on the WAKEUP1 pin if bit 1 in the EDGE register is 0. Detect rising edge if bit 1 in the EDGE register is 1.
	EVENTROUTER_HILO_WAKEUP1_L_DETECT_HIGH_LEVEL = 0x1
	// Position of WAKEUP2_L field.
	EVENTROUTER_HILO_WAKEUP2_L_Pos = 0x2
	// Bit mask of WAKEUP2_L field.
	EVENTROUTER_HILO_WAKEUP2_L_Msk = 0x4
	// Bit WAKEUP2_L.
	EVENTROUTER_HILO_WAKEUP2_L = 0x4
	// Detect LOW level on the WAKEUP2 pin if bit 2 in the EDGE register is 0. Detect falling edge if bit 2 in the EDGE register is 1.
	EVENTROUTER_HILO_WAKEUP2_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level on the WAKEUP2 pin if bit 2 in the EDGE register is 0. Detect rising edge if bit 2 in the EDGE register is 1.
	EVENTROUTER_HILO_WAKEUP2_L_DETECT_HIGH_LEVEL = 0x1
	// Position of WAKEUP3_L field.
	EVENTROUTER_HILO_WAKEUP3_L_Pos = 0x3
	// Bit mask of WAKEUP3_L field.
	EVENTROUTER_HILO_WAKEUP3_L_Msk = 0x8
	// Bit WAKEUP3_L.
	EVENTROUTER_HILO_WAKEUP3_L = 0x8
	// Detect LOW level on the WAKEUP3 pin if bit 3 in the EDGE register is 0. Detect falling edge if bit 3 in the EDGE register is 1.
	EVENTROUTER_HILO_WAKEUP3_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level on the WAKEUP3 pin if bit 3 in the EDGE register is 0. Detect rising edge if bit 3 in the EDGE register is 1.
	EVENTROUTER_HILO_WAKEUP3_L_DETECT_HIGH_LEVEL = 0x1
	// Position of ATIMER_L field.
	EVENTROUTER_HILO_ATIMER_L_Pos = 0x4
	// Bit mask of ATIMER_L field.
	EVENTROUTER_HILO_ATIMER_L_Msk = 0x10
	// Bit ATIMER_L.
	EVENTROUTER_HILO_ATIMER_L = 0x10
	// Detect LOW level of the alarm timer interrupt if bit 4 in the EDGE register is 0. Detect falling edge if bit 4 in the EDGE register is 1.
	EVENTROUTER_HILO_ATIMER_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the alarm timer interrupt if bit 4 in the EDGE register is 0. Detect rising edge if bit 4 in the EDGE register is 1.
	EVENTROUTER_HILO_ATIMER_L_DETECT_HIGH_LEVEL = 0x1
	// Position of RTC_L field.
	EVENTROUTER_HILO_RTC_L_Pos = 0x5
	// Bit mask of RTC_L field.
	EVENTROUTER_HILO_RTC_L_Msk = 0x20
	// Bit RTC_L.
	EVENTROUTER_HILO_RTC_L = 0x20
	// Detect LOW level of the RTC interrupt if bit 5 in the EDGE register is 0. Detect falling edge if bit 5 in the EDGE register is 1.
	EVENTROUTER_HILO_RTC_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the RTC interrupt if bit 5 in the EDGE register is 0. Detect rising edge if bit 5 in the EDGE register is 1.
	EVENTROUTER_HILO_RTC_L_DETECT_HIGH_LEVEL = 0x1
	// Position of BOD_L field.
	EVENTROUTER_HILO_BOD_L_Pos = 0x6
	// Bit mask of BOD_L field.
	EVENTROUTER_HILO_BOD_L_Msk = 0x40
	// Bit BOD_L.
	EVENTROUTER_HILO_BOD_L = 0x40
	// Detect LOW level of the BOD interrupt if bit 6 in the EDGE register is 0. Detect falling edge if bit 6 in the EDGE register is 1.
	EVENTROUTER_HILO_BOD_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the BOD interrupt if bit 6 in the EDGE register is 0. Detect rising edge if bit 6 in the EDGE register is 1.
	EVENTROUTER_HILO_BOD_L_DETECT_HIGH_LEVEL = 0x1
	// Position of WWDT_L field.
	EVENTROUTER_HILO_WWDT_L_Pos = 0x7
	// Bit mask of WWDT_L field.
	EVENTROUTER_HILO_WWDT_L_Msk = 0x80
	// Bit WWDT_L.
	EVENTROUTER_HILO_WWDT_L = 0x80
	// Detect LOW level of the WWDT interrupt if bit 7 in the EDGE register is 0. Detect falling edge if bit 7 in the EDGE register is 1.
	EVENTROUTER_HILO_WWDT_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the WWDT interrupt if bit 7 in the EDGE register is 0. Detect rising edge if bit 7 in the EDGE register is 1.
	EVENTROUTER_HILO_WWDT_L_DETECT_HIGH_LEVEL = 0x1
	// Position of ETH_L field.
	EVENTROUTER_HILO_ETH_L_Pos = 0x8
	// Bit mask of ETH_L field.
	EVENTROUTER_HILO_ETH_L_Msk = 0x100
	// Bit ETH_L.
	EVENTROUTER_HILO_ETH_L = 0x100
	// Detect LOW level of the Ethernet interrupt if bit 8 in the EDGE register is 0. Detect falling edge if bit 8 in the EDGE register is 1.
	EVENTROUTER_HILO_ETH_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the Ethernet interrupt if bit 8 in the EDGE register is 0. Detect rising edge if bit 8 in the EDGE register is 1.
	EVENTROUTER_HILO_ETH_L_DETECT_HIGH_LEVEL = 0x1
	// Position of USB0_L field.
	EVENTROUTER_HILO_USB0_L_Pos = 0x9
	// Bit mask of USB0_L field.
	EVENTROUTER_HILO_USB0_L_Msk = 0x200
	// Bit USB0_L.
	EVENTROUTER_HILO_USB0_L = 0x200
	// Detect LOW level of the USB0 interrupt if bit 9 in the EDGE register is 0. Detect falling edge if bit 9 in the EDGE register is 1.
	EVENTROUTER_HILO_USB0_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the USB0 interrupt if bit 9 in the EDGE register is 0. Detect rising edge if bit 9 in the EDGE register is 1.
	EVENTROUTER_HILO_USB0_L_DETECT_HIGH_LEVEL = 0x1
	// Position of USB1_L field.
	EVENTROUTER_HILO_USB1_L_Pos = 0xa
	// Bit mask of USB1_L field.
	EVENTROUTER_HILO_USB1_L_Msk = 0x400
	// Bit USB1_L.
	EVENTROUTER_HILO_USB1_L = 0x400
	// Detect LOW level of the USB1 interrupt if bit 10 in the EDGE register is 0. Detect falling edge if bit 10 in the EDGE register is 1.
	EVENTROUTER_HILO_USB1_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the USB1 interrupt if bit 10 in the EDGE register is 0. Detect rising edge if bit 10 in the EDGE register is 1.
	EVENTROUTER_HILO_USB1_L_DETECT_HIGH_LEVEL = 0x1
	// Position of SDMMC_L field.
	EVENTROUTER_HILO_SDMMC_L_Pos = 0xb
	// Bit mask of SDMMC_L field.
	EVENTROUTER_HILO_SDMMC_L_Msk = 0x800
	// Bit SDMMC_L.
	EVENTROUTER_HILO_SDMMC_L = 0x800
	// Detect LOW level of the SD/MMC interrupt if bit 11 in the EDGE register is 0. Detect falling edge if bit 11 in the EDGE register is 1.
	EVENTROUTER_HILO_SDMMC_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the SD/MMC interrupt if bit 11 in the EDGE register is 0. Detect rising edge if bit 11 in the EDGE register is 1.
	EVENTROUTER_HILO_SDMMC_L_DETECT_HIGH_LEVEL = 0x1
	// Position of CAN_L field.
	EVENTROUTER_HILO_CAN_L_Pos = 0xc
	// Bit mask of CAN_L field.
	EVENTROUTER_HILO_CAN_L_Msk = 0x1000
	// Bit CAN_L.
	EVENTROUTER_HILO_CAN_L = 0x1000
	// Detect LOW level of the combined C_CAN interrupt if bit 12 in the EDGE register is 0. Detect falling edge if bit 12 in the EDGE register is 1.
	EVENTROUTER_HILO_CAN_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the combined C_CAN interrupt if bit 12 in the EDGE register is 0. Detect rising edge if bit 12 in the EDGE register is 1.
	EVENTROUTER_HILO_CAN_L_DETECT_HIGH_LEVEL = 0x1
	// Position of TIM2_L field.
	EVENTROUTER_HILO_TIM2_L_Pos = 0xd
	// Bit mask of TIM2_L field.
	EVENTROUTER_HILO_TIM2_L_Msk = 0x2000
	// Bit TIM2_L.
	EVENTROUTER_HILO_TIM2_L = 0x2000
	// Detect LOW level GIMA output 25 if bit 13 in the EDGE register is 0. Detect falling edge if bit 13 in the EDGE register is 1.
	EVENTROUTER_HILO_TIM2_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level GIMA output 25 if bit 13 in the EDGE register is 0. Detect rising edge if bit 13 in the EDGE register is 1.
	EVENTROUTER_HILO_TIM2_L_DETECT_HIGH_LEVEL = 0x1
	// Position of TIM6_L field.
	EVENTROUTER_HILO_TIM6_L_Pos = 0xe
	// Bit mask of TIM6_L field.
	EVENTROUTER_HILO_TIM6_L_Msk = 0x4000
	// Bit TIM6_L.
	EVENTROUTER_HILO_TIM6_L = 0x4000
	// Detect LOW level of GIMA output 26 if bit 14 in the EDGE register is 0. Detect falling edge if bit 14 in the EDGE register is 1.
	EVENTROUTER_HILO_TIM6_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of GIMA output 26 if bit 14 in the EDGE register is 0. Detect rising edge if bit 14 in the EDGE register is 1.
	EVENTROUTER_HILO_TIM6_L_DETECT_HIGH_LEVEL = 0x1
	// Position of QEI_L field.
	EVENTROUTER_HILO_QEI_L_Pos = 0xf
	// Bit mask of QEI_L field.
	EVENTROUTER_HILO_QEI_L_Msk = 0x8000
	// Bit QEI_L.
	EVENTROUTER_HILO_QEI_L = 0x8000
	// Detect LOW level of the QEI interrupt if bit 15 in the EDGE register is 0. Detect falling edge if bit 15 in the EDGE register is 1.
	EVENTROUTER_HILO_QEI_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of the QEI interrupt if bit 15 in the EDGE register is 0. Detect rising edge if bit 15 in the EDGE register is 1.
	EVENTROUTER_HILO_QEI_L_DETECT_HIGH_LEVEL = 0x1
	// Position of TIM14_L field.
	EVENTROUTER_HILO_TIM14_L_Pos = 0x10
	// Bit mask of TIM14_L field.
	EVENTROUTER_HILO_TIM14_L_Msk = 0x10000
	// Bit TIM14_L.
	EVENTROUTER_HILO_TIM14_L = 0x10000
	// Detect LOW level of GIMA output 27 if bit 16 in the EDGE register is 0. Detect falling edge if bit 16 in the EDGE register is 1.
	EVENTROUTER_HILO_TIM14_L_DETECT_LOW_LEVEL = 0x0
	// Detect HIGH level of GIMA output 27 if bit 16 in the EDGE register is 0. Detect rising edge if bit 16 in the EDGE register is 1.
	EVENTROUTER_HILO_TIM14_L_DETECT_HIGH_LEVEL = 0x1
	// Position of RESERVED field.
	EVENTROUTER_HILO_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	EVENTROUTER_HILO_RESERVED_Msk = 0x60000
	// Position of RESET_L field.
	EVENTROUTER_HILO_RESET_L_Pos = 0x13
	// Bit mask of RESET_L field.
	EVENTROUTER_HILO_RESET_L_Msk = 0x80000
	// Bit RESET_L.
	EVENTROUTER_HILO_RESET_L = 0x80000
	// Detect LOW level if bit 17 in the EDGE register is 0. Detect falling edge if bit 17 in the EDGE register is 1.
	EVENTROUTER_HILO_RESET_L_DETECT_LOW_LEVEL_IF = 0x0
	// Detect HIGH level if bit 17 in the EDGE register is 0. Detect rising edge if bit 17 in the EDGE register is 1.
	EVENTROUTER_HILO_RESET_L_DETECT_HIGH_LEVEL_IF = 0x1
	// Position of BODRESET_L field.
	EVENTROUTER_HILO_BODRESET_L_Pos = 0x14
	// Bit mask of BODRESET_L field.
	EVENTROUTER_HILO_BODRESET_L_Msk = 0x100000
	// Bit BODRESET_L.
	EVENTROUTER_HILO_BODRESET_L = 0x100000
	// Detect LOW level if bit 20 in the EDGE register is 0. Detect falling edge if bit 20 in the EDGE register is 1.
	EVENTROUTER_HILO_BODRESET_L_DETECT_LOW_LEVEL_IF = 0x0
	// Detect HIGH level if bit 20 in the EDGE register is 0. Detect rising edge if bit 20 in the EDGE register is 1.
	EVENTROUTER_HILO_BODRESET_L_DETECT_HIGH_LEVEL_IF = 0x1
	// Position of DPDRESET_L field.
	EVENTROUTER_HILO_DPDRESET_L_Pos = 0x15
	// Bit mask of DPDRESET_L field.
	EVENTROUTER_HILO_DPDRESET_L_Msk = 0x200000
	// Bit DPDRESET_L.
	EVENTROUTER_HILO_DPDRESET_L = 0x200000
	// Detect LOW level if bit 21 in the EDGE register is 0. Detect falling edge if bit 21 in the EDGE register is 1.
	EVENTROUTER_HILO_DPDRESET_L_DETECT_LOW_LEVEL_IF = 0x0
	// Detect HIGH level if bit 21 in the EDGE register is 0. Detect rising edge if bit 21 in the EDGE register is 1.
	EVENTROUTER_HILO_DPDRESET_L_DETECT_HIGH_LEVEL_IF = 0x1
	// Position of RESERVED field.
	EVENTROUTER_HILO_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	EVENTROUTER_HILO_RESERVED_Msk = 0xffc00000

	// EDGE: Edge configuration
	// Position of WAKEUP0_E field.
	EVENTROUTER_EDGE_WAKEUP0_E_Pos = 0x0
	// Bit mask of WAKEUP0_E field.
	EVENTROUTER_EDGE_WAKEUP0_E_Msk = 0x1
	// Bit WAKEUP0_E.
	EVENTROUTER_EDGE_WAKEUP0_E = 0x1
	// Level detect.
	EVENTROUTER_EDGE_WAKEUP0_E_LEVEL_DETECT = 0x0
	// Edge detect of WAKEUP0 pin. Detect falling edge if bit 0 in the HILO register is 0. Detect rising edge if bit 0 in the HILO register is 1.
	EVENTROUTER_EDGE_WAKEUP0_E_EDGE_DETECT_OF_WAKEU = 0x1
	// Position of WAKEUP1_E field.
	EVENTROUTER_EDGE_WAKEUP1_E_Pos = 0x1
	// Bit mask of WAKEUP1_E field.
	EVENTROUTER_EDGE_WAKEUP1_E_Msk = 0x2
	// Bit WAKEUP1_E.
	EVENTROUTER_EDGE_WAKEUP1_E = 0x2
	// Level detect.
	EVENTROUTER_EDGE_WAKEUP1_E_LEVEL_DETECT = 0x0
	// Edge detect of WAKEUP1 pin. Detect falling edge if bit 1 in the HILO register is 0. Detect rising edge if bit 1 in the HILO register is 1.
	EVENTROUTER_EDGE_WAKEUP1_E_EDGE_DETECT_OF_WAKEU = 0x1
	// Position of WAKEUP2_E field.
	EVENTROUTER_EDGE_WAKEUP2_E_Pos = 0x2
	// Bit mask of WAKEUP2_E field.
	EVENTROUTER_EDGE_WAKEUP2_E_Msk = 0x4
	// Bit WAKEUP2_E.
	EVENTROUTER_EDGE_WAKEUP2_E = 0x4
	// Level detect.
	EVENTROUTER_EDGE_WAKEUP2_E_LEVEL_DETECT = 0x0
	// Edge detect of WAKEUP2 pin. Detect falling edge if bit 2 in the HILO register is 0. Detect rising edge if bit 2 in the HILO register is 1.
	EVENTROUTER_EDGE_WAKEUP2_E_EDGE_DETECT_OF_WAKEU = 0x1
	// Position of WAKEUP3_E field.
	EVENTROUTER_EDGE_WAKEUP3_E_Pos = 0x3
	// Bit mask of WAKEUP3_E field.
	EVENTROUTER_EDGE_WAKEUP3_E_Msk = 0x8
	// Bit WAKEUP3_E.
	EVENTROUTER_EDGE_WAKEUP3_E = 0x8
	// Level detect.
	EVENTROUTER_EDGE_WAKEUP3_E_LEVEL_DETECT = 0x0
	// Edge detect of WAKEUP3 pin. Detect falling edge if bit 30 in the HILO register is 0. Detect rising edge if bit 3 in the HILO register is 1.
	EVENTROUTER_EDGE_WAKEUP3_E_EDGE_DETECT_OF_WAKEU = 0x1
	// Position of ATIMER_E field.
	EVENTROUTER_EDGE_ATIMER_E_Pos = 0x4
	// Bit mask of ATIMER_E field.
	EVENTROUTER_EDGE_ATIMER_E_Msk = 0x10
	// Bit ATIMER_E.
	EVENTROUTER_EDGE_ATIMER_E = 0x10
	// Level detect.
	EVENTROUTER_EDGE_ATIMER_E_LEVEL_DETECT = 0x0
	// Edge detect of the alarm timer interrupt. Detect falling edge if bit 4 in the HILO register is 0. Detect rising edge if bit 4 in the HILO register is 1.
	EVENTROUTER_EDGE_ATIMER_E_EDGE_DETECT_OF_THE_A = 0x1
	// Position of RTC_E field.
	EVENTROUTER_EDGE_RTC_E_Pos = 0x5
	// Bit mask of RTC_E field.
	EVENTROUTER_EDGE_RTC_E_Msk = 0x20
	// Bit RTC_E.
	EVENTROUTER_EDGE_RTC_E = 0x20
	// Level detect.
	EVENTROUTER_EDGE_RTC_E_LEVEL_DETECT = 0x0
	// Edge detect of the RTC interrupt. Detect falling edge if bit 5 in the HILO register is 0. Detect rising edge if bit 5 in the HILO register is 1.
	EVENTROUTER_EDGE_RTC_E_EDGE_DETECT_OF_THE_R = 0x1
	// Position of BOD_E field.
	EVENTROUTER_EDGE_BOD_E_Pos = 0x6
	// Bit mask of BOD_E field.
	EVENTROUTER_EDGE_BOD_E_Msk = 0x40
	// Bit BOD_E.
	EVENTROUTER_EDGE_BOD_E = 0x40
	// Level detect.
	EVENTROUTER_EDGE_BOD_E_LEVEL_DETECT = 0x0
	// Edge detect of the BOD interrupt. Detect falling edge if bit 6 in the HILO register is 0. Detect rising edge if bit 6 in the HILO register is 1.
	EVENTROUTER_EDGE_BOD_E_EDGE_DETECT_OF_THE_B = 0x1
	// Position of WWDT_E field.
	EVENTROUTER_EDGE_WWDT_E_Pos = 0x7
	// Bit mask of WWDT_E field.
	EVENTROUTER_EDGE_WWDT_E_Msk = 0x80
	// Bit WWDT_E.
	EVENTROUTER_EDGE_WWDT_E = 0x80
	// Level detect.
	EVENTROUTER_EDGE_WWDT_E_LEVEL_DETECT = 0x0
	// Edge detect of the WWDT interrupt. Detect falling edge if bit 7 in the HILO register is 0. Detect rising edge if bit 7 in the HILO register is 1.
	EVENTROUTER_EDGE_WWDT_E_EDGE_DETECT_OF_THE_W = 0x1
	// Position of ETH_E field.
	EVENTROUTER_EDGE_ETH_E_Pos = 0x8
	// Bit mask of ETH_E field.
	EVENTROUTER_EDGE_ETH_E_Msk = 0x100
	// Bit ETH_E.
	EVENTROUTER_EDGE_ETH_E = 0x100
	// Level detect.
	EVENTROUTER_EDGE_ETH_E_LEVEL_DETECT = 0x0
	// Edge detect of the Ethernet interrupt. Detect falling edge if bit 8 in the HILO register is 0. Detect rising edge if bit 8 in the HILO register is 1.
	EVENTROUTER_EDGE_ETH_E_EDGE_DETECT_OF_THE_E = 0x1
	// Position of USB0_E field.
	EVENTROUTER_EDGE_USB0_E_Pos = 0x9
	// Bit mask of USB0_E field.
	EVENTROUTER_EDGE_USB0_E_Msk = 0x200
	// Bit USB0_E.
	EVENTROUTER_EDGE_USB0_E = 0x200
	// Level detect.
	EVENTROUTER_EDGE_USB0_E_LEVEL_DETECT = 0x0
	// Edge detect of the USB0 event. Detect falling edge if bit 9 in the HILO register is 0. Detect rising edge if bit 9 in the HILO register is 1.
	EVENTROUTER_EDGE_USB0_E_EDGE_DETECT_OF_THE_U = 0x1
	// Position of USB1_E field.
	EVENTROUTER_EDGE_USB1_E_Pos = 0xa
	// Bit mask of USB1_E field.
	EVENTROUTER_EDGE_USB1_E_Msk = 0x400
	// Bit USB1_E.
	EVENTROUTER_EDGE_USB1_E = 0x400
	// Level detect.
	EVENTROUTER_EDGE_USB1_E_LEVEL_DETECT = 0x0
	// Edge detect of the USB1 interrupt. Detect falling edge if bit 10 in the HILO register is 0. Detect rising edge if bit 10 in the HILO register is 1.
	EVENTROUTER_EDGE_USB1_E_EDGE_DETECT_OF_THE_U = 0x1
	// Position of SDMMC_E field.
	EVENTROUTER_EDGE_SDMMC_E_Pos = 0xb
	// Bit mask of SDMMC_E field.
	EVENTROUTER_EDGE_SDMMC_E_Msk = 0x800
	// Bit SDMMC_E.
	EVENTROUTER_EDGE_SDMMC_E = 0x800
	// Level detect.
	EVENTROUTER_EDGE_SDMMC_E_LEVEL_DETECT = 0x0
	// Edge detect of the SD/MMC interrupt. Detect falling edge if bit 10 in the HILO register is 0. Detect rising edge if bit 10 in the HILO register is 1.
	EVENTROUTER_EDGE_SDMMC_E_EDGE_DETECT_OF_THE_S = 0x1
	// Position of CAN_E field.
	EVENTROUTER_EDGE_CAN_E_Pos = 0xc
	// Bit mask of CAN_E field.
	EVENTROUTER_EDGE_CAN_E_Msk = 0x1000
	// Bit CAN_E.
	EVENTROUTER_EDGE_CAN_E = 0x1000
	// Level detect.
	EVENTROUTER_EDGE_CAN_E_LEVEL_DETECT = 0x0
	// Edge detect of the combined C_CAN interrupt. Detect falling edge if bit 12 in the HILO register is 0. Detect rising edge if bit 12 in the HILO register is 1.
	EVENTROUTER_EDGE_CAN_E_EDGE_DETECT_OF_THE_C = 0x1
	// Position of TIM2_E field.
	EVENTROUTER_EDGE_TIM2_E_Pos = 0xd
	// Bit mask of TIM2_E field.
	EVENTROUTER_EDGE_TIM2_E_Msk = 0x2000
	// Bit TIM2_E.
	EVENTROUTER_EDGE_TIM2_E = 0x2000
	// Level detect.
	EVENTROUTER_EDGE_TIM2_E_LEVEL_DETECT = 0x0
	// Edge detect of GIMA output 25. Detect falling edge if bit 13 in the HILO register is 0. Detect rising edge if bit 13 in the HILO register is 1.
	EVENTROUTER_EDGE_TIM2_E_EDGE_DETECT_OF_GIMA = 0x1
	// Position of TIM6_E field.
	EVENTROUTER_EDGE_TIM6_E_Pos = 0xe
	// Bit mask of TIM6_E field.
	EVENTROUTER_EDGE_TIM6_E_Msk = 0x4000
	// Bit TIM6_E.
	EVENTROUTER_EDGE_TIM6_E = 0x4000
	// Level detect.
	EVENTROUTER_EDGE_TIM6_E_LEVEL_DETECT = 0x0
	// Edge detect of GIMA output 26. Detect falling edge if bit 14 in the HILO register is 0. Detect rising edge if bit 14 in the HILO register is 1.
	EVENTROUTER_EDGE_TIM6_E_EDGE_DETECT_OF_GIMA = 0x1
	// Position of QEI_E field.
	EVENTROUTER_EDGE_QEI_E_Pos = 0xf
	// Bit mask of QEI_E field.
	EVENTROUTER_EDGE_QEI_E_Msk = 0x8000
	// Bit QEI_E.
	EVENTROUTER_EDGE_QEI_E = 0x8000
	// Level detect.
	EVENTROUTER_EDGE_QEI_E_LEVEL_DETECT = 0x0
	// Edge detect of QEI interrupt. Detect falling edge if bit 15 in the HILO register is 0. Detect rising edge if bit 15 in the HILO register is 1.
	EVENTROUTER_EDGE_QEI_E_EDGE_DETECT_OF_QEI_I = 0x1
	// Position of TIM14_E field.
	EVENTROUTER_EDGE_TIM14_E_Pos = 0x10
	// Bit mask of TIM14_E field.
	EVENTROUTER_EDGE_TIM14_E_Msk = 0x10000
	// Bit TIM14_E.
	EVENTROUTER_EDGE_TIM14_E = 0x10000
	// Level detect.
	EVENTROUTER_EDGE_TIM14_E_LEVEL_DETECT = 0x0
	// Edge detect of GIMA output 27. Detect falling edge if bit 16 in the HILO register is 0. Detect rising edge if bit 16 in the HILO register is 1.
	EVENTROUTER_EDGE_TIM14_E_EDGE_DETECT_OF_GIMA = 0x1
	// Position of RESERVED field.
	EVENTROUTER_EDGE_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	EVENTROUTER_EDGE_RESERVED_Msk = 0x60000
	// Position of RESET_E field.
	EVENTROUTER_EDGE_RESET_E_Pos = 0x13
	// Bit mask of RESET_E field.
	EVENTROUTER_EDGE_RESET_E_Msk = 0x80000
	// Bit RESET_E.
	EVENTROUTER_EDGE_RESET_E = 0x80000
	// Level detect.
	EVENTROUTER_EDGE_RESET_E_LEVEL_DETECT = 0x0
	// Edge detect of the reset signal. Detect falling edge if bit 19 in the HILO register is 0. Detect rising edge if bit 19 in the HILO register is 1.
	EVENTROUTER_EDGE_RESET_E_EDGE_DETECT_OF_THE_R = 0x1
	// Position of BODRESET_E field.
	EVENTROUTER_EDGE_BODRESET_E_Pos = 0x14
	// Bit mask of BODRESET_E field.
	EVENTROUTER_EDGE_BODRESET_E_Msk = 0x100000
	// Bit BODRESET_E.
	EVENTROUTER_EDGE_BODRESET_E = 0x100000
	// Level detect.
	EVENTROUTER_EDGE_BODRESET_E_LEVEL_DETECT = 0x0
	// Edge detect of the reset signal. Detect falling edge if bit 20 in the HILO register is 0. Detect rising edge if bit 19 in the HILO register is 1.
	EVENTROUTER_EDGE_BODRESET_E_EDGE_DETECT_OF_THE_R = 0x1
	// Position of DPDRESET_E field.
	EVENTROUTER_EDGE_DPDRESET_E_Pos = 0x15
	// Bit mask of DPDRESET_E field.
	EVENTROUTER_EDGE_DPDRESET_E_Msk = 0x200000
	// Bit DPDRESET_E.
	EVENTROUTER_EDGE_DPDRESET_E = 0x200000
	// Level detect.
	EVENTROUTER_EDGE_DPDRESET_E_LEVEL_DETECT = 0x0
	// Edge detect of the reset signal. Detect falling edge if bit 21 in the HILO register is 0. Detect rising edge if bit 21 in the HILO register is 1.
	EVENTROUTER_EDGE_DPDRESET_E_EDGE_DETECT_OF_THE_R = 0x1
	// Position of RESERVED field.
	EVENTROUTER_EDGE_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	EVENTROUTER_EDGE_RESERVED_Msk = 0xffc00000

	// CLR_EN: Clear event enable register
	// Position of WAKEUP0_CLREN field.
	EVENTROUTER_CLR_EN_WAKEUP0_CLREN_Pos = 0x0
	// Bit mask of WAKEUP0_CLREN field.
	EVENTROUTER_CLR_EN_WAKEUP0_CLREN_Msk = 0x1
	// Bit WAKEUP0_CLREN.
	EVENTROUTER_CLR_EN_WAKEUP0_CLREN = 0x1
	// Position of WAKEUP1_CLREN field.
	EVENTROUTER_CLR_EN_WAKEUP1_CLREN_Pos = 0x1
	// Bit mask of WAKEUP1_CLREN field.
	EVENTROUTER_CLR_EN_WAKEUP1_CLREN_Msk = 0x2
	// Bit WAKEUP1_CLREN.
	EVENTROUTER_CLR_EN_WAKEUP1_CLREN = 0x2
	// Position of WAKEUP2_CLREN field.
	EVENTROUTER_CLR_EN_WAKEUP2_CLREN_Pos = 0x2
	// Bit mask of WAKEUP2_CLREN field.
	EVENTROUTER_CLR_EN_WAKEUP2_CLREN_Msk = 0x4
	// Bit WAKEUP2_CLREN.
	EVENTROUTER_CLR_EN_WAKEUP2_CLREN = 0x4
	// Position of WAKEUP3_CLREN field.
	EVENTROUTER_CLR_EN_WAKEUP3_CLREN_Pos = 0x3
	// Bit mask of WAKEUP3_CLREN field.
	EVENTROUTER_CLR_EN_WAKEUP3_CLREN_Msk = 0x8
	// Bit WAKEUP3_CLREN.
	EVENTROUTER_CLR_EN_WAKEUP3_CLREN = 0x8
	// Position of ATIMER_CLREN field.
	EVENTROUTER_CLR_EN_ATIMER_CLREN_Pos = 0x4
	// Bit mask of ATIMER_CLREN field.
	EVENTROUTER_CLR_EN_ATIMER_CLREN_Msk = 0x10
	// Bit ATIMER_CLREN.
	EVENTROUTER_CLR_EN_ATIMER_CLREN = 0x10
	// Position of RTC_CLREN field.
	EVENTROUTER_CLR_EN_RTC_CLREN_Pos = 0x5
	// Bit mask of RTC_CLREN field.
	EVENTROUTER_CLR_EN_RTC_CLREN_Msk = 0x20
	// Bit RTC_CLREN.
	EVENTROUTER_CLR_EN_RTC_CLREN = 0x20
	// Position of BOD_CLREN field.
	EVENTROUTER_CLR_EN_BOD_CLREN_Pos = 0x6
	// Bit mask of BOD_CLREN field.
	EVENTROUTER_CLR_EN_BOD_CLREN_Msk = 0x40
	// Bit BOD_CLREN.
	EVENTROUTER_CLR_EN_BOD_CLREN = 0x40
	// Position of WWDT_CLREN field.
	EVENTROUTER_CLR_EN_WWDT_CLREN_Pos = 0x7
	// Bit mask of WWDT_CLREN field.
	EVENTROUTER_CLR_EN_WWDT_CLREN_Msk = 0x80
	// Bit WWDT_CLREN.
	EVENTROUTER_CLR_EN_WWDT_CLREN = 0x80
	// Position of ETH_CLREN field.
	EVENTROUTER_CLR_EN_ETH_CLREN_Pos = 0x8
	// Bit mask of ETH_CLREN field.
	EVENTROUTER_CLR_EN_ETH_CLREN_Msk = 0x100
	// Bit ETH_CLREN.
	EVENTROUTER_CLR_EN_ETH_CLREN = 0x100
	// Position of USB0_CLREN field.
	EVENTROUTER_CLR_EN_USB0_CLREN_Pos = 0x9
	// Bit mask of USB0_CLREN field.
	EVENTROUTER_CLR_EN_USB0_CLREN_Msk = 0x200
	// Bit USB0_CLREN.
	EVENTROUTER_CLR_EN_USB0_CLREN = 0x200
	// Position of USB1_CLREN field.
	EVENTROUTER_CLR_EN_USB1_CLREN_Pos = 0xa
	// Bit mask of USB1_CLREN field.
	EVENTROUTER_CLR_EN_USB1_CLREN_Msk = 0x400
	// Bit USB1_CLREN.
	EVENTROUTER_CLR_EN_USB1_CLREN = 0x400
	// Position of SDMMC_CLREN field.
	EVENTROUTER_CLR_EN_SDMMC_CLREN_Pos = 0xb
	// Bit mask of SDMMC_CLREN field.
	EVENTROUTER_CLR_EN_SDMMC_CLREN_Msk = 0x800
	// Bit SDMMC_CLREN.
	EVENTROUTER_CLR_EN_SDMMC_CLREN = 0x800
	// Position of CAN_CLREN field.
	EVENTROUTER_CLR_EN_CAN_CLREN_Pos = 0xc
	// Bit mask of CAN_CLREN field.
	EVENTROUTER_CLR_EN_CAN_CLREN_Msk = 0x1000
	// Bit CAN_CLREN.
	EVENTROUTER_CLR_EN_CAN_CLREN = 0x1000
	// Position of TIM2_CLREN field.
	EVENTROUTER_CLR_EN_TIM2_CLREN_Pos = 0xd
	// Bit mask of TIM2_CLREN field.
	EVENTROUTER_CLR_EN_TIM2_CLREN_Msk = 0x2000
	// Bit TIM2_CLREN.
	EVENTROUTER_CLR_EN_TIM2_CLREN = 0x2000
	// Position of TIM6_CLREN field.
	EVENTROUTER_CLR_EN_TIM6_CLREN_Pos = 0xe
	// Bit mask of TIM6_CLREN field.
	EVENTROUTER_CLR_EN_TIM6_CLREN_Msk = 0x4000
	// Bit TIM6_CLREN.
	EVENTROUTER_CLR_EN_TIM6_CLREN = 0x4000
	// Position of QEI_CLREN field.
	EVENTROUTER_CLR_EN_QEI_CLREN_Pos = 0xf
	// Bit mask of QEI_CLREN field.
	EVENTROUTER_CLR_EN_QEI_CLREN_Msk = 0x8000
	// Bit QEI_CLREN.
	EVENTROUTER_CLR_EN_QEI_CLREN = 0x8000
	// Position of TIM14_CLREN field.
	EVENTROUTER_CLR_EN_TIM14_CLREN_Pos = 0x10
	// Bit mask of TIM14_CLREN field.
	EVENTROUTER_CLR_EN_TIM14_CLREN_Msk = 0x10000
	// Bit TIM14_CLREN.
	EVENTROUTER_CLR_EN_TIM14_CLREN = 0x10000
	// Position of RESERVED field.
	EVENTROUTER_CLR_EN_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	EVENTROUTER_CLR_EN_RESERVED_Msk = 0x60000
	// Position of RESET_CLREN field.
	EVENTROUTER_CLR_EN_RESET_CLREN_Pos = 0x13
	// Bit mask of RESET_CLREN field.
	EVENTROUTER_CLR_EN_RESET_CLREN_Msk = 0x80000
	// Bit RESET_CLREN.
	EVENTROUTER_CLR_EN_RESET_CLREN = 0x80000
	// Position of BODRESET_CLREN field.
	EVENTROUTER_CLR_EN_BODRESET_CLREN_Pos = 0x14
	// Bit mask of BODRESET_CLREN field.
	EVENTROUTER_CLR_EN_BODRESET_CLREN_Msk = 0x100000
	// Bit BODRESET_CLREN.
	EVENTROUTER_CLR_EN_BODRESET_CLREN = 0x100000
	// Position of DPDRESET_CLREN field.
	EVENTROUTER_CLR_EN_DPDRESET_CLREN_Pos = 0x15
	// Bit mask of DPDRESET_CLREN field.
	EVENTROUTER_CLR_EN_DPDRESET_CLREN_Msk = 0x200000
	// Bit DPDRESET_CLREN.
	EVENTROUTER_CLR_EN_DPDRESET_CLREN = 0x200000
	// Position of RESERVED field.
	EVENTROUTER_CLR_EN_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	EVENTROUTER_CLR_EN_RESERVED_Msk = 0xffc00000

	// SET_EN: Set event enable register
	// Position of WAKEUP0_SETEN field.
	EVENTROUTER_SET_EN_WAKEUP0_SETEN_Pos = 0x0
	// Bit mask of WAKEUP0_SETEN field.
	EVENTROUTER_SET_EN_WAKEUP0_SETEN_Msk = 0x1
	// Bit WAKEUP0_SETEN.
	EVENTROUTER_SET_EN_WAKEUP0_SETEN = 0x1
	// Position of WAKEUP1_SETEN field.
	EVENTROUTER_SET_EN_WAKEUP1_SETEN_Pos = 0x1
	// Bit mask of WAKEUP1_SETEN field.
	EVENTROUTER_SET_EN_WAKEUP1_SETEN_Msk = 0x2
	// Bit WAKEUP1_SETEN.
	EVENTROUTER_SET_EN_WAKEUP1_SETEN = 0x2
	// Position of WAKEUP2_SETEN field.
	EVENTROUTER_SET_EN_WAKEUP2_SETEN_Pos = 0x2
	// Bit mask of WAKEUP2_SETEN field.
	EVENTROUTER_SET_EN_WAKEUP2_SETEN_Msk = 0x4
	// Bit WAKEUP2_SETEN.
	EVENTROUTER_SET_EN_WAKEUP2_SETEN = 0x4
	// Position of WAKEUP3_SETEN field.
	EVENTROUTER_SET_EN_WAKEUP3_SETEN_Pos = 0x3
	// Bit mask of WAKEUP3_SETEN field.
	EVENTROUTER_SET_EN_WAKEUP3_SETEN_Msk = 0x8
	// Bit WAKEUP3_SETEN.
	EVENTROUTER_SET_EN_WAKEUP3_SETEN = 0x8
	// Position of ATIMER_SETEN field.
	EVENTROUTER_SET_EN_ATIMER_SETEN_Pos = 0x4
	// Bit mask of ATIMER_SETEN field.
	EVENTROUTER_SET_EN_ATIMER_SETEN_Msk = 0x10
	// Bit ATIMER_SETEN.
	EVENTROUTER_SET_EN_ATIMER_SETEN = 0x10
	// Position of RTC_SETEN field.
	EVENTROUTER_SET_EN_RTC_SETEN_Pos = 0x5
	// Bit mask of RTC_SETEN field.
	EVENTROUTER_SET_EN_RTC_SETEN_Msk = 0x20
	// Bit RTC_SETEN.
	EVENTROUTER_SET_EN_RTC_SETEN = 0x20
	// Position of BOD_SETEN field.
	EVENTROUTER_SET_EN_BOD_SETEN_Pos = 0x6
	// Bit mask of BOD_SETEN field.
	EVENTROUTER_SET_EN_BOD_SETEN_Msk = 0x40
	// Bit BOD_SETEN.
	EVENTROUTER_SET_EN_BOD_SETEN = 0x40
	// Position of WWDT_SETEN field.
	EVENTROUTER_SET_EN_WWDT_SETEN_Pos = 0x7
	// Bit mask of WWDT_SETEN field.
	EVENTROUTER_SET_EN_WWDT_SETEN_Msk = 0x80
	// Bit WWDT_SETEN.
	EVENTROUTER_SET_EN_WWDT_SETEN = 0x80
	// Position of ETH_SETEN field.
	EVENTROUTER_SET_EN_ETH_SETEN_Pos = 0x8
	// Bit mask of ETH_SETEN field.
	EVENTROUTER_SET_EN_ETH_SETEN_Msk = 0x100
	// Bit ETH_SETEN.
	EVENTROUTER_SET_EN_ETH_SETEN = 0x100
	// Position of USB0_SETEN field.
	EVENTROUTER_SET_EN_USB0_SETEN_Pos = 0x9
	// Bit mask of USB0_SETEN field.
	EVENTROUTER_SET_EN_USB0_SETEN_Msk = 0x200
	// Bit USB0_SETEN.
	EVENTROUTER_SET_EN_USB0_SETEN = 0x200
	// Position of USB1_SETEN field.
	EVENTROUTER_SET_EN_USB1_SETEN_Pos = 0xa
	// Bit mask of USB1_SETEN field.
	EVENTROUTER_SET_EN_USB1_SETEN_Msk = 0x400
	// Bit USB1_SETEN.
	EVENTROUTER_SET_EN_USB1_SETEN = 0x400
	// Position of SDMMC_SETEN field.
	EVENTROUTER_SET_EN_SDMMC_SETEN_Pos = 0xb
	// Bit mask of SDMMC_SETEN field.
	EVENTROUTER_SET_EN_SDMMC_SETEN_Msk = 0x800
	// Bit SDMMC_SETEN.
	EVENTROUTER_SET_EN_SDMMC_SETEN = 0x800
	// Position of CAN_SETEN field.
	EVENTROUTER_SET_EN_CAN_SETEN_Pos = 0xc
	// Bit mask of CAN_SETEN field.
	EVENTROUTER_SET_EN_CAN_SETEN_Msk = 0x1000
	// Bit CAN_SETEN.
	EVENTROUTER_SET_EN_CAN_SETEN = 0x1000
	// Position of TIM2_SETEN field.
	EVENTROUTER_SET_EN_TIM2_SETEN_Pos = 0xd
	// Bit mask of TIM2_SETEN field.
	EVENTROUTER_SET_EN_TIM2_SETEN_Msk = 0x2000
	// Bit TIM2_SETEN.
	EVENTROUTER_SET_EN_TIM2_SETEN = 0x2000
	// Position of TIM6_SETEN field.
	EVENTROUTER_SET_EN_TIM6_SETEN_Pos = 0xe
	// Bit mask of TIM6_SETEN field.
	EVENTROUTER_SET_EN_TIM6_SETEN_Msk = 0x4000
	// Bit TIM6_SETEN.
	EVENTROUTER_SET_EN_TIM6_SETEN = 0x4000
	// Position of QEI_SETEN field.
	EVENTROUTER_SET_EN_QEI_SETEN_Pos = 0xf
	// Bit mask of QEI_SETEN field.
	EVENTROUTER_SET_EN_QEI_SETEN_Msk = 0x8000
	// Bit QEI_SETEN.
	EVENTROUTER_SET_EN_QEI_SETEN = 0x8000
	// Position of TIM14_SETEN field.
	EVENTROUTER_SET_EN_TIM14_SETEN_Pos = 0x10
	// Bit mask of TIM14_SETEN field.
	EVENTROUTER_SET_EN_TIM14_SETEN_Msk = 0x10000
	// Bit TIM14_SETEN.
	EVENTROUTER_SET_EN_TIM14_SETEN = 0x10000
	// Position of RESERVED field.
	EVENTROUTER_SET_EN_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	EVENTROUTER_SET_EN_RESERVED_Msk = 0x60000
	// Position of RESET_SETEN field.
	EVENTROUTER_SET_EN_RESET_SETEN_Pos = 0x13
	// Bit mask of RESET_SETEN field.
	EVENTROUTER_SET_EN_RESET_SETEN_Msk = 0x80000
	// Bit RESET_SETEN.
	EVENTROUTER_SET_EN_RESET_SETEN = 0x80000
	// Position of BODRESET_SETEN field.
	EVENTROUTER_SET_EN_BODRESET_SETEN_Pos = 0x14
	// Bit mask of BODRESET_SETEN field.
	EVENTROUTER_SET_EN_BODRESET_SETEN_Msk = 0x100000
	// Bit BODRESET_SETEN.
	EVENTROUTER_SET_EN_BODRESET_SETEN = 0x100000
	// Position of DPDRESET_SETEN field.
	EVENTROUTER_SET_EN_DPDRESET_SETEN_Pos = 0x15
	// Bit mask of DPDRESET_SETEN field.
	EVENTROUTER_SET_EN_DPDRESET_SETEN_Msk = 0x200000
	// Bit DPDRESET_SETEN.
	EVENTROUTER_SET_EN_DPDRESET_SETEN = 0x200000
	// Position of RESERVED field.
	EVENTROUTER_SET_EN_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	EVENTROUTER_SET_EN_RESERVED_Msk = 0xffc00000

	// STATUS: Event Status register
	// Position of WAKEUP0_ST field.
	EVENTROUTER_STATUS_WAKEUP0_ST_Pos = 0x0
	// Bit mask of WAKEUP0_ST field.
	EVENTROUTER_STATUS_WAKEUP0_ST_Msk = 0x1
	// Bit WAKEUP0_ST.
	EVENTROUTER_STATUS_WAKEUP0_ST = 0x1
	// Position of WAKEUP1_ST field.
	EVENTROUTER_STATUS_WAKEUP1_ST_Pos = 0x1
	// Bit mask of WAKEUP1_ST field.
	EVENTROUTER_STATUS_WAKEUP1_ST_Msk = 0x2
	// Bit WAKEUP1_ST.
	EVENTROUTER_STATUS_WAKEUP1_ST = 0x2
	// Position of WAKEUP2_ST field.
	EVENTROUTER_STATUS_WAKEUP2_ST_Pos = 0x2
	// Bit mask of WAKEUP2_ST field.
	EVENTROUTER_STATUS_WAKEUP2_ST_Msk = 0x4
	// Bit WAKEUP2_ST.
	EVENTROUTER_STATUS_WAKEUP2_ST = 0x4
	// Position of WAKEUP3_ST field.
	EVENTROUTER_STATUS_WAKEUP3_ST_Pos = 0x3
	// Bit mask of WAKEUP3_ST field.
	EVENTROUTER_STATUS_WAKEUP3_ST_Msk = 0x8
	// Bit WAKEUP3_ST.
	EVENTROUTER_STATUS_WAKEUP3_ST = 0x8
	// Position of ATIMER_ST field.
	EVENTROUTER_STATUS_ATIMER_ST_Pos = 0x4
	// Bit mask of ATIMER_ST field.
	EVENTROUTER_STATUS_ATIMER_ST_Msk = 0x10
	// Bit ATIMER_ST.
	EVENTROUTER_STATUS_ATIMER_ST = 0x10
	// Position of RTC_ST field.
	EVENTROUTER_STATUS_RTC_ST_Pos = 0x5
	// Bit mask of RTC_ST field.
	EVENTROUTER_STATUS_RTC_ST_Msk = 0x20
	// Bit RTC_ST.
	EVENTROUTER_STATUS_RTC_ST = 0x20
	// Position of BOD_ST field.
	EVENTROUTER_STATUS_BOD_ST_Pos = 0x6
	// Bit mask of BOD_ST field.
	EVENTROUTER_STATUS_BOD_ST_Msk = 0x40
	// Bit BOD_ST.
	EVENTROUTER_STATUS_BOD_ST = 0x40
	// Position of WWDT_ST field.
	EVENTROUTER_STATUS_WWDT_ST_Pos = 0x7
	// Bit mask of WWDT_ST field.
	EVENTROUTER_STATUS_WWDT_ST_Msk = 0x80
	// Bit WWDT_ST.
	EVENTROUTER_STATUS_WWDT_ST = 0x80
	// Position of ETH_ST field.
	EVENTROUTER_STATUS_ETH_ST_Pos = 0x8
	// Bit mask of ETH_ST field.
	EVENTROUTER_STATUS_ETH_ST_Msk = 0x100
	// Bit ETH_ST.
	EVENTROUTER_STATUS_ETH_ST = 0x100
	// Position of USB0_ST field.
	EVENTROUTER_STATUS_USB0_ST_Pos = 0x9
	// Bit mask of USB0_ST field.
	EVENTROUTER_STATUS_USB0_ST_Msk = 0x200
	// Bit USB0_ST.
	EVENTROUTER_STATUS_USB0_ST = 0x200
	// Position of USB1_ST field.
	EVENTROUTER_STATUS_USB1_ST_Pos = 0xa
	// Bit mask of USB1_ST field.
	EVENTROUTER_STATUS_USB1_ST_Msk = 0x400
	// Bit USB1_ST.
	EVENTROUTER_STATUS_USB1_ST = 0x400
	// Position of SDMMC_ST field.
	EVENTROUTER_STATUS_SDMMC_ST_Pos = 0xb
	// Bit mask of SDMMC_ST field.
	EVENTROUTER_STATUS_SDMMC_ST_Msk = 0x800
	// Bit SDMMC_ST.
	EVENTROUTER_STATUS_SDMMC_ST = 0x800
	// Position of CAN_ST field.
	EVENTROUTER_STATUS_CAN_ST_Pos = 0xc
	// Bit mask of CAN_ST field.
	EVENTROUTER_STATUS_CAN_ST_Msk = 0x1000
	// Bit CAN_ST.
	EVENTROUTER_STATUS_CAN_ST = 0x1000
	// Position of TIM2_ST field.
	EVENTROUTER_STATUS_TIM2_ST_Pos = 0xd
	// Bit mask of TIM2_ST field.
	EVENTROUTER_STATUS_TIM2_ST_Msk = 0x2000
	// Bit TIM2_ST.
	EVENTROUTER_STATUS_TIM2_ST = 0x2000
	// Position of TIM6_ST field.
	EVENTROUTER_STATUS_TIM6_ST_Pos = 0xe
	// Bit mask of TIM6_ST field.
	EVENTROUTER_STATUS_TIM6_ST_Msk = 0x4000
	// Bit TIM6_ST.
	EVENTROUTER_STATUS_TIM6_ST = 0x4000
	// Position of QEI_ST field.
	EVENTROUTER_STATUS_QEI_ST_Pos = 0xf
	// Bit mask of QEI_ST field.
	EVENTROUTER_STATUS_QEI_ST_Msk = 0x8000
	// Bit QEI_ST.
	EVENTROUTER_STATUS_QEI_ST = 0x8000
	// Position of TIM14_ST field.
	EVENTROUTER_STATUS_TIM14_ST_Pos = 0x10
	// Bit mask of TIM14_ST field.
	EVENTROUTER_STATUS_TIM14_ST_Msk = 0x10000
	// Bit TIM14_ST.
	EVENTROUTER_STATUS_TIM14_ST = 0x10000
	// Position of RESERVED field.
	EVENTROUTER_STATUS_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	EVENTROUTER_STATUS_RESERVED_Msk = 0x60000
	// Position of RESET_ST field.
	EVENTROUTER_STATUS_RESET_ST_Pos = 0x13
	// Bit mask of RESET_ST field.
	EVENTROUTER_STATUS_RESET_ST_Msk = 0x80000
	// Bit RESET_ST.
	EVENTROUTER_STATUS_RESET_ST = 0x80000
	// Position of BODRESET_ST field.
	EVENTROUTER_STATUS_BODRESET_ST_Pos = 0x14
	// Bit mask of BODRESET_ST field.
	EVENTROUTER_STATUS_BODRESET_ST_Msk = 0x100000
	// Bit BODRESET_ST.
	EVENTROUTER_STATUS_BODRESET_ST = 0x100000
	// Position of DPDRESET_ST field.
	EVENTROUTER_STATUS_DPDRESET_ST_Pos = 0x15
	// Bit mask of DPDRESET_ST field.
	EVENTROUTER_STATUS_DPDRESET_ST_Msk = 0x200000
	// Bit DPDRESET_ST.
	EVENTROUTER_STATUS_DPDRESET_ST = 0x200000
	// Position of RESERVED field.
	EVENTROUTER_STATUS_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	EVENTROUTER_STATUS_RESERVED_Msk = 0xffc00000

	// ENABLE: Event Enable register
	// Position of WAKEUP0_EN field.
	EVENTROUTER_ENABLE_WAKEUP0_EN_Pos = 0x0
	// Bit mask of WAKEUP0_EN field.
	EVENTROUTER_ENABLE_WAKEUP0_EN_Msk = 0x1
	// Bit WAKEUP0_EN.
	EVENTROUTER_ENABLE_WAKEUP0_EN = 0x1
	// Position of WAKEUP1_EN field.
	EVENTROUTER_ENABLE_WAKEUP1_EN_Pos = 0x1
	// Bit mask of WAKEUP1_EN field.
	EVENTROUTER_ENABLE_WAKEUP1_EN_Msk = 0x2
	// Bit WAKEUP1_EN.
	EVENTROUTER_ENABLE_WAKEUP1_EN = 0x2
	// Position of WAKEUP2_EN field.
	EVENTROUTER_ENABLE_WAKEUP2_EN_Pos = 0x2
	// Bit mask of WAKEUP2_EN field.
	EVENTROUTER_ENABLE_WAKEUP2_EN_Msk = 0x4
	// Bit WAKEUP2_EN.
	EVENTROUTER_ENABLE_WAKEUP2_EN = 0x4
	// Position of WAKEUP3_EN field.
	EVENTROUTER_ENABLE_WAKEUP3_EN_Pos = 0x3
	// Bit mask of WAKEUP3_EN field.
	EVENTROUTER_ENABLE_WAKEUP3_EN_Msk = 0x8
	// Bit WAKEUP3_EN.
	EVENTROUTER_ENABLE_WAKEUP3_EN = 0x8
	// Position of ATIMER_EN field.
	EVENTROUTER_ENABLE_ATIMER_EN_Pos = 0x4
	// Bit mask of ATIMER_EN field.
	EVENTROUTER_ENABLE_ATIMER_EN_Msk = 0x10
	// Bit ATIMER_EN.
	EVENTROUTER_ENABLE_ATIMER_EN = 0x10
	// Position of RTC_EN field.
	EVENTROUTER_ENABLE_RTC_EN_Pos = 0x5
	// Bit mask of RTC_EN field.
	EVENTROUTER_ENABLE_RTC_EN_Msk = 0x20
	// Bit RTC_EN.
	EVENTROUTER_ENABLE_RTC_EN = 0x20
	// Position of BOD_EN field.
	EVENTROUTER_ENABLE_BOD_EN_Pos = 0x6
	// Bit mask of BOD_EN field.
	EVENTROUTER_ENABLE_BOD_EN_Msk = 0x40
	// Bit BOD_EN.
	EVENTROUTER_ENABLE_BOD_EN = 0x40
	// Position of WWDT_EN field.
	EVENTROUTER_ENABLE_WWDT_EN_Pos = 0x7
	// Bit mask of WWDT_EN field.
	EVENTROUTER_ENABLE_WWDT_EN_Msk = 0x80
	// Bit WWDT_EN.
	EVENTROUTER_ENABLE_WWDT_EN = 0x80
	// Position of ETH_EN field.
	EVENTROUTER_ENABLE_ETH_EN_Pos = 0x8
	// Bit mask of ETH_EN field.
	EVENTROUTER_ENABLE_ETH_EN_Msk = 0x100
	// Bit ETH_EN.
	EVENTROUTER_ENABLE_ETH_EN = 0x100
	// Position of USB0_EN field.
	EVENTROUTER_ENABLE_USB0_EN_Pos = 0x9
	// Bit mask of USB0_EN field.
	EVENTROUTER_ENABLE_USB0_EN_Msk = 0x200
	// Bit USB0_EN.
	EVENTROUTER_ENABLE_USB0_EN = 0x200
	// Position of USB1_EN field.
	EVENTROUTER_ENABLE_USB1_EN_Pos = 0xa
	// Bit mask of USB1_EN field.
	EVENTROUTER_ENABLE_USB1_EN_Msk = 0x400
	// Bit USB1_EN.
	EVENTROUTER_ENABLE_USB1_EN = 0x400
	// Position of SDMMC_EN field.
	EVENTROUTER_ENABLE_SDMMC_EN_Pos = 0xb
	// Bit mask of SDMMC_EN field.
	EVENTROUTER_ENABLE_SDMMC_EN_Msk = 0x800
	// Bit SDMMC_EN.
	EVENTROUTER_ENABLE_SDMMC_EN = 0x800
	// Position of CAN_EN field.
	EVENTROUTER_ENABLE_CAN_EN_Pos = 0xc
	// Bit mask of CAN_EN field.
	EVENTROUTER_ENABLE_CAN_EN_Msk = 0x1000
	// Bit CAN_EN.
	EVENTROUTER_ENABLE_CAN_EN = 0x1000
	// Position of TIM2_EN field.
	EVENTROUTER_ENABLE_TIM2_EN_Pos = 0xd
	// Bit mask of TIM2_EN field.
	EVENTROUTER_ENABLE_TIM2_EN_Msk = 0x2000
	// Bit TIM2_EN.
	EVENTROUTER_ENABLE_TIM2_EN = 0x2000
	// Position of TIM6_EN field.
	EVENTROUTER_ENABLE_TIM6_EN_Pos = 0xe
	// Bit mask of TIM6_EN field.
	EVENTROUTER_ENABLE_TIM6_EN_Msk = 0x4000
	// Bit TIM6_EN.
	EVENTROUTER_ENABLE_TIM6_EN = 0x4000
	// Position of QEI_EN field.
	EVENTROUTER_ENABLE_QEI_EN_Pos = 0xf
	// Bit mask of QEI_EN field.
	EVENTROUTER_ENABLE_QEI_EN_Msk = 0x8000
	// Bit QEI_EN.
	EVENTROUTER_ENABLE_QEI_EN = 0x8000
	// Position of TIM14_EN field.
	EVENTROUTER_ENABLE_TIM14_EN_Pos = 0x10
	// Bit mask of TIM14_EN field.
	EVENTROUTER_ENABLE_TIM14_EN_Msk = 0x10000
	// Bit TIM14_EN.
	EVENTROUTER_ENABLE_TIM14_EN = 0x10000
	// Position of RESERVED field.
	EVENTROUTER_ENABLE_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	EVENTROUTER_ENABLE_RESERVED_Msk = 0x60000
	// Position of RESET_EN field.
	EVENTROUTER_ENABLE_RESET_EN_Pos = 0x13
	// Bit mask of RESET_EN field.
	EVENTROUTER_ENABLE_RESET_EN_Msk = 0x80000
	// Bit RESET_EN.
	EVENTROUTER_ENABLE_RESET_EN = 0x80000
	// Position of BODRESET_EN field.
	EVENTROUTER_ENABLE_BODRESET_EN_Pos = 0x14
	// Bit mask of BODRESET_EN field.
	EVENTROUTER_ENABLE_BODRESET_EN_Msk = 0x100000
	// Bit BODRESET_EN.
	EVENTROUTER_ENABLE_BODRESET_EN = 0x100000
	// Position of DPDRESET_EN field.
	EVENTROUTER_ENABLE_DPDRESET_EN_Pos = 0x15
	// Bit mask of DPDRESET_EN field.
	EVENTROUTER_ENABLE_DPDRESET_EN_Msk = 0x200000
	// Bit DPDRESET_EN.
	EVENTROUTER_ENABLE_DPDRESET_EN = 0x200000
	// Position of RESERVED field.
	EVENTROUTER_ENABLE_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	EVENTROUTER_ENABLE_RESERVED_Msk = 0xffc00000

	// CLR_STAT: Clear event status register
	// Position of WAKEUP0_CLRST field.
	EVENTROUTER_CLR_STAT_WAKEUP0_CLRST_Pos = 0x0
	// Bit mask of WAKEUP0_CLRST field.
	EVENTROUTER_CLR_STAT_WAKEUP0_CLRST_Msk = 0x1
	// Bit WAKEUP0_CLRST.
	EVENTROUTER_CLR_STAT_WAKEUP0_CLRST = 0x1
	// Position of WAKEUP1_CLRST field.
	EVENTROUTER_CLR_STAT_WAKEUP1_CLRST_Pos = 0x1
	// Bit mask of WAKEUP1_CLRST field.
	EVENTROUTER_CLR_STAT_WAKEUP1_CLRST_Msk = 0x2
	// Bit WAKEUP1_CLRST.
	EVENTROUTER_CLR_STAT_WAKEUP1_CLRST = 0x2
	// Position of WAKEUP2_CLRST field.
	EVENTROUTER_CLR_STAT_WAKEUP2_CLRST_Pos = 0x2
	// Bit mask of WAKEUP2_CLRST field.
	EVENTROUTER_CLR_STAT_WAKEUP2_CLRST_Msk = 0x4
	// Bit WAKEUP2_CLRST.
	EVENTROUTER_CLR_STAT_WAKEUP2_CLRST = 0x4
	// Position of WAKEUP3_CLRST field.
	EVENTROUTER_CLR_STAT_WAKEUP3_CLRST_Pos = 0x3
	// Bit mask of WAKEUP3_CLRST field.
	EVENTROUTER_CLR_STAT_WAKEUP3_CLRST_Msk = 0x8
	// Bit WAKEUP3_CLRST.
	EVENTROUTER_CLR_STAT_WAKEUP3_CLRST = 0x8
	// Position of ATIMER_CLRST field.
	EVENTROUTER_CLR_STAT_ATIMER_CLRST_Pos = 0x4
	// Bit mask of ATIMER_CLRST field.
	EVENTROUTER_CLR_STAT_ATIMER_CLRST_Msk = 0x10
	// Bit ATIMER_CLRST.
	EVENTROUTER_CLR_STAT_ATIMER_CLRST = 0x10
	// Position of RTC_CLRST field.
	EVENTROUTER_CLR_STAT_RTC_CLRST_Pos = 0x5
	// Bit mask of RTC_CLRST field.
	EVENTROUTER_CLR_STAT_RTC_CLRST_Msk = 0x20
	// Bit RTC_CLRST.
	EVENTROUTER_CLR_STAT_RTC_CLRST = 0x20
	// Position of BOD_CLRST field.
	EVENTROUTER_CLR_STAT_BOD_CLRST_Pos = 0x6
	// Bit mask of BOD_CLRST field.
	EVENTROUTER_CLR_STAT_BOD_CLRST_Msk = 0x40
	// Bit BOD_CLRST.
	EVENTROUTER_CLR_STAT_BOD_CLRST = 0x40
	// Position of WWDT_CLRST field.
	EVENTROUTER_CLR_STAT_WWDT_CLRST_Pos = 0x7
	// Bit mask of WWDT_CLRST field.
	EVENTROUTER_CLR_STAT_WWDT_CLRST_Msk = 0x80
	// Bit WWDT_CLRST.
	EVENTROUTER_CLR_STAT_WWDT_CLRST = 0x80
	// Position of ETH_CLRST field.
	EVENTROUTER_CLR_STAT_ETH_CLRST_Pos = 0x8
	// Bit mask of ETH_CLRST field.
	EVENTROUTER_CLR_STAT_ETH_CLRST_Msk = 0x100
	// Bit ETH_CLRST.
	EVENTROUTER_CLR_STAT_ETH_CLRST = 0x100
	// Position of USB0_CLRST field.
	EVENTROUTER_CLR_STAT_USB0_CLRST_Pos = 0x9
	// Bit mask of USB0_CLRST field.
	EVENTROUTER_CLR_STAT_USB0_CLRST_Msk = 0x200
	// Bit USB0_CLRST.
	EVENTROUTER_CLR_STAT_USB0_CLRST = 0x200
	// Position of USB1_CLRST field.
	EVENTROUTER_CLR_STAT_USB1_CLRST_Pos = 0xa
	// Bit mask of USB1_CLRST field.
	EVENTROUTER_CLR_STAT_USB1_CLRST_Msk = 0x400
	// Bit USB1_CLRST.
	EVENTROUTER_CLR_STAT_USB1_CLRST = 0x400
	// Position of SDMMC_CLRST field.
	EVENTROUTER_CLR_STAT_SDMMC_CLRST_Pos = 0xb
	// Bit mask of SDMMC_CLRST field.
	EVENTROUTER_CLR_STAT_SDMMC_CLRST_Msk = 0x800
	// Bit SDMMC_CLRST.
	EVENTROUTER_CLR_STAT_SDMMC_CLRST = 0x800
	// Position of CAN_CLRST field.
	EVENTROUTER_CLR_STAT_CAN_CLRST_Pos = 0xc
	// Bit mask of CAN_CLRST field.
	EVENTROUTER_CLR_STAT_CAN_CLRST_Msk = 0x1000
	// Bit CAN_CLRST.
	EVENTROUTER_CLR_STAT_CAN_CLRST = 0x1000
	// Position of TIM2_CLRST field.
	EVENTROUTER_CLR_STAT_TIM2_CLRST_Pos = 0xd
	// Bit mask of TIM2_CLRST field.
	EVENTROUTER_CLR_STAT_TIM2_CLRST_Msk = 0x2000
	// Bit TIM2_CLRST.
	EVENTROUTER_CLR_STAT_TIM2_CLRST = 0x2000
	// Position of TIM6_CLRST field.
	EVENTROUTER_CLR_STAT_TIM6_CLRST_Pos = 0xe
	// Bit mask of TIM6_CLRST field.
	EVENTROUTER_CLR_STAT_TIM6_CLRST_Msk = 0x4000
	// Bit TIM6_CLRST.
	EVENTROUTER_CLR_STAT_TIM6_CLRST = 0x4000
	// Position of QEI_CLRST field.
	EVENTROUTER_CLR_STAT_QEI_CLRST_Pos = 0xf
	// Bit mask of QEI_CLRST field.
	EVENTROUTER_CLR_STAT_QEI_CLRST_Msk = 0x8000
	// Bit QEI_CLRST.
	EVENTROUTER_CLR_STAT_QEI_CLRST = 0x8000
	// Position of TIM14_CLRST field.
	EVENTROUTER_CLR_STAT_TIM14_CLRST_Pos = 0x10
	// Bit mask of TIM14_CLRST field.
	EVENTROUTER_CLR_STAT_TIM14_CLRST_Msk = 0x10000
	// Bit TIM14_CLRST.
	EVENTROUTER_CLR_STAT_TIM14_CLRST = 0x10000
	// Position of RESERVED field.
	EVENTROUTER_CLR_STAT_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	EVENTROUTER_CLR_STAT_RESERVED_Msk = 0x60000
	// Position of RESET_CLRST field.
	EVENTROUTER_CLR_STAT_RESET_CLRST_Pos = 0x13
	// Bit mask of RESET_CLRST field.
	EVENTROUTER_CLR_STAT_RESET_CLRST_Msk = 0x80000
	// Bit RESET_CLRST.
	EVENTROUTER_CLR_STAT_RESET_CLRST = 0x80000
	// Position of BODRESET_CLRST field.
	EVENTROUTER_CLR_STAT_BODRESET_CLRST_Pos = 0x14
	// Bit mask of BODRESET_CLRST field.
	EVENTROUTER_CLR_STAT_BODRESET_CLRST_Msk = 0x100000
	// Bit BODRESET_CLRST.
	EVENTROUTER_CLR_STAT_BODRESET_CLRST = 0x100000
	// Position of DPDRESET_CLRST field.
	EVENTROUTER_CLR_STAT_DPDRESET_CLRST_Pos = 0x15
	// Bit mask of DPDRESET_CLRST field.
	EVENTROUTER_CLR_STAT_DPDRESET_CLRST_Msk = 0x200000
	// Bit DPDRESET_CLRST.
	EVENTROUTER_CLR_STAT_DPDRESET_CLRST = 0x200000
	// Position of RESERVED field.
	EVENTROUTER_CLR_STAT_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	EVENTROUTER_CLR_STAT_RESERVED_Msk = 0xffc00000

	// SET_STAT: Set event status register
	// Position of WAKEUP0_SETST field.
	EVENTROUTER_SET_STAT_WAKEUP0_SETST_Pos = 0x0
	// Bit mask of WAKEUP0_SETST field.
	EVENTROUTER_SET_STAT_WAKEUP0_SETST_Msk = 0x1
	// Bit WAKEUP0_SETST.
	EVENTROUTER_SET_STAT_WAKEUP0_SETST = 0x1
	// Position of WAKEUP1_SETST field.
	EVENTROUTER_SET_STAT_WAKEUP1_SETST_Pos = 0x1
	// Bit mask of WAKEUP1_SETST field.
	EVENTROUTER_SET_STAT_WAKEUP1_SETST_Msk = 0x2
	// Bit WAKEUP1_SETST.
	EVENTROUTER_SET_STAT_WAKEUP1_SETST = 0x2
	// Position of WAKEUP2_SETST field.
	EVENTROUTER_SET_STAT_WAKEUP2_SETST_Pos = 0x2
	// Bit mask of WAKEUP2_SETST field.
	EVENTROUTER_SET_STAT_WAKEUP2_SETST_Msk = 0x4
	// Bit WAKEUP2_SETST.
	EVENTROUTER_SET_STAT_WAKEUP2_SETST = 0x4
	// Position of WAKEUP3_SETST field.
	EVENTROUTER_SET_STAT_WAKEUP3_SETST_Pos = 0x3
	// Bit mask of WAKEUP3_SETST field.
	EVENTROUTER_SET_STAT_WAKEUP3_SETST_Msk = 0x8
	// Bit WAKEUP3_SETST.
	EVENTROUTER_SET_STAT_WAKEUP3_SETST = 0x8
	// Position of ATIMER_SETST field.
	EVENTROUTER_SET_STAT_ATIMER_SETST_Pos = 0x4
	// Bit mask of ATIMER_SETST field.
	EVENTROUTER_SET_STAT_ATIMER_SETST_Msk = 0x10
	// Bit ATIMER_SETST.
	EVENTROUTER_SET_STAT_ATIMER_SETST = 0x10
	// Position of RTC_SETST field.
	EVENTROUTER_SET_STAT_RTC_SETST_Pos = 0x5
	// Bit mask of RTC_SETST field.
	EVENTROUTER_SET_STAT_RTC_SETST_Msk = 0x20
	// Bit RTC_SETST.
	EVENTROUTER_SET_STAT_RTC_SETST = 0x20
	// Position of BOD_SETST field.
	EVENTROUTER_SET_STAT_BOD_SETST_Pos = 0x6
	// Bit mask of BOD_SETST field.
	EVENTROUTER_SET_STAT_BOD_SETST_Msk = 0x40
	// Bit BOD_SETST.
	EVENTROUTER_SET_STAT_BOD_SETST = 0x40
	// Position of WWDT_SETST field.
	EVENTROUTER_SET_STAT_WWDT_SETST_Pos = 0x7
	// Bit mask of WWDT_SETST field.
	EVENTROUTER_SET_STAT_WWDT_SETST_Msk = 0x80
	// Bit WWDT_SETST.
	EVENTROUTER_SET_STAT_WWDT_SETST = 0x80
	// Position of ETH_SETST field.
	EVENTROUTER_SET_STAT_ETH_SETST_Pos = 0x8
	// Bit mask of ETH_SETST field.
	EVENTROUTER_SET_STAT_ETH_SETST_Msk = 0x100
	// Bit ETH_SETST.
	EVENTROUTER_SET_STAT_ETH_SETST = 0x100
	// Position of USB0_SETST field.
	EVENTROUTER_SET_STAT_USB0_SETST_Pos = 0x9
	// Bit mask of USB0_SETST field.
	EVENTROUTER_SET_STAT_USB0_SETST_Msk = 0x200
	// Bit USB0_SETST.
	EVENTROUTER_SET_STAT_USB0_SETST = 0x200
	// Position of USB1_SETST field.
	EVENTROUTER_SET_STAT_USB1_SETST_Pos = 0xa
	// Bit mask of USB1_SETST field.
	EVENTROUTER_SET_STAT_USB1_SETST_Msk = 0x400
	// Bit USB1_SETST.
	EVENTROUTER_SET_STAT_USB1_SETST = 0x400
	// Position of SDMMC_SETST field.
	EVENTROUTER_SET_STAT_SDMMC_SETST_Pos = 0xb
	// Bit mask of SDMMC_SETST field.
	EVENTROUTER_SET_STAT_SDMMC_SETST_Msk = 0x800
	// Bit SDMMC_SETST.
	EVENTROUTER_SET_STAT_SDMMC_SETST = 0x800
	// Position of CAN_SETST field.
	EVENTROUTER_SET_STAT_CAN_SETST_Pos = 0xc
	// Bit mask of CAN_SETST field.
	EVENTROUTER_SET_STAT_CAN_SETST_Msk = 0x1000
	// Bit CAN_SETST.
	EVENTROUTER_SET_STAT_CAN_SETST = 0x1000
	// Position of TIM2_SETST field.
	EVENTROUTER_SET_STAT_TIM2_SETST_Pos = 0xd
	// Bit mask of TIM2_SETST field.
	EVENTROUTER_SET_STAT_TIM2_SETST_Msk = 0x2000
	// Bit TIM2_SETST.
	EVENTROUTER_SET_STAT_TIM2_SETST = 0x2000
	// Position of TIM6_SETST field.
	EVENTROUTER_SET_STAT_TIM6_SETST_Pos = 0xe
	// Bit mask of TIM6_SETST field.
	EVENTROUTER_SET_STAT_TIM6_SETST_Msk = 0x4000
	// Bit TIM6_SETST.
	EVENTROUTER_SET_STAT_TIM6_SETST = 0x4000
	// Position of QEI_SETST field.
	EVENTROUTER_SET_STAT_QEI_SETST_Pos = 0xf
	// Bit mask of QEI_SETST field.
	EVENTROUTER_SET_STAT_QEI_SETST_Msk = 0x8000
	// Bit QEI_SETST.
	EVENTROUTER_SET_STAT_QEI_SETST = 0x8000
	// Position of TIM14_SETST field.
	EVENTROUTER_SET_STAT_TIM14_SETST_Pos = 0x10
	// Bit mask of TIM14_SETST field.
	EVENTROUTER_SET_STAT_TIM14_SETST_Msk = 0x10000
	// Bit TIM14_SETST.
	EVENTROUTER_SET_STAT_TIM14_SETST = 0x10000
	// Position of RESERVED field.
	EVENTROUTER_SET_STAT_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	EVENTROUTER_SET_STAT_RESERVED_Msk = 0x60000
	// Position of RESET_SETST field.
	EVENTROUTER_SET_STAT_RESET_SETST_Pos = 0x13
	// Bit mask of RESET_SETST field.
	EVENTROUTER_SET_STAT_RESET_SETST_Msk = 0x80000
	// Bit RESET_SETST.
	EVENTROUTER_SET_STAT_RESET_SETST = 0x80000
	// Position of BODRESET_SETST field.
	EVENTROUTER_SET_STAT_BODRESET_SETST_Pos = 0x14
	// Bit mask of BODRESET_SETST field.
	EVENTROUTER_SET_STAT_BODRESET_SETST_Msk = 0x100000
	// Bit BODRESET_SETST.
	EVENTROUTER_SET_STAT_BODRESET_SETST = 0x100000
	// Position of DPDRESET_SETST field.
	EVENTROUTER_SET_STAT_DPDRESET_SETST_Pos = 0x15
	// Bit mask of DPDRESET_SETST field.
	EVENTROUTER_SET_STAT_DPDRESET_SETST_Msk = 0x200000
	// Bit DPDRESET_SETST.
	EVENTROUTER_SET_STAT_DPDRESET_SETST = 0x200000
	// Position of RESERVED field.
	EVENTROUTER_SET_STAT_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	EVENTROUTER_SET_STAT_RESERVED_Msk = 0xffc00000
)

// Constants for RTC: Real-Time Clock (RTC) and event recorder
const (
	// ILR: Interrupt Location Register
	// Position of RTCCIF field.
	RTC_ILR_RTCCIF_Pos = 0x0
	// Bit mask of RTCCIF field.
	RTC_ILR_RTCCIF_Msk = 0x1
	// Bit RTCCIF.
	RTC_ILR_RTCCIF = 0x1
	// Position of RTCALF field.
	RTC_ILR_RTCALF_Pos = 0x1
	// Bit mask of RTCALF field.
	RTC_ILR_RTCALF_Msk = 0x2
	// Bit RTCALF.
	RTC_ILR_RTCALF = 0x2
	// Position of RESERVED field.
	RTC_ILR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	RTC_ILR_RESERVED_Msk = 0xfffffffc

	// CCR: Clock Control Register
	// Position of CLKEN field.
	RTC_CCR_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	RTC_CCR_CLKEN_Msk = 0x1
	// Bit CLKEN.
	RTC_CCR_CLKEN = 0x1
	// The time counters are disabled so that they may be initialized.
	RTC_CCR_CLKEN_DISABLED = 0x0
	// The time counters are enabled.
	RTC_CCR_CLKEN_ENABLED = 0x1
	// Position of CTCRST field.
	RTC_CCR_CTCRST_Pos = 0x1
	// Bit mask of CTCRST field.
	RTC_CCR_CTCRST_Msk = 0x2
	// Bit CTCRST.
	RTC_CCR_CTCRST = 0x2
	// No effect.
	RTC_CCR_CTCRST_NO_EFFECT = 0x0
	// When one, the elements in the internal oscillator divider are reset, and remain reset until CCR[1] is changed to zero. This is the divider that generates the 1 Hz clock from the 32.768 kHz crystal. The state of the divider is not visible to software.
	RTC_CCR_CTCRST_RESET = 0x1
	// Position of RESERVED field.
	RTC_CCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	RTC_CCR_RESERVED_Msk = 0xc
	// Position of CCALEN field.
	RTC_CCR_CCALEN_Pos = 0x4
	// Bit mask of CCALEN field.
	RTC_CCR_CCALEN_Msk = 0x10
	// Bit CCALEN.
	RTC_CCR_CCALEN = 0x10
	// The calibration counter is enabled and counting, using the 1 Hz clock. When the calibration counter is equal to the value of the CALIBRATION register, the counter resets and repeats counting up to the value of the CALIBRATION register. See Section 29.6.6.2 and Section 29.7.1.
	RTC_CCR_CCALEN_ENABLED = 0x0
	// The calibration counter is disabled and reset to zero.
	RTC_CCR_CCALEN_DISABLED = 0x1
	// Position of RESERVED field.
	RTC_CCR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_CCR_RESERVED_Msk = 0xffffffe0

	// CIIR: Counter Increment Interrupt Register
	// Position of IMSEC field.
	RTC_CIIR_IMSEC_Pos = 0x0
	// Bit mask of IMSEC field.
	RTC_CIIR_IMSEC_Msk = 0x1
	// Bit IMSEC.
	RTC_CIIR_IMSEC = 0x1
	// Position of IMMIN field.
	RTC_CIIR_IMMIN_Pos = 0x1
	// Bit mask of IMMIN field.
	RTC_CIIR_IMMIN_Msk = 0x2
	// Bit IMMIN.
	RTC_CIIR_IMMIN = 0x2
	// Position of IMHOUR field.
	RTC_CIIR_IMHOUR_Pos = 0x2
	// Bit mask of IMHOUR field.
	RTC_CIIR_IMHOUR_Msk = 0x4
	// Bit IMHOUR.
	RTC_CIIR_IMHOUR = 0x4
	// Position of IMDOM field.
	RTC_CIIR_IMDOM_Pos = 0x3
	// Bit mask of IMDOM field.
	RTC_CIIR_IMDOM_Msk = 0x8
	// Bit IMDOM.
	RTC_CIIR_IMDOM = 0x8
	// Position of IMDOW field.
	RTC_CIIR_IMDOW_Pos = 0x4
	// Bit mask of IMDOW field.
	RTC_CIIR_IMDOW_Msk = 0x10
	// Bit IMDOW.
	RTC_CIIR_IMDOW = 0x10
	// Position of IMDOY field.
	RTC_CIIR_IMDOY_Pos = 0x5
	// Bit mask of IMDOY field.
	RTC_CIIR_IMDOY_Msk = 0x20
	// Bit IMDOY.
	RTC_CIIR_IMDOY = 0x20
	// Position of IMMON field.
	RTC_CIIR_IMMON_Pos = 0x6
	// Bit mask of IMMON field.
	RTC_CIIR_IMMON_Msk = 0x40
	// Bit IMMON.
	RTC_CIIR_IMMON = 0x40
	// Position of IMYEAR field.
	RTC_CIIR_IMYEAR_Pos = 0x7
	// Bit mask of IMYEAR field.
	RTC_CIIR_IMYEAR_Msk = 0x80
	// Bit IMYEAR.
	RTC_CIIR_IMYEAR = 0x80
	// Position of RESERVED field.
	RTC_CIIR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	RTC_CIIR_RESERVED_Msk = 0xffffff00

	// AMR: Alarm Mask Register
	// Position of AMRSEC field.
	RTC_AMR_AMRSEC_Pos = 0x0
	// Bit mask of AMRSEC field.
	RTC_AMR_AMRSEC_Msk = 0x1
	// Bit AMRSEC.
	RTC_AMR_AMRSEC = 0x1
	// Position of AMRMIN field.
	RTC_AMR_AMRMIN_Pos = 0x1
	// Bit mask of AMRMIN field.
	RTC_AMR_AMRMIN_Msk = 0x2
	// Bit AMRMIN.
	RTC_AMR_AMRMIN = 0x2
	// Position of AMRHOUR field.
	RTC_AMR_AMRHOUR_Pos = 0x2
	// Bit mask of AMRHOUR field.
	RTC_AMR_AMRHOUR_Msk = 0x4
	// Bit AMRHOUR.
	RTC_AMR_AMRHOUR = 0x4
	// Position of AMRDOM field.
	RTC_AMR_AMRDOM_Pos = 0x3
	// Bit mask of AMRDOM field.
	RTC_AMR_AMRDOM_Msk = 0x8
	// Bit AMRDOM.
	RTC_AMR_AMRDOM = 0x8
	// Position of AMRDOW field.
	RTC_AMR_AMRDOW_Pos = 0x4
	// Bit mask of AMRDOW field.
	RTC_AMR_AMRDOW_Msk = 0x10
	// Bit AMRDOW.
	RTC_AMR_AMRDOW = 0x10
	// Position of AMRDOY field.
	RTC_AMR_AMRDOY_Pos = 0x5
	// Bit mask of AMRDOY field.
	RTC_AMR_AMRDOY_Msk = 0x20
	// Bit AMRDOY.
	RTC_AMR_AMRDOY = 0x20
	// Position of AMRMON field.
	RTC_AMR_AMRMON_Pos = 0x6
	// Bit mask of AMRMON field.
	RTC_AMR_AMRMON_Msk = 0x40
	// Bit AMRMON.
	RTC_AMR_AMRMON = 0x40
	// Position of AMRYEAR field.
	RTC_AMR_AMRYEAR_Pos = 0x7
	// Bit mask of AMRYEAR field.
	RTC_AMR_AMRYEAR_Msk = 0x80
	// Bit AMRYEAR.
	RTC_AMR_AMRYEAR = 0x80
	// Position of RESERVED field.
	RTC_AMR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	RTC_AMR_RESERVED_Msk = 0xffffff00

	// CTIME0: Consolidated Time Register 0
	// Position of SECONDS field.
	RTC_CTIME0_SECONDS_Pos = 0x0
	// Bit mask of SECONDS field.
	RTC_CTIME0_SECONDS_Msk = 0x3f
	// Position of RESERVED field.
	RTC_CTIME0_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_CTIME0_RESERVED_Msk = 0xc0
	// Position of MINUTES field.
	RTC_CTIME0_MINUTES_Pos = 0x8
	// Bit mask of MINUTES field.
	RTC_CTIME0_MINUTES_Msk = 0x3f00
	// Position of RESERVED field.
	RTC_CTIME0_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	RTC_CTIME0_RESERVED_Msk = 0xc000
	// Position of HOURS field.
	RTC_CTIME0_HOURS_Pos = 0x10
	// Bit mask of HOURS field.
	RTC_CTIME0_HOURS_Msk = 0x1f0000
	// Position of RESERVED field.
	RTC_CTIME0_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	RTC_CTIME0_RESERVED_Msk = 0xe00000
	// Position of DOW field.
	RTC_CTIME0_DOW_Pos = 0x18
	// Bit mask of DOW field.
	RTC_CTIME0_DOW_Msk = 0x7000000
	// Position of RESERVED field.
	RTC_CTIME0_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	RTC_CTIME0_RESERVED_Msk = 0xf8000000

	// CTIME1: Consolidated Time Register 1
	// Position of DOM field.
	RTC_CTIME1_DOM_Pos = 0x0
	// Bit mask of DOM field.
	RTC_CTIME1_DOM_Msk = 0x1f
	// Position of RESERVED field.
	RTC_CTIME1_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_CTIME1_RESERVED_Msk = 0xe0
	// Position of MONTH field.
	RTC_CTIME1_MONTH_Pos = 0x8
	// Bit mask of MONTH field.
	RTC_CTIME1_MONTH_Msk = 0xf00
	// Position of RESERVED field.
	RTC_CTIME1_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	RTC_CTIME1_RESERVED_Msk = 0xf000
	// Position of YEAR field.
	RTC_CTIME1_YEAR_Pos = 0x10
	// Bit mask of YEAR field.
	RTC_CTIME1_YEAR_Msk = 0xfff0000
	// Position of RESERVED field.
	RTC_CTIME1_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	RTC_CTIME1_RESERVED_Msk = 0xf0000000

	// CTIME2: Consolidated Time Register 2
	// Position of DOY field.
	RTC_CTIME2_DOY_Pos = 0x0
	// Bit mask of DOY field.
	RTC_CTIME2_DOY_Msk = 0xfff
	// Position of RESERVED field.
	RTC_CTIME2_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	RTC_CTIME2_RESERVED_Msk = 0xfffff000

	// SEC: Seconds Register
	// Position of SECONDS field.
	RTC_SEC_SECONDS_Pos = 0x0
	// Bit mask of SECONDS field.
	RTC_SEC_SECONDS_Msk = 0x3f
	// Position of RESERVED field.
	RTC_SEC_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_SEC_RESERVED_Msk = 0xffffffc0

	// MIN: Minutes Register
	// Position of MINUTES field.
	RTC_MIN_MINUTES_Pos = 0x0
	// Bit mask of MINUTES field.
	RTC_MIN_MINUTES_Msk = 0x3f
	// Position of RESERVED field.
	RTC_MIN_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_MIN_RESERVED_Msk = 0xffffffc0

	// HRS: Hours Register
	// Position of HOURS field.
	RTC_HRS_HOURS_Pos = 0x0
	// Bit mask of HOURS field.
	RTC_HRS_HOURS_Msk = 0x1f
	// Position of RESERVED field.
	RTC_HRS_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_HRS_RESERVED_Msk = 0xffffffe0

	// DOM: Day of Month Register
	// Position of DOM field.
	RTC_DOM_DOM_Pos = 0x0
	// Bit mask of DOM field.
	RTC_DOM_DOM_Msk = 0x1f
	// Position of RESERVED field.
	RTC_DOM_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_DOM_RESERVED_Msk = 0xffffffe0

	// DOW: Day of Week Register
	// Position of DOW field.
	RTC_DOW_DOW_Pos = 0x0
	// Bit mask of DOW field.
	RTC_DOW_DOW_Msk = 0x7
	// Position of RESERVED field.
	RTC_DOW_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RTC_DOW_RESERVED_Msk = 0xfffffff8

	// DOY: Day of Year Register
	// Position of DOY field.
	RTC_DOY_DOY_Pos = 0x0
	// Bit mask of DOY field.
	RTC_DOY_DOY_Msk = 0x1ff
	// Position of RESERVED field.
	RTC_DOY_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	RTC_DOY_RESERVED_Msk = 0xfffffe00

	// MONTH: Months Register
	// Position of MONTH field.
	RTC_MONTH_MONTH_Pos = 0x0
	// Bit mask of MONTH field.
	RTC_MONTH_MONTH_Msk = 0xf
	// Position of RESERVED field.
	RTC_MONTH_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RTC_MONTH_RESERVED_Msk = 0xfffffff0

	// YEAR: Years Register
	// Position of YEAR field.
	RTC_YEAR_YEAR_Pos = 0x0
	// Bit mask of YEAR field.
	RTC_YEAR_YEAR_Msk = 0xfff
	// Position of RESERVED field.
	RTC_YEAR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	RTC_YEAR_RESERVED_Msk = 0xfffff000

	// CALIBRATION: Calibration Value Register
	// Position of CALVAL field.
	RTC_CALIBRATION_CALVAL_Pos = 0x0
	// Bit mask of CALVAL field.
	RTC_CALIBRATION_CALVAL_Msk = 0x1ffff
	// Position of CALDIR field.
	RTC_CALIBRATION_CALDIR_Pos = 0x11
	// Bit mask of CALDIR field.
	RTC_CALIBRATION_CALDIR_Msk = 0x20000
	// Bit CALDIR.
	RTC_CALIBRATION_CALDIR = 0x20000
	// Forward calibration. When CALVAL is equal to the calibration counter, the RTC timers will jump by 2 seconds.
	RTC_CALIBRATION_CALDIR_FORWARD_CALIBRATION_ = 0x0
	// Backward calibration. When CALVAL is equal to the calibration counter, the RTC timers will stop incrementing for 1 second.
	RTC_CALIBRATION_CALDIR_BACKWARD_CALIBRATION = 0x1

	// ASEC: Alarm value for Seconds
	// Position of SECONDS field.
	RTC_ASEC_SECONDS_Pos = 0x0
	// Bit mask of SECONDS field.
	RTC_ASEC_SECONDS_Msk = 0x3f
	// Position of RESERVED field.
	RTC_ASEC_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_ASEC_RESERVED_Msk = 0xffffffc0

	// AMIN: Alarm value for Minutes
	// Position of MINUTES field.
	RTC_AMIN_MINUTES_Pos = 0x0
	// Bit mask of MINUTES field.
	RTC_AMIN_MINUTES_Msk = 0x3f
	// Position of RESERVED field.
	RTC_AMIN_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_AMIN_RESERVED_Msk = 0xffffffc0

	// AHRS: Alarm value for Hours
	// Position of HOURS field.
	RTC_AHRS_HOURS_Pos = 0x0
	// Bit mask of HOURS field.
	RTC_AHRS_HOURS_Msk = 0x1f
	// Position of RESERVED field.
	RTC_AHRS_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_AHRS_RESERVED_Msk = 0xffffffe0

	// ADOM: Alarm value for Day of Month
	// Position of DOM field.
	RTC_ADOM_DOM_Pos = 0x0
	// Bit mask of DOM field.
	RTC_ADOM_DOM_Msk = 0x1f
	// Position of RESERVED field.
	RTC_ADOM_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_ADOM_RESERVED_Msk = 0xffffffe0

	// ADOW: Alarm value for Day of Week
	// Position of DOW field.
	RTC_ADOW_DOW_Pos = 0x0
	// Bit mask of DOW field.
	RTC_ADOW_DOW_Msk = 0x7
	// Position of RESERVED field.
	RTC_ADOW_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RTC_ADOW_RESERVED_Msk = 0xfffffff8

	// ADOY: Alarm value for Day of Year
	// Position of DOY field.
	RTC_ADOY_DOY_Pos = 0x0
	// Bit mask of DOY field.
	RTC_ADOY_DOY_Msk = 0x1ff
	// Position of RESERVED field.
	RTC_ADOY_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	RTC_ADOY_RESERVED_Msk = 0xfffffe00

	// AMON: Alarm value for Months
	// Position of MONTH field.
	RTC_AMON_MONTH_Pos = 0x0
	// Bit mask of MONTH field.
	RTC_AMON_MONTH_Msk = 0xf
	// Position of RESERVED field.
	RTC_AMON_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RTC_AMON_RESERVED_Msk = 0xfffffff0

	// AYRS: Alarm value for Year
	// Position of YEAR field.
	RTC_AYRS_YEAR_Pos = 0x0
	// Bit mask of YEAR field.
	RTC_AYRS_YEAR_Msk = 0xfff
	// Position of RESERVED field.
	RTC_AYRS_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	RTC_AYRS_RESERVED_Msk = 0xfffff000

	// ERSTATUS: Event Monitor/Recorder Status register. Contains status flags for event channels and other Event Monitor/Recorder conditions.
	// Position of EV0 field.
	RTC_ERSTATUS_EV0_Pos = 0x0
	// Bit mask of EV0 field.
	RTC_ERSTATUS_EV0_Msk = 0x1
	// Bit EV0.
	RTC_ERSTATUS_EV0 = 0x1
	// No event change on channel 0.
	RTC_ERSTATUS_EV0_NO_CHANGE = 0x0
	// At least one event has occurred on channel 0.
	RTC_ERSTATUS_EV0_EVENT = 0x1
	// Position of EV1 field.
	RTC_ERSTATUS_EV1_Pos = 0x1
	// Bit mask of EV1 field.
	RTC_ERSTATUS_EV1_Msk = 0x2
	// Bit EV1.
	RTC_ERSTATUS_EV1 = 0x2
	// No event change on channel 1.
	RTC_ERSTATUS_EV1_NO_CHANGE = 0x0
	// At least one event has occurred on channel 1.
	RTC_ERSTATUS_EV1_EVENT = 0x1
	// Position of EV2 field.
	RTC_ERSTATUS_EV2_Pos = 0x2
	// Bit mask of EV2 field.
	RTC_ERSTATUS_EV2_Msk = 0x4
	// Bit EV2.
	RTC_ERSTATUS_EV2 = 0x4
	// No event change on channel 2.
	RTC_ERSTATUS_EV2_NO_CHANGE = 0x0
	// At least one event has occurred on channel 2.
	RTC_ERSTATUS_EV2_EVENT = 0x1
	// Position of GP_CLEARED field.
	RTC_ERSTATUS_GP_CLEARED_Pos = 0x3
	// Bit mask of GP_CLEARED field.
	RTC_ERSTATUS_GP_CLEARED_Msk = 0x8
	// Bit GP_CLEARED.
	RTC_ERSTATUS_GP_CLEARED = 0x8
	// General purpose registers have not been asynchronous cleared.
	RTC_ERSTATUS_GP_CLEARED_NO_CHANGE = 0x0
	// General purpose registers have been asynchronous cleared.
	RTC_ERSTATUS_GP_CLEARED_EVENT = 0x1
	// Position of RESERVED field.
	RTC_ERSTATUS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RTC_ERSTATUS_RESERVED_Msk = 0x7ffffff0
	// Position of WAKEUP field.
	RTC_ERSTATUS_WAKEUP_Pos = 0x1f
	// Bit mask of WAKEUP field.
	RTC_ERSTATUS_WAKEUP_Msk = 0x80000000
	// Bit WAKEUP.
	RTC_ERSTATUS_WAKEUP = 0x80000000
	// No interrupt/wake-up request is pending
	RTC_ERSTATUS_WAKEUP_NOINTERRUPTWAKEUP = 0x0
	// An interrupt/wake-up request is pending.
	RTC_ERSTATUS_WAKEUP_INTERRUPTWAKEUP = 0x1

	// ERCONTRO: Event Monitor/Recorder Control register. Contains bits that control actions for the event channels as well as for Event Monitor/Recorder setup.
	// Position of INTWAKE_EN0 field.
	RTC_ERCONTRO_INTWAKE_EN0_Pos = 0x0
	// Bit mask of INTWAKE_EN0 field.
	RTC_ERCONTRO_INTWAKE_EN0_Msk = 0x1
	// Bit INTWAKE_EN0.
	RTC_ERCONTRO_INTWAKE_EN0 = 0x1
	// No interrupt or wake-up will be generated by event channel 0.
	RTC_ERCONTRO_INTWAKE_EN0_DISABLED = 0x0
	// An event in channel 0 will trigger an (RTC) interrupt and a wake-up request.
	RTC_ERCONTRO_INTWAKE_EN0_ENABLED = 0x1
	// Position of GPCLEAR_EN0 field.
	RTC_ERCONTRO_GPCLEAR_EN0_Pos = 0x1
	// Bit mask of GPCLEAR_EN0 field.
	RTC_ERCONTRO_GPCLEAR_EN0_Msk = 0x2
	// Bit GPCLEAR_EN0.
	RTC_ERCONTRO_GPCLEAR_EN0 = 0x2
	// Channel 0 has no influence on the general purpose registers.
	RTC_ERCONTRO_GPCLEAR_EN0_DISABLED = 0x0
	// An event in channel 0 will clear the general purpose registers asynchronously.
	RTC_ERCONTRO_GPCLEAR_EN0_ENABLED = 0x1
	// Position of POL0 field.
	RTC_ERCONTRO_POL0_Pos = 0x2
	// Bit mask of POL0 field.
	RTC_ERCONTRO_POL0_Msk = 0x4
	// Bit POL0.
	RTC_ERCONTRO_POL0 = 0x4
	// A channel 0 event is defined as a negative edge on WAKEUP0.
	RTC_ERCONTRO_POL0_NEGATIVE = 0x0
	// A channel 0 event is defined as a positive edge on WAKEUP0.
	RTC_ERCONTRO_POL0_POSITIVE = 0x1
	// Position of EV0_INPUT_EN field.
	RTC_ERCONTRO_EV0_INPUT_EN_Pos = 0x3
	// Bit mask of EV0_INPUT_EN field.
	RTC_ERCONTRO_EV0_INPUT_EN_Msk = 0x8
	// Bit EV0_INPUT_EN.
	RTC_ERCONTRO_EV0_INPUT_EN = 0x8
	// Event 0 input is disabled and forced high internally.
	RTC_ERCONTRO_EV0_INPUT_EN_DISABLED = 0x0
	// Event 0 input is enabled.
	RTC_ERCONTRO_EV0_INPUT_EN_ENABLED = 0x1
	// Position of RESERVED field.
	RTC_ERCONTRO_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RTC_ERCONTRO_RESERVED_Msk = 0x3f0
	// Position of INTWAKE_EN1 field.
	RTC_ERCONTRO_INTWAKE_EN1_Pos = 0xa
	// Bit mask of INTWAKE_EN1 field.
	RTC_ERCONTRO_INTWAKE_EN1_Msk = 0x400
	// Bit INTWAKE_EN1.
	RTC_ERCONTRO_INTWAKE_EN1 = 0x400
	// No interrupt or wake-up will be generated by event channel 1.
	RTC_ERCONTRO_INTWAKE_EN1_DISABLED = 0x0
	// An event in channel 1 will trigger an (RTC) interrupt and a wake-up request.
	RTC_ERCONTRO_INTWAKE_EN1_ENABLED = 0x1
	// Position of GPCLEAR_EN1 field.
	RTC_ERCONTRO_GPCLEAR_EN1_Pos = 0xb
	// Bit mask of GPCLEAR_EN1 field.
	RTC_ERCONTRO_GPCLEAR_EN1_Msk = 0x800
	// Bit GPCLEAR_EN1.
	RTC_ERCONTRO_GPCLEAR_EN1 = 0x800
	// Channel 1 has no influence on the general purpose registers.
	RTC_ERCONTRO_GPCLEAR_EN1_DISABLED = 0x0
	// A n event in channel 1 will clear the general purpose registers asynchronously.
	RTC_ERCONTRO_GPCLEAR_EN1_ENABLED = 0x1
	// Position of POL1 field.
	RTC_ERCONTRO_POL1_Pos = 0xc
	// Bit mask of POL1 field.
	RTC_ERCONTRO_POL1_Msk = 0x1000
	// Bit POL1.
	RTC_ERCONTRO_POL1 = 0x1000
	// A channel 1 event is defined as a negative edge on WAKEUP1.
	RTC_ERCONTRO_POL1_NEGATIVE = 0x0
	// A channel 1 event is defined as a positive edge on WAKEUP1.
	RTC_ERCONTRO_POL1_POSITIVE = 0x1
	// Position of EV1_INPUT_EN field.
	RTC_ERCONTRO_EV1_INPUT_EN_Pos = 0xd
	// Bit mask of EV1_INPUT_EN field.
	RTC_ERCONTRO_EV1_INPUT_EN_Msk = 0x2000
	// Bit EV1_INPUT_EN.
	RTC_ERCONTRO_EV1_INPUT_EN = 0x2000
	// Event 1 input is disabled and forced high internally.
	RTC_ERCONTRO_EV1_INPUT_EN_DISABLED = 0x0
	// Event 1 input is enabled.
	RTC_ERCONTRO_EV1_INPUT_EN_ENABLED = 0x1
	// Position of RESERVED field.
	RTC_ERCONTRO_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	RTC_ERCONTRO_RESERVED_Msk = 0xfc000
	// Position of INTWAKE_EN2 field.
	RTC_ERCONTRO_INTWAKE_EN2_Pos = 0x14
	// Bit mask of INTWAKE_EN2 field.
	RTC_ERCONTRO_INTWAKE_EN2_Msk = 0x100000
	// Bit INTWAKE_EN2.
	RTC_ERCONTRO_INTWAKE_EN2 = 0x100000
	// No interrupt or wake-up will be generated by event channel 2.
	RTC_ERCONTRO_INTWAKE_EN2_DISABLED = 0x0
	// An event in channel 2 will trigger an (RTC) interrupt and a wake-up request.
	RTC_ERCONTRO_INTWAKE_EN2_ENABLED = 0x1
	// Position of GPCLEAR_EN2 field.
	RTC_ERCONTRO_GPCLEAR_EN2_Pos = 0x15
	// Bit mask of GPCLEAR_EN2 field.
	RTC_ERCONTRO_GPCLEAR_EN2_Msk = 0x200000
	// Bit GPCLEAR_EN2.
	RTC_ERCONTRO_GPCLEAR_EN2 = 0x200000
	// Channel 2 has no influence on the general purpose registers.
	RTC_ERCONTRO_GPCLEAR_EN2_DISABLED = 0x0
	// An event in channel 2 will clear the general purpose registers asynchronously.
	RTC_ERCONTRO_GPCLEAR_EN2_ENABLED = 0x1
	// Position of POL2 field.
	RTC_ERCONTRO_POL2_Pos = 0x16
	// Bit mask of POL2 field.
	RTC_ERCONTRO_POL2_Msk = 0x400000
	// Bit POL2.
	RTC_ERCONTRO_POL2 = 0x400000
	// A channel 2 event is defined as a negative edge on WAKEUP2.
	RTC_ERCONTRO_POL2_NEGATIVE = 0x0
	// A channel 2 event is defined as a positive edge on WAKEUP2.
	RTC_ERCONTRO_POL2_POSITIVE = 0x1
	// Position of EV2_INPUT_EN field.
	RTC_ERCONTRO_EV2_INPUT_EN_Pos = 0x17
	// Bit mask of EV2_INPUT_EN field.
	RTC_ERCONTRO_EV2_INPUT_EN_Msk = 0x800000
	// Bit EV2_INPUT_EN.
	RTC_ERCONTRO_EV2_INPUT_EN = 0x800000
	// Event 2 input is disabled and forced high internally.
	RTC_ERCONTRO_EV2_INPUT_EN_DISABLED = 0x0
	// Event 2 input is enabled.
	RTC_ERCONTRO_EV2_INPUT_EN_ENABLED = 0x1
	// Position of RESERVED field.
	RTC_ERCONTRO_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	RTC_ERCONTRO_RESERVED_Msk = 0x3f000000
	// Position of ERMODE field.
	RTC_ERCONTRO_ERMODE_Pos = 0x1e
	// Bit mask of ERMODE field.
	RTC_ERCONTRO_ERMODE_Msk = 0xc0000000
	// Disable Event Monitor/Recorder clocks. Operation of the Event Monitor/Recorder is disabled except for asynchronous clearing of GP registers if selected.
	RTC_ERCONTRO_ERMODE_DISABLE_EVENT_MONITO = 0x0
	// 16 Hz sample clock. Enable Event Monitor/Recorder and select a 16 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 62.5 ms to 125 ms will be filtered out.
	RTC_ERCONTRO_ERMODE_16_HZ_SAMPLE_CLOCK = 0x1
	// 64 Hz sample clock. Enable Event Monitor/Recorder and select a 64 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 15.6 ms to 31.2 ms will be filtered out.
	RTC_ERCONTRO_ERMODE_64_HZ_SAMPLE_CLOCK = 0x2
	// 1 kHz sample clock. Enable Event Monitor/Recorder and select a 1 kHz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 1 ms to 2 ms will be filtered out.
	RTC_ERCONTRO_ERMODE_1_KHZ_SAMPLE_CLOCK = 0x3

	// ERCOUNTERS: Event Monitor/Recorder Counters register. Allows reading the counters associated with the event channels.
	// Position of COUNTER0 field.
	RTC_ERCOUNTERS_COUNTER0_Pos = 0x0
	// Bit mask of COUNTER0 field.
	RTC_ERCOUNTERS_COUNTER0_Msk = 0x7
	// Position of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Msk = 0xf8
	// Position of COUNTER1 field.
	RTC_ERCOUNTERS_COUNTER1_Pos = 0x8
	// Bit mask of COUNTER1 field.
	RTC_ERCOUNTERS_COUNTER1_Msk = 0x700
	// Position of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Msk = 0xf800
	// Position of COUNTER2 field.
	RTC_ERCOUNTERS_COUNTER2_Pos = 0x10
	// Bit mask of COUNTER2 field.
	RTC_ERCOUNTERS_COUNTER2_Msk = 0x70000
	// Position of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Msk = 0xfff80000

	// ERFIRSTSTAMP0: Event Monitor/Recorder First Stamp register for channel 0. Retains the time stamp for the first event on channel 0.
	// Position of SEC field.
	RTC_ERFIRSTSTAMP_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_ERFIRSTSTAMP_SEC_Msk = 0x3f
	// Position of MIN field.
	RTC_ERFIRSTSTAMP_MIN_Pos = 0x6
	// Bit mask of MIN field.
	RTC_ERFIRSTSTAMP_MIN_Msk = 0xfc0
	// Position of HOUR field.
	RTC_ERFIRSTSTAMP_HOUR_Pos = 0xc
	// Bit mask of HOUR field.
	RTC_ERFIRSTSTAMP_HOUR_Msk = 0x1f000
	// Position of DOY field.
	RTC_ERFIRSTSTAMP_DOY_Pos = 0x11
	// Bit mask of DOY field.
	RTC_ERFIRSTSTAMP_DOY_Msk = 0x3fe0000
	// Position of RESERVED field.
	RTC_ERFIRSTSTAMP_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	RTC_ERFIRSTSTAMP_RESERVED_Msk = 0xfc000000

	// ERLASTSTAMP0: Event Monitor/Recorder Last Stamp register for channel 0. Retains the time stamp for the last (i.e. most recent) event on channel 0.
	// Position of SEC field.
	RTC_ERLASTSTAMP_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_ERLASTSTAMP_SEC_Msk = 0x3f
	// Position of MIN field.
	RTC_ERLASTSTAMP_MIN_Pos = 0x6
	// Bit mask of MIN field.
	RTC_ERLASTSTAMP_MIN_Msk = 0xfc0
	// Position of HOUR field.
	RTC_ERLASTSTAMP_HOUR_Pos = 0xc
	// Bit mask of HOUR field.
	RTC_ERLASTSTAMP_HOUR_Msk = 0x1f000
	// Position of DOY field.
	RTC_ERLASTSTAMP_DOY_Pos = 0x11
	// Bit mask of DOY field.
	RTC_ERLASTSTAMP_DOY_Msk = 0x3fe0000
	// Position of RESERVED field.
	RTC_ERLASTSTAMP_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	RTC_ERLASTSTAMP_RESERVED_Msk = 0xfc000000
)

// Constants for CGU: Clock Generation Unit (CGU)
const (
	// FREQ_MON: Frequency monitor register
	// Position of RCNT field.
	CGU_FREQ_MON_RCNT_Pos = 0x0
	// Bit mask of RCNT field.
	CGU_FREQ_MON_RCNT_Msk = 0x1ff
	// Position of FCNT field.
	CGU_FREQ_MON_FCNT_Pos = 0x9
	// Bit mask of FCNT field.
	CGU_FREQ_MON_FCNT_Msk = 0x7ffe00
	// Position of MEAS field.
	CGU_FREQ_MON_MEAS_Pos = 0x17
	// Bit mask of MEAS field.
	CGU_FREQ_MON_MEAS_Msk = 0x800000
	// Bit MEAS.
	CGU_FREQ_MON_MEAS = 0x800000
	// RCNT and FCNT disabled
	CGU_FREQ_MON_MEAS_RCNT_AND_FCNT_DISABL = 0x0
	// Frequency counters started
	CGU_FREQ_MON_MEAS_FREQUENCY_COUNTERS_S = 0x1
	// Position of CLK_SEL field.
	CGU_FREQ_MON_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_FREQ_MON_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator (default)
	CGU_FREQ_MON_CLK_SEL_32_KHZ_OSCILLATOR_D = 0x0
	// IRC
	CGU_FREQ_MON_CLK_SEL_IRC = 0x1
	// ENET_RX_CLK
	CGU_FREQ_MON_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_FREQ_MON_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_FREQ_MON_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_FREQ_MON_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0USB
	CGU_FREQ_MON_CLK_SEL_PLL0USB = 0x7
	// PLL0AUDIO
	CGU_FREQ_MON_CLK_SEL_PLL0AUDIO = 0x8
	// PLL1
	CGU_FREQ_MON_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_FREQ_MON_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_FREQ_MON_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_FREQ_MON_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_FREQ_MON_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_FREQ_MON_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_FREQ_MON_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_FREQ_MON_RESERVED_Msk = 0xe0000000

	// XTAL_OSC_CTRL: Crystal oscillator control register
	// Position of ENABLE field.
	CGU_XTAL_OSC_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	CGU_XTAL_OSC_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	CGU_XTAL_OSC_CTRL_ENABLE = 0x1
	// Enable
	CGU_XTAL_OSC_CTRL_ENABLE_ENABLE = 0x0
	// Power-down (default)
	CGU_XTAL_OSC_CTRL_ENABLE_POWER_DOWN = 0x1
	// Position of BYPASS field.
	CGU_XTAL_OSC_CTRL_BYPASS_Pos = 0x1
	// Bit mask of BYPASS field.
	CGU_XTAL_OSC_CTRL_BYPASS_Msk = 0x2
	// Bit BYPASS.
	CGU_XTAL_OSC_CTRL_BYPASS = 0x2
	// Crystal. Operation with crystal connected (default).
	CGU_XTAL_OSC_CTRL_BYPASS_CRYSTAL = 0x0
	// Bypass mode. Use this mode when an external clock source is used instead of a crystal.
	CGU_XTAL_OSC_CTRL_BYPASS_BYPASS_MODE = 0x1
	// Position of HF field.
	CGU_XTAL_OSC_CTRL_HF_Pos = 0x2
	// Bit mask of HF field.
	CGU_XTAL_OSC_CTRL_HF_Msk = 0x4
	// Bit HF.
	CGU_XTAL_OSC_CTRL_HF = 0x4
	// Low. Oscillator low-frequency mode (crystal or external clock source 1 to 20 MHz). Between 15 MHz and 20 MHz, the state of the HF bit is don't care.
	CGU_XTAL_OSC_CTRL_HF_LOW = 0x0
	// High. Oscillator high-frequency mode; crystal or external clock source 15 to 25 MHz. Between 15 MHz and 20 MHz, the state of the HF bit is don't care.
	CGU_XTAL_OSC_CTRL_HF_HIGH = 0x1
	// Position of RESERVED field.
	CGU_XTAL_OSC_CTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CGU_XTAL_OSC_CTRL_RESERVED_Msk = 0xfffffff8

	// PLL0USB_STAT: PLL0USB status register
	// Position of LOCK field.
	CGU_PLL0USB_STAT_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	CGU_PLL0USB_STAT_LOCK_Msk = 0x1
	// Bit LOCK.
	CGU_PLL0USB_STAT_LOCK = 0x1
	// Position of FR field.
	CGU_PLL0USB_STAT_FR_Pos = 0x1
	// Bit mask of FR field.
	CGU_PLL0USB_STAT_FR_Msk = 0x2
	// Bit FR.
	CGU_PLL0USB_STAT_FR = 0x2
	// Position of RESERVED field.
	CGU_PLL0USB_STAT_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	CGU_PLL0USB_STAT_RESERVED_Msk = 0xfffffffc

	// PLL0USB_CTRL: PLL0USB control register
	// Position of PD field.
	CGU_PLL0USB_CTRL_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_PLL0USB_CTRL_PD_Msk = 0x1
	// Bit PD.
	CGU_PLL0USB_CTRL_PD = 0x1
	// PLL0 enabled
	CGU_PLL0USB_CTRL_PD_PLL0_ENABLED = 0x0
	// PLL0 powered down
	CGU_PLL0USB_CTRL_PD_PLL0_POWERED_DOWN = 0x1
	// Position of BYPASS field.
	CGU_PLL0USB_CTRL_BYPASS_Pos = 0x1
	// Bit mask of BYPASS field.
	CGU_PLL0USB_CTRL_BYPASS_Msk = 0x2
	// Bit BYPASS.
	CGU_PLL0USB_CTRL_BYPASS = 0x2
	// CCO clock sent to post-dividers. Use this in normal operation.
	CGU_PLL0USB_CTRL_BYPASS_CCO_CLOCK_SENT_TO_PO = 0x0
	// PLL0 input clock sent to post-dividers (default).
	CGU_PLL0USB_CTRL_BYPASS_PLL0_INPUT_CLOCK_SEN = 0x1
	// Position of DIRECTI field.
	CGU_PLL0USB_CTRL_DIRECTI_Pos = 0x2
	// Bit mask of DIRECTI field.
	CGU_PLL0USB_CTRL_DIRECTI_Msk = 0x4
	// Bit DIRECTI.
	CGU_PLL0USB_CTRL_DIRECTI = 0x4
	// Position of DIRECTO field.
	CGU_PLL0USB_CTRL_DIRECTO_Pos = 0x3
	// Bit mask of DIRECTO field.
	CGU_PLL0USB_CTRL_DIRECTO_Msk = 0x8
	// Bit DIRECTO.
	CGU_PLL0USB_CTRL_DIRECTO = 0x8
	// Position of CLKEN field.
	CGU_PLL0USB_CTRL_CLKEN_Pos = 0x4
	// Bit mask of CLKEN field.
	CGU_PLL0USB_CTRL_CLKEN_Msk = 0x10
	// Bit CLKEN.
	CGU_PLL0USB_CTRL_CLKEN = 0x10
	// Position of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Msk = 0x20
	// Bit RESERVED.
	CGU_PLL0USB_CTRL_RESERVED = 0x20
	// Position of FRM field.
	CGU_PLL0USB_CTRL_FRM_Pos = 0x6
	// Bit mask of FRM field.
	CGU_PLL0USB_CTRL_FRM_Msk = 0x40
	// Bit FRM.
	CGU_PLL0USB_CTRL_FRM = 0x40
	// Position of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Msk = 0x80
	// Bit RESERVED.
	CGU_PLL0USB_CTRL_RESERVED = 0x80
	// Position of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Msk = 0x100
	// Bit RESERVED.
	CGU_PLL0USB_CTRL_RESERVED = 0x100
	// Position of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Msk = 0x200
	// Bit RESERVED.
	CGU_PLL0USB_CTRL_RESERVED = 0x200
	// Position of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Msk = 0x400
	// Bit RESERVED.
	CGU_PLL0USB_CTRL_RESERVED = 0x400
	// Position of AUTOBLOCK field.
	CGU_PLL0USB_CTRL_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_PLL0USB_CTRL_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_PLL0USB_CTRL_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_PLL0USB_CTRL_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_PLL0USB_CTRL_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_PLL0USB_CTRL_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_PLL0USB_CTRL_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_PLL0USB_CTRL_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_PLL0USB_CTRL_CLK_SEL_IRC = 0x1
	// ENET_RX_CLK
	CGU_PLL0USB_CTRL_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_PLL0USB_CTRL_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_PLL0USB_CTRL_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_PLL0USB_CTRL_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL1
	CGU_PLL0USB_CTRL_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_PLL0USB_CTRL_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_PLL0USB_CTRL_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_PLL0USB_CTRL_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_PLL0USB_CTRL_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_PLL0USB_CTRL_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_PLL0USB_CTRL_RESERVED_Msk = 0xe0000000

	// PLL0USB_MDIV: PLL0USB M-divider register
	// Position of MDEC field.
	CGU_PLL0USB_MDIV_MDEC_Pos = 0x0
	// Bit mask of MDEC field.
	CGU_PLL0USB_MDIV_MDEC_Msk = 0x1ffff
	// Position of SELP field.
	CGU_PLL0USB_MDIV_SELP_Pos = 0x11
	// Bit mask of SELP field.
	CGU_PLL0USB_MDIV_SELP_Msk = 0x3e0000
	// Position of SELI field.
	CGU_PLL0USB_MDIV_SELI_Pos = 0x16
	// Bit mask of SELI field.
	CGU_PLL0USB_MDIV_SELI_Msk = 0xfc00000
	// Position of SELR field.
	CGU_PLL0USB_MDIV_SELR_Pos = 0x1c
	// Bit mask of SELR field.
	CGU_PLL0USB_MDIV_SELR_Msk = 0xf0000000

	// PLL0USB_NP_DIV: PLL0USB N/P-divider register
	// Position of PDEC field.
	CGU_PLL0USB_NP_DIV_PDEC_Pos = 0x0
	// Bit mask of PDEC field.
	CGU_PLL0USB_NP_DIV_PDEC_Msk = 0x7f
	// Position of RESERVED field.
	CGU_PLL0USB_NP_DIV_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	CGU_PLL0USB_NP_DIV_RESERVED_Msk = 0xf80
	// Position of NDEC field.
	CGU_PLL0USB_NP_DIV_NDEC_Pos = 0xc
	// Bit mask of NDEC field.
	CGU_PLL0USB_NP_DIV_NDEC_Msk = 0x3ff000
	// Position of RESERVED field.
	CGU_PLL0USB_NP_DIV_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	CGU_PLL0USB_NP_DIV_RESERVED_Msk = 0xffc00000

	// PLL0AUDIO_STAT: PLL0AUDIO status register
	// Position of LOCK field.
	CGU_PLL0AUDIO_STAT_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	CGU_PLL0AUDIO_STAT_LOCK_Msk = 0x1
	// Bit LOCK.
	CGU_PLL0AUDIO_STAT_LOCK = 0x1
	// Position of FR field.
	CGU_PLL0AUDIO_STAT_FR_Pos = 0x1
	// Bit mask of FR field.
	CGU_PLL0AUDIO_STAT_FR_Msk = 0x2
	// Bit FR.
	CGU_PLL0AUDIO_STAT_FR = 0x2
	// Position of RESERVED field.
	CGU_PLL0AUDIO_STAT_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_STAT_RESERVED_Msk = 0xfffffffc

	// PLL0AUDIO_CTRL: PLL0AUDIO control register
	// Position of PD field.
	CGU_PLL0AUDIO_CTRL_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_PLL0AUDIO_CTRL_PD_Msk = 0x1
	// Bit PD.
	CGU_PLL0AUDIO_CTRL_PD = 0x1
	// PLL0 enabled
	CGU_PLL0AUDIO_CTRL_PD_PLL0_ENABLED = 0x0
	// PLL0 powered down
	CGU_PLL0AUDIO_CTRL_PD_PLL0_POWERED_DOWN = 0x1
	// Position of BYPASS field.
	CGU_PLL0AUDIO_CTRL_BYPASS_Pos = 0x1
	// Bit mask of BYPASS field.
	CGU_PLL0AUDIO_CTRL_BYPASS_Msk = 0x2
	// Bit BYPASS.
	CGU_PLL0AUDIO_CTRL_BYPASS = 0x2
	// CCO clock sent to post-dividers. Use this in normal operation.
	CGU_PLL0AUDIO_CTRL_BYPASS_CCO_CLOCK_SENT_TO_PO = 0x0
	// PLL0 input clock sent to post-dividers (default).
	CGU_PLL0AUDIO_CTRL_BYPASS_PLL0_INPUT_CLOCK_SEN = 0x1
	// Position of DIRECTI field.
	CGU_PLL0AUDIO_CTRL_DIRECTI_Pos = 0x2
	// Bit mask of DIRECTI field.
	CGU_PLL0AUDIO_CTRL_DIRECTI_Msk = 0x4
	// Bit DIRECTI.
	CGU_PLL0AUDIO_CTRL_DIRECTI = 0x4
	// Position of DIRECTO field.
	CGU_PLL0AUDIO_CTRL_DIRECTO_Pos = 0x3
	// Bit mask of DIRECTO field.
	CGU_PLL0AUDIO_CTRL_DIRECTO_Msk = 0x8
	// Bit DIRECTO.
	CGU_PLL0AUDIO_CTRL_DIRECTO = 0x8
	// Position of CLKEN field.
	CGU_PLL0AUDIO_CTRL_CLKEN_Pos = 0x4
	// Bit mask of CLKEN field.
	CGU_PLL0AUDIO_CTRL_CLKEN_Msk = 0x10
	// Bit CLKEN.
	CGU_PLL0AUDIO_CTRL_CLKEN = 0x10
	// Position of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Msk = 0x20
	// Bit RESERVED.
	CGU_PLL0AUDIO_CTRL_RESERVED = 0x20
	// Position of FRM field.
	CGU_PLL0AUDIO_CTRL_FRM_Pos = 0x6
	// Bit mask of FRM field.
	CGU_PLL0AUDIO_CTRL_FRM_Msk = 0x40
	// Bit FRM.
	CGU_PLL0AUDIO_CTRL_FRM = 0x40
	// Position of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Msk = 0x80
	// Bit RESERVED.
	CGU_PLL0AUDIO_CTRL_RESERVED = 0x80
	// Position of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Msk = 0x100
	// Bit RESERVED.
	CGU_PLL0AUDIO_CTRL_RESERVED = 0x100
	// Position of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Msk = 0x200
	// Bit RESERVED.
	CGU_PLL0AUDIO_CTRL_RESERVED = 0x200
	// Position of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Msk = 0x400
	// Bit RESERVED.
	CGU_PLL0AUDIO_CTRL_RESERVED = 0x400
	// Position of AUTOBLOCK field.
	CGU_PLL0AUDIO_CTRL_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_PLL0AUDIO_CTRL_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_PLL0AUDIO_CTRL_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_PLL0AUDIO_CTRL_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_PLL0AUDIO_CTRL_AUTOBLOCK_ENABLED = 0x1
	// Position of PLLFRACT_REQ field.
	CGU_PLL0AUDIO_CTRL_PLLFRACT_REQ_Pos = 0xc
	// Bit mask of PLLFRACT_REQ field.
	CGU_PLL0AUDIO_CTRL_PLLFRACT_REQ_Msk = 0x1000
	// Bit PLLFRACT_REQ.
	CGU_PLL0AUDIO_CTRL_PLLFRACT_REQ = 0x1000
	// Position of SEL_EXT field.
	CGU_PLL0AUDIO_CTRL_SEL_EXT_Pos = 0xd
	// Bit mask of SEL_EXT field.
	CGU_PLL0AUDIO_CTRL_SEL_EXT_Msk = 0x2000
	// Bit SEL_EXT.
	CGU_PLL0AUDIO_CTRL_SEL_EXT = 0x2000
	// FRAC Enabled. Enable fractional divider.
	CGU_PLL0AUDIO_CTRL_SEL_EXT_FRAC_ENABLED = 0x0
	// MDEC enabled. Fractional divider not used.
	CGU_PLL0AUDIO_CTRL_SEL_EXT_MDEC_ENABLED = 0x1
	// Position of MOD_PD field.
	CGU_PLL0AUDIO_CTRL_MOD_PD_Pos = 0xe
	// Bit mask of MOD_PD field.
	CGU_PLL0AUDIO_CTRL_MOD_PD_Msk = 0x4000
	// Bit MOD_PD.
	CGU_PLL0AUDIO_CTRL_MOD_PD = 0x4000
	// Enabled. Sigma-Delta modulator enabled
	CGU_PLL0AUDIO_CTRL_MOD_PD_ENABLED = 0x0
	// Disabled. Sigma-Delta modulator powered down
	CGU_PLL0AUDIO_CTRL_MOD_PD_DISABLED = 0x1
	// Position of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Msk = 0xff8000
	// Position of CLK_SEL field.
	CGU_PLL0AUDIO_CTRL_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_PLL0AUDIO_CTRL_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_PLL0AUDIO_CTRL_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_PLL0AUDIO_CTRL_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_PLL0AUDIO_CTRL_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_PLL0AUDIO_CTRL_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_PLL0AUDIO_CTRL_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_PLL0AUDIO_CTRL_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL1
	CGU_PLL0AUDIO_CTRL_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_PLL0AUDIO_CTRL_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_PLL0AUDIO_CTRL_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_PLL0AUDIO_CTRL_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_PLL0AUDIO_CTRL_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_PLL0AUDIO_CTRL_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_CTRL_RESERVED_Msk = 0xe0000000

	// PLL0AUDIO_MDIV: PLL0AUDIO M-divider register
	// Position of MDEC field.
	CGU_PLL0AUDIO_MDIV_MDEC_Pos = 0x0
	// Bit mask of MDEC field.
	CGU_PLL0AUDIO_MDIV_MDEC_Msk = 0x1ffff
	// Position of RESERVED field.
	CGU_PLL0AUDIO_MDIV_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_MDIV_RESERVED_Msk = 0xfffe0000

	// PLL0AUDIO_NP_DIV: PLL0AUDIO N/P-divider register
	// Position of PDEC field.
	CGU_PLL0AUDIO_NP_DIV_PDEC_Pos = 0x0
	// Bit mask of PDEC field.
	CGU_PLL0AUDIO_NP_DIV_PDEC_Msk = 0x7f
	// Position of RESERVED field.
	CGU_PLL0AUDIO_NP_DIV_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_NP_DIV_RESERVED_Msk = 0xf80
	// Position of NDEC field.
	CGU_PLL0AUDIO_NP_DIV_NDEC_Pos = 0xc
	// Bit mask of NDEC field.
	CGU_PLL0AUDIO_NP_DIV_NDEC_Msk = 0x3ff000
	// Position of RESERVED field.
	CGU_PLL0AUDIO_NP_DIV_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_NP_DIV_RESERVED_Msk = 0xffc00000

	// PLL0AUDIO_FRAC: PLL0AUDIO fractional divider register
	// Position of PLLFRACT_CTRL field.
	CGU_PLL0AUDIO_FRAC_PLLFRACT_CTRL_Pos = 0x0
	// Bit mask of PLLFRACT_CTRL field.
	CGU_PLL0AUDIO_FRAC_PLLFRACT_CTRL_Msk = 0x3fffff
	// Position of RESERVED field.
	CGU_PLL0AUDIO_FRAC_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	CGU_PLL0AUDIO_FRAC_RESERVED_Msk = 0xffc00000

	// PLL1_STAT: PLL1 status register
	// Position of LOCK field.
	CGU_PLL1_STAT_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	CGU_PLL1_STAT_LOCK_Msk = 0x1
	// Bit LOCK.
	CGU_PLL1_STAT_LOCK = 0x1
	// Position of RESERVED field.
	CGU_PLL1_STAT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_PLL1_STAT_RESERVED_Msk = 0xfffffffe

	// PLL1_CTRL: PLL1 control register
	// Position of PD field.
	CGU_PLL1_CTRL_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_PLL1_CTRL_PD_Msk = 0x1
	// Bit PD.
	CGU_PLL1_CTRL_PD = 0x1
	// PLL1 enabled
	CGU_PLL1_CTRL_PD_PLL1_ENABLED = 0x0
	// PLL1 powered down
	CGU_PLL1_CTRL_PD_PLL1_POWERED_DOWN = 0x1
	// Position of BYPASS field.
	CGU_PLL1_CTRL_BYPASS_Pos = 0x1
	// Bit mask of BYPASS field.
	CGU_PLL1_CTRL_BYPASS_Msk = 0x2
	// Bit BYPASS.
	CGU_PLL1_CTRL_BYPASS = 0x2
	// Normal. CCO clock sent to post-dividers. Use for normal operation.
	CGU_PLL1_CTRL_BYPASS_NORMAL = 0x0
	// Input clock. PLL1 input clock sent to post-dividers (default).
	CGU_PLL1_CTRL_BYPASS_INPUT_CLOCK = 0x1
	// Position of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Msk = 0x4
	// Bit RESERVED.
	CGU_PLL1_CTRL_RESERVED = 0x4
	// Position of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Msk = 0x38
	// Position of FBSEL field.
	CGU_PLL1_CTRL_FBSEL_Pos = 0x6
	// Bit mask of FBSEL field.
	CGU_PLL1_CTRL_FBSEL_Msk = 0x40
	// Bit FBSEL.
	CGU_PLL1_CTRL_FBSEL = 0x40
	// CCO out. CCO output is used as feedback divider input clock.
	CGU_PLL1_CTRL_FBSEL_CCO_OUT = 0x0
	// PLL out. PLL output clock (clkout) is used as feedback divider input clock. Use for normal operation.
	CGU_PLL1_CTRL_FBSEL_PLL_OUT = 0x1
	// Position of DIRECT field.
	CGU_PLL1_CTRL_DIRECT_Pos = 0x7
	// Bit mask of DIRECT field.
	CGU_PLL1_CTRL_DIRECT_Msk = 0x80
	// Bit DIRECT.
	CGU_PLL1_CTRL_DIRECT = 0x80
	// Disabled
	CGU_PLL1_CTRL_DIRECT_DISABLED = 0x0
	// Enabled
	CGU_PLL1_CTRL_DIRECT_ENABLED = 0x1
	// Position of PSEL field.
	CGU_PLL1_CTRL_PSEL_Pos = 0x8
	// Bit mask of PSEL field.
	CGU_PLL1_CTRL_PSEL_Msk = 0x300
	// 1
	CGU_PLL1_CTRL_PSEL_1 = 0x0
	// 2 (default)
	CGU_PLL1_CTRL_PSEL_PEQ2 = 0x1
	// 4
	CGU_PLL1_CTRL_PSEL_PEQ4 = 0x2
	// 8
	CGU_PLL1_CTRL_PSEL_8 = 0x3
	// Position of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Msk = 0x400
	// Bit RESERVED.
	CGU_PLL1_CTRL_RESERVED = 0x400
	// Position of AUTOBLOCK field.
	CGU_PLL1_CTRL_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_PLL1_CTRL_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_PLL1_CTRL_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_PLL1_CTRL_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_PLL1_CTRL_AUTOBLOCK_ENABLED = 0x1
	// Position of NSEL field.
	CGU_PLL1_CTRL_NSEL_Pos = 0xc
	// Bit mask of NSEL field.
	CGU_PLL1_CTRL_NSEL_Msk = 0x3000
	// 1
	CGU_PLL1_CTRL_NSEL_1 = 0x0
	// 2
	CGU_PLL1_CTRL_NSEL_NEQ2 = 0x1
	// 3 (default)
	CGU_PLL1_CTRL_NSEL_NEQ3 = 0x2
	// 4
	CGU_PLL1_CTRL_NSEL_4 = 0x3
	// Position of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Msk = 0xc000
	// Position of MSEL field.
	CGU_PLL1_CTRL_MSEL_Pos = 0x10
	// Bit mask of MSEL field.
	CGU_PLL1_CTRL_MSEL_Msk = 0xff0000
	// Position of CLK_SEL field.
	CGU_PLL1_CTRL_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_PLL1_CTRL_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_PLL1_CTRL_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_PLL1_CTRL_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_PLL1_CTRL_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_PLL1_CTRL_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_PLL1_CTRL_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_PLL1_CTRL_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0USB
	CGU_PLL1_CTRL_CLK_SEL_PLL0USB = 0x7
	// PLL0AUDIO
	CGU_PLL1_CTRL_CLK_SEL_PLL0AUDIO = 0x8
	// IDIVA
	CGU_PLL1_CTRL_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_PLL1_CTRL_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_PLL1_CTRL_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_PLL1_CTRL_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_PLL1_CTRL_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_PLL1_CTRL_RESERVED_Msk = 0xe0000000

	// IDIVA_CTRL: Integer divider A control register
	// Position of PD field.
	CGU_IDIVA_CTRL_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_IDIVA_CTRL_PD_Msk = 0x1
	// Bit PD.
	CGU_IDIVA_CTRL_PD = 0x1
	// Enabled. IDIVA enabled (default)
	CGU_IDIVA_CTRL_PD_ENABLED = 0x0
	// Power-down
	CGU_IDIVA_CTRL_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_IDIVA_CTRL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_IDIVA_CTRL_RESERVED_Msk = 0x2
	// Bit RESERVED.
	CGU_IDIVA_CTRL_RESERVED = 0x2
	// Position of IDIV field.
	CGU_IDIVA_CTRL_IDIV_Pos = 0x2
	// Bit mask of IDIV field.
	CGU_IDIVA_CTRL_IDIV_Msk = 0xc
	// 1 (default)
	CGU_IDIVA_CTRL_IDIV_DIV1 = 0x0
	// 2
	CGU_IDIVA_CTRL_IDIV_DIV2 = 0x1
	// 3
	CGU_IDIVA_CTRL_IDIV_DIV3 = 0x2
	// 4
	CGU_IDIVA_CTRL_IDIV_DIV4 = 0x3
	// Position of RESERVED field.
	CGU_IDIVA_CTRL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	CGU_IDIVA_CTRL_RESERVED_Msk = 0x7f0
	// Position of AUTOBLOCK field.
	CGU_IDIVA_CTRL_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_IDIVA_CTRL_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_IDIVA_CTRL_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_IDIVA_CTRL_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_IDIVA_CTRL_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_IDIVA_CTRL_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_IDIVA_CTRL_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_IDIVA_CTRL_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_IDIVA_CTRL_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_IDIVA_CTRL_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_IDIVA_CTRL_CLK_SEL_IRC = 0x1
	// ENET_RX_CLK
	CGU_IDIVA_CTRL_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_IDIVA_CTRL_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_IDIVA_CTRL_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_IDIVA_CTRL_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0USB
	CGU_IDIVA_CTRL_CLK_SEL_PLL0USB = 0x7
	// PLL0AUDIO
	CGU_IDIVA_CTRL_CLK_SEL_PLL0AUDIO = 0x8
	// PLL1
	CGU_IDIVA_CTRL_CLK_SEL_PLL1 = 0x9
	// Position of RESERVED field.
	CGU_IDIVA_CTRL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_IDIVA_CTRL_RESERVED_Msk = 0xe0000000

	// IDIVB_CTRL: Integer divider B control register
	// Position of PD field.
	CGU_IDIVB_CTRL_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_IDIVB_CTRL_PD_Msk = 0x1
	// Bit PD.
	CGU_IDIVB_CTRL_PD = 0x1
	// Enabled. IDIV enabled (default)
	CGU_IDIVB_CTRL_PD_ENABLED = 0x0
	// Power-down
	CGU_IDIVB_CTRL_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_IDIVB_CTRL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_IDIVB_CTRL_RESERVED_Msk = 0x2
	// Bit RESERVED.
	CGU_IDIVB_CTRL_RESERVED = 0x2
	// Position of IDIV field.
	CGU_IDIVB_CTRL_IDIV_Pos = 0x2
	// Bit mask of IDIV field.
	CGU_IDIVB_CTRL_IDIV_Msk = 0x3c
	// Position of RESERVED field.
	CGU_IDIVB_CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CGU_IDIVB_CTRL_RESERVED_Msk = 0x7c0
	// Position of AUTOBLOCK field.
	CGU_IDIVB_CTRL_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_IDIVB_CTRL_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_IDIVB_CTRL_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_IDIVB_CTRL_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_IDIVB_CTRL_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_IDIVB_CTRL_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_IDIVB_CTRL_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_IDIVB_CTRL_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_IDIVB_CTRL_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_IDIVB_CTRL_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_IDIVB_CTRL_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_IDIVB_CTRL_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_IDIVB_CTRL_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_IDIVB_CTRL_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_IDIVB_CTRL_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0AUDIO
	CGU_IDIVB_CTRL_CLK_SEL_PLL0AUDIO = 0x8
	// PLL1
	CGU_IDIVB_CTRL_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_IDIVB_CTRL_CLK_SEL_IDIVA = 0xc
	// Position of RESERVED field.
	CGU_IDIVB_CTRL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_IDIVB_CTRL_RESERVED_Msk = 0xe0000000

	// IDIVC_CTRL: Integer divider C control register
	// Position of PD field.
	CGU_IDIVC_CTRL_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_IDIVC_CTRL_PD_Msk = 0x1
	// Bit PD.
	CGU_IDIVC_CTRL_PD = 0x1
	// Enabled. IDIV enabled (default)
	CGU_IDIVC_CTRL_PD_ENABLED = 0x0
	// Power-down
	CGU_IDIVC_CTRL_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_IDIVC_CTRL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_IDIVC_CTRL_RESERVED_Msk = 0x2
	// Bit RESERVED.
	CGU_IDIVC_CTRL_RESERVED = 0x2
	// Position of IDIV field.
	CGU_IDIVC_CTRL_IDIV_Pos = 0x2
	// Bit mask of IDIV field.
	CGU_IDIVC_CTRL_IDIV_Msk = 0x3c
	// Position of RESERVED field.
	CGU_IDIVC_CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CGU_IDIVC_CTRL_RESERVED_Msk = 0x7c0
	// Position of AUTOBLOCK field.
	CGU_IDIVC_CTRL_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_IDIVC_CTRL_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_IDIVC_CTRL_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_IDIVC_CTRL_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_IDIVC_CTRL_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_IDIVC_CTRL_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_IDIVC_CTRL_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_IDIVC_CTRL_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_IDIVC_CTRL_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_IDIVC_CTRL_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_IDIVC_CTRL_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_IDIVC_CTRL_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_IDIVC_CTRL_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_IDIVC_CTRL_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_IDIVC_CTRL_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0AUDIO
	CGU_IDIVC_CTRL_CLK_SEL_PLL0AUDIO = 0x8
	// PLL1
	CGU_IDIVC_CTRL_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_IDIVC_CTRL_CLK_SEL_IDIVA = 0xc
	// Position of RESERVED field.
	CGU_IDIVC_CTRL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_IDIVC_CTRL_RESERVED_Msk = 0xe0000000

	// IDIVD_CTRL: Integer divider D control register
	// Position of PD field.
	CGU_IDIVD_CTRL_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_IDIVD_CTRL_PD_Msk = 0x1
	// Bit PD.
	CGU_IDIVD_CTRL_PD = 0x1
	// Enabled. IDIV enabled (default)
	CGU_IDIVD_CTRL_PD_ENABLED = 0x0
	// Power-down
	CGU_IDIVD_CTRL_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_IDIVD_CTRL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_IDIVD_CTRL_RESERVED_Msk = 0x2
	// Bit RESERVED.
	CGU_IDIVD_CTRL_RESERVED = 0x2
	// Position of IDIV field.
	CGU_IDIVD_CTRL_IDIV_Pos = 0x2
	// Bit mask of IDIV field.
	CGU_IDIVD_CTRL_IDIV_Msk = 0x3c
	// Position of RESERVED field.
	CGU_IDIVD_CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CGU_IDIVD_CTRL_RESERVED_Msk = 0x7c0
	// Position of AUTOBLOCK field.
	CGU_IDIVD_CTRL_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_IDIVD_CTRL_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_IDIVD_CTRL_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_IDIVD_CTRL_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_IDIVD_CTRL_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_IDIVD_CTRL_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_IDIVD_CTRL_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_IDIVD_CTRL_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_IDIVD_CTRL_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_IDIVD_CTRL_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_IDIVD_CTRL_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_IDIVD_CTRL_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_IDIVD_CTRL_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_IDIVD_CTRL_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_IDIVD_CTRL_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0AUDIO
	CGU_IDIVD_CTRL_CLK_SEL_PLL0AUDIO = 0x8
	// PLL1
	CGU_IDIVD_CTRL_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_IDIVD_CTRL_CLK_SEL_IDIVA = 0xc
	// Position of RESERVED field.
	CGU_IDIVD_CTRL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_IDIVD_CTRL_RESERVED_Msk = 0xe0000000

	// IDIVE_CTRL: Integer divider E control register
	// Position of PD field.
	CGU_IDIVE_CTRL_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_IDIVE_CTRL_PD_Msk = 0x1
	// Bit PD.
	CGU_IDIVE_CTRL_PD = 0x1
	// Enabled. IDIV enabled (default)
	CGU_IDIVE_CTRL_PD_ENABLED = 0x0
	// Power-down
	CGU_IDIVE_CTRL_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_IDIVE_CTRL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_IDIVE_CTRL_RESERVED_Msk = 0x2
	// Bit RESERVED.
	CGU_IDIVE_CTRL_RESERVED = 0x2
	// Position of IDIV field.
	CGU_IDIVE_CTRL_IDIV_Pos = 0x2
	// Bit mask of IDIV field.
	CGU_IDIVE_CTRL_IDIV_Msk = 0x3fc
	// Position of RESERVED field.
	CGU_IDIVE_CTRL_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	CGU_IDIVE_CTRL_RESERVED_Msk = 0x400
	// Bit RESERVED.
	CGU_IDIVE_CTRL_RESERVED = 0x400
	// Position of AUTOBLOCK field.
	CGU_IDIVE_CTRL_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_IDIVE_CTRL_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_IDIVE_CTRL_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_IDIVE_CTRL_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_IDIVE_CTRL_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_IDIVE_CTRL_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_IDIVE_CTRL_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_IDIVE_CTRL_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_IDIVE_CTRL_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_IDIVE_CTRL_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_IDIVE_CTRL_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_IDIVE_CTRL_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_IDIVE_CTRL_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_IDIVE_CTRL_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_IDIVE_CTRL_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0AUDIO
	CGU_IDIVE_CTRL_CLK_SEL_PLL0AUDIO = 0x8
	// PLL1
	CGU_IDIVE_CTRL_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_IDIVE_CTRL_CLK_SEL_IDIVA = 0xc
	// Position of RESERVED field.
	CGU_IDIVE_CTRL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_IDIVE_CTRL_RESERVED_Msk = 0xe0000000

	// BASE_SAFE_CLK: Output stage 0 control register for base clock BASE_SAFE_CLK
	// Position of PD field.
	CGU_BASE_SAFE_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_SAFE_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_SAFE_CLK_PD = 0x1
	// Enabled. Output stage enabled (default)
	CGU_BASE_SAFE_CLK_PD_ENABLED = 0x0
	// Power-down
	CGU_BASE_SAFE_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_SAFE_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_SAFE_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_SAFE_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_SAFE_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_SAFE_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_SAFE_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_SAFE_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_SAFE_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_SAFE_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_SAFE_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_SAFE_CLK_CLK_SEL_Msk = 0x1f000000
	// IRC (default)
	CGU_BASE_SAFE_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// Position of RESERVED field.
	CGU_BASE_SAFE_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_SAFE_CLK_RESERVED_Msk = 0xe0000000

	// BASE_USB0_CLK: Output stage 1 control register for base clock BASE_USB0_CLK
	// Position of PD field.
	CGU_BASE_USB0_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_USB0_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_USB0_CLK_PD = 0x1
	// Enabled. Output stage enabled (default)
	CGU_BASE_USB0_CLK_PD_ENABLED = 0x0
	// Power-down
	CGU_BASE_USB0_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_USB0_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_USB0_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_USB0_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_USB0_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_USB0_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_USB0_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_USB0_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_USB0_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_USB0_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_USB0_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_USB0_CLK_CLK_SEL_Msk = 0x1f000000
	// PLL0USB (default)
	CGU_BASE_USB0_CLK_CLK_SEL_PLL0USB = 0x7
	// Position of RESERVED field.
	CGU_BASE_USB0_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_USB0_CLK_RESERVED_Msk = 0xe0000000

	// BASE_PERIPH_CLK: Output stage 2 control register for base clock BASE_PERIPH_CLK
	// Position of PD field.
	CGU_BASE_PERIPH_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_PERIPH_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_PERIPH_CLK_PD = 0x1
	// Enabled. Output stage enabled (default)
	CGU_BASE_PERIPH_CLK_PD_ENABLED = 0x0
	// Power-down
	CGU_BASE_PERIPH_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_PERIPH_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_PERIPH_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_PERIPH_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_PERIPH_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_PERIPH_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_PERIPH_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_PERIPH_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_PERIPH_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_PERIPH_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_PERIPH_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_PERIPH_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_PERIPH_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_PERIPH_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_PERIPH_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_PERIPH_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_PERIPH_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_PERIPH_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0AUDIO
	CGU_BASE_PERIPH_CLK_CLK_SEL_PLL0AUDIO = 0x8
	// PLL1
	CGU_BASE_PERIPH_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_PERIPH_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_PERIPH_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_PERIPH_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_PERIPH_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_PERIPH_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_PERIPH_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_PERIPH_CLK_RESERVED_Msk = 0xe0000000

	// BASE_USB1_CLK: Output stage 3 control register for base clock BASE_USB1_CLK
	// Position of PD field.
	CGU_BASE_USB1_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_USB1_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_USB1_CLK_PD = 0x1
	// Enabled. Output stage enabled (default)
	CGU_BASE_USB1_CLK_PD_ENABLED = 0x0
	// Power-down
	CGU_BASE_USB1_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_USB1_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_USB1_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_USB1_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_USB1_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_USB1_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_USB1_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_USB1_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_USB1_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_USB1_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_USB1_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_USB1_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_USB1_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_USB1_CLK_CLK_SEL_IRC = 0x1
	// ENET_RX_CLK
	CGU_BASE_USB1_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_USB1_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_USB1_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_USB1_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0USB
	CGU_BASE_USB1_CLK_CLK_SEL_PLL0USB = 0x7
	// PLL0AUDIO
	CGU_BASE_USB1_CLK_CLK_SEL_PLL0AUDIO = 0x8
	// PLL1
	CGU_BASE_USB1_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_USB1_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_USB1_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_USB1_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_USB1_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_USB1_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_USB1_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_USB1_CLK_RESERVED_Msk = 0xe0000000

	// BASE_M3_CLK: Output stage BASE_M3_CLK control register
	// Position of PD field.
	CGU_BASE_M3_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_M3_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_M3_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_M3_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_M3_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_M3_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_M3_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_M3_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_M3_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_M3_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_M3_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_M3_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_M3_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_M3_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_M3_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_M3_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_M3_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_M3_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_M3_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_M3_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_M3_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_M3_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_M3_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_M3_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_M3_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_M3_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_M3_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_M3_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_M3_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_M3_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_M3_CLK_RESERVED_Msk = 0xe0000000

	// BASE_SPIFI_CLK: Output stage BASE_SPIFI_CLK control register
	// Position of PD field.
	CGU_BASE_SPIFI_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_SPIFI_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_SPIFI_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_SPIFI_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_SPIFI_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_SPIFI_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_SPIFI_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_SPIFI_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_SPIFI_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_SPIFI_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_SPIFI_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_SPIFI_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_SPIFI_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_SPIFI_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_SPIFI_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_SPIFI_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_SPIFI_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_SPIFI_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_SPIFI_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_SPIFI_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_SPIFI_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_SPIFI_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_SPIFI_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_SPIFI_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_SPIFI_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_SPIFI_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_SPIFI_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_SPIFI_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_SPIFI_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_SPIFI_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_SPIFI_CLK_RESERVED_Msk = 0xe0000000

	// BASE_PHY_RX_CLK: Output stage BASE_PHY_RX_CLK control register
	// Position of PD field.
	CGU_BASE_PHY_RX_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_PHY_RX_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_PHY_RX_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_PHY_RX_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_PHY_RX_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_PHY_RX_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_PHY_RX_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_PHY_RX_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_PHY_RX_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_PHY_RX_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_PHY_RX_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_PHY_RX_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_PHY_RX_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_PHY_RX_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_PHY_RX_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_PHY_RX_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_PHY_RX_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_PHY_RX_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_PHY_RX_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_PHY_RX_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_PHY_RX_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_PHY_RX_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_PHY_RX_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_PHY_RX_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_PHY_RX_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_PHY_RX_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_PHY_RX_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_PHY_RX_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_PHY_RX_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_PHY_RX_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_PHY_RX_CLK_RESERVED_Msk = 0xe0000000

	// BASE_PHY_TX_CLK: Output stage BASE_PHY_TX_CLK control register
	// Position of PD field.
	CGU_BASE_PHY_TX_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_PHY_TX_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_PHY_TX_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_PHY_TX_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_PHY_TX_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_PHY_TX_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_PHY_TX_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_PHY_TX_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_PHY_TX_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_PHY_TX_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_PHY_TX_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_PHY_TX_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_PHY_TX_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_PHY_TX_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_PHY_TX_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_PHY_TX_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_PHY_TX_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_PHY_TX_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_PHY_TX_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_PHY_TX_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_PHY_TX_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_PHY_TX_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_PHY_TX_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_PHY_TX_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_PHY_TX_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_PHY_TX_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_PHY_TX_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_PHY_TX_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_PHY_TX_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_PHY_TX_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_PHY_TX_CLK_RESERVED_Msk = 0xe0000000

	// BASE_APB1_CLK: Output stage BASE_APB1_CLK control register
	// Position of PD field.
	CGU_BASE_APB1_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_APB1_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_APB1_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_APB1_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_APB1_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_APB1_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_APB1_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_APB1_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_APB1_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_APB1_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_APB1_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_APB1_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_APB1_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_APB1_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_APB1_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_APB1_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_APB1_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_APB1_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_APB1_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_APB1_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_APB1_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_APB1_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_APB1_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_APB1_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_APB1_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_APB1_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_APB1_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_APB1_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_APB1_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_APB1_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_APB1_CLK_RESERVED_Msk = 0xe0000000

	// BASE_APB3_CLK: Output stage BASE_APB3_CLK control register
	// Position of PD field.
	CGU_BASE_APB3_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_APB3_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_APB3_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_APB3_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_APB3_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_APB3_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_APB3_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_APB3_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_APB3_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_APB3_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_APB3_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_APB3_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_APB3_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_APB3_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_APB3_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_APB3_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_APB3_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_APB3_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_APB3_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_APB3_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_APB3_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_APB3_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_APB3_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_APB3_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_APB3_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_APB3_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_APB3_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_APB3_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_APB3_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_APB3_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_APB3_CLK_RESERVED_Msk = 0xe0000000

	// BASE_LCD_CLK: Output stage BASE_LCD_CLK control register
	// Position of PD field.
	CGU_BASE_LCD_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_LCD_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_LCD_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_LCD_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_LCD_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_LCD_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_LCD_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_LCD_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_LCD_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_LCD_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_LCD_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_LCD_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_LCD_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_LCD_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_LCD_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_LCD_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_LCD_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_LCD_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_LCD_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_LCD_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_LCD_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_LCD_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_LCD_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_LCD_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_LCD_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_LCD_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_LCD_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_LCD_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_LCD_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_LCD_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_LCD_CLK_RESERVED_Msk = 0xe0000000

	// BASE_SDIO_CLK: Output stage BASE_SDIO_CLK control register
	// Position of PD field.
	CGU_BASE_SDIO_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_SDIO_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_SDIO_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_SDIO_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_SDIO_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_SDIO_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_SDIO_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_SDIO_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_SDIO_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_SDIO_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_SDIO_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_SDIO_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_SDIO_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_SDIO_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_SDIO_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_SDIO_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_SDIO_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_SDIO_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_SDIO_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_SDIO_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_SDIO_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_SDIO_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_SDIO_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_SDIO_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_SDIO_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_SDIO_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_SDIO_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_SDIO_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_SDIO_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_SDIO_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_SDIO_CLK_RESERVED_Msk = 0xe0000000

	// BASE_SSP0_CLK: Output stage BASE_SSP0_CLK control register
	// Position of PD field.
	CGU_BASE_SSP0_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_SSP0_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_SSP0_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_SSP0_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_SSP0_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_SSP0_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_SSP0_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_SSP0_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_SSP0_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_SSP0_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_SSP0_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_SSP0_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_SSP0_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_SSP0_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_SSP0_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_SSP0_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_SSP0_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_SSP0_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_SSP0_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_SSP0_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_SSP0_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_SSP0_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_SSP0_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_SSP0_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_SSP0_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_SSP0_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_SSP0_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_SSP0_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_SSP0_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_SSP0_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_SSP0_CLK_RESERVED_Msk = 0xe0000000

	// BASE_SSP1_CLK: Output stage BASE_SSP1_CLK control register
	// Position of PD field.
	CGU_BASE_SSP1_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_SSP1_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_SSP1_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_SSP1_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_SSP1_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_SSP1_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_SSP1_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_SSP1_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_SSP1_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_SSP1_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_SSP1_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_SSP1_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_SSP1_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_SSP1_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_SSP1_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_SSP1_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_SSP1_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_SSP1_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_SSP1_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_SSP1_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_SSP1_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_SSP1_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_SSP1_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_SSP1_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_SSP1_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_SSP1_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_SSP1_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_SSP1_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_SSP1_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_SSP1_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_SSP1_CLK_RESERVED_Msk = 0xe0000000

	// BASE_UART0_CLK: Output stage BASE_UART0_CLK control register
	// Position of PD field.
	CGU_BASE_UART0_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_UART0_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_UART0_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_UART0_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_UART0_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_UART0_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_UART0_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_UART0_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_UART0_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_UART0_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_UART0_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_UART0_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_UART0_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_UART0_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_UART0_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_UART0_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_UART0_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_UART0_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_UART0_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_UART0_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_UART0_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_UART0_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_UART0_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_UART0_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_UART0_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_UART0_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_UART0_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_UART0_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_UART0_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_UART0_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_UART0_CLK_RESERVED_Msk = 0xe0000000

	// BASE_UART1_CLK: Output stage BASE_UART1_CLK control register
	// Position of PD field.
	CGU_BASE_UART1_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_UART1_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_UART1_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_UART1_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_UART1_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_UART1_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_UART1_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_UART1_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_UART1_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_UART1_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_UART1_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_UART1_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_UART1_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_UART1_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_UART1_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_UART1_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_UART1_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_UART1_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_UART1_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_UART1_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_UART1_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_UART1_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_UART1_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_UART1_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_UART1_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_UART1_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_UART1_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_UART1_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_UART1_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_UART1_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_UART1_CLK_RESERVED_Msk = 0xe0000000

	// BASE_UART2_CLK: Output stage BASE_UART2_CLK control register
	// Position of PD field.
	CGU_BASE_UART2_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_UART2_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_UART2_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_UART2_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_UART2_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_UART2_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_UART2_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_UART2_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_UART2_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_UART2_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_UART2_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_UART2_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_UART2_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_UART2_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_UART2_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_UART2_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_UART2_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_UART2_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_UART2_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_UART2_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_UART2_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_UART2_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_UART2_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_UART2_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_UART2_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_UART2_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_UART2_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_UART2_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_UART2_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_UART2_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_UART2_CLK_RESERVED_Msk = 0xe0000000

	// BASE_UART3_CLK: Output stage BASE_UART3_CLK control register
	// Position of PD field.
	CGU_BASE_UART3_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_UART3_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_UART3_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_UART3_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_UART3_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_UART3_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_UART3_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_UART3_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_UART3_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_UART3_CLK_AUTOBLOCK = 0x800
	// Disabled. Autoblocking disabled
	CGU_BASE_UART3_CLK_AUTOBLOCK_DISABLED = 0x0
	// Enabled. Autoblocking enabled
	CGU_BASE_UART3_CLK_AUTOBLOCK_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_UART3_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_UART3_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_UART3_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_UART3_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_UART3_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_UART3_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_UART3_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_UART3_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_UART3_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_UART3_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_UART3_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_UART3_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_UART3_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_UART3_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_UART3_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_UART3_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_UART3_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_UART3_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_UART3_CLK_RESERVED_Msk = 0xe0000000

	// BASE_OUT_CLK: Output stage 20 control register for base clock BASE_OUT_CLK
	// Position of PD field.
	CGU_BASE_OUT_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_OUT_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_OUT_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_OUT_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_OUT_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_OUT_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_OUT_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_OUT_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_OUT_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_OUT_CLK_AUTOBLOCK = 0x800
	// Autoblocking disabled
	CGU_BASE_OUT_CLK_AUTOBLOCK_AUTOBLOCKING_DISABLE = 0x0
	// Autoblocking enabled
	CGU_BASE_OUT_CLK_AUTOBLOCK_AUTOBLOCKING_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_OUT_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_OUT_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_OUT_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_OUT_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_OUT_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_OUT_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_OUT_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_OUT_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_OUT_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_OUT_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for USB)
	CGU_BASE_OUT_CLK_CLK_SEL_PLL0_FOR_USB = 0x7
	// PLL0 (for audio)
	CGU_BASE_OUT_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_OUT_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_OUT_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_OUT_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_OUT_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_OUT_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_OUT_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_OUT_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_OUT_CLK_RESERVED_Msk = 0xe0000000

	// BASE_AUDIO_CLK: Output stage 25 control register for base clock BASE_AUDIO_CLK
	// Position of PD field.
	CGU_BASE_AUDIO_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_AUDIO_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_AUDIO_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_AUDIO_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_AUDIO_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_AUDIO_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_AUDIO_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_AUDIO_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_AUDIO_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_AUDIO_CLK_AUTOBLOCK = 0x800
	// Autoblocking disabled
	CGU_BASE_AUDIO_CLK_AUTOBLOCK_AUTOBLOCKING_DISABLE = 0x0
	// Autoblocking enabled
	CGU_BASE_AUDIO_CLK_AUTOBLOCK_AUTOBLOCKING_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_AUDIO_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_AUDIO_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_AUDIO_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_AUDIO_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_AUDIO_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_AUDIO_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_AUDIO_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_AUDIO_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_AUDIO_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_AUDIO_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_AUDIO_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_AUDIO_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_AUDIO_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_AUDIO_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_AUDIO_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_AUDIO_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_AUDIO_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_AUDIO_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_AUDIO_CLK_RESERVED_Msk = 0xe0000000

	// BASE_CGU_OUT0_CLK: Output stage 25 control register for base clock BASE_CGU_OUT0_CLK
	// Position of PD field.
	CGU_BASE_CGU_OUT0_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_CGU_OUT0_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_CGU_OUT0_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_CGU_OUT0_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_CGU_OUT0_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_CGU_OUT0_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_CGU_OUT0_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_CGU_OUT0_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_CGU_OUT0_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_CGU_OUT0_CLK_AUTOBLOCK = 0x800
	// Autoblocking disabled
	CGU_BASE_CGU_OUT0_CLK_AUTOBLOCK_AUTOBLOCKING_DISABLE = 0x0
	// Autoblocking enabled
	CGU_BASE_CGU_OUT0_CLK_AUTOBLOCK_AUTOBLOCKING_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_CGU_OUT0_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_CGU_OUT0_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_CGU_OUT0_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_CGU_OUT0_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_CGU_OUT0_CLK_RESERVED_Msk = 0xe0000000

	// BASE_CGU_OUT1_CLK: Output stage 25 control register for base clock BASE_CGU_OUT1_CLK
	// Position of PD field.
	CGU_BASE_CGU_OUT1_CLK_PD_Pos = 0x0
	// Bit mask of PD field.
	CGU_BASE_CGU_OUT1_CLK_PD_Msk = 0x1
	// Bit PD.
	CGU_BASE_CGU_OUT1_CLK_PD = 0x1
	// Output stage enabled (default)
	CGU_BASE_CGU_OUT1_CLK_PD_OUTPUT_STAGE_ENABLED = 0x0
	// power-down
	CGU_BASE_CGU_OUT1_CLK_PD_POWER_DOWN = 0x1
	// Position of RESERVED field.
	CGU_BASE_CGU_OUT1_CLK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CGU_BASE_CGU_OUT1_CLK_RESERVED_Msk = 0x7fe
	// Position of AUTOBLOCK field.
	CGU_BASE_CGU_OUT1_CLK_AUTOBLOCK_Pos = 0xb
	// Bit mask of AUTOBLOCK field.
	CGU_BASE_CGU_OUT1_CLK_AUTOBLOCK_Msk = 0x800
	// Bit AUTOBLOCK.
	CGU_BASE_CGU_OUT1_CLK_AUTOBLOCK = 0x800
	// Autoblocking disabled
	CGU_BASE_CGU_OUT1_CLK_AUTOBLOCK_AUTOBLOCKING_DISABLE = 0x0
	// Autoblocking enabled
	CGU_BASE_CGU_OUT1_CLK_AUTOBLOCK_AUTOBLOCKING_ENABLED = 0x1
	// Position of RESERVED field.
	CGU_BASE_CGU_OUT1_CLK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CGU_BASE_CGU_OUT1_CLK_RESERVED_Msk = 0xfff000
	// Position of CLK_SEL field.
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_Pos = 0x18
	// Bit mask of CLK_SEL field.
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_Msk = 0x1f000000
	// 32 kHz oscillator
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_32_KHZ_OSCILLATOR = 0x0
	// IRC (default)
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_IRC_DEFAULT = 0x1
	// ENET_RX_CLK
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_ENET_RX_CLK = 0x2
	// ENET_TX_CLK
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_ENET_TX_CLK = 0x3
	// GP_CLKIN
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_GP_CLKIN = 0x4
	// Crystal oscillator
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_CRYSTAL_OSCILLATOR = 0x6
	// PLL0 (for audio)
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_PLL0_FOR_AUDIO = 0x8
	// PLL1
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_PLL1 = 0x9
	// IDIVA
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_IDIVA = 0xc
	// IDIVB
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_IDIVB = 0xd
	// IDIVC
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_IDIVC = 0xe
	// IDIVD
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_IDIVD = 0xf
	// IDIVE
	CGU_BASE_CGU_OUT1_CLK_CLK_SEL_IDIVE = 0x10
	// Position of RESERVED field.
	CGU_BASE_CGU_OUT1_CLK_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	CGU_BASE_CGU_OUT1_CLK_RESERVED_Msk = 0xe0000000
)

// Constants for CCU1: Clock Control Unit (CCU)
const (
	// PM: CCU1 power mode register
	// Position of PD field.
	CCU1_PM_PD_Pos = 0x0
	// Bit mask of PD field.
	CCU1_PM_PD_Msk = 0x1
	// Bit PD.
	CCU1_PM_PD = 0x1
	// Normal operation.
	CCU1_PM_PD_NORMAL_OPERATION_ = 0x0
	// Clocks with wake-up mode enabled (W = 1) are disabled.
	CCU1_PM_PD_CLOCKS_WITH_WAKE_UP_ = 0x1
	// Position of RESERVED field.
	CCU1_PM_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CCU1_PM_RESERVED_Msk = 0xfffffffe

	// BASE_STAT: CCU1 base clocks status register
	// Position of BASE_APB3_CLK_IND field.
	CCU1_BASE_STAT_BASE_APB3_CLK_IND_Pos = 0x0
	// Bit mask of BASE_APB3_CLK_IND field.
	CCU1_BASE_STAT_BASE_APB3_CLK_IND_Msk = 0x1
	// Bit BASE_APB3_CLK_IND.
	CCU1_BASE_STAT_BASE_APB3_CLK_IND = 0x1
	// Position of BASE_APB1_CLK_IND field.
	CCU1_BASE_STAT_BASE_APB1_CLK_IND_Pos = 0x1
	// Bit mask of BASE_APB1_CLK_IND field.
	CCU1_BASE_STAT_BASE_APB1_CLK_IND_Msk = 0x2
	// Bit BASE_APB1_CLK_IND.
	CCU1_BASE_STAT_BASE_APB1_CLK_IND = 0x2
	// Position of BASE_SPIFI_CLK_IND field.
	CCU1_BASE_STAT_BASE_SPIFI_CLK_IND_Pos = 0x2
	// Bit mask of BASE_SPIFI_CLK_IND field.
	CCU1_BASE_STAT_BASE_SPIFI_CLK_IND_Msk = 0x4
	// Bit BASE_SPIFI_CLK_IND.
	CCU1_BASE_STAT_BASE_SPIFI_CLK_IND = 0x4
	// Position of BASE_M3_CLK_IND field.
	CCU1_BASE_STAT_BASE_M3_CLK_IND_Pos = 0x3
	// Bit mask of BASE_M3_CLK_IND field.
	CCU1_BASE_STAT_BASE_M3_CLK_IND_Msk = 0x8
	// Bit BASE_M3_CLK_IND.
	CCU1_BASE_STAT_BASE_M3_CLK_IND = 0x8
	// Position of RESERVED field.
	CCU1_BASE_STAT_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	CCU1_BASE_STAT_RESERVED_Msk = 0x70
	// Position of BASE_USB0_CLK_IND field.
	CCU1_BASE_STAT_BASE_USB0_CLK_IND_Pos = 0x7
	// Bit mask of BASE_USB0_CLK_IND field.
	CCU1_BASE_STAT_BASE_USB0_CLK_IND_Msk = 0x80
	// Bit BASE_USB0_CLK_IND.
	CCU1_BASE_STAT_BASE_USB0_CLK_IND = 0x80
	// Position of BASE_USB1_CLK_IND field.
	CCU1_BASE_STAT_BASE_USB1_CLK_IND_Pos = 0x8
	// Bit mask of BASE_USB1_CLK_IND field.
	CCU1_BASE_STAT_BASE_USB1_CLK_IND_Msk = 0x100
	// Bit BASE_USB1_CLK_IND.
	CCU1_BASE_STAT_BASE_USB1_CLK_IND = 0x100
	// Position of RESERVED field.
	CCU1_BASE_STAT_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	CCU1_BASE_STAT_RESERVED_Msk = 0xfffffe00

	// CLK_APB3_BUS_CFG: CLK_APB3_BUS clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB3_BUS_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_BUS_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_BUS_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB3_BUS_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB3_BUS_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_BUS_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_BUS_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_BUS_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB3_BUS_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB3_BUS_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB3_BUS_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_BUS_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_BUS_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB3_BUS_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB3_BUS_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB3_BUS_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_BUS_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_BUS_STAT: CLK_APB3_BUS clock status register
	// Position of RUN field.
	CCU1_CLK_APB3_BUS_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_BUS_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_BUS_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_BUS_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_BUS_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_BUS_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB3_BUS_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_BUS_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_BUS_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB3_BUS_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_BUS_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_I2C1_CFG: CLK_APB3_I2C1 clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB3_I2C1_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_I2C1_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_I2C1_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB3_I2C1_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB3_I2C1_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_I2C1_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_I2C1_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_I2C1_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB3_I2C1_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB3_I2C1_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB3_I2C1_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_I2C1_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_I2C1_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB3_I2C1_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB3_I2C1_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB3_I2C1_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_I2C1_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_I2C1_STAT: CLK_APB3_I2C1 clock status register
	// Position of RUN field.
	CCU1_CLK_APB3_I2C1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_I2C1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_I2C1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_I2C1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_I2C1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_I2C1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB3_I2C1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_I2C1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_I2C1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB3_I2C1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_I2C1_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_DAC_CFG: CLK_APB3_DAC clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB3_DAC_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_DAC_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_DAC_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB3_DAC_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB3_DAC_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_DAC_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_DAC_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_DAC_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB3_DAC_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB3_DAC_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB3_DAC_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_DAC_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_DAC_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB3_DAC_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB3_DAC_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB3_DAC_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_DAC_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_DAC_STAT: CLK_APB3_DAC clock status register
	// Position of RUN field.
	CCU1_CLK_APB3_DAC_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_DAC_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_DAC_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_DAC_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_DAC_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_DAC_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB3_DAC_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_DAC_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_DAC_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB3_DAC_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_DAC_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_ADC0_CFG: CLK_APB3_ADC0 clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB3_ADC0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_ADC0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_ADC0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB3_ADC0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB3_ADC0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_ADC0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_ADC0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_ADC0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB3_ADC0_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB3_ADC0_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB3_ADC0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_ADC0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_ADC0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB3_ADC0_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB3_ADC0_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB3_ADC0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_ADC0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_ADC0_STAT: CLK_APB3_ADC0 clock status register
	// Position of RUN field.
	CCU1_CLK_APB3_ADC0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_ADC0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_ADC0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_ADC0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_ADC0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_ADC0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB3_ADC0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_ADC0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_ADC0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB3_ADC0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_ADC0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_ADC1_CFG: CLK_APB3_ADC1 clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB3_ADC1_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_ADC1_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_ADC1_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB3_ADC1_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB3_ADC1_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_ADC1_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_ADC1_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_ADC1_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB3_ADC1_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB3_ADC1_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB3_ADC1_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_ADC1_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_ADC1_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB3_ADC1_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB3_ADC1_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB3_ADC1_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_ADC1_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_ADC1_STAT: CLK_APB3_ADC1 clock status register
	// Position of RUN field.
	CCU1_CLK_APB3_ADC1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_ADC1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_ADC1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_ADC1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_ADC1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_ADC1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB3_ADC1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_ADC1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_ADC1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB3_ADC1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_ADC1_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_CAN0_CFG: CLK_APB3_CAN0 clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB3_CAN0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_CAN0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_CAN0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB3_CAN0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB3_CAN0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_CAN0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_CAN0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_CAN0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB3_CAN0_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB3_CAN0_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB3_CAN0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_CAN0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_CAN0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB3_CAN0_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB3_CAN0_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB3_CAN0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_CAN0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB3_CAN0_STAT: CLK_APB3_CAN0 clock status register
	// Position of RUN field.
	CCU1_CLK_APB3_CAN0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB3_CAN0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB3_CAN0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB3_CAN0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB3_CAN0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB3_CAN0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB3_CAN0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB3_CAN0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB3_CAN0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB3_CAN0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB3_CAN0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_BUS_CFG: CLK_APB1_BUS clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB1_BUS_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_BUS_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_BUS_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB1_BUS_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB1_BUS_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_BUS_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_BUS_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_BUS_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB1_BUS_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB1_BUS_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB1_BUS_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_BUS_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_BUS_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB1_BUS_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB1_BUS_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB1_BUS_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_BUS_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_BUS_STAT: CLK_APB1_BUS clock status register
	// Position of RUN field.
	CCU1_CLK_APB1_BUS_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_BUS_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_BUS_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_BUS_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_BUS_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_BUS_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB1_BUS_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_BUS_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_BUS_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB1_BUS_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_BUS_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_MOTOCONPWM_CFG: CLK_APB1_MOTOCONPWM clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_MOTOCONPWM_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_MOTOCONPWM_STAT: CLK_APB1_MOTOCONPWM clock status register
	// Position of RUN field.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_MOTOCONPWM_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_I2C0_CFG: CLK_ABP1_I2C0 clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB1_I2C0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_I2C0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_I2C0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB1_I2C0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB1_I2C0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_I2C0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_I2C0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_I2C0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB1_I2C0_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB1_I2C0_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB1_I2C0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_I2C0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_I2C0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB1_I2C0_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB1_I2C0_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB1_I2C0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_I2C0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_I2C0_STAT: CLK_APB1_I2C0 clock status register
	// Position of RUN field.
	CCU1_CLK_APB1_I2C0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_I2C0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_I2C0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_I2C0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_I2C0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_I2C0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB1_I2C0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_I2C0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_I2C0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB1_I2C0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_I2C0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_I2S_CFG: CLK_APB1_I2S clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB1_I2S_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_I2S_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_I2S_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB1_I2S_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB1_I2S_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_I2S_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_I2S_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_I2S_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB1_I2S_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB1_I2S_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB1_I2S_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_I2S_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_I2S_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB1_I2S_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB1_I2S_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB1_I2S_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_I2S_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_I2S_STAT: CLK_APB1_I2S clock status register
	// Position of RUN field.
	CCU1_CLK_APB1_I2S_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_I2S_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_I2S_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_I2S_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_I2S_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_I2S_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB1_I2S_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_I2S_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_I2S_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB1_I2S_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_I2S_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_CAN1_CFG: CLK_APB1_CAN1 clock configuration register
	// Position of RUN field.
	CCU1_CLK_APB1_CAN1_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_CAN1_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_CAN1_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_APB1_CAN1_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_APB1_CAN1_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_CAN1_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_CAN1_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_CAN1_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_APB1_CAN1_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_APB1_CAN1_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_APB1_CAN1_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_CAN1_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_CAN1_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_APB1_CAN1_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_APB1_CAN1_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_APB1_CAN1_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_CAN1_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB1_CAN1_STAT: CLK_APB1_CAN1 clock status register
	// Position of RUN field.
	CCU1_CLK_APB1_CAN1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_APB1_CAN1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_APB1_CAN1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_APB1_CAN1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_APB1_CAN1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_APB1_CAN1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_APB1_CAN1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_APB1_CAN1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_APB1_CAN1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_APB1_CAN1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_APB1_CAN1_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_SPIFI_CFG: CLK_SPIFI clock configuration register
	// Position of RUN field.
	CCU1_CLK_SPIFI_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_SPIFI_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_SPIFI_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_SPIFI_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_SPIFI_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_SPIFI_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_SPIFI_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_SPIFI_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_SPIFI_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_SPIFI_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_SPIFI_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_SPIFI_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_SPIFI_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_SPIFI_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_SPIFI_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_SPIFI_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_SPIFI_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_SPIFI_STAT: CLK_APB1_SPIFI clock status register
	// Position of RUN field.
	CCU1_CLK_SPIFI_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_SPIFI_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_SPIFI_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_SPIFI_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_SPIFI_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_SPIFI_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_SPIFI_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_SPIFI_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_SPIFI_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_SPIFI_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_SPIFI_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_BUS_CFG: CLK_M3_BUS clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_BUS_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_BUS_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_BUS_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_BUS_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_BUS_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_BUS_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_BUS_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_BUS_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_BUS_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_BUS_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_BUS_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_BUS_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_BUS_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_BUS_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_BUS_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_BUS_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_BUS_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_BUS_STAT: CLK_M4_BUSclock status register
	// Position of RUN field.
	CCU1_CLK_M3_BUS_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_BUS_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_BUS_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_BUS_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_BUS_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_BUS_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_BUS_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_BUS_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_BUS_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_BUS_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_BUS_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SPIFI_CFG: CLK_M3_SPIFI clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_SPIFI_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SPIFI_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SPIFI_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_SPIFI_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_SPIFI_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SPIFI_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SPIFI_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SPIFI_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_SPIFI_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_SPIFI_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_SPIFI_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SPIFI_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SPIFI_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_SPIFI_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_SPIFI_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_SPIFI_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SPIFI_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SPIFI_STAT: CLK_M3_SPIFI clock status register
	// Position of RUN field.
	CCU1_CLK_M3_SPIFI_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SPIFI_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SPIFI_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SPIFI_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SPIFI_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SPIFI_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_SPIFI_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SPIFI_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SPIFI_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_SPIFI_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SPIFI_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_GPIO_CFG: CLK_M3_GPIO clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_GPIO_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_GPIO_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_GPIO_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_GPIO_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_GPIO_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_GPIO_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_GPIO_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_GPIO_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_GPIO_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_GPIO_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_GPIO_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_GPIO_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_GPIO_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_GPIO_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_GPIO_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_GPIO_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_GPIO_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_GPIO_STAT: CLK_M3_GPIO clock status register
	// Position of RUN field.
	CCU1_CLK_M3_GPIO_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_GPIO_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_GPIO_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_GPIO_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_GPIO_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_GPIO_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_GPIO_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_GPIO_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_GPIO_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_GPIO_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_GPIO_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_LCD_CFG: CLK_M3_LCD clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_LCD_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_LCD_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_LCD_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_LCD_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_LCD_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_LCD_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_LCD_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_LCD_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_LCD_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_LCD_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_LCD_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_LCD_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_LCD_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_LCD_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_LCD_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_LCD_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_LCD_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_LCD_STAT: CLK_M3_LCD clock status register
	// Position of RUN field.
	CCU1_CLK_M3_LCD_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_LCD_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_LCD_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_LCD_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_LCD_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_LCD_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_LCD_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_LCD_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_LCD_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_LCD_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_LCD_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_ETHERNET_CFG: CLK_M3_ETHERNET clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_ETHERNET_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_ETHERNET_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_ETHERNET_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_ETHERNET_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_ETHERNET_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_ETHERNET_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_ETHERNET_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_ETHERNET_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_ETHERNET_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_ETHERNET_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_ETHERNET_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_ETHERNET_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_ETHERNET_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_ETHERNET_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_ETHERNET_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_ETHERNET_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_ETHERNET_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_ETHERNET_STAT: CLK_M3_ETHERNET clock status register
	// Position of RUN field.
	CCU1_CLK_M3_ETHERNET_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_ETHERNET_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_ETHERNET_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_ETHERNET_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_ETHERNET_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_ETHERNET_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_ETHERNET_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_ETHERNET_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_ETHERNET_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_ETHERNET_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_ETHERNET_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USB0_CFG: CLK_M3_USB0 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_USB0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USB0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USB0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_USB0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_USB0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USB0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USB0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USB0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_USB0_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_USB0_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_USB0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USB0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USB0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_USB0_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_USB0_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_USB0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USB0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USB0_STAT: CLK_M3_USB0 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_USB0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USB0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USB0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USB0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USB0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USB0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_USB0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USB0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USB0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_USB0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USB0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_EMC_CFG: CLK_M3_EMC clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_EMC_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_EMC_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_EMC_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_EMC_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_EMC_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_EMC_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_EMC_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_EMC_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_EMC_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_EMC_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_EMC_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_EMC_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_EMC_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_EMC_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_EMC_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_EMC_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_EMC_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_EMC_STAT: CLK_M3_EMC clock status register
	// Position of RUN field.
	CCU1_CLK_M3_EMC_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_EMC_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_EMC_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_EMC_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_EMC_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_EMC_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_EMC_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_EMC_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_EMC_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_EMC_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_EMC_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SDIO_CFG: CLK_M3_SDIO clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_SDIO_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SDIO_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SDIO_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_SDIO_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_SDIO_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SDIO_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SDIO_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SDIO_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_SDIO_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_SDIO_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_SDIO_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SDIO_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SDIO_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_SDIO_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_SDIO_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_SDIO_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SDIO_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SDIO_STAT: CLK_M3_SDIO clock status register
	// Position of RUN field.
	CCU1_CLK_M3_SDIO_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SDIO_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SDIO_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SDIO_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SDIO_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SDIO_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_SDIO_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SDIO_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SDIO_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_SDIO_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SDIO_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_DMA_CFG: CLK_M3_DMA clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_DMA_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_DMA_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_DMA_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_DMA_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_DMA_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_DMA_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_DMA_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_DMA_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_DMA_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_DMA_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_DMA_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_DMA_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_DMA_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_DMA_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_DMA_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_DMA_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_DMA_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_DMA_STAT: CLK_M3_DMA clock status register
	// Position of RUN field.
	CCU1_CLK_M3_DMA_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_DMA_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_DMA_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_DMA_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_DMA_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_DMA_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_DMA_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_DMA_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_DMA_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_DMA_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_DMA_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_M3CORE_CFG: CLK_M3_M3CORE clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_M3CORE_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_M3CORE_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_M3CORE_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_M3CORE_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_M3CORE_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_M3CORE_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_M3CORE_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_M3CORE_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_M3CORE_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_M3CORE_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_M3CORE_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_M3CORE_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_M3CORE_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_M3CORE_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_M3CORE_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_M3CORE_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_M3CORE_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_M3CORE_STAT: CLK_M3_M3CORE clock status register
	// Position of RUN field.
	CCU1_CLK_M3_M3CORE_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_M3CORE_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_M3CORE_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_M3CORE_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_M3CORE_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_M3CORE_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_M3CORE_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_M3CORE_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_M3CORE_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_M3CORE_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_M3CORE_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SCT_CFG: CLK_M3_SCT clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_SCT_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SCT_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SCT_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_SCT_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_SCT_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SCT_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SCT_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SCT_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_SCT_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_SCT_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_SCT_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SCT_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SCT_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_SCT_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_SCT_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_SCT_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SCT_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SCT_STAT: CLK_M3_SCT clock status register
	// Position of RUN field.
	CCU1_CLK_M3_SCT_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SCT_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SCT_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SCT_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SCT_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SCT_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_SCT_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SCT_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SCT_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_SCT_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SCT_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USB1_CFG: CLK_M3_USB1 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_USB1_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USB1_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USB1_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_USB1_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_USB1_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USB1_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USB1_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USB1_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_USB1_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_USB1_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_USB1_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USB1_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USB1_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_USB1_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_USB1_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_USB1_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USB1_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USB1_STAT: CLK_M3_USB1 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_USB1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USB1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USB1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USB1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USB1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USB1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_USB1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USB1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USB1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_USB1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USB1_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_EMCDIV_CFG: CLK_M3_EMCDIV clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_EMCDIV_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_EMCDIV_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_EMCDIV_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_EMCDIV_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_EMCDIV_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_EMCDIV_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_EMCDIV_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_EMCDIV_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_EMCDIV_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_EMCDIV_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_EMCDIV_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_EMCDIV_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_EMCDIV_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_EMCDIV_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_EMCDIV_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_EMCDIV_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_EMCDIV_CFG_RESERVED_Msk = 0x18
	// Position of DIV field.
	CCU1_CLK_M3_EMCDIV_CFG_DIV_Pos = 0x5
	// Bit mask of DIV field.
	CCU1_CLK_M3_EMCDIV_CFG_DIV_Msk = 0xe0
	// No division. Divide by 1.
	CCU1_CLK_M3_EMCDIV_CFG_DIV_DIVIDEBY1 = 0x0
	// Divide by 2.
	CCU1_CLK_M3_EMCDIV_CFG_DIV_DIVIDEBY2 = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_EMCDIV_CFG_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_EMCDIV_CFG_RESERVED_Msk = 0xffffff00

	// CLK_M3_EMCDIV_STAT: CLK_M3_EMCDIV clock status register
	// Position of RUN field.
	CCU1_CLK_M3_EMCDIV_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_EMCDIV_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_EMCDIV_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_EMCDIV_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_EMCDIV_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_EMCDIV_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_EMCDIV_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_EMCDIV_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_EMCDIV_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_EMCDIV_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_EMCDIV_STAT_RESERVED_Msk = 0x18
	// Position of DIV field.
	CCU1_CLK_M3_EMCDIV_STAT_DIV_Pos = 0x5
	// Bit mask of DIV field.
	CCU1_CLK_M3_EMCDIV_STAT_DIV_Msk = 0xe0
	// No division. Divide by 1.
	CCU1_CLK_M3_EMCDIV_STAT_DIV_DIVIDEBY1 = 0x0
	// Divide by 2.
	CCU1_CLK_M3_EMCDIV_STAT_DIV_DIVIDEBY2 = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_EMCDIV_STAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_EMCDIV_STAT_RESERVED_Msk = 0xffffff00

	// CLK_M3_FLASHA_CFG: CLK_M3_FLASHA clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_FLASHA_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_FLASHA_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_FLASHA_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_FLASHA_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_FLASHA_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_FLASHA_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_FLASHA_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_FLASHA_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_FLASHA_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_FLASHA_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_FLASHA_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_FLASHA_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_FLASHA_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_FLASHA_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_FLASHA_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_FLASHA_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_FLASHA_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_FLASHA_STAT: CLK_M3_FLASHA clock status register
	// Position of RUN field.
	CCU1_CLK_M3_FLASHA_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_FLASHA_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_FLASHA_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_FLASHA_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_FLASHA_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_FLASHA_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_FLASHA_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_FLASHA_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_FLASHA_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_FLASHA_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_FLASHA_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_FLASHB_CFG: CLK_M3_FLASHB clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_FLASHB_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_FLASHB_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_FLASHB_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_FLASHB_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_FLASHB_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_FLASHB_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_FLASHB_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_FLASHB_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_FLASHB_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_FLASHB_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_FLASHB_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_FLASHB_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_FLASHB_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_FLASHB_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_FLASHB_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_FLASHB_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_FLASHB_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_FLASHB_STAT: CLK_M3_FLASHB clock status register
	// Position of RUN field.
	CCU1_CLK_M3_FLASHB_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_FLASHB_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_FLASHB_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_FLASHB_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_FLASHB_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_FLASHB_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_FLASHB_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_FLASHB_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_FLASHB_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_FLASHB_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_FLASHB_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_EEPROM_CFG: CLK_EEPROM_CFG clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_EEPROM_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_EEPROM_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_EEPROM_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_EEPROM_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_EEPROM_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_EEPROM_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_EEPROM_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_EEPROM_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_EEPROM_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_EEPROM_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_EEPROM_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_EEPROM_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_EEPROM_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_EEPROM_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_EEPROM_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_EEPROM_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_EEPROM_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_EEPROM_STAT: CLK_M3_EEPROM clock status register
	// Position of RUN field.
	CCU1_CLK_M3_EEPROM_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_EEPROM_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_EEPROM_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_EEPROM_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_EEPROM_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_EEPROM_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_EEPROM_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_EEPROM_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_EEPROM_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_EEPROM_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_EEPROM_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_WWDT_CFG: CLK_M3_WWDT clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_WWDT_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_WWDT_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_WWDT_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_WWDT_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_WWDT_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_WWDT_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_WWDT_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_WWDT_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_WWDT_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_WWDT_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_WWDT_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_WWDT_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_WWDT_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_WWDT_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_WWDT_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_WWDT_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_WWDT_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_WWDT_STAT: CLK_M3_WWDT clock status register
	// Position of RUN field.
	CCU1_CLK_M3_WWDT_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_WWDT_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_WWDT_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_WWDT_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_WWDT_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_WWDT_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_WWDT_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_WWDT_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_WWDT_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_WWDT_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_WWDT_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USART0_CFG: CLK_M3_USART0 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_USART0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USART0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USART0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_USART0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_USART0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USART0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USART0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USART0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_USART0_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_USART0_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_USART0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USART0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USART0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_USART0_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_USART0_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_USART0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USART0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USART0_STAT: CLK_M3_USART0 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_USART0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USART0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USART0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USART0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USART0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USART0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_USART0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USART0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USART0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_USART0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USART0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_UART1_CFG: CLK_M3_UART1 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_UART1_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_UART1_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_UART1_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_UART1_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_UART1_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_UART1_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_UART1_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_UART1_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_UART1_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_UART1_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_UART1_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_UART1_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_UART1_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_UART1_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_UART1_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_UART1_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_UART1_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_UART1_STAT: CLK_M3_UART1 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_UART1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_UART1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_UART1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_UART1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_UART1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_UART1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_UART1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_UART1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_UART1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_UART1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_UART1_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SSP0_CFG: CLK_M3_SSP0 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_SSP0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SSP0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SSP0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_SSP0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_SSP0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SSP0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SSP0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SSP0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_SSP0_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_SSP0_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_SSP0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SSP0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SSP0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_SSP0_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_SSP0_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_SSP0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SSP0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SSP0_STAT: CLK_M3_SSP0 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_SSP0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SSP0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SSP0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SSP0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SSP0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SSP0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_SSP0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SSP0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SSP0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_SSP0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SSP0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_TIMER0_CFG: CLK_M3_TIMER0 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_TIMER0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_TIMER0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_TIMER0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_TIMER0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_TIMER0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_TIMER0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_TIMER0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_TIMER0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_TIMER0_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_TIMER0_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_TIMER0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_TIMER0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_TIMER0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_TIMER0_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_TIMER0_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_TIMER0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_TIMER0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_TIMER0_STAT: CLK_M3_TIMER0 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_TIMER0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_TIMER0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_TIMER0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_TIMER0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_TIMER0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_TIMER0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_TIMER0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_TIMER0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_TIMER0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_TIMER0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_TIMER0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_TIMER1_CFG: CLK_M3_TIMER1clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_TIMER1_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_TIMER1_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_TIMER1_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_TIMER1_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_TIMER1_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_TIMER1_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_TIMER1_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_TIMER1_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_TIMER1_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_TIMER1_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_TIMER1_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_TIMER1_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_TIMER1_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_TIMER1_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_TIMER1_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_TIMER1_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_TIMER1_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_TIMER1_STAT: CLK_M3_TIMER1 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_TIMER1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_TIMER1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_TIMER1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_TIMER1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_TIMER1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_TIMER1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_TIMER1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_TIMER1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_TIMER1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_TIMER1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_TIMER1_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SCU_CFG: CLK_M3_SCU clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_SCU_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SCU_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SCU_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_SCU_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_SCU_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SCU_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SCU_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SCU_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_SCU_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_SCU_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_SCU_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SCU_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SCU_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_SCU_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_SCU_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_SCU_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SCU_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SCU_STAT: CLK_SCU_XXX clock status register
	// Position of RUN field.
	CCU1_CLK_M3_SCU_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SCU_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SCU_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SCU_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SCU_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SCU_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_SCU_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SCU_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SCU_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_SCU_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SCU_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_CREG_CFG: CLK_M3_CREG clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_CREG_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_CREG_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_CREG_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_CREG_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_CREG_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_CREG_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_CREG_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_CREG_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_CREG_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_CREG_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_CREG_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_CREG_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_CREG_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_CREG_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_CREG_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_CREG_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_CREG_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_CREG_STAT: CLK_M3_CREG clock status register
	// Position of RUN field.
	CCU1_CLK_M3_CREG_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_CREG_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_CREG_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_CREG_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_CREG_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_CREG_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_CREG_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_CREG_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_CREG_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_CREG_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_CREG_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_RITIMER_CFG: CLK_M3_RITIMER clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_RITIMER_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_RITIMER_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_RITIMER_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_RITIMER_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_RITIMER_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_RITIMER_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_RITIMER_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_RITIMER_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_RITIMER_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_RITIMER_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_RITIMER_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_RITIMER_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_RITIMER_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_RITIMER_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_RITIMER_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_RITIMER_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_RITIMER_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_RITIMER_STAT: CLK_M3_RITIMER clock status register
	// Position of RUN field.
	CCU1_CLK_M3_RITIMER_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_RITIMER_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_RITIMER_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_RITIMER_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_RITIMER_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_RITIMER_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_RITIMER_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_RITIMER_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_RITIMER_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_RITIMER_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_RITIMER_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USART2_CFG: CLK_M3_USART2 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_USART2_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USART2_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USART2_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_USART2_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_USART2_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USART2_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USART2_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USART2_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_USART2_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_USART2_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_USART2_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USART2_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USART2_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_USART2_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_USART2_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_USART2_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USART2_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USART2_STAT: CLK_M3_USART2 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_USART2_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USART2_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USART2_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USART2_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USART2_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USART2_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_USART2_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USART2_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USART2_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_USART2_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USART2_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USART3_CFG: CLK_M3_USART3 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_USART3_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USART3_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USART3_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_USART3_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_USART3_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USART3_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USART3_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USART3_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_USART3_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_USART3_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_USART3_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USART3_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USART3_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_USART3_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_USART3_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_USART3_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USART3_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_USART3_STAT: CLK_M3_USART3 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_USART3_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_USART3_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_USART3_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_USART3_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_USART3_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_USART3_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_USART3_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_USART3_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_USART3_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_USART3_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_USART3_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_TIMER2_CFG: CLK_M3_TIMER2 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_TIMER2_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_TIMER2_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_TIMER2_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_TIMER2_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_TIMER2_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_TIMER2_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_TIMER2_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_TIMER2_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_TIMER2_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_TIMER2_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_TIMER2_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_TIMER2_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_TIMER2_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_TIMER2_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_TIMER2_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_TIMER2_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_TIMER2_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_TIMER2_STAT: CLK_M3_TIMER2 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_TIMER2_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_TIMER2_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_TIMER2_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_TIMER2_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_TIMER2_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_TIMER2_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_TIMER2_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_TIMER2_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_TIMER2_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_TIMER2_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_TIMER2_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_TIMER3_CFG: CLK_M3_TIMER3 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_TIMER3_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_TIMER3_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_TIMER3_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_TIMER3_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_TIMER3_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_TIMER3_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_TIMER3_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_TIMER3_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_TIMER3_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_TIMER3_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_TIMER3_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_TIMER3_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_TIMER3_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_TIMER3_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_TIMER3_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_TIMER3_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_TIMER3_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_TIMER3_STAT: CLK_M3_TIMER3 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_TIMER3_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_TIMER3_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_TIMER3_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_TIMER3_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_TIMER3_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_TIMER3_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_TIMER3_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_TIMER3_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_TIMER3_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_TIMER3_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_TIMER3_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SSP1_CFG: CLK_M3_SSP1 clock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_SSP1_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SSP1_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SSP1_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_SSP1_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_SSP1_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SSP1_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SSP1_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SSP1_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_SSP1_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_SSP1_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_SSP1_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SSP1_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SSP1_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_SSP1_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_SSP1_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_SSP1_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SSP1_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_SSP1_STAT: CLK_M3_SSP1 clock status register
	// Position of RUN field.
	CCU1_CLK_M3_SSP1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_SSP1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_SSP1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_SSP1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_SSP1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_SSP1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_SSP1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_SSP1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_SSP1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_SSP1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_SSP1_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_M3_QEI_CFG: CLK_M3_QEIclock configuration register
	// Position of RUN field.
	CCU1_CLK_M3_QEI_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_QEI_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_QEI_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_M3_QEI_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_M3_QEI_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_QEI_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_QEI_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_QEI_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_M3_QEI_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_M3_QEI_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_M3_QEI_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_QEI_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_QEI_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_M3_QEI_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU1_CLK_M3_QEI_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU1_CLK_M3_QEI_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_QEI_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_M3_QEI_STAT: CLK_M3_QEI clock status register
	// Position of RUN field.
	CCU1_CLK_M3_QEI_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_M3_QEI_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_M3_QEI_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_M3_QEI_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_M3_QEI_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_M3_QEI_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_M3_QEI_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_M3_QEI_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_M3_QEI_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_M3_QEI_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_M3_QEI_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_USB0_CFG: CLK_USB0 clock configuration register
	// Position of RUN field.
	CCU1_CLK_USB0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_USB0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_USB0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_USB0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_USB0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_USB0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_USB0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_USB0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_USB0_CFG_AUTO_AUTO_IS_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_USB0_CFG_AUTO_AUTO_IS_ENABLED_ = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_USB0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_USB0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_USB0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_USB0_CFG_WAKEUP_WAKE_UP_IS_DISABLED_ = 0x0
	// Wake-up is enabled.
	CCU1_CLK_USB0_CFG_WAKEUP_WAKE_UP_IS_ENABLED_ = 0x1
	// Position of RESERVED field.
	CCU1_CLK_USB0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_USB0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_USB0_STAT: CLK_USB0 clock status register
	// Position of RUN field.
	CCU1_CLK_USB0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_USB0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_USB0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_USB0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_USB0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_USB0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_USB0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_USB0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_USB0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_USB0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_USB0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_USB1_CFG: CLK_USB1 clock configuration register
	// Position of RUN field.
	CCU1_CLK_USB1_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_USB1_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_USB1_CFG_RUN = 0x1
	// Clock is disabled.
	CCU1_CLK_USB1_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU1_CLK_USB1_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU1_CLK_USB1_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_USB1_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_USB1_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU1_CLK_USB1_CFG_AUTO_AUTO_IS_DISABLED_ = 0x0
	// Auto is enabled.
	CCU1_CLK_USB1_CFG_AUTO_AUTO_IS_ENABLED_ = 0x1
	// Position of WAKEUP field.
	CCU1_CLK_USB1_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_USB1_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_USB1_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU1_CLK_USB1_CFG_WAKEUP_WAKE_UP_IS_DISABLED_ = 0x0
	// Wake-up is enabled.
	CCU1_CLK_USB1_CFG_WAKEUP_WAKE_UP_IS_ENABLED_ = 0x1
	// Position of RESERVED field.
	CCU1_CLK_USB1_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_USB1_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_USB1_STAT: CLK_USB1 clock status register
	// Position of RUN field.
	CCU1_CLK_USB1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU1_CLK_USB1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU1_CLK_USB1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU1_CLK_USB1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU1_CLK_USB1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU1_CLK_USB1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU1_CLK_USB1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU1_CLK_USB1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU1_CLK_USB1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU1_CLK_USB1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU1_CLK_USB1_STAT_RESERVED_Msk = 0xfffffff8
)

// Constants for CCU2: Clock Control Unit (CCU2)
const (
	// PM: Power mode register
	// Position of PD field.
	CCU2_PM_PD_Pos = 0x0
	// Bit mask of PD field.
	CCU2_PM_PD_Msk = 0x1
	// Bit PD.
	CCU2_PM_PD = 0x1
	// Normal operation.
	CCU2_PM_PD_NORMAL_OPERATION_ = 0x0
	// Clocks with wake-up mode enabled (W = 1) are disabled.
	CCU2_PM_PD_CLOCKS_WITH_WAKE_UP_ = 0x1
	// Position of RESERVED field.
	CCU2_PM_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CCU2_PM_RESERVED_Msk = 0xfffffffe

	// BASE_STAT: CCU base clocks status register
	// Position of RESERVED field.
	CCU2_BASE_STAT_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CCU2_BASE_STAT_RESERVED_Msk = 0x1
	// Bit RESERVED.
	CCU2_BASE_STAT_RESERVED = 0x1
	// Position of BASE_UART3_CLK field.
	CCU2_BASE_STAT_BASE_UART3_CLK_Pos = 0x1
	// Bit mask of BASE_UART3_CLK field.
	CCU2_BASE_STAT_BASE_UART3_CLK_Msk = 0x2
	// Bit BASE_UART3_CLK.
	CCU2_BASE_STAT_BASE_UART3_CLK = 0x2
	// Position of BASE_UART2_CLK field.
	CCU2_BASE_STAT_BASE_UART2_CLK_Pos = 0x2
	// Bit mask of BASE_UART2_CLK field.
	CCU2_BASE_STAT_BASE_UART2_CLK_Msk = 0x4
	// Bit BASE_UART2_CLK.
	CCU2_BASE_STAT_BASE_UART2_CLK = 0x4
	// Position of BASE_UART1_CLK field.
	CCU2_BASE_STAT_BASE_UART1_CLK_Pos = 0x3
	// Bit mask of BASE_UART1_CLK field.
	CCU2_BASE_STAT_BASE_UART1_CLK_Msk = 0x8
	// Bit BASE_UART1_CLK.
	CCU2_BASE_STAT_BASE_UART1_CLK = 0x8
	// Position of BASE_UART0_CLK field.
	CCU2_BASE_STAT_BASE_UART0_CLK_Pos = 0x4
	// Bit mask of BASE_UART0_CLK field.
	CCU2_BASE_STAT_BASE_UART0_CLK_Msk = 0x10
	// Bit BASE_UART0_CLK.
	CCU2_BASE_STAT_BASE_UART0_CLK = 0x10
	// Position of BASE_SSP1_CLK field.
	CCU2_BASE_STAT_BASE_SSP1_CLK_Pos = 0x5
	// Bit mask of BASE_SSP1_CLK field.
	CCU2_BASE_STAT_BASE_SSP1_CLK_Msk = 0x20
	// Bit BASE_SSP1_CLK.
	CCU2_BASE_STAT_BASE_SSP1_CLK = 0x20
	// Position of BASE_SSP0_CLK field.
	CCU2_BASE_STAT_BASE_SSP0_CLK_Pos = 0x6
	// Bit mask of BASE_SSP0_CLK field.
	CCU2_BASE_STAT_BASE_SSP0_CLK_Msk = 0x40
	// Bit BASE_SSP0_CLK.
	CCU2_BASE_STAT_BASE_SSP0_CLK = 0x40
	// Position of RESERVED field.
	CCU2_BASE_STAT_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	CCU2_BASE_STAT_RESERVED_Msk = 0x80
	// Bit RESERVED.
	CCU2_BASE_STAT_RESERVED = 0x80
	// Position of RESERVED field.
	CCU2_BASE_STAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CCU2_BASE_STAT_RESERVED_Msk = 0xffffff00

	// CLK_AUDIO_CFG: CLK_AUDIO clock configuration register
	// Position of RUN field.
	CCU2_CLK_AUDIO_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_AUDIO_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_AUDIO_CFG_RUN = 0x1
	// Clock is disabled.
	CCU2_CLK_AUDIO_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU2_CLK_AUDIO_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU2_CLK_AUDIO_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_AUDIO_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_AUDIO_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU2_CLK_AUDIO_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU2_CLK_AUDIO_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU2_CLK_AUDIO_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_AUDIO_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_AUDIO_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU2_CLK_AUDIO_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU2_CLK_AUDIO_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU2_CLK_AUDIO_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_AUDIO_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_AUDIO_STAT: CLK_AUDIO clock status register
	// Position of RUN field.
	CCU2_CLK_AUDIO_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_AUDIO_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_AUDIO_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU2_CLK_AUDIO_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_AUDIO_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_AUDIO_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU2_CLK_AUDIO_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_AUDIO_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_AUDIO_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU2_CLK_AUDIO_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_AUDIO_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB2_USART3_CFG: CLK_APB2_USART3 clock configuration register
	// Position of RUN field.
	CCU2_CLK_APB2_USART3_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB2_USART3_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB2_USART3_CFG_RUN = 0x1
	// Clock is disabled.
	CCU2_CLK_APB2_USART3_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU2_CLK_APB2_USART3_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB2_USART3_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB2_USART3_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB2_USART3_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU2_CLK_APB2_USART3_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU2_CLK_APB2_USART3_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU2_CLK_APB2_USART3_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB2_USART3_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB2_USART3_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU2_CLK_APB2_USART3_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU2_CLK_APB2_USART3_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU2_CLK_APB2_USART3_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB2_USART3_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB2_USART3_STAT: CLK_APB2_USART3 clock status register
	// Position of RUN field.
	CCU2_CLK_APB2_USART3_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB2_USART3_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB2_USART3_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB2_USART3_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB2_USART3_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB2_USART3_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU2_CLK_APB2_USART3_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB2_USART3_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB2_USART3_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU2_CLK_APB2_USART3_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB2_USART3_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB2_USART2_CFG: CLK_APB2_USART2 clock configuration register
	// Position of RUN field.
	CCU2_CLK_APB2_USART2_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB2_USART2_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB2_USART2_CFG_RUN = 0x1
	// Clock is disabled.
	CCU2_CLK_APB2_USART2_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU2_CLK_APB2_USART2_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB2_USART2_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB2_USART2_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB2_USART2_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU2_CLK_APB2_USART2_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU2_CLK_APB2_USART2_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU2_CLK_APB2_USART2_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB2_USART2_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB2_USART2_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU2_CLK_APB2_USART2_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU2_CLK_APB2_USART2_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU2_CLK_APB2_USART2_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB2_USART2_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB2_USART2_STAT: CLK_APB2_USART clock status register
	// Position of RUN field.
	CCU2_CLK_APB2_USART2_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB2_USART2_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB2_USART2_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB2_USART2_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB2_USART2_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB2_USART2_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU2_CLK_APB2_USART2_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB2_USART2_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB2_USART2_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU2_CLK_APB2_USART2_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB2_USART2_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB0_UART1_BUS_CFG: CLK_APB2_UART1 clock configuration register
	// Position of RUN field.
	CCU2_CLK_APB0_UART1_BUS_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB0_UART1_BUS_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB0_UART1_BUS_CFG_RUN = 0x1
	// Clock is disabled.
	CCU2_CLK_APB0_UART1_BUS_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU2_CLK_APB0_UART1_BUS_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB0_UART1_BUS_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB0_UART1_BUS_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB0_UART1_BUS_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU2_CLK_APB0_UART1_BUS_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU2_CLK_APB0_UART1_BUS_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU2_CLK_APB0_UART1_BUS_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB0_UART1_BUS_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB0_UART1_BUS_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU2_CLK_APB0_UART1_BUS_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU2_CLK_APB0_UART1_BUS_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU2_CLK_APB0_UART1_BUS_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB0_UART1_BUS_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB0_UART1_STAT: CLK_APB0_UART1 clock status register
	// Position of RUN field.
	CCU2_CLK_APB0_UART1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB0_UART1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB0_UART1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB0_UART1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB0_UART1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB0_UART1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU2_CLK_APB0_UART1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB0_UART1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB0_UART1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU2_CLK_APB0_UART1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB0_UART1_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB0_USART0_CFG: CLK_APB2_USART0 clock configuration register
	// Position of RUN field.
	CCU2_CLK_APB0_USART0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB0_USART0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB0_USART0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU2_CLK_APB0_USART0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU2_CLK_APB0_USART0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB0_USART0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB0_USART0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB0_USART0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU2_CLK_APB0_USART0_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU2_CLK_APB0_USART0_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU2_CLK_APB0_USART0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB0_USART0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB0_USART0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU2_CLK_APB0_USART0_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU2_CLK_APB0_USART0_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU2_CLK_APB0_USART0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB0_USART0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB0_USART0_STAT: CLK_APB0_USART0 clock status register
	// Position of RUN field.
	CCU2_CLK_APB0_USART0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB0_USART0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB0_USART0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB0_USART0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB0_USART0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB0_USART0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU2_CLK_APB0_USART0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB0_USART0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB0_USART0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU2_CLK_APB0_USART0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB0_USART0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB2_SSP1_CFG: CLK_APB2_SSP1 clock configuration register
	// Position of RUN field.
	CCU2_CLK_APB2_SSP1_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB2_SSP1_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB2_SSP1_CFG_RUN = 0x1
	// Clock is disabled.
	CCU2_CLK_APB2_SSP1_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU2_CLK_APB2_SSP1_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB2_SSP1_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB2_SSP1_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB2_SSP1_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU2_CLK_APB2_SSP1_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU2_CLK_APB2_SSP1_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU2_CLK_APB2_SSP1_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB2_SSP1_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB2_SSP1_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU2_CLK_APB2_SSP1_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU2_CLK_APB2_SSP1_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU2_CLK_APB2_SSP1_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB2_SSP1_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB2_SSP1_STAT: CLK_APB2_SSP1 clock status register
	// Position of RUN field.
	CCU2_CLK_APB2_SSP1_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB2_SSP1_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB2_SSP1_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB2_SSP1_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB2_SSP1_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB2_SSP1_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU2_CLK_APB2_SSP1_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB2_SSP1_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB2_SSP1_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU2_CLK_APB2_SSP1_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB2_SSP1_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_APB0_SSP0_CFG: CLK_APB0_SSP0 clock configuration register
	// Position of RUN field.
	CCU2_CLK_APB0_SSP0_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB0_SSP0_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB0_SSP0_CFG_RUN = 0x1
	// Clock is disabled.
	CCU2_CLK_APB0_SSP0_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU2_CLK_APB0_SSP0_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB0_SSP0_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB0_SSP0_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB0_SSP0_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU2_CLK_APB0_SSP0_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU2_CLK_APB0_SSP0_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU2_CLK_APB0_SSP0_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB0_SSP0_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB0_SSP0_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU2_CLK_APB0_SSP0_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU2_CLK_APB0_SSP0_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU2_CLK_APB0_SSP0_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB0_SSP0_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_APB0_SSP0_STAT: CLK_APB0_SSP0 clock status register
	// Position of RUN field.
	CCU2_CLK_APB0_SSP0_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_APB0_SSP0_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_APB0_SSP0_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU2_CLK_APB0_SSP0_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_APB0_SSP0_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_APB0_SSP0_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU2_CLK_APB0_SSP0_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_APB0_SSP0_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_APB0_SSP0_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU2_CLK_APB0_SSP0_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_APB0_SSP0_STAT_RESERVED_Msk = 0xfffffff8

	// CLK_SDIO_CFG: CLK_SDIO clock configuration register
	// Position of RUN field.
	CCU2_CLK_SDIO_CFG_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_SDIO_CFG_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_SDIO_CFG_RUN = 0x1
	// Clock is disabled.
	CCU2_CLK_SDIO_CFG_RUN_DISABLED = 0x0
	// Clock is enabled.
	CCU2_CLK_SDIO_CFG_RUN_ENABLED = 0x1
	// Position of AUTO field.
	CCU2_CLK_SDIO_CFG_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_SDIO_CFG_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_SDIO_CFG_AUTO = 0x2
	// Auto is disabled.
	CCU2_CLK_SDIO_CFG_AUTO_DISABLED_ = 0x0
	// Auto is enabled.
	CCU2_CLK_SDIO_CFG_AUTO_ENABLED = 0x1
	// Position of WAKEUP field.
	CCU2_CLK_SDIO_CFG_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_SDIO_CFG_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_SDIO_CFG_WAKEUP = 0x4
	// Wake-up is disabled.
	CCU2_CLK_SDIO_CFG_WAKEUP_DISABLED = 0x0
	// Wake-up is enabled.
	CCU2_CLK_SDIO_CFG_WAKEUP_ENABLED = 0x1
	// Position of RESERVED field.
	CCU2_CLK_SDIO_CFG_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_SDIO_CFG_RESERVED_Msk = 0xfffffff8

	// CLK_SDIO_STAT: CLK_SDIO clock status register
	// Position of RUN field.
	CCU2_CLK_SDIO_STAT_RUN_Pos = 0x0
	// Bit mask of RUN field.
	CCU2_CLK_SDIO_STAT_RUN_Msk = 0x1
	// Bit RUN.
	CCU2_CLK_SDIO_STAT_RUN = 0x1
	// Position of AUTO field.
	CCU2_CLK_SDIO_STAT_AUTO_Pos = 0x1
	// Bit mask of AUTO field.
	CCU2_CLK_SDIO_STAT_AUTO_Msk = 0x2
	// Bit AUTO.
	CCU2_CLK_SDIO_STAT_AUTO = 0x2
	// Position of WAKEUP field.
	CCU2_CLK_SDIO_STAT_WAKEUP_Pos = 0x2
	// Bit mask of WAKEUP field.
	CCU2_CLK_SDIO_STAT_WAKEUP_Msk = 0x4
	// Bit WAKEUP.
	CCU2_CLK_SDIO_STAT_WAKEUP = 0x4
	// Position of RESERVED field.
	CCU2_CLK_SDIO_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CCU2_CLK_SDIO_STAT_RESERVED_Msk = 0xfffffff8
)

// Constants for RGU: Reset Generation Unit (RGU)
const (
	// RESET_CTRL0: Reset control register 0
	// Position of CORE_RST field.
	RGU_RESET_CTRL0_CORE_RST_Pos = 0x0
	// Bit mask of CORE_RST field.
	RGU_RESET_CTRL0_CORE_RST_Msk = 0x1
	// Bit CORE_RST.
	RGU_RESET_CTRL0_CORE_RST = 0x1
	// Position of PERIPH_RST field.
	RGU_RESET_CTRL0_PERIPH_RST_Pos = 0x1
	// Bit mask of PERIPH_RST field.
	RGU_RESET_CTRL0_PERIPH_RST_Msk = 0x2
	// Bit PERIPH_RST.
	RGU_RESET_CTRL0_PERIPH_RST = 0x2
	// Position of MASTER_RST field.
	RGU_RESET_CTRL0_MASTER_RST_Pos = 0x2
	// Bit mask of MASTER_RST field.
	RGU_RESET_CTRL0_MASTER_RST_Msk = 0x4
	// Bit MASTER_RST.
	RGU_RESET_CTRL0_MASTER_RST = 0x4
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x8
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x8
	// Position of WWDT_RST field.
	RGU_RESET_CTRL0_WWDT_RST_Pos = 0x4
	// Bit mask of WWDT_RST field.
	RGU_RESET_CTRL0_WWDT_RST_Msk = 0x10
	// Bit WWDT_RST.
	RGU_RESET_CTRL0_WWDT_RST = 0x10
	// Position of CREG_RST field.
	RGU_RESET_CTRL0_CREG_RST_Pos = 0x5
	// Bit mask of CREG_RST field.
	RGU_RESET_CTRL0_CREG_RST_Msk = 0x20
	// Bit CREG_RST.
	RGU_RESET_CTRL0_CREG_RST = 0x20
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x40
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x40
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x80
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x80
	// Position of BUS_RST field.
	RGU_RESET_CTRL0_BUS_RST_Pos = 0x8
	// Bit mask of BUS_RST field.
	RGU_RESET_CTRL0_BUS_RST_Msk = 0x100
	// Bit BUS_RST.
	RGU_RESET_CTRL0_BUS_RST = 0x100
	// Position of SCU_RST field.
	RGU_RESET_CTRL0_SCU_RST_Pos = 0x9
	// Bit mask of SCU_RST field.
	RGU_RESET_CTRL0_SCU_RST_Msk = 0x200
	// Bit SCU_RST.
	RGU_RESET_CTRL0_SCU_RST = 0x200
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x400
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x400
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x800
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x800
	// Position of M0_SUB_RST field.
	RGU_RESET_CTRL0_M0_SUB_RST_Pos = 0xc
	// Bit mask of M0_SUB_RST field.
	RGU_RESET_CTRL0_M0_SUB_RST_Msk = 0x1000
	// Bit M0_SUB_RST.
	RGU_RESET_CTRL0_M0_SUB_RST = 0x1000
	// Position of M3_RST field.
	RGU_RESET_CTRL0_M3_RST_Pos = 0xd
	// Bit mask of M3_RST field.
	RGU_RESET_CTRL0_M3_RST_Msk = 0x2000
	// Bit M3_RST.
	RGU_RESET_CTRL0_M3_RST = 0x2000
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x4000
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x4000
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x8000
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x8000
	// Position of LCD_RST field.
	RGU_RESET_CTRL0_LCD_RST_Pos = 0x10
	// Bit mask of LCD_RST field.
	RGU_RESET_CTRL0_LCD_RST_Msk = 0x10000
	// Bit LCD_RST.
	RGU_RESET_CTRL0_LCD_RST = 0x10000
	// Position of USB0_RST field.
	RGU_RESET_CTRL0_USB0_RST_Pos = 0x11
	// Bit mask of USB0_RST field.
	RGU_RESET_CTRL0_USB0_RST_Msk = 0x20000
	// Bit USB0_RST.
	RGU_RESET_CTRL0_USB0_RST = 0x20000
	// Position of USB1_RST field.
	RGU_RESET_CTRL0_USB1_RST_Pos = 0x12
	// Bit mask of USB1_RST field.
	RGU_RESET_CTRL0_USB1_RST_Msk = 0x40000
	// Bit USB1_RST.
	RGU_RESET_CTRL0_USB1_RST = 0x40000
	// Position of DMA_RST field.
	RGU_RESET_CTRL0_DMA_RST_Pos = 0x13
	// Bit mask of DMA_RST field.
	RGU_RESET_CTRL0_DMA_RST_Msk = 0x80000
	// Bit DMA_RST.
	RGU_RESET_CTRL0_DMA_RST = 0x80000
	// Position of SDIO_RST field.
	RGU_RESET_CTRL0_SDIO_RST_Pos = 0x14
	// Bit mask of SDIO_RST field.
	RGU_RESET_CTRL0_SDIO_RST_Msk = 0x100000
	// Bit SDIO_RST.
	RGU_RESET_CTRL0_SDIO_RST = 0x100000
	// Position of EMC_RST field.
	RGU_RESET_CTRL0_EMC_RST_Pos = 0x15
	// Bit mask of EMC_RST field.
	RGU_RESET_CTRL0_EMC_RST_Msk = 0x200000
	// Bit EMC_RST.
	RGU_RESET_CTRL0_EMC_RST = 0x200000
	// Position of ETHERNET_RST field.
	RGU_RESET_CTRL0_ETHERNET_RST_Pos = 0x16
	// Bit mask of ETHERNET_RST field.
	RGU_RESET_CTRL0_ETHERNET_RST_Msk = 0x400000
	// Bit ETHERNET_RST.
	RGU_RESET_CTRL0_ETHERNET_RST = 0x400000
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0x17
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x800000
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x800000
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x1000000
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x1000000
	// Position of FLASHA_RST field.
	RGU_RESET_CTRL0_FLASHA_RST_Pos = 0x19
	// Bit mask of FLASHA_RST field.
	RGU_RESET_CTRL0_FLASHA_RST_Msk = 0x2000000
	// Bit FLASHA_RST.
	RGU_RESET_CTRL0_FLASHA_RST = 0x2000000
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x4000000
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x4000000
	// Position of EEPROM_RST field.
	RGU_RESET_CTRL0_EEPROM_RST_Pos = 0x1b
	// Bit mask of EEPROM_RST field.
	RGU_RESET_CTRL0_EEPROM_RST_Msk = 0x8000000
	// Bit EEPROM_RST.
	RGU_RESET_CTRL0_EEPROM_RST = 0x8000000
	// Position of GPIO_RST field.
	RGU_RESET_CTRL0_GPIO_RST_Pos = 0x1c
	// Bit mask of GPIO_RST field.
	RGU_RESET_CTRL0_GPIO_RST_Msk = 0x10000000
	// Bit GPIO_RST.
	RGU_RESET_CTRL0_GPIO_RST = 0x10000000
	// Position of FLASHB_RST field.
	RGU_RESET_CTRL0_FLASHB_RST_Pos = 0x1d
	// Bit mask of FLASHB_RST field.
	RGU_RESET_CTRL0_FLASHB_RST_Msk = 0x20000000
	// Bit FLASHB_RST.
	RGU_RESET_CTRL0_FLASHB_RST = 0x20000000
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0x1e
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x40000000
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x40000000
	// Position of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL0_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	RGU_RESET_CTRL0_RESERVED = 0x80000000

	// RESET_CTRL1: Reset control register 1
	// Position of TIMER0_RST field.
	RGU_RESET_CTRL1_TIMER0_RST_Pos = 0x0
	// Bit mask of TIMER0_RST field.
	RGU_RESET_CTRL1_TIMER0_RST_Msk = 0x1
	// Bit TIMER0_RST.
	RGU_RESET_CTRL1_TIMER0_RST = 0x1
	// Position of TIMER1_RST field.
	RGU_RESET_CTRL1_TIMER1_RST_Pos = 0x1
	// Bit mask of TIMER1_RST field.
	RGU_RESET_CTRL1_TIMER1_RST_Msk = 0x2
	// Bit TIMER1_RST.
	RGU_RESET_CTRL1_TIMER1_RST = 0x2
	// Position of TIMER2_RST field.
	RGU_RESET_CTRL1_TIMER2_RST_Pos = 0x2
	// Bit mask of TIMER2_RST field.
	RGU_RESET_CTRL1_TIMER2_RST_Msk = 0x4
	// Bit TIMER2_RST.
	RGU_RESET_CTRL1_TIMER2_RST = 0x4
	// Position of TIMER3_RST field.
	RGU_RESET_CTRL1_TIMER3_RST_Pos = 0x3
	// Bit mask of TIMER3_RST field.
	RGU_RESET_CTRL1_TIMER3_RST_Msk = 0x8
	// Bit TIMER3_RST.
	RGU_RESET_CTRL1_TIMER3_RST = 0x8
	// Position of RITIMER_RST field.
	RGU_RESET_CTRL1_RITIMER_RST_Pos = 0x4
	// Bit mask of RITIMER_RST field.
	RGU_RESET_CTRL1_RITIMER_RST_Msk = 0x10
	// Bit RITIMER_RST.
	RGU_RESET_CTRL1_RITIMER_RST = 0x10
	// Position of SCT_RST field.
	RGU_RESET_CTRL1_SCT_RST_Pos = 0x5
	// Bit mask of SCT_RST field.
	RGU_RESET_CTRL1_SCT_RST_Msk = 0x20
	// Bit SCT_RST.
	RGU_RESET_CTRL1_SCT_RST = 0x20
	// Position of MOTOCONPWM_RST field.
	RGU_RESET_CTRL1_MOTOCONPWM_RST_Pos = 0x6
	// Bit mask of MOTOCONPWM_RST field.
	RGU_RESET_CTRL1_MOTOCONPWM_RST_Msk = 0x40
	// Bit MOTOCONPWM_RST.
	RGU_RESET_CTRL1_MOTOCONPWM_RST = 0x40
	// Position of QEI_RST field.
	RGU_RESET_CTRL1_QEI_RST_Pos = 0x7
	// Bit mask of QEI_RST field.
	RGU_RESET_CTRL1_QEI_RST_Msk = 0x80
	// Bit QEI_RST.
	RGU_RESET_CTRL1_QEI_RST = 0x80
	// Position of ADC0_RST field.
	RGU_RESET_CTRL1_ADC0_RST_Pos = 0x8
	// Bit mask of ADC0_RST field.
	RGU_RESET_CTRL1_ADC0_RST_Msk = 0x100
	// Bit ADC0_RST.
	RGU_RESET_CTRL1_ADC0_RST = 0x100
	// Position of ADC1_RST field.
	RGU_RESET_CTRL1_ADC1_RST_Pos = 0x9
	// Bit mask of ADC1_RST field.
	RGU_RESET_CTRL1_ADC1_RST_Msk = 0x200
	// Bit ADC1_RST.
	RGU_RESET_CTRL1_ADC1_RST = 0x200
	// Position of DAC_RST field.
	RGU_RESET_CTRL1_DAC_RST_Pos = 0xa
	// Bit mask of DAC_RST field.
	RGU_RESET_CTRL1_DAC_RST_Msk = 0x400
	// Bit DAC_RST.
	RGU_RESET_CTRL1_DAC_RST = 0x400
	// Position of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Msk = 0x800
	// Bit RESERVED.
	RGU_RESET_CTRL1_RESERVED = 0x800
	// Position of UART0_RST field.
	RGU_RESET_CTRL1_UART0_RST_Pos = 0xc
	// Bit mask of UART0_RST field.
	RGU_RESET_CTRL1_UART0_RST_Msk = 0x1000
	// Bit UART0_RST.
	RGU_RESET_CTRL1_UART0_RST = 0x1000
	// Position of UART1_RST field.
	RGU_RESET_CTRL1_UART1_RST_Pos = 0xd
	// Bit mask of UART1_RST field.
	RGU_RESET_CTRL1_UART1_RST_Msk = 0x2000
	// Bit UART1_RST.
	RGU_RESET_CTRL1_UART1_RST = 0x2000
	// Position of UART2_RST field.
	RGU_RESET_CTRL1_UART2_RST_Pos = 0xe
	// Bit mask of UART2_RST field.
	RGU_RESET_CTRL1_UART2_RST_Msk = 0x4000
	// Bit UART2_RST.
	RGU_RESET_CTRL1_UART2_RST = 0x4000
	// Position of UART3_RST field.
	RGU_RESET_CTRL1_UART3_RST_Pos = 0xf
	// Bit mask of UART3_RST field.
	RGU_RESET_CTRL1_UART3_RST_Msk = 0x8000
	// Bit UART3_RST.
	RGU_RESET_CTRL1_UART3_RST = 0x8000
	// Position of I2C0_RST field.
	RGU_RESET_CTRL1_I2C0_RST_Pos = 0x10
	// Bit mask of I2C0_RST field.
	RGU_RESET_CTRL1_I2C0_RST_Msk = 0x10000
	// Bit I2C0_RST.
	RGU_RESET_CTRL1_I2C0_RST = 0x10000
	// Position of I2C1_RST field.
	RGU_RESET_CTRL1_I2C1_RST_Pos = 0x11
	// Bit mask of I2C1_RST field.
	RGU_RESET_CTRL1_I2C1_RST_Msk = 0x20000
	// Bit I2C1_RST.
	RGU_RESET_CTRL1_I2C1_RST = 0x20000
	// Position of SSP0_RST field.
	RGU_RESET_CTRL1_SSP0_RST_Pos = 0x12
	// Bit mask of SSP0_RST field.
	RGU_RESET_CTRL1_SSP0_RST_Msk = 0x40000
	// Bit SSP0_RST.
	RGU_RESET_CTRL1_SSP0_RST = 0x40000
	// Position of SSP1_RST field.
	RGU_RESET_CTRL1_SSP1_RST_Pos = 0x13
	// Bit mask of SSP1_RST field.
	RGU_RESET_CTRL1_SSP1_RST_Msk = 0x80000
	// Bit SSP1_RST.
	RGU_RESET_CTRL1_SSP1_RST = 0x80000
	// Position of I2S_RST field.
	RGU_RESET_CTRL1_I2S_RST_Pos = 0x14
	// Bit mask of I2S_RST field.
	RGU_RESET_CTRL1_I2S_RST_Msk = 0x100000
	// Bit I2S_RST.
	RGU_RESET_CTRL1_I2S_RST = 0x100000
	// Position of SPIFI_RST field.
	RGU_RESET_CTRL1_SPIFI_RST_Pos = 0x15
	// Bit mask of SPIFI_RST field.
	RGU_RESET_CTRL1_SPIFI_RST_Msk = 0x200000
	// Bit SPIFI_RST.
	RGU_RESET_CTRL1_SPIFI_RST = 0x200000
	// Position of CAN1_RST field.
	RGU_RESET_CTRL1_CAN1_RST_Pos = 0x16
	// Bit mask of CAN1_RST field.
	RGU_RESET_CTRL1_CAN1_RST_Msk = 0x400000
	// Bit CAN1_RST.
	RGU_RESET_CTRL1_CAN1_RST = 0x400000
	// Position of CAN0_RST field.
	RGU_RESET_CTRL1_CAN0_RST_Pos = 0x17
	// Bit mask of CAN0_RST field.
	RGU_RESET_CTRL1_CAN0_RST_Msk = 0x800000
	// Bit CAN0_RST.
	RGU_RESET_CTRL1_CAN0_RST = 0x800000
	// Position of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Msk = 0x1000000
	// Bit RESERVED.
	RGU_RESET_CTRL1_RESERVED = 0x1000000
	// Position of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Pos = 0x19
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Msk = 0xe000000
	// Position of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Msk = 0x10000000
	// Bit RESERVED.
	RGU_RESET_CTRL1_RESERVED = 0x10000000
	// Position of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Msk = 0x20000000
	// Bit RESERVED.
	RGU_RESET_CTRL1_RESERVED = 0x20000000
	// Position of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Pos = 0x1e
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Msk = 0x40000000
	// Bit RESERVED.
	RGU_RESET_CTRL1_RESERVED = 0x40000000
	// Position of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	RGU_RESET_CTRL1_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	RGU_RESET_CTRL1_RESERVED = 0x80000000

	// RESET_STATUS0: Reset status register 0
	// Position of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Msk = 0x3
	// Position of PERIPH_RST field.
	RGU_RESET_STATUS0_PERIPH_RST_Pos = 0x2
	// Bit mask of PERIPH_RST field.
	RGU_RESET_STATUS0_PERIPH_RST_Msk = 0xc
	// Position of MASTER_RST field.
	RGU_RESET_STATUS0_MASTER_RST_Pos = 0x4
	// Bit mask of MASTER_RST field.
	RGU_RESET_STATUS0_MASTER_RST_Msk = 0x30
	// Position of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Msk = 0xc0
	// Position of WWDT_RST field.
	RGU_RESET_STATUS0_WWDT_RST_Pos = 0x8
	// Bit mask of WWDT_RST field.
	RGU_RESET_STATUS0_WWDT_RST_Msk = 0x300
	// Position of CREG_RST field.
	RGU_RESET_STATUS0_CREG_RST_Pos = 0xa
	// Bit mask of CREG_RST field.
	RGU_RESET_STATUS0_CREG_RST_Msk = 0xc00
	// Position of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Msk = 0x3000
	// Position of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Msk = 0xc000
	// Position of BUS_RST field.
	RGU_RESET_STATUS0_BUS_RST_Pos = 0x10
	// Bit mask of BUS_RST field.
	RGU_RESET_STATUS0_BUS_RST_Msk = 0x30000
	// Position of SCU_RST field.
	RGU_RESET_STATUS0_SCU_RST_Pos = 0x12
	// Bit mask of SCU_RST field.
	RGU_RESET_STATUS0_SCU_RST_Msk = 0xc0000
	// Position of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Msk = 0x300000
	// Position of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Msk = 0xc00000
	// Position of M0SUB_RST field.
	RGU_RESET_STATUS0_M0SUB_RST_Pos = 0x18
	// Bit mask of M0SUB_RST field.
	RGU_RESET_STATUS0_M0SUB_RST_Msk = 0x3000000
	// Position of M3_RST field.
	RGU_RESET_STATUS0_M3_RST_Pos = 0x1a
	// Bit mask of M3_RST field.
	RGU_RESET_STATUS0_M3_RST_Msk = 0xc000000
	// Position of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Msk = 0x30000000
	// Position of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Pos = 0x1e
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS0_RESERVED_Msk = 0xc0000000

	// RESET_STATUS1: Reset status register 1
	// Position of LCD_RST field.
	RGU_RESET_STATUS1_LCD_RST_Pos = 0x0
	// Bit mask of LCD_RST field.
	RGU_RESET_STATUS1_LCD_RST_Msk = 0x3
	// Position of USB0_RST field.
	RGU_RESET_STATUS1_USB0_RST_Pos = 0x2
	// Bit mask of USB0_RST field.
	RGU_RESET_STATUS1_USB0_RST_Msk = 0xc
	// Position of USB1_RST field.
	RGU_RESET_STATUS1_USB1_RST_Pos = 0x4
	// Bit mask of USB1_RST field.
	RGU_RESET_STATUS1_USB1_RST_Msk = 0x30
	// Position of DMA_RST field.
	RGU_RESET_STATUS1_DMA_RST_Pos = 0x6
	// Bit mask of DMA_RST field.
	RGU_RESET_STATUS1_DMA_RST_Msk = 0xc0
	// Position of SDIO_RST field.
	RGU_RESET_STATUS1_SDIO_RST_Pos = 0x8
	// Bit mask of SDIO_RST field.
	RGU_RESET_STATUS1_SDIO_RST_Msk = 0x300
	// Position of EMC_RST field.
	RGU_RESET_STATUS1_EMC_RST_Pos = 0xa
	// Bit mask of EMC_RST field.
	RGU_RESET_STATUS1_EMC_RST_Msk = 0xc00
	// Position of ETHERNET_RST field.
	RGU_RESET_STATUS1_ETHERNET_RST_Pos = 0xc
	// Bit mask of ETHERNET_RST field.
	RGU_RESET_STATUS1_ETHERNET_RST_Msk = 0x3000
	// Position of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Msk = 0xc000
	// Position of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Msk = 0x30000
	// Position of FLASHA_RST field.
	RGU_RESET_STATUS1_FLASHA_RST_Pos = 0x12
	// Bit mask of FLASHA_RST field.
	RGU_RESET_STATUS1_FLASHA_RST_Msk = 0xc0000
	// Position of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Msk = 0x300000
	// Position of EEPROM_RST field.
	RGU_RESET_STATUS1_EEPROM_RST_Pos = 0x16
	// Bit mask of EEPROM_RST field.
	RGU_RESET_STATUS1_EEPROM_RST_Msk = 0xc00000
	// Position of GPIO_RST field.
	RGU_RESET_STATUS1_GPIO_RST_Pos = 0x18
	// Bit mask of GPIO_RST field.
	RGU_RESET_STATUS1_GPIO_RST_Msk = 0x3000000
	// Position of FLASHB_RST field.
	RGU_RESET_STATUS1_FLASHB_RST_Pos = 0x1a
	// Bit mask of FLASHB_RST field.
	RGU_RESET_STATUS1_FLASHB_RST_Msk = 0xc000000
	// Position of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Msk = 0x30000000
	// Position of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Pos = 0x1e
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS1_RESERVED_Msk = 0xc0000000

	// RESET_STATUS2: Reset status register 2
	// Position of TIMER0_RST field.
	RGU_RESET_STATUS2_TIMER0_RST_Pos = 0x0
	// Bit mask of TIMER0_RST field.
	RGU_RESET_STATUS2_TIMER0_RST_Msk = 0x3
	// Position of TIMER1_RST field.
	RGU_RESET_STATUS2_TIMER1_RST_Pos = 0x2
	// Bit mask of TIMER1_RST field.
	RGU_RESET_STATUS2_TIMER1_RST_Msk = 0xc
	// Position of TIMER2_RST field.
	RGU_RESET_STATUS2_TIMER2_RST_Pos = 0x4
	// Bit mask of TIMER2_RST field.
	RGU_RESET_STATUS2_TIMER2_RST_Msk = 0x30
	// Position of TIMER3_RST field.
	RGU_RESET_STATUS2_TIMER3_RST_Pos = 0x6
	// Bit mask of TIMER3_RST field.
	RGU_RESET_STATUS2_TIMER3_RST_Msk = 0xc0
	// Position of RITIMER_RST field.
	RGU_RESET_STATUS2_RITIMER_RST_Pos = 0x8
	// Bit mask of RITIMER_RST field.
	RGU_RESET_STATUS2_RITIMER_RST_Msk = 0x300
	// Position of SCT_RST field.
	RGU_RESET_STATUS2_SCT_RST_Pos = 0xa
	// Bit mask of SCT_RST field.
	RGU_RESET_STATUS2_SCT_RST_Msk = 0xc00
	// Position of MOTOCONPWM_RST field.
	RGU_RESET_STATUS2_MOTOCONPWM_RST_Pos = 0xc
	// Bit mask of MOTOCONPWM_RST field.
	RGU_RESET_STATUS2_MOTOCONPWM_RST_Msk = 0x3000
	// Position of QEI_RST field.
	RGU_RESET_STATUS2_QEI_RST_Pos = 0xe
	// Bit mask of QEI_RST field.
	RGU_RESET_STATUS2_QEI_RST_Msk = 0xc000
	// Position of ADC0_RST field.
	RGU_RESET_STATUS2_ADC0_RST_Pos = 0x10
	// Bit mask of ADC0_RST field.
	RGU_RESET_STATUS2_ADC0_RST_Msk = 0x30000
	// Position of ADC1_RST field.
	RGU_RESET_STATUS2_ADC1_RST_Pos = 0x12
	// Bit mask of ADC1_RST field.
	RGU_RESET_STATUS2_ADC1_RST_Msk = 0xc0000
	// Position of DAC_RST field.
	RGU_RESET_STATUS2_DAC_RST_Pos = 0x14
	// Bit mask of DAC_RST field.
	RGU_RESET_STATUS2_DAC_RST_Msk = 0x300000
	// Position of RESERVED field.
	RGU_RESET_STATUS2_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS2_RESERVED_Msk = 0xc00000
	// Position of UART0_RST field.
	RGU_RESET_STATUS2_UART0_RST_Pos = 0x18
	// Bit mask of UART0_RST field.
	RGU_RESET_STATUS2_UART0_RST_Msk = 0x3000000
	// Position of UART1_RST field.
	RGU_RESET_STATUS2_UART1_RST_Pos = 0x1a
	// Bit mask of UART1_RST field.
	RGU_RESET_STATUS2_UART1_RST_Msk = 0xc000000
	// Position of UART2_RST field.
	RGU_RESET_STATUS2_UART2_RST_Pos = 0x1c
	// Bit mask of UART2_RST field.
	RGU_RESET_STATUS2_UART2_RST_Msk = 0x30000000
	// Position of UART3_RST field.
	RGU_RESET_STATUS2_UART3_RST_Pos = 0x1e
	// Bit mask of UART3_RST field.
	RGU_RESET_STATUS2_UART3_RST_Msk = 0xc0000000

	// RESET_STATUS3: Reset status register 3
	// Position of I2C0_RST field.
	RGU_RESET_STATUS3_I2C0_RST_Pos = 0x0
	// Bit mask of I2C0_RST field.
	RGU_RESET_STATUS3_I2C0_RST_Msk = 0x3
	// Position of I2C1_RST field.
	RGU_RESET_STATUS3_I2C1_RST_Pos = 0x2
	// Bit mask of I2C1_RST field.
	RGU_RESET_STATUS3_I2C1_RST_Msk = 0xc
	// Position of SSP0_RST field.
	RGU_RESET_STATUS3_SSP0_RST_Pos = 0x4
	// Bit mask of SSP0_RST field.
	RGU_RESET_STATUS3_SSP0_RST_Msk = 0x30
	// Position of SSP1_RST field.
	RGU_RESET_STATUS3_SSP1_RST_Pos = 0x6
	// Bit mask of SSP1_RST field.
	RGU_RESET_STATUS3_SSP1_RST_Msk = 0xc0
	// Position of I2S_RST field.
	RGU_RESET_STATUS3_I2S_RST_Pos = 0x8
	// Bit mask of I2S_RST field.
	RGU_RESET_STATUS3_I2S_RST_Msk = 0x300
	// Position of SPIFI_RST field.
	RGU_RESET_STATUS3_SPIFI_RST_Pos = 0xa
	// Bit mask of SPIFI_RST field.
	RGU_RESET_STATUS3_SPIFI_RST_Msk = 0xc00
	// Position of CAN1_RST field.
	RGU_RESET_STATUS3_CAN1_RST_Pos = 0xc
	// Bit mask of CAN1_RST field.
	RGU_RESET_STATUS3_CAN1_RST_Msk = 0x3000
	// Position of CAN0_RST field.
	RGU_RESET_STATUS3_CAN0_RST_Pos = 0xe
	// Bit mask of CAN0_RST field.
	RGU_RESET_STATUS3_CAN0_RST_Msk = 0xc000
	// Position of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Msk = 0x30000
	// Position of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Msk = 0xfc0000
	// Position of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Msk = 0x3000000
	// Position of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Msk = 0xc000000
	// Position of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Msk = 0x30000000
	// Position of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Pos = 0x1e
	// Bit mask of RESERVED field.
	RGU_RESET_STATUS3_RESERVED_Msk = 0xc0000000

	// RESET_ACTIVE_STATUS0: Reset active status register 0
	// Position of CORE_RST field.
	RGU_RESET_ACTIVE_STATUS0_CORE_RST_Pos = 0x0
	// Bit mask of CORE_RST field.
	RGU_RESET_ACTIVE_STATUS0_CORE_RST_Msk = 0x1
	// Bit CORE_RST.
	RGU_RESET_ACTIVE_STATUS0_CORE_RST = 0x1
	// Position of PERIPH_RST field.
	RGU_RESET_ACTIVE_STATUS0_PERIPH_RST_Pos = 0x1
	// Bit mask of PERIPH_RST field.
	RGU_RESET_ACTIVE_STATUS0_PERIPH_RST_Msk = 0x2
	// Bit PERIPH_RST.
	RGU_RESET_ACTIVE_STATUS0_PERIPH_RST = 0x2
	// Position of MASTER_RST field.
	RGU_RESET_ACTIVE_STATUS0_MASTER_RST_Pos = 0x2
	// Bit mask of MASTER_RST field.
	RGU_RESET_ACTIVE_STATUS0_MASTER_RST_Msk = 0x4
	// Bit MASTER_RST.
	RGU_RESET_ACTIVE_STATUS0_MASTER_RST = 0x4
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x8
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x8
	// Position of WWDT_RST field.
	RGU_RESET_ACTIVE_STATUS0_WWDT_RST_Pos = 0x4
	// Bit mask of WWDT_RST field.
	RGU_RESET_ACTIVE_STATUS0_WWDT_RST_Msk = 0x10
	// Bit WWDT_RST.
	RGU_RESET_ACTIVE_STATUS0_WWDT_RST = 0x10
	// Position of CREG_RST field.
	RGU_RESET_ACTIVE_STATUS0_CREG_RST_Pos = 0x5
	// Bit mask of CREG_RST field.
	RGU_RESET_ACTIVE_STATUS0_CREG_RST_Msk = 0x20
	// Bit CREG_RST.
	RGU_RESET_ACTIVE_STATUS0_CREG_RST = 0x20
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x40
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x40
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x80
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x80
	// Position of BUS_RST field.
	RGU_RESET_ACTIVE_STATUS0_BUS_RST_Pos = 0x8
	// Bit mask of BUS_RST field.
	RGU_RESET_ACTIVE_STATUS0_BUS_RST_Msk = 0x100
	// Bit BUS_RST.
	RGU_RESET_ACTIVE_STATUS0_BUS_RST = 0x100
	// Position of SCU_RST field.
	RGU_RESET_ACTIVE_STATUS0_SCU_RST_Pos = 0x9
	// Bit mask of SCU_RST field.
	RGU_RESET_ACTIVE_STATUS0_SCU_RST_Msk = 0x200
	// Bit SCU_RST.
	RGU_RESET_ACTIVE_STATUS0_SCU_RST = 0x200
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x400
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x400
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x800
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x800
	// Position of M0SUB_RST field.
	RGU_RESET_ACTIVE_STATUS0_M0SUB_RST_Pos = 0xc
	// Bit mask of M0SUB_RST field.
	RGU_RESET_ACTIVE_STATUS0_M0SUB_RST_Msk = 0x1000
	// Bit M0SUB_RST.
	RGU_RESET_ACTIVE_STATUS0_M0SUB_RST = 0x1000
	// Position of M3_RST field.
	RGU_RESET_ACTIVE_STATUS0_M3_RST_Pos = 0xd
	// Bit mask of M3_RST field.
	RGU_RESET_ACTIVE_STATUS0_M3_RST_Msk = 0x2000
	// Bit M3_RST.
	RGU_RESET_ACTIVE_STATUS0_M3_RST = 0x2000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x4000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x4000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x8000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x8000
	// Position of LCD_RST field.
	RGU_RESET_ACTIVE_STATUS0_LCD_RST_Pos = 0x10
	// Bit mask of LCD_RST field.
	RGU_RESET_ACTIVE_STATUS0_LCD_RST_Msk = 0x10000
	// Bit LCD_RST.
	RGU_RESET_ACTIVE_STATUS0_LCD_RST = 0x10000
	// Position of USB0_RST field.
	RGU_RESET_ACTIVE_STATUS0_USB0_RST_Pos = 0x11
	// Bit mask of USB0_RST field.
	RGU_RESET_ACTIVE_STATUS0_USB0_RST_Msk = 0x20000
	// Bit USB0_RST.
	RGU_RESET_ACTIVE_STATUS0_USB0_RST = 0x20000
	// Position of USB1_RST field.
	RGU_RESET_ACTIVE_STATUS0_USB1_RST_Pos = 0x12
	// Bit mask of USB1_RST field.
	RGU_RESET_ACTIVE_STATUS0_USB1_RST_Msk = 0x40000
	// Bit USB1_RST.
	RGU_RESET_ACTIVE_STATUS0_USB1_RST = 0x40000
	// Position of DMA_RST field.
	RGU_RESET_ACTIVE_STATUS0_DMA_RST_Pos = 0x13
	// Bit mask of DMA_RST field.
	RGU_RESET_ACTIVE_STATUS0_DMA_RST_Msk = 0x80000
	// Bit DMA_RST.
	RGU_RESET_ACTIVE_STATUS0_DMA_RST = 0x80000
	// Position of SDIO_RST field.
	RGU_RESET_ACTIVE_STATUS0_SDIO_RST_Pos = 0x14
	// Bit mask of SDIO_RST field.
	RGU_RESET_ACTIVE_STATUS0_SDIO_RST_Msk = 0x100000
	// Bit SDIO_RST.
	RGU_RESET_ACTIVE_STATUS0_SDIO_RST = 0x100000
	// Position of EMC_RST field.
	RGU_RESET_ACTIVE_STATUS0_EMC_RST_Pos = 0x15
	// Bit mask of EMC_RST field.
	RGU_RESET_ACTIVE_STATUS0_EMC_RST_Msk = 0x200000
	// Bit EMC_RST.
	RGU_RESET_ACTIVE_STATUS0_EMC_RST = 0x200000
	// Position of ETHERNET_RST field.
	RGU_RESET_ACTIVE_STATUS0_ETHERNET_RST_Pos = 0x16
	// Bit mask of ETHERNET_RST field.
	RGU_RESET_ACTIVE_STATUS0_ETHERNET_RST_Msk = 0x400000
	// Bit ETHERNET_RST.
	RGU_RESET_ACTIVE_STATUS0_ETHERNET_RST = 0x400000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0x17
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x800000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x800000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x1000000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x1000000
	// Position of FLASHA_RST field.
	RGU_RESET_ACTIVE_STATUS0_FLASHA_RST_Pos = 0x19
	// Bit mask of FLASHA_RST field.
	RGU_RESET_ACTIVE_STATUS0_FLASHA_RST_Msk = 0x2000000
	// Bit FLASHA_RST.
	RGU_RESET_ACTIVE_STATUS0_FLASHA_RST = 0x2000000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x4000000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x4000000
	// Position of EEPROM_RST field.
	RGU_RESET_ACTIVE_STATUS0_EEPROM_RST_Pos = 0x1b
	// Bit mask of EEPROM_RST field.
	RGU_RESET_ACTIVE_STATUS0_EEPROM_RST_Msk = 0x8000000
	// Bit EEPROM_RST.
	RGU_RESET_ACTIVE_STATUS0_EEPROM_RST = 0x8000000
	// Position of GPIO_RST field.
	RGU_RESET_ACTIVE_STATUS0_GPIO_RST_Pos = 0x1c
	// Bit mask of GPIO_RST field.
	RGU_RESET_ACTIVE_STATUS0_GPIO_RST_Msk = 0x10000000
	// Bit GPIO_RST.
	RGU_RESET_ACTIVE_STATUS0_GPIO_RST = 0x10000000
	// Position of FLASHB_RST field.
	RGU_RESET_ACTIVE_STATUS0_FLASHB_RST_Pos = 0x1d
	// Bit mask of FLASHB_RST field.
	RGU_RESET_ACTIVE_STATUS0_FLASHB_RST_Msk = 0x20000000
	// Bit FLASHB_RST.
	RGU_RESET_ACTIVE_STATUS0_FLASHB_RST = 0x20000000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0x1e
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x40000000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x40000000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS0_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS0_RESERVED = 0x80000000

	// RESET_ACTIVE_STATUS1: Reset active status register 1
	// Position of TIMER0_RST field.
	RGU_RESET_ACTIVE_STATUS1_TIMER0_RST_Pos = 0x0
	// Bit mask of TIMER0_RST field.
	RGU_RESET_ACTIVE_STATUS1_TIMER0_RST_Msk = 0x1
	// Bit TIMER0_RST.
	RGU_RESET_ACTIVE_STATUS1_TIMER0_RST = 0x1
	// Position of TIMER1_RST field.
	RGU_RESET_ACTIVE_STATUS1_TIMER1_RST_Pos = 0x1
	// Bit mask of TIMER1_RST field.
	RGU_RESET_ACTIVE_STATUS1_TIMER1_RST_Msk = 0x2
	// Bit TIMER1_RST.
	RGU_RESET_ACTIVE_STATUS1_TIMER1_RST = 0x2
	// Position of TIMER2_RST field.
	RGU_RESET_ACTIVE_STATUS1_TIMER2_RST_Pos = 0x2
	// Bit mask of TIMER2_RST field.
	RGU_RESET_ACTIVE_STATUS1_TIMER2_RST_Msk = 0x4
	// Bit TIMER2_RST.
	RGU_RESET_ACTIVE_STATUS1_TIMER2_RST = 0x4
	// Position of TIMER3_RST field.
	RGU_RESET_ACTIVE_STATUS1_TIMER3_RST_Pos = 0x3
	// Bit mask of TIMER3_RST field.
	RGU_RESET_ACTIVE_STATUS1_TIMER3_RST_Msk = 0x8
	// Bit TIMER3_RST.
	RGU_RESET_ACTIVE_STATUS1_TIMER3_RST = 0x8
	// Position of RITIMER_RST field.
	RGU_RESET_ACTIVE_STATUS1_RITIMER_RST_Pos = 0x4
	// Bit mask of RITIMER_RST field.
	RGU_RESET_ACTIVE_STATUS1_RITIMER_RST_Msk = 0x10
	// Bit RITIMER_RST.
	RGU_RESET_ACTIVE_STATUS1_RITIMER_RST = 0x10
	// Position of SCT_RST field.
	RGU_RESET_ACTIVE_STATUS1_SCT_RST_Pos = 0x5
	// Bit mask of SCT_RST field.
	RGU_RESET_ACTIVE_STATUS1_SCT_RST_Msk = 0x20
	// Bit SCT_RST.
	RGU_RESET_ACTIVE_STATUS1_SCT_RST = 0x20
	// Position of MOTOCONPWM_RST field.
	RGU_RESET_ACTIVE_STATUS1_MOTOCONPWM_RST_Pos = 0x6
	// Bit mask of MOTOCONPWM_RST field.
	RGU_RESET_ACTIVE_STATUS1_MOTOCONPWM_RST_Msk = 0x40
	// Bit MOTOCONPWM_RST.
	RGU_RESET_ACTIVE_STATUS1_MOTOCONPWM_RST = 0x40
	// Position of QEI_RST field.
	RGU_RESET_ACTIVE_STATUS1_QEI_RST_Pos = 0x7
	// Bit mask of QEI_RST field.
	RGU_RESET_ACTIVE_STATUS1_QEI_RST_Msk = 0x80
	// Bit QEI_RST.
	RGU_RESET_ACTIVE_STATUS1_QEI_RST = 0x80
	// Position of ADC0_RST field.
	RGU_RESET_ACTIVE_STATUS1_ADC0_RST_Pos = 0x8
	// Bit mask of ADC0_RST field.
	RGU_RESET_ACTIVE_STATUS1_ADC0_RST_Msk = 0x100
	// Bit ADC0_RST.
	RGU_RESET_ACTIVE_STATUS1_ADC0_RST = 0x100
	// Position of ADC1_RST field.
	RGU_RESET_ACTIVE_STATUS1_ADC1_RST_Pos = 0x9
	// Bit mask of ADC1_RST field.
	RGU_RESET_ACTIVE_STATUS1_ADC1_RST_Msk = 0x200
	// Bit ADC1_RST.
	RGU_RESET_ACTIVE_STATUS1_ADC1_RST = 0x200
	// Position of DAC_RST field.
	RGU_RESET_ACTIVE_STATUS1_DAC_RST_Pos = 0xa
	// Bit mask of DAC_RST field.
	RGU_RESET_ACTIVE_STATUS1_DAC_RST_Msk = 0x400
	// Bit DAC_RST.
	RGU_RESET_ACTIVE_STATUS1_DAC_RST = 0x400
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Msk = 0x800
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS1_RESERVED = 0x800
	// Position of UART0_RST field.
	RGU_RESET_ACTIVE_STATUS1_UART0_RST_Pos = 0xc
	// Bit mask of UART0_RST field.
	RGU_RESET_ACTIVE_STATUS1_UART0_RST_Msk = 0x1000
	// Bit UART0_RST.
	RGU_RESET_ACTIVE_STATUS1_UART0_RST = 0x1000
	// Position of UART1_RST field.
	RGU_RESET_ACTIVE_STATUS1_UART1_RST_Pos = 0xd
	// Bit mask of UART1_RST field.
	RGU_RESET_ACTIVE_STATUS1_UART1_RST_Msk = 0x2000
	// Bit UART1_RST.
	RGU_RESET_ACTIVE_STATUS1_UART1_RST = 0x2000
	// Position of UART2_RST field.
	RGU_RESET_ACTIVE_STATUS1_UART2_RST_Pos = 0xe
	// Bit mask of UART2_RST field.
	RGU_RESET_ACTIVE_STATUS1_UART2_RST_Msk = 0x4000
	// Bit UART2_RST.
	RGU_RESET_ACTIVE_STATUS1_UART2_RST = 0x4000
	// Position of UART3_RST field.
	RGU_RESET_ACTIVE_STATUS1_UART3_RST_Pos = 0xf
	// Bit mask of UART3_RST field.
	RGU_RESET_ACTIVE_STATUS1_UART3_RST_Msk = 0x8000
	// Bit UART3_RST.
	RGU_RESET_ACTIVE_STATUS1_UART3_RST = 0x8000
	// Position of I2C0_RST field.
	RGU_RESET_ACTIVE_STATUS1_I2C0_RST_Pos = 0x10
	// Bit mask of I2C0_RST field.
	RGU_RESET_ACTIVE_STATUS1_I2C0_RST_Msk = 0x10000
	// Bit I2C0_RST.
	RGU_RESET_ACTIVE_STATUS1_I2C0_RST = 0x10000
	// Position of I2C1_RST field.
	RGU_RESET_ACTIVE_STATUS1_I2C1_RST_Pos = 0x11
	// Bit mask of I2C1_RST field.
	RGU_RESET_ACTIVE_STATUS1_I2C1_RST_Msk = 0x20000
	// Bit I2C1_RST.
	RGU_RESET_ACTIVE_STATUS1_I2C1_RST = 0x20000
	// Position of SSP0_RST field.
	RGU_RESET_ACTIVE_STATUS1_SSP0_RST_Pos = 0x12
	// Bit mask of SSP0_RST field.
	RGU_RESET_ACTIVE_STATUS1_SSP0_RST_Msk = 0x40000
	// Bit SSP0_RST.
	RGU_RESET_ACTIVE_STATUS1_SSP0_RST = 0x40000
	// Position of SSP1_RST field.
	RGU_RESET_ACTIVE_STATUS1_SSP1_RST_Pos = 0x13
	// Bit mask of SSP1_RST field.
	RGU_RESET_ACTIVE_STATUS1_SSP1_RST_Msk = 0x80000
	// Bit SSP1_RST.
	RGU_RESET_ACTIVE_STATUS1_SSP1_RST = 0x80000
	// Position of I2S_RST field.
	RGU_RESET_ACTIVE_STATUS1_I2S_RST_Pos = 0x14
	// Bit mask of I2S_RST field.
	RGU_RESET_ACTIVE_STATUS1_I2S_RST_Msk = 0x100000
	// Bit I2S_RST.
	RGU_RESET_ACTIVE_STATUS1_I2S_RST = 0x100000
	// Position of SPIFI_RST field.
	RGU_RESET_ACTIVE_STATUS1_SPIFI_RST_Pos = 0x15
	// Bit mask of SPIFI_RST field.
	RGU_RESET_ACTIVE_STATUS1_SPIFI_RST_Msk = 0x200000
	// Bit SPIFI_RST.
	RGU_RESET_ACTIVE_STATUS1_SPIFI_RST = 0x200000
	// Position of CAN1_RST field.
	RGU_RESET_ACTIVE_STATUS1_CAN1_RST_Pos = 0x16
	// Bit mask of CAN1_RST field.
	RGU_RESET_ACTIVE_STATUS1_CAN1_RST_Msk = 0x400000
	// Bit CAN1_RST.
	RGU_RESET_ACTIVE_STATUS1_CAN1_RST = 0x400000
	// Position of CAN0_RST field.
	RGU_RESET_ACTIVE_STATUS1_CAN0_RST_Pos = 0x17
	// Bit mask of CAN0_RST field.
	RGU_RESET_ACTIVE_STATUS1_CAN0_RST_Msk = 0x800000
	// Bit CAN0_RST.
	RGU_RESET_ACTIVE_STATUS1_CAN0_RST = 0x800000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Msk = 0x1000000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS1_RESERVED = 0x1000000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Pos = 0x19
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Msk = 0xe000000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Msk = 0x10000000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS1_RESERVED = 0x10000000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Msk = 0x20000000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS1_RESERVED = 0x20000000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Pos = 0x1e
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Msk = 0x40000000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS1_RESERVED = 0x40000000
	// Position of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	RGU_RESET_ACTIVE_STATUS1_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	RGU_RESET_ACTIVE_STATUS1_RESERVED = 0x80000000

	// RESET_EXT_STAT1: Reset external status register 1 for PERIPH_RST
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT1_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT1_RESERVED_Msk = 0x1
	// Bit RESERVED.
	RGU_RESET_EXT_STAT1_RESERVED = 0x1
	// Position of CORE_RESET field.
	RGU_RESET_EXT_STAT1_CORE_RESET_Pos = 0x1
	// Bit mask of CORE_RESET field.
	RGU_RESET_EXT_STAT1_CORE_RESET_Msk = 0x2
	// Bit CORE_RESET.
	RGU_RESET_EXT_STAT1_CORE_RESET = 0x2
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT1_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT1_RESERVED_Msk = 0xfffffffc

	// RESET_EXT_STAT2: Reset external status register 2 for MASTER_RST
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT2_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT2_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT2_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT2_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT2_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT2_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT2_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT5: Reset external status register 5 for CREG_RST
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT5_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT5_RESERVED_Msk = 0x1
	// Bit RESERVED.
	RGU_RESET_EXT_STAT5_RESERVED = 0x1
	// Position of CORE_RESET field.
	RGU_RESET_EXT_STAT5_CORE_RESET_Pos = 0x1
	// Bit mask of CORE_RESET field.
	RGU_RESET_EXT_STAT5_CORE_RESET_Msk = 0x2
	// Bit CORE_RESET.
	RGU_RESET_EXT_STAT5_CORE_RESET = 0x2
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT5_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT5_RESERVED_Msk = 0xfffffffc

	// RESET_EXT_STAT8: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT8_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT8_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT8_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT8_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT8_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT8_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT8_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT9: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT9_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT9_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT9_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT9_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT9_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT9_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT9_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT13: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT13_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT13_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT13_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT13_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT13_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT13_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT13_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT16: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT16_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT16_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT16_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT16_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT16_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT16_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT16_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT17: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT17_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT17_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT17_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT17_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT17_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT17_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT17_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT18: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT18_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT18_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT18_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT18_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT18_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT18_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT18_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT19: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT19_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT19_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT19_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT19_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT19_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT19_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT19_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT20: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT20_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT20_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT20_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT20_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT20_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT20_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT20_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT21: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT21_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT21_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT21_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT21_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT21_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT21_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT21_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT22: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT22_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT22_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT22_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT22_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT22_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT22_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT22_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT25: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT25_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT25_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT25_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT25_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT25_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT25_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT25_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT27: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT27_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT27_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT27_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT27_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT27_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT27_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT27_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT28: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT28_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT28_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT28_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT28_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT28_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT28_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT28_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT29: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT29_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT29_RESERVED_Msk = 0x7
	// Position of MASTER_RESET field.
	RGU_RESET_EXT_STAT29_MASTER_RESET_Pos = 0x3
	// Bit mask of MASTER_RESET field.
	RGU_RESET_EXT_STAT29_MASTER_RESET_Msk = 0x8
	// Bit MASTER_RESET.
	RGU_RESET_EXT_STAT29_MASTER_RESET = 0x8
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT29_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT29_RESERVED_Msk = 0xfffffff0

	// RESET_EXT_STAT32: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT32_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT32_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT32_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT32_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT32_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT32_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT32_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT33: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT33_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT33_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT33_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT33_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT33_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT33_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT33_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT34: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT34_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT34_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT34_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT34_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT34_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT34_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT34_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT35: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT35_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT35_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT35_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT35_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT35_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT35_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT35_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT36: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT36_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT36_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT36_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT36_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT36_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT36_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT36_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT37: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT37_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT37_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT37_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT37_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT37_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT37_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT37_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT38: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT38_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT38_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT38_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT38_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT38_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT38_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT38_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT39: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT39_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT39_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT39_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT39_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT39_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT39_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT39_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT40: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT40_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT40_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT40_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT40_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT40_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT40_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT40_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT41: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT41_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT41_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT41_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT41_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT41_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT41_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT41_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT42: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT42_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT42_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT42_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT42_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT42_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT42_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT42_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT44: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT44_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT44_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT44_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT44_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT44_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT44_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT44_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT45: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT45_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT45_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT45_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT45_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT45_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT45_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT45_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT46: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT46_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT46_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT46_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT46_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT46_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT46_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT46_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT47: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT47_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT47_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT47_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT47_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT47_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT47_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT47_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT48: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT48_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT48_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT48_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT48_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT48_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT48_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT48_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT49: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT49_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT49_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT49_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT49_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT49_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT49_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT49_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT50: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT50_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT50_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT50_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT50_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT50_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT50_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT50_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT51: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT51_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT51_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT51_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT51_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT51_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT51_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT51_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT52: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT52_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT52_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT52_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT52_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT52_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT52_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT52_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT53: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT53_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT53_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT53_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT53_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT53_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT53_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT53_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT54: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT54_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT54_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT54_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT54_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT54_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT54_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT54_RESERVED_Msk = 0xfffffff8

	// RESET_EXT_STAT55: Reset external status register
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT55_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT55_RESERVED_Msk = 0x3
	// Position of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT55_PERIPHERAL_RESET_Pos = 0x2
	// Bit mask of PERIPHERAL_RESET field.
	RGU_RESET_EXT_STAT55_PERIPHERAL_RESET_Msk = 0x4
	// Bit PERIPHERAL_RESET.
	RGU_RESET_EXT_STAT55_PERIPHERAL_RESET = 0x4
	// Position of RESERVED field.
	RGU_RESET_EXT_STAT55_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RGU_RESET_EXT_STAT55_RESERVED_Msk = 0xfffffff8
)

// Constants for WWDT: Windowed Watchdog timer (WWDT)
const (
	// MOD: Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.
	// Position of WDEN field.
	WWDT_MOD_WDEN_Pos = 0x0
	// Bit mask of WDEN field.
	WWDT_MOD_WDEN_Msk = 0x1
	// Bit WDEN.
	WWDT_MOD_WDEN = 0x1
	// The watchdog timer is stopped.
	WWDT_MOD_WDEN_WWDTSTOPPED = 0x0
	// The watchdog timer is running.
	WWDT_MOD_WDEN_WWDTRUN = 0x1
	// Position of WDRESET field.
	WWDT_MOD_WDRESET_Pos = 0x1
	// Bit mask of WDRESET field.
	WWDT_MOD_WDRESET_Msk = 0x2
	// Bit WDRESET.
	WWDT_MOD_WDRESET = 0x2
	// A watchdog time-out will not cause a chip reset.
	WWDT_MOD_WDRESET_WWDTINT = 0x0
	// A watchdog time-out will cause a chip reset.
	WWDT_MOD_WDRESET_WWDTRESET = 0x1
	// Position of WDTOF field.
	WWDT_MOD_WDTOF_Pos = 0x2
	// Bit mask of WDTOF field.
	WWDT_MOD_WDTOF_Msk = 0x4
	// Bit WDTOF.
	WWDT_MOD_WDTOF = 0x4
	// Position of WDINT field.
	WWDT_MOD_WDINT_Pos = 0x3
	// Bit mask of WDINT field.
	WWDT_MOD_WDINT_Msk = 0x8
	// Bit WDINT.
	WWDT_MOD_WDINT = 0x8
	// Position of WDPROTECT field.
	WWDT_MOD_WDPROTECT_Pos = 0x4
	// Bit mask of WDPROTECT field.
	WWDT_MOD_WDPROTECT_Msk = 0x10
	// Bit WDPROTECT.
	WWDT_MOD_WDPROTECT = 0x10
	// The watchdog time-out value (WDTC) can be changed at any time.
	WWDT_MOD_WDPROTECT_NO_LOCK = 0x0
	// The watchdog time-out value (WDTC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW.
	WWDT_MOD_WDPROTECT_LOCK = 0x1
	// Position of RESERVED field.
	WWDT_MOD_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	WWDT_MOD_RESERVED_Msk = 0xe0

	// TC: Watchdog timer constant register. This register determines the time-out value.
	// Position of WDTC field.
	WWDT_TC_WDTC_Pos = 0x0
	// Bit mask of WDTC field.
	WWDT_TC_WDTC_Msk = 0xffffff
	// Position of RESERVED field.
	WWDT_TC_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	WWDT_TC_RESERVED_Msk = 0xff000000

	// FEED: Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.
	// Position of Feed field.
	WWDT_FEED_Feed_Pos = 0x0
	// Bit mask of Feed field.
	WWDT_FEED_Feed_Msk = 0xff

	// TV: Watchdog timer value register. This register reads out the current value of the Watchdog timer.
	// Position of Count field.
	WWDT_TV_Count_Pos = 0x0
	// Bit mask of Count field.
	WWDT_TV_Count_Msk = 0xffffff
	// Position of RESERVED field.
	WWDT_TV_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	WWDT_TV_RESERVED_Msk = 0xff000000

	// WARNINT: Watchdog warning interrupt register. This register contains the Watchdog warning interrupt compare value.
	// Position of WDWARNINT field.
	WWDT_WARNINT_WDWARNINT_Pos = 0x0
	// Bit mask of WDWARNINT field.
	WWDT_WARNINT_WDWARNINT_Msk = 0x3ff
	// Position of RESERVED field.
	WWDT_WARNINT_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	WWDT_WARNINT_RESERVED_Msk = 0xfffffc00

	// WINDOW: Watchdog timer window register. This register contains the Watchdog window value.
	// Position of WDWINDOW field.
	WWDT_WINDOW_WDWINDOW_Pos = 0x0
	// Bit mask of WDWINDOW field.
	WWDT_WINDOW_WDWINDOW_Msk = 0xffffff
	// Position of RESERVED field.
	WWDT_WINDOW_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	WWDT_WINDOW_RESERVED_Msk = 0xff000000
)

// Constants for USART0: USART0_2_3
const (
	// RBR: Receiver Buffer Register. Contains the next received character to be read (DLAB = 0).
	// Position of RBR field.
	USART_RBR_RBR_Pos = 0x0
	// Bit mask of RBR field.
	USART_RBR_RBR_Msk = 0xff
	// Position of RESERVED field.
	USART_RBR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_RBR_RESERVED_Msk = 0xffffff00

	// THR: Transmit Holding Register. The next character to be transmitted is written here (DLAB = 0).
	// Position of THR field.
	USART_THR_THR_Pos = 0x0
	// Bit mask of THR field.
	USART_THR_THR_Msk = 0xff
	// Position of RESERVED field.
	USART_THR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_THR_RESERVED_Msk = 0xffffff00

	// DLL: Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB = 1).
	// Position of DLLSB field.
	USART_DLL_DLLSB_Pos = 0x0
	// Bit mask of DLLSB field.
	USART_DLL_DLLSB_Msk = 0xff
	// Position of RESERVED field.
	USART_DLL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_DLL_RESERVED_Msk = 0xffffff00

	// DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB = 1).
	// Position of DLMSB field.
	USART_DLM_DLMSB_Pos = 0x0
	// Bit mask of DLMSB field.
	USART_DLM_DLMSB_Msk = 0xff
	// Position of RESERVED field.
	USART_DLM_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_DLM_RESERVED_Msk = 0xffffff00

	// IER: Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential USART interrupts (DLAB = 0).
	// Position of RBRIE field.
	USART_IER_RBRIE_Pos = 0x0
	// Bit mask of RBRIE field.
	USART_IER_RBRIE_Msk = 0x1
	// Bit RBRIE.
	USART_IER_RBRIE = 0x1
	// Disable. Disable the RDA interrupt.
	USART_IER_RBRIE_DISABLE = 0x0
	// Enable. Enable the RDA interrupt.
	USART_IER_RBRIE_ENABLE = 0x1
	// Position of THREIE field.
	USART_IER_THREIE_Pos = 0x1
	// Bit mask of THREIE field.
	USART_IER_THREIE_Msk = 0x2
	// Bit THREIE.
	USART_IER_THREIE = 0x2
	// Disable. Disable the THRE interrupt.
	USART_IER_THREIE_DISABLE = 0x0
	// Enable. Enable the THRE interrupt.
	USART_IER_THREIE_ENABLE = 0x1
	// Position of RXIE field.
	USART_IER_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	USART_IER_RXIE_Msk = 0x4
	// Bit RXIE.
	USART_IER_RXIE = 0x4
	// Disable. Disable the RX line status interrupts.
	USART_IER_RXIE_DISABLE = 0x0
	// Enable. Enable the RX line status interrupts.
	USART_IER_RXIE_ENABLE = 0x1
	// Position of RESERVED field.
	USART_IER_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USART_IER_RESERVED_Msk = 0x8
	// Bit RESERVED.
	USART_IER_RESERVED = 0x8
	// Position of RESERVED field.
	USART_IER_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USART_IER_RESERVED_Msk = 0x70
	// Position of RESERVED field.
	USART_IER_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	USART_IER_RESERVED_Msk = 0x80
	// Bit RESERVED.
	USART_IER_RESERVED = 0x80
	// Position of ABEOINTEN field.
	USART_IER_ABEOINTEN_Pos = 0x8
	// Bit mask of ABEOINTEN field.
	USART_IER_ABEOINTEN_Msk = 0x100
	// Bit ABEOINTEN.
	USART_IER_ABEOINTEN = 0x100
	// Disable. Disable end of auto-baud Interrupt.
	USART_IER_ABEOINTEN_DISABLE = 0x0
	// Enable. Enable end of auto-baud Interrupt.
	USART_IER_ABEOINTEN_ENABLE = 0x1
	// Position of ABTOINTEN field.
	USART_IER_ABTOINTEN_Pos = 0x9
	// Bit mask of ABTOINTEN field.
	USART_IER_ABTOINTEN_Msk = 0x200
	// Bit ABTOINTEN.
	USART_IER_ABTOINTEN = 0x200
	// Disable. Disable auto-baud time-out Interrupt.
	USART_IER_ABTOINTEN_DISABLE = 0x0
	// Enable. Enable auto-baud time-out Interrupt.
	USART_IER_ABTOINTEN_ENABLE = 0x1
	// Position of RESERVED field.
	USART_IER_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USART_IER_RESERVED_Msk = 0xfffffc00

	// IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
	// Position of INTSTATUS field.
	USART_IIR_INTSTATUS_Pos = 0x0
	// Bit mask of INTSTATUS field.
	USART_IIR_INTSTATUS_Msk = 0x1
	// Bit INTSTATUS.
	USART_IIR_INTSTATUS = 0x1
	// Interrupt pending. At least one interrupt is pending.
	USART_IIR_INTSTATUS_INTERRUPT_PENDING = 0x0
	// Not pending. No interrupt is pending.
	USART_IIR_INTSTATUS_NOT_PENDING = 0x1
	// Position of INTID field.
	USART_IIR_INTID_Pos = 0x1
	// Bit mask of INTID field.
	USART_IIR_INTID_Msk = 0xe
	// RLS. Priority 1 (highest). (Highest) Receive Line Status (RLS).
	USART_IIR_INTID_RLS = 0x3
	// RDA. Priority 2 - Receive Data Available (RDA).
	USART_IIR_INTID_RDA = 0x2
	// CTI. Priority 2 - Character Time-out Indicator (CTI).
	USART_IIR_INTID_CTI = 0x6
	// THRE. Priority 3 - THRE Interrupt.
	USART_IIR_INTID_THRE = 0x1
	// Position of RESERVED field.
	USART_IIR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USART_IIR_RESERVED_Msk = 0x30
	// Position of FIFOENABLE field.
	USART_IIR_FIFOENABLE_Pos = 0x6
	// Bit mask of FIFOENABLE field.
	USART_IIR_FIFOENABLE_Msk = 0xc0
	// Position of ABEOINT field.
	USART_IIR_ABEOINT_Pos = 0x8
	// Bit mask of ABEOINT field.
	USART_IIR_ABEOINT_Msk = 0x100
	// Bit ABEOINT.
	USART_IIR_ABEOINT = 0x100
	// Position of ABTOINT field.
	USART_IIR_ABTOINT_Pos = 0x9
	// Bit mask of ABTOINT field.
	USART_IIR_ABTOINT_Msk = 0x200
	// Bit ABTOINT.
	USART_IIR_ABTOINT = 0x200
	// Position of RESERVED field.
	USART_IIR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USART_IIR_RESERVED_Msk = 0xfffffc00

	// FCR: FIFO Control Register. Controls USART FIFO usage and modes.
	// Position of FIFOEN field.
	USART_FCR_FIFOEN_Pos = 0x0
	// Bit mask of FIFOEN field.
	USART_FCR_FIFOEN_Msk = 0x1
	// Bit FIFOEN.
	USART_FCR_FIFOEN = 0x1
	// Disabled. USART FIFOs are disabled. Must not be used in the application.
	USART_FCR_FIFOEN_DISABLED = 0x0
	// Enabled. Active high enable for both USART Rx and TX FIFOs and FCR[7:1] access. This bit must be set for proper USART operation. Any transition on this bit will automatically clear the USART FIFOs.
	USART_FCR_FIFOEN_ENABLED = 0x1
	// Position of RXFIFORES field.
	USART_FCR_RXFIFORES_Pos = 0x1
	// Bit mask of RXFIFORES field.
	USART_FCR_RXFIFORES_Msk = 0x2
	// Bit RXFIFORES.
	USART_FCR_RXFIFORES = 0x2
	// No effect. No impact on either of USART FIFOs.
	USART_FCR_RXFIFORES_NO_EFFECT = 0x0
	// Clear. Writing a logic 1 to FCR[1] will clear all bytes in USART Rx FIFO, reset the pointer logic. This bit is self-clearing.
	USART_FCR_RXFIFORES_CLEAR = 0x1
	// Position of TXFIFORES field.
	USART_FCR_TXFIFORES_Pos = 0x2
	// Bit mask of TXFIFORES field.
	USART_FCR_TXFIFORES_Msk = 0x4
	// Bit TXFIFORES.
	USART_FCR_TXFIFORES = 0x4
	// No effect. No impact on either of USART FIFOs.
	USART_FCR_TXFIFORES_NO_EFFECT = 0x0
	// Clear. Writing a logic 1 to FCR[2] will clear all bytes in USART TX FIFO, reset the pointer logic. This bit is self-clearing.
	USART_FCR_TXFIFORES_CLEAR = 0x1
	// Position of DMAMODE field.
	USART_FCR_DMAMODE_Pos = 0x3
	// Bit mask of DMAMODE field.
	USART_FCR_DMAMODE_Msk = 0x8
	// Bit DMAMODE.
	USART_FCR_DMAMODE = 0x8
	// Position of RESERVED field.
	USART_FCR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USART_FCR_RESERVED_Msk = 0x30
	// Position of RXTRIGLVL field.
	USART_FCR_RXTRIGLVL_Pos = 0x6
	// Bit mask of RXTRIGLVL field.
	USART_FCR_RXTRIGLVL_Msk = 0xc0
	// Level 0. Trigger level 0 (1 character or 0x01).
	USART_FCR_RXTRIGLVL_LEVEL_0 = 0x0
	// Level 1. Trigger level 1 (4 characters or 0x04).
	USART_FCR_RXTRIGLVL_LEVEL_1 = 0x1
	// Level 2. Trigger level 2 (8 characters or 0x08).
	USART_FCR_RXTRIGLVL_LEVEL_2 = 0x2
	// Level 3. Trigger level 3 (14 characters or 0x0E).
	USART_FCR_RXTRIGLVL_LEVEL_3 = 0x3
	// Position of RESERVED field.
	USART_FCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_FCR_RESERVED_Msk = 0xffffff00

	// LCR: Line Control Register. Contains controls for frame formatting and break generation.
	// Position of WLS field.
	USART_LCR_WLS_Pos = 0x0
	// Bit mask of WLS field.
	USART_LCR_WLS_Msk = 0x3
	// 5-bit character length.
	USART_LCR_WLS_5_BIT_CHARACTER_LENG = 0x0
	// 6-bit character length.
	USART_LCR_WLS_6_BIT_CHARACTER_LENG = 0x1
	// 7-bit character length.
	USART_LCR_WLS_7_BIT_CHARACTER_LENG = 0x2
	// 8-bit character length.
	USART_LCR_WLS_8_BIT_CHARACTER_LENG = 0x3
	// Position of SBS field.
	USART_LCR_SBS_Pos = 0x2
	// Bit mask of SBS field.
	USART_LCR_SBS_Msk = 0x4
	// Bit SBS.
	USART_LCR_SBS = 0x4
	// 1 stop bit.
	USART_LCR_SBS_1_STOP_BIT = 0x0
	// 2 stop bits (1.5 if LCR[1:0]=00).
	USART_LCR_SBS_2_STOP_BITS_1 = 0x1
	// Position of PE field.
	USART_LCR_PE_Pos = 0x3
	// Bit mask of PE field.
	USART_LCR_PE_Msk = 0x8
	// Bit PE.
	USART_LCR_PE = 0x8
	// Disable parity generation and checking.
	USART_LCR_PE_DISABLE_PARITY_GENER = 0x0
	// Enable parity generation and checking.
	USART_LCR_PE_ENABLE_PARITY_GENERA = 0x1
	// Position of PS field.
	USART_LCR_PS_Pos = 0x4
	// Bit mask of PS field.
	USART_LCR_PS_Msk = 0x30
	// Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd.
	USART_LCR_PS_ODD_PARITY = 0x0
	// Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even.
	USART_LCR_PS_EVEN_PARITY = 0x1
	// Force HIGH. Forced 1 stick parity.
	USART_LCR_PS_FORCE_HIGH = 0x2
	// Force LOW. Forced 0 stick parity.
	USART_LCR_PS_FORCE_LOW = 0x3
	// Position of BC field.
	USART_LCR_BC_Pos = 0x6
	// Bit mask of BC field.
	USART_LCR_BC_Msk = 0x40
	// Bit BC.
	USART_LCR_BC = 0x40
	// Disabled. Disable break transmission.
	USART_LCR_BC_DISABLED = 0x0
	// Enabled. Enable break transmission. Output pin USART TXD is forced to logic 0 when LCR[6] is active high.
	USART_LCR_BC_ENABLED = 0x1
	// Position of DLAB field.
	USART_LCR_DLAB_Pos = 0x7
	// Bit mask of DLAB field.
	USART_LCR_DLAB_Msk = 0x80
	// Bit DLAB.
	USART_LCR_DLAB = 0x80
	// Disabled. Disable access to Divisor Latches.
	USART_LCR_DLAB_DISABLED = 0x0
	// Enabled. Enable access to Divisor Latches.
	USART_LCR_DLAB_ENABLED = 0x1
	// Position of RESERVED field.
	USART_LCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_LCR_RESERVED_Msk = 0xffffff00

	// LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
	// Position of RDR field.
	USART_LSR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	USART_LSR_RDR_Msk = 0x1
	// Bit RDR.
	USART_LSR_RDR = 0x1
	// Empty. RBR is empty.
	USART_LSR_RDR_EMPTY = 0x0
	// Data. RBR contains valid data.
	USART_LSR_RDR_DATA = 0x1
	// Position of OE field.
	USART_LSR_OE_Pos = 0x1
	// Bit mask of OE field.
	USART_LSR_OE_Msk = 0x2
	// Bit OE.
	USART_LSR_OE = 0x2
	// Inactive. Overrun error status is inactive.
	USART_LSR_OE_INACTIVE = 0x0
	// Active. Overrun error status is active.
	USART_LSR_OE_ACTIVE = 0x1
	// Position of PE field.
	USART_LSR_PE_Pos = 0x2
	// Bit mask of PE field.
	USART_LSR_PE_Msk = 0x4
	// Bit PE.
	USART_LSR_PE = 0x4
	// Inactive. Parity error status is inactive.
	USART_LSR_PE_INACTIVE = 0x0
	// Active. Parity error status is active.
	USART_LSR_PE_ACTIVE = 0x1
	// Position of FE field.
	USART_LSR_FE_Pos = 0x3
	// Bit mask of FE field.
	USART_LSR_FE_Msk = 0x8
	// Bit FE.
	USART_LSR_FE = 0x8
	// Inactive. Framing error status is inactive.
	USART_LSR_FE_INACTIVE = 0x0
	// Active. Framing error status is active.
	USART_LSR_FE_ACTIVE = 0x1
	// Position of BI field.
	USART_LSR_BI_Pos = 0x4
	// Bit mask of BI field.
	USART_LSR_BI_Msk = 0x10
	// Bit BI.
	USART_LSR_BI = 0x10
	// Inactive. Break interrupt status is inactive.
	USART_LSR_BI_INACTIVE = 0x0
	// Active. Break interrupt status is active.
	USART_LSR_BI_ACTIVE = 0x1
	// Position of THRE field.
	USART_LSR_THRE_Pos = 0x5
	// Bit mask of THRE field.
	USART_LSR_THRE_Msk = 0x20
	// Bit THRE.
	USART_LSR_THRE = 0x20
	// Not empty. THR contains valid data.
	USART_LSR_THRE_NOT_EMPTY = 0x0
	// Empty. THR is empty.
	USART_LSR_THRE_EMPTY = 0x1
	// Position of TEMT field.
	USART_LSR_TEMT_Pos = 0x6
	// Bit mask of TEMT field.
	USART_LSR_TEMT_Msk = 0x40
	// Bit TEMT.
	USART_LSR_TEMT = 0x40
	// Not empty. THR and/or the TSR contains valid data.
	USART_LSR_TEMT_NOT_EMPTY = 0x0
	// Empty. THR and the TSR are empty.
	USART_LSR_TEMT_EMPTY = 0x1
	// Position of RXFE field.
	USART_LSR_RXFE_Pos = 0x7
	// Bit mask of RXFE field.
	USART_LSR_RXFE_Msk = 0x80
	// Bit RXFE.
	USART_LSR_RXFE = 0x80
	// No error. RBR contains no USART RX errors or FCR[0]=0.
	USART_LSR_RXFE_NO_ERROR = 0x0
	// Error. USART RBR contains at least one USART RX error.
	USART_LSR_RXFE_ERROR = 0x1
	// Position of TXERR field.
	USART_LSR_TXERR_Pos = 0x8
	// Bit mask of TXERR field.
	USART_LSR_TXERR_Msk = 0x100
	// Bit TXERR.
	USART_LSR_TXERR = 0x100
	// No error. No error (normal default condition).
	USART_LSR_TXERR_NO_ERROR = 0x0
	// NACK. A NACK response is received during Smart card T=0 operation.
	USART_LSR_TXERR_NACK = 0x1
	// Position of RESERVED field.
	USART_LSR_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USART_LSR_RESERVED_Msk = 0xfffffe00

	// SCR: Scratch Pad Register. Eight-bit temporary storage for software.
	// Position of PAD field.
	USART_SCR_PAD_Pos = 0x0
	// Bit mask of PAD field.
	USART_SCR_PAD_Msk = 0xff
	// Position of RESERVED field.
	USART_SCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_SCR_RESERVED_Msk = 0xffffff00

	// ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
	// Position of START field.
	USART_ACR_START_Pos = 0x0
	// Bit mask of START field.
	USART_ACR_START_Msk = 0x1
	// Bit START.
	USART_ACR_START = 0x1
	// Stop. Auto-baud stop (auto-baud is not running).
	USART_ACR_START_STOP = 0x0
	// Start. Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion.
	USART_ACR_START_START = 0x1
	// Position of MODE field.
	USART_ACR_MODE_Pos = 0x1
	// Bit mask of MODE field.
	USART_ACR_MODE_Msk = 0x2
	// Bit MODE.
	USART_ACR_MODE = 0x2
	// Mode 0.
	USART_ACR_MODE_MODE_0 = 0x0
	// Mode 1.
	USART_ACR_MODE_MODE_1 = 0x1
	// Position of AUTORESTART field.
	USART_ACR_AUTORESTART_Pos = 0x2
	// Bit mask of AUTORESTART field.
	USART_ACR_AUTORESTART_Msk = 0x4
	// Bit AUTORESTART.
	USART_ACR_AUTORESTART = 0x4
	// No restart.
	USART_ACR_AUTORESTART_NO_RESTART = 0x0
	// Restart. Restart in case of time-out (counter restarts at next USART Rx falling edge)
	USART_ACR_AUTORESTART_RESTART = 0x1
	// Position of RESERVED field.
	USART_ACR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USART_ACR_RESERVED_Msk = 0xf8
	// Position of ABEOINTCLR field.
	USART_ACR_ABEOINTCLR_Pos = 0x8
	// Bit mask of ABEOINTCLR field.
	USART_ACR_ABEOINTCLR_Msk = 0x100
	// Bit ABEOINTCLR.
	USART_ACR_ABEOINTCLR = 0x100
	// No effect. Writing a 0 has no impact.
	USART_ACR_ABEOINTCLR_NO_EFFECT = 0x0
	// Clear. Writing a 1 will clear the corresponding interrupt in the IIR.
	USART_ACR_ABEOINTCLR_CLEAR = 0x1
	// Position of ABTOINTCLR field.
	USART_ACR_ABTOINTCLR_Pos = 0x9
	// Bit mask of ABTOINTCLR field.
	USART_ACR_ABTOINTCLR_Msk = 0x200
	// Bit ABTOINTCLR.
	USART_ACR_ABTOINTCLR = 0x200
	// No effect. Writing a 0 has no impact.
	USART_ACR_ABTOINTCLR_NO_EFFECT = 0x0
	// Clear. Writing a 1 will clear the corresponding interrupt in the IIR.
	USART_ACR_ABTOINTCLR_CLEAR = 0x1
	// Position of RESERVED field.
	USART_ACR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USART_ACR_RESERVED_Msk = 0xfffffc00

	// ICR: IrDA control register (USART3 only)
	// Position of IRDAEN field.
	USART_ICR_IRDAEN_Pos = 0x0
	// Bit mask of IRDAEN field.
	USART_ICR_IRDAEN_Msk = 0x1
	// Bit IRDAEN.
	USART_ICR_IRDAEN = 0x1
	// Disabled. IrDA mode on USART3 is disabled, USART3 acts as a standard USART.
	USART_ICR_IRDAEN_DISABLED = 0x0
	// Enabled. IrDA mode on USART3 is enabled.
	USART_ICR_IRDAEN_ENABLED = 0x1
	// Position of IRDAINV field.
	USART_ICR_IRDAINV_Pos = 0x1
	// Bit mask of IRDAINV field.
	USART_ICR_IRDAINV_Msk = 0x2
	// Bit IRDAINV.
	USART_ICR_IRDAINV = 0x2
	// Not inverted. The serial input is not inverted.
	USART_ICR_IRDAINV_NOT_INVERTED = 0x0
	// Inverted. The serial input is inverted. This has no effect on the serial output.
	USART_ICR_IRDAINV_INVERTED = 0x1
	// Position of FIXPULSEEN field.
	USART_ICR_FIXPULSEEN_Pos = 0x2
	// Bit mask of FIXPULSEEN field.
	USART_ICR_FIXPULSEEN_Msk = 0x4
	// Bit FIXPULSEEN.
	USART_ICR_FIXPULSEEN = 0x4
	// Disabled. IrDA fixed pulse width mode disabled.
	USART_ICR_FIXPULSEEN_DISABLED = 0x0
	// Enabled. IrDA fixed pulse width mode enabled.
	USART_ICR_FIXPULSEEN_ENABLED = 0x1
	// Position of PULSEDIV field.
	USART_ICR_PULSEDIV_Pos = 0x3
	// Bit mask of PULSEDIV field.
	USART_ICR_PULSEDIV_Msk = 0x38
	// Position of RESERVED field.
	USART_ICR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USART_ICR_RESERVED_Msk = 0xffffffc0

	// FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
	// Position of DIVADDVAL field.
	USART_FDR_DIVADDVAL_Pos = 0x0
	// Bit mask of DIVADDVAL field.
	USART_FDR_DIVADDVAL_Msk = 0xf
	// Position of MULVAL field.
	USART_FDR_MULVAL_Pos = 0x4
	// Bit mask of MULVAL field.
	USART_FDR_MULVAL_Msk = 0xf0
	// Position of RESERVED field.
	USART_FDR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_FDR_RESERVED_Msk = 0xffffff00

	// OSR: Oversampling Register. Controls the degree of oversampling during each bit time.
	// Position of RESERVED field.
	USART_OSR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USART_OSR_RESERVED_Msk = 0x1
	// Bit RESERVED.
	USART_OSR_RESERVED = 0x1
	// Position of OSFRAC field.
	USART_OSR_OSFRAC_Pos = 0x1
	// Bit mask of OSFRAC field.
	USART_OSR_OSFRAC_Msk = 0xe
	// Position of OSINT field.
	USART_OSR_OSINT_Pos = 0x4
	// Bit mask of OSINT field.
	USART_OSR_OSINT_Msk = 0xf0
	// Position of FDINT field.
	USART_OSR_FDINT_Pos = 0x8
	// Bit mask of FDINT field.
	USART_OSR_FDINT_Msk = 0x7f00
	// Position of RESERVED field.
	USART_OSR_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	USART_OSR_RESERVED_Msk = 0xffff8000

	// HDEN: Half-duplex enable Register
	// Position of HDEN field.
	USART_HDEN_HDEN_Pos = 0x0
	// Bit mask of HDEN field.
	USART_HDEN_HDEN_Msk = 0x1
	// Bit HDEN.
	USART_HDEN_HDEN = 0x1
	// Disabled. Disable half-duplex mode.
	USART_HDEN_HDEN_DISABLED = 0x0
	// Enabled. Enable half-duplex mode.
	USART_HDEN_HDEN_ENABLED = 0x1
	// Position of RESERVED field.
	USART_HDEN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	USART_HDEN_RESERVED_Msk = 0xfffffffe

	// SCICTRL: Smart card interface control register
	// Position of SCIEN field.
	USART_SCICTRL_SCIEN_Pos = 0x0
	// Bit mask of SCIEN field.
	USART_SCICTRL_SCIEN_Msk = 0x1
	// Bit SCIEN.
	USART_SCICTRL_SCIEN = 0x1
	// Disabled. Smart card interface disabled.
	USART_SCICTRL_SCIEN_DISABLED = 0x0
	// Enabled. synchronous half duplex smart card interface is enabled.
	USART_SCICTRL_SCIEN_ENABLED = 0x1
	// Position of NACKDIS field.
	USART_SCICTRL_NACKDIS_Pos = 0x1
	// Bit mask of NACKDIS field.
	USART_SCICTRL_NACKDIS_Msk = 0x2
	// Bit NACKDIS.
	USART_SCICTRL_NACKDIS = 0x2
	// Enabled. A NACK response is enabled.
	USART_SCICTRL_NACKDIS_ENABLED = 0x0
	// Disabled. A NACK response is inhibited.
	USART_SCICTRL_NACKDIS_DISABLED = 0x1
	// Position of PROTSEL field.
	USART_SCICTRL_PROTSEL_Pos = 0x2
	// Bit mask of PROTSEL field.
	USART_SCICTRL_PROTSEL_Msk = 0x4
	// Bit PROTSEL.
	USART_SCICTRL_PROTSEL = 0x4
	// T = 0
	USART_SCICTRL_PROTSEL_T_EQ_0 = 0x0
	// T = 1
	USART_SCICTRL_PROTSEL_T_EQ_1 = 0x1
	// Position of RESERVED field.
	USART_SCICTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USART_SCICTRL_RESERVED_Msk = 0x18
	// Position of TXRETRY field.
	USART_SCICTRL_TXRETRY_Pos = 0x5
	// Bit mask of TXRETRY field.
	USART_SCICTRL_TXRETRY_Msk = 0xe0
	// Position of GUARDTIME field.
	USART_SCICTRL_GUARDTIME_Pos = 0x8
	// Bit mask of GUARDTIME field.
	USART_SCICTRL_GUARDTIME_Msk = 0xff00
	// Position of RESERVED field.
	USART_SCICTRL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USART_SCICTRL_RESERVED_Msk = 0xffff0000

	// RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
	// Position of NMMEN field.
	USART_RS485CTRL_NMMEN_Pos = 0x0
	// Bit mask of NMMEN field.
	USART_RS485CTRL_NMMEN_Msk = 0x1
	// Bit NMMEN.
	USART_RS485CTRL_NMMEN = 0x1
	// Disabled. RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled.
	USART_RS485CTRL_NMMEN_DISABLED = 0x0
	// Enabled. RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the USART to set the parity error and generate an interrupt.
	USART_RS485CTRL_NMMEN_ENABLED = 0x1
	// Position of RXDIS field.
	USART_RS485CTRL_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	USART_RS485CTRL_RXDIS_Msk = 0x2
	// Bit RXDIS.
	USART_RS485CTRL_RXDIS = 0x2
	// Enabled. The receiver is enabled.
	USART_RS485CTRL_RXDIS_ENABLED = 0x0
	// Disabled.The receiver is disabled.
	USART_RS485CTRL_RXDIS_DISABLED = 0x1
	// Position of AADEN field.
	USART_RS485CTRL_AADEN_Pos = 0x2
	// Bit mask of AADEN field.
	USART_RS485CTRL_AADEN_Msk = 0x4
	// Bit AADEN.
	USART_RS485CTRL_AADEN = 0x4
	// Disabled. Auto Address Detect (AAD) is disabled.
	USART_RS485CTRL_AADEN_DISABLED = 0x0
	// Enabled. Auto Address Detect (AAD) is enabled.
	USART_RS485CTRL_AADEN_ENABLED = 0x1
	// Position of RESERVED field.
	USART_RS485CTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USART_RS485CTRL_RESERVED_Msk = 0x8
	// Bit RESERVED.
	USART_RS485CTRL_RESERVED = 0x8
	// Position of DCTRL field.
	USART_RS485CTRL_DCTRL_Pos = 0x4
	// Bit mask of DCTRL field.
	USART_RS485CTRL_DCTRL_Msk = 0x10
	// Bit DCTRL.
	USART_RS485CTRL_DCTRL = 0x10
	// Disabled. Disable Auto Direction Control.
	USART_RS485CTRL_DCTRL_DISABLED = 0x0
	// Enabled. Enable Auto Direction Control.
	USART_RS485CTRL_DCTRL_ENABLED = 0x1
	// Position of OINV field.
	USART_RS485CTRL_OINV_Pos = 0x5
	// Bit mask of OINV field.
	USART_RS485CTRL_OINV_Msk = 0x20
	// Bit OINV.
	USART_RS485CTRL_OINV = 0x20
	// Low. The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted.
	USART_RS485CTRL_OINV_LOW = 0x0
	// High. The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted.
	USART_RS485CTRL_OINV_HIGH = 0x1
	// Position of RESERVED field.
	USART_RS485CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USART_RS485CTRL_RESERVED_Msk = 0xffffffc0

	// RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
	// Position of ADRMATCH field.
	USART_RS485ADRMATCH_ADRMATCH_Pos = 0x0
	// Bit mask of ADRMATCH field.
	USART_RS485ADRMATCH_ADRMATCH_Msk = 0xff
	// Position of RESERVED field.
	USART_RS485ADRMATCH_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_RS485ADRMATCH_RESERVED_Msk = 0xffffff00

	// RS485DLY: RS-485/EIA-485 direction control delay.
	// Position of DLY field.
	USART_RS485DLY_DLY_Pos = 0x0
	// Bit mask of DLY field.
	USART_RS485DLY_DLY_Msk = 0xff
	// Position of RESERVED field.
	USART_RS485DLY_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USART_RS485DLY_RESERVED_Msk = 0xffffff00

	// SYNCCTRL: Synchronous mode control register.
	// Position of SYNC field.
	USART_SYNCCTRL_SYNC_Pos = 0x0
	// Bit mask of SYNC field.
	USART_SYNCCTRL_SYNC_Msk = 0x1
	// Bit SYNC.
	USART_SYNCCTRL_SYNC = 0x1
	// Disabled.
	USART_SYNCCTRL_SYNC_DISABLED = 0x0
	// Enabled.
	USART_SYNCCTRL_SYNC_ENABLED = 0x1
	// Position of CSRC field.
	USART_SYNCCTRL_CSRC_Pos = 0x1
	// Bit mask of CSRC field.
	USART_SYNCCTRL_CSRC_Msk = 0x2
	// Bit CSRC.
	USART_SYNCCTRL_CSRC = 0x2
	// Slave mode. Synchronous slave mode (SCLK in)
	USART_SYNCCTRL_CSRC_SLAVE_MODE = 0x0
	// Master mode. Synchronous master mode (SCLK out)
	USART_SYNCCTRL_CSRC_MASTER_MODE = 0x1
	// Position of FES field.
	USART_SYNCCTRL_FES_Pos = 0x2
	// Bit mask of FES field.
	USART_SYNCCTRL_FES_Msk = 0x4
	// Bit FES.
	USART_SYNCCTRL_FES = 0x4
	// Rising. RxD is sampled on the rising edge of SCLK.
	USART_SYNCCTRL_FES_RISING = 0x0
	// Falling. RxD is sampled on the falling edge of SCLK.
	USART_SYNCCTRL_FES_FALLING = 0x1
	// Position of TSBYPASS field.
	USART_SYNCCTRL_TSBYPASS_Pos = 0x3
	// Bit mask of TSBYPASS field.
	USART_SYNCCTRL_TSBYPASS_Msk = 0x8
	// Bit TSBYPASS.
	USART_SYNCCTRL_TSBYPASS = 0x8
	// Synchronized. The input clock is synchronized prior to being used in clock edge detection logic.
	USART_SYNCCTRL_TSBYPASS_SYNCHRONIZED = 0x0
	// Not synchronized. The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability.
	USART_SYNCCTRL_TSBYPASS_NOT_SYNCHRONIZED = 0x1
	// Position of CSCEN field.
	USART_SYNCCTRL_CSCEN_Pos = 0x4
	// Bit mask of CSCEN field.
	USART_SYNCCTRL_CSCEN_Msk = 0x10
	// Bit CSCEN.
	USART_SYNCCTRL_CSCEN = 0x10
	// On character. SCLK cycles only when characters are being sent on TxD.
	USART_SYNCCTRL_CSCEN_ON_CHARACTER = 0x0
	// Continuously. SCLK runs continuously (characters can be received on RxD independently from transmission on TxD).
	USART_SYNCCTRL_CSCEN_CONTINUOUSLY = 0x1
	// Position of SSSDIS field.
	USART_SYNCCTRL_SSSDIS_Pos = 0x5
	// Bit mask of SSSDIS field.
	USART_SYNCCTRL_SSSDIS_Msk = 0x20
	// Bit SSSDIS.
	USART_SYNCCTRL_SSSDIS = 0x20
	// Send. Send start and stop bits as in other modes.
	USART_SYNCCTRL_SSSDIS_SEND = 0x0
	// Do not send. Do not send start/stop bits.
	USART_SYNCCTRL_SSSDIS_DO_NOT_SEND = 0x1
	// Position of CCCLR field.
	USART_SYNCCTRL_CCCLR_Pos = 0x6
	// Bit mask of CCCLR field.
	USART_SYNCCTRL_CCCLR_Msk = 0x40
	// Bit CCCLR.
	USART_SYNCCTRL_CCCLR = 0x40
	// Software. CSCEN is under software control.
	USART_SYNCCTRL_CCCLR_SOFTWARE = 0x0
	// Hardware. Hardware clears CSCEN after each character is received.
	USART_SYNCCTRL_CCCLR_HARDWARE = 0x1
	// Position of RESERVED field.
	USART_SYNCCTRL_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	USART_SYNCCTRL_RESERVED_Msk = 0xffffff80

	// TER: Transmit Enable Register. Turns off USART transmitter for use with software flow control.
	// Position of TXEN field.
	USART_TER_TXEN_Pos = 0x0
	// Bit mask of TXEN field.
	USART_TER_TXEN_Msk = 0x1
	// Bit TXEN.
	USART_TER_TXEN = 0x1
	// Position of RESERVED field.
	USART_TER_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	USART_TER_RESERVED_Msk = 0xfffffffe
)

// Constants for UART1: UART1
const (
	// RBR: Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)
	// Position of RBR field.
	UART1_RBR_RBR_Pos = 0x0
	// Bit mask of RBR field.
	UART1_RBR_RBR_Msk = 0xff
	// Position of RESERVED field.
	UART1_RBR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_RBR_RESERVED_Msk = 0xffffff00

	// THR: Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0)
	// Position of THR field.
	UART1_THR_THR_Pos = 0x0
	// Bit mask of THR field.
	UART1_THR_THR_Msk = 0xff
	// Position of RESERVED field.
	UART1_THR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_THR_RESERVED_Msk = 0xffffff00

	// DLL: Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
	// Position of DLLSB field.
	UART1_DLL_DLLSB_Pos = 0x0
	// Bit mask of DLLSB field.
	UART1_DLL_DLLSB_Msk = 0xff
	// Position of RESERVED field.
	UART1_DLL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_DLL_RESERVED_Msk = 0xffffff00

	// DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider.(DLAB=1)
	// Position of DLMSB field.
	UART1_DLM_DLMSB_Pos = 0x0
	// Bit mask of DLMSB field.
	UART1_DLM_DLMSB_Msk = 0xff
	// Position of RESERVED field.
	UART1_DLM_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_DLM_RESERVED_Msk = 0xffffff00

	// IER: Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART1 interrupts. (DLAB=0)
	// Position of RBRIE field.
	UART1_IER_RBRIE_Pos = 0x0
	// Bit mask of RBRIE field.
	UART1_IER_RBRIE_Msk = 0x1
	// Bit RBRIE.
	UART1_IER_RBRIE = 0x1
	// Disable. Disable the RDA interrupts.
	UART1_IER_RBRIE_DISABLE = 0x0
	// Enable. Enable the RDA interrupts.
	UART1_IER_RBRIE_ENABLE = 0x1
	// Position of THREIE field.
	UART1_IER_THREIE_Pos = 0x1
	// Bit mask of THREIE field.
	UART1_IER_THREIE_Msk = 0x2
	// Bit THREIE.
	UART1_IER_THREIE = 0x2
	// Disable. Disable the THRE interrupts.
	UART1_IER_THREIE_DISABLE = 0x0
	// Enable. Enable the THRE interrupts.
	UART1_IER_THREIE_ENABLE = 0x1
	// Position of RXIE field.
	UART1_IER_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	UART1_IER_RXIE_Msk = 0x4
	// Bit RXIE.
	UART1_IER_RXIE = 0x4
	// Disable. Disable the RX line status interrupts.
	UART1_IER_RXIE_DISABLE = 0x0
	// Enable. Enable the RX line status interrupts.
	UART1_IER_RXIE_ENABLE = 0x1
	// Position of MSIE field.
	UART1_IER_MSIE_Pos = 0x3
	// Bit mask of MSIE field.
	UART1_IER_MSIE_Msk = 0x8
	// Bit MSIE.
	UART1_IER_MSIE = 0x8
	// Disable. Disable the modem interrupt.
	UART1_IER_MSIE_DISABLE = 0x0
	// Enable. Enable the modem interrupt.
	UART1_IER_MSIE_ENABLE = 0x1
	// Position of RESERVED field.
	UART1_IER_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART1_IER_RESERVED_Msk = 0x70
	// Position of CTSIE field.
	UART1_IER_CTSIE_Pos = 0x7
	// Bit mask of CTSIE field.
	UART1_IER_CTSIE_Msk = 0x80
	// Bit CTSIE.
	UART1_IER_CTSIE = 0x80
	// Disable. Disable the CTS interrupt.
	UART1_IER_CTSIE_DISABLE = 0x0
	// Enable. Enable the CTS interrupt.
	UART1_IER_CTSIE_ENABLE = 0x1
	// Position of ABEOIE field.
	UART1_IER_ABEOIE_Pos = 0x8
	// Bit mask of ABEOIE field.
	UART1_IER_ABEOIE_Msk = 0x100
	// Bit ABEOIE.
	UART1_IER_ABEOIE = 0x100
	// Disable. Disable end of auto-baud Interrupt.
	UART1_IER_ABEOIE_DISABLE = 0x0
	// Enable. Enable end of auto-baud Interrupt.
	UART1_IER_ABEOIE_ENABLE = 0x1
	// Position of ABTOIE field.
	UART1_IER_ABTOIE_Pos = 0x9
	// Bit mask of ABTOIE field.
	UART1_IER_ABTOIE_Msk = 0x200
	// Bit ABTOIE.
	UART1_IER_ABTOIE = 0x200
	// Disable. Disable auto-baud time-out Interrupt.
	UART1_IER_ABTOIE_DISABLE = 0x0
	// Enable. Enable auto-baud time-out Interrupt.
	UART1_IER_ABTOIE_ENABLE = 0x1
	// Position of RESERVED field.
	UART1_IER_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART1_IER_RESERVED_Msk = 0xfffffc00

	// IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
	// Position of INTSTATUS field.
	UART1_IIR_INTSTATUS_Pos = 0x0
	// Bit mask of INTSTATUS field.
	UART1_IIR_INTSTATUS_Msk = 0x1
	// Bit INTSTATUS.
	UART1_IIR_INTSTATUS = 0x1
	// Interrupt pending. At least one interrupt is pending.
	UART1_IIR_INTSTATUS_INTERRUPT_PENDING = 0x0
	// Not pending. No interrupt is pending.
	UART1_IIR_INTSTATUS_NOT_PENDING = 0x1
	// Position of INTID field.
	UART1_IIR_INTID_Pos = 0x1
	// Bit mask of INTID field.
	UART1_IIR_INTID_Msk = 0xe
	// RLS. Priority 1 (highest). (Highest) Receive Line Status (RLS).
	UART1_IIR_INTID_RLS = 0x3
	// RDA. Priority 2 - Receive Data Available (RDA).
	UART1_IIR_INTID_RDA = 0x2
	// CTI. Priority 2 - Character Time-out Indicator (CTI).
	UART1_IIR_INTID_CTI = 0x6
	// THRE. Priority 3 - THRE Interrupt.
	UART1_IIR_INTID_THRE = 0x1
	// Position of RESERVED field.
	UART1_IIR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART1_IIR_RESERVED_Msk = 0x30
	// Position of FIFOENABLE field.
	UART1_IIR_FIFOENABLE_Pos = 0x6
	// Bit mask of FIFOENABLE field.
	UART1_IIR_FIFOENABLE_Msk = 0xc0
	// Position of ABEOINT field.
	UART1_IIR_ABEOINT_Pos = 0x8
	// Bit mask of ABEOINT field.
	UART1_IIR_ABEOINT_Msk = 0x100
	// Bit ABEOINT.
	UART1_IIR_ABEOINT = 0x100
	// Position of ABTOINT field.
	UART1_IIR_ABTOINT_Pos = 0x9
	// Bit mask of ABTOINT field.
	UART1_IIR_ABTOINT_Msk = 0x200
	// Bit ABTOINT.
	UART1_IIR_ABTOINT = 0x200
	// Position of RESERVED field.
	UART1_IIR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART1_IIR_RESERVED_Msk = 0xfffffc00

	// FCR: FIFO Control Register. Controls UART1 FIFO usage and modes.
	// Position of FIFOEN field.
	UART1_FCR_FIFOEN_Pos = 0x0
	// Bit mask of FIFOEN field.
	UART1_FCR_FIFOEN_Msk = 0x1
	// Bit FIFOEN.
	UART1_FCR_FIFOEN = 0x1
	// Disabled. Must not be used in the application.
	UART1_FCR_FIFOEN_DISABLED = 0x0
	// Enabled. Active high enable for both UART1 Rx and TX FIFOs and FCR[7:1] access. This bit must be set for proper UART1 operation. Any transition on this bit will automatically clear the UART1 FIFOs.
	UART1_FCR_FIFOEN_ENABLED = 0x1
	// Position of RXFIFORES field.
	UART1_FCR_RXFIFORES_Pos = 0x1
	// Bit mask of RXFIFORES field.
	UART1_FCR_RXFIFORES_Msk = 0x2
	// Bit RXFIFORES.
	UART1_FCR_RXFIFORES = 0x2
	// No effect. No impact on either of UART1 FIFOs.
	UART1_FCR_RXFIFORES_NO_EFFECT = 0x0
	// Clear. Writing a logic 1 to FCR[1] will clear all bytes in UART1 Rx FIFO, reset the pointer logic. This bit is self-clearing.
	UART1_FCR_RXFIFORES_CLEAR = 0x1
	// Position of TXFIFORES field.
	UART1_FCR_TXFIFORES_Pos = 0x2
	// Bit mask of TXFIFORES field.
	UART1_FCR_TXFIFORES_Msk = 0x4
	// Bit TXFIFORES.
	UART1_FCR_TXFIFORES = 0x4
	// No effect. No impact on either of UART1 FIFOs.
	UART1_FCR_TXFIFORES_NO_EFFECT = 0x0
	// Clear. Writing a logic 1 to FCR[2] will clear all bytes in UART1 TX FIFO, reset the pointer logic. This bit is self-clearing.
	UART1_FCR_TXFIFORES_CLEAR = 0x1
	// Position of DMAMODE field.
	UART1_FCR_DMAMODE_Pos = 0x3
	// Bit mask of DMAMODE field.
	UART1_FCR_DMAMODE_Msk = 0x8
	// Bit DMAMODE.
	UART1_FCR_DMAMODE = 0x8
	// Position of RESERVED field.
	UART1_FCR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART1_FCR_RESERVED_Msk = 0x30
	// Position of RXTRIGLVL field.
	UART1_FCR_RXTRIGLVL_Pos = 0x6
	// Bit mask of RXTRIGLVL field.
	UART1_FCR_RXTRIGLVL_Msk = 0xc0
	// Level 0. Trigger level 0 (1 character or 0x01).
	UART1_FCR_RXTRIGLVL_LEVEL_0 = 0x0
	// Level 1. Trigger level 1 (4 characters or 0x04).
	UART1_FCR_RXTRIGLVL_LEVEL_1 = 0x1
	// Level 2. Trigger level 2 (8 characters or 0x08).
	UART1_FCR_RXTRIGLVL_LEVEL_2 = 0x2
	// Level 3. Trigger level 3 (14 characters or 0x0E).
	UART1_FCR_RXTRIGLVL_LEVEL_3 = 0x3
	// Position of RESERVED field.
	UART1_FCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_FCR_RESERVED_Msk = 0xffffff00

	// LCR: Line Control Register. Contains controls for frame formatting and break generation.
	// Position of WLS field.
	UART1_LCR_WLS_Pos = 0x0
	// Bit mask of WLS field.
	UART1_LCR_WLS_Msk = 0x3
	// 5-bit character length.
	UART1_LCR_WLS_5_BIT_CHARACTER_LENG = 0x0
	// 6-bit character length.
	UART1_LCR_WLS_6_BIT_CHARACTER_LENG = 0x1
	// 7-bit character length.
	UART1_LCR_WLS_7_BIT_CHARACTER_LENG = 0x2
	// 8-bit character length.
	UART1_LCR_WLS_8_BIT_CHARACTER_LENG = 0x3
	// Position of SBS field.
	UART1_LCR_SBS_Pos = 0x2
	// Bit mask of SBS field.
	UART1_LCR_SBS_Msk = 0x4
	// Bit SBS.
	UART1_LCR_SBS = 0x4
	// 1 stop bit.
	UART1_LCR_SBS_1_STOP_BIT = 0x0
	// 2 stop bits. (1.5 if LCR[1:0]=00).
	UART1_LCR_SBS_2_STOP_BITS = 0x1
	// Position of PE field.
	UART1_LCR_PE_Pos = 0x3
	// Bit mask of PE field.
	UART1_LCR_PE_Msk = 0x8
	// Bit PE.
	UART1_LCR_PE = 0x8
	// Disable parity generation and checking.
	UART1_LCR_PE_DISABLE_PARITY_GENER = 0x0
	// Enable parity generation and checking.
	UART1_LCR_PE_ENABLE_PARITY_GENERA = 0x1
	// Position of PS field.
	UART1_LCR_PS_Pos = 0x4
	// Bit mask of PS field.
	UART1_LCR_PS_Msk = 0x30
	// Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd.
	UART1_LCR_PS_ODD_PARITY = 0x0
	// Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even.
	UART1_LCR_PS_EVEN_PARITY = 0x1
	// Force HIGH. Forced 1 stick parity.
	UART1_LCR_PS_FORCE_HIGH = 0x2
	// Force LOW. Forced 0 stick parity.
	UART1_LCR_PS_FORCE_LOW = 0x3
	// Position of BC field.
	UART1_LCR_BC_Pos = 0x6
	// Bit mask of BC field.
	UART1_LCR_BC_Msk = 0x40
	// Bit BC.
	UART1_LCR_BC = 0x40
	// Disabled. Disable break transmission.
	UART1_LCR_BC_DISABLED = 0x0
	// Enabled. Enable break transmission. Output pin UART1 TXD is forced to logic 0 when LCR[6] is active high.
	UART1_LCR_BC_ENABLED = 0x1
	// Position of DLAB field.
	UART1_LCR_DLAB_Pos = 0x7
	// Bit mask of DLAB field.
	UART1_LCR_DLAB_Msk = 0x80
	// Bit DLAB.
	UART1_LCR_DLAB = 0x80
	// Disabled. Disable access to Divisor Latches.
	UART1_LCR_DLAB_DISABLED = 0x0
	// Enabled. Enable access to Divisor Latches.
	UART1_LCR_DLAB_ENABLED = 0x1
	// Position of RESERVED field.
	UART1_LCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_LCR_RESERVED_Msk = 0xffffff00

	// MCR: Modem Control Register. Contains controls for flow control handshaking and loopback mode.
	// Position of DTRCTRL field.
	UART1_MCR_DTRCTRL_Pos = 0x0
	// Bit mask of DTRCTRL field.
	UART1_MCR_DTRCTRL_Msk = 0x1
	// Bit DTRCTRL.
	UART1_MCR_DTRCTRL = 0x1
	// Position of RTSCTRL field.
	UART1_MCR_RTSCTRL_Pos = 0x1
	// Bit mask of RTSCTRL field.
	UART1_MCR_RTSCTRL_Msk = 0x2
	// Bit RTSCTRL.
	UART1_MCR_RTSCTRL = 0x2
	// Position of RESERVED field.
	UART1_MCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	UART1_MCR_RESERVED_Msk = 0xc
	// Position of LMS field.
	UART1_MCR_LMS_Pos = 0x4
	// Bit mask of LMS field.
	UART1_MCR_LMS_Msk = 0x10
	// Bit LMS.
	UART1_MCR_LMS = 0x10
	// Disabled. Disable modem loopback mode.
	UART1_MCR_LMS_DISABLED = 0x0
	// Enabled. Enable modem loopback mode.
	UART1_MCR_LMS_ENABLED = 0x1
	// Position of RESERVED field.
	UART1_MCR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	UART1_MCR_RESERVED_Msk = 0x20
	// Bit RESERVED.
	UART1_MCR_RESERVED = 0x20
	// Position of RTSEN field.
	UART1_MCR_RTSEN_Pos = 0x6
	// Bit mask of RTSEN field.
	UART1_MCR_RTSEN_Msk = 0x40
	// Bit RTSEN.
	UART1_MCR_RTSEN = 0x40
	// Disabled. Disable auto-rts flow control.
	UART1_MCR_RTSEN_DISABLED = 0x0
	// Enabled. Enable auto-rts flow control.
	UART1_MCR_RTSEN_ENABLED = 0x1
	// Position of CTSEN field.
	UART1_MCR_CTSEN_Pos = 0x7
	// Bit mask of CTSEN field.
	UART1_MCR_CTSEN_Msk = 0x80
	// Bit CTSEN.
	UART1_MCR_CTSEN = 0x80
	// Disabled. Disable auto-cts flow control.
	UART1_MCR_CTSEN_DISABLED = 0x0
	// Enabled. Enable auto-cts flow control.
	UART1_MCR_CTSEN_ENABLED = 0x1
	// Position of RESERVED field.
	UART1_MCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_MCR_RESERVED_Msk = 0xffffff00

	// LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
	// Position of RDR field.
	UART1_LSR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	UART1_LSR_RDR_Msk = 0x1
	// Bit RDR.
	UART1_LSR_RDR = 0x1
	// Empty. The UART1 receiver FIFO is empty.
	UART1_LSR_RDR_EMPTY = 0x0
	// Data. The UART1 receiver FIFO is not empty.
	UART1_LSR_RDR_DATA = 0x1
	// Position of OE field.
	UART1_LSR_OE_Pos = 0x1
	// Bit mask of OE field.
	UART1_LSR_OE_Msk = 0x2
	// Bit OE.
	UART1_LSR_OE = 0x2
	// Inactive. Overrun error status is inactive.
	UART1_LSR_OE_INACTIVE = 0x0
	// Active. Overrun error status is active.
	UART1_LSR_OE_ACTIVE = 0x1
	// Position of PE field.
	UART1_LSR_PE_Pos = 0x2
	// Bit mask of PE field.
	UART1_LSR_PE_Msk = 0x4
	// Bit PE.
	UART1_LSR_PE = 0x4
	// Inactive. Parity error status is inactive.
	UART1_LSR_PE_INACTIVE = 0x0
	// Active. Parity error status is active.
	UART1_LSR_PE_ACTIVE = 0x1
	// Position of FE field.
	UART1_LSR_FE_Pos = 0x3
	// Bit mask of FE field.
	UART1_LSR_FE_Msk = 0x8
	// Bit FE.
	UART1_LSR_FE = 0x8
	// Inactive. Framing error status is inactive.
	UART1_LSR_FE_INACTIVE = 0x0
	// Active. Framing error status is active.
	UART1_LSR_FE_ACTIVE = 0x1
	// Position of BI field.
	UART1_LSR_BI_Pos = 0x4
	// Bit mask of BI field.
	UART1_LSR_BI_Msk = 0x10
	// Bit BI.
	UART1_LSR_BI = 0x10
	// Position of THRE field.
	UART1_LSR_THRE_Pos = 0x5
	// Bit mask of THRE field.
	UART1_LSR_THRE_Msk = 0x20
	// Bit THRE.
	UART1_LSR_THRE = 0x20
	// Not empty. THR contains valid data.
	UART1_LSR_THRE_NOT_EMPTY = 0x0
	// Empty. THR is empty.
	UART1_LSR_THRE_EMPTY = 0x1
	// Position of TEMT field.
	UART1_LSR_TEMT_Pos = 0x6
	// Bit mask of TEMT field.
	UART1_LSR_TEMT_Msk = 0x40
	// Bit TEMT.
	UART1_LSR_TEMT = 0x40
	// Not empty. THR and/or the TSR contains valid data.
	UART1_LSR_TEMT_NOT_EMPTY = 0x0
	// Empty. THR and the TSR are empty.
	UART1_LSR_TEMT_EMPTY = 0x1
	// Position of RXFE field.
	UART1_LSR_RXFE_Pos = 0x7
	// Bit mask of RXFE field.
	UART1_LSR_RXFE_Msk = 0x80
	// Bit RXFE.
	UART1_LSR_RXFE = 0x80
	// No error. RBR contains no UART1 RX errors or FCR[0]=0.
	UART1_LSR_RXFE_NO_ERROR = 0x0
	// Error. UART1 RBR contains at least one UART1 RX error.
	UART1_LSR_RXFE_ERROR = 0x1
	// Position of RESERVED field.
	UART1_LSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_LSR_RESERVED_Msk = 0xffffff00

	// MSR: Modem Status Register. Contains handshake signal status flags.
	// Position of DCTS field.
	UART1_MSR_DCTS_Pos = 0x0
	// Bit mask of DCTS field.
	UART1_MSR_DCTS_Msk = 0x1
	// Bit DCTS.
	UART1_MSR_DCTS = 0x1
	// No change. No change detected on modem input, CTS.
	UART1_MSR_DCTS_NO_CHANGE = 0x0
	// State change. State change detected on modem input, CTS.
	UART1_MSR_DCTS_STATE_CHANGE = 0x1
	// Position of DDSR field.
	UART1_MSR_DDSR_Pos = 0x1
	// Bit mask of DDSR field.
	UART1_MSR_DDSR_Msk = 0x2
	// Bit DDSR.
	UART1_MSR_DDSR = 0x2
	// No change. No change detected on modem input, DSR.
	UART1_MSR_DDSR_NO_CHANGE = 0x0
	// State change. State change detected on modem input, DSR.
	UART1_MSR_DDSR_STATE_CHANGE = 0x1
	// Position of TERI field.
	UART1_MSR_TERI_Pos = 0x2
	// Bit mask of TERI field.
	UART1_MSR_TERI_Msk = 0x4
	// Bit TERI.
	UART1_MSR_TERI = 0x4
	// No change. No change detected on modem input, RI.
	UART1_MSR_TERI_NO_CHANGE = 0x0
	// Rising. Low-to-high transition detected on RI.
	UART1_MSR_TERI_RISING = 0x1
	// Position of DDCD field.
	UART1_MSR_DDCD_Pos = 0x3
	// Bit mask of DDCD field.
	UART1_MSR_DDCD_Msk = 0x8
	// Bit DDCD.
	UART1_MSR_DDCD = 0x8
	// No change. No change detected on modem input, DCD.
	UART1_MSR_DDCD_NO_CHANGE = 0x0
	// State change. State change detected on modem input, DCD.
	UART1_MSR_DDCD_STATE_CHANGE = 0x1
	// Position of CTS field.
	UART1_MSR_CTS_Pos = 0x4
	// Bit mask of CTS field.
	UART1_MSR_CTS_Msk = 0x10
	// Bit CTS.
	UART1_MSR_CTS = 0x10
	// Position of DSR field.
	UART1_MSR_DSR_Pos = 0x5
	// Bit mask of DSR field.
	UART1_MSR_DSR_Msk = 0x20
	// Bit DSR.
	UART1_MSR_DSR = 0x20
	// Position of RI field.
	UART1_MSR_RI_Pos = 0x6
	// Bit mask of RI field.
	UART1_MSR_RI_Msk = 0x40
	// Bit RI.
	UART1_MSR_RI = 0x40
	// Position of DCD field.
	UART1_MSR_DCD_Pos = 0x7
	// Bit mask of DCD field.
	UART1_MSR_DCD_Msk = 0x80
	// Bit DCD.
	UART1_MSR_DCD = 0x80
	// Position of RESERVED field.
	UART1_MSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_MSR_RESERVED_Msk = 0xffffff00

	// SCR: Scratch Pad Register. 8-bit temporary storage for software.
	// Position of Pad field.
	UART1_SCR_Pad_Pos = 0x0
	// Bit mask of Pad field.
	UART1_SCR_Pad_Msk = 0xff
	// Position of RESERVED field.
	UART1_SCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_SCR_RESERVED_Msk = 0xffffff00

	// ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
	// Position of START field.
	UART1_ACR_START_Pos = 0x0
	// Bit mask of START field.
	UART1_ACR_START_Msk = 0x1
	// Bit START.
	UART1_ACR_START = 0x1
	// Stop. Auto-baud stop (auto-baud is not running).
	UART1_ACR_START_STOP = 0x0
	// Start. Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion.
	UART1_ACR_START_START = 0x1
	// Position of MODE field.
	UART1_ACR_MODE_Pos = 0x1
	// Bit mask of MODE field.
	UART1_ACR_MODE_Msk = 0x2
	// Bit MODE.
	UART1_ACR_MODE = 0x2
	// Mode 0.
	UART1_ACR_MODE_MODE_0 = 0x0
	// Mode 1.
	UART1_ACR_MODE_MODE_1 = 0x1
	// Position of AUTORESTART field.
	UART1_ACR_AUTORESTART_Pos = 0x2
	// Bit mask of AUTORESTART field.
	UART1_ACR_AUTORESTART_Msk = 0x4
	// Bit AUTORESTART.
	UART1_ACR_AUTORESTART = 0x4
	// No restart
	UART1_ACR_AUTORESTART_NO_RESTART = 0x0
	// Restart. Restart in case of time-out (counter restarts at next UART1 Rx falling edge)
	UART1_ACR_AUTORESTART_RESTART = 0x1
	// Position of RESERVED field.
	UART1_ACR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART1_ACR_RESERVED_Msk = 0xf8
	// Position of ABEOINTCLR field.
	UART1_ACR_ABEOINTCLR_Pos = 0x8
	// Bit mask of ABEOINTCLR field.
	UART1_ACR_ABEOINTCLR_Msk = 0x100
	// Bit ABEOINTCLR.
	UART1_ACR_ABEOINTCLR = 0x100
	// No effect. Writing a 0 has no impact.
	UART1_ACR_ABEOINTCLR_NO_EFFECT = 0x0
	// Clear. Writing a 1 will clear the corresponding interrupt in the IIR.
	UART1_ACR_ABEOINTCLR_CLEAR = 0x1
	// Position of ABTOINTCLR field.
	UART1_ACR_ABTOINTCLR_Pos = 0x9
	// Bit mask of ABTOINTCLR field.
	UART1_ACR_ABTOINTCLR_Msk = 0x200
	// Bit ABTOINTCLR.
	UART1_ACR_ABTOINTCLR = 0x200
	// No effect. Writing a 0 has no impact.
	UART1_ACR_ABTOINTCLR_NO_EFFECT = 0x0
	// Clear. Writing a 1 will clear the corresponding interrupt in the IIR.
	UART1_ACR_ABTOINTCLR_CLEAR = 0x1
	// Position of RESERVED field.
	UART1_ACR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART1_ACR_RESERVED_Msk = 0xfffffc00

	// FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
	// Position of DIVADDVAL field.
	UART1_FDR_DIVADDVAL_Pos = 0x0
	// Bit mask of DIVADDVAL field.
	UART1_FDR_DIVADDVAL_Msk = 0xf
	// Position of MULVAL field.
	UART1_FDR_MULVAL_Pos = 0x4
	// Bit mask of MULVAL field.
	UART1_FDR_MULVAL_Msk = 0xf0
	// Position of RESERVED field.
	UART1_FDR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_FDR_RESERVED_Msk = 0xffffff00

	// RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
	// Position of NMMEN field.
	UART1_RS485CTRL_NMMEN_Pos = 0x0
	// Bit mask of NMMEN field.
	UART1_RS485CTRL_NMMEN_Msk = 0x1
	// Bit NMMEN.
	UART1_RS485CTRL_NMMEN = 0x1
	// Disabled. RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled.
	UART1_RS485CTRL_NMMEN_DISABLED = 0x0
	// Enabled. RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the USART to set the parity error and generate an interrupt.
	UART1_RS485CTRL_NMMEN_ENABLED = 0x1
	// Position of RXDIS field.
	UART1_RS485CTRL_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	UART1_RS485CTRL_RXDIS_Msk = 0x2
	// Bit RXDIS.
	UART1_RS485CTRL_RXDIS = 0x2
	// Enabled. The receiver is enabled.
	UART1_RS485CTRL_RXDIS_ENABLED = 0x0
	// Disabled.The receiver is disabled.
	UART1_RS485CTRL_RXDIS_DISABLED = 0x1
	// Position of AADEN field.
	UART1_RS485CTRL_AADEN_Pos = 0x2
	// Bit mask of AADEN field.
	UART1_RS485CTRL_AADEN_Msk = 0x4
	// Bit AADEN.
	UART1_RS485CTRL_AADEN = 0x4
	// Disabled. Auto Address Detect (AAD) is disabled.
	UART1_RS485CTRL_AADEN_DISABLED = 0x0
	// Enabled. Auto Address Detect (AAD) is enabled.
	UART1_RS485CTRL_AADEN_ENABLED = 0x1
	// Position of SEL field.
	UART1_RS485CTRL_SEL_Pos = 0x3
	// Bit mask of SEL field.
	UART1_RS485CTRL_SEL_Msk = 0x8
	// Bit SEL.
	UART1_RS485CTRL_SEL = 0x8
	// RTS. If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control.
	UART1_RS485CTRL_SEL_RTS = 0x0
	// DTR. If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control.
	UART1_RS485CTRL_SEL_DTR = 0x1
	// Position of DCTRL field.
	UART1_RS485CTRL_DCTRL_Pos = 0x4
	// Bit mask of DCTRL field.
	UART1_RS485CTRL_DCTRL_Msk = 0x10
	// Bit DCTRL.
	UART1_RS485CTRL_DCTRL = 0x10
	// Disabled. Disable Auto Direction Control.
	UART1_RS485CTRL_DCTRL_DISABLED = 0x0
	// Enabled. Enable Auto Direction Control.
	UART1_RS485CTRL_DCTRL_ENABLED = 0x1
	// Position of OINV field.
	UART1_RS485CTRL_OINV_Pos = 0x5
	// Bit mask of OINV field.
	UART1_RS485CTRL_OINV_Msk = 0x20
	// Bit OINV.
	UART1_RS485CTRL_OINV = 0x20
	// Low. The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted.
	UART1_RS485CTRL_OINV_LOW = 0x0
	// High. The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted.
	UART1_RS485CTRL_OINV_HIGH = 0x1
	// Position of RESERVED field.
	UART1_RS485CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	UART1_RS485CTRL_RESERVED_Msk = 0xffffffc0

	// RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
	// Position of ADRMATCH field.
	UART1_RS485ADRMATCH_ADRMATCH_Pos = 0x0
	// Bit mask of ADRMATCH field.
	UART1_RS485ADRMATCH_ADRMATCH_Msk = 0xff
	// Position of RESERVED field.
	UART1_RS485ADRMATCH_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_RS485ADRMATCH_RESERVED_Msk = 0xffffff00

	// RS485DLY: RS-485/EIA-485 direction control delay.
	// Position of DLY field.
	UART1_RS485DLY_DLY_Pos = 0x0
	// Bit mask of DLY field.
	UART1_RS485DLY_DLY_Msk = 0xff
	// Position of RESERVED field.
	UART1_RS485DLY_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_RS485DLY_RESERVED_Msk = 0xffffff00

	// TER: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
	// Position of TXEN field.
	UART1_TER_TXEN_Pos = 0x0
	// Bit mask of TXEN field.
	UART1_TER_TXEN_Msk = 0x1
	// Bit TXEN.
	UART1_TER_TXEN = 0x1
	// Position of RESERVED field.
	UART1_TER_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	UART1_TER_RESERVED_Msk = 0xfffffffe
)

// Constants for SSP0: SSP0/1
const (
	// CR0: Control Register 0. Selects the serial clock rate, bus type, and data size.
	// Position of DSS field.
	SSP_CR0_DSS_Pos = 0x0
	// Bit mask of DSS field.
	SSP_CR0_DSS_Msk = 0xf
	// 4-bit transfer
	SSP_CR0_DSS_4_BIT_TRANSFER = 0x3
	// 5-bit transfer
	SSP_CR0_DSS_5_BIT_TRANSFER = 0x4
	// 6-bit transfer
	SSP_CR0_DSS_6_BIT_TRANSFER = 0x5
	// 7-bit transfer
	SSP_CR0_DSS_7_BIT_TRANSFER = 0x6
	// 8-bit transfer
	SSP_CR0_DSS_8_BIT_TRANSFER = 0x7
	// 9-bit transfer
	SSP_CR0_DSS_9_BIT_TRANSFER = 0x8
	// 10-bit transfer
	SSP_CR0_DSS_10_BIT_TRANSFER = 0x9
	// 11-bit transfer
	SSP_CR0_DSS_11_BIT_TRANSFER = 0xa
	// 12-bit transfer
	SSP_CR0_DSS_12_BIT_TRANSFER = 0xb
	// 13-bit transfer
	SSP_CR0_DSS_13_BIT_TRANSFER = 0xc
	// 14-bit transfer
	SSP_CR0_DSS_14_BIT_TRANSFER = 0xd
	// 15-bit transfer
	SSP_CR0_DSS_15_BIT_TRANSFER = 0xe
	// 16-bit transfer
	SSP_CR0_DSS_16_BIT_TRANSFER = 0xf
	// Position of FRF field.
	SSP_CR0_FRF_Pos = 0x4
	// Bit mask of FRF field.
	SSP_CR0_FRF_Msk = 0x30
	// SPI
	SSP_CR0_FRF_SPI = 0x0
	// TI
	SSP_CR0_FRF_TI = 0x1
	// Microwire
	SSP_CR0_FRF_MICROWIRE = 0x2
	// This combination is not supported and should not be used.
	SSP_CR0_FRF_THIS_COMBINATION_IS_ = 0x3
	// Position of CPOL field.
	SSP_CR0_CPOL_Pos = 0x6
	// Bit mask of CPOL field.
	SSP_CR0_CPOL_Msk = 0x40
	// Bit CPOL.
	SSP_CR0_CPOL = 0x40
	// SSP controller maintains the bus clock low between frames.
	SSP_CR0_CPOL_BUS_LOW = 0x0
	// SSP controller maintains the bus clock high between frames.
	SSP_CR0_CPOL_BUS_HIGH = 0x1
	// Position of CPHA field.
	SSP_CR0_CPHA_Pos = 0x7
	// Bit mask of CPHA field.
	SSP_CR0_CPHA_Msk = 0x80
	// Bit CPHA.
	SSP_CR0_CPHA = 0x80
	// SSP controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line.
	SSP_CR0_CPHA_FIRST_CLOCK = 0x0
	// SSP controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line.
	SSP_CR0_CPHA_SECOND_CLOCK = 0x1
	// Position of SCR field.
	SSP_CR0_SCR_Pos = 0x8
	// Bit mask of SCR field.
	SSP_CR0_SCR_Msk = 0xff00
	// Position of RESERVED field.
	SSP_CR0_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SSP_CR0_RESERVED_Msk = 0xffff0000

	// CR1: Control Register 1. Selects master/slave and other modes.
	// Position of LBM field.
	SSP_CR1_LBM_Pos = 0x0
	// Bit mask of LBM field.
	SSP_CR1_LBM_Msk = 0x1
	// Bit LBM.
	SSP_CR1_LBM = 0x1
	// During normal operation.
	SSP_CR1_LBM_NORMAL = 0x0
	// Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively).
	SSP_CR1_LBM_OUPTU = 0x1
	// Position of SSE field.
	SSP_CR1_SSE_Pos = 0x1
	// Bit mask of SSE field.
	SSP_CR1_SSE_Msk = 0x2
	// Bit SSE.
	SSP_CR1_SSE = 0x2
	// The SSP controller is disabled.
	SSP_CR1_SSE_DISABLED = 0x0
	// The SSP controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP registers and interrupt controller registers, before setting this bit.
	SSP_CR1_SSE_ENABLED = 0x1
	// Position of MS field.
	SSP_CR1_MS_Pos = 0x2
	// Bit mask of MS field.
	SSP_CR1_MS_Msk = 0x4
	// Bit MS.
	SSP_CR1_MS = 0x4
	// The SSP controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line.
	SSP_CR1_MS_MASTER = 0x0
	// The SSP controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines.
	SSP_CR1_MS_SLAVE = 0x1
	// Position of SOD field.
	SSP_CR1_SOD_Pos = 0x3
	// Bit mask of SOD field.
	SSP_CR1_SOD_Msk = 0x8
	// Bit SOD.
	SSP_CR1_SOD = 0x8
	// Position of RESERVED field.
	SSP_CR1_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SSP_CR1_RESERVED_Msk = 0xfffffff0

	// DR: Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
	// Position of DATA field.
	SSP_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SSP_DR_DATA_Msk = 0xffff
	// Position of RESERVED field.
	SSP_DR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SSP_DR_RESERVED_Msk = 0xffff0000

	// SR: Status Register
	// Position of TFE field.
	SSP_SR_TFE_Pos = 0x0
	// Bit mask of TFE field.
	SSP_SR_TFE_Msk = 0x1
	// Bit TFE.
	SSP_SR_TFE = 0x1
	// Position of TNF field.
	SSP_SR_TNF_Pos = 0x1
	// Bit mask of TNF field.
	SSP_SR_TNF_Msk = 0x2
	// Bit TNF.
	SSP_SR_TNF = 0x2
	// Position of RNE field.
	SSP_SR_RNE_Pos = 0x2
	// Bit mask of RNE field.
	SSP_SR_RNE_Msk = 0x4
	// Bit RNE.
	SSP_SR_RNE = 0x4
	// Position of RFF field.
	SSP_SR_RFF_Pos = 0x3
	// Bit mask of RFF field.
	SSP_SR_RFF_Msk = 0x8
	// Bit RFF.
	SSP_SR_RFF = 0x8
	// Position of BSY field.
	SSP_SR_BSY_Pos = 0x4
	// Bit mask of BSY field.
	SSP_SR_BSY_Msk = 0x10
	// Bit BSY.
	SSP_SR_BSY = 0x10
	// Position of RESERVED field.
	SSP_SR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SSP_SR_RESERVED_Msk = 0xffffffe0

	// CPSR: Clock Prescale Register
	// Position of CPSDVSR field.
	SSP_CPSR_CPSDVSR_Pos = 0x0
	// Bit mask of CPSDVSR field.
	SSP_CPSR_CPSDVSR_Msk = 0xff
	// Position of RESERVED field.
	SSP_CPSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SSP_CPSR_RESERVED_Msk = 0xffffff00

	// IMSC: Interrupt Mask Set and Clear Register
	// Position of RORIM field.
	SSP_IMSC_RORIM_Pos = 0x0
	// Bit mask of RORIM field.
	SSP_IMSC_RORIM_Msk = 0x1
	// Bit RORIM.
	SSP_IMSC_RORIM = 0x1
	// Position of RTIM field.
	SSP_IMSC_RTIM_Pos = 0x1
	// Bit mask of RTIM field.
	SSP_IMSC_RTIM_Msk = 0x2
	// Bit RTIM.
	SSP_IMSC_RTIM = 0x2
	// Position of RXIM field.
	SSP_IMSC_RXIM_Pos = 0x2
	// Bit mask of RXIM field.
	SSP_IMSC_RXIM_Msk = 0x4
	// Bit RXIM.
	SSP_IMSC_RXIM = 0x4
	// Position of TXIM field.
	SSP_IMSC_TXIM_Pos = 0x3
	// Bit mask of TXIM field.
	SSP_IMSC_TXIM_Msk = 0x8
	// Bit TXIM.
	SSP_IMSC_TXIM = 0x8
	// Position of RESERVED field.
	SSP_IMSC_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SSP_IMSC_RESERVED_Msk = 0xfffffff0

	// RIS: Raw Interrupt Status Register
	// Position of RORRIS field.
	SSP_RIS_RORRIS_Pos = 0x0
	// Bit mask of RORRIS field.
	SSP_RIS_RORRIS_Msk = 0x1
	// Bit RORRIS.
	SSP_RIS_RORRIS = 0x1
	// Position of RTRIS field.
	SSP_RIS_RTRIS_Pos = 0x1
	// Bit mask of RTRIS field.
	SSP_RIS_RTRIS_Msk = 0x2
	// Bit RTRIS.
	SSP_RIS_RTRIS = 0x2
	// Position of RXRIS field.
	SSP_RIS_RXRIS_Pos = 0x2
	// Bit mask of RXRIS field.
	SSP_RIS_RXRIS_Msk = 0x4
	// Bit RXRIS.
	SSP_RIS_RXRIS = 0x4
	// Position of TXRIS field.
	SSP_RIS_TXRIS_Pos = 0x3
	// Bit mask of TXRIS field.
	SSP_RIS_TXRIS_Msk = 0x8
	// Bit TXRIS.
	SSP_RIS_TXRIS = 0x8
	// Position of RESERVED field.
	SSP_RIS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SSP_RIS_RESERVED_Msk = 0xfffffff0

	// MIS: Masked Interrupt Status Register
	// Position of RORMIS field.
	SSP_MIS_RORMIS_Pos = 0x0
	// Bit mask of RORMIS field.
	SSP_MIS_RORMIS_Msk = 0x1
	// Bit RORMIS.
	SSP_MIS_RORMIS = 0x1
	// Position of RTMIS field.
	SSP_MIS_RTMIS_Pos = 0x1
	// Bit mask of RTMIS field.
	SSP_MIS_RTMIS_Msk = 0x2
	// Bit RTMIS.
	SSP_MIS_RTMIS = 0x2
	// Position of RXMIS field.
	SSP_MIS_RXMIS_Pos = 0x2
	// Bit mask of RXMIS field.
	SSP_MIS_RXMIS_Msk = 0x4
	// Bit RXMIS.
	SSP_MIS_RXMIS = 0x4
	// Position of TXMIS field.
	SSP_MIS_TXMIS_Pos = 0x3
	// Bit mask of TXMIS field.
	SSP_MIS_TXMIS_Msk = 0x8
	// Bit TXMIS.
	SSP_MIS_TXMIS = 0x8
	// Position of RESERVED field.
	SSP_MIS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SSP_MIS_RESERVED_Msk = 0xfffffff0

	// ICR: SSPICR Interrupt Clear Register
	// Position of RORIC field.
	SSP_ICR_RORIC_Pos = 0x0
	// Bit mask of RORIC field.
	SSP_ICR_RORIC_Msk = 0x1
	// Bit RORIC.
	SSP_ICR_RORIC = 0x1
	// Position of RTIC field.
	SSP_ICR_RTIC_Pos = 0x1
	// Bit mask of RTIC field.
	SSP_ICR_RTIC_Msk = 0x2
	// Bit RTIC.
	SSP_ICR_RTIC = 0x2
	// Position of RESERVED field.
	SSP_ICR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SSP_ICR_RESERVED_Msk = 0xfffffffc

	// DMACR: SSP0 DMA control register
	// Position of RXDMAE field.
	SSP_DMACR_RXDMAE_Pos = 0x0
	// Bit mask of RXDMAE field.
	SSP_DMACR_RXDMAE_Msk = 0x1
	// Bit RXDMAE.
	SSP_DMACR_RXDMAE = 0x1
	// Position of TXDMAE field.
	SSP_DMACR_TXDMAE_Pos = 0x1
	// Bit mask of TXDMAE field.
	SSP_DMACR_TXDMAE_Msk = 0x2
	// Bit TXDMAE.
	SSP_DMACR_TXDMAE = 0x2
	// Position of RESERVED field.
	SSP_DMACR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SSP_DMACR_RESERVED_Msk = 0xfffffffc
)

// Constants for TIMER0: Timer0/1/2/3
const (
	// IR: Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
	// Position of MR0INT field.
	TIMER_IR_MR0INT_Pos = 0x0
	// Bit mask of MR0INT field.
	TIMER_IR_MR0INT_Msk = 0x1
	// Bit MR0INT.
	TIMER_IR_MR0INT = 0x1
	// Position of MR1INT field.
	TIMER_IR_MR1INT_Pos = 0x1
	// Bit mask of MR1INT field.
	TIMER_IR_MR1INT_Msk = 0x2
	// Bit MR1INT.
	TIMER_IR_MR1INT = 0x2
	// Position of MR2INT field.
	TIMER_IR_MR2INT_Pos = 0x2
	// Bit mask of MR2INT field.
	TIMER_IR_MR2INT_Msk = 0x4
	// Bit MR2INT.
	TIMER_IR_MR2INT = 0x4
	// Position of MR3INT field.
	TIMER_IR_MR3INT_Pos = 0x3
	// Bit mask of MR3INT field.
	TIMER_IR_MR3INT_Msk = 0x8
	// Bit MR3INT.
	TIMER_IR_MR3INT = 0x8
	// Position of CR0INT field.
	TIMER_IR_CR0INT_Pos = 0x4
	// Bit mask of CR0INT field.
	TIMER_IR_CR0INT_Msk = 0x10
	// Bit CR0INT.
	TIMER_IR_CR0INT = 0x10
	// Position of CR1INT field.
	TIMER_IR_CR1INT_Pos = 0x5
	// Bit mask of CR1INT field.
	TIMER_IR_CR1INT_Msk = 0x20
	// Bit CR1INT.
	TIMER_IR_CR1INT = 0x20
	// Position of CR2INT field.
	TIMER_IR_CR2INT_Pos = 0x6
	// Bit mask of CR2INT field.
	TIMER_IR_CR2INT_Msk = 0x40
	// Bit CR2INT.
	TIMER_IR_CR2INT = 0x40
	// Position of CR3INT field.
	TIMER_IR_CR3INT_Pos = 0x7
	// Bit mask of CR3INT field.
	TIMER_IR_CR3INT_Msk = 0x80
	// Bit CR3INT.
	TIMER_IR_CR3INT = 0x80
	// Position of RESERVED field.
	TIMER_IR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	TIMER_IR_RESERVED_Msk = 0xffffff00

	// TCR: Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
	// Position of CEN field.
	TIMER_TCR_CEN_Pos = 0x0
	// Bit mask of CEN field.
	TIMER_TCR_CEN_Msk = 0x1
	// Bit CEN.
	TIMER_TCR_CEN = 0x1
	// Position of CRST field.
	TIMER_TCR_CRST_Pos = 0x1
	// Bit mask of CRST field.
	TIMER_TCR_CRST_Msk = 0x2
	// Bit CRST.
	TIMER_TCR_CRST = 0x2
	// Position of RESERVED field.
	TIMER_TCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	TIMER_TCR_RESERVED_Msk = 0xfffffffc

	// TC: Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
	// Position of TC field.
	TIMER_TC_TC_Pos = 0x0
	// Bit mask of TC field.
	TIMER_TC_TC_Msk = 0xffffffff

	// PR: Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
	// Position of PM field.
	TIMER_PR_PM_Pos = 0x0
	// Bit mask of PM field.
	TIMER_PR_PM_Msk = 0xffffffff

	// PC: Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
	// Position of PC field.
	TIMER_PC_PC_Pos = 0x0
	// Bit mask of PC field.
	TIMER_PC_PC_Msk = 0xffffffff

	// MCR: Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
	// Position of MR0I field.
	TIMER_MCR_MR0I_Pos = 0x0
	// Bit mask of MR0I field.
	TIMER_MCR_MR0I_Msk = 0x1
	// Bit MR0I.
	TIMER_MCR_MR0I = 0x1
	// Disabled. Interrupt is disabled
	TIMER_MCR_MR0I_DISABLED = 0x0
	// Enabled. Interrupt is generated when MR0 matches the value in the TC.
	TIMER_MCR_MR0I_ENABLED = 0x1
	// Position of MR0R field.
	TIMER_MCR_MR0R_Pos = 0x1
	// Bit mask of MR0R field.
	TIMER_MCR_MR0R_Msk = 0x2
	// Bit MR0R.
	TIMER_MCR_MR0R = 0x2
	// Disabled. Feature disabled.
	TIMER_MCR_MR0R_DISABLED = 0x0
	// Reset. TC will be reset if MR0 matches it.
	TIMER_MCR_MR0R_RESET = 0x1
	// Position of MR0S field.
	TIMER_MCR_MR0S_Pos = 0x2
	// Bit mask of MR0S field.
	TIMER_MCR_MR0S_Msk = 0x4
	// Bit MR0S.
	TIMER_MCR_MR0S = 0x4
	// Disabled. Feature disabled.
	TIMER_MCR_MR0S_DISABLED = 0x0
	// Match. TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC.
	TIMER_MCR_MR0S_MATCH = 0x1
	// Position of MR1I field.
	TIMER_MCR_MR1I_Pos = 0x3
	// Bit mask of MR1I field.
	TIMER_MCR_MR1I_Msk = 0x8
	// Bit MR1I.
	TIMER_MCR_MR1I = 0x8
	// Disabled. Interrupt is disabled.
	TIMER_MCR_MR1I_DISABLED = 0x0
	// Match. Interrupt is generated when MR1 matches the value in the TC.
	TIMER_MCR_MR1I_MATCH = 0x1
	// Position of MR1R field.
	TIMER_MCR_MR1R_Pos = 0x4
	// Bit mask of MR1R field.
	TIMER_MCR_MR1R_Msk = 0x10
	// Bit MR1R.
	TIMER_MCR_MR1R = 0x10
	// Disabled. Feature disabled.
	TIMER_MCR_MR1R_DISABLED = 0x0
	// Reset. TC will be reset if MR1 matches it.
	TIMER_MCR_MR1R_RESET = 0x1
	// Position of MR1S field.
	TIMER_MCR_MR1S_Pos = 0x5
	// Bit mask of MR1S field.
	TIMER_MCR_MR1S_Msk = 0x20
	// Bit MR1S.
	TIMER_MCR_MR1S = 0x20
	// Disabled. Feature disabled.
	TIMER_MCR_MR1S_DISABLED = 0x0
	// Stop. TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC.
	TIMER_MCR_MR1S_STOP = 0x1
	// Position of MR2I field.
	TIMER_MCR_MR2I_Pos = 0x6
	// Bit mask of MR2I field.
	TIMER_MCR_MR2I_Msk = 0x40
	// Bit MR2I.
	TIMER_MCR_MR2I = 0x40
	// Disabled. Interrupt is disabled
	TIMER_MCR_MR2I_DISABLED = 0x0
	// Match. Interrupt is generated when MR2 matches the value in the TC.
	TIMER_MCR_MR2I_MATCH = 0x1
	// Position of MR2R field.
	TIMER_MCR_MR2R_Pos = 0x7
	// Bit mask of MR2R field.
	TIMER_MCR_MR2R_Msk = 0x80
	// Bit MR2R.
	TIMER_MCR_MR2R = 0x80
	// Disabled. Feature disabled.
	TIMER_MCR_MR2R_DISABLED = 0x0
	// Match. TC will be reset if MR2 matches it.
	TIMER_MCR_MR2R_MATCH = 0x1
	// Position of MR2S field.
	TIMER_MCR_MR2S_Pos = 0x8
	// Bit mask of MR2S field.
	TIMER_MCR_MR2S_Msk = 0x100
	// Bit MR2S.
	TIMER_MCR_MR2S = 0x100
	// Disabled. Feature disabled.
	TIMER_MCR_MR2S_DISABLED = 0x0
	// Stop. TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC.
	TIMER_MCR_MR2S_STOP = 0x1
	// Position of MR3I field.
	TIMER_MCR_MR3I_Pos = 0x9
	// Bit mask of MR3I field.
	TIMER_MCR_MR3I_Msk = 0x200
	// Bit MR3I.
	TIMER_MCR_MR3I = 0x200
	// Disabled. This interrupt is disabled.
	TIMER_MCR_MR3I_DISABLED = 0x0
	// Interrupt. Interrupt is generated when MR3 matches the value in the TC.
	TIMER_MCR_MR3I_INTERRUPT = 0x1
	// Position of MR3R field.
	TIMER_MCR_MR3R_Pos = 0xa
	// Bit mask of MR3R field.
	TIMER_MCR_MR3R_Msk = 0x400
	// Bit MR3R.
	TIMER_MCR_MR3R = 0x400
	// Disabled. Feature disabled.
	TIMER_MCR_MR3R_DISABLED = 0x0
	// Match. TC will be reset if MR3 matches it.
	TIMER_MCR_MR3R_MATCH = 0x1
	// Position of MR3S field.
	TIMER_MCR_MR3S_Pos = 0xb
	// Bit mask of MR3S field.
	TIMER_MCR_MR3S_Msk = 0x800
	// Bit MR3S.
	TIMER_MCR_MR3S = 0x800
	// Disabled. Feature disabled.
	TIMER_MCR_MR3S_DISABLED = 0x0
	// Stop. TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC.
	TIMER_MCR_MR3S_STOP = 0x1
	// Position of RESERVED field.
	TIMER_MCR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	TIMER_MCR_RESERVED_Msk = 0xfffff000

	// MR0: Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
	// Position of MATCH field.
	TIMER_MR_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	TIMER_MR_MATCH_Msk = 0xffffffff

	// CCR: Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
	// Position of CAP0RE field.
	TIMER_CCR_CAP0RE_Pos = 0x0
	// Bit mask of CAP0RE field.
	TIMER_CCR_CAP0RE_Msk = 0x1
	// Bit CAP0RE.
	TIMER_CCR_CAP0RE = 0x1
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP0RE_DISABLED = 0x0
	// Low to high. A sequence of 0 then 1 on CAPn.0 will cause CR0 to be loaded with the contents of TC.
	TIMER_CCR_CAP0RE_LOW_TO_HIGH = 0x1
	// Position of CAP0FE field.
	TIMER_CCR_CAP0FE_Pos = 0x1
	// Bit mask of CAP0FE field.
	TIMER_CCR_CAP0FE_Msk = 0x2
	// Bit CAP0FE.
	TIMER_CCR_CAP0FE = 0x2
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP0FE_DISABLED = 0x0
	// High to low. A sequence of 1 then 0 on CAPn.0 will cause CR0 to be loaded with the contents of TC.
	TIMER_CCR_CAP0FE_HIGH_TO_LOW = 0x1
	// Position of CAP0I field.
	TIMER_CCR_CAP0I_Pos = 0x2
	// Bit mask of CAP0I field.
	TIMER_CCR_CAP0I_Msk = 0x4
	// Bit CAP0I.
	TIMER_CCR_CAP0I = 0x4
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP0I_DISABLED = 0x0
	// Load. A CR0 load due to a CAPn.0 event will generate an interrupt.
	TIMER_CCR_CAP0I_LOAD = 0x1
	// Position of CAP1RE field.
	TIMER_CCR_CAP1RE_Pos = 0x3
	// Bit mask of CAP1RE field.
	TIMER_CCR_CAP1RE_Msk = 0x8
	// Bit CAP1RE.
	TIMER_CCR_CAP1RE = 0x8
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP1RE_DISABLED = 0x0
	// Low to high. A sequence of 0 then 1 on CAPn.1 will cause CR1 to be loaded with the contents of TC.
	TIMER_CCR_CAP1RE_LOW_TO_HIGH = 0x1
	// Position of CAP1FE field.
	TIMER_CCR_CAP1FE_Pos = 0x4
	// Bit mask of CAP1FE field.
	TIMER_CCR_CAP1FE_Msk = 0x10
	// Bit CAP1FE.
	TIMER_CCR_CAP1FE = 0x10
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP1FE_DISABLED = 0x0
	// High to low. A sequence of 1 then 0 on CAPn.1 will cause CR1 to be loaded with the contents of TC.
	TIMER_CCR_CAP1FE_HIGH_TO_LOW = 0x1
	// Position of CAP1I field.
	TIMER_CCR_CAP1I_Pos = 0x5
	// Bit mask of CAP1I field.
	TIMER_CCR_CAP1I_Msk = 0x20
	// Bit CAP1I.
	TIMER_CCR_CAP1I = 0x20
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP1I_DISABLED = 0x0
	// Load. A CR1 load due to a CAPn.1 event will generate an interrupt.
	TIMER_CCR_CAP1I_LOAD = 0x1
	// Position of CAP2RE field.
	TIMER_CCR_CAP2RE_Pos = 0x6
	// Bit mask of CAP2RE field.
	TIMER_CCR_CAP2RE_Msk = 0x40
	// Bit CAP2RE.
	TIMER_CCR_CAP2RE = 0x40
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP2RE_DISABLED = 0x0
	// Low to high. A sequence of 0 then 1 on CAPn.2 will cause CR2 to be loaded with the contents of TC.
	TIMER_CCR_CAP2RE_LOW_TO_HIGH = 0x1
	// Position of CAP2FE field.
	TIMER_CCR_CAP2FE_Pos = 0x7
	// Bit mask of CAP2FE field.
	TIMER_CCR_CAP2FE_Msk = 0x80
	// Bit CAP2FE.
	TIMER_CCR_CAP2FE = 0x80
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP2FE_DISABLED = 0x0
	// High to low. A sequence of 1 then 0 on CAPn.2 will cause CR2 to be loaded with the contents of TC.
	TIMER_CCR_CAP2FE_HIGH_TO_LOW = 0x1
	// Position of CAP2I field.
	TIMER_CCR_CAP2I_Pos = 0x8
	// Bit mask of CAP2I field.
	TIMER_CCR_CAP2I_Msk = 0x100
	// Bit CAP2I.
	TIMER_CCR_CAP2I = 0x100
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP2I_DISABLED = 0x0
	// Load. A CR2 load due to a CAPn.2 event will generate an interrupt.
	TIMER_CCR_CAP2I_LOAD = 0x1
	// Position of CAP3RE field.
	TIMER_CCR_CAP3RE_Pos = 0x9
	// Bit mask of CAP3RE field.
	TIMER_CCR_CAP3RE_Msk = 0x200
	// Bit CAP3RE.
	TIMER_CCR_CAP3RE = 0x200
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP3RE_DISABLED = 0x0
	// Low to high. A sequence of 0 then 1 on CAPn.3 will cause CR3 to be loaded with the contents of TC.
	TIMER_CCR_CAP3RE_LOW_TO_HIGH = 0x1
	// Position of CAP3FE field.
	TIMER_CCR_CAP3FE_Pos = 0xa
	// Bit mask of CAP3FE field.
	TIMER_CCR_CAP3FE_Msk = 0x400
	// Bit CAP3FE.
	TIMER_CCR_CAP3FE = 0x400
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP3FE_DISABLED = 0x0
	// A sequence of 1 then 0 on CAPn.3 will cause CR3 to be loaded with the contents of TC.
	TIMER_CCR_CAP3FE_HIGH_TO_LOW = 0x1
	// Position of CAP3I field.
	TIMER_CCR_CAP3I_Pos = 0xb
	// Bit mask of CAP3I field.
	TIMER_CCR_CAP3I_Msk = 0x800
	// Bit CAP3I.
	TIMER_CCR_CAP3I = 0x800
	// Disabled. This feature is disabled.
	TIMER_CCR_CAP3I_DISABLED = 0x0
	// Load. A CR3 load due to a CAPn.3 event will generate an interrupt.
	TIMER_CCR_CAP3I_LOAD = 0x1
	// Position of RESERVED field.
	TIMER_CCR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	TIMER_CCR_RESERVED_Msk = 0xfffff000

	// CR0: Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
	// Position of CAP field.
	TIMER_CR_CAP_Pos = 0x0
	// Bit mask of CAP field.
	TIMER_CR_CAP_Msk = 0xffffffff

	// EMR: External Match Register. The EMR controls the external match pins MATn.0-3 (MAT0.0-3 and MAT1.0-3 respectively).
	// Position of EM0 field.
	TIMER_EMR_EM0_Pos = 0x0
	// Bit mask of EM0 field.
	TIMER_EMR_EM0_Msk = 0x1
	// Bit EM0.
	TIMER_EMR_EM0 = 0x1
	// Position of EM1 field.
	TIMER_EMR_EM1_Pos = 0x1
	// Bit mask of EM1 field.
	TIMER_EMR_EM1_Msk = 0x2
	// Bit EM1.
	TIMER_EMR_EM1 = 0x2
	// Position of EM2 field.
	TIMER_EMR_EM2_Pos = 0x2
	// Bit mask of EM2 field.
	TIMER_EMR_EM2_Msk = 0x4
	// Bit EM2.
	TIMER_EMR_EM2 = 0x4
	// Position of EM3 field.
	TIMER_EMR_EM3_Pos = 0x3
	// Bit mask of EM3 field.
	TIMER_EMR_EM3_Msk = 0x8
	// Bit EM3.
	TIMER_EMR_EM3 = 0x8
	// Position of EMC0 field.
	TIMER_EMR_EMC0_Pos = 0x4
	// Bit mask of EMC0 field.
	TIMER_EMR_EMC0_Msk = 0x30
	// Do Nothing.
	TIMER_EMR_EMC0_NOP = 0x0
	// Clear. Clear the corresponding External Match bit/output to 0 (MATn.m pin is LOW if pinned out).
	TIMER_EMR_EMC0_CLEAR = 0x1
	// Set. Set the corresponding External Match bit/output to 1 (MATn.m pin is HIGH if pinned out).
	TIMER_EMR_EMC0_SET = 0x2
	// Toggle. Toggle the corresponding External Match bit/output.
	TIMER_EMR_EMC0_TOGGLE = 0x3
	// Position of EMC1 field.
	TIMER_EMR_EMC1_Pos = 0x6
	// Bit mask of EMC1 field.
	TIMER_EMR_EMC1_Msk = 0xc0
	// Do Nothing.
	TIMER_EMR_EMC1_NOP = 0x0
	// Clear. Clear the corresponding External Match bit/output to 0 (MATn.m pin is LOW if pinned out).
	TIMER_EMR_EMC1_CLEAR = 0x1
	// Set. Set the corresponding External Match bit/output to 1 (MATn.m pin is HIGH if pinned out).
	TIMER_EMR_EMC1_SET = 0x2
	// Toggle. Toggle the corresponding External Match bit/output.
	TIMER_EMR_EMC1_TOGGLE = 0x3
	// Position of EMC2 field.
	TIMER_EMR_EMC2_Pos = 0x8
	// Bit mask of EMC2 field.
	TIMER_EMR_EMC2_Msk = 0x300
	// Do Nothing.
	TIMER_EMR_EMC2_NOP = 0x0
	// Clear. Clear the corresponding External Match bit/output to 0 (MATn.m pin is LOW if pinned out).
	TIMER_EMR_EMC2_CLEAR = 0x1
	// Set. Set the corresponding External Match bit/output to 1 (MATn.m pin is HIGH if pinned out).
	TIMER_EMR_EMC2_SET = 0x2
	// Toggle. Toggle the corresponding External Match bit/output.
	TIMER_EMR_EMC2_TOGGLE = 0x3
	// Position of EMC3 field.
	TIMER_EMR_EMC3_Pos = 0xa
	// Bit mask of EMC3 field.
	TIMER_EMR_EMC3_Msk = 0xc00
	// Do Nothing.
	TIMER_EMR_EMC3_NOP = 0x0
	// Clear. Clear the corresponding External Match bit/output to 0 (MATn.m pin is LOW if pinned out).
	TIMER_EMR_EMC3_CLEAR = 0x1
	// Set. Set the corresponding External Match bit/output to 1 (MATn.m pin is HIGH if pinned out).
	TIMER_EMR_EMC3_SET = 0x2
	// Toggle. Toggle the corresponding External Match bit/output.
	TIMER_EMR_EMC3_TOGGLE = 0x3
	// Position of RESERVED field.
	TIMER_EMR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	TIMER_EMR_RESERVED_Msk = 0xfffff000

	// CTCR: Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
	// Position of CTMODE field.
	TIMER_CTCR_CTMODE_Pos = 0x0
	// Bit mask of CTMODE field.
	TIMER_CTCR_CTMODE_Msk = 0x3
	// Timer Mode. Counts every rising PCLK edge
	TIMER_CTCR_CTMODE_TIMER_MODE = 0x0
	// Counter Mode rising edge. TC is incremented on rising edges on the CAP input selected by bits 3:2.
	TIMER_CTCR_CTMODE_COUNTER_MODE_RISING = 0x1
	// Counter Mode falling edge. TC is incremented on falling edges on the CAP input selected by bits 3:2.
	TIMER_CTCR_CTMODE_COUNTER_MODE_FALLING = 0x2
	// Counter Mode edges. TC is incremented on both edges on the CAP input selected by bits 3:2.
	TIMER_CTCR_CTMODE_COUNTER_MODE_EDGES = 0x3
	// Position of CINSEL field.
	TIMER_CTCR_CINSEL_Pos = 0x2
	// Bit mask of CINSEL field.
	TIMER_CTCR_CINSEL_Msk = 0xc
	// CAP0. CAPn.0 for TIMERn
	TIMER_CTCR_CINSEL_CAP0 = 0x0
	// CAP1. CAPn.1 for TIMERn
	TIMER_CTCR_CINSEL_CAP1 = 0x1
	// CAP2. CAPn.2 for TIMERn
	TIMER_CTCR_CINSEL_CAP2 = 0x2
	// CAP3. CAPn.3 for TIMERn
	TIMER_CTCR_CINSEL_CAP3 = 0x3
	// Position of RESERVED field.
	TIMER_CTCR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	TIMER_CTCR_RESERVED_Msk = 0xfffffff0
)

// Constants for SCU: System Control Unit (SCU) I/O configuration
const (
	// SFSP0_0: Pin configuration register for pins P0
	// Position of MODE field.
	SCU_SFSP0_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP0_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP0_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP0_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP0_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP0_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP0_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP0_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP0_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP0_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP0_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP0_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP0_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP0_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP0_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP0_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP0_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP0_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP0_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP0_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP0_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP0_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP0_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP0_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP0_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP0_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP0_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP0_EZI = 0x40
	// Disable input buffer
	SCU_SFSP0_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP0_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP0_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP0_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP0_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP0_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP0_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP0_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP0_RESERVED_Msk = 0xffffff00

	// SFSP1_0: Pin configuration register for pins P1
	// Position of MODE field.
	SCU_SFSP1_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP1_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP1_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP1_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP1_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP1_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP1_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP1_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP1_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP1_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP1_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP1_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP1_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP1_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP1_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP1_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP1_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP1_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP1_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP1_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP1_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP1_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP1_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP1_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP1_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP1_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP1_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP1_EZI = 0x40
	// Disable input buffer
	SCU_SFSP1_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP1_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP1_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP1_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP1_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP1_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP1_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP1_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP1_RESERVED_Msk = 0xffffff00

	// SFSP1_17: Pin configuration register for pins P1_17
	// Position of MODE field.
	SCU_SFSP1_17_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP1_17_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP1_17_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP1_17_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP1_17_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP1_17_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP1_17_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP1_17_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP1_17_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP1_17_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP1_17_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP1_17_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP1_17_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP1_17_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP1_17_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP1_17_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP1_17_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP1_17_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP1_17_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up
	SCU_SFSP1_17_EPUN_DISABLE_PULL_UP = 0x1
	// Position of RESERVED field.
	SCU_SFSP1_17_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SCU_SFSP1_17_RESERVED_Msk = 0x20
	// Bit RESERVED.
	SCU_SFSP1_17_RESERVED = 0x20
	// Position of EZI field.
	SCU_SFSP1_17_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP1_17_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP1_17_EZI = 0x40
	// Disable input buffer
	SCU_SFSP1_17_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP1_17_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP1_17_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP1_17_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP1_17_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP1_17_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP1_17_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of EHD field.
	SCU_SFSP1_17_EHD_Pos = 0x8
	// Bit mask of EHD field.
	SCU_SFSP1_17_EHD_Msk = 0x300
	// Normal-drive: 4 mA drive strength
	SCU_SFSP1_17_EHD_NORMAL_DRIVE_4_MA_D = 0x0
	// Medium-drive: 8 mA drive strength
	SCU_SFSP1_17_EHD_MEDIUM_DRIVE_8_MA_D = 0x1
	// High-drive: 14 mA drive strength
	SCU_SFSP1_17_EHD_HIGH_DRIVE_14_MA_DR = 0x2
	// Ultra high-drive: 20 mA drive strength
	SCU_SFSP1_17_EHD_ULTRA_HIGH_DRIVE_20 = 0x3
	// Position of RESERVED field.
	SCU_SFSP1_17_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	SCU_SFSP1_17_RESERVED_Msk = 0xfffffc00

	// SFSP1_18: Pin configuration register for pins P1
	// Position of MODE field.
	SCU_SFSP1_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP1_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP1_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP1_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP1_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP1_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP1_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP1_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP1_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP1_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP1_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP1_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP1_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP1_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP1_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP1_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP1_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP1_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP1_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP1_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP1_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP1_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP1_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP1_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP1_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP1_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP1_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP1_EZI = 0x40
	// Disable input buffer
	SCU_SFSP1_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP1_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP1_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP1_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP1_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP1_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP1_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP1_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP1_RESERVED_Msk = 0xffffff00

	// SFSP2_0: Pin configuration register for pins P2
	// Position of MODE field.
	SCU_SFSP2_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP2_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP2_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP2_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP2_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP2_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP2_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP2_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP2_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP2_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP2_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP2_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP2_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP2_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP2_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP2_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP2_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP2_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP2_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP2_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP2_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP2_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP2_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP2_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP2_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP2_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP2_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP2_EZI = 0x40
	// Disable input buffer
	SCU_SFSP2_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP2_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP2_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP2_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP2_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP2_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP2_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP2_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP2_RESERVED_Msk = 0xffffff00

	// SFSP2_3: Pin configuration register for pins P2
	// Position of MODE field.
	SCU_SFSP2_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP2_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP2_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP2_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP2_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP2_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP2_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP2_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP2_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP2_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP2_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP2_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP2_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP2_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP2_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP2_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP2_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP2_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP2_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up
	SCU_SFSP2_EPUN_DISABLE_PULL_UP = 0x1
	// Position of RESERVED field.
	SCU_SFSP2_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SCU_SFSP2_RESERVED_Msk = 0x20
	// Bit RESERVED.
	SCU_SFSP2_RESERVED = 0x20
	// Position of EZI field.
	SCU_SFSP2_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP2_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP2_EZI = 0x40
	// Disable input buffer
	SCU_SFSP2_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP2_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP2_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP2_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP2_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP2_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP2_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of EHD field.
	SCU_SFSP2_EHD_Pos = 0x8
	// Bit mask of EHD field.
	SCU_SFSP2_EHD_Msk = 0x300
	// Normal-drive: 4 mA drive strength
	SCU_SFSP2_EHD_NORMAL_DRIVE_4_MA_D = 0x0
	// Medium-drive: 8 mA drive strength
	SCU_SFSP2_EHD_MEDIUM_DRIVE_8_MA_D = 0x1
	// High-drive: 14 mA drive strength
	SCU_SFSP2_EHD_HIGH_DRIVE_14_MA_DR = 0x2
	// Ultra high-drive: 20 mA drive strength
	SCU_SFSP2_EHD_ULTRA_HIGH_DRIVE_20 = 0x3
	// Position of RESERVED field.
	SCU_SFSP2_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	SCU_SFSP2_RESERVED_Msk = 0xfffffc00

	// SFSP2_6: Pin configuration register for pins P2
	// Position of MODE field.
	SCU_SFSP2_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP2_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP2_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP2_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP2_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP2_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP2_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP2_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP2_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP2_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP2_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP2_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP2_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP2_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP2_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP2_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP2_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP2_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP2_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP2_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP2_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP2_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP2_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP2_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP2_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP2_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP2_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP2_EZI = 0x40
	// Disable input buffer
	SCU_SFSP2_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP2_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP2_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP2_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP2_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP2_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP2_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP2_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP2_RESERVED_Msk = 0xffffff00

	// SFSP3_0: Pin configuration register for pins P3
	// Position of MODE field.
	SCU_SFSP3_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP3_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP3_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP3_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP3_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP3_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP3_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP3_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP3_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP3_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP3_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP3_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP3_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP3_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP3_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP3_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP3_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP3_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP3_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP3_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP3_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP3_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP3_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP3_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP3_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP3_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP3_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP3_EZI = 0x40
	// Disable input buffer
	SCU_SFSP3_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP3_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP3_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP3_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP3_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP3_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP3_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP3_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP3_RESERVED_Msk = 0xffffff00

	// SFSP3_3: Pin configuration register for pins P3
	// Position of MODE field.
	SCU_SFSP3_3_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP3_3_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP3_3_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP3_3_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP3_3_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP3_3_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP3_3_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP3_3_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP3_3_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP3_3_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP3_3_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP3_3_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP3_3_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP3_3_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP3_3_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP3_3_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP3_3_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP3_3_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP3_3_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP3_3_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP3_3_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP3_3_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP3_3_EHS = 0x20
	// Fast (low noise with fast speed)
	SCU_SFSP3_3_EHS_FAST_LOW_NOISE_WITH = 0x0
	// High-speed (medium noise with high speed)
	SCU_SFSP3_3_EHS_HIGH_SPEED_MEDIUM_N = 0x1
	// Position of EZI field.
	SCU_SFSP3_3_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP3_3_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP3_3_EZI = 0x40
	// Disable input buffer
	SCU_SFSP3_3_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP3_3_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP3_3_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP3_3_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP3_3_ZIF = 0x80
	// Enable input filter
	SCU_SFSP3_3_ZIF_ENABLE_INPUT_FILTER = 0x0
	// Disable input filter
	SCU_SFSP3_3_ZIF_DISABLE_INPUT_FILTER = 0x1
	// Position of RESERVED field.
	SCU_SFSP3_3_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP3_3_RESERVED_Msk = 0xffffff00

	// SFSP3_4: Pin configuration register for pins P3
	// Position of MODE field.
	SCU_SFSP3_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP3_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP3_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP3_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP3_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP3_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP3_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP3_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP3_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP3_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP3_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP3_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP3_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP3_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP3_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP3_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP3_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP3_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP3_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP3_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP3_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP3_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP3_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP3_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP3_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP3_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP3_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP3_EZI = 0x40
	// Disable input buffer
	SCU_SFSP3_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP3_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP3_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP3_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP3_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP3_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP3_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP3_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP3_RESERVED_Msk = 0xffffff00

	// SFSP4_0: Pin configuration register for pins P4
	// Position of MODE field.
	SCU_SFSP4_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP4_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP4_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP4_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP4_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP4_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP4_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP4_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP4_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP4_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP4_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP4_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP4_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP4_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP4_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP4_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP4_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP4_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP4_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP4_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP4_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP4_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP4_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP4_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP4_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP4_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP4_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP4_EZI = 0x40
	// Disable input buffer
	SCU_SFSP4_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP4_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP4_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP4_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP4_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP4_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP4_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP4_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP4_RESERVED_Msk = 0xffffff00

	// SFSP5_0: Pin configuration register for pins P5
	// Position of MODE field.
	SCU_SFSP5_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP5_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP5_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP5_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP5_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP5_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP5_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP5_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP5_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP5_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP5_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP5_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP5_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP5_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP5_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP5_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP5_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP5_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP5_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP5_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP5_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP5_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP5_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP5_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP5_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP5_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP5_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP5_EZI = 0x40
	// Disable input buffer
	SCU_SFSP5_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP5_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP5_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP5_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP5_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP5_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP5_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP5_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP5_RESERVED_Msk = 0xffffff00

	// SFSP6_0: Pin configuration register for pins P6
	// Position of MODE field.
	SCU_SFSP6_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP6_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP6_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP6_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP6_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP6_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP6_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP6_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP6_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP6_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP6_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP6_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP6_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP6_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP6_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP6_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP6_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP6_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP6_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP6_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP6_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP6_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP6_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP6_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP6_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP6_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP6_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP6_EZI = 0x40
	// Disable input buffer
	SCU_SFSP6_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP6_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP6_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP6_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP6_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP6_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP6_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP6_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP6_RESERVED_Msk = 0xffffff00

	// SFSP7_0: Pin configuration register for pins P7
	// Position of MODE field.
	SCU_SFSP7_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP7_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP7_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP7_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP7_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP7_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP7_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP7_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP7_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP7_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP7_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP7_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP7_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP7_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP7_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP7_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP7_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP7_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP7_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP7_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP7_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP7_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP7_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP7_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP7_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP7_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP7_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP7_EZI = 0x40
	// Disable input buffer
	SCU_SFSP7_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP7_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP7_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP7_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP7_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP7_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP7_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP7_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP7_RESERVED_Msk = 0xffffff00

	// SFSP8_0: Pin configuration register for pins P8
	// Position of MODE field.
	SCU_SFSP8_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP8_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP8_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP8_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP8_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP8_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP8_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP8_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP8_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP8_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP8_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP8_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP8_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP8_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP8_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP8_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP8_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP8_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP8_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP8_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP8_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP8_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP8_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP8_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP8_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP8_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP8_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP8_EZI = 0x40
	// Disable input buffer
	SCU_SFSP8_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP8_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP8_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP8_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP8_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP8_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP8_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP8_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP8_RESERVED_Msk = 0xffffff00

	// SFSP8_3: Pin configuration register for pins P8
	// Position of MODE field.
	SCU_SFSP8_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP8_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP8_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP8_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP8_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP8_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP8_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP8_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP8_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP8_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP8_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP8_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP8_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP8_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP8_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSP8_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP8_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP8_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSP8_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSP8_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP8_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP8_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP8_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSP8_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSP8_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSP8_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP8_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP8_EZI = 0x40
	// Disable input buffer
	SCU_SFSP8_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP8_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSP8_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSP8_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSP8_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSP8_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSP8_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSP8_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSP8_RESERVED_Msk = 0xffffff00

	// SFSP9_0: Pin configuration register for pins P9
	// Position of MODE field.
	SCU_SFSP9_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSP9_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSP9_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSP9_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSP9_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSP9_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSP9_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSP9_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSP9_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSP9_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSP9_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSP9_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSP9_EPD = 0x8
	// Disable pull-down.
	SCU_SFSP9_EPD_DISABLE_PULL_DOWN_ = 0x0
	// Enable pull-down.
	SCU_SFSP9_EPD_ENABLE_PULL_DOWN_ = 0x1
	// Position of EPUN field.
	SCU_SFSP9_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSP9_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSP9_EPUN = 0x10
	// Enable pull-up
	SCU_SFSP9_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up
	SCU_SFSP9_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSP9_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSP9_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSP9_EHS = 0x20
	// Slow
	SCU_SFSP9_EHS_SLOW = 0x0
	// Fast
	SCU_SFSP9_EHS_FAST = 0x1
	// Position of EZI field.
	SCU_SFSP9_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSP9_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSP9_EZI = 0x40
	// Disable input buffer
	SCU_SFSP9_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSP9_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of RESERVED field.
	SCU_SFSP9_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	SCU_SFSP9_RESERVED_Msk = 0x80
	// Bit RESERVED.
	SCU_SFSP9_RESERVED = 0x80
	// Position of EHD field.
	SCU_SFSP9_EHD_Pos = 0x8
	// Bit mask of EHD field.
	SCU_SFSP9_EHD_Msk = 0x300
	// Standard drive: 4 mA drive strength
	SCU_SFSP9_EHD_STANDARD_DRIVE_4_MA = 0x0
	// Medium drive: 8 mA drive strength
	SCU_SFSP9_EHD_MEDIUM_DRIVE_8_MA_D = 0x1
	// High drive: 14 mA drive strength
	SCU_SFSP9_EHD_HIGH_DRIVE_14_MA_DR = 0x2
	// Ultra-high drive: 20 mA drive strength
	SCU_SFSP9_EHD_ULTRA_HIGH_DRIVE_20 = 0x3
	// Position of RESERVED field.
	SCU_SFSP9_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	SCU_SFSP9_RESERVED_Msk = 0xfffffc00

	// SFSPA_0: Pin configuration register for pins PA
	// Position of MODE field.
	SCU_SFSPA_0_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSPA_0_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSPA_0_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSPA_0_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSPA_0_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSPA_0_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSPA_0_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSPA_0_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSPA_0_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSPA_0_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSPA_0_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSPA_0_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSPA_0_EPD = 0x8
	// Disable pull-down.
	SCU_SFSPA_0_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPA_0_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSPA_0_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSPA_0_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSPA_0_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPA_0_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSPA_0_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSPA_0_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSPA_0_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSPA_0_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSPA_0_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSPA_0_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSPA_0_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSPA_0_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSPA_0_EZI = 0x40
	// Disable input buffer
	SCU_SFSPA_0_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSPA_0_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSPA_0_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSPA_0_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSPA_0_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSPA_0_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSPA_0_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSPA_0_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSPA_0_RESERVED_Msk = 0xffffff00

	// SFSPA_1: Pin configuration register for pins PA
	// Position of MODE field.
	SCU_SFSPA_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSPA_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSPA_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSPA_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSPA_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSPA_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSPA_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSPA_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSPA_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSPA_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSPA_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSPA_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSPA_EPD = 0x8
	// Disable pull-down.
	SCU_SFSPA_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPA_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSPA_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSPA_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSPA_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPA_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up
	SCU_SFSPA_EPUN_DISABLE_PULL_UP = 0x1
	// Position of RESERVED field.
	SCU_SFSPA_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SCU_SFSPA_RESERVED_Msk = 0x20
	// Bit RESERVED.
	SCU_SFSPA_RESERVED = 0x20
	// Position of EZI field.
	SCU_SFSPA_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSPA_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSPA_EZI = 0x40
	// Disable input buffer
	SCU_SFSPA_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSPA_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSPA_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSPA_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSPA_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSPA_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSPA_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of EHD field.
	SCU_SFSPA_EHD_Pos = 0x8
	// Bit mask of EHD field.
	SCU_SFSPA_EHD_Msk = 0x300
	// Normal-drive: 4 mA drive strength
	SCU_SFSPA_EHD_NORMAL_DRIVE_4_MA_D = 0x0
	// Medium-drive: 8 mA drive strength
	SCU_SFSPA_EHD_MEDIUM_DRIVE_8_MA_D = 0x1
	// High-drive: 14 mA drive strength
	SCU_SFSPA_EHD_HIGH_DRIVE_14_MA_DR = 0x2
	// Ultra high-drive: 20 mA drive strength
	SCU_SFSPA_EHD_ULTRA_HIGH_DRIVE_20 = 0x3
	// Position of RESERVED field.
	SCU_SFSPA_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	SCU_SFSPA_RESERVED_Msk = 0xfffffc00

	// SFSPA_4: Pin configuration register for pins PA
	// Position of MODE field.
	SCU_SFSPA_4_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSPA_4_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSPA_4_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSPA_4_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSPA_4_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSPA_4_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSPA_4_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSPA_4_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSPA_4_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSPA_4_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSPA_4_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSPA_4_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSPA_4_EPD = 0x8
	// Disable pull-down.
	SCU_SFSPA_4_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPA_4_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSPA_4_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSPA_4_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSPA_4_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPA_4_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSPA_4_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSPA_4_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSPA_4_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSPA_4_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSPA_4_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSPA_4_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSPA_4_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSPA_4_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSPA_4_EZI = 0x40
	// Disable input buffer
	SCU_SFSPA_4_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSPA_4_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSPA_4_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSPA_4_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSPA_4_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSPA_4_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSPA_4_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSPA_4_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSPA_4_RESERVED_Msk = 0xffffff00

	// SFSPB_0: Pin configuration register for pins PB
	// Position of MODE field.
	SCU_SFSPB_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSPB_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSPB_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSPB_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSPB_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSPB_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSPB_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSPB_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSPB_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSPB_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSPB_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSPB_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSPB_EPD = 0x8
	// Disable pull-down.
	SCU_SFSPB_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPB_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSPB_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSPB_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSPB_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPB_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSPB_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSPB_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSPB_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSPB_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSPB_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSPB_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSPB_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSPB_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSPB_EZI = 0x40
	// Disable input buffer
	SCU_SFSPB_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSPB_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSPB_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSPB_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSPB_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSPB_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSPB_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSPB_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSPB_RESERVED_Msk = 0xffffff00

	// SFSPC_0: Pin configuration register for pins PC
	// Position of MODE field.
	SCU_SFSPC_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSPC_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSPC_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSPC_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSPC_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSPC_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSPC_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSPC_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSPC_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSPC_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSPC_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSPC_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSPC_EPD = 0x8
	// Disable pull-down.
	SCU_SFSPC_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPC_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSPC_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSPC_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSPC_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPC_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSPC_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSPC_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSPC_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSPC_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSPC_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSPC_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSPC_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSPC_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSPC_EZI = 0x40
	// Disable input buffer
	SCU_SFSPC_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSPC_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSPC_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSPC_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSPC_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSPC_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSPC_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSPC_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSPC_RESERVED_Msk = 0xffffff00

	// SFSPD_0: Pin configuration register for pins PD
	// Position of MODE field.
	SCU_SFSPD_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSPD_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSPD_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSPD_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSPD_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSPD_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSPD_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSPD_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSPD_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSPD_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSPD_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSPD_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSPD_EPD = 0x8
	// Disable pull-down.
	SCU_SFSPD_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPD_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSPD_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSPD_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSPD_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPD_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSPD_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSPD_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSPD_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSPD_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSPD_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSPD_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSPD_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSPD_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSPD_EZI = 0x40
	// Disable input buffer
	SCU_SFSPD_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSPD_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSPD_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSPD_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSPD_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSPD_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSPD_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSPD_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSPD_RESERVED_Msk = 0xffffff00

	// SFSPE_0: Pin configuration register for pins PE
	// Position of MODE field.
	SCU_SFSPE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSPE_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSPE_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSPE_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSPE_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSPE_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSPE_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSPE_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSPE_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSPE_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSPE_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSPE_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSPE_EPD = 0x8
	// Disable pull-down.
	SCU_SFSPE_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPE_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSPE_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSPE_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSPE_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPE_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSPE_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSPE_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSPE_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSPE_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSPE_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSPE_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSPE_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSPE_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSPE_EZI = 0x40
	// Disable input buffer
	SCU_SFSPE_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSPE_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSPE_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSPE_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSPE_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSPE_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSPE_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSPE_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSPE_RESERVED_Msk = 0xffffff00

	// SFSPF_0: Pin configuration register for pins PF
	// Position of MODE field.
	SCU_SFSPF_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSPF_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSPF_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSPF_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSPF_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSPF_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSPF_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSPF_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSPF_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSPF_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSPF_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSPF_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSPF_EPD = 0x8
	// Disable pull-down.
	SCU_SFSPF_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down.Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPF_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSPF_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSPF_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSPF_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSPF_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSPF_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSPF_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSPF_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSPF_EHS = 0x20
	// Slow (low noise with medium speed)
	SCU_SFSPF_EHS_SLOW_LOW_NOISE_WITH = 0x0
	// Fast (medium noise with fast speed)
	SCU_SFSPF_EHS_FAST_MEDIUM_NOISE_W = 0x1
	// Position of EZI field.
	SCU_SFSPF_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSPF_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSPF_EZI = 0x40
	// Disable input buffer
	SCU_SFSPF_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSPF_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSPF_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSPF_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSPF_ZIF = 0x80
	// Enable input glitch filter
	SCU_SFSPF_ZIF_ENABLE_INPUT_GLITCH = 0x0
	// Disable input glitch filter
	SCU_SFSPF_ZIF_DISABLE_INPUT_GLITCH = 0x1
	// Position of RESERVED field.
	SCU_SFSPF_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSPF_RESERVED_Msk = 0xffffff00

	// SFSCLK_0: Pin configuration register for pins CLK
	// Position of MODE field.
	SCU_SFSCLK_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SCU_SFSCLK_MODE_Msk = 0x7
	// Function 0 (default)
	SCU_SFSCLK_MODE_FUNCTION_0_DEFAULT = 0x0
	// Function 1
	SCU_SFSCLK_MODE_FUNCTION_1 = 0x1
	// Function 2
	SCU_SFSCLK_MODE_FUNCTION_2 = 0x2
	// Function 3
	SCU_SFSCLK_MODE_FUNCTION_3 = 0x3
	// Function 4
	SCU_SFSCLK_MODE_FUNCTION_4 = 0x4
	// Function 5
	SCU_SFSCLK_MODE_FUNCTION_5 = 0x5
	// Function 6
	SCU_SFSCLK_MODE_FUNCTION_6 = 0x6
	// Function 7
	SCU_SFSCLK_MODE_FUNCTION_7 = 0x7
	// Position of EPD field.
	SCU_SFSCLK_EPD_Pos = 0x3
	// Bit mask of EPD field.
	SCU_SFSCLK_EPD_Msk = 0x8
	// Bit EPD.
	SCU_SFSCLK_EPD = 0x8
	// Disable pull-down.
	SCU_SFSCLK_EPD_DISABLE_PULL_DOWN = 0x0
	// Enable pull-down. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSCLK_EPD_ENABLE_PULL_DOWN = 0x1
	// Position of EPUN field.
	SCU_SFSCLK_EPUN_Pos = 0x4
	// Bit mask of EPUN field.
	SCU_SFSCLK_EPUN_Msk = 0x10
	// Bit EPUN.
	SCU_SFSCLK_EPUN = 0x10
	// Enable pull-up. Enable both pull-down resistor and pull-up resistor for repeater mode.
	SCU_SFSCLK_EPUN_ENABLE_PULL_UP = 0x0
	// Disable pull-up.
	SCU_SFSCLK_EPUN_DISABLE_PULL_UP = 0x1
	// Position of EHS field.
	SCU_SFSCLK_EHS_Pos = 0x5
	// Bit mask of EHS field.
	SCU_SFSCLK_EHS_Msk = 0x20
	// Bit EHS.
	SCU_SFSCLK_EHS = 0x20
	// Fast (low noise with fast speed)
	SCU_SFSCLK_EHS_FAST_LOW_NOISE_WITH = 0x0
	// High-speed (medium noise with high speed)
	SCU_SFSCLK_EHS_HIGH_SPEED_MEDIUM_N = 0x1
	// Position of EZI field.
	SCU_SFSCLK_EZI_Pos = 0x6
	// Bit mask of EZI field.
	SCU_SFSCLK_EZI_Msk = 0x40
	// Bit EZI.
	SCU_SFSCLK_EZI = 0x40
	// Disable input buffer
	SCU_SFSCLK_EZI_DISABLE_INPUT_BUFFER = 0x0
	// Enable input buffer
	SCU_SFSCLK_EZI_ENABLE_INPUT_BUFFER = 0x1
	// Position of ZIF field.
	SCU_SFSCLK_ZIF_Pos = 0x7
	// Bit mask of ZIF field.
	SCU_SFSCLK_ZIF_Msk = 0x80
	// Bit ZIF.
	SCU_SFSCLK_ZIF = 0x80
	// Enable input filter
	SCU_SFSCLK_ZIF_ENABLE_INPUT_FILTER = 0x0
	// Disable input filter
	SCU_SFSCLK_ZIF_DISABLE_INPUT_FILTER = 0x1
	// Position of RESERVED field.
	SCU_SFSCLK_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SCU_SFSCLK_RESERVED_Msk = 0xffffff00

	// SFSUSB: Pin configuration register for pins USB1_DM and USB1_DP
	// Position of USB_AIM field.
	SCU_SFSUSB_USB_AIM_Pos = 0x0
	// Bit mask of USB_AIM field.
	SCU_SFSUSB_USB_AIM_Msk = 0x1
	// Bit USB_AIM.
	SCU_SFSUSB_USB_AIM = 0x1
	// Going LOW with full speed edge rate
	SCU_SFSUSB_USB_AIM_GOING_LOW_WITH_FULL = 0x0
	// Going HIGH with full speed edge rate
	SCU_SFSUSB_USB_AIM_GOING_HIGH_WITH_FULL = 0x1
	// Position of USB_ESEA field.
	SCU_SFSUSB_USB_ESEA_Pos = 0x1
	// Bit mask of USB_ESEA field.
	SCU_SFSUSB_USB_ESEA_Msk = 0x2
	// Bit USB_ESEA.
	SCU_SFSUSB_USB_ESEA = 0x2
	// Single input. Enables USB1. Use with the on-chip full-speed PHY.
	SCU_SFSUSB_USB_ESEA_SINGLE_INPUT = 0x1
	// Position of USB_EPD field.
	SCU_SFSUSB_USB_EPD_Pos = 0x2
	// Bit mask of USB_EPD field.
	SCU_SFSUSB_USB_EPD_Msk = 0x4
	// Bit USB_EPD.
	SCU_SFSUSB_USB_EPD = 0x4
	// Pull-down disconnected
	SCU_SFSUSB_USB_EPD_PULL_DOWN_DISCONNECT = 0x0
	// Pull-down connected
	SCU_SFSUSB_USB_EPD_PULL_DOWN_CONNECTED = 0x1
	// Position of RESERVED field.
	SCU_SFSUSB_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	SCU_SFSUSB_RESERVED_Msk = 0x8
	// Bit RESERVED.
	SCU_SFSUSB_RESERVED = 0x8
	// Position of USB_EPWR field.
	SCU_SFSUSB_USB_EPWR_Pos = 0x4
	// Bit mask of USB_EPWR field.
	SCU_SFSUSB_USB_EPWR_Msk = 0x10
	// Bit USB_EPWR.
	SCU_SFSUSB_USB_EPWR = 0x10
	// Power saving mode (Suspend mode)
	SCU_SFSUSB_USB_EPWR_POWER_SAVING_MODE_S = 0x0
	// Normal mode
	SCU_SFSUSB_USB_EPWR_NORMAL_MODE = 0x1
	// Position of USB_VBUS field.
	SCU_SFSUSB_USB_VBUS_Pos = 0x5
	// Bit mask of USB_VBUS field.
	SCU_SFSUSB_USB_VBUS_Msk = 0x20
	// Bit USB_VBUS.
	SCU_SFSUSB_USB_VBUS = 0x20
	// VBUS signal LOW or inactive
	SCU_SFSUSB_USB_VBUS_VBUS_SIGNAL_LOW_OR_I = 0x0
	// VBUS signal HIGH or active
	SCU_SFSUSB_USB_VBUS_VBUS_SIGNAL_HIGH_OR = 0x1
	// Position of RESERVED field.
	SCU_SFSUSB_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	SCU_SFSUSB_RESERVED_Msk = 0xffffffc0

	// SFSI2C0: Pin configuration register for I2C0-bus pins
	// Position of SCL_EFP field.
	SCU_SFSI2C0_SCL_EFP_Pos = 0x0
	// Bit mask of SCL_EFP field.
	SCU_SFSI2C0_SCL_EFP_Msk = 0x1
	// Bit SCL_EFP.
	SCU_SFSI2C0_SCL_EFP = 0x1
	// 50 ns glitch filter
	SCU_SFSI2C0_SCL_EFP_50_NS_GLITCH_FILTER = 0x0
	// 3 ns glitch filter
	SCU_SFSI2C0_SCL_EFP_3_NS_GLITCH_FILTER = 0x1
	// Position of RESERVED field.
	SCU_SFSI2C0_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SCU_SFSI2C0_RESERVED_Msk = 0x2
	// Bit RESERVED.
	SCU_SFSI2C0_RESERVED = 0x2
	// Position of SCL_EHD field.
	SCU_SFSI2C0_SCL_EHD_Pos = 0x2
	// Bit mask of SCL_EHD field.
	SCU_SFSI2C0_SCL_EHD_Msk = 0x4
	// Bit SCL_EHD.
	SCU_SFSI2C0_SCL_EHD = 0x4
	// Standard/Fast mode transmit
	SCU_SFSI2C0_SCL_EHD_STANDARDFAST_MODE = 0x0
	// Fast-mode Plus transmit
	SCU_SFSI2C0_SCL_EHD_FAST_MODE_PLUS_TRANS = 0x1
	// Position of SCL_EZI field.
	SCU_SFSI2C0_SCL_EZI_Pos = 0x3
	// Bit mask of SCL_EZI field.
	SCU_SFSI2C0_SCL_EZI_Msk = 0x8
	// Bit SCL_EZI.
	SCU_SFSI2C0_SCL_EZI = 0x8
	// Disabled
	SCU_SFSI2C0_SCL_EZI_DISABLED = 0x0
	// Enabled
	SCU_SFSI2C0_SCL_EZI_ENABLED = 0x1
	// Position of RESERVED field.
	SCU_SFSI2C0_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SCU_SFSI2C0_RESERVED_Msk = 0x70
	// Position of SCL_ZIF field.
	SCU_SFSI2C0_SCL_ZIF_Pos = 0x7
	// Bit mask of SCL_ZIF field.
	SCU_SFSI2C0_SCL_ZIF_Msk = 0x80
	// Bit SCL_ZIF.
	SCU_SFSI2C0_SCL_ZIF = 0x80
	// Enable input filter
	SCU_SFSI2C0_SCL_ZIF_ENABLE_INPUT_FILTER = 0x0
	// Disable input filter
	SCU_SFSI2C0_SCL_ZIF_DISABLE_INPUT_FILTER = 0x1
	// Position of SDA_EFP field.
	SCU_SFSI2C0_SDA_EFP_Pos = 0x8
	// Bit mask of SDA_EFP field.
	SCU_SFSI2C0_SDA_EFP_Msk = 0x100
	// Bit SDA_EFP.
	SCU_SFSI2C0_SDA_EFP = 0x100
	// 50 ns glitch filter
	SCU_SFSI2C0_SDA_EFP_50_NS_GLITCH_FILTER = 0x0
	// 3 ns glitch filter
	SCU_SFSI2C0_SDA_EFP_3_NS_GLITCH_FILTER = 0x1
	// Position of RESERVED field.
	SCU_SFSI2C0_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	SCU_SFSI2C0_RESERVED_Msk = 0x200
	// Bit RESERVED.
	SCU_SFSI2C0_RESERVED = 0x200
	// Position of SDA_EHD field.
	SCU_SFSI2C0_SDA_EHD_Pos = 0xa
	// Bit mask of SDA_EHD field.
	SCU_SFSI2C0_SDA_EHD_Msk = 0x400
	// Bit SDA_EHD.
	SCU_SFSI2C0_SDA_EHD = 0x400
	// Standard/Fast mode transmit
	SCU_SFSI2C0_SDA_EHD_STANDARDFAST_MODE = 0x0
	// Fast-mode Plus transmit
	SCU_SFSI2C0_SDA_EHD_FAST_MODE_PLUS_TRANS = 0x1
	// Position of SDA_EZI field.
	SCU_SFSI2C0_SDA_EZI_Pos = 0xb
	// Bit mask of SDA_EZI field.
	SCU_SFSI2C0_SDA_EZI_Msk = 0x800
	// Bit SDA_EZI.
	SCU_SFSI2C0_SDA_EZI = 0x800
	// Disabled
	SCU_SFSI2C0_SDA_EZI_DISABLED = 0x0
	// Enabled
	SCU_SFSI2C0_SDA_EZI_ENABLED = 0x1
	// Position of RESERVED field.
	SCU_SFSI2C0_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	SCU_SFSI2C0_RESERVED_Msk = 0x7000
	// Position of SDA_ZIF field.
	SCU_SFSI2C0_SDA_ZIF_Pos = 0xf
	// Bit mask of SDA_ZIF field.
	SCU_SFSI2C0_SDA_ZIF_Msk = 0x8000
	// Bit SDA_ZIF.
	SCU_SFSI2C0_SDA_ZIF = 0x8000
	// Enable input filter
	SCU_SFSI2C0_SDA_ZIF_ENABLE_INPUT_FILTER = 0x0
	// Disable input filter
	SCU_SFSI2C0_SDA_ZIF_DISABLE_INPUT_FILTER = 0x1
	// Position of RESERVED field.
	SCU_SFSI2C0_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCU_SFSI2C0_RESERVED_Msk = 0xffff0000

	// ENAIO0: ADC0 function select register
	// Position of ADC0_0 field.
	SCU_ENAIO0_ADC0_0_Pos = 0x0
	// Bit mask of ADC0_0 field.
	SCU_ENAIO0_ADC0_0_Msk = 0x1
	// Bit ADC0_0.
	SCU_ENAIO0_ADC0_0 = 0x1
	// Digital function selected on pin P4_3.
	SCU_ENAIO0_ADC0_0_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC0_0 selected on pin P4_3
	SCU_ENAIO0_ADC0_0_ANALOG_FUNCTION_ADC0 = 0x1
	// Position of ADC0_1 field.
	SCU_ENAIO0_ADC0_1_Pos = 0x1
	// Bit mask of ADC0_1 field.
	SCU_ENAIO0_ADC0_1_Msk = 0x2
	// Bit ADC0_1.
	SCU_ENAIO0_ADC0_1 = 0x2
	// Digital function selected on pin P4_1.
	SCU_ENAIO0_ADC0_1_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC0_1 selected on pin P4_1.
	SCU_ENAIO0_ADC0_1_ANALOG_FUNCTION_ADC0 = 0x1
	// Position of ADC0_2 field.
	SCU_ENAIO0_ADC0_2_Pos = 0x2
	// Bit mask of ADC0_2 field.
	SCU_ENAIO0_ADC0_2_Msk = 0x4
	// Bit ADC0_2.
	SCU_ENAIO0_ADC0_2 = 0x4
	// Digital function selected on pin PF_8.
	SCU_ENAIO0_ADC0_2_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC0_2 selected on pin PF_8.
	SCU_ENAIO0_ADC0_2_ANALOG_FUNCTION_ADC0 = 0x1
	// Position of ADC0_3 field.
	SCU_ENAIO0_ADC0_3_Pos = 0x3
	// Bit mask of ADC0_3 field.
	SCU_ENAIO0_ADC0_3_Msk = 0x8
	// Bit ADC0_3.
	SCU_ENAIO0_ADC0_3 = 0x8
	// Digital function selected on pin P7_5.
	SCU_ENAIO0_ADC0_3_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC0_3 selected on pin P7_5.
	SCU_ENAIO0_ADC0_3_ANALOG_FUNCTION_ADC0 = 0x1
	// Position of ADC0_4 field.
	SCU_ENAIO0_ADC0_4_Pos = 0x4
	// Bit mask of ADC0_4 field.
	SCU_ENAIO0_ADC0_4_Msk = 0x10
	// Bit ADC0_4.
	SCU_ENAIO0_ADC0_4 = 0x10
	// Digital function selected on pin P7_4.
	SCU_ENAIO0_ADC0_4_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC0_4 selected on pin P7_4.
	SCU_ENAIO0_ADC0_4_ANALOG_FUNCTION_ADC0 = 0x1
	// Position of ADC0_5 field.
	SCU_ENAIO0_ADC0_5_Pos = 0x5
	// Bit mask of ADC0_5 field.
	SCU_ENAIO0_ADC0_5_Msk = 0x20
	// Bit ADC0_5.
	SCU_ENAIO0_ADC0_5 = 0x20
	// Digital function selected on pin PF_10.
	SCU_ENAIO0_ADC0_5_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC0_5 selected on pin PF_10.
	SCU_ENAIO0_ADC0_5_ANALOG_FUNCTION_ADC0 = 0x1
	// Position of ADC0_6 field.
	SCU_ENAIO0_ADC0_6_Pos = 0x6
	// Bit mask of ADC0_6 field.
	SCU_ENAIO0_ADC0_6_Msk = 0x40
	// Bit ADC0_6.
	SCU_ENAIO0_ADC0_6 = 0x40
	// Digital function selected on pin PB_6.
	SCU_ENAIO0_ADC0_6_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC0_6 selected on pin PB_6.
	SCU_ENAIO0_ADC0_6_ANALOG_FUNCTION_ADC0 = 0x1

	// ENAIO1: ADC1 function select register
	// Position of ADC1_0 field.
	SCU_ENAIO1_ADC1_0_Pos = 0x0
	// Bit mask of ADC1_0 field.
	SCU_ENAIO1_ADC1_0_Msk = 0x1
	// Bit ADC1_0.
	SCU_ENAIO1_ADC1_0 = 0x1
	// Digital function selected on pin PC_3.
	SCU_ENAIO1_ADC1_0_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC1_0 selected on pin PC_3.
	SCU_ENAIO1_ADC1_0_ANALOG_FUNCTION_ADC1 = 0x1
	// Position of ADC1_1 field.
	SCU_ENAIO1_ADC1_1_Pos = 0x1
	// Bit mask of ADC1_1 field.
	SCU_ENAIO1_ADC1_1_Msk = 0x2
	// Bit ADC1_1.
	SCU_ENAIO1_ADC1_1 = 0x2
	// Digital function selected on pin PC_0.
	SCU_ENAIO1_ADC1_1_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC1_1 selected on pin PC_0.
	SCU_ENAIO1_ADC1_1_ANALOG_FUNCTION_ADC1 = 0x1
	// Position of ADC1_2 field.
	SCU_ENAIO1_ADC1_2_Pos = 0x2
	// Bit mask of ADC1_2 field.
	SCU_ENAIO1_ADC1_2_Msk = 0x4
	// Bit ADC1_2.
	SCU_ENAIO1_ADC1_2 = 0x4
	// Digital function selected on pin PF_9.
	SCU_ENAIO1_ADC1_2_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC1_2 selected on pin PF_9.
	SCU_ENAIO1_ADC1_2_ANALOG_FUNCTION_ADC1 = 0x1
	// Position of ADC1_3 field.
	SCU_ENAIO1_ADC1_3_Pos = 0x3
	// Bit mask of ADC1_3 field.
	SCU_ENAIO1_ADC1_3_Msk = 0x8
	// Bit ADC1_3.
	SCU_ENAIO1_ADC1_3 = 0x8
	// Digital function selected on pin PF_6.
	SCU_ENAIO1_ADC1_3_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC1_3 selected on pin PF_6.
	SCU_ENAIO1_ADC1_3_ANALOG_FUNCTION_ADC1 = 0x1
	// Position of ADC1_4 field.
	SCU_ENAIO1_ADC1_4_Pos = 0x4
	// Bit mask of ADC1_4 field.
	SCU_ENAIO1_ADC1_4_Msk = 0x10
	// Bit ADC1_4.
	SCU_ENAIO1_ADC1_4 = 0x10
	// Digital function selected on pin PF_5.
	SCU_ENAIO1_ADC1_4_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC1_4 selected on pin PF_5.
	SCU_ENAIO1_ADC1_4_ANALOG_FUNCTION_ADC1 = 0x1
	// Position of ADC1_5 field.
	SCU_ENAIO1_ADC1_5_Pos = 0x5
	// Bit mask of ADC1_5 field.
	SCU_ENAIO1_ADC1_5_Msk = 0x20
	// Bit ADC1_5.
	SCU_ENAIO1_ADC1_5 = 0x20
	// Digital function selected on pin PF_11.
	SCU_ENAIO1_ADC1_5_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC1_5 selected on pin PF_11.
	SCU_ENAIO1_ADC1_5_ANALOG_FUNCTION_ADC1 = 0x1
	// Position of ADC1_6 field.
	SCU_ENAIO1_ADC1_6_Pos = 0x6
	// Bit mask of ADC1_6 field.
	SCU_ENAIO1_ADC1_6_Msk = 0x40
	// Bit ADC1_6.
	SCU_ENAIO1_ADC1_6 = 0x40
	// Digital function selected on pin P7_7.
	SCU_ENAIO1_ADC1_6_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC1_6 selected on pin P7_7.
	SCU_ENAIO1_ADC1_6_ANALOG_FUNCTION_ADC1 = 0x1
	// Position of ADC1_7 field.
	SCU_ENAIO1_ADC1_7_Pos = 0x7
	// Bit mask of ADC1_7 field.
	SCU_ENAIO1_ADC1_7_Msk = 0x80
	// Bit ADC1_7.
	SCU_ENAIO1_ADC1_7 = 0x80
	// Digital function selected on pin PF_7.
	SCU_ENAIO1_ADC1_7_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function ADC1_7 selected on pin PF_7.
	SCU_ENAIO1_ADC1_7_ANALOG_FUNCTION_ADC1 = 0x1

	// ENAIO2: Analog function select register
	// Position of DAC field.
	SCU_ENAIO2_DAC_Pos = 0x0
	// Bit mask of DAC field.
	SCU_ENAIO2_DAC_Msk = 0x1
	// Bit DAC.
	SCU_ENAIO2_DAC = 0x1
	// Digital function selected on pin P4_4.
	SCU_ENAIO2_DAC_DIGITAL_FUNCTION_SEL = 0x0
	// Analog function DAC selected on pin P4_4.
	SCU_ENAIO2_DAC_ANALOG_FUNCTION_DAC = 0x1
	// Position of BG field.
	SCU_ENAIO2_BG_Pos = 0x4
	// Bit mask of BG field.
	SCU_ENAIO2_BG_Msk = 0x10
	// Bit BG.
	SCU_ENAIO2_BG = 0x10
	// Digital function selected on pin PF_7.
	SCU_ENAIO2_BG_DIGITAL_FUNCTION_SEL = 0x0
	// Band gap output selected for pin PF_7.
	SCU_ENAIO2_BG_BAND_GAP_OUTPUT_SELE = 0x1

	// EMCDELAYCLK: EMC clock delay register
	// Position of CLK_DELAY field.
	SCU_EMCDELAYCLK_CLK_DELAY_Pos = 0x0
	// Bit mask of CLK_DELAY field.
	SCU_EMCDELAYCLK_CLK_DELAY_Msk = 0xffff
	// Position of RESERVED field.
	SCU_EMCDELAYCLK_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SCU_EMCDELAYCLK_RESERVED_Msk = 0xffff0000

	// SDDELAY: SD/MMC sample and drive delay register
	// Position of SAMPLE_DELAY field.
	SCU_SDDELAY_SAMPLE_DELAY_Pos = 0x0
	// Bit mask of SAMPLE_DELAY field.
	SCU_SDDELAY_SAMPLE_DELAY_Msk = 0xf
	// Position of RESERVED field.
	SCU_SDDELAY_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SCU_SDDELAY_RESERVED_Msk = 0xf0
	// Position of DRV_DELAY field.
	SCU_SDDELAY_DRV_DELAY_Pos = 0x8
	// Bit mask of DRV_DELAY field.
	SCU_SDDELAY_DRV_DELAY_Msk = 0xf00
	// Position of RESERVED field.
	SCU_SDDELAY_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	SCU_SDDELAY_RESERVED_Msk = 0xfffff000

	// PINTSEL0: Pin interrupt select register for pin interrupts 0 to 3.
	// Position of INTPIN0 field.
	SCU_PINTSEL0_INTPIN0_Pos = 0x0
	// Bit mask of INTPIN0 field.
	SCU_PINTSEL0_INTPIN0_Msk = 0x1f
	// Position of PORTSEL0 field.
	SCU_PINTSEL0_PORTSEL0_Pos = 0x5
	// Bit mask of PORTSEL0 field.
	SCU_PINTSEL0_PORTSEL0_Msk = 0xe0
	// GPIO Port 0
	SCU_PINTSEL0_PORTSEL0_GPIO_PORT_0 = 0x0
	// GPIO Port 1
	SCU_PINTSEL0_PORTSEL0_GPIO_PORT_1 = 0x1
	// GPIO Port 2
	SCU_PINTSEL0_PORTSEL0_GPIO_PORT_2 = 0x2
	// GPIO Port 3
	SCU_PINTSEL0_PORTSEL0_GPIO_PORT_3 = 0x3
	// GPIO Port 4
	SCU_PINTSEL0_PORTSEL0_GPIO_PORT_4 = 0x4
	// GPIO Port 5
	SCU_PINTSEL0_PORTSEL0_GPIO_PORT_5 = 0x5
	// GPIO Port 6
	SCU_PINTSEL0_PORTSEL0_GPIO_PORT_6 = 0x6
	// GPIO Port 7
	SCU_PINTSEL0_PORTSEL0_GPIO_PORT_7 = 0x7
	// Position of INTPIN1 field.
	SCU_PINTSEL0_INTPIN1_Pos = 0x8
	// Bit mask of INTPIN1 field.
	SCU_PINTSEL0_INTPIN1_Msk = 0x1f00
	// Position of PORTSEL1 field.
	SCU_PINTSEL0_PORTSEL1_Pos = 0xd
	// Bit mask of PORTSEL1 field.
	SCU_PINTSEL0_PORTSEL1_Msk = 0xe000
	// GPIO Port 0
	SCU_PINTSEL0_PORTSEL1_GPIO_PORT_0 = 0x0
	// GPIO Port 1
	SCU_PINTSEL0_PORTSEL1_GPIO_PORT_1 = 0x1
	// GPIO Port 2
	SCU_PINTSEL0_PORTSEL1_GPIO_PORT_2 = 0x2
	// GPIO Port 3
	SCU_PINTSEL0_PORTSEL1_GPIO_PORT_3 = 0x3
	// GPIO Port 4
	SCU_PINTSEL0_PORTSEL1_GPIO_PORT_4 = 0x4
	// GPIO Port 5
	SCU_PINTSEL0_PORTSEL1_GPIO_PORT_5 = 0x5
	// GPIO Port 6
	SCU_PINTSEL0_PORTSEL1_GPIO_PORT_6 = 0x6
	// GPIO Port 7
	SCU_PINTSEL0_PORTSEL1_GPIO_PORT_7 = 0x7
	// Position of INTPIN2 field.
	SCU_PINTSEL0_INTPIN2_Pos = 0x10
	// Bit mask of INTPIN2 field.
	SCU_PINTSEL0_INTPIN2_Msk = 0x1f0000
	// Position of PORTSEL2 field.
	SCU_PINTSEL0_PORTSEL2_Pos = 0x15
	// Bit mask of PORTSEL2 field.
	SCU_PINTSEL0_PORTSEL2_Msk = 0xe00000
	// GPIO Port 0
	SCU_PINTSEL0_PORTSEL2_GPIO_PORT_0 = 0x0
	// GPIO Port 1
	SCU_PINTSEL0_PORTSEL2_GPIO_PORT_1 = 0x1
	// GPIO Port 2
	SCU_PINTSEL0_PORTSEL2_GPIO_PORT_2 = 0x2
	// GPIO Port 3
	SCU_PINTSEL0_PORTSEL2_GPIO_PORT_3 = 0x3
	// GPIO Port 4
	SCU_PINTSEL0_PORTSEL2_GPIO_PORT_4 = 0x4
	// GPIO Port 5
	SCU_PINTSEL0_PORTSEL2_GPIO_PORT_5 = 0x5
	// GPIO Port 6
	SCU_PINTSEL0_PORTSEL2_GPIO_PORT_6 = 0x6
	// GPIO Port 7
	SCU_PINTSEL0_PORTSEL2_GPIO_PORT_7 = 0x7
	// Position of INTPIN3 field.
	SCU_PINTSEL0_INTPIN3_Pos = 0x18
	// Bit mask of INTPIN3 field.
	SCU_PINTSEL0_INTPIN3_Msk = 0x1f000000
	// Position of PORTSEL3 field.
	SCU_PINTSEL0_PORTSEL3_Pos = 0x1d
	// Bit mask of PORTSEL3 field.
	SCU_PINTSEL0_PORTSEL3_Msk = 0xe0000000
	// GPIO Port 0
	SCU_PINTSEL0_PORTSEL3_GPIO_PORT_0 = 0x0
	// GPIO Port 1
	SCU_PINTSEL0_PORTSEL3_GPIO_PORT_1 = 0x1
	// GPIO Port 2
	SCU_PINTSEL0_PORTSEL3_GPIO_PORT_2 = 0x2
	// GPIO Port 3
	SCU_PINTSEL0_PORTSEL3_GPIO_PORT_3 = 0x3
	// GPIO Port 4
	SCU_PINTSEL0_PORTSEL3_GPIO_PORT_4 = 0x4
	// GPIO Port 5
	SCU_PINTSEL0_PORTSEL3_GPIO_PORT_5 = 0x5
	// GPIO Port 6
	SCU_PINTSEL0_PORTSEL3_GPIO_PORT_6 = 0x6
	// GPIO Port 7
	SCU_PINTSEL0_PORTSEL3_GPIO_PORT_7 = 0x7

	// PINTSEL1: Pin interrupt select register for pin interrupts 4 to 7.
	// Position of INTPIN4 field.
	SCU_PINTSEL1_INTPIN4_Pos = 0x0
	// Bit mask of INTPIN4 field.
	SCU_PINTSEL1_INTPIN4_Msk = 0x1f
	// Position of PORTSEL4 field.
	SCU_PINTSEL1_PORTSEL4_Pos = 0x5
	// Bit mask of PORTSEL4 field.
	SCU_PINTSEL1_PORTSEL4_Msk = 0xe0
	// GPIO Port 0
	SCU_PINTSEL1_PORTSEL4_GPIO_PORT_0 = 0x0
	// GPIO Port 1
	SCU_PINTSEL1_PORTSEL4_GPIO_PORT_1 = 0x1
	// GPIO Port 2
	SCU_PINTSEL1_PORTSEL4_GPIO_PORT_2 = 0x2
	// GPIO Port 3
	SCU_PINTSEL1_PORTSEL4_GPIO_PORT_3 = 0x3
	// GPIO Port 4
	SCU_PINTSEL1_PORTSEL4_GPIO_PORT_4 = 0x4
	// GPIO Port 5
	SCU_PINTSEL1_PORTSEL4_GPIO_PORT_5 = 0x5
	// GPIO Port 6
	SCU_PINTSEL1_PORTSEL4_GPIO_PORT_6 = 0x6
	// GPIO Port 7
	SCU_PINTSEL1_PORTSEL4_GPIO_PORT_7 = 0x7
	// Position of INTPIN5 field.
	SCU_PINTSEL1_INTPIN5_Pos = 0x8
	// Bit mask of INTPIN5 field.
	SCU_PINTSEL1_INTPIN5_Msk = 0x1f00
	// Position of PORTSEL5 field.
	SCU_PINTSEL1_PORTSEL5_Pos = 0xd
	// Bit mask of PORTSEL5 field.
	SCU_PINTSEL1_PORTSEL5_Msk = 0xe000
	// GPIO Port 0
	SCU_PINTSEL1_PORTSEL5_GPIO_PORT_0 = 0x0
	// GPIO Port 1
	SCU_PINTSEL1_PORTSEL5_GPIO_PORT_1 = 0x1
	// GPIO Port 2
	SCU_PINTSEL1_PORTSEL5_GPIO_PORT_2 = 0x2
	// GPIO Port 3
	SCU_PINTSEL1_PORTSEL5_GPIO_PORT_3 = 0x3
	// GPIO Port 4
	SCU_PINTSEL1_PORTSEL5_GPIO_PORT_4 = 0x4
	// GPIO Port 5
	SCU_PINTSEL1_PORTSEL5_GPIO_PORT_5 = 0x5
	// GPIO Port 6
	SCU_PINTSEL1_PORTSEL5_GPIO_PORT_6 = 0x6
	// GPIO Port 7
	SCU_PINTSEL1_PORTSEL5_GPIO_PORT_7 = 0x7
	// Position of INTPIN6 field.
	SCU_PINTSEL1_INTPIN6_Pos = 0x10
	// Bit mask of INTPIN6 field.
	SCU_PINTSEL1_INTPIN6_Msk = 0x1f0000
	// Position of PORTSEL6 field.
	SCU_PINTSEL1_PORTSEL6_Pos = 0x15
	// Bit mask of PORTSEL6 field.
	SCU_PINTSEL1_PORTSEL6_Msk = 0xe00000
	// GPIO Port 0
	SCU_PINTSEL1_PORTSEL6_GPIO_PORT_0 = 0x0
	// GPIO Port 1
	SCU_PINTSEL1_PORTSEL6_GPIO_PORT_1 = 0x1
	// GPIO Port 2
	SCU_PINTSEL1_PORTSEL6_GPIO_PORT_2 = 0x2
	// GPIO Port 3
	SCU_PINTSEL1_PORTSEL6_GPIO_PORT_3 = 0x3
	// GPIO Port 4
	SCU_PINTSEL1_PORTSEL6_GPIO_PORT_4 = 0x4
	// GPIO Port 5
	SCU_PINTSEL1_PORTSEL6_GPIO_PORT_5 = 0x5
	// GPIO Port 6
	SCU_PINTSEL1_PORTSEL6_GPIO_PORT_6 = 0x6
	// GPIO Port 7
	SCU_PINTSEL1_PORTSEL6_GPIO_PORT_7 = 0x7
	// Position of INTPIN7 field.
	SCU_PINTSEL1_INTPIN7_Pos = 0x18
	// Bit mask of INTPIN7 field.
	SCU_PINTSEL1_INTPIN7_Msk = 0x1f000000
	// Position of PORTSEL7 field.
	SCU_PINTSEL1_PORTSEL7_Pos = 0x1d
	// Bit mask of PORTSEL7 field.
	SCU_PINTSEL1_PORTSEL7_Msk = 0xe0000000
	// GPIO Port 0
	SCU_PINTSEL1_PORTSEL7_GPIO_PORT_0 = 0x0
	// GPIO Port 1
	SCU_PINTSEL1_PORTSEL7_GPIO_PORT_1 = 0x1
	// GPIO Port 2
	SCU_PINTSEL1_PORTSEL7_GPIO_PORT_2 = 0x2
	// GPIO Port 3
	SCU_PINTSEL1_PORTSEL7_GPIO_PORT_3 = 0x3
	// GPIO Port 4
	SCU_PINTSEL1_PORTSEL7_GPIO_PORT_4 = 0x4
	// GPIO Port 5
	SCU_PINTSEL1_PORTSEL7_GPIO_PORT_5 = 0x5
	// GPIO Port 6
	SCU_PINTSEL1_PORTSEL7_GPIO_PORT_6 = 0x6
	// GPIO Port 7
	SCU_PINTSEL1_PORTSEL7_GPIO_PORT_7 = 0x7
)

// Constants for GPIO_PIN_INT: GPIO pin interrupt
const (
	// ISEL: Pin Interrupt Mode register
	// Position of PMODE0 field.
	GPIO_PIN_INT_ISEL_PMODE0_Pos = 0x0
	// Bit mask of PMODE0 field.
	GPIO_PIN_INT_ISEL_PMODE0_Msk = 0x1
	// Bit PMODE0.
	GPIO_PIN_INT_ISEL_PMODE0 = 0x1
	// Position of PMODE1 field.
	GPIO_PIN_INT_ISEL_PMODE1_Pos = 0x1
	// Bit mask of PMODE1 field.
	GPIO_PIN_INT_ISEL_PMODE1_Msk = 0x2
	// Bit PMODE1.
	GPIO_PIN_INT_ISEL_PMODE1 = 0x2
	// Position of PMODE2 field.
	GPIO_PIN_INT_ISEL_PMODE2_Pos = 0x2
	// Bit mask of PMODE2 field.
	GPIO_PIN_INT_ISEL_PMODE2_Msk = 0x4
	// Bit PMODE2.
	GPIO_PIN_INT_ISEL_PMODE2 = 0x4
	// Position of PMODE3 field.
	GPIO_PIN_INT_ISEL_PMODE3_Pos = 0x3
	// Bit mask of PMODE3 field.
	GPIO_PIN_INT_ISEL_PMODE3_Msk = 0x8
	// Bit PMODE3.
	GPIO_PIN_INT_ISEL_PMODE3 = 0x8
	// Position of PMODE4 field.
	GPIO_PIN_INT_ISEL_PMODE4_Pos = 0x4
	// Bit mask of PMODE4 field.
	GPIO_PIN_INT_ISEL_PMODE4_Msk = 0x10
	// Bit PMODE4.
	GPIO_PIN_INT_ISEL_PMODE4 = 0x10
	// Position of PMODE5 field.
	GPIO_PIN_INT_ISEL_PMODE5_Pos = 0x5
	// Bit mask of PMODE5 field.
	GPIO_PIN_INT_ISEL_PMODE5_Msk = 0x20
	// Bit PMODE5.
	GPIO_PIN_INT_ISEL_PMODE5 = 0x20
	// Position of PMODE6 field.
	GPIO_PIN_INT_ISEL_PMODE6_Pos = 0x6
	// Bit mask of PMODE6 field.
	GPIO_PIN_INT_ISEL_PMODE6_Msk = 0x40
	// Bit PMODE6.
	GPIO_PIN_INT_ISEL_PMODE6 = 0x40
	// Position of PMODE7 field.
	GPIO_PIN_INT_ISEL_PMODE7_Pos = 0x7
	// Bit mask of PMODE7 field.
	GPIO_PIN_INT_ISEL_PMODE7_Msk = 0x80
	// Bit PMODE7.
	GPIO_PIN_INT_ISEL_PMODE7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_ISEL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_ISEL_RESERVED_Msk = 0xffffff00

	// IENR: Pin Interrupt Enable (Rising) register
	// Position of ENRL0 field.
	GPIO_PIN_INT_IENR_ENRL0_Pos = 0x0
	// Bit mask of ENRL0 field.
	GPIO_PIN_INT_IENR_ENRL0_Msk = 0x1
	// Bit ENRL0.
	GPIO_PIN_INT_IENR_ENRL0 = 0x1
	// Position of ENRL1 field.
	GPIO_PIN_INT_IENR_ENRL1_Pos = 0x1
	// Bit mask of ENRL1 field.
	GPIO_PIN_INT_IENR_ENRL1_Msk = 0x2
	// Bit ENRL1.
	GPIO_PIN_INT_IENR_ENRL1 = 0x2
	// Position of ENRL2 field.
	GPIO_PIN_INT_IENR_ENRL2_Pos = 0x2
	// Bit mask of ENRL2 field.
	GPIO_PIN_INT_IENR_ENRL2_Msk = 0x4
	// Bit ENRL2.
	GPIO_PIN_INT_IENR_ENRL2 = 0x4
	// Position of ENRL3 field.
	GPIO_PIN_INT_IENR_ENRL3_Pos = 0x3
	// Bit mask of ENRL3 field.
	GPIO_PIN_INT_IENR_ENRL3_Msk = 0x8
	// Bit ENRL3.
	GPIO_PIN_INT_IENR_ENRL3 = 0x8
	// Position of ENRL4 field.
	GPIO_PIN_INT_IENR_ENRL4_Pos = 0x4
	// Bit mask of ENRL4 field.
	GPIO_PIN_INT_IENR_ENRL4_Msk = 0x10
	// Bit ENRL4.
	GPIO_PIN_INT_IENR_ENRL4 = 0x10
	// Position of ENRL5 field.
	GPIO_PIN_INT_IENR_ENRL5_Pos = 0x5
	// Bit mask of ENRL5 field.
	GPIO_PIN_INT_IENR_ENRL5_Msk = 0x20
	// Bit ENRL5.
	GPIO_PIN_INT_IENR_ENRL5 = 0x20
	// Position of ENRL6 field.
	GPIO_PIN_INT_IENR_ENRL6_Pos = 0x6
	// Bit mask of ENRL6 field.
	GPIO_PIN_INT_IENR_ENRL6_Msk = 0x40
	// Bit ENRL6.
	GPIO_PIN_INT_IENR_ENRL6 = 0x40
	// Position of ENRL7 field.
	GPIO_PIN_INT_IENR_ENRL7_Pos = 0x7
	// Bit mask of ENRL7 field.
	GPIO_PIN_INT_IENR_ENRL7_Msk = 0x80
	// Bit ENRL7.
	GPIO_PIN_INT_IENR_ENRL7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_IENR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_IENR_RESERVED_Msk = 0xffffff00

	// SIENR: Set Pin Interrupt Enable (Rising) register
	// Position of SETENRL0 field.
	GPIO_PIN_INT_SIENR_SETENRL0_Pos = 0x0
	// Bit mask of SETENRL0 field.
	GPIO_PIN_INT_SIENR_SETENRL0_Msk = 0x1
	// Bit SETENRL0.
	GPIO_PIN_INT_SIENR_SETENRL0 = 0x1
	// Position of SETENRL1 field.
	GPIO_PIN_INT_SIENR_SETENRL1_Pos = 0x1
	// Bit mask of SETENRL1 field.
	GPIO_PIN_INT_SIENR_SETENRL1_Msk = 0x2
	// Bit SETENRL1.
	GPIO_PIN_INT_SIENR_SETENRL1 = 0x2
	// Position of SETENRL2 field.
	GPIO_PIN_INT_SIENR_SETENRL2_Pos = 0x2
	// Bit mask of SETENRL2 field.
	GPIO_PIN_INT_SIENR_SETENRL2_Msk = 0x4
	// Bit SETENRL2.
	GPIO_PIN_INT_SIENR_SETENRL2 = 0x4
	// Position of SETENRL3 field.
	GPIO_PIN_INT_SIENR_SETENRL3_Pos = 0x3
	// Bit mask of SETENRL3 field.
	GPIO_PIN_INT_SIENR_SETENRL3_Msk = 0x8
	// Bit SETENRL3.
	GPIO_PIN_INT_SIENR_SETENRL3 = 0x8
	// Position of SETENRL4 field.
	GPIO_PIN_INT_SIENR_SETENRL4_Pos = 0x4
	// Bit mask of SETENRL4 field.
	GPIO_PIN_INT_SIENR_SETENRL4_Msk = 0x10
	// Bit SETENRL4.
	GPIO_PIN_INT_SIENR_SETENRL4 = 0x10
	// Position of SETENRL5 field.
	GPIO_PIN_INT_SIENR_SETENRL5_Pos = 0x5
	// Bit mask of SETENRL5 field.
	GPIO_PIN_INT_SIENR_SETENRL5_Msk = 0x20
	// Bit SETENRL5.
	GPIO_PIN_INT_SIENR_SETENRL5 = 0x20
	// Position of SETENRL6 field.
	GPIO_PIN_INT_SIENR_SETENRL6_Pos = 0x6
	// Bit mask of SETENRL6 field.
	GPIO_PIN_INT_SIENR_SETENRL6_Msk = 0x40
	// Bit SETENRL6.
	GPIO_PIN_INT_SIENR_SETENRL6 = 0x40
	// Position of SETENRL7 field.
	GPIO_PIN_INT_SIENR_SETENRL7_Pos = 0x7
	// Bit mask of SETENRL7 field.
	GPIO_PIN_INT_SIENR_SETENRL7_Msk = 0x80
	// Bit SETENRL7.
	GPIO_PIN_INT_SIENR_SETENRL7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_SIENR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_SIENR_RESERVED_Msk = 0xffffff00

	// CIENR: Clear Pin Interrupt Enable (Rising) register
	// Position of CENRL0 field.
	GPIO_PIN_INT_CIENR_CENRL0_Pos = 0x0
	// Bit mask of CENRL0 field.
	GPIO_PIN_INT_CIENR_CENRL0_Msk = 0x1
	// Bit CENRL0.
	GPIO_PIN_INT_CIENR_CENRL0 = 0x1
	// Position of CENRL1 field.
	GPIO_PIN_INT_CIENR_CENRL1_Pos = 0x1
	// Bit mask of CENRL1 field.
	GPIO_PIN_INT_CIENR_CENRL1_Msk = 0x2
	// Bit CENRL1.
	GPIO_PIN_INT_CIENR_CENRL1 = 0x2
	// Position of CENRL2 field.
	GPIO_PIN_INT_CIENR_CENRL2_Pos = 0x2
	// Bit mask of CENRL2 field.
	GPIO_PIN_INT_CIENR_CENRL2_Msk = 0x4
	// Bit CENRL2.
	GPIO_PIN_INT_CIENR_CENRL2 = 0x4
	// Position of CENRL3 field.
	GPIO_PIN_INT_CIENR_CENRL3_Pos = 0x3
	// Bit mask of CENRL3 field.
	GPIO_PIN_INT_CIENR_CENRL3_Msk = 0x8
	// Bit CENRL3.
	GPIO_PIN_INT_CIENR_CENRL3 = 0x8
	// Position of CENRL4 field.
	GPIO_PIN_INT_CIENR_CENRL4_Pos = 0x4
	// Bit mask of CENRL4 field.
	GPIO_PIN_INT_CIENR_CENRL4_Msk = 0x10
	// Bit CENRL4.
	GPIO_PIN_INT_CIENR_CENRL4 = 0x10
	// Position of CENRL5 field.
	GPIO_PIN_INT_CIENR_CENRL5_Pos = 0x5
	// Bit mask of CENRL5 field.
	GPIO_PIN_INT_CIENR_CENRL5_Msk = 0x20
	// Bit CENRL5.
	GPIO_PIN_INT_CIENR_CENRL5 = 0x20
	// Position of CENRL6 field.
	GPIO_PIN_INT_CIENR_CENRL6_Pos = 0x6
	// Bit mask of CENRL6 field.
	GPIO_PIN_INT_CIENR_CENRL6_Msk = 0x40
	// Bit CENRL6.
	GPIO_PIN_INT_CIENR_CENRL6 = 0x40
	// Position of CENRL7 field.
	GPIO_PIN_INT_CIENR_CENRL7_Pos = 0x7
	// Bit mask of CENRL7 field.
	GPIO_PIN_INT_CIENR_CENRL7_Msk = 0x80
	// Bit CENRL7.
	GPIO_PIN_INT_CIENR_CENRL7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_CIENR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_CIENR_RESERVED_Msk = 0xffffff00

	// IENF: Pin Interrupt Enable Falling Edge / Active Level register
	// Position of ENAF0 field.
	GPIO_PIN_INT_IENF_ENAF0_Pos = 0x0
	// Bit mask of ENAF0 field.
	GPIO_PIN_INT_IENF_ENAF0_Msk = 0x1
	// Bit ENAF0.
	GPIO_PIN_INT_IENF_ENAF0 = 0x1
	// Position of ENAF1 field.
	GPIO_PIN_INT_IENF_ENAF1_Pos = 0x1
	// Bit mask of ENAF1 field.
	GPIO_PIN_INT_IENF_ENAF1_Msk = 0x2
	// Bit ENAF1.
	GPIO_PIN_INT_IENF_ENAF1 = 0x2
	// Position of ENAF2 field.
	GPIO_PIN_INT_IENF_ENAF2_Pos = 0x2
	// Bit mask of ENAF2 field.
	GPIO_PIN_INT_IENF_ENAF2_Msk = 0x4
	// Bit ENAF2.
	GPIO_PIN_INT_IENF_ENAF2 = 0x4
	// Position of ENAF3 field.
	GPIO_PIN_INT_IENF_ENAF3_Pos = 0x3
	// Bit mask of ENAF3 field.
	GPIO_PIN_INT_IENF_ENAF3_Msk = 0x8
	// Bit ENAF3.
	GPIO_PIN_INT_IENF_ENAF3 = 0x8
	// Position of ENAF4 field.
	GPIO_PIN_INT_IENF_ENAF4_Pos = 0x4
	// Bit mask of ENAF4 field.
	GPIO_PIN_INT_IENF_ENAF4_Msk = 0x10
	// Bit ENAF4.
	GPIO_PIN_INT_IENF_ENAF4 = 0x10
	// Position of ENAF5 field.
	GPIO_PIN_INT_IENF_ENAF5_Pos = 0x5
	// Bit mask of ENAF5 field.
	GPIO_PIN_INT_IENF_ENAF5_Msk = 0x20
	// Bit ENAF5.
	GPIO_PIN_INT_IENF_ENAF5 = 0x20
	// Position of ENAF6 field.
	GPIO_PIN_INT_IENF_ENAF6_Pos = 0x6
	// Bit mask of ENAF6 field.
	GPIO_PIN_INT_IENF_ENAF6_Msk = 0x40
	// Bit ENAF6.
	GPIO_PIN_INT_IENF_ENAF6 = 0x40
	// Position of ENAF7 field.
	GPIO_PIN_INT_IENF_ENAF7_Pos = 0x7
	// Bit mask of ENAF7 field.
	GPIO_PIN_INT_IENF_ENAF7_Msk = 0x80
	// Bit ENAF7.
	GPIO_PIN_INT_IENF_ENAF7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_IENF_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_IENF_RESERVED_Msk = 0xffffff00

	// SIENF: Set Pin Interrupt Enable Falling Edge / Active Level register
	// Position of SETENAF0 field.
	GPIO_PIN_INT_SIENF_SETENAF0_Pos = 0x0
	// Bit mask of SETENAF0 field.
	GPIO_PIN_INT_SIENF_SETENAF0_Msk = 0x1
	// Bit SETENAF0.
	GPIO_PIN_INT_SIENF_SETENAF0 = 0x1
	// Position of SETENAF1 field.
	GPIO_PIN_INT_SIENF_SETENAF1_Pos = 0x1
	// Bit mask of SETENAF1 field.
	GPIO_PIN_INT_SIENF_SETENAF1_Msk = 0x2
	// Bit SETENAF1.
	GPIO_PIN_INT_SIENF_SETENAF1 = 0x2
	// Position of SETENAF2 field.
	GPIO_PIN_INT_SIENF_SETENAF2_Pos = 0x2
	// Bit mask of SETENAF2 field.
	GPIO_PIN_INT_SIENF_SETENAF2_Msk = 0x4
	// Bit SETENAF2.
	GPIO_PIN_INT_SIENF_SETENAF2 = 0x4
	// Position of SETENAF3 field.
	GPIO_PIN_INT_SIENF_SETENAF3_Pos = 0x3
	// Bit mask of SETENAF3 field.
	GPIO_PIN_INT_SIENF_SETENAF3_Msk = 0x8
	// Bit SETENAF3.
	GPIO_PIN_INT_SIENF_SETENAF3 = 0x8
	// Position of SETENAF4 field.
	GPIO_PIN_INT_SIENF_SETENAF4_Pos = 0x4
	// Bit mask of SETENAF4 field.
	GPIO_PIN_INT_SIENF_SETENAF4_Msk = 0x10
	// Bit SETENAF4.
	GPIO_PIN_INT_SIENF_SETENAF4 = 0x10
	// Position of SETENAF5 field.
	GPIO_PIN_INT_SIENF_SETENAF5_Pos = 0x5
	// Bit mask of SETENAF5 field.
	GPIO_PIN_INT_SIENF_SETENAF5_Msk = 0x20
	// Bit SETENAF5.
	GPIO_PIN_INT_SIENF_SETENAF5 = 0x20
	// Position of SETENAF6 field.
	GPIO_PIN_INT_SIENF_SETENAF6_Pos = 0x6
	// Bit mask of SETENAF6 field.
	GPIO_PIN_INT_SIENF_SETENAF6_Msk = 0x40
	// Bit SETENAF6.
	GPIO_PIN_INT_SIENF_SETENAF6 = 0x40
	// Position of SETENAF7 field.
	GPIO_PIN_INT_SIENF_SETENAF7_Pos = 0x7
	// Bit mask of SETENAF7 field.
	GPIO_PIN_INT_SIENF_SETENAF7_Msk = 0x80
	// Bit SETENAF7.
	GPIO_PIN_INT_SIENF_SETENAF7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_SIENF_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_SIENF_RESERVED_Msk = 0xffffff00

	// CIENF: Clear Pin Interrupt Enable Falling Edge / Active Level address
	// Position of CENAF0 field.
	GPIO_PIN_INT_CIENF_CENAF0_Pos = 0x0
	// Bit mask of CENAF0 field.
	GPIO_PIN_INT_CIENF_CENAF0_Msk = 0x1
	// Bit CENAF0.
	GPIO_PIN_INT_CIENF_CENAF0 = 0x1
	// Position of CENAF1 field.
	GPIO_PIN_INT_CIENF_CENAF1_Pos = 0x1
	// Bit mask of CENAF1 field.
	GPIO_PIN_INT_CIENF_CENAF1_Msk = 0x2
	// Bit CENAF1.
	GPIO_PIN_INT_CIENF_CENAF1 = 0x2
	// Position of CENAF2 field.
	GPIO_PIN_INT_CIENF_CENAF2_Pos = 0x2
	// Bit mask of CENAF2 field.
	GPIO_PIN_INT_CIENF_CENAF2_Msk = 0x4
	// Bit CENAF2.
	GPIO_PIN_INT_CIENF_CENAF2 = 0x4
	// Position of CENAF3 field.
	GPIO_PIN_INT_CIENF_CENAF3_Pos = 0x3
	// Bit mask of CENAF3 field.
	GPIO_PIN_INT_CIENF_CENAF3_Msk = 0x8
	// Bit CENAF3.
	GPIO_PIN_INT_CIENF_CENAF3 = 0x8
	// Position of CENAF4 field.
	GPIO_PIN_INT_CIENF_CENAF4_Pos = 0x4
	// Bit mask of CENAF4 field.
	GPIO_PIN_INT_CIENF_CENAF4_Msk = 0x10
	// Bit CENAF4.
	GPIO_PIN_INT_CIENF_CENAF4 = 0x10
	// Position of CENAF5 field.
	GPIO_PIN_INT_CIENF_CENAF5_Pos = 0x5
	// Bit mask of CENAF5 field.
	GPIO_PIN_INT_CIENF_CENAF5_Msk = 0x20
	// Bit CENAF5.
	GPIO_PIN_INT_CIENF_CENAF5 = 0x20
	// Position of CENAF6 field.
	GPIO_PIN_INT_CIENF_CENAF6_Pos = 0x6
	// Bit mask of CENAF6 field.
	GPIO_PIN_INT_CIENF_CENAF6_Msk = 0x40
	// Bit CENAF6.
	GPIO_PIN_INT_CIENF_CENAF6 = 0x40
	// Position of CENAF7 field.
	GPIO_PIN_INT_CIENF_CENAF7_Pos = 0x7
	// Bit mask of CENAF7 field.
	GPIO_PIN_INT_CIENF_CENAF7_Msk = 0x80
	// Bit CENAF7.
	GPIO_PIN_INT_CIENF_CENAF7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_CIENF_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_CIENF_RESERVED_Msk = 0xffffff00

	// RISE: Pin Interrupt Rising Edge register
	// Position of RDET0 field.
	GPIO_PIN_INT_RISE_RDET0_Pos = 0x0
	// Bit mask of RDET0 field.
	GPIO_PIN_INT_RISE_RDET0_Msk = 0x1
	// Bit RDET0.
	GPIO_PIN_INT_RISE_RDET0 = 0x1
	// Position of RDET1 field.
	GPIO_PIN_INT_RISE_RDET1_Pos = 0x1
	// Bit mask of RDET1 field.
	GPIO_PIN_INT_RISE_RDET1_Msk = 0x2
	// Bit RDET1.
	GPIO_PIN_INT_RISE_RDET1 = 0x2
	// Position of RDET2 field.
	GPIO_PIN_INT_RISE_RDET2_Pos = 0x2
	// Bit mask of RDET2 field.
	GPIO_PIN_INT_RISE_RDET2_Msk = 0x4
	// Bit RDET2.
	GPIO_PIN_INT_RISE_RDET2 = 0x4
	// Position of RDET3 field.
	GPIO_PIN_INT_RISE_RDET3_Pos = 0x3
	// Bit mask of RDET3 field.
	GPIO_PIN_INT_RISE_RDET3_Msk = 0x8
	// Bit RDET3.
	GPIO_PIN_INT_RISE_RDET3 = 0x8
	// Position of RDET4 field.
	GPIO_PIN_INT_RISE_RDET4_Pos = 0x4
	// Bit mask of RDET4 field.
	GPIO_PIN_INT_RISE_RDET4_Msk = 0x10
	// Bit RDET4.
	GPIO_PIN_INT_RISE_RDET4 = 0x10
	// Position of RDET5 field.
	GPIO_PIN_INT_RISE_RDET5_Pos = 0x5
	// Bit mask of RDET5 field.
	GPIO_PIN_INT_RISE_RDET5_Msk = 0x20
	// Bit RDET5.
	GPIO_PIN_INT_RISE_RDET5 = 0x20
	// Position of RDET6 field.
	GPIO_PIN_INT_RISE_RDET6_Pos = 0x6
	// Bit mask of RDET6 field.
	GPIO_PIN_INT_RISE_RDET6_Msk = 0x40
	// Bit RDET6.
	GPIO_PIN_INT_RISE_RDET6 = 0x40
	// Position of RDET7 field.
	GPIO_PIN_INT_RISE_RDET7_Pos = 0x7
	// Bit mask of RDET7 field.
	GPIO_PIN_INT_RISE_RDET7_Msk = 0x80
	// Bit RDET7.
	GPIO_PIN_INT_RISE_RDET7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_RISE_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_RISE_RESERVED_Msk = 0xffffff00

	// FALL: Pin Interrupt Falling Edge register
	// Position of FDET0 field.
	GPIO_PIN_INT_FALL_FDET0_Pos = 0x0
	// Bit mask of FDET0 field.
	GPIO_PIN_INT_FALL_FDET0_Msk = 0x1
	// Bit FDET0.
	GPIO_PIN_INT_FALL_FDET0 = 0x1
	// Position of FDET1 field.
	GPIO_PIN_INT_FALL_FDET1_Pos = 0x1
	// Bit mask of FDET1 field.
	GPIO_PIN_INT_FALL_FDET1_Msk = 0x2
	// Bit FDET1.
	GPIO_PIN_INT_FALL_FDET1 = 0x2
	// Position of FDET2 field.
	GPIO_PIN_INT_FALL_FDET2_Pos = 0x2
	// Bit mask of FDET2 field.
	GPIO_PIN_INT_FALL_FDET2_Msk = 0x4
	// Bit FDET2.
	GPIO_PIN_INT_FALL_FDET2 = 0x4
	// Position of FDET3 field.
	GPIO_PIN_INT_FALL_FDET3_Pos = 0x3
	// Bit mask of FDET3 field.
	GPIO_PIN_INT_FALL_FDET3_Msk = 0x8
	// Bit FDET3.
	GPIO_PIN_INT_FALL_FDET3 = 0x8
	// Position of FDET4 field.
	GPIO_PIN_INT_FALL_FDET4_Pos = 0x4
	// Bit mask of FDET4 field.
	GPIO_PIN_INT_FALL_FDET4_Msk = 0x10
	// Bit FDET4.
	GPIO_PIN_INT_FALL_FDET4 = 0x10
	// Position of FDET5 field.
	GPIO_PIN_INT_FALL_FDET5_Pos = 0x5
	// Bit mask of FDET5 field.
	GPIO_PIN_INT_FALL_FDET5_Msk = 0x20
	// Bit FDET5.
	GPIO_PIN_INT_FALL_FDET5 = 0x20
	// Position of FDET6 field.
	GPIO_PIN_INT_FALL_FDET6_Pos = 0x6
	// Bit mask of FDET6 field.
	GPIO_PIN_INT_FALL_FDET6_Msk = 0x40
	// Bit FDET6.
	GPIO_PIN_INT_FALL_FDET6 = 0x40
	// Position of FDET7 field.
	GPIO_PIN_INT_FALL_FDET7_Pos = 0x7
	// Bit mask of FDET7 field.
	GPIO_PIN_INT_FALL_FDET7_Msk = 0x80
	// Bit FDET7.
	GPIO_PIN_INT_FALL_FDET7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_FALL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_FALL_RESERVED_Msk = 0xffffff00

	// IST: Pin Interrupt Status register
	// Position of PSTAT0 field.
	GPIO_PIN_INT_IST_PSTAT0_Pos = 0x0
	// Bit mask of PSTAT0 field.
	GPIO_PIN_INT_IST_PSTAT0_Msk = 0x1
	// Bit PSTAT0.
	GPIO_PIN_INT_IST_PSTAT0 = 0x1
	// Position of PSTAT1 field.
	GPIO_PIN_INT_IST_PSTAT1_Pos = 0x1
	// Bit mask of PSTAT1 field.
	GPIO_PIN_INT_IST_PSTAT1_Msk = 0x2
	// Bit PSTAT1.
	GPIO_PIN_INT_IST_PSTAT1 = 0x2
	// Position of PSTAT2 field.
	GPIO_PIN_INT_IST_PSTAT2_Pos = 0x2
	// Bit mask of PSTAT2 field.
	GPIO_PIN_INT_IST_PSTAT2_Msk = 0x4
	// Bit PSTAT2.
	GPIO_PIN_INT_IST_PSTAT2 = 0x4
	// Position of PSTAT3 field.
	GPIO_PIN_INT_IST_PSTAT3_Pos = 0x3
	// Bit mask of PSTAT3 field.
	GPIO_PIN_INT_IST_PSTAT3_Msk = 0x8
	// Bit PSTAT3.
	GPIO_PIN_INT_IST_PSTAT3 = 0x8
	// Position of PSTAT4 field.
	GPIO_PIN_INT_IST_PSTAT4_Pos = 0x4
	// Bit mask of PSTAT4 field.
	GPIO_PIN_INT_IST_PSTAT4_Msk = 0x10
	// Bit PSTAT4.
	GPIO_PIN_INT_IST_PSTAT4 = 0x10
	// Position of PSTAT5 field.
	GPIO_PIN_INT_IST_PSTAT5_Pos = 0x5
	// Bit mask of PSTAT5 field.
	GPIO_PIN_INT_IST_PSTAT5_Msk = 0x20
	// Bit PSTAT5.
	GPIO_PIN_INT_IST_PSTAT5 = 0x20
	// Position of PSTAT6 field.
	GPIO_PIN_INT_IST_PSTAT6_Pos = 0x6
	// Bit mask of PSTAT6 field.
	GPIO_PIN_INT_IST_PSTAT6_Msk = 0x40
	// Bit PSTAT6.
	GPIO_PIN_INT_IST_PSTAT6 = 0x40
	// Position of PSTAT7 field.
	GPIO_PIN_INT_IST_PSTAT7_Pos = 0x7
	// Bit mask of PSTAT7 field.
	GPIO_PIN_INT_IST_PSTAT7_Msk = 0x80
	// Bit PSTAT7.
	GPIO_PIN_INT_IST_PSTAT7 = 0x80
	// Position of RESERVED field.
	GPIO_PIN_INT_IST_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPIO_PIN_INT_IST_RESERVED_Msk = 0xffffff00
)

// Constants for GPIO_GROUP_INT0: GPIO group interrupt 0
const (
	// CTRL: GPIO grouped interrupt control register
	// Position of INT field.
	GPIO_GROUP_INT0_CTRL_INT_Pos = 0x0
	// Bit mask of INT field.
	GPIO_GROUP_INT0_CTRL_INT_Msk = 0x1
	// Bit INT.
	GPIO_GROUP_INT0_CTRL_INT = 0x1
	// No interrupt request is pending.
	GPIO_GROUP_INT0_CTRL_INT_NO_INTERRUPT_REQUEST = 0x0
	// Interrupt request is active.
	GPIO_GROUP_INT0_CTRL_INT_INTERRUPT_REQUEST_IS = 0x1
	// Position of COMB field.
	GPIO_GROUP_INT0_CTRL_COMB_Pos = 0x1
	// Bit mask of COMB field.
	GPIO_GROUP_INT0_CTRL_COMB_Msk = 0x2
	// Bit COMB.
	GPIO_GROUP_INT0_CTRL_COMB = 0x2
	// OR functionality: A grouped interrupt is generated when any one of the enabled inputs is active (based on its programmed polarity).
	GPIO_GROUP_INT0_CTRL_COMB_OR_FUNCTIONALITY_A_ = 0x0
	// AND functionality: An interrupt is generated when all enabled bits are active (based on their programmed polarity).
	GPIO_GROUP_INT0_CTRL_COMB_AND_FUNCTIONALITY_A = 0x1
	// Position of TRIG field.
	GPIO_GROUP_INT0_CTRL_TRIG_Pos = 0x2
	// Bit mask of TRIG field.
	GPIO_GROUP_INT0_CTRL_TRIG_Msk = 0x4
	// Bit TRIG.
	GPIO_GROUP_INT0_CTRL_TRIG = 0x4
	// Edge-triggered
	GPIO_GROUP_INT0_CTRL_TRIG_EDGE_TRIGGERED = 0x0
	// Level-triggered
	GPIO_GROUP_INT0_CTRL_TRIG_LEVEL_TRIGGERED = 0x1
	// Position of RESERVED field.
	GPIO_GROUP_INT0_CTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	GPIO_GROUP_INT0_CTRL_RESERVED_Msk = 0xfffffff8

	// PORT_POL0: GPIO grouped interrupt port polarity register
	// Position of POL_0 field.
	GPIO_GROUP_INT0_PORT_POL_POL_0_Pos = 0x0
	// Bit mask of POL_0 field.
	GPIO_GROUP_INT0_PORT_POL_POL_0_Msk = 0x1
	// Bit POL_0.
	GPIO_GROUP_INT0_PORT_POL_POL_0 = 0x1
	// Position of POL_1 field.
	GPIO_GROUP_INT0_PORT_POL_POL_1_Pos = 0x1
	// Bit mask of POL_1 field.
	GPIO_GROUP_INT0_PORT_POL_POL_1_Msk = 0x2
	// Bit POL_1.
	GPIO_GROUP_INT0_PORT_POL_POL_1 = 0x2
	// Position of POL_2 field.
	GPIO_GROUP_INT0_PORT_POL_POL_2_Pos = 0x2
	// Bit mask of POL_2 field.
	GPIO_GROUP_INT0_PORT_POL_POL_2_Msk = 0x4
	// Bit POL_2.
	GPIO_GROUP_INT0_PORT_POL_POL_2 = 0x4
	// Position of POL_3 field.
	GPIO_GROUP_INT0_PORT_POL_POL_3_Pos = 0x3
	// Bit mask of POL_3 field.
	GPIO_GROUP_INT0_PORT_POL_POL_3_Msk = 0x8
	// Bit POL_3.
	GPIO_GROUP_INT0_PORT_POL_POL_3 = 0x8
	// Position of POL_4 field.
	GPIO_GROUP_INT0_PORT_POL_POL_4_Pos = 0x4
	// Bit mask of POL_4 field.
	GPIO_GROUP_INT0_PORT_POL_POL_4_Msk = 0x10
	// Bit POL_4.
	GPIO_GROUP_INT0_PORT_POL_POL_4 = 0x10
	// Position of POL_5 field.
	GPIO_GROUP_INT0_PORT_POL_POL_5_Pos = 0x5
	// Bit mask of POL_5 field.
	GPIO_GROUP_INT0_PORT_POL_POL_5_Msk = 0x20
	// Bit POL_5.
	GPIO_GROUP_INT0_PORT_POL_POL_5 = 0x20
	// Position of POL_6 field.
	GPIO_GROUP_INT0_PORT_POL_POL_6_Pos = 0x6
	// Bit mask of POL_6 field.
	GPIO_GROUP_INT0_PORT_POL_POL_6_Msk = 0x40
	// Bit POL_6.
	GPIO_GROUP_INT0_PORT_POL_POL_6 = 0x40
	// Position of POL_7 field.
	GPIO_GROUP_INT0_PORT_POL_POL_7_Pos = 0x7
	// Bit mask of POL_7 field.
	GPIO_GROUP_INT0_PORT_POL_POL_7_Msk = 0x80
	// Bit POL_7.
	GPIO_GROUP_INT0_PORT_POL_POL_7 = 0x80
	// Position of POL_8 field.
	GPIO_GROUP_INT0_PORT_POL_POL_8_Pos = 0x8
	// Bit mask of POL_8 field.
	GPIO_GROUP_INT0_PORT_POL_POL_8_Msk = 0x100
	// Bit POL_8.
	GPIO_GROUP_INT0_PORT_POL_POL_8 = 0x100
	// Position of POL_9 field.
	GPIO_GROUP_INT0_PORT_POL_POL_9_Pos = 0x9
	// Bit mask of POL_9 field.
	GPIO_GROUP_INT0_PORT_POL_POL_9_Msk = 0x200
	// Bit POL_9.
	GPIO_GROUP_INT0_PORT_POL_POL_9 = 0x200
	// Position of POL_10 field.
	GPIO_GROUP_INT0_PORT_POL_POL_10_Pos = 0xa
	// Bit mask of POL_10 field.
	GPIO_GROUP_INT0_PORT_POL_POL_10_Msk = 0x400
	// Bit POL_10.
	GPIO_GROUP_INT0_PORT_POL_POL_10 = 0x400
	// Position of POL_11 field.
	GPIO_GROUP_INT0_PORT_POL_POL_11_Pos = 0xb
	// Bit mask of POL_11 field.
	GPIO_GROUP_INT0_PORT_POL_POL_11_Msk = 0x800
	// Bit POL_11.
	GPIO_GROUP_INT0_PORT_POL_POL_11 = 0x800
	// Position of POL_12 field.
	GPIO_GROUP_INT0_PORT_POL_POL_12_Pos = 0xc
	// Bit mask of POL_12 field.
	GPIO_GROUP_INT0_PORT_POL_POL_12_Msk = 0x1000
	// Bit POL_12.
	GPIO_GROUP_INT0_PORT_POL_POL_12 = 0x1000
	// Position of POL_13 field.
	GPIO_GROUP_INT0_PORT_POL_POL_13_Pos = 0xd
	// Bit mask of POL_13 field.
	GPIO_GROUP_INT0_PORT_POL_POL_13_Msk = 0x2000
	// Bit POL_13.
	GPIO_GROUP_INT0_PORT_POL_POL_13 = 0x2000
	// Position of POL_14 field.
	GPIO_GROUP_INT0_PORT_POL_POL_14_Pos = 0xe
	// Bit mask of POL_14 field.
	GPIO_GROUP_INT0_PORT_POL_POL_14_Msk = 0x4000
	// Bit POL_14.
	GPIO_GROUP_INT0_PORT_POL_POL_14 = 0x4000
	// Position of POL_15 field.
	GPIO_GROUP_INT0_PORT_POL_POL_15_Pos = 0xf
	// Bit mask of POL_15 field.
	GPIO_GROUP_INT0_PORT_POL_POL_15_Msk = 0x8000
	// Bit POL_15.
	GPIO_GROUP_INT0_PORT_POL_POL_15 = 0x8000
	// Position of POL_16 field.
	GPIO_GROUP_INT0_PORT_POL_POL_16_Pos = 0x10
	// Bit mask of POL_16 field.
	GPIO_GROUP_INT0_PORT_POL_POL_16_Msk = 0x10000
	// Bit POL_16.
	GPIO_GROUP_INT0_PORT_POL_POL_16 = 0x10000
	// Position of POL_17 field.
	GPIO_GROUP_INT0_PORT_POL_POL_17_Pos = 0x11
	// Bit mask of POL_17 field.
	GPIO_GROUP_INT0_PORT_POL_POL_17_Msk = 0x20000
	// Bit POL_17.
	GPIO_GROUP_INT0_PORT_POL_POL_17 = 0x20000
	// Position of POL_18 field.
	GPIO_GROUP_INT0_PORT_POL_POL_18_Pos = 0x12
	// Bit mask of POL_18 field.
	GPIO_GROUP_INT0_PORT_POL_POL_18_Msk = 0x40000
	// Bit POL_18.
	GPIO_GROUP_INT0_PORT_POL_POL_18 = 0x40000
	// Position of POL_19 field.
	GPIO_GROUP_INT0_PORT_POL_POL_19_Pos = 0x13
	// Bit mask of POL_19 field.
	GPIO_GROUP_INT0_PORT_POL_POL_19_Msk = 0x80000
	// Bit POL_19.
	GPIO_GROUP_INT0_PORT_POL_POL_19 = 0x80000
	// Position of POL_20 field.
	GPIO_GROUP_INT0_PORT_POL_POL_20_Pos = 0x14
	// Bit mask of POL_20 field.
	GPIO_GROUP_INT0_PORT_POL_POL_20_Msk = 0x100000
	// Bit POL_20.
	GPIO_GROUP_INT0_PORT_POL_POL_20 = 0x100000
	// Position of POL_21 field.
	GPIO_GROUP_INT0_PORT_POL_POL_21_Pos = 0x15
	// Bit mask of POL_21 field.
	GPIO_GROUP_INT0_PORT_POL_POL_21_Msk = 0x200000
	// Bit POL_21.
	GPIO_GROUP_INT0_PORT_POL_POL_21 = 0x200000
	// Position of POL_22 field.
	GPIO_GROUP_INT0_PORT_POL_POL_22_Pos = 0x16
	// Bit mask of POL_22 field.
	GPIO_GROUP_INT0_PORT_POL_POL_22_Msk = 0x400000
	// Bit POL_22.
	GPIO_GROUP_INT0_PORT_POL_POL_22 = 0x400000
	// Position of POL_23 field.
	GPIO_GROUP_INT0_PORT_POL_POL_23_Pos = 0x17
	// Bit mask of POL_23 field.
	GPIO_GROUP_INT0_PORT_POL_POL_23_Msk = 0x800000
	// Bit POL_23.
	GPIO_GROUP_INT0_PORT_POL_POL_23 = 0x800000
	// Position of POL_24 field.
	GPIO_GROUP_INT0_PORT_POL_POL_24_Pos = 0x18
	// Bit mask of POL_24 field.
	GPIO_GROUP_INT0_PORT_POL_POL_24_Msk = 0x1000000
	// Bit POL_24.
	GPIO_GROUP_INT0_PORT_POL_POL_24 = 0x1000000
	// Position of POL_25 field.
	GPIO_GROUP_INT0_PORT_POL_POL_25_Pos = 0x19
	// Bit mask of POL_25 field.
	GPIO_GROUP_INT0_PORT_POL_POL_25_Msk = 0x2000000
	// Bit POL_25.
	GPIO_GROUP_INT0_PORT_POL_POL_25 = 0x2000000
	// Position of POL_26 field.
	GPIO_GROUP_INT0_PORT_POL_POL_26_Pos = 0x1a
	// Bit mask of POL_26 field.
	GPIO_GROUP_INT0_PORT_POL_POL_26_Msk = 0x4000000
	// Bit POL_26.
	GPIO_GROUP_INT0_PORT_POL_POL_26 = 0x4000000
	// Position of POL_27 field.
	GPIO_GROUP_INT0_PORT_POL_POL_27_Pos = 0x1b
	// Bit mask of POL_27 field.
	GPIO_GROUP_INT0_PORT_POL_POL_27_Msk = 0x8000000
	// Bit POL_27.
	GPIO_GROUP_INT0_PORT_POL_POL_27 = 0x8000000
	// Position of POL_28 field.
	GPIO_GROUP_INT0_PORT_POL_POL_28_Pos = 0x1c
	// Bit mask of POL_28 field.
	GPIO_GROUP_INT0_PORT_POL_POL_28_Msk = 0x10000000
	// Bit POL_28.
	GPIO_GROUP_INT0_PORT_POL_POL_28 = 0x10000000
	// Position of POL_29 field.
	GPIO_GROUP_INT0_PORT_POL_POL_29_Pos = 0x1d
	// Bit mask of POL_29 field.
	GPIO_GROUP_INT0_PORT_POL_POL_29_Msk = 0x20000000
	// Bit POL_29.
	GPIO_GROUP_INT0_PORT_POL_POL_29 = 0x20000000
	// Position of POL_30 field.
	GPIO_GROUP_INT0_PORT_POL_POL_30_Pos = 0x1e
	// Bit mask of POL_30 field.
	GPIO_GROUP_INT0_PORT_POL_POL_30_Msk = 0x40000000
	// Bit POL_30.
	GPIO_GROUP_INT0_PORT_POL_POL_30 = 0x40000000
	// Position of POL_31 field.
	GPIO_GROUP_INT0_PORT_POL_POL_31_Pos = 0x1f
	// Bit mask of POL_31 field.
	GPIO_GROUP_INT0_PORT_POL_POL_31_Msk = 0x80000000
	// Bit POL_31.
	GPIO_GROUP_INT0_PORT_POL_POL_31 = 0x80000000

	// PORT_ENA0: GPIO grouped interrupt port m enable register
	// Position of ENA_0 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_0_Pos = 0x0
	// Bit mask of ENA_0 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_0_Msk = 0x1
	// Bit ENA_0.
	GPIO_GROUP_INT0_PORT_ENA_ENA_0 = 0x1
	// Position of ENA_1 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_1_Pos = 0x1
	// Bit mask of ENA_1 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_1_Msk = 0x2
	// Bit ENA_1.
	GPIO_GROUP_INT0_PORT_ENA_ENA_1 = 0x2
	// Position of ENA_2 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_2_Pos = 0x2
	// Bit mask of ENA_2 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_2_Msk = 0x4
	// Bit ENA_2.
	GPIO_GROUP_INT0_PORT_ENA_ENA_2 = 0x4
	// Position of ENA_3 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_3_Pos = 0x3
	// Bit mask of ENA_3 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_3_Msk = 0x8
	// Bit ENA_3.
	GPIO_GROUP_INT0_PORT_ENA_ENA_3 = 0x8
	// Position of ENA_4 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_4_Pos = 0x4
	// Bit mask of ENA_4 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_4_Msk = 0x10
	// Bit ENA_4.
	GPIO_GROUP_INT0_PORT_ENA_ENA_4 = 0x10
	// Position of ENA_5 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_5_Pos = 0x5
	// Bit mask of ENA_5 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_5_Msk = 0x20
	// Bit ENA_5.
	GPIO_GROUP_INT0_PORT_ENA_ENA_5 = 0x20
	// Position of ENA_6 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_6_Pos = 0x6
	// Bit mask of ENA_6 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_6_Msk = 0x40
	// Bit ENA_6.
	GPIO_GROUP_INT0_PORT_ENA_ENA_6 = 0x40
	// Position of ENA_7 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_7_Pos = 0x7
	// Bit mask of ENA_7 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_7_Msk = 0x80
	// Bit ENA_7.
	GPIO_GROUP_INT0_PORT_ENA_ENA_7 = 0x80
	// Position of ENA_8 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_8_Pos = 0x8
	// Bit mask of ENA_8 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_8_Msk = 0x100
	// Bit ENA_8.
	GPIO_GROUP_INT0_PORT_ENA_ENA_8 = 0x100
	// Position of ENA_9 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_9_Pos = 0x9
	// Bit mask of ENA_9 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_9_Msk = 0x200
	// Bit ENA_9.
	GPIO_GROUP_INT0_PORT_ENA_ENA_9 = 0x200
	// Position of ENA_10 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_10_Pos = 0xa
	// Bit mask of ENA_10 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_10_Msk = 0x400
	// Bit ENA_10.
	GPIO_GROUP_INT0_PORT_ENA_ENA_10 = 0x400
	// Position of ENA_11 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_11_Pos = 0xb
	// Bit mask of ENA_11 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_11_Msk = 0x800
	// Bit ENA_11.
	GPIO_GROUP_INT0_PORT_ENA_ENA_11 = 0x800
	// Position of ENA_12 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_12_Pos = 0xc
	// Bit mask of ENA_12 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_12_Msk = 0x1000
	// Bit ENA_12.
	GPIO_GROUP_INT0_PORT_ENA_ENA_12 = 0x1000
	// Position of ENA_13 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_13_Pos = 0xd
	// Bit mask of ENA_13 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_13_Msk = 0x2000
	// Bit ENA_13.
	GPIO_GROUP_INT0_PORT_ENA_ENA_13 = 0x2000
	// Position of ENA_14 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_14_Pos = 0xe
	// Bit mask of ENA_14 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_14_Msk = 0x4000
	// Bit ENA_14.
	GPIO_GROUP_INT0_PORT_ENA_ENA_14 = 0x4000
	// Position of ENA_15 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_15_Pos = 0xf
	// Bit mask of ENA_15 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_15_Msk = 0x8000
	// Bit ENA_15.
	GPIO_GROUP_INT0_PORT_ENA_ENA_15 = 0x8000
	// Position of ENA_16 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_16_Pos = 0x10
	// Bit mask of ENA_16 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_16_Msk = 0x10000
	// Bit ENA_16.
	GPIO_GROUP_INT0_PORT_ENA_ENA_16 = 0x10000
	// Position of ENA_17 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_17_Pos = 0x11
	// Bit mask of ENA_17 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_17_Msk = 0x20000
	// Bit ENA_17.
	GPIO_GROUP_INT0_PORT_ENA_ENA_17 = 0x20000
	// Position of ENA_18 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_18_Pos = 0x12
	// Bit mask of ENA_18 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_18_Msk = 0x40000
	// Bit ENA_18.
	GPIO_GROUP_INT0_PORT_ENA_ENA_18 = 0x40000
	// Position of ENA_19 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_19_Pos = 0x13
	// Bit mask of ENA_19 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_19_Msk = 0x80000
	// Bit ENA_19.
	GPIO_GROUP_INT0_PORT_ENA_ENA_19 = 0x80000
	// Position of ENA_20 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_20_Pos = 0x14
	// Bit mask of ENA_20 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_20_Msk = 0x100000
	// Bit ENA_20.
	GPIO_GROUP_INT0_PORT_ENA_ENA_20 = 0x100000
	// Position of ENA_21 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_21_Pos = 0x15
	// Bit mask of ENA_21 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_21_Msk = 0x200000
	// Bit ENA_21.
	GPIO_GROUP_INT0_PORT_ENA_ENA_21 = 0x200000
	// Position of ENA_22 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_22_Pos = 0x16
	// Bit mask of ENA_22 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_22_Msk = 0x400000
	// Bit ENA_22.
	GPIO_GROUP_INT0_PORT_ENA_ENA_22 = 0x400000
	// Position of ENA_23 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_23_Pos = 0x17
	// Bit mask of ENA_23 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_23_Msk = 0x800000
	// Bit ENA_23.
	GPIO_GROUP_INT0_PORT_ENA_ENA_23 = 0x800000
	// Position of ENA_24 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_24_Pos = 0x18
	// Bit mask of ENA_24 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_24_Msk = 0x1000000
	// Bit ENA_24.
	GPIO_GROUP_INT0_PORT_ENA_ENA_24 = 0x1000000
	// Position of ENA_25 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_25_Pos = 0x19
	// Bit mask of ENA_25 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_25_Msk = 0x2000000
	// Bit ENA_25.
	GPIO_GROUP_INT0_PORT_ENA_ENA_25 = 0x2000000
	// Position of ENA_26 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_26_Pos = 0x1a
	// Bit mask of ENA_26 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_26_Msk = 0x4000000
	// Bit ENA_26.
	GPIO_GROUP_INT0_PORT_ENA_ENA_26 = 0x4000000
	// Position of ENA_27 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_27_Pos = 0x1b
	// Bit mask of ENA_27 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_27_Msk = 0x8000000
	// Bit ENA_27.
	GPIO_GROUP_INT0_PORT_ENA_ENA_27 = 0x8000000
	// Position of ENA_28 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_28_Pos = 0x1c
	// Bit mask of ENA_28 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_28_Msk = 0x10000000
	// Bit ENA_28.
	GPIO_GROUP_INT0_PORT_ENA_ENA_28 = 0x10000000
	// Position of ENA_29 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_29_Pos = 0x1d
	// Bit mask of ENA_29 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_29_Msk = 0x20000000
	// Bit ENA_29.
	GPIO_GROUP_INT0_PORT_ENA_ENA_29 = 0x20000000
	// Position of ENA_30 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_30_Pos = 0x1e
	// Bit mask of ENA_30 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_30_Msk = 0x40000000
	// Bit ENA_30.
	GPIO_GROUP_INT0_PORT_ENA_ENA_30 = 0x40000000
	// Position of ENA_31 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_31_Pos = 0x1f
	// Bit mask of ENA_31 field.
	GPIO_GROUP_INT0_PORT_ENA_ENA_31_Msk = 0x80000000
	// Bit ENA_31.
	GPIO_GROUP_INT0_PORT_ENA_ENA_31 = 0x80000000
)

// Constants for MCPWM: Motor Control PWM (MOTOCONPWM)
const (
	// CON: PWM Control read address
	// Position of RUN0 field.
	MCPWM_CON_RUN0_Pos = 0x0
	// Bit mask of RUN0 field.
	MCPWM_CON_RUN0_Msk = 0x1
	// Bit RUN0.
	MCPWM_CON_RUN0 = 0x1
	// Stop.
	MCPWM_CON_RUN0_STOP_ = 0x0
	// Run.
	MCPWM_CON_RUN0_RUN_ = 0x1
	// Position of CENTER0 field.
	MCPWM_CON_CENTER0_Pos = 0x1
	// Bit mask of CENTER0 field.
	MCPWM_CON_CENTER0_Msk = 0x2
	// Bit CENTER0.
	MCPWM_CON_CENTER0 = 0x2
	// Edge-aligned.
	MCPWM_CON_CENTER0_EDGE_ALIGNED_ = 0x0
	// Center-aligned.
	MCPWM_CON_CENTER0_CENTER_ALIGNED_ = 0x1
	// Position of POLA0 field.
	MCPWM_CON_POLA0_Pos = 0x2
	// Bit mask of POLA0 field.
	MCPWM_CON_POLA0_Msk = 0x4
	// Bit POLA0.
	MCPWM_CON_POLA0 = 0x4
	// Passive state is LOW, active state is HIGH.
	MCPWM_CON_POLA0_PASSIVE_STATE_IS_LOW = 0x0
	// Passive state is HIGH, active state is LOW.
	MCPWM_CON_POLA0_PASSIVE_STATE_IS_HIG = 0x1
	// Position of DTE0 field.
	MCPWM_CON_DTE0_Pos = 0x3
	// Bit mask of DTE0 field.
	MCPWM_CON_DTE0_Msk = 0x8
	// Bit DTE0.
	MCPWM_CON_DTE0 = 0x8
	// Dead-time disabled.
	MCPWM_CON_DTE0_DEAD_TIME_DISABLED_ = 0x0
	// Dead-time enabled.
	MCPWM_CON_DTE0_DEAD_TIME_ENABLED_ = 0x1
	// Position of DISUP0 field.
	MCPWM_CON_DISUP0_Pos = 0x4
	// Bit mask of DISUP0 field.
	MCPWM_CON_DISUP0_Msk = 0x10
	// Bit DISUP0.
	MCPWM_CON_DISUP0 = 0x10
	// Functional registers are updated from the write registers at the end of each PWM cycle.
	MCPWM_CON_DISUP0_UPDATE = 0x0
	// Functional registers remain the same as long as the timer is running.
	MCPWM_CON_DISUP0_NOUPDATE = 0x1
	// Position of RESERVED field.
	MCPWM_CON_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	MCPWM_CON_RESERVED_Msk = 0xe0
	// Position of RUN1 field.
	MCPWM_CON_RUN1_Pos = 0x8
	// Bit mask of RUN1 field.
	MCPWM_CON_RUN1_Msk = 0x100
	// Bit RUN1.
	MCPWM_CON_RUN1 = 0x100
	// Stop.
	MCPWM_CON_RUN1_STOP_ = 0x0
	// Run.
	MCPWM_CON_RUN1_RUN_ = 0x1
	// Position of CENTER1 field.
	MCPWM_CON_CENTER1_Pos = 0x9
	// Bit mask of CENTER1 field.
	MCPWM_CON_CENTER1_Msk = 0x200
	// Bit CENTER1.
	MCPWM_CON_CENTER1 = 0x200
	// Edge-aligned.
	MCPWM_CON_CENTER1_EDGE_ALIGNED_ = 0x0
	// Center-aligned.
	MCPWM_CON_CENTER1_CENTER_ALIGNED_ = 0x1
	// Position of POLA1 field.
	MCPWM_CON_POLA1_Pos = 0xa
	// Bit mask of POLA1 field.
	MCPWM_CON_POLA1_Msk = 0x400
	// Bit POLA1.
	MCPWM_CON_POLA1 = 0x400
	// Passive state is LOW, active state is HIGH.
	MCPWM_CON_POLA1_PASSIVE_STATE_IS_LOW = 0x0
	// Passive state is HIGH, active state is LOW.
	MCPWM_CON_POLA1_PASSIVE_STATE_IS_HIG = 0x1
	// Position of DTE1 field.
	MCPWM_CON_DTE1_Pos = 0xb
	// Bit mask of DTE1 field.
	MCPWM_CON_DTE1_Msk = 0x800
	// Bit DTE1.
	MCPWM_CON_DTE1 = 0x800
	// Dead-time disabled.
	MCPWM_CON_DTE1_DEAD_TIME_DISABLED_ = 0x0
	// Dead-time enabled.
	MCPWM_CON_DTE1_DEAD_TIME_ENABLED_ = 0x1
	// Position of DISUP1 field.
	MCPWM_CON_DISUP1_Pos = 0xc
	// Bit mask of DISUP1 field.
	MCPWM_CON_DISUP1_Msk = 0x1000
	// Bit DISUP1.
	MCPWM_CON_DISUP1 = 0x1000
	// Functional registers are updated from the write registers at the end of each PWM cycle.
	MCPWM_CON_DISUP1_UPDATE = 0x0
	// Functional registers remain the same as long as the timer is running.
	MCPWM_CON_DISUP1_NOUPDATE = 0x1
	// Position of RESERVED field.
	MCPWM_CON_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	MCPWM_CON_RESERVED_Msk = 0xe000
	// Position of RUN2 field.
	MCPWM_CON_RUN2_Pos = 0x10
	// Bit mask of RUN2 field.
	MCPWM_CON_RUN2_Msk = 0x10000
	// Bit RUN2.
	MCPWM_CON_RUN2 = 0x10000
	// Stop.
	MCPWM_CON_RUN2_STOP_ = 0x0
	// Run.
	MCPWM_CON_RUN2_RUN_ = 0x1
	// Position of CENTER2 field.
	MCPWM_CON_CENTER2_Pos = 0x11
	// Bit mask of CENTER2 field.
	MCPWM_CON_CENTER2_Msk = 0x20000
	// Bit CENTER2.
	MCPWM_CON_CENTER2 = 0x20000
	// Edge-aligned.
	MCPWM_CON_CENTER2_EDGE_ALIGNED_ = 0x0
	// Center-aligned.
	MCPWM_CON_CENTER2_CENTER_ALIGNED_ = 0x1
	// Position of POLA2 field.
	MCPWM_CON_POLA2_Pos = 0x12
	// Bit mask of POLA2 field.
	MCPWM_CON_POLA2_Msk = 0x40000
	// Bit POLA2.
	MCPWM_CON_POLA2 = 0x40000
	// Passive state is LOW, active state is HIGH.
	MCPWM_CON_POLA2_PASSIVE_STATE_IS_LOW = 0x0
	// Passive state is HIGH, active state is LOW.
	MCPWM_CON_POLA2_PASSIVE_STATE_IS_HIG = 0x1
	// Position of DTE2 field.
	MCPWM_CON_DTE2_Pos = 0x13
	// Bit mask of DTE2 field.
	MCPWM_CON_DTE2_Msk = 0x80000
	// Bit DTE2.
	MCPWM_CON_DTE2 = 0x80000
	// Dead-time disabled.
	MCPWM_CON_DTE2_DEAD_TIME_DISABLED_ = 0x0
	// Dead-time enabled.
	MCPWM_CON_DTE2_DEAD_TIME_ENABLED_ = 0x1
	// Position of DISUP2 field.
	MCPWM_CON_DISUP2_Pos = 0x14
	// Bit mask of DISUP2 field.
	MCPWM_CON_DISUP2_Msk = 0x100000
	// Bit DISUP2.
	MCPWM_CON_DISUP2 = 0x100000
	// Functional registers are updated from the write registers at the end of each PWM cycle.
	MCPWM_CON_DISUP2_UPDATE = 0x0
	// Functional registers remain the same as long as the timer is running.
	MCPWM_CON_DISUP2_NOUPDATE = 0x1
	// Position of RESERVED field.
	MCPWM_CON_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CON_RESERVED_Msk = 0x1fe00000
	// Position of INVBDC field.
	MCPWM_CON_INVBDC_Pos = 0x1d
	// Bit mask of INVBDC field.
	MCPWM_CON_INVBDC_Msk = 0x20000000
	// Bit INVBDC.
	MCPWM_CON_INVBDC = 0x20000000
	// The MCOB outputs have opposite polarity from the MCOA outputs (aside from dead time).
	MCPWM_CON_INVBDC_OPPOSITE = 0x0
	// The MCOB outputs have the same basic polarity as the MCOA outputs. (see Section 24.8.6)
	MCPWM_CON_INVBDC_SAME = 0x1
	// Position of ACMODE field.
	MCPWM_CON_ACMODE_Pos = 0x1e
	// Bit mask of ACMODE field.
	MCPWM_CON_ACMODE_Msk = 0x40000000
	// Bit ACMODE.
	MCPWM_CON_ACMODE = 0x40000000
	// 3-phase AC-mode off: Each PWM channel uses its own timer-counter and period register.
	MCPWM_CON_ACMODE_3_PHASE_AC_MODE_OFF = 0x0
	// 3-phase AC-mode on: All PWM channels use the timer-counter and period register of channel 0.
	MCPWM_CON_ACMODE_3_PHASE_AC_MODE_ON_ = 0x1
	// Position of DCMODE field.
	MCPWM_CON_DCMODE_Pos = 0x1f
	// Bit mask of DCMODE field.
	MCPWM_CON_DCMODE_Msk = 0x80000000
	// Bit DCMODE.
	MCPWM_CON_DCMODE = 0x80000000
	// 3-phase DC mode off: PWM channels are independent (unless bit ACMODE = 1)
	MCPWM_CON_DCMODE_3_PHASE_DC_MODE_OFF = 0x0
	// 3-phase DC mode on: The internal MCOA0 output is routed through the CP register (i.e. a mask) register to all six PWM outputs.
	MCPWM_CON_DCMODE_3_PHASE_DC_MODE_ON_ = 0x1

	// CON_SET: PWM Control set address
	// Position of RUN0_SET field.
	MCPWM_CON_SET_RUN0_SET_Pos = 0x0
	// Bit mask of RUN0_SET field.
	MCPWM_CON_SET_RUN0_SET_Msk = 0x1
	// Bit RUN0_SET.
	MCPWM_CON_SET_RUN0_SET = 0x1
	// Position of CENTER0_SET field.
	MCPWM_CON_SET_CENTER0_SET_Pos = 0x1
	// Bit mask of CENTER0_SET field.
	MCPWM_CON_SET_CENTER0_SET_Msk = 0x2
	// Bit CENTER0_SET.
	MCPWM_CON_SET_CENTER0_SET = 0x2
	// Position of POLA0_SET field.
	MCPWM_CON_SET_POLA0_SET_Pos = 0x2
	// Bit mask of POLA0_SET field.
	MCPWM_CON_SET_POLA0_SET_Msk = 0x4
	// Bit POLA0_SET.
	MCPWM_CON_SET_POLA0_SET = 0x4
	// Position of DTE0_SET field.
	MCPWM_CON_SET_DTE0_SET_Pos = 0x3
	// Bit mask of DTE0_SET field.
	MCPWM_CON_SET_DTE0_SET_Msk = 0x8
	// Bit DTE0_SET.
	MCPWM_CON_SET_DTE0_SET = 0x8
	// Position of DISUP0_SET field.
	MCPWM_CON_SET_DISUP0_SET_Pos = 0x4
	// Bit mask of DISUP0_SET field.
	MCPWM_CON_SET_DISUP0_SET_Msk = 0x10
	// Bit DISUP0_SET.
	MCPWM_CON_SET_DISUP0_SET = 0x10
	// Position of RESERVED field.
	MCPWM_CON_SET_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	MCPWM_CON_SET_RESERVED_Msk = 0xe0
	// Position of RUN1_SET field.
	MCPWM_CON_SET_RUN1_SET_Pos = 0x8
	// Bit mask of RUN1_SET field.
	MCPWM_CON_SET_RUN1_SET_Msk = 0x100
	// Bit RUN1_SET.
	MCPWM_CON_SET_RUN1_SET = 0x100
	// Position of CENTER1_SET field.
	MCPWM_CON_SET_CENTER1_SET_Pos = 0x9
	// Bit mask of CENTER1_SET field.
	MCPWM_CON_SET_CENTER1_SET_Msk = 0x200
	// Bit CENTER1_SET.
	MCPWM_CON_SET_CENTER1_SET = 0x200
	// Position of POLA1_SET field.
	MCPWM_CON_SET_POLA1_SET_Pos = 0xa
	// Bit mask of POLA1_SET field.
	MCPWM_CON_SET_POLA1_SET_Msk = 0x400
	// Bit POLA1_SET.
	MCPWM_CON_SET_POLA1_SET = 0x400
	// Position of DTE1_SET field.
	MCPWM_CON_SET_DTE1_SET_Pos = 0xb
	// Bit mask of DTE1_SET field.
	MCPWM_CON_SET_DTE1_SET_Msk = 0x800
	// Bit DTE1_SET.
	MCPWM_CON_SET_DTE1_SET = 0x800
	// Position of DISUP1_SET field.
	MCPWM_CON_SET_DISUP1_SET_Pos = 0xc
	// Bit mask of DISUP1_SET field.
	MCPWM_CON_SET_DISUP1_SET_Msk = 0x1000
	// Bit DISUP1_SET.
	MCPWM_CON_SET_DISUP1_SET = 0x1000
	// Position of RESERVED field.
	MCPWM_CON_SET_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	MCPWM_CON_SET_RESERVED_Msk = 0xe000
	// Position of RUN2_SET field.
	MCPWM_CON_SET_RUN2_SET_Pos = 0x10
	// Bit mask of RUN2_SET field.
	MCPWM_CON_SET_RUN2_SET_Msk = 0x10000
	// Bit RUN2_SET.
	MCPWM_CON_SET_RUN2_SET = 0x10000
	// Position of CENTER2_SET field.
	MCPWM_CON_SET_CENTER2_SET_Pos = 0x11
	// Bit mask of CENTER2_SET field.
	MCPWM_CON_SET_CENTER2_SET_Msk = 0x20000
	// Bit CENTER2_SET.
	MCPWM_CON_SET_CENTER2_SET = 0x20000
	// Position of POLA2_SET field.
	MCPWM_CON_SET_POLA2_SET_Pos = 0x12
	// Bit mask of POLA2_SET field.
	MCPWM_CON_SET_POLA2_SET_Msk = 0x40000
	// Bit POLA2_SET.
	MCPWM_CON_SET_POLA2_SET = 0x40000
	// Position of DTE2_SET field.
	MCPWM_CON_SET_DTE2_SET_Pos = 0x13
	// Bit mask of DTE2_SET field.
	MCPWM_CON_SET_DTE2_SET_Msk = 0x80000
	// Bit DTE2_SET.
	MCPWM_CON_SET_DTE2_SET = 0x80000
	// Position of DISUP2_SET field.
	MCPWM_CON_SET_DISUP2_SET_Pos = 0x14
	// Bit mask of DISUP2_SET field.
	MCPWM_CON_SET_DISUP2_SET_Msk = 0x100000
	// Bit DISUP2_SET.
	MCPWM_CON_SET_DISUP2_SET = 0x100000
	// Position of RESERVED field.
	MCPWM_CON_SET_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CON_SET_RESERVED_Msk = 0x1fe00000
	// Position of INVBDC_SET field.
	MCPWM_CON_SET_INVBDC_SET_Pos = 0x1d
	// Bit mask of INVBDC_SET field.
	MCPWM_CON_SET_INVBDC_SET_Msk = 0x20000000
	// Bit INVBDC_SET.
	MCPWM_CON_SET_INVBDC_SET = 0x20000000
	// Position of ACMODE_SET field.
	MCPWM_CON_SET_ACMODE_SET_Pos = 0x1e
	// Bit mask of ACMODE_SET field.
	MCPWM_CON_SET_ACMODE_SET_Msk = 0x40000000
	// Bit ACMODE_SET.
	MCPWM_CON_SET_ACMODE_SET = 0x40000000
	// Position of DCMODE_SET field.
	MCPWM_CON_SET_DCMODE_SET_Pos = 0x1f
	// Bit mask of DCMODE_SET field.
	MCPWM_CON_SET_DCMODE_SET_Msk = 0x80000000
	// Bit DCMODE_SET.
	MCPWM_CON_SET_DCMODE_SET = 0x80000000

	// CON_CLR: PWM Control clear address
	// Position of RUN0_CLR field.
	MCPWM_CON_CLR_RUN0_CLR_Pos = 0x0
	// Bit mask of RUN0_CLR field.
	MCPWM_CON_CLR_RUN0_CLR_Msk = 0x1
	// Bit RUN0_CLR.
	MCPWM_CON_CLR_RUN0_CLR = 0x1
	// Position of CENTER0_CLR field.
	MCPWM_CON_CLR_CENTER0_CLR_Pos = 0x1
	// Bit mask of CENTER0_CLR field.
	MCPWM_CON_CLR_CENTER0_CLR_Msk = 0x2
	// Bit CENTER0_CLR.
	MCPWM_CON_CLR_CENTER0_CLR = 0x2
	// Position of POLA0_CLR field.
	MCPWM_CON_CLR_POLA0_CLR_Pos = 0x2
	// Bit mask of POLA0_CLR field.
	MCPWM_CON_CLR_POLA0_CLR_Msk = 0x4
	// Bit POLA0_CLR.
	MCPWM_CON_CLR_POLA0_CLR = 0x4
	// Position of DTE0_CLR field.
	MCPWM_CON_CLR_DTE0_CLR_Pos = 0x3
	// Bit mask of DTE0_CLR field.
	MCPWM_CON_CLR_DTE0_CLR_Msk = 0x8
	// Bit DTE0_CLR.
	MCPWM_CON_CLR_DTE0_CLR = 0x8
	// Position of DISUP0_CLR field.
	MCPWM_CON_CLR_DISUP0_CLR_Pos = 0x4
	// Bit mask of DISUP0_CLR field.
	MCPWM_CON_CLR_DISUP0_CLR_Msk = 0x10
	// Bit DISUP0_CLR.
	MCPWM_CON_CLR_DISUP0_CLR = 0x10
	// Position of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Msk = 0xe0
	// Position of RUN1_CLR field.
	MCPWM_CON_CLR_RUN1_CLR_Pos = 0x8
	// Bit mask of RUN1_CLR field.
	MCPWM_CON_CLR_RUN1_CLR_Msk = 0x100
	// Bit RUN1_CLR.
	MCPWM_CON_CLR_RUN1_CLR = 0x100
	// Position of CENTER1_CLR field.
	MCPWM_CON_CLR_CENTER1_CLR_Pos = 0x9
	// Bit mask of CENTER1_CLR field.
	MCPWM_CON_CLR_CENTER1_CLR_Msk = 0x200
	// Bit CENTER1_CLR.
	MCPWM_CON_CLR_CENTER1_CLR = 0x200
	// Position of POLA1_CLR field.
	MCPWM_CON_CLR_POLA1_CLR_Pos = 0xa
	// Bit mask of POLA1_CLR field.
	MCPWM_CON_CLR_POLA1_CLR_Msk = 0x400
	// Bit POLA1_CLR.
	MCPWM_CON_CLR_POLA1_CLR = 0x400
	// Position of DTE1_CLR field.
	MCPWM_CON_CLR_DTE1_CLR_Pos = 0xb
	// Bit mask of DTE1_CLR field.
	MCPWM_CON_CLR_DTE1_CLR_Msk = 0x800
	// Bit DTE1_CLR.
	MCPWM_CON_CLR_DTE1_CLR = 0x800
	// Position of DISUP1_CLR field.
	MCPWM_CON_CLR_DISUP1_CLR_Pos = 0xc
	// Bit mask of DISUP1_CLR field.
	MCPWM_CON_CLR_DISUP1_CLR_Msk = 0x1000
	// Bit DISUP1_CLR.
	MCPWM_CON_CLR_DISUP1_CLR = 0x1000
	// Position of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Msk = 0xe000
	// Position of RUN2_CLR field.
	MCPWM_CON_CLR_RUN2_CLR_Pos = 0x10
	// Bit mask of RUN2_CLR field.
	MCPWM_CON_CLR_RUN2_CLR_Msk = 0x10000
	// Bit RUN2_CLR.
	MCPWM_CON_CLR_RUN2_CLR = 0x10000
	// Position of CENTER2_CLR field.
	MCPWM_CON_CLR_CENTER2_CLR_Pos = 0x11
	// Bit mask of CENTER2_CLR field.
	MCPWM_CON_CLR_CENTER2_CLR_Msk = 0x20000
	// Bit CENTER2_CLR.
	MCPWM_CON_CLR_CENTER2_CLR = 0x20000
	// Position of POLA2_CLR field.
	MCPWM_CON_CLR_POLA2_CLR_Pos = 0x12
	// Bit mask of POLA2_CLR field.
	MCPWM_CON_CLR_POLA2_CLR_Msk = 0x40000
	// Bit POLA2_CLR.
	MCPWM_CON_CLR_POLA2_CLR = 0x40000
	// Position of DTE2_CLR field.
	MCPWM_CON_CLR_DTE2_CLR_Pos = 0x13
	// Bit mask of DTE2_CLR field.
	MCPWM_CON_CLR_DTE2_CLR_Msk = 0x80000
	// Bit DTE2_CLR.
	MCPWM_CON_CLR_DTE2_CLR = 0x80000
	// Position of DISUP2_CLR field.
	MCPWM_CON_CLR_DISUP2_CLR_Pos = 0x14
	// Bit mask of DISUP2_CLR field.
	MCPWM_CON_CLR_DISUP2_CLR_Msk = 0x100000
	// Bit DISUP2_CLR.
	MCPWM_CON_CLR_DISUP2_CLR = 0x100000
	// Position of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Msk = 0x1fe00000
	// Position of INVBDC_CLR field.
	MCPWM_CON_CLR_INVBDC_CLR_Pos = 0x1d
	// Bit mask of INVBDC_CLR field.
	MCPWM_CON_CLR_INVBDC_CLR_Msk = 0x20000000
	// Bit INVBDC_CLR.
	MCPWM_CON_CLR_INVBDC_CLR = 0x20000000
	// Position of ACMOD_CLR field.
	MCPWM_CON_CLR_ACMOD_CLR_Pos = 0x1e
	// Bit mask of ACMOD_CLR field.
	MCPWM_CON_CLR_ACMOD_CLR_Msk = 0x40000000
	// Bit ACMOD_CLR.
	MCPWM_CON_CLR_ACMOD_CLR = 0x40000000
	// Position of DCMODE_CLR field.
	MCPWM_CON_CLR_DCMODE_CLR_Pos = 0x1f
	// Bit mask of DCMODE_CLR field.
	MCPWM_CON_CLR_DCMODE_CLR_Msk = 0x80000000
	// Bit DCMODE_CLR.
	MCPWM_CON_CLR_DCMODE_CLR = 0x80000000

	// CAPCON: Capture Control read address
	// Position of CAP0MCI0_RE field.
	MCPWM_CAPCON_CAP0MCI0_RE_Pos = 0x0
	// Bit mask of CAP0MCI0_RE field.
	MCPWM_CAPCON_CAP0MCI0_RE_Msk = 0x1
	// Bit CAP0MCI0_RE.
	MCPWM_CAPCON_CAP0MCI0_RE = 0x1
	// Position of CAP0MCI0_FE field.
	MCPWM_CAPCON_CAP0MCI0_FE_Pos = 0x1
	// Bit mask of CAP0MCI0_FE field.
	MCPWM_CAPCON_CAP0MCI0_FE_Msk = 0x2
	// Bit CAP0MCI0_FE.
	MCPWM_CAPCON_CAP0MCI0_FE = 0x2
	// Position of CAP0MCI1_RE field.
	MCPWM_CAPCON_CAP0MCI1_RE_Pos = 0x2
	// Bit mask of CAP0MCI1_RE field.
	MCPWM_CAPCON_CAP0MCI1_RE_Msk = 0x4
	// Bit CAP0MCI1_RE.
	MCPWM_CAPCON_CAP0MCI1_RE = 0x4
	// Position of CAP0MCI1_FE field.
	MCPWM_CAPCON_CAP0MCI1_FE_Pos = 0x3
	// Bit mask of CAP0MCI1_FE field.
	MCPWM_CAPCON_CAP0MCI1_FE_Msk = 0x8
	// Bit CAP0MCI1_FE.
	MCPWM_CAPCON_CAP0MCI1_FE = 0x8
	// Position of CAP0MCI2_RE field.
	MCPWM_CAPCON_CAP0MCI2_RE_Pos = 0x4
	// Bit mask of CAP0MCI2_RE field.
	MCPWM_CAPCON_CAP0MCI2_RE_Msk = 0x10
	// Bit CAP0MCI2_RE.
	MCPWM_CAPCON_CAP0MCI2_RE = 0x10
	// Position of CAP0MCI2_FE field.
	MCPWM_CAPCON_CAP0MCI2_FE_Pos = 0x5
	// Bit mask of CAP0MCI2_FE field.
	MCPWM_CAPCON_CAP0MCI2_FE_Msk = 0x20
	// Bit CAP0MCI2_FE.
	MCPWM_CAPCON_CAP0MCI2_FE = 0x20
	// Position of CAP1MCI0_RE field.
	MCPWM_CAPCON_CAP1MCI0_RE_Pos = 0x6
	// Bit mask of CAP1MCI0_RE field.
	MCPWM_CAPCON_CAP1MCI0_RE_Msk = 0x40
	// Bit CAP1MCI0_RE.
	MCPWM_CAPCON_CAP1MCI0_RE = 0x40
	// Position of CAP1MCI0_FE field.
	MCPWM_CAPCON_CAP1MCI0_FE_Pos = 0x7
	// Bit mask of CAP1MCI0_FE field.
	MCPWM_CAPCON_CAP1MCI0_FE_Msk = 0x80
	// Bit CAP1MCI0_FE.
	MCPWM_CAPCON_CAP1MCI0_FE = 0x80
	// Position of CAP1MCI1_RE field.
	MCPWM_CAPCON_CAP1MCI1_RE_Pos = 0x8
	// Bit mask of CAP1MCI1_RE field.
	MCPWM_CAPCON_CAP1MCI1_RE_Msk = 0x100
	// Bit CAP1MCI1_RE.
	MCPWM_CAPCON_CAP1MCI1_RE = 0x100
	// Position of CAP1MCI1_FE field.
	MCPWM_CAPCON_CAP1MCI1_FE_Pos = 0x9
	// Bit mask of CAP1MCI1_FE field.
	MCPWM_CAPCON_CAP1MCI1_FE_Msk = 0x200
	// Bit CAP1MCI1_FE.
	MCPWM_CAPCON_CAP1MCI1_FE = 0x200
	// Position of CAP1MCI2_RE field.
	MCPWM_CAPCON_CAP1MCI2_RE_Pos = 0xa
	// Bit mask of CAP1MCI2_RE field.
	MCPWM_CAPCON_CAP1MCI2_RE_Msk = 0x400
	// Bit CAP1MCI2_RE.
	MCPWM_CAPCON_CAP1MCI2_RE = 0x400
	// Position of CAP1MCI2_FE field.
	MCPWM_CAPCON_CAP1MCI2_FE_Pos = 0xb
	// Bit mask of CAP1MCI2_FE field.
	MCPWM_CAPCON_CAP1MCI2_FE_Msk = 0x800
	// Bit CAP1MCI2_FE.
	MCPWM_CAPCON_CAP1MCI2_FE = 0x800
	// Position of CAP2MCI0_RE field.
	MCPWM_CAPCON_CAP2MCI0_RE_Pos = 0xc
	// Bit mask of CAP2MCI0_RE field.
	MCPWM_CAPCON_CAP2MCI0_RE_Msk = 0x1000
	// Bit CAP2MCI0_RE.
	MCPWM_CAPCON_CAP2MCI0_RE = 0x1000
	// Position of CAP2MCI0_FE field.
	MCPWM_CAPCON_CAP2MCI0_FE_Pos = 0xd
	// Bit mask of CAP2MCI0_FE field.
	MCPWM_CAPCON_CAP2MCI0_FE_Msk = 0x2000
	// Bit CAP2MCI0_FE.
	MCPWM_CAPCON_CAP2MCI0_FE = 0x2000
	// Position of CAP2MCI1_RE field.
	MCPWM_CAPCON_CAP2MCI1_RE_Pos = 0xe
	// Bit mask of CAP2MCI1_RE field.
	MCPWM_CAPCON_CAP2MCI1_RE_Msk = 0x4000
	// Bit CAP2MCI1_RE.
	MCPWM_CAPCON_CAP2MCI1_RE = 0x4000
	// Position of CAP2MCI1_FE field.
	MCPWM_CAPCON_CAP2MCI1_FE_Pos = 0xf
	// Bit mask of CAP2MCI1_FE field.
	MCPWM_CAPCON_CAP2MCI1_FE_Msk = 0x8000
	// Bit CAP2MCI1_FE.
	MCPWM_CAPCON_CAP2MCI1_FE = 0x8000
	// Position of CAP2MCI2_RE field.
	MCPWM_CAPCON_CAP2MCI2_RE_Pos = 0x10
	// Bit mask of CAP2MCI2_RE field.
	MCPWM_CAPCON_CAP2MCI2_RE_Msk = 0x10000
	// Bit CAP2MCI2_RE.
	MCPWM_CAPCON_CAP2MCI2_RE = 0x10000
	// Position of CAP2MCI2_FE field.
	MCPWM_CAPCON_CAP2MCI2_FE_Pos = 0x11
	// Bit mask of CAP2MCI2_FE field.
	MCPWM_CAPCON_CAP2MCI2_FE_Msk = 0x20000
	// Bit CAP2MCI2_FE.
	MCPWM_CAPCON_CAP2MCI2_FE = 0x20000
	// Position of RT0 field.
	MCPWM_CAPCON_RT0_Pos = 0x12
	// Bit mask of RT0 field.
	MCPWM_CAPCON_RT0_Msk = 0x40000
	// Bit RT0.
	MCPWM_CAPCON_RT0 = 0x40000
	// Position of RT1 field.
	MCPWM_CAPCON_RT1_Pos = 0x13
	// Bit mask of RT1 field.
	MCPWM_CAPCON_RT1_Msk = 0x80000
	// Bit RT1.
	MCPWM_CAPCON_RT1 = 0x80000
	// Position of RT2 field.
	MCPWM_CAPCON_RT2_Pos = 0x14
	// Bit mask of RT2 field.
	MCPWM_CAPCON_RT2_Msk = 0x100000
	// Bit RT2.
	MCPWM_CAPCON_RT2 = 0x100000
	// Position of RESERVED field.
	MCPWM_CAPCON_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CAPCON_RESERVED_Msk = 0xffe00000

	// CAPCON_SET: Capture Control set address
	// Position of CAP0MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI0_RE_SET_Pos = 0x0
	// Bit mask of CAP0MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI0_RE_SET_Msk = 0x1
	// Bit CAP0MCI0_RE_SET.
	MCPWM_CAPCON_SET_CAP0MCI0_RE_SET = 0x1
	// Position of CAP0MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI0_FE_SET_Pos = 0x1
	// Bit mask of CAP0MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI0_FE_SET_Msk = 0x2
	// Bit CAP0MCI0_FE_SET.
	MCPWM_CAPCON_SET_CAP0MCI0_FE_SET = 0x2
	// Position of CAP0MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI1_RE_SET_Pos = 0x2
	// Bit mask of CAP0MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI1_RE_SET_Msk = 0x4
	// Bit CAP0MCI1_RE_SET.
	MCPWM_CAPCON_SET_CAP0MCI1_RE_SET = 0x4
	// Position of CAP0MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI1_FE_SET_Pos = 0x3
	// Bit mask of CAP0MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI1_FE_SET_Msk = 0x8
	// Bit CAP0MCI1_FE_SET.
	MCPWM_CAPCON_SET_CAP0MCI1_FE_SET = 0x8
	// Position of CAP0MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI2_RE_SET_Pos = 0x4
	// Bit mask of CAP0MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI2_RE_SET_Msk = 0x10
	// Bit CAP0MCI2_RE_SET.
	MCPWM_CAPCON_SET_CAP0MCI2_RE_SET = 0x10
	// Position of CAP0MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI2_FE_SET_Pos = 0x5
	// Bit mask of CAP0MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI2_FE_SET_Msk = 0x20
	// Bit CAP0MCI2_FE_SET.
	MCPWM_CAPCON_SET_CAP0MCI2_FE_SET = 0x20
	// Position of CAP1MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI0_RE_SET_Pos = 0x6
	// Bit mask of CAP1MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI0_RE_SET_Msk = 0x40
	// Bit CAP1MCI0_RE_SET.
	MCPWM_CAPCON_SET_CAP1MCI0_RE_SET = 0x40
	// Position of CAP1MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI0_FE_SET_Pos = 0x7
	// Bit mask of CAP1MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI0_FE_SET_Msk = 0x80
	// Bit CAP1MCI0_FE_SET.
	MCPWM_CAPCON_SET_CAP1MCI0_FE_SET = 0x80
	// Position of CAP1MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI1_RE_SET_Pos = 0x8
	// Bit mask of CAP1MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI1_RE_SET_Msk = 0x100
	// Bit CAP1MCI1_RE_SET.
	MCPWM_CAPCON_SET_CAP1MCI1_RE_SET = 0x100
	// Position of CAP1MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI1_FE_SET_Pos = 0x9
	// Bit mask of CAP1MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI1_FE_SET_Msk = 0x200
	// Bit CAP1MCI1_FE_SET.
	MCPWM_CAPCON_SET_CAP1MCI1_FE_SET = 0x200
	// Position of CAP1MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI2_RE_SET_Pos = 0xa
	// Bit mask of CAP1MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI2_RE_SET_Msk = 0x400
	// Bit CAP1MCI2_RE_SET.
	MCPWM_CAPCON_SET_CAP1MCI2_RE_SET = 0x400
	// Position of CAP1MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI2_FE_SET_Pos = 0xb
	// Bit mask of CAP1MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI2_FE_SET_Msk = 0x800
	// Bit CAP1MCI2_FE_SET.
	MCPWM_CAPCON_SET_CAP1MCI2_FE_SET = 0x800
	// Position of CAP2MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI0_RE_SET_Pos = 0xc
	// Bit mask of CAP2MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI0_RE_SET_Msk = 0x1000
	// Bit CAP2MCI0_RE_SET.
	MCPWM_CAPCON_SET_CAP2MCI0_RE_SET = 0x1000
	// Position of CAP2MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI0_FE_SET_Pos = 0xd
	// Bit mask of CAP2MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI0_FE_SET_Msk = 0x2000
	// Bit CAP2MCI0_FE_SET.
	MCPWM_CAPCON_SET_CAP2MCI0_FE_SET = 0x2000
	// Position of CAP2MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI1_RE_SET_Pos = 0xe
	// Bit mask of CAP2MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI1_RE_SET_Msk = 0x4000
	// Bit CAP2MCI1_RE_SET.
	MCPWM_CAPCON_SET_CAP2MCI1_RE_SET = 0x4000
	// Position of CAP2MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI1_FE_SET_Pos = 0xf
	// Bit mask of CAP2MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI1_FE_SET_Msk = 0x8000
	// Bit CAP2MCI1_FE_SET.
	MCPWM_CAPCON_SET_CAP2MCI1_FE_SET = 0x8000
	// Position of CAP2MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI2_RE_SET_Pos = 0x10
	// Bit mask of CAP2MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI2_RE_SET_Msk = 0x10000
	// Bit CAP2MCI2_RE_SET.
	MCPWM_CAPCON_SET_CAP2MCI2_RE_SET = 0x10000
	// Position of CAP2MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI2_FE_SET_Pos = 0x11
	// Bit mask of CAP2MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI2_FE_SET_Msk = 0x20000
	// Bit CAP2MCI2_FE_SET.
	MCPWM_CAPCON_SET_CAP2MCI2_FE_SET = 0x20000
	// Position of RT0_SET field.
	MCPWM_CAPCON_SET_RT0_SET_Pos = 0x12
	// Bit mask of RT0_SET field.
	MCPWM_CAPCON_SET_RT0_SET_Msk = 0x40000
	// Bit RT0_SET.
	MCPWM_CAPCON_SET_RT0_SET = 0x40000
	// Position of RT1_SET field.
	MCPWM_CAPCON_SET_RT1_SET_Pos = 0x13
	// Bit mask of RT1_SET field.
	MCPWM_CAPCON_SET_RT1_SET_Msk = 0x80000
	// Bit RT1_SET.
	MCPWM_CAPCON_SET_RT1_SET = 0x80000
	// Position of RT2_SET field.
	MCPWM_CAPCON_SET_RT2_SET_Pos = 0x14
	// Bit mask of RT2_SET field.
	MCPWM_CAPCON_SET_RT2_SET_Msk = 0x100000
	// Bit RT2_SET.
	MCPWM_CAPCON_SET_RT2_SET = 0x100000
	// Position of RESERVED field.
	MCPWM_CAPCON_SET_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CAPCON_SET_RESERVED_Msk = 0xffe00000

	// CAPCON_CLR: Event Control clear address
	// Position of CAP0MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI0_RE_CLR_Pos = 0x0
	// Bit mask of CAP0MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI0_RE_CLR_Msk = 0x1
	// Bit CAP0MCI0_RE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI0_RE_CLR = 0x1
	// Position of CAP0MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI0_FE_CLR_Pos = 0x1
	// Bit mask of CAP0MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI0_FE_CLR_Msk = 0x2
	// Bit CAP0MCI0_FE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI0_FE_CLR = 0x2
	// Position of CAP0MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI1_RE_CLR_Pos = 0x2
	// Bit mask of CAP0MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI1_RE_CLR_Msk = 0x4
	// Bit CAP0MCI1_RE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI1_RE_CLR = 0x4
	// Position of CAP0MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI1_FE_CLR_Pos = 0x3
	// Bit mask of CAP0MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI1_FE_CLR_Msk = 0x8
	// Bit CAP0MCI1_FE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI1_FE_CLR = 0x8
	// Position of CAP0MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI2_RE_CLR_Pos = 0x4
	// Bit mask of CAP0MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI2_RE_CLR_Msk = 0x10
	// Bit CAP0MCI2_RE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI2_RE_CLR = 0x10
	// Position of CAP0MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI2_FE_CLR_Pos = 0x5
	// Bit mask of CAP0MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI2_FE_CLR_Msk = 0x20
	// Bit CAP0MCI2_FE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI2_FE_CLR = 0x20
	// Position of CAP1MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI0_RE_CLR_Pos = 0x6
	// Bit mask of CAP1MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI0_RE_CLR_Msk = 0x40
	// Bit CAP1MCI0_RE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI0_RE_CLR = 0x40
	// Position of CAP1MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI0_FE_CLR_Pos = 0x7
	// Bit mask of CAP1MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI0_FE_CLR_Msk = 0x80
	// Bit CAP1MCI0_FE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI0_FE_CLR = 0x80
	// Position of CAP1MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI1_RE_CLR_Pos = 0x8
	// Bit mask of CAP1MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI1_RE_CLR_Msk = 0x100
	// Bit CAP1MCI1_RE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI1_RE_CLR = 0x100
	// Position of CAP1MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI1_FE_CLR_Pos = 0x9
	// Bit mask of CAP1MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI1_FE_CLR_Msk = 0x200
	// Bit CAP1MCI1_FE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI1_FE_CLR = 0x200
	// Position of CAP1MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI2_RE_CLR_Pos = 0xa
	// Bit mask of CAP1MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI2_RE_CLR_Msk = 0x400
	// Bit CAP1MCI2_RE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI2_RE_CLR = 0x400
	// Position of CAP1MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI2_FE_CLR_Pos = 0xb
	// Bit mask of CAP1MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI2_FE_CLR_Msk = 0x800
	// Bit CAP1MCI2_FE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI2_FE_CLR = 0x800
	// Position of CAP2MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI0_RE_CLR_Pos = 0xc
	// Bit mask of CAP2MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI0_RE_CLR_Msk = 0x1000
	// Bit CAP2MCI0_RE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI0_RE_CLR = 0x1000
	// Position of CAP2MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI0_FE_CLR_Pos = 0xd
	// Bit mask of CAP2MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI0_FE_CLR_Msk = 0x2000
	// Bit CAP2MCI0_FE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI0_FE_CLR = 0x2000
	// Position of CAP2MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI1_RE_CLR_Pos = 0xe
	// Bit mask of CAP2MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI1_RE_CLR_Msk = 0x4000
	// Bit CAP2MCI1_RE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI1_RE_CLR = 0x4000
	// Position of CAP2MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI1_FE_CLR_Pos = 0xf
	// Bit mask of CAP2MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI1_FE_CLR_Msk = 0x8000
	// Bit CAP2MCI1_FE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI1_FE_CLR = 0x8000
	// Position of CAP2MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI2_RE_CLR_Pos = 0x10
	// Bit mask of CAP2MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI2_RE_CLR_Msk = 0x10000
	// Bit CAP2MCI2_RE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI2_RE_CLR = 0x10000
	// Position of CAP2MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI2_FE_CLR_Pos = 0x11
	// Bit mask of CAP2MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI2_FE_CLR_Msk = 0x20000
	// Bit CAP2MCI2_FE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI2_FE_CLR = 0x20000
	// Position of RT0_CLR field.
	MCPWM_CAPCON_CLR_RT0_CLR_Pos = 0x12
	// Bit mask of RT0_CLR field.
	MCPWM_CAPCON_CLR_RT0_CLR_Msk = 0x40000
	// Bit RT0_CLR.
	MCPWM_CAPCON_CLR_RT0_CLR = 0x40000
	// Position of RT1_CLR field.
	MCPWM_CAPCON_CLR_RT1_CLR_Pos = 0x13
	// Bit mask of RT1_CLR field.
	MCPWM_CAPCON_CLR_RT1_CLR_Msk = 0x80000
	// Bit RT1_CLR.
	MCPWM_CAPCON_CLR_RT1_CLR = 0x80000
	// Position of RT2_CLR field.
	MCPWM_CAPCON_CLR_RT2_CLR_Pos = 0x14
	// Bit mask of RT2_CLR field.
	MCPWM_CAPCON_CLR_RT2_CLR_Msk = 0x100000
	// Bit RT2_CLR.
	MCPWM_CAPCON_CLR_RT2_CLR = 0x100000
	// Position of RESERVED field.
	MCPWM_CAPCON_CLR_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CAPCON_CLR_RESERVED_Msk = 0xffe00000

	// TC0: Timer Counter register
	// Position of MCTC field.
	MCPWM_TC_MCTC_Pos = 0x0
	// Bit mask of MCTC field.
	MCPWM_TC_MCTC_Msk = 0xffffffff

	// LIM0: Limit register
	// Position of MCLIM field.
	MCPWM_LIM_MCLIM_Pos = 0x0
	// Bit mask of MCLIM field.
	MCPWM_LIM_MCLIM_Msk = 0xffffffff

	// MAT0: Match register
	// Position of MCMAT field.
	MCPWM_MAT_MCMAT_Pos = 0x0
	// Bit mask of MCMAT field.
	MCPWM_MAT_MCMAT_Msk = 0xffffffff

	// DT: Dead time register
	// Position of DT0 field.
	MCPWM_DT_DT0_Pos = 0x0
	// Bit mask of DT0 field.
	MCPWM_DT_DT0_Msk = 0x3ff
	// Position of DT1 field.
	MCPWM_DT_DT1_Pos = 0xa
	// Bit mask of DT1 field.
	MCPWM_DT_DT1_Msk = 0xffc00
	// Position of DT2 field.
	MCPWM_DT_DT2_Pos = 0x14
	// Bit mask of DT2 field.
	MCPWM_DT_DT2_Msk = 0x3ff00000
	// Position of RESERVED field.
	MCPWM_DT_RESERVED_Pos = 0x1e
	// Bit mask of RESERVED field.
	MCPWM_DT_RESERVED_Msk = 0xc0000000

	// CCP: Communication Pattern register
	// Position of CCPA0 field.
	MCPWM_CCP_CCPA0_Pos = 0x0
	// Bit mask of CCPA0 field.
	MCPWM_CCP_CCPA0_Msk = 0x1
	// Bit CCPA0.
	MCPWM_CCP_CCPA0 = 0x1
	// MCOA0 passive.
	MCPWM_CCP_CCPA0_MCOA0_PASSIVE_ = 0x0
	// internal MCOA0.
	MCPWM_CCP_CCPA0_INTERNAL_MCOA0_ = 0x1
	// Position of CCPB0 field.
	MCPWM_CCP_CCPB0_Pos = 0x1
	// Bit mask of CCPB0 field.
	MCPWM_CCP_CCPB0_Msk = 0x2
	// Bit CCPB0.
	MCPWM_CCP_CCPB0 = 0x2
	// MCOB0 passive.
	MCPWM_CCP_CCPB0_MCOB0_PASSIVE_ = 0x0
	// MCOB0 tracks internal MCOA0.
	MCPWM_CCP_CCPB0_MCOB0_TRACKS_INTERNA = 0x1
	// Position of CCPA1 field.
	MCPWM_CCP_CCPA1_Pos = 0x2
	// Bit mask of CCPA1 field.
	MCPWM_CCP_CCPA1_Msk = 0x4
	// Bit CCPA1.
	MCPWM_CCP_CCPA1 = 0x4
	// MCOA1 passive.
	MCPWM_CCP_CCPA1_MCOA1_PASSIVE_ = 0x0
	// MCOA1 tracks internal MCOA0.
	MCPWM_CCP_CCPA1_MCOA1_TRACKS_INTERNA = 0x1
	// Position of CCPB1 field.
	MCPWM_CCP_CCPB1_Pos = 0x3
	// Bit mask of CCPB1 field.
	MCPWM_CCP_CCPB1_Msk = 0x8
	// Bit CCPB1.
	MCPWM_CCP_CCPB1 = 0x8
	// MCOB1 passive.
	MCPWM_CCP_CCPB1_MCOB1_PASSIVE_ = 0x0
	// MCOB1 tracks internal MCOA0.
	MCPWM_CCP_CCPB1_MCOB1_TRACKS_INTERNA = 0x1
	// Position of CCPA2 field.
	MCPWM_CCP_CCPA2_Pos = 0x4
	// Bit mask of CCPA2 field.
	MCPWM_CCP_CCPA2_Msk = 0x10
	// Bit CCPA2.
	MCPWM_CCP_CCPA2 = 0x10
	// MCOA2 passive.
	MCPWM_CCP_CCPA2_MCOA2_PASSIVE_ = 0x0
	// MCOA2 tracks internal MCOA0.
	MCPWM_CCP_CCPA2_MCOA2_TRACKS_INTERNA = 0x1
	// Position of CCPB2 field.
	MCPWM_CCP_CCPB2_Pos = 0x5
	// Bit mask of CCPB2 field.
	MCPWM_CCP_CCPB2_Msk = 0x20
	// Bit CCPB2.
	MCPWM_CCP_CCPB2 = 0x20
	// MCOB2 passive.
	MCPWM_CCP_CCPB2_MCOB2_PASSIVE_ = 0x0
	// MCOB2 tracks internal MCOA0.
	MCPWM_CCP_CCPB2_MCOB2_TRACKS_INTERNA = 0x1
	// Position of RESERVED field.
	MCPWM_CCP_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	MCPWM_CCP_RESERVED_Msk = 0xffffffc0

	// CAP0: Capture register
	// Position of CAP field.
	MCPWM_CAP_CAP_Pos = 0x0
	// Bit mask of CAP field.
	MCPWM_CAP_CAP_Msk = 0xffffffff

	// INTEN: Interrupt Enable read address
	// Position of ILIM0 field.
	MCPWM_INTEN_ILIM0_Pos = 0x0
	// Bit mask of ILIM0 field.
	MCPWM_INTEN_ILIM0_Msk = 0x1
	// Bit ILIM0.
	MCPWM_INTEN_ILIM0 = 0x1
	// Interrupt disabled.
	MCPWM_INTEN_ILIM0_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ILIM0_INTERRUPT_ENABLED_ = 0x1
	// Position of IMAT0 field.
	MCPWM_INTEN_IMAT0_Pos = 0x1
	// Bit mask of IMAT0 field.
	MCPWM_INTEN_IMAT0_Msk = 0x2
	// Bit IMAT0.
	MCPWM_INTEN_IMAT0 = 0x2
	// Interrupt disabled.
	MCPWM_INTEN_IMAT0_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_IMAT0_INTERRUPT_ENABLED_ = 0x1
	// Position of ICAP0 field.
	MCPWM_INTEN_ICAP0_Pos = 0x2
	// Bit mask of ICAP0 field.
	MCPWM_INTEN_ICAP0_Msk = 0x4
	// Bit ICAP0.
	MCPWM_INTEN_ICAP0 = 0x4
	// Interrupt disabled.
	MCPWM_INTEN_ICAP0_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ICAP0_INTERRUPT_ENABLED_ = 0x1
	// Position of RESERVED field.
	MCPWM_INTEN_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTEN_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTEN_RESERVED = 0x8
	// Position of ILIM1 field.
	MCPWM_INTEN_ILIM1_Pos = 0x4
	// Bit mask of ILIM1 field.
	MCPWM_INTEN_ILIM1_Msk = 0x10
	// Bit ILIM1.
	MCPWM_INTEN_ILIM1 = 0x10
	// Interrupt disabled.
	MCPWM_INTEN_ILIM1_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ILIM1_INTERRUPT_ENABLED_ = 0x1
	// Position of IMAT1 field.
	MCPWM_INTEN_IMAT1_Pos = 0x5
	// Bit mask of IMAT1 field.
	MCPWM_INTEN_IMAT1_Msk = 0x20
	// Bit IMAT1.
	MCPWM_INTEN_IMAT1 = 0x20
	// Interrupt disabled.
	MCPWM_INTEN_IMAT1_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_IMAT1_INTERRUPT_ENABLED_ = 0x1
	// Position of ICAP1 field.
	MCPWM_INTEN_ICAP1_Pos = 0x6
	// Bit mask of ICAP1 field.
	MCPWM_INTEN_ICAP1_Msk = 0x40
	// Bit ICAP1.
	MCPWM_INTEN_ICAP1 = 0x40
	// Interrupt disabled.
	MCPWM_INTEN_ICAP1_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ICAP1_INTERRUPT_ENABLED_ = 0x1
	// Position of RESERVED field.
	MCPWM_INTEN_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTEN_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTEN_RESERVED = 0x80
	// Position of ILIM2 field.
	MCPWM_INTEN_ILIM2_Pos = 0x8
	// Bit mask of ILIM2 field.
	MCPWM_INTEN_ILIM2_Msk = 0x100
	// Bit ILIM2.
	MCPWM_INTEN_ILIM2 = 0x100
	// Interrupt disabled.
	MCPWM_INTEN_ILIM2_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ILIM2_INTERRUPT_ENABLED_ = 0x1
	// Position of IMAT2 field.
	MCPWM_INTEN_IMAT2_Pos = 0x9
	// Bit mask of IMAT2 field.
	MCPWM_INTEN_IMAT2_Msk = 0x200
	// Bit IMAT2.
	MCPWM_INTEN_IMAT2 = 0x200
	// Interrupt disabled.
	MCPWM_INTEN_IMAT2_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_IMAT2_INTERRUPT_ENABLED_ = 0x1
	// Position of ICAP2 field.
	MCPWM_INTEN_ICAP2_Pos = 0xa
	// Bit mask of ICAP2 field.
	MCPWM_INTEN_ICAP2_Msk = 0x400
	// Bit ICAP2.
	MCPWM_INTEN_ICAP2 = 0x400
	// Interrupt disabled.
	MCPWM_INTEN_ICAP2_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ICAP2_INTERRUPT_ENABLED_ = 0x1
	// Position of RESERVED field.
	MCPWM_INTEN_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTEN_RESERVED_Msk = 0x7800
	// Position of ABORT field.
	MCPWM_INTEN_ABORT_Pos = 0xf
	// Bit mask of ABORT field.
	MCPWM_INTEN_ABORT_Msk = 0x8000
	// Bit ABORT.
	MCPWM_INTEN_ABORT = 0x8000
	// Interrupt disabled.
	MCPWM_INTEN_ABORT_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ABORT_INTERRUPT_ENABLED_ = 0x1
	// Position of RESERVED field.
	MCPWM_INTEN_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTEN_RESERVED_Msk = 0xffff0000

	// INTEN_SET: Interrupt Enable set address
	// Position of ILIM0_SET field.
	MCPWM_INTEN_SET_ILIM0_SET_Pos = 0x0
	// Bit mask of ILIM0_SET field.
	MCPWM_INTEN_SET_ILIM0_SET_Msk = 0x1
	// Bit ILIM0_SET.
	MCPWM_INTEN_SET_ILIM0_SET = 0x1
	// Position of IMAT0_SET field.
	MCPWM_INTEN_SET_IMAT0_SET_Pos = 0x1
	// Bit mask of IMAT0_SET field.
	MCPWM_INTEN_SET_IMAT0_SET_Msk = 0x2
	// Bit IMAT0_SET.
	MCPWM_INTEN_SET_IMAT0_SET = 0x2
	// Position of ICAP0_SET field.
	MCPWM_INTEN_SET_ICAP0_SET_Pos = 0x2
	// Bit mask of ICAP0_SET field.
	MCPWM_INTEN_SET_ICAP0_SET_Msk = 0x4
	// Bit ICAP0_SET.
	MCPWM_INTEN_SET_ICAP0_SET = 0x4
	// Position of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTEN_SET_RESERVED = 0x8
	// Position of ILIM1_SET field.
	MCPWM_INTEN_SET_ILIM1_SET_Pos = 0x4
	// Bit mask of ILIM1_SET field.
	MCPWM_INTEN_SET_ILIM1_SET_Msk = 0x10
	// Bit ILIM1_SET.
	MCPWM_INTEN_SET_ILIM1_SET = 0x10
	// Position of IMAT1_SET field.
	MCPWM_INTEN_SET_IMAT1_SET_Pos = 0x5
	// Bit mask of IMAT1_SET field.
	MCPWM_INTEN_SET_IMAT1_SET_Msk = 0x20
	// Bit IMAT1_SET.
	MCPWM_INTEN_SET_IMAT1_SET = 0x20
	// Position of ICAP1_SET field.
	MCPWM_INTEN_SET_ICAP1_SET_Pos = 0x6
	// Bit mask of ICAP1_SET field.
	MCPWM_INTEN_SET_ICAP1_SET_Msk = 0x40
	// Bit ICAP1_SET.
	MCPWM_INTEN_SET_ICAP1_SET = 0x40
	// Position of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTEN_SET_RESERVED = 0x80
	// Position of ILIM2_SET field.
	MCPWM_INTEN_SET_ILIM2_SET_Pos = 0x9
	// Bit mask of ILIM2_SET field.
	MCPWM_INTEN_SET_ILIM2_SET_Msk = 0x200
	// Bit ILIM2_SET.
	MCPWM_INTEN_SET_ILIM2_SET = 0x200
	// Position of IMAT2_SET field.
	MCPWM_INTEN_SET_IMAT2_SET_Pos = 0xa
	// Bit mask of IMAT2_SET field.
	MCPWM_INTEN_SET_IMAT2_SET_Msk = 0x400
	// Bit IMAT2_SET.
	MCPWM_INTEN_SET_IMAT2_SET = 0x400
	// Position of ICAP2_SET field.
	MCPWM_INTEN_SET_ICAP2_SET_Pos = 0xb
	// Bit mask of ICAP2_SET field.
	MCPWM_INTEN_SET_ICAP2_SET_Msk = 0x800
	// Bit ICAP2_SET.
	MCPWM_INTEN_SET_ICAP2_SET = 0x800
	// Position of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Msk = 0x7000
	// Position of ABORT_SET field.
	MCPWM_INTEN_SET_ABORT_SET_Pos = 0xf
	// Bit mask of ABORT_SET field.
	MCPWM_INTEN_SET_ABORT_SET_Msk = 0x8000
	// Bit ABORT_SET.
	MCPWM_INTEN_SET_ABORT_SET = 0x8000
	// Position of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Msk = 0xffff0000

	// INTEN_CLR: Interrupt Enable clear address
	// Position of ILIM0_CLR field.
	MCPWM_INTEN_CLR_ILIM0_CLR_Pos = 0x0
	// Bit mask of ILIM0_CLR field.
	MCPWM_INTEN_CLR_ILIM0_CLR_Msk = 0x1
	// Bit ILIM0_CLR.
	MCPWM_INTEN_CLR_ILIM0_CLR = 0x1
	// Position of IMAT0_CLR field.
	MCPWM_INTEN_CLR_IMAT0_CLR_Pos = 0x1
	// Bit mask of IMAT0_CLR field.
	MCPWM_INTEN_CLR_IMAT0_CLR_Msk = 0x2
	// Bit IMAT0_CLR.
	MCPWM_INTEN_CLR_IMAT0_CLR = 0x2
	// Position of ICAP0_CLR field.
	MCPWM_INTEN_CLR_ICAP0_CLR_Pos = 0x2
	// Bit mask of ICAP0_CLR field.
	MCPWM_INTEN_CLR_ICAP0_CLR_Msk = 0x4
	// Bit ICAP0_CLR.
	MCPWM_INTEN_CLR_ICAP0_CLR = 0x4
	// Position of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTEN_CLR_RESERVED = 0x8
	// Position of ILIM1_CLR field.
	MCPWM_INTEN_CLR_ILIM1_CLR_Pos = 0x4
	// Bit mask of ILIM1_CLR field.
	MCPWM_INTEN_CLR_ILIM1_CLR_Msk = 0x10
	// Bit ILIM1_CLR.
	MCPWM_INTEN_CLR_ILIM1_CLR = 0x10
	// Position of IMAT1_CLR field.
	MCPWM_INTEN_CLR_IMAT1_CLR_Pos = 0x5
	// Bit mask of IMAT1_CLR field.
	MCPWM_INTEN_CLR_IMAT1_CLR_Msk = 0x20
	// Bit IMAT1_CLR.
	MCPWM_INTEN_CLR_IMAT1_CLR = 0x20
	// Position of ICAP1_CLR field.
	MCPWM_INTEN_CLR_ICAP1_CLR_Pos = 0x6
	// Bit mask of ICAP1_CLR field.
	MCPWM_INTEN_CLR_ICAP1_CLR_Msk = 0x40
	// Bit ICAP1_CLR.
	MCPWM_INTEN_CLR_ICAP1_CLR = 0x40
	// Position of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTEN_CLR_RESERVED = 0x80
	// Position of ILIM2_CLR field.
	MCPWM_INTEN_CLR_ILIM2_CLR_Pos = 0x8
	// Bit mask of ILIM2_CLR field.
	MCPWM_INTEN_CLR_ILIM2_CLR_Msk = 0x100
	// Bit ILIM2_CLR.
	MCPWM_INTEN_CLR_ILIM2_CLR = 0x100
	// Position of IMAT2_CLR field.
	MCPWM_INTEN_CLR_IMAT2_CLR_Pos = 0x9
	// Bit mask of IMAT2_CLR field.
	MCPWM_INTEN_CLR_IMAT2_CLR_Msk = 0x200
	// Bit IMAT2_CLR.
	MCPWM_INTEN_CLR_IMAT2_CLR = 0x200
	// Position of ICAP2_CLR field.
	MCPWM_INTEN_CLR_ICAP2_CLR_Pos = 0xa
	// Bit mask of ICAP2_CLR field.
	MCPWM_INTEN_CLR_ICAP2_CLR_Msk = 0x400
	// Bit ICAP2_CLR.
	MCPWM_INTEN_CLR_ICAP2_CLR = 0x400
	// Position of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Msk = 0x7800
	// Position of ABORT_CLR field.
	MCPWM_INTEN_CLR_ABORT_CLR_Pos = 0xf
	// Bit mask of ABORT_CLR field.
	MCPWM_INTEN_CLR_ABORT_CLR_Msk = 0x8000
	// Bit ABORT_CLR.
	MCPWM_INTEN_CLR_ABORT_CLR = 0x8000
	// Position of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Msk = 0xffff0000

	// CNTCON: Count Control read address
	// Position of TC0MCI0_RE field.
	MCPWM_CNTCON_TC0MCI0_RE_Pos = 0x0
	// Bit mask of TC0MCI0_RE field.
	MCPWM_CNTCON_TC0MCI0_RE_Msk = 0x1
	// Bit TC0MCI0_RE.
	MCPWM_CNTCON_TC0MCI0_RE = 0x1
	// A rising edge on MCI0 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI0_RE_NOEFFECT = 0x0
	// If MODE0 is 1, counter 0 advances on a rising edge on MCI0.
	MCPWM_CNTCON_TC0MCI0_RE_RISING = 0x1
	// Position of TC0MCI0_FE field.
	MCPWM_CNTCON_TC0MCI0_FE_Pos = 0x1
	// Bit mask of TC0MCI0_FE field.
	MCPWM_CNTCON_TC0MCI0_FE_Msk = 0x2
	// Bit TC0MCI0_FE.
	MCPWM_CNTCON_TC0MCI0_FE = 0x2
	// A falling edge on MCI0 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI0_FE_NOEFECT = 0x0
	// If MODE0 is 1, counter 0 advances on a falling edge on MCI0.
	MCPWM_CNTCON_TC0MCI0_FE_FALLING = 0x1
	// Position of TC0MCI1_RE field.
	MCPWM_CNTCON_TC0MCI1_RE_Pos = 0x2
	// Bit mask of TC0MCI1_RE field.
	MCPWM_CNTCON_TC0MCI1_RE_Msk = 0x4
	// Bit TC0MCI1_RE.
	MCPWM_CNTCON_TC0MCI1_RE = 0x4
	// A rising edge on MCI1 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI1_RE_NOEFFECT = 0x0
	// If MODE0 is 1, counter 0 advances on a rising edge on MCI1.
	MCPWM_CNTCON_TC0MCI1_RE_RISING = 0x1
	// Position of TC0MCI1_FE field.
	MCPWM_CNTCON_TC0MCI1_FE_Pos = 0x3
	// Bit mask of TC0MCI1_FE field.
	MCPWM_CNTCON_TC0MCI1_FE_Msk = 0x8
	// Bit TC0MCI1_FE.
	MCPWM_CNTCON_TC0MCI1_FE = 0x8
	// A falling edge on MCI1 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI1_FE_NOEFFECT = 0x0
	// If MODE0 is 1, counter 0 advances on a falling edge on MCI1.
	MCPWM_CNTCON_TC0MCI1_FE_FALLING = 0x1
	// Position of TC0MCI2_RE field.
	MCPWM_CNTCON_TC0MCI2_RE_Pos = 0x4
	// Bit mask of TC0MCI2_RE field.
	MCPWM_CNTCON_TC0MCI2_RE_Msk = 0x10
	// Bit TC0MCI2_RE.
	MCPWM_CNTCON_TC0MCI2_RE = 0x10
	// A rising edge on MCI0 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI2_RE_NOEFFECT = 0x0
	// If MODE0 is 1, counter 0 advances on a rising edge on MCI2.
	MCPWM_CNTCON_TC0MCI2_RE_RISING = 0x1
	// Position of TC0MCI2_FE field.
	MCPWM_CNTCON_TC0MCI2_FE_Pos = 0x5
	// Bit mask of TC0MCI2_FE field.
	MCPWM_CNTCON_TC0MCI2_FE_Msk = 0x20
	// Bit TC0MCI2_FE.
	MCPWM_CNTCON_TC0MCI2_FE = 0x20
	// A falling edge on MCI0 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI2_FE_NOEFFECT = 0x0
	// If MODE0 is 1, counter 0 advances on a falling edge on MCI2.
	MCPWM_CNTCON_TC0MCI2_FE_FALLING = 0x1
	// Position of TC1MCI0_RE field.
	MCPWM_CNTCON_TC1MCI0_RE_Pos = 0x6
	// Bit mask of TC1MCI0_RE field.
	MCPWM_CNTCON_TC1MCI0_RE_Msk = 0x40
	// Bit TC1MCI0_RE.
	MCPWM_CNTCON_TC1MCI0_RE = 0x40
	// A rising edge on MCI0 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI0_RE_NOEFFECT = 0x0
	// If MODE1 is 1, counter 1 advances on a rising edge on MCI0.
	MCPWM_CNTCON_TC1MCI0_RE_RISING = 0x1
	// Position of TC1MCI0_FE field.
	MCPWM_CNTCON_TC1MCI0_FE_Pos = 0x7
	// Bit mask of TC1MCI0_FE field.
	MCPWM_CNTCON_TC1MCI0_FE_Msk = 0x80
	// Bit TC1MCI0_FE.
	MCPWM_CNTCON_TC1MCI0_FE = 0x80
	// A falling edge on MCI0 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI0_FE_RISING = 0x0
	// If MODE1 is 1, counter 1 advances on a falling edge on MCI0.
	MCPWM_CNTCON_TC1MCI0_FE_FALLING = 0x1
	// Position of TC1MCI1_RE field.
	MCPWM_CNTCON_TC1MCI1_RE_Pos = 0x8
	// Bit mask of TC1MCI1_RE field.
	MCPWM_CNTCON_TC1MCI1_RE_Msk = 0x100
	// Bit TC1MCI1_RE.
	MCPWM_CNTCON_TC1MCI1_RE = 0x100
	// A rising edge on MCI1 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI1_RE_NOEFFECT = 0x0
	// If MODE1 is 1, counter 1 advances on a rising edge on MCI1.
	MCPWM_CNTCON_TC1MCI1_RE_RISING = 0x1
	// Position of TC1MCI1_FE field.
	MCPWM_CNTCON_TC1MCI1_FE_Pos = 0x9
	// Bit mask of TC1MCI1_FE field.
	MCPWM_CNTCON_TC1MCI1_FE_Msk = 0x200
	// Bit TC1MCI1_FE.
	MCPWM_CNTCON_TC1MCI1_FE = 0x200
	// A falling edge on MCI0 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI1_FE_NOEFFECT = 0x0
	// If MODE1 is 1, counter 1 advances on a falling edge on MCI1.
	MCPWM_CNTCON_TC1MCI1_FE_FALLING = 0x1
	// Position of TC1MCI2_RE field.
	MCPWM_CNTCON_TC1MCI2_RE_Pos = 0xa
	// Bit mask of TC1MCI2_RE field.
	MCPWM_CNTCON_TC1MCI2_RE_Msk = 0x400
	// Bit TC1MCI2_RE.
	MCPWM_CNTCON_TC1MCI2_RE = 0x400
	// A rising edge on MCI2 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI2_RE_NOEFFECT = 0x0
	// If MODE1 is 1, counter 1 advances on a rising edge on MCI2.
	MCPWM_CNTCON_TC1MCI2_RE_RISING = 0x1
	// Position of TC1MCI2_FE field.
	MCPWM_CNTCON_TC1MCI2_FE_Pos = 0xb
	// Bit mask of TC1MCI2_FE field.
	MCPWM_CNTCON_TC1MCI2_FE_Msk = 0x800
	// Bit TC1MCI2_FE.
	MCPWM_CNTCON_TC1MCI2_FE = 0x800
	// A falling edge on MCI2 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI2_FE_NOEFFECT = 0x0
	// If MODE1 is 1, counter 1 advances on a falling edge on MCI2.
	MCPWM_CNTCON_TC1MCI2_FE_RISING = 0x1
	// Position of TC2MCI0_RE field.
	MCPWM_CNTCON_TC2MCI0_RE_Pos = 0xc
	// Bit mask of TC2MCI0_RE field.
	MCPWM_CNTCON_TC2MCI0_RE_Msk = 0x1000
	// Bit TC2MCI0_RE.
	MCPWM_CNTCON_TC2MCI0_RE = 0x1000
	// A rising edge on MCI0 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI0_RE_NOEFFECT = 0x0
	// If MODE2 is 1, counter 2 advances on a rising edge on MCI0.
	MCPWM_CNTCON_TC2MCI0_RE_FALLING = 0x1
	// Position of TC2MCI0_FE field.
	MCPWM_CNTCON_TC2MCI0_FE_Pos = 0xd
	// Bit mask of TC2MCI0_FE field.
	MCPWM_CNTCON_TC2MCI0_FE_Msk = 0x2000
	// Bit TC2MCI0_FE.
	MCPWM_CNTCON_TC2MCI0_FE = 0x2000
	// A falling edge on MCI0 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI0_FE_NOEFFECT = 0x0
	// If MODE2 is 1, counter 2 advances on a falling edge on MCI0.
	MCPWM_CNTCON_TC2MCI0_FE_FALLING = 0x1
	// Position of TC2MCI1_RE field.
	MCPWM_CNTCON_TC2MCI1_RE_Pos = 0xe
	// Bit mask of TC2MCI1_RE field.
	MCPWM_CNTCON_TC2MCI1_RE_Msk = 0x4000
	// Bit TC2MCI1_RE.
	MCPWM_CNTCON_TC2MCI1_RE = 0x4000
	// A rising edge on MCI1 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI1_RE_NOEFFECT = 0x0
	// If MODE2 is 1, counter 2 advances on a rising edge on MCI1.
	MCPWM_CNTCON_TC2MCI1_RE_FALLING = 0x1
	// Position of TC2MCI1_FE field.
	MCPWM_CNTCON_TC2MCI1_FE_Pos = 0xf
	// Bit mask of TC2MCI1_FE field.
	MCPWM_CNTCON_TC2MCI1_FE_Msk = 0x8000
	// Bit TC2MCI1_FE.
	MCPWM_CNTCON_TC2MCI1_FE = 0x8000
	// A falling edge on MCI1 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI1_FE_NOEFFECT = 0x0
	// If MODE2 is 1, counter 2 advances on a falling edge on MCI1.
	MCPWM_CNTCON_TC2MCI1_FE_FALLING = 0x1
	// Position of TC2MCI2_RE field.
	MCPWM_CNTCON_TC2MCI2_RE_Pos = 0x10
	// Bit mask of TC2MCI2_RE field.
	MCPWM_CNTCON_TC2MCI2_RE_Msk = 0x10000
	// Bit TC2MCI2_RE.
	MCPWM_CNTCON_TC2MCI2_RE = 0x10000
	// A rising edge on MCI2 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI2_RE_NOEFFECT = 0x0
	// If MODE2 is 1, counter 2 advances on a rising edge on MCI2.
	MCPWM_CNTCON_TC2MCI2_RE_FALLING = 0x1
	// Position of TC2MCI2_FE field.
	MCPWM_CNTCON_TC2MCI2_FE_Pos = 0x11
	// Bit mask of TC2MCI2_FE field.
	MCPWM_CNTCON_TC2MCI2_FE_Msk = 0x20000
	// Bit TC2MCI2_FE.
	MCPWM_CNTCON_TC2MCI2_FE = 0x20000
	// A falling edge on MCI2 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI2_FE_NOEFFECT = 0x0
	// If MODE2 is 1, counter 2 advances on a falling edge on MCI2.
	MCPWM_CNTCON_TC2MCI2_FE_FALLING = 0x1
	// Position of RESERVED field.
	MCPWM_CNTCON_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	MCPWM_CNTCON_RESERVED_Msk = 0x1ffc0000
	// Position of CNTR0 field.
	MCPWM_CNTCON_CNTR0_Pos = 0x1d
	// Bit mask of CNTR0 field.
	MCPWM_CNTCON_CNTR0_Msk = 0x20000000
	// Bit CNTR0.
	MCPWM_CNTCON_CNTR0 = 0x20000000
	// Channel 0 is in timer mode.
	MCPWM_CNTCON_CNTR0_CHANNEL_0_IS_IN_TIME = 0x0
	// Channel 0 is in counter mode.
	MCPWM_CNTCON_CNTR0_CHANNEL_0_IS_IN_COUN = 0x1
	// Position of CNTR1 field.
	MCPWM_CNTCON_CNTR1_Pos = 0x1e
	// Bit mask of CNTR1 field.
	MCPWM_CNTCON_CNTR1_Msk = 0x40000000
	// Bit CNTR1.
	MCPWM_CNTCON_CNTR1 = 0x40000000
	// Channel 1 is in timer mode.
	MCPWM_CNTCON_CNTR1_CHANNEL_1_IS_IN_TIME = 0x0
	// Channel 1 is in counter mode.
	MCPWM_CNTCON_CNTR1_CHANNEL_1_IS_IN_COUN = 0x1
	// Position of CNTR2 field.
	MCPWM_CNTCON_CNTR2_Pos = 0x1f
	// Bit mask of CNTR2 field.
	MCPWM_CNTCON_CNTR2_Msk = 0x80000000
	// Bit CNTR2.
	MCPWM_CNTCON_CNTR2 = 0x80000000
	// Channel 2 is in timer mode.
	MCPWM_CNTCON_CNTR2_CHANNEL_2_IS_IN_TIME = 0x0
	// Channel 2 is in counter mode.
	MCPWM_CNTCON_CNTR2_CHANNEL_2_IS_IN_COUN = 0x1

	// CNTCON_SET: Count Control set address
	// Position of TC0MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI0_RE_SET_Pos = 0x0
	// Bit mask of TC0MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI0_RE_SET_Msk = 0x1
	// Bit TC0MCI0_RE_SET.
	MCPWM_CNTCON_SET_TC0MCI0_RE_SET = 0x1
	// Position of TC0MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI0_FE_SET_Pos = 0x1
	// Bit mask of TC0MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI0_FE_SET_Msk = 0x2
	// Bit TC0MCI0_FE_SET.
	MCPWM_CNTCON_SET_TC0MCI0_FE_SET = 0x2
	// Position of TC0MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI1_RE_SET_Pos = 0x2
	// Bit mask of TC0MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI1_RE_SET_Msk = 0x4
	// Bit TC0MCI1_RE_SET.
	MCPWM_CNTCON_SET_TC0MCI1_RE_SET = 0x4
	// Position of TC0MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI1_FE_SET_Pos = 0x3
	// Bit mask of TC0MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI1_FE_SET_Msk = 0x8
	// Bit TC0MCI1_FE_SET.
	MCPWM_CNTCON_SET_TC0MCI1_FE_SET = 0x8
	// Position of TC0MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI2_RE_SET_Pos = 0x4
	// Bit mask of TC0MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI2_RE_SET_Msk = 0x10
	// Bit TC0MCI2_RE_SET.
	MCPWM_CNTCON_SET_TC0MCI2_RE_SET = 0x10
	// Position of TC0MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI2_FE_SET_Pos = 0x5
	// Bit mask of TC0MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI2_FE_SET_Msk = 0x20
	// Bit TC0MCI2_FE_SET.
	MCPWM_CNTCON_SET_TC0MCI2_FE_SET = 0x20
	// Position of TC1MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI0_RE_SET_Pos = 0x6
	// Bit mask of TC1MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI0_RE_SET_Msk = 0x40
	// Bit TC1MCI0_RE_SET.
	MCPWM_CNTCON_SET_TC1MCI0_RE_SET = 0x40
	// Position of TC1MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI0_FE_SET_Pos = 0x7
	// Bit mask of TC1MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI0_FE_SET_Msk = 0x80
	// Bit TC1MCI0_FE_SET.
	MCPWM_CNTCON_SET_TC1MCI0_FE_SET = 0x80
	// Position of TC1MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI1_RE_SET_Pos = 0x8
	// Bit mask of TC1MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI1_RE_SET_Msk = 0x100
	// Bit TC1MCI1_RE_SET.
	MCPWM_CNTCON_SET_TC1MCI1_RE_SET = 0x100
	// Position of TC1MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI1_FE_SET_Pos = 0x9
	// Bit mask of TC1MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI1_FE_SET_Msk = 0x200
	// Bit TC1MCI1_FE_SET.
	MCPWM_CNTCON_SET_TC1MCI1_FE_SET = 0x200
	// Position of TC1MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI2_RE_SET_Pos = 0xa
	// Bit mask of TC1MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI2_RE_SET_Msk = 0x400
	// Bit TC1MCI2_RE_SET.
	MCPWM_CNTCON_SET_TC1MCI2_RE_SET = 0x400
	// Position of TC1MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI2_FE_SET_Pos = 0xb
	// Bit mask of TC1MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI2_FE_SET_Msk = 0x800
	// Bit TC1MCI2_FE_SET.
	MCPWM_CNTCON_SET_TC1MCI2_FE_SET = 0x800
	// Position of TC2MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI0_RE_SET_Pos = 0xc
	// Bit mask of TC2MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI0_RE_SET_Msk = 0x1000
	// Bit TC2MCI0_RE_SET.
	MCPWM_CNTCON_SET_TC2MCI0_RE_SET = 0x1000
	// Position of TC2MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI0_FE_SET_Pos = 0xd
	// Bit mask of TC2MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI0_FE_SET_Msk = 0x2000
	// Bit TC2MCI0_FE_SET.
	MCPWM_CNTCON_SET_TC2MCI0_FE_SET = 0x2000
	// Position of TC2MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI1_RE_SET_Pos = 0xe
	// Bit mask of TC2MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI1_RE_SET_Msk = 0x4000
	// Bit TC2MCI1_RE_SET.
	MCPWM_CNTCON_SET_TC2MCI1_RE_SET = 0x4000
	// Position of TC2MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI1_FE_SET_Pos = 0xf
	// Bit mask of TC2MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI1_FE_SET_Msk = 0x8000
	// Bit TC2MCI1_FE_SET.
	MCPWM_CNTCON_SET_TC2MCI1_FE_SET = 0x8000
	// Position of TC2MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI2_RE_SET_Pos = 0x10
	// Bit mask of TC2MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI2_RE_SET_Msk = 0x10000
	// Bit TC2MCI2_RE_SET.
	MCPWM_CNTCON_SET_TC2MCI2_RE_SET = 0x10000
	// Position of TC2MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI2_FE_SET_Pos = 0x11
	// Bit mask of TC2MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI2_FE_SET_Msk = 0x20000
	// Bit TC2MCI2_FE_SET.
	MCPWM_CNTCON_SET_TC2MCI2_FE_SET = 0x20000
	// Position of RESERVED field.
	MCPWM_CNTCON_SET_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	MCPWM_CNTCON_SET_RESERVED_Msk = 0x1ffc0000
	// Position of CNTR0_SET field.
	MCPWM_CNTCON_SET_CNTR0_SET_Pos = 0x1d
	// Bit mask of CNTR0_SET field.
	MCPWM_CNTCON_SET_CNTR0_SET_Msk = 0x20000000
	// Bit CNTR0_SET.
	MCPWM_CNTCON_SET_CNTR0_SET = 0x20000000
	// Position of CNTR1_SET field.
	MCPWM_CNTCON_SET_CNTR1_SET_Pos = 0x1e
	// Bit mask of CNTR1_SET field.
	MCPWM_CNTCON_SET_CNTR1_SET_Msk = 0x40000000
	// Bit CNTR1_SET.
	MCPWM_CNTCON_SET_CNTR1_SET = 0x40000000
	// Position of CNTR2_SET field.
	MCPWM_CNTCON_SET_CNTR2_SET_Pos = 0x1f
	// Bit mask of CNTR2_SET field.
	MCPWM_CNTCON_SET_CNTR2_SET_Msk = 0x80000000
	// Bit CNTR2_SET.
	MCPWM_CNTCON_SET_CNTR2_SET = 0x80000000

	// CNTCON_CLR: Count Control clear address
	// Position of TC0MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI0_RE_CLR_Pos = 0x0
	// Bit mask of TC0MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI0_RE_CLR_Msk = 0x1
	// Bit TC0MCI0_RE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI0_RE_CLR = 0x1
	// Position of TC0MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI0_FE_CLR_Pos = 0x1
	// Bit mask of TC0MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI0_FE_CLR_Msk = 0x2
	// Bit TC0MCI0_FE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI0_FE_CLR = 0x2
	// Position of TC0MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI1_RE_CLR_Pos = 0x2
	// Bit mask of TC0MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI1_RE_CLR_Msk = 0x4
	// Bit TC0MCI1_RE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI1_RE_CLR = 0x4
	// Position of TC0MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI1_FE_CLR_Pos = 0x3
	// Bit mask of TC0MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI1_FE_CLR_Msk = 0x8
	// Bit TC0MCI1_FE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI1_FE_CLR = 0x8
	// Position of TC0MCI2_RE field.
	MCPWM_CNTCON_CLR_TC0MCI2_RE_Pos = 0x4
	// Bit mask of TC0MCI2_RE field.
	MCPWM_CNTCON_CLR_TC0MCI2_RE_Msk = 0x10
	// Bit TC0MCI2_RE.
	MCPWM_CNTCON_CLR_TC0MCI2_RE = 0x10
	// Position of TC0MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI2_FE_CLR_Pos = 0x5
	// Bit mask of TC0MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI2_FE_CLR_Msk = 0x20
	// Bit TC0MCI2_FE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI2_FE_CLR = 0x20
	// Position of TC1MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI0_RE_CLR_Pos = 0x6
	// Bit mask of TC1MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI0_RE_CLR_Msk = 0x40
	// Bit TC1MCI0_RE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI0_RE_CLR = 0x40
	// Position of TC1MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI0_FE_CLR_Pos = 0x7
	// Bit mask of TC1MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI0_FE_CLR_Msk = 0x80
	// Bit TC1MCI0_FE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI0_FE_CLR = 0x80
	// Position of TC1MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI1_RE_CLR_Pos = 0x8
	// Bit mask of TC1MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI1_RE_CLR_Msk = 0x100
	// Bit TC1MCI1_RE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI1_RE_CLR = 0x100
	// Position of TC1MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI1_FE_CLR_Pos = 0x9
	// Bit mask of TC1MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI1_FE_CLR_Msk = 0x200
	// Bit TC1MCI1_FE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI1_FE_CLR = 0x200
	// Position of TC1MCI2_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI2_RE_CLR_Pos = 0xa
	// Bit mask of TC1MCI2_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI2_RE_CLR_Msk = 0x400
	// Bit TC1MCI2_RE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI2_RE_CLR = 0x400
	// Position of TC1MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI2_FE_CLR_Pos = 0xb
	// Bit mask of TC1MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI2_FE_CLR_Msk = 0x800
	// Bit TC1MCI2_FE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI2_FE_CLR = 0x800
	// Position of TC2MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI0_RE_CLR_Pos = 0xc
	// Bit mask of TC2MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI0_RE_CLR_Msk = 0x1000
	// Bit TC2MCI0_RE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI0_RE_CLR = 0x1000
	// Position of TC2MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI0_FE_CLR_Pos = 0xd
	// Bit mask of TC2MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI0_FE_CLR_Msk = 0x2000
	// Bit TC2MCI0_FE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI0_FE_CLR = 0x2000
	// Position of TC2MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI1_RE_CLR_Pos = 0xe
	// Bit mask of TC2MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI1_RE_CLR_Msk = 0x4000
	// Bit TC2MCI1_RE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI1_RE_CLR = 0x4000
	// Position of TC2MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI1_FE_CLR_Pos = 0xf
	// Bit mask of TC2MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI1_FE_CLR_Msk = 0x8000
	// Bit TC2MCI1_FE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI1_FE_CLR = 0x8000
	// Position of TC2MCI2_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI2_RE_CLR_Pos = 0x10
	// Bit mask of TC2MCI2_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI2_RE_CLR_Msk = 0x10000
	// Bit TC2MCI2_RE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI2_RE_CLR = 0x10000
	// Position of TC2MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI2_FE_CLR_Pos = 0x11
	// Bit mask of TC2MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI2_FE_CLR_Msk = 0x20000
	// Bit TC2MCI2_FE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI2_FE_CLR = 0x20000
	// Position of RESERVED field.
	MCPWM_CNTCON_CLR_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	MCPWM_CNTCON_CLR_RESERVED_Msk = 0x1ffc0000
	// Position of CNTR0_CLR field.
	MCPWM_CNTCON_CLR_CNTR0_CLR_Pos = 0x1d
	// Bit mask of CNTR0_CLR field.
	MCPWM_CNTCON_CLR_CNTR0_CLR_Msk = 0x20000000
	// Bit CNTR0_CLR.
	MCPWM_CNTCON_CLR_CNTR0_CLR = 0x20000000
	// Position of CNTR1_CLR field.
	MCPWM_CNTCON_CLR_CNTR1_CLR_Pos = 0x1e
	// Bit mask of CNTR1_CLR field.
	MCPWM_CNTCON_CLR_CNTR1_CLR_Msk = 0x40000000
	// Bit CNTR1_CLR.
	MCPWM_CNTCON_CLR_CNTR1_CLR = 0x40000000
	// Position of CNTR2_CLR field.
	MCPWM_CNTCON_CLR_CNTR2_CLR_Pos = 0x1f
	// Bit mask of CNTR2_CLR field.
	MCPWM_CNTCON_CLR_CNTR2_CLR_Msk = 0x80000000
	// Bit CNTR2_CLR.
	MCPWM_CNTCON_CLR_CNTR2_CLR = 0x80000000

	// INTF: Interrupt flags read address
	// Position of ILIM0_F field.
	MCPWM_INTF_ILIM0_F_Pos = 0x0
	// Bit mask of ILIM0_F field.
	MCPWM_INTF_ILIM0_F_Msk = 0x1
	// Bit ILIM0_F.
	MCPWM_INTF_ILIM0_F = 0x1
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ILIM0_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ILIM0_F_IF_THE_CORRESPONDING = 0x1
	// Position of IMAT0_F field.
	MCPWM_INTF_IMAT0_F_Pos = 0x1
	// Bit mask of IMAT0_F field.
	MCPWM_INTF_IMAT0_F_Msk = 0x2
	// Bit IMAT0_F.
	MCPWM_INTF_IMAT0_F = 0x2
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_IMAT0_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_IMAT0_F_IF_THE_CORRESPONDING = 0x1
	// Position of ICAP0_F field.
	MCPWM_INTF_ICAP0_F_Pos = 0x2
	// Bit mask of ICAP0_F field.
	MCPWM_INTF_ICAP0_F_Msk = 0x4
	// Bit ICAP0_F.
	MCPWM_INTF_ICAP0_F = 0x4
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ICAP0_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ICAP0_F_IF_THE_CORRESPONDING = 0x1
	// Position of RESERVED field.
	MCPWM_INTF_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTF_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTF_RESERVED = 0x8
	// Position of ILIM1_F field.
	MCPWM_INTF_ILIM1_F_Pos = 0x4
	// Bit mask of ILIM1_F field.
	MCPWM_INTF_ILIM1_F_Msk = 0x10
	// Bit ILIM1_F.
	MCPWM_INTF_ILIM1_F = 0x10
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ILIM1_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ILIM1_F_IF_THE_CORRESPONDING = 0x1
	// Position of IMAT1_F field.
	MCPWM_INTF_IMAT1_F_Pos = 0x5
	// Bit mask of IMAT1_F field.
	MCPWM_INTF_IMAT1_F_Msk = 0x20
	// Bit IMAT1_F.
	MCPWM_INTF_IMAT1_F = 0x20
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_IMAT1_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_IMAT1_F_IF_THE_CORRESPONDING = 0x1
	// Position of ICAP1_F field.
	MCPWM_INTF_ICAP1_F_Pos = 0x6
	// Bit mask of ICAP1_F field.
	MCPWM_INTF_ICAP1_F_Msk = 0x40
	// Bit ICAP1_F.
	MCPWM_INTF_ICAP1_F = 0x40
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ICAP1_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ICAP1_F_IF_THE_CORRESPONDING = 0x1
	// Position of RESERVED field.
	MCPWM_INTF_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTF_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTF_RESERVED = 0x80
	// Position of ILIM2_F field.
	MCPWM_INTF_ILIM2_F_Pos = 0x8
	// Bit mask of ILIM2_F field.
	MCPWM_INTF_ILIM2_F_Msk = 0x100
	// Bit ILIM2_F.
	MCPWM_INTF_ILIM2_F = 0x100
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ILIM2_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ILIM2_F_IF_THE_CORRESPONDING = 0x1
	// Position of IMAT2_F field.
	MCPWM_INTF_IMAT2_F_Pos = 0x9
	// Bit mask of IMAT2_F field.
	MCPWM_INTF_IMAT2_F_Msk = 0x200
	// Bit IMAT2_F.
	MCPWM_INTF_IMAT2_F = 0x200
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_IMAT2_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_IMAT2_F_IF_THE_CORRESPONDING = 0x1
	// Position of ICAP2_F field.
	MCPWM_INTF_ICAP2_F_Pos = 0xa
	// Bit mask of ICAP2_F field.
	MCPWM_INTF_ICAP2_F_Msk = 0x400
	// Bit ICAP2_F.
	MCPWM_INTF_ICAP2_F = 0x400
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ICAP2_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ICAP2_F_IF_THE_CORRESPONDING = 0x1
	// Position of RESERVED field.
	MCPWM_INTF_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTF_RESERVED_Msk = 0x7800
	// Position of ABORT_F field.
	MCPWM_INTF_ABORT_F_Pos = 0xf
	// Bit mask of ABORT_F field.
	MCPWM_INTF_ABORT_F_Msk = 0x8000
	// Bit ABORT_F.
	MCPWM_INTF_ABORT_F = 0x8000
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ABORT_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ABORT_F_IF_THE_CORRESPONDING = 0x1
	// Position of RESERVED field.
	MCPWM_INTF_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTF_RESERVED_Msk = 0xffff0000

	// INTF_SET: Interrupt flags set address
	// Position of ILIM0_F_SET field.
	MCPWM_INTF_SET_ILIM0_F_SET_Pos = 0x0
	// Bit mask of ILIM0_F_SET field.
	MCPWM_INTF_SET_ILIM0_F_SET_Msk = 0x1
	// Bit ILIM0_F_SET.
	MCPWM_INTF_SET_ILIM0_F_SET = 0x1
	// Position of IMAT0_F_SET field.
	MCPWM_INTF_SET_IMAT0_F_SET_Pos = 0x1
	// Bit mask of IMAT0_F_SET field.
	MCPWM_INTF_SET_IMAT0_F_SET_Msk = 0x2
	// Bit IMAT0_F_SET.
	MCPWM_INTF_SET_IMAT0_F_SET = 0x2
	// Position of ICAP0_F_SET field.
	MCPWM_INTF_SET_ICAP0_F_SET_Pos = 0x2
	// Bit mask of ICAP0_F_SET field.
	MCPWM_INTF_SET_ICAP0_F_SET_Msk = 0x4
	// Bit ICAP0_F_SET.
	MCPWM_INTF_SET_ICAP0_F_SET = 0x4
	// Position of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTF_SET_RESERVED = 0x8
	// Position of ILIM1_F_SET field.
	MCPWM_INTF_SET_ILIM1_F_SET_Pos = 0x4
	// Bit mask of ILIM1_F_SET field.
	MCPWM_INTF_SET_ILIM1_F_SET_Msk = 0x10
	// Bit ILIM1_F_SET.
	MCPWM_INTF_SET_ILIM1_F_SET = 0x10
	// Position of IMAT1_F_SET field.
	MCPWM_INTF_SET_IMAT1_F_SET_Pos = 0x5
	// Bit mask of IMAT1_F_SET field.
	MCPWM_INTF_SET_IMAT1_F_SET_Msk = 0x20
	// Bit IMAT1_F_SET.
	MCPWM_INTF_SET_IMAT1_F_SET = 0x20
	// Position of ICAP1_F_SET field.
	MCPWM_INTF_SET_ICAP1_F_SET_Pos = 0x6
	// Bit mask of ICAP1_F_SET field.
	MCPWM_INTF_SET_ICAP1_F_SET_Msk = 0x40
	// Bit ICAP1_F_SET.
	MCPWM_INTF_SET_ICAP1_F_SET = 0x40
	// Position of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTF_SET_RESERVED = 0x80
	// Position of ILIM2_F_SET field.
	MCPWM_INTF_SET_ILIM2_F_SET_Pos = 0x8
	// Bit mask of ILIM2_F_SET field.
	MCPWM_INTF_SET_ILIM2_F_SET_Msk = 0x100
	// Bit ILIM2_F_SET.
	MCPWM_INTF_SET_ILIM2_F_SET = 0x100
	// Position of IMAT2_F_SET field.
	MCPWM_INTF_SET_IMAT2_F_SET_Pos = 0x9
	// Bit mask of IMAT2_F_SET field.
	MCPWM_INTF_SET_IMAT2_F_SET_Msk = 0x200
	// Bit IMAT2_F_SET.
	MCPWM_INTF_SET_IMAT2_F_SET = 0x200
	// Position of ICAP2_F_SET field.
	MCPWM_INTF_SET_ICAP2_F_SET_Pos = 0xa
	// Bit mask of ICAP2_F_SET field.
	MCPWM_INTF_SET_ICAP2_F_SET_Msk = 0x400
	// Bit ICAP2_F_SET.
	MCPWM_INTF_SET_ICAP2_F_SET = 0x400
	// Position of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Msk = 0x7800
	// Position of ABORT_F_SET field.
	MCPWM_INTF_SET_ABORT_F_SET_Pos = 0xf
	// Bit mask of ABORT_F_SET field.
	MCPWM_INTF_SET_ABORT_F_SET_Msk = 0x8000
	// Bit ABORT_F_SET.
	MCPWM_INTF_SET_ABORT_F_SET = 0x8000
	// Position of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Msk = 0xffff0000

	// INTF_CLR: Interrupt flags clear address
	// Position of ILIM0_F_CLR field.
	MCPWM_INTF_CLR_ILIM0_F_CLR_Pos = 0x0
	// Bit mask of ILIM0_F_CLR field.
	MCPWM_INTF_CLR_ILIM0_F_CLR_Msk = 0x1
	// Bit ILIM0_F_CLR.
	MCPWM_INTF_CLR_ILIM0_F_CLR = 0x1
	// Position of IMAT0_F_CLR field.
	MCPWM_INTF_CLR_IMAT0_F_CLR_Pos = 0x1
	// Bit mask of IMAT0_F_CLR field.
	MCPWM_INTF_CLR_IMAT0_F_CLR_Msk = 0x2
	// Bit IMAT0_F_CLR.
	MCPWM_INTF_CLR_IMAT0_F_CLR = 0x2
	// Position of ICAP0_F_CLR field.
	MCPWM_INTF_CLR_ICAP0_F_CLR_Pos = 0x2
	// Bit mask of ICAP0_F_CLR field.
	MCPWM_INTF_CLR_ICAP0_F_CLR_Msk = 0x4
	// Bit ICAP0_F_CLR.
	MCPWM_INTF_CLR_ICAP0_F_CLR = 0x4
	// Position of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTF_CLR_RESERVED = 0x8
	// Position of ILIM1_F_CLR field.
	MCPWM_INTF_CLR_ILIM1_F_CLR_Pos = 0x4
	// Bit mask of ILIM1_F_CLR field.
	MCPWM_INTF_CLR_ILIM1_F_CLR_Msk = 0x10
	// Bit ILIM1_F_CLR.
	MCPWM_INTF_CLR_ILIM1_F_CLR = 0x10
	// Position of IMAT1_F_CLR field.
	MCPWM_INTF_CLR_IMAT1_F_CLR_Pos = 0x5
	// Bit mask of IMAT1_F_CLR field.
	MCPWM_INTF_CLR_IMAT1_F_CLR_Msk = 0x20
	// Bit IMAT1_F_CLR.
	MCPWM_INTF_CLR_IMAT1_F_CLR = 0x20
	// Position of ICAP1_F_CLR field.
	MCPWM_INTF_CLR_ICAP1_F_CLR_Pos = 0x6
	// Bit mask of ICAP1_F_CLR field.
	MCPWM_INTF_CLR_ICAP1_F_CLR_Msk = 0x40
	// Bit ICAP1_F_CLR.
	MCPWM_INTF_CLR_ICAP1_F_CLR = 0x40
	// Position of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTF_CLR_RESERVED = 0x80
	// Position of ILIM2_F_CLR field.
	MCPWM_INTF_CLR_ILIM2_F_CLR_Pos = 0x8
	// Bit mask of ILIM2_F_CLR field.
	MCPWM_INTF_CLR_ILIM2_F_CLR_Msk = 0x100
	// Bit ILIM2_F_CLR.
	MCPWM_INTF_CLR_ILIM2_F_CLR = 0x100
	// Position of IMAT2_F_CLR field.
	MCPWM_INTF_CLR_IMAT2_F_CLR_Pos = 0x9
	// Bit mask of IMAT2_F_CLR field.
	MCPWM_INTF_CLR_IMAT2_F_CLR_Msk = 0x200
	// Bit IMAT2_F_CLR.
	MCPWM_INTF_CLR_IMAT2_F_CLR = 0x200
	// Position of ICAP2_F_CLR field.
	MCPWM_INTF_CLR_ICAP2_F_CLR_Pos = 0xa
	// Bit mask of ICAP2_F_CLR field.
	MCPWM_INTF_CLR_ICAP2_F_CLR_Msk = 0x400
	// Bit ICAP2_F_CLR.
	MCPWM_INTF_CLR_ICAP2_F_CLR = 0x400
	// Position of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Msk = 0x7800
	// Position of ABORT_F_CLR field.
	MCPWM_INTF_CLR_ABORT_F_CLR_Pos = 0xf
	// Bit mask of ABORT_F_CLR field.
	MCPWM_INTF_CLR_ABORT_F_CLR_Msk = 0x8000
	// Bit ABORT_F_CLR.
	MCPWM_INTF_CLR_ABORT_F_CLR = 0x8000
	// Position of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Msk = 0xffff0000

	// CAP_CLR: Capture clear address
	// Position of CAP_CLR0 field.
	MCPWM_CAP_CLR_CAP_CLR0_Pos = 0x0
	// Bit mask of CAP_CLR0 field.
	MCPWM_CAP_CLR_CAP_CLR0_Msk = 0x1
	// Bit CAP_CLR0.
	MCPWM_CAP_CLR_CAP_CLR0 = 0x1
	// Position of CAP_CLR1 field.
	MCPWM_CAP_CLR_CAP_CLR1_Pos = 0x1
	// Bit mask of CAP_CLR1 field.
	MCPWM_CAP_CLR_CAP_CLR1_Msk = 0x2
	// Bit CAP_CLR1.
	MCPWM_CAP_CLR_CAP_CLR1 = 0x2
	// Position of CAP_CLR2 field.
	MCPWM_CAP_CLR_CAP_CLR2_Pos = 0x2
	// Bit mask of CAP_CLR2 field.
	MCPWM_CAP_CLR_CAP_CLR2_Msk = 0x4
	// Bit CAP_CLR2.
	MCPWM_CAP_CLR_CAP_CLR2 = 0x4
	// Position of RESERVED field.
	MCPWM_CAP_CLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_CAP_CLR_RESERVED_Msk = 0xfffffff8
)

// Constants for I2C0: I2C-bus interface
const (
	// CONSET: I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
	// Position of RESERVED field.
	I2C_CONSET_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_CONSET_RESERVED_Msk = 0x3
	// Position of AA field.
	I2C_CONSET_AA_Pos = 0x2
	// Bit mask of AA field.
	I2C_CONSET_AA_Msk = 0x4
	// Bit AA.
	I2C_CONSET_AA = 0x4
	// Position of SI field.
	I2C_CONSET_SI_Pos = 0x3
	// Bit mask of SI field.
	I2C_CONSET_SI_Msk = 0x8
	// Bit SI.
	I2C_CONSET_SI = 0x8
	// Position of STO field.
	I2C_CONSET_STO_Pos = 0x4
	// Bit mask of STO field.
	I2C_CONSET_STO_Msk = 0x10
	// Bit STO.
	I2C_CONSET_STO = 0x10
	// Position of STA field.
	I2C_CONSET_STA_Pos = 0x5
	// Bit mask of STA field.
	I2C_CONSET_STA_Msk = 0x20
	// Bit STA.
	I2C_CONSET_STA = 0x20
	// Position of I2EN field.
	I2C_CONSET_I2EN_Pos = 0x6
	// Bit mask of I2EN field.
	I2C_CONSET_I2EN_Msk = 0x40
	// Bit I2EN.
	I2C_CONSET_I2EN = 0x40
	// Position of RESERVED field.
	I2C_CONSET_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	I2C_CONSET_RESERVED_Msk = 0xffffff80

	// STAT: I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
	// Position of RESERVED field.
	I2C_STAT_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_STAT_RESERVED_Msk = 0x7
	// Position of Status field.
	I2C_STAT_Status_Pos = 0x3
	// Bit mask of Status field.
	I2C_STAT_Status_Msk = 0xf8
	// Position of RESERVED field.
	I2C_STAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_STAT_RESERVED_Msk = 0xffffff00

	// DAT: I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
	// Position of Data field.
	I2C_DAT_Data_Pos = 0x0
	// Bit mask of Data field.
	I2C_DAT_Data_Msk = 0xff
	// Position of RESERVED field.
	I2C_DAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_DAT_RESERVED_Msk = 0xffffff00

	// ADR0: I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
	// Position of GC field.
	I2C_ADR0_GC_Pos = 0x0
	// Bit mask of GC field.
	I2C_ADR0_GC_Msk = 0x1
	// Bit GC.
	I2C_ADR0_GC = 0x1
	// Position of Address field.
	I2C_ADR0_Address_Pos = 0x1
	// Bit mask of Address field.
	I2C_ADR0_Address_Msk = 0xfe
	// Position of RESERVED field.
	I2C_ADR0_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_ADR0_RESERVED_Msk = 0xffffff00

	// SCLH: SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
	// Position of SCLH field.
	I2C_SCLH_SCLH_Pos = 0x0
	// Bit mask of SCLH field.
	I2C_SCLH_SCLH_Msk = 0xffff
	// Position of RESERVED field.
	I2C_SCLH_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2C_SCLH_RESERVED_Msk = 0xffff0000

	// SCLL: SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
	// Position of SCLL field.
	I2C_SCLL_SCLL_Pos = 0x0
	// Bit mask of SCLL field.
	I2C_SCLL_SCLL_Msk = 0xffff
	// Position of RESERVED field.
	I2C_SCLL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2C_SCLL_RESERVED_Msk = 0xffff0000

	// CONCLR: I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0x3
	// Position of AAC field.
	I2C_CONCLR_AAC_Pos = 0x2
	// Bit mask of AAC field.
	I2C_CONCLR_AAC_Msk = 0x4
	// Bit AAC.
	I2C_CONCLR_AAC = 0x4
	// Position of SIC field.
	I2C_CONCLR_SIC_Pos = 0x3
	// Bit mask of SIC field.
	I2C_CONCLR_SIC_Msk = 0x8
	// Bit SIC.
	I2C_CONCLR_SIC = 0x8
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0x10
	// Bit RESERVED.
	I2C_CONCLR_RESERVED = 0x10
	// Position of STAC field.
	I2C_CONCLR_STAC_Pos = 0x5
	// Bit mask of STAC field.
	I2C_CONCLR_STAC_Msk = 0x20
	// Bit STAC.
	I2C_CONCLR_STAC = 0x20
	// Position of I2ENC field.
	I2C_CONCLR_I2ENC_Pos = 0x6
	// Bit mask of I2ENC field.
	I2C_CONCLR_I2ENC_Msk = 0x40
	// Bit I2ENC.
	I2C_CONCLR_I2ENC = 0x40
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0x80
	// Bit RESERVED.
	I2C_CONCLR_RESERVED = 0x80
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0xffffff00

	// MMCTRL: Monitor mode control register.
	// Position of MM_ENA field.
	I2C_MMCTRL_MM_ENA_Pos = 0x0
	// Bit mask of MM_ENA field.
	I2C_MMCTRL_MM_ENA_Msk = 0x1
	// Bit MM_ENA.
	I2C_MMCTRL_MM_ENA = 0x1
	// Monitor mode disabled.
	I2C_MMCTRL_MM_ENA_MONITOR_MODE_DISABLE = 0x0
	// The I 2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line.
	I2C_MMCTRL_MM_ENA_THE_I_2C_MODULE_WILL = 0x1
	// Position of ENA_SCL field.
	I2C_MMCTRL_ENA_SCL_Pos = 0x1
	// Bit mask of ENA_SCL field.
	I2C_MMCTRL_ENA_SCL_Msk = 0x2
	// Bit ENA_SCL.
	I2C_MMCTRL_ENA_SCL = 0x2
	// When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line.
	I2C_MMCTRL_ENA_SCL_WHEN_THIS_BIT_IS_CLE = 0x0
	// When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]
	I2C_MMCTRL_ENA_SCL_WHEN_THIS_BIT_IS_SET = 0x1
	// Position of MATCH_ALL field.
	I2C_MMCTRL_MATCH_ALL_Pos = 0x2
	// Bit mask of MATCH_ALL field.
	I2C_MMCTRL_MATCH_ALL_Msk = 0x4
	// Bit MATCH_ALL.
	I2C_MMCTRL_MATCH_ALL = 0x4
	// When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above. That is, the module will respond as a normal slave as far as address-recognition is concerned.
	I2C_MMCTRL_MATCH_ALL_WHEN_THIS_BIT_IS_CLE = 0x0
	// When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus.
	I2C_MMCTRL_MATCH_ALL_WHEN_THIS_BIT_IS_SET = 0x1
	// Position of RESERVED field.
	I2C_MMCTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	I2C_MMCTRL_RESERVED_Msk = 0xfffffff8

	// ADR1: I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
	// Position of GC field.
	I2C_ADR_GC_Pos = 0x0
	// Bit mask of GC field.
	I2C_ADR_GC_Msk = 0x1
	// Bit GC.
	I2C_ADR_GC = 0x1
	// Position of Address field.
	I2C_ADR_Address_Pos = 0x1
	// Bit mask of Address field.
	I2C_ADR_Address_Msk = 0xfe
	// Position of RESERVED field.
	I2C_ADR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_ADR_RESERVED_Msk = 0xffffff00

	// DATA_BUFFER: Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
	// Position of Data field.
	I2C_DATA_BUFFER_Data_Pos = 0x0
	// Bit mask of Data field.
	I2C_DATA_BUFFER_Data_Msk = 0xff
	// Position of RESERVED field.
	I2C_DATA_BUFFER_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_DATA_BUFFER_RESERVED_Msk = 0xffffff00

	// MASK0: I2C Slave address mask register
	// Position of RESERVED field.
	I2C_MASK_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_MASK_RESERVED_Msk = 0x1
	// Bit RESERVED.
	I2C_MASK_RESERVED = 0x1
	// Position of MASK field.
	I2C_MASK_MASK_Pos = 0x1
	// Bit mask of MASK field.
	I2C_MASK_MASK_Msk = 0xfe
	// Position of RESERVED field.
	I2C_MASK_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_MASK_RESERVED_Msk = 0xffffff00
)

// Constants for I2S0: I2S interface
const (
	// DAO: I2S Digital Audio Output Register. Contains control bits for the I2S transmit channel.
	// Position of WORDWIDTH field.
	I2S_DAO_WORDWIDTH_Pos = 0x0
	// Bit mask of WORDWIDTH field.
	I2S_DAO_WORDWIDTH_Msk = 0x3
	// 8-bit data
	I2S_DAO_WORDWIDTH_8_BIT_DATA = 0x0
	// 16-bit data
	I2S_DAO_WORDWIDTH_16_BIT_DATA = 0x1
	// 32-bit data
	I2S_DAO_WORDWIDTH_32_BIT_DATA = 0x3
	// Position of MONO field.
	I2S_DAO_MONO_Pos = 0x2
	// Bit mask of MONO field.
	I2S_DAO_MONO_Msk = 0x4
	// Bit MONO.
	I2S_DAO_MONO = 0x4
	// Position of STOP field.
	I2S_DAO_STOP_Pos = 0x3
	// Bit mask of STOP field.
	I2S_DAO_STOP_Msk = 0x8
	// Bit STOP.
	I2S_DAO_STOP = 0x8
	// Position of RESET field.
	I2S_DAO_RESET_Pos = 0x4
	// Bit mask of RESET field.
	I2S_DAO_RESET_Msk = 0x10
	// Bit RESET.
	I2S_DAO_RESET = 0x10
	// Position of WS_SEL field.
	I2S_DAO_WS_SEL_Pos = 0x5
	// Bit mask of WS_SEL field.
	I2S_DAO_WS_SEL_Msk = 0x20
	// Bit WS_SEL.
	I2S_DAO_WS_SEL = 0x20
	// Position of WS_HALFPERIOD field.
	I2S_DAO_WS_HALFPERIOD_Pos = 0x6
	// Bit mask of WS_HALFPERIOD field.
	I2S_DAO_WS_HALFPERIOD_Msk = 0x7fc0
	// Position of MUTE field.
	I2S_DAO_MUTE_Pos = 0xf
	// Bit mask of MUTE field.
	I2S_DAO_MUTE_Msk = 0x8000
	// Bit MUTE.
	I2S_DAO_MUTE = 0x8000
	// Position of RESERVED field.
	I2S_DAO_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2S_DAO_RESERVED_Msk = 0xffff0000

	// DAI: I2S Digital Audio Input Register. Contains control bits for the I2S receive channel.
	// Position of WORDWIDTH field.
	I2S_DAI_WORDWIDTH_Pos = 0x0
	// Bit mask of WORDWIDTH field.
	I2S_DAI_WORDWIDTH_Msk = 0x3
	// 8-bit data
	I2S_DAI_WORDWIDTH_8_BIT_DATA = 0x0
	// 16-bit data
	I2S_DAI_WORDWIDTH_16_BIT_DATA = 0x1
	// 32-bit data
	I2S_DAI_WORDWIDTH_32_BIT_DATA = 0x3
	// Position of MONO field.
	I2S_DAI_MONO_Pos = 0x2
	// Bit mask of MONO field.
	I2S_DAI_MONO_Msk = 0x4
	// Bit MONO.
	I2S_DAI_MONO = 0x4
	// Position of STOP field.
	I2S_DAI_STOP_Pos = 0x3
	// Bit mask of STOP field.
	I2S_DAI_STOP_Msk = 0x8
	// Bit STOP.
	I2S_DAI_STOP = 0x8
	// Position of RESET field.
	I2S_DAI_RESET_Pos = 0x4
	// Bit mask of RESET field.
	I2S_DAI_RESET_Msk = 0x10
	// Bit RESET.
	I2S_DAI_RESET = 0x10
	// Position of WS_SEL field.
	I2S_DAI_WS_SEL_Pos = 0x5
	// Bit mask of WS_SEL field.
	I2S_DAI_WS_SEL_Msk = 0x20
	// Bit WS_SEL.
	I2S_DAI_WS_SEL = 0x20
	// Position of WS_HALFPERIOD field.
	I2S_DAI_WS_HALFPERIOD_Pos = 0x6
	// Bit mask of WS_HALFPERIOD field.
	I2S_DAI_WS_HALFPERIOD_Msk = 0x7fc0
	// Position of RESERVED field.
	I2S_DAI_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	I2S_DAI_RESERVED_Msk = 0xffff8000

	// TXFIFO: I2S Transmit FIFO. Access register for the 8 x 32-bit transmitter FIFO.
	// Position of I2STXFIFO field.
	I2S_TXFIFO_I2STXFIFO_Pos = 0x0
	// Bit mask of I2STXFIFO field.
	I2S_TXFIFO_I2STXFIFO_Msk = 0xffffffff

	// RXFIFO: I2S Receive FIFO. Access register for the 8 x 32-bit receiver FIFO.
	// Position of I2SRXFIFO field.
	I2S_RXFIFO_I2SRXFIFO_Pos = 0x0
	// Bit mask of I2SRXFIFO field.
	I2S_RXFIFO_I2SRXFIFO_Msk = 0xffffffff

	// STATE: I2S Status Feedback Register. Contains status information about the I2S interface.
	// Position of IRQ field.
	I2S_STATE_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	I2S_STATE_IRQ_Msk = 0x1
	// Bit IRQ.
	I2S_STATE_IRQ = 0x1
	// Position of DMAREQ1 field.
	I2S_STATE_DMAREQ1_Pos = 0x1
	// Bit mask of DMAREQ1 field.
	I2S_STATE_DMAREQ1_Msk = 0x2
	// Bit DMAREQ1.
	I2S_STATE_DMAREQ1 = 0x2
	// Position of DMAREQ2 field.
	I2S_STATE_DMAREQ2_Pos = 0x2
	// Bit mask of DMAREQ2 field.
	I2S_STATE_DMAREQ2_Msk = 0x4
	// Bit DMAREQ2.
	I2S_STATE_DMAREQ2 = 0x4
	// Position of RESERVED field.
	I2S_STATE_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	I2S_STATE_RESERVED_Msk = 0xf8
	// Position of RX_LEVEL field.
	I2S_STATE_RX_LEVEL_Pos = 0x8
	// Bit mask of RX_LEVEL field.
	I2S_STATE_RX_LEVEL_Msk = 0xf00
	// Position of RESERVED field.
	I2S_STATE_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	I2S_STATE_RESERVED_Msk = 0xf000
	// Position of TX_LEVEL field.
	I2S_STATE_TX_LEVEL_Pos = 0x10
	// Bit mask of TX_LEVEL field.
	I2S_STATE_TX_LEVEL_Msk = 0xf0000
	// Position of RESERVED field.
	I2S_STATE_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	I2S_STATE_RESERVED_Msk = 0xfff00000

	// DMA1: I2S DMA Configuration Register 1. Contains control information for DMA request 1.
	// Position of RX_DMA1_ENABLE field.
	I2S_DMA1_RX_DMA1_ENABLE_Pos = 0x0
	// Bit mask of RX_DMA1_ENABLE field.
	I2S_DMA1_RX_DMA1_ENABLE_Msk = 0x1
	// Bit RX_DMA1_ENABLE.
	I2S_DMA1_RX_DMA1_ENABLE = 0x1
	// Position of TX_DMA1_ENABLE field.
	I2S_DMA1_TX_DMA1_ENABLE_Pos = 0x1
	// Bit mask of TX_DMA1_ENABLE field.
	I2S_DMA1_TX_DMA1_ENABLE_Msk = 0x2
	// Bit TX_DMA1_ENABLE.
	I2S_DMA1_TX_DMA1_ENABLE = 0x2
	// Position of RESERVED field.
	I2S_DMA1_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	I2S_DMA1_RESERVED_Msk = 0xfc
	// Position of RX_DEPTH_DMA1 field.
	I2S_DMA1_RX_DEPTH_DMA1_Pos = 0x8
	// Bit mask of RX_DEPTH_DMA1 field.
	I2S_DMA1_RX_DEPTH_DMA1_Msk = 0xf00
	// Position of RESERVED field.
	I2S_DMA1_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	I2S_DMA1_RESERVED_Msk = 0xf000
	// Position of TX_DEPTH_DMA1 field.
	I2S_DMA1_TX_DEPTH_DMA1_Pos = 0x10
	// Bit mask of TX_DEPTH_DMA1 field.
	I2S_DMA1_TX_DEPTH_DMA1_Msk = 0xf0000
	// Position of RESERVED field.
	I2S_DMA1_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	I2S_DMA1_RESERVED_Msk = 0xfff00000

	// DMA2: I2S DMA Configuration Register 2. Contains control information for DMA request 2.
	// Position of RX_DMA2_ENABLE field.
	I2S_DMA2_RX_DMA2_ENABLE_Pos = 0x0
	// Bit mask of RX_DMA2_ENABLE field.
	I2S_DMA2_RX_DMA2_ENABLE_Msk = 0x1
	// Bit RX_DMA2_ENABLE.
	I2S_DMA2_RX_DMA2_ENABLE = 0x1
	// Position of TX_DMA2_ENABLE field.
	I2S_DMA2_TX_DMA2_ENABLE_Pos = 0x1
	// Bit mask of TX_DMA2_ENABLE field.
	I2S_DMA2_TX_DMA2_ENABLE_Msk = 0x2
	// Bit TX_DMA2_ENABLE.
	I2S_DMA2_TX_DMA2_ENABLE = 0x2
	// Position of RESERVED field.
	I2S_DMA2_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	I2S_DMA2_RESERVED_Msk = 0xfc
	// Position of RX_DEPTH_DMA2 field.
	I2S_DMA2_RX_DEPTH_DMA2_Pos = 0x8
	// Bit mask of RX_DEPTH_DMA2 field.
	I2S_DMA2_RX_DEPTH_DMA2_Msk = 0xf00
	// Position of RESERVED field.
	I2S_DMA2_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	I2S_DMA2_RESERVED_Msk = 0xf000
	// Position of TX_DEPTH_DMA2 field.
	I2S_DMA2_TX_DEPTH_DMA2_Pos = 0x10
	// Bit mask of TX_DEPTH_DMA2 field.
	I2S_DMA2_TX_DEPTH_DMA2_Msk = 0xf0000
	// Position of RESERVED field.
	I2S_DMA2_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	I2S_DMA2_RESERVED_Msk = 0xfff00000

	// IRQ: I2S Interrupt Request Control Register. Contains bits that control how the I2S interrupt request is generated.
	// Position of RX_IRQ_ENABLE field.
	I2S_IRQ_RX_IRQ_ENABLE_Pos = 0x0
	// Bit mask of RX_IRQ_ENABLE field.
	I2S_IRQ_RX_IRQ_ENABLE_Msk = 0x1
	// Bit RX_IRQ_ENABLE.
	I2S_IRQ_RX_IRQ_ENABLE = 0x1
	// Position of TX_IRQ_ENABLE field.
	I2S_IRQ_TX_IRQ_ENABLE_Pos = 0x1
	// Bit mask of TX_IRQ_ENABLE field.
	I2S_IRQ_TX_IRQ_ENABLE_Msk = 0x2
	// Bit TX_IRQ_ENABLE.
	I2S_IRQ_TX_IRQ_ENABLE = 0x2
	// Position of RESERVED field.
	I2S_IRQ_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	I2S_IRQ_RESERVED_Msk = 0xfc
	// Position of RX_DEPTH_IRQ field.
	I2S_IRQ_RX_DEPTH_IRQ_Pos = 0x8
	// Bit mask of RX_DEPTH_IRQ field.
	I2S_IRQ_RX_DEPTH_IRQ_Msk = 0xf00
	// Position of RESERVED field.
	I2S_IRQ_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	I2S_IRQ_RESERVED_Msk = 0xf000
	// Position of TX_DEPTH_IRQ field.
	I2S_IRQ_TX_DEPTH_IRQ_Pos = 0x10
	// Bit mask of TX_DEPTH_IRQ field.
	I2S_IRQ_TX_DEPTH_IRQ_Msk = 0xf0000
	// Position of RESERVED field.
	I2S_IRQ_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	I2S_IRQ_RESERVED_Msk = 0xfff00000

	// TXRATE: I2S Transmit MCLK divider. This register determines the I2S TX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
	// Position of Y_DIVIDER field.
	I2S_TXRATE_Y_DIVIDER_Pos = 0x0
	// Bit mask of Y_DIVIDER field.
	I2S_TXRATE_Y_DIVIDER_Msk = 0xff
	// Position of X_DIVIDER field.
	I2S_TXRATE_X_DIVIDER_Pos = 0x8
	// Bit mask of X_DIVIDER field.
	I2S_TXRATE_X_DIVIDER_Msk = 0xff00
	// Position of RESERVED field.
	I2S_TXRATE_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2S_TXRATE_RESERVED_Msk = 0xffff0000

	// RXRATE: I2S Receive MCLK divider. This register determines the I2S RX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
	// Position of Y_DIVIDER field.
	I2S_RXRATE_Y_DIVIDER_Pos = 0x0
	// Bit mask of Y_DIVIDER field.
	I2S_RXRATE_Y_DIVIDER_Msk = 0xff
	// Position of X_DIVIDER field.
	I2S_RXRATE_X_DIVIDER_Pos = 0x8
	// Bit mask of X_DIVIDER field.
	I2S_RXRATE_X_DIVIDER_Msk = 0xff00
	// Position of RESERVED field.
	I2S_RXRATE_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2S_RXRATE_RESERVED_Msk = 0xffff0000

	// TXBITRATE: I2S Transmit bit rate divider. This register determines the I2S transmit bit rate by specifying the value to divide TX_MCLK by in order to produce the transmit bit clock.
	// Position of TX_BITRATE field.
	I2S_TXBITRATE_TX_BITRATE_Pos = 0x0
	// Bit mask of TX_BITRATE field.
	I2S_TXBITRATE_TX_BITRATE_Msk = 0x3f
	// Position of RESERVED field.
	I2S_TXBITRATE_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	I2S_TXBITRATE_RESERVED_Msk = 0xffffffc0

	// RXBITRATE: I2S Receive bit rate divider. This register determines the I2S receive bit rate by specifying the value to divide RX_MCLK by in order to produce the receive bit clock.
	// Position of RX_BITRATE field.
	I2S_RXBITRATE_RX_BITRATE_Pos = 0x0
	// Bit mask of RX_BITRATE field.
	I2S_RXBITRATE_RX_BITRATE_Msk = 0x3f
	// Position of RESERVED field.
	I2S_RXBITRATE_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	I2S_RXBITRATE_RESERVED_Msk = 0xffffffc0

	// TXMODE: I2S Transmit mode control.
	// Position of TXCLKSEL field.
	I2S_TXMODE_TXCLKSEL_Pos = 0x0
	// Bit mask of TXCLKSEL field.
	I2S_TXMODE_TXCLKSEL_Msk = 0x3
	// Select the TX fractional rate divider clock output as the source
	I2S_TXMODE_TXCLKSEL_SELECT_THE_TX_FRACTI = 0x0
	// Select the RX_MCLK signal as the TX_MCLK clock source
	I2S_TXMODE_TXCLKSEL_SELECT_THE_RX_MCLK_S = 0x2
	// Position of TX4PIN field.
	I2S_TXMODE_TX4PIN_Pos = 0x2
	// Bit mask of TX4PIN field.
	I2S_TXMODE_TX4PIN_Msk = 0x4
	// Bit TX4PIN.
	I2S_TXMODE_TX4PIN = 0x4
	// Position of TXMCENA field.
	I2S_TXMODE_TXMCENA_Pos = 0x3
	// Bit mask of TXMCENA field.
	I2S_TXMODE_TXMCENA_Msk = 0x8
	// Bit TXMCENA.
	I2S_TXMODE_TXMCENA = 0x8
	// Position of RESERVED field.
	I2S_TXMODE_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	I2S_TXMODE_RESERVED_Msk = 0xfffffff0

	// RXMODE: I2S Receive mode control.
	// Position of RXCLKSEL field.
	I2S_RXMODE_RXCLKSEL_Pos = 0x0
	// Bit mask of RXCLKSEL field.
	I2S_RXMODE_RXCLKSEL_Msk = 0x3
	// Select the RX fractional rate divider clock output as the source
	I2S_RXMODE_RXCLKSEL_SELECT_THE_RX_FRACTI = 0x0
	// Select the TX_MCLK signal as the RX_MCLK clock source
	I2S_RXMODE_RXCLKSEL_SELECT_THE_TX_MCLK_S = 0x2
	// Position of RX4PIN field.
	I2S_RXMODE_RX4PIN_Pos = 0x2
	// Bit mask of RX4PIN field.
	I2S_RXMODE_RX4PIN_Msk = 0x4
	// Bit RX4PIN.
	I2S_RXMODE_RX4PIN = 0x4
	// Position of RXMCENA field.
	I2S_RXMODE_RXMCENA_Pos = 0x3
	// Bit mask of RXMCENA field.
	I2S_RXMODE_RXMCENA_Msk = 0x8
	// Bit RXMCENA.
	I2S_RXMODE_RXMCENA = 0x8
	// Position of RESERVED field.
	I2S_RXMODE_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	I2S_RXMODE_RESERVED_Msk = 0xfffffff0
)

// Constants for C_CAN1: C_CAN
const (
	// CNTL: CAN control
	// Position of INIT field.
	C_CAN1_CNTL_INIT_Pos = 0x0
	// Bit mask of INIT field.
	C_CAN1_CNTL_INIT_Msk = 0x1
	// Bit INIT.
	C_CAN1_CNTL_INIT = 0x1
	// Initialization is started. On reset, software needs to initialize the CAN controller.
	C_CAN1_CNTL_INIT_INITIALIZATION_IS_ST = 0x1
	// Normal operation.
	C_CAN1_CNTL_INIT_NORMAL_OPERATION_ = 0x0
	// Position of IE field.
	C_CAN1_CNTL_IE_Pos = 0x1
	// Bit mask of IE field.
	C_CAN1_CNTL_IE_Msk = 0x2
	// Bit IE.
	C_CAN1_CNTL_IE = 0x2
	// Enable CAN interrupts. The interrupt line is set to LOW and remains LOW until all pending interrupts are cleared.
	C_CAN1_CNTL_IE_ENABLE_CAN_INTERRUPT = 0x1
	// Disable CAN interrupts. The interrupt line is always HIGH.
	C_CAN1_CNTL_IE_DISABLE_CAN_INTERRUP = 0x0
	// Position of SIE field.
	C_CAN1_CNTL_SIE_Pos = 0x2
	// Bit mask of SIE field.
	C_CAN1_CNTL_SIE_Msk = 0x4
	// Bit SIE.
	C_CAN1_CNTL_SIE = 0x4
	// Enable status change interrupts. A status change interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected.
	C_CAN1_CNTL_SIE_ENABLE_STATUS_CHANGE = 0x1
	// Disable status change interrupts. No status change interrupt will be generated.
	C_CAN1_CNTL_SIE_DISABLE_STATUS_CHANG = 0x0
	// Position of EIE field.
	C_CAN1_CNTL_EIE_Pos = 0x3
	// Bit mask of EIE field.
	C_CAN1_CNTL_EIE_Msk = 0x8
	// Bit EIE.
	C_CAN1_CNTL_EIE = 0x8
	// Enable error interrupt. A change in the bits BOFF or EWARN in the CANSTAT registers will generate an interrupt.
	C_CAN1_CNTL_EIE_ENABLE_ERROR_INTERRU = 0x1
	// Disable error interrupt. No error status interrupt will be generated.
	C_CAN1_CNTL_EIE_DISABLE_ERROR_INTERR = 0x0
	// Position of RESERVED field.
	C_CAN1_CNTL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	C_CAN1_CNTL_RESERVED_Msk = 0x10
	// Bit RESERVED.
	C_CAN1_CNTL_RESERVED = 0x10
	// Position of DAR field.
	C_CAN1_CNTL_DAR_Pos = 0x5
	// Bit mask of DAR field.
	C_CAN1_CNTL_DAR_Msk = 0x20
	// Bit DAR.
	C_CAN1_CNTL_DAR = 0x20
	// Automatic retransmission disabled.
	C_CAN1_CNTL_DAR_DISABLED = 0x1
	// Automatic retransmission of disturbed messages enabled.
	C_CAN1_CNTL_DAR_ENABLED = 0x0
	// Position of CCE field.
	C_CAN1_CNTL_CCE_Pos = 0x6
	// Bit mask of CCE field.
	C_CAN1_CNTL_CCE_Msk = 0x40
	// Bit CCE.
	C_CAN1_CNTL_CCE = 0x40
	// The CPU has write access to the CANBT register while the INIT bit is one.
	C_CAN1_CNTL_CCE_THE_CPU_HAS_WRITE_AC = 0x1
	// The CPU has no write access to the bit timing register.
	C_CAN1_CNTL_CCE_THE_CPU_HAS_NO_WRITE = 0x0
	// Position of TEST field.
	C_CAN1_CNTL_TEST_Pos = 0x7
	// Bit mask of TEST field.
	C_CAN1_CNTL_TEST_Msk = 0x80
	// Bit TEST.
	C_CAN1_CNTL_TEST = 0x80
	// Test mode.
	C_CAN1_CNTL_TEST_TEST_MODE_ = 0x1
	// Normal operation.
	C_CAN1_CNTL_TEST_NORMAL_OPERATION_ = 0x0
	// Position of RESERVED field.
	C_CAN1_CNTL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN1_CNTL_RESERVED_Msk = 0xffffff00

	// STAT: Status register
	// Position of LEC field.
	C_CAN1_STAT_LEC_Pos = 0x0
	// Bit mask of LEC field.
	C_CAN1_STAT_LEC_Msk = 0x7
	// No error.
	C_CAN1_STAT_LEC_NO_ERROR_ = 0x0
	// Stuff error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
	C_CAN1_STAT_LEC_STUFF_ERROR_MORE_TH = 0x1
	// Form error: A fixed format part of a received frame has the wrong format.
	C_CAN1_STAT_LEC_FORM_ERROR_A_FIXED_ = 0x2
	// AckError: The message this CAN core transmitted was not acknowledged.
	C_CAN1_STAT_LEC_ACKERROR_THE_MESSAG = 0x3
	// Bit1Error: During the transmission of a message (with the exception of the arbitration field), the device wanted to send a HIGH/recessive level (bit of logical value 1), but the monitored bus value was LOW/dominant.
	C_CAN1_STAT_LEC_BIT1ERROR_DURING_TH = 0x4
	// Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a LOW/dominant level (data or identifier bit logical value 0), but the monitored Bus value was HIGH/recessive. During busoff recovery this status is set each time a sequence of 11 HIGH/recessive bits has been monitored. This enables the CPU to monitor the proceeding of the busoff recovery sequence (indicating the bus is not stuck at LOW/dominant or continuously disturbed).
	C_CAN1_STAT_LEC_BIT0ERROR_DURING_TH = 0x5
	// CRCError: The CRC checksum was incorrect in the message received.
	C_CAN1_STAT_LEC_CRCERROR_THE_CRC_CH = 0x6
	// Unused: No CAN bus event was detected (written by the CPU).
	C_CAN1_STAT_LEC_UNUSED_NO_CAN_BUS_E = 0x7
	// Position of TXOK field.
	C_CAN1_STAT_TXOK_Pos = 0x3
	// Bit mask of TXOK field.
	C_CAN1_STAT_TXOK_Msk = 0x8
	// Bit TXOK.
	C_CAN1_STAT_TXOK = 0x8
	// Since this bit was last reset by the CPU, a message has been successfully transmitted (error free and acknowledged by at least one other node).
	C_CAN1_STAT_TXOK_MSGTRANSFER = 0x1
	// Since this bit was reset by the CPU, no message has been successfully transmitted.
	C_CAN1_STAT_TXOK_NOMSGTRANSFER = 0x0
	// Position of RXOK field.
	C_CAN1_STAT_RXOK_Pos = 0x4
	// Bit mask of RXOK field.
	C_CAN1_STAT_RXOK_Msk = 0x10
	// Bit RXOK.
	C_CAN1_STAT_RXOK = 0x10
	// Since this bit was last set to zero by the CPU, a message has been successfully received independent of the result of acceptance filtering.
	C_CAN1_STAT_RXOK_MSGTRANSFER = 0x1
	// Since this bit was last reset by the CPU, no message has been successfully transmitted.
	C_CAN1_STAT_RXOK_NOMSGTRANSFER = 0x0
	// Position of EPASS field.
	C_CAN1_STAT_EPASS_Pos = 0x5
	// Bit mask of EPASS field.
	C_CAN1_STAT_EPASS_Msk = 0x20
	// Bit EPASS.
	C_CAN1_STAT_EPASS = 0x20
	// The CAN controller is in the error passive state as defined in the CAN 2.0 specification.
	C_CAN1_STAT_EPASS_PASSIVE = 0x1
	// The CAN controller is in the error active state.
	C_CAN1_STAT_EPASS_ACTIVE = 0x0
	// Position of EWARN field.
	C_CAN1_STAT_EWARN_Pos = 0x6
	// Bit mask of EWARN field.
	C_CAN1_STAT_EWARN_Msk = 0x40
	// Bit EWARN.
	C_CAN1_STAT_EWARN = 0x40
	// At least one of the error counters in the EML has reached the error warning limit of 96.
	C_CAN1_STAT_EWARN_AT_LEAST_ONE_OF_THE_ = 0x1
	// Both error counters are below the error warning limit of 96.
	C_CAN1_STAT_EWARN_BOTH_ERROR_COUNTERS_ = 0x0
	// Position of BOFF field.
	C_CAN1_STAT_BOFF_Pos = 0x7
	// Bit mask of BOFF field.
	C_CAN1_STAT_BOFF_Msk = 0x80
	// Bit BOFF.
	C_CAN1_STAT_BOFF = 0x80
	// The CAN controller is in busoff state.
	C_CAN1_STAT_BOFF_BUSOFF = 0x1
	// The CAN module is not in busoff.
	C_CAN1_STAT_BOFF_NOBUSOFF = 0x0
	// Position of RESERVED field.
	C_CAN1_STAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN1_STAT_RESERVED_Msk = 0xffffff00

	// EC: Error counter
	// Position of TEC_7_0 field.
	C_CAN1_EC_TEC_7_0_Pos = 0x0
	// Bit mask of TEC_7_0 field.
	C_CAN1_EC_TEC_7_0_Msk = 0xff
	// Position of REC_6_0 field.
	C_CAN1_EC_REC_6_0_Pos = 0x8
	// Bit mask of REC_6_0 field.
	C_CAN1_EC_REC_6_0_Msk = 0x7f00
	// Position of RP field.
	C_CAN1_EC_RP_Pos = 0xf
	// Bit mask of RP field.
	C_CAN1_EC_RP_Msk = 0x8000
	// Bit RP.
	C_CAN1_EC_RP = 0x8000
	// The receive counter has reached the error passive level as defined in the CAN2.0 specification.
	C_CAN1_EC_RP_PASSIVE = 0x1
	// The receive counter is below the error passive level.
	C_CAN1_EC_RP_BELOWPASSIVE = 0x0
	// Position of RESERVED field.
	C_CAN1_EC_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_EC_RESERVED_Msk = 0xffff0000

	// BT: Bit timing register
	// Position of BRP field.
	C_CAN1_BT_BRP_Pos = 0x0
	// Bit mask of BRP field.
	C_CAN1_BT_BRP_Msk = 0x3f
	// Position of SJW field.
	C_CAN1_BT_SJW_Pos = 0x6
	// Bit mask of SJW field.
	C_CAN1_BT_SJW_Msk = 0xc0
	// Position of TSEG1 field.
	C_CAN1_BT_TSEG1_Pos = 0x8
	// Bit mask of TSEG1 field.
	C_CAN1_BT_TSEG1_Msk = 0xf00
	// Position of TSEG2 field.
	C_CAN1_BT_TSEG2_Pos = 0xc
	// Bit mask of TSEG2 field.
	C_CAN1_BT_TSEG2_Msk = 0x7000
	// Position of RESERVED field.
	C_CAN1_BT_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	C_CAN1_BT_RESERVED_Msk = 0xffff8000

	// INT: Interrupt register
	// Position of INTID15_0 field.
	C_CAN1_INT_INTID15_0_Pos = 0x0
	// Bit mask of INTID15_0 field.
	C_CAN1_INT_INTID15_0_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_INT_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_INT_RESERVED_Msk = 0xffff0000

	// TEST: Test register
	// Position of RESERVED field.
	C_CAN1_TEST_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	C_CAN1_TEST_RESERVED_Msk = 0x3
	// Position of BASIC field.
	C_CAN1_TEST_BASIC_Pos = 0x2
	// Bit mask of BASIC field.
	C_CAN1_TEST_BASIC_Msk = 0x4
	// Bit BASIC.
	C_CAN1_TEST_BASIC = 0x4
	// IF1 registers used as TX buffer, IF2 registers used as RX buffer.
	C_CAN1_TEST_BASIC_IF1_TX_if2_rx = 0x1
	// Basic mode disabled.
	C_CAN1_TEST_BASIC_BASIC_MODE_DISABLED_ = 0x0
	// Position of SILENT field.
	C_CAN1_TEST_SILENT_Pos = 0x3
	// Bit mask of SILENT field.
	C_CAN1_TEST_SILENT_Msk = 0x8
	// Bit SILENT.
	C_CAN1_TEST_SILENT = 0x8
	// The module is in silent mode.
	C_CAN1_TEST_SILENT_SILENT = 0x1
	// Normal operation.
	C_CAN1_TEST_SILENT_NORMAL_OPERATION_ = 0x0
	// Position of LBACK field.
	C_CAN1_TEST_LBACK_Pos = 0x4
	// Bit mask of LBACK field.
	C_CAN1_TEST_LBACK_Msk = 0x10
	// Bit LBACK.
	C_CAN1_TEST_LBACK = 0x10
	// Loop back mode is enabled.
	C_CAN1_TEST_LBACK_ENABLED = 0x1
	// Loop back mode is disabled.
	C_CAN1_TEST_LBACK_DISABLED = 0x0
	// Position of TX1_0 field.
	C_CAN1_TEST_TX1_0_Pos = 0x5
	// Bit mask of TX1_0 field.
	C_CAN1_TEST_TX1_0_Msk = 0x60
	// Level at the TD pin is controlled by the CAN controller. This is the value at reset.
	C_CAN1_TEST_TX1_0_LEVEL_AT_THE_TD_PIN_ = 0x0
	// The sample point can be monitored at the TD pin.
	C_CAN1_TEST_TX1_0_THE_SAMPLE_POINT_CAN = 0x1
	// TD pin is driven LOW/dominant.
	C_CAN1_TEST_TX1_0_TD_PIN_IS_DRIVEN_LOW = 0x2
	// TD pin is driven HIGH/recessive.
	C_CAN1_TEST_TX1_0_TD_PIN_IS_DRIVEN_HIG = 0x3
	// Position of RX field.
	C_CAN1_TEST_RX_Pos = 0x7
	// Bit mask of RX field.
	C_CAN1_TEST_RX_Msk = 0x80
	// Bit RX.
	C_CAN1_TEST_RX = 0x80
	// The CAN bus is recessive (RD = 1).
	C_CAN1_TEST_RX_THE_CAN_BUS_IS_RECES = 0x1
	// The CAN bus is dominant (RD = 0).
	C_CAN1_TEST_RX_THE_CAN_BUS_IS_DOMIN = 0x0
	// Position of RESERVED field.
	C_CAN1_TEST_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN1_TEST_RESERVED_Msk = 0xffffff00

	// BRPE: Baud rate prescaler extension register
	// Position of BRPE field.
	C_CAN1_BRPE_BRPE_Pos = 0x0
	// Bit mask of BRPE field.
	C_CAN1_BRPE_BRPE_Msk = 0xf
	// Position of RESERVED field.
	C_CAN1_BRPE_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	C_CAN1_BRPE_RESERVED_Msk = 0xfffffff0

	// IF1_CMDREQ: Message interface command request
	// Position of MESSNUM field.
	C_CAN1_IF_CMDREQ_MESSNUM_Pos = 0x0
	// Bit mask of MESSNUM field.
	C_CAN1_IF_CMDREQ_MESSNUM_Msk = 0x3f
	// Position of RESERVED field.
	C_CAN1_IF_CMDREQ_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	C_CAN1_IF_CMDREQ_RESERVED_Msk = 0x7fc0
	// Position of BUSY field.
	C_CAN1_IF_CMDREQ_BUSY_Pos = 0xf
	// Bit mask of BUSY field.
	C_CAN1_IF_CMDREQ_BUSY_Msk = 0x8000
	// Bit BUSY.
	C_CAN1_IF_CMDREQ_BUSY = 0x8000
	// Position of RESERVED field.
	C_CAN1_IF_CMDREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_CMDREQ_RESERVED_Msk = 0xffff0000

	// IF1_CMDMSK_W: Message interface command mask (write direction)
	// Position of DATA_B field.
	C_CAN1_IF_CMDMSK_W_DATA_B_Pos = 0x0
	// Bit mask of DATA_B field.
	C_CAN1_IF_CMDMSK_W_DATA_B_Msk = 0x1
	// Bit DATA_B.
	C_CAN1_IF_CMDMSK_W_DATA_B = 0x1
	// Transfer data bytes 4-7 to message object.
	C_CAN1_IF_CMDMSK_W_DATA_B_TRANSFER_DATA_BYTES_ = 0x1
	// data bytes 4-7 unchanged.
	C_CAN1_IF_CMDMSK_W_DATA_B_DATA_BYTES_4_7_UNCHA = 0x0
	// Position of DATA_A field.
	C_CAN1_IF_CMDMSK_W_DATA_A_Pos = 0x1
	// Bit mask of DATA_A field.
	C_CAN1_IF_CMDMSK_W_DATA_A_Msk = 0x2
	// Bit DATA_A.
	C_CAN1_IF_CMDMSK_W_DATA_A = 0x2
	// Transfer data bytes 0-3 to message object.
	C_CAN1_IF_CMDMSK_W_DATA_A_TRANSFER_DATA_BYTES_ = 0x1
	// data bytes 0-3 unchanged.
	C_CAN1_IF_CMDMSK_W_DATA_A_DATA_BYTES_0_3_UNCHA = 0x0
	// Position of TXRQST field.
	C_CAN1_IF_CMDMSK_W_TXRQST_Pos = 0x2
	// Bit mask of TXRQST field.
	C_CAN1_IF_CMDMSK_W_TXRQST_Msk = 0x4
	// Bit TXRQST.
	C_CAN1_IF_CMDMSK_W_TXRQST = 0x4
	// Request a transmission. Set the TXRQST bit IF1/2_MCTRL.
	C_CAN1_IF_CMDMSK_W_TXRQST_REQUEST_A_TRANSMISSI = 0x1
	// No transmission request. TXRQSRT bit unchanged in IF1/2_MCTRL. If a transmission is requested by programming this bit, the TXRQST bit in the CANIFn_MCTRL register is ignored.
	C_CAN1_IF_CMDMSK_W_TXRQST_NO_TRANSMISSION_REQU = 0x0
	// Position of CLRINTPND field.
	C_CAN1_IF_CMDMSK_W_CLRINTPND_Pos = 0x3
	// Bit mask of CLRINTPND field.
	C_CAN1_IF_CMDMSK_W_CLRINTPND_Msk = 0x8
	// Bit CLRINTPND.
	C_CAN1_IF_CMDMSK_W_CLRINTPND = 0x8
	// Position of CTRL field.
	C_CAN1_IF_CMDMSK_W_CTRL_Pos = 0x4
	// Bit mask of CTRL field.
	C_CAN1_IF_CMDMSK_W_CTRL_Msk = 0x10
	// Bit CTRL.
	C_CAN1_IF_CMDMSK_W_CTRL = 0x10
	// Transfer control bits to message object
	C_CAN1_IF_CMDMSK_W_CTRL_TRANSFER_CONTROL_BIT = 0x1
	// Control bits unchanged.
	C_CAN1_IF_CMDMSK_W_CTRL_CONTROL_BITS_UNCHANG = 0x0
	// Position of ARB field.
	C_CAN1_IF_CMDMSK_W_ARB_Pos = 0x5
	// Bit mask of ARB field.
	C_CAN1_IF_CMDMSK_W_ARB_Msk = 0x20
	// Bit ARB.
	C_CAN1_IF_CMDMSK_W_ARB = 0x20
	// Transfer Identifier, DIR, XTD, and MSGVAL bits to message object.
	C_CAN1_IF_CMDMSK_W_ARB_TRANSFER_IDENTIFIER = 0x1
	// Arbitration bits unchanged.
	C_CAN1_IF_CMDMSK_W_ARB_ARBITRATION_BITS_UNC = 0x0
	// Position of MASK field.
	C_CAN1_IF_CMDMSK_W_MASK_Pos = 0x6
	// Bit mask of MASK field.
	C_CAN1_IF_CMDMSK_W_MASK_Msk = 0x40
	// Bit MASK.
	C_CAN1_IF_CMDMSK_W_MASK = 0x40
	// Transfer Identifier MASK + MDIR + MXTD to message object.
	C_CAN1_IF_CMDMSK_W_MASK_TRANSFER_IDENTIFIER_ = 0x1
	// Mask bits unchanged.
	C_CAN1_IF_CMDMSK_W_MASK_MASK_BITS_UNCHANGED_ = 0x0
	// Position of WR_RD field.
	C_CAN1_IF_CMDMSK_W_WR_RD_Pos = 0x7
	// Bit mask of WR_RD field.
	C_CAN1_IF_CMDMSK_W_WR_RD_Msk = 0x80
	// Bit WR_RD.
	C_CAN1_IF_CMDMSK_W_WR_RD = 0x80
	// Position of RESERVED field.
	C_CAN1_IF_CMDMSK_W_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN1_IF_CMDMSK_W_RESERVED_Msk = 0xffffff00

	// IF1_CMDMSK_R: Message interface command mask (read direction)
	// Position of DATA_B field.
	C_CAN1_IF_CMDMSK_R_DATA_B_Pos = 0x0
	// Bit mask of DATA_B field.
	C_CAN1_IF_CMDMSK_R_DATA_B_Msk = 0x1
	// Bit DATA_B.
	C_CAN1_IF_CMDMSK_R_DATA_B = 0x1
	// Transfer data bytes 4-7 to IFx message buffer register.
	C_CAN1_IF_CMDMSK_R_DATA_B_TRANSFER_DATA_BYTES_ = 0x1
	// data bytes 4-7 unchanged.
	C_CAN1_IF_CMDMSK_R_DATA_B_DATA_BYTES_4_7_UNCHA = 0x0
	// Position of DATA_A field.
	C_CAN1_IF_CMDMSK_R_DATA_A_Pos = 0x1
	// Bit mask of DATA_A field.
	C_CAN1_IF_CMDMSK_R_DATA_A_Msk = 0x2
	// Bit DATA_A.
	C_CAN1_IF_CMDMSK_R_DATA_A = 0x2
	// Transfer data bytes 0-3 to IFx message buffer.
	C_CAN1_IF_CMDMSK_R_DATA_A_TRANSFER_DATA_BYTES_ = 0x1
	// data bytes 0-3 unchanged.
	C_CAN1_IF_CMDMSK_R_DATA_A_DATA_BYTES_0_3_UNCHA = 0x0
	// Position of NEWDAT field.
	C_CAN1_IF_CMDMSK_R_NEWDAT_Pos = 0x2
	// Bit mask of NEWDAT field.
	C_CAN1_IF_CMDMSK_R_NEWDAT_Msk = 0x4
	// Bit NEWDAT.
	C_CAN1_IF_CMDMSK_R_NEWDAT = 0x4
	// Clear NEWDAT bit in the message object.
	C_CAN1_IF_CMDMSK_R_NEWDAT_CLEAR_NEWDAT_BIT_IN_ = 0x1
	// NEWDAT bit remains unchanged. A read access to a message object can be combined with the reset of the control bits INTPND and NEWDAT in IF1/2_MCTRL. The values of these bits transferred to the IFx Message Control Register always reflect the status before resetting these bits.
	C_CAN1_IF_CMDMSK_R_NEWDAT_NEWDAT_BIT_REMAINS_U = 0x0
	// Position of CLRINTPND field.
	C_CAN1_IF_CMDMSK_R_CLRINTPND_Pos = 0x3
	// Bit mask of CLRINTPND field.
	C_CAN1_IF_CMDMSK_R_CLRINTPND_Msk = 0x8
	// Bit CLRINTPND.
	C_CAN1_IF_CMDMSK_R_CLRINTPND = 0x8
	// Clear INTPND bit in the message object.
	C_CAN1_IF_CMDMSK_R_CLRINTPND_CLEAR_INTPND_BIT_IN_ = 0x1
	// INTPND bit remains unchanged.
	C_CAN1_IF_CMDMSK_R_CLRINTPND_INTPND_BIT_REMAINS_U = 0x0
	// Position of CTRL field.
	C_CAN1_IF_CMDMSK_R_CTRL_Pos = 0x4
	// Bit mask of CTRL field.
	C_CAN1_IF_CMDMSK_R_CTRL_Msk = 0x10
	// Bit CTRL.
	C_CAN1_IF_CMDMSK_R_CTRL = 0x10
	// Transfer control bits to IFx message buffer.
	C_CAN1_IF_CMDMSK_R_CTRL_TRANSFER_CONTROL_BIT = 0x1
	// Control bits unchanged.
	C_CAN1_IF_CMDMSK_R_CTRL_CONTROL_BITS_UNCHANG = 0x0
	// Position of ARB field.
	C_CAN1_IF_CMDMSK_R_ARB_Pos = 0x5
	// Bit mask of ARB field.
	C_CAN1_IF_CMDMSK_R_ARB_Msk = 0x20
	// Bit ARB.
	C_CAN1_IF_CMDMSK_R_ARB = 0x20
	// Transfer Identifier, DIR, XTD, and MSGVAL bits to IFx message buffer register.
	C_CAN1_IF_CMDMSK_R_ARB_TRANSFER_IDENTIFIER = 0x1
	// Arbitration bits unchanged.
	C_CAN1_IF_CMDMSK_R_ARB_ARBITRATION_BITS_UNC = 0x0
	// Position of MASK field.
	C_CAN1_IF_CMDMSK_R_MASK_Pos = 0x6
	// Bit mask of MASK field.
	C_CAN1_IF_CMDMSK_R_MASK_Msk = 0x40
	// Bit MASK.
	C_CAN1_IF_CMDMSK_R_MASK = 0x40
	// Transfer Identifier MASK + MDIR + MXTD to IFx message buffer register.
	C_CAN1_IF_CMDMSK_R_MASK_TRANSFER_IDENTIFIER_ = 0x1
	// Mask bits unchanged.
	C_CAN1_IF_CMDMSK_R_MASK_MASK_BITS_UNCHANGED_ = 0x0
	// Position of WR_RD field.
	C_CAN1_IF_CMDMSK_R_WR_RD_Pos = 0x7
	// Bit mask of WR_RD field.
	C_CAN1_IF_CMDMSK_R_WR_RD_Msk = 0x80
	// Bit WR_RD.
	C_CAN1_IF_CMDMSK_R_WR_RD = 0x80
	// Position of RESERVED field.
	C_CAN1_IF_CMDMSK_R_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN1_IF_CMDMSK_R_RESERVED_Msk = 0xffffff00

	// IF1_MSK1: Message interface mask 1
	// Position of MSK15_0 field.
	C_CAN1_IF_MSK1_MSK15_0_Pos = 0x0
	// Bit mask of MSK15_0 field.
	C_CAN1_IF_MSK1_MSK15_0_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_IF_MSK1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_MSK1_RESERVED_Msk = 0xffff0000

	// IF1_MSK2: Message interface 1 mask 2
	// Position of MSK28_16 field.
	C_CAN1_IF_MSK2_MSK28_16_Pos = 0x0
	// Bit mask of MSK28_16 field.
	C_CAN1_IF_MSK2_MSK28_16_Msk = 0x1fff
	// Position of RESERVED field.
	C_CAN1_IF_MSK2_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	C_CAN1_IF_MSK2_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	C_CAN1_IF_MSK2_RESERVED = 0x2000
	// Position of MDIR field.
	C_CAN1_IF_MSK2_MDIR_Pos = 0xe
	// Bit mask of MDIR field.
	C_CAN1_IF_MSK2_MDIR_Msk = 0x4000
	// Bit MDIR.
	C_CAN1_IF_MSK2_MDIR = 0x4000
	// Position of MXTD field.
	C_CAN1_IF_MSK2_MXTD_Pos = 0xf
	// Bit mask of MXTD field.
	C_CAN1_IF_MSK2_MXTD_Msk = 0x8000
	// Bit MXTD.
	C_CAN1_IF_MSK2_MXTD = 0x8000
	// Position of RESERVED field.
	C_CAN1_IF_MSK2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_MSK2_RESERVED_Msk = 0xffff0000

	// IF1_ARB1: Message interface 1 arbitration 1
	// Position of ID15_0 field.
	C_CAN1_IF_ARB1_ID15_0_Pos = 0x0
	// Bit mask of ID15_0 field.
	C_CAN1_IF_ARB1_ID15_0_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_IF_ARB1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_ARB1_RESERVED_Msk = 0xffff0000

	// IF1_ARB2: Message interface 1 arbitration 2
	// Position of ID28_16 field.
	C_CAN1_IF_ARB2_ID28_16_Pos = 0x0
	// Bit mask of ID28_16 field.
	C_CAN1_IF_ARB2_ID28_16_Msk = 0x1fff
	// Position of DIR field.
	C_CAN1_IF_ARB2_DIR_Pos = 0xd
	// Bit mask of DIR field.
	C_CAN1_IF_ARB2_DIR_Msk = 0x2000
	// Bit DIR.
	C_CAN1_IF_ARB2_DIR = 0x2000
	// Direction = transmit. On TXRQST, the respective Message Object is transmitted as a Data Frame. On reception of a Remote Frame with matching identifier, the TXRQST bit of this Message Object is set (if RMTEN = one).
	C_CAN1_IF_ARB2_DIR_DIRECTION_EQ_TRANSMIT = 0x1
	// Direction = receive. On TXRQST, a Remote Frame with the identifier of this Message Object is transmitted. On reception of a Data Frame with matching identifier, that message is stored in this Message Object.
	C_CAN1_IF_ARB2_DIR_DIRECTION_EQ_RECEIVE_ = 0x0
	// Position of XTD field.
	C_CAN1_IF_ARB2_XTD_Pos = 0xe
	// Bit mask of XTD field.
	C_CAN1_IF_ARB2_XTD_Msk = 0x4000
	// Bit XTD.
	C_CAN1_IF_ARB2_XTD = 0x4000
	// The 29-bit extended identifier will be used for this message object.
	C_CAN1_IF_ARB2_XTD_THE_29_BIT_EXTENDED_ = 0x1
	// The 11-bit standard identifier will be used for this message object.
	C_CAN1_IF_ARB2_XTD_THE_11_BIT_STANDARD_ = 0x0
	// Position of MSGVAL field.
	C_CAN1_IF_ARB2_MSGVAL_Pos = 0xf
	// Bit mask of MSGVAL field.
	C_CAN1_IF_ARB2_MSGVAL_Msk = 0x8000
	// Bit MSGVAL.
	C_CAN1_IF_ARB2_MSGVAL = 0x8000
	// Position of RESERVED field.
	C_CAN1_IF_ARB2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_ARB2_RESERVED_Msk = 0xffff0000

	// IF1_MCTRL: Message interface 1 message control
	// Position of DLC3_0 field.
	C_CAN1_IF_MCTRL_DLC3_0_Pos = 0x0
	// Bit mask of DLC3_0 field.
	C_CAN1_IF_MCTRL_DLC3_0_Msk = 0xf
	// Position of RESERVED field.
	C_CAN1_IF_MCTRL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	C_CAN1_IF_MCTRL_RESERVED_Msk = 0x70
	// Position of EOB field.
	C_CAN1_IF_MCTRL_EOB_Pos = 0x7
	// Bit mask of EOB field.
	C_CAN1_IF_MCTRL_EOB_Msk = 0x80
	// Bit EOB.
	C_CAN1_IF_MCTRL_EOB = 0x80
	// Single message object or last message object of a FIFO buffer.
	C_CAN1_IF_MCTRL_EOB_SINGLE_MESSAGE_OBJEC = 0x1
	// Message object belongs to a FIFO buffer and is not the last message object of that FIFO buffer.
	C_CAN1_IF_MCTRL_EOB_MESSAGE_OBJECT_BELON = 0x0
	// Position of TXRQST field.
	C_CAN1_IF_MCTRL_TXRQST_Pos = 0x8
	// Bit mask of TXRQST field.
	C_CAN1_IF_MCTRL_TXRQST_Msk = 0x100
	// Bit TXRQST.
	C_CAN1_IF_MCTRL_TXRQST = 0x100
	// The transmission of this message object is requested and is not yet done
	C_CAN1_IF_MCTRL_TXRQST_REQUEST = 0x1
	// This message object is not waiting for transmission.
	C_CAN1_IF_MCTRL_TXRQST_WAIT = 0x0
	// Position of RMTEN field.
	C_CAN1_IF_MCTRL_RMTEN_Pos = 0x9
	// Bit mask of RMTEN field.
	C_CAN1_IF_MCTRL_RMTEN_Msk = 0x200
	// Bit RMTEN.
	C_CAN1_IF_MCTRL_RMTEN = 0x200
	// At the reception of a remote frame, TXRQST is set.
	C_CAN1_IF_MCTRL_RMTEN_TXRQSTSET = 0x1
	// At the reception of a remote frame, TXRQST is left unchanged.
	C_CAN1_IF_MCTRL_RMTEN_UNCHANGED = 0x0
	// Position of RXIE field.
	C_CAN1_IF_MCTRL_RXIE_Pos = 0xa
	// Bit mask of RXIE field.
	C_CAN1_IF_MCTRL_RXIE_Msk = 0x400
	// Bit RXIE.
	C_CAN1_IF_MCTRL_RXIE = 0x400
	// INTPND will be set after successful reception of a frame.
	C_CAN1_IF_MCTRL_RXIE_INTPNDSET = 0x1
	// INTPND will be left unchanged after successful reception of a frame.
	C_CAN1_IF_MCTRL_RXIE_UNCHANGED = 0x0
	// Position of TXIE field.
	C_CAN1_IF_MCTRL_TXIE_Pos = 0xb
	// Bit mask of TXIE field.
	C_CAN1_IF_MCTRL_TXIE_Msk = 0x800
	// Bit TXIE.
	C_CAN1_IF_MCTRL_TXIE = 0x800
	// INTPND will be set after a successful reception of a frame.
	C_CAN1_IF_MCTRL_TXIE_INTPNDSET = 0x1
	// The INTPND bit will be left unchanged after a successful reception of a frame.
	C_CAN1_IF_MCTRL_TXIE_UNCHANGED = 0x0
	// Position of UMASK field.
	C_CAN1_IF_MCTRL_UMASK_Pos = 0xc
	// Bit mask of UMASK field.
	C_CAN1_IF_MCTRL_UMASK_Msk = 0x1000
	// Bit UMASK.
	C_CAN1_IF_MCTRL_UMASK = 0x1000
	// Use mask (MSK[28:0], MXTD, and MDIR) for acceptance filtering.
	C_CAN1_IF_MCTRL_UMASK_USE_MASK = 0x1
	// Mask ignored.
	C_CAN1_IF_MCTRL_UMASK_MASK_IGNORED_ = 0x0
	// Position of INTPND field.
	C_CAN1_IF_MCTRL_INTPND_Pos = 0xd
	// Bit mask of INTPND field.
	C_CAN1_IF_MCTRL_INTPND_Msk = 0x2000
	// Bit INTPND.
	C_CAN1_IF_MCTRL_INTPND = 0x2000
	// This message object is the source of an interrupt. The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
	C_CAN1_IF_MCTRL_INTPND_INTSOURCE = 0x1
	// This message object is not the source of an interrupt.
	C_CAN1_IF_MCTRL_INTPND_NOINTSOURCE = 0x0
	// Position of MSGLST field.
	C_CAN1_IF_MCTRL_MSGLST_Pos = 0xe
	// Bit mask of MSGLST field.
	C_CAN1_IF_MCTRL_MSGLST_Msk = 0x4000
	// Bit MSGLST.
	C_CAN1_IF_MCTRL_MSGLST = 0x4000
	// The Message Handler stored a new message into this object when NEWDAT was still set, the CPU has lost a message.
	C_CAN1_IF_MCTRL_MSGLST_THE_MESSAGE_HANDLER_ = 0x1
	// No message lost since this bit was reset last by the CPU.
	C_CAN1_IF_MCTRL_MSGLST_NO_MESSAGE_LOST_SINC = 0x0
	// Position of NEWDAT field.
	C_CAN1_IF_MCTRL_NEWDAT_Pos = 0xf
	// Bit mask of NEWDAT field.
	C_CAN1_IF_MCTRL_NEWDAT_Msk = 0x8000
	// Bit NEWDAT.
	C_CAN1_IF_MCTRL_NEWDAT = 0x8000
	// The message handler or the CPU has written new data into the data portion of this message object.
	C_CAN1_IF_MCTRL_NEWDAT_THE_MESSAGE_HANDLER_ = 0x1
	// No new data has been written into the data portion of this message object by the message handler since this flag was cleared last by the CPU.
	C_CAN1_IF_MCTRL_NEWDAT_NO_NEW_DATA_HAS_BEEN = 0x0
	// Position of RESERVED field.
	C_CAN1_IF_MCTRL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_MCTRL_RESERVED_Msk = 0xffff0000

	// IF1_DA1: Message interface data A1
	// Position of DATA0 field.
	C_CAN1_IF_DA1_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	C_CAN1_IF_DA1_DATA0_Msk = 0xff
	// Position of DATA1 field.
	C_CAN1_IF_DA1_DATA1_Pos = 0x8
	// Bit mask of DATA1 field.
	C_CAN1_IF_DA1_DATA1_Msk = 0xff00
	// Position of RESERVED field.
	C_CAN1_IF_DA1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_DA1_RESERVED_Msk = 0xffff0000

	// IF1_DA2: Message interface 1 data A2
	// Position of DATA2 field.
	C_CAN1_IF_DA2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	C_CAN1_IF_DA2_DATA2_Msk = 0xff
	// Position of DATA3 field.
	C_CAN1_IF_DA2_DATA3_Pos = 0x8
	// Bit mask of DATA3 field.
	C_CAN1_IF_DA2_DATA3_Msk = 0xff00
	// Position of RESERVED field.
	C_CAN1_IF_DA2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_DA2_RESERVED_Msk = 0xffff0000

	// IF1_DB1: Message interface 1 data B1
	// Position of DATA4 field.
	C_CAN1_IF_DB1_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	C_CAN1_IF_DB1_DATA4_Msk = 0xff
	// Position of DATA5 field.
	C_CAN1_IF_DB1_DATA5_Pos = 0x8
	// Bit mask of DATA5 field.
	C_CAN1_IF_DB1_DATA5_Msk = 0xff00
	// Position of RESERVED field.
	C_CAN1_IF_DB1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_DB1_RESERVED_Msk = 0xffff0000

	// IF1_DB2: Message interface 1 data B2
	// Position of DATA6 field.
	C_CAN1_IF_DB2_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	C_CAN1_IF_DB2_DATA6_Msk = 0xff
	// Position of DATA7 field.
	C_CAN1_IF_DB2_DATA7_Pos = 0x8
	// Bit mask of DATA7 field.
	C_CAN1_IF_DB2_DATA7_Msk = 0xff00
	// Position of RESERVED field.
	C_CAN1_IF_DB2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IF_DB2_RESERVED_Msk = 0xffff0000

	// TXREQ1: Transmission request 1
	// Position of TXRQST16_1 field.
	C_CAN1_TXREQ1_TXRQST16_1_Pos = 0x0
	// Bit mask of TXRQST16_1 field.
	C_CAN1_TXREQ1_TXRQST16_1_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_TXREQ1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_TXREQ1_RESERVED_Msk = 0xffff0000

	// TXREQ2: Transmission request 2
	// Position of TXRQST32_17 field.
	C_CAN1_TXREQ2_TXRQST32_17_Pos = 0x0
	// Bit mask of TXRQST32_17 field.
	C_CAN1_TXREQ2_TXRQST32_17_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_TXREQ2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_TXREQ2_RESERVED_Msk = 0xffff0000

	// ND1: New data 1
	// Position of NEWDAT16_1 field.
	C_CAN1_ND1_NEWDAT16_1_Pos = 0x0
	// Bit mask of NEWDAT16_1 field.
	C_CAN1_ND1_NEWDAT16_1_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_ND1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_ND1_RESERVED_Msk = 0xffff0000

	// ND2: New data 2
	// Position of NEWDAT32_17 field.
	C_CAN1_ND2_NEWDAT32_17_Pos = 0x0
	// Bit mask of NEWDAT32_17 field.
	C_CAN1_ND2_NEWDAT32_17_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_ND2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_ND2_RESERVED_Msk = 0xffff0000

	// IR1: Interrupt pending 1
	// Position of INTPND16_1 field.
	C_CAN1_IR1_INTPND16_1_Pos = 0x0
	// Bit mask of INTPND16_1 field.
	C_CAN1_IR1_INTPND16_1_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_IR1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IR1_RESERVED_Msk = 0xffff0000

	// IR2: Interrupt pending 2
	// Position of INTPND32_17 field.
	C_CAN1_IR2_INTPND32_17_Pos = 0x0
	// Bit mask of INTPND32_17 field.
	C_CAN1_IR2_INTPND32_17_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_IR2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_IR2_RESERVED_Msk = 0xffff0000

	// MSGV1: Message valid 1
	// Position of MSGVAL16_1 field.
	C_CAN1_MSGV1_MSGVAL16_1_Pos = 0x0
	// Bit mask of MSGVAL16_1 field.
	C_CAN1_MSGV1_MSGVAL16_1_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_MSGV1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_MSGV1_RESERVED_Msk = 0xffff0000

	// MSGV2: Message valid 2
	// Position of MSGVAL32_17 field.
	C_CAN1_MSGV2_MSGVAL32_17_Pos = 0x0
	// Bit mask of MSGVAL32_17 field.
	C_CAN1_MSGV2_MSGVAL32_17_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN1_MSGV2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN1_MSGV2_RESERVED_Msk = 0xffff0000

	// CLKDIV: CAN clock divider register
	// Position of CLKDIVVAL field.
	C_CAN1_CLKDIV_CLKDIVVAL_Pos = 0x0
	// Bit mask of CLKDIVVAL field.
	C_CAN1_CLKDIV_CLKDIVVAL_Msk = 0xf
	// Position of RESERVED field.
	C_CAN1_CLKDIV_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	C_CAN1_CLKDIV_RESERVED_Msk = 0xfffffff0
)

// Constants for RITIMER: Repetitive Interrupt Timer (RIT)
const (
	// COMPVAL: Compare register
	// Position of RICOMP field.
	RITIMER_COMPVAL_RICOMP_Pos = 0x0
	// Bit mask of RICOMP field.
	RITIMER_COMPVAL_RICOMP_Msk = 0xffffffff

	// MASK: Mask register. This register holds the 32-bit mask value. A 1 written to any bit will force a compare on the corresponding bit of the counter and compare register.
	// Position of RIMASK field.
	RITIMER_MASK_RIMASK_Pos = 0x0
	// Bit mask of RIMASK field.
	RITIMER_MASK_RIMASK_Msk = 0xffffffff

	// CTRL: Control register.
	// Position of RITINT field.
	RITIMER_CTRL_RITINT_Pos = 0x0
	// Bit mask of RITINT field.
	RITIMER_CTRL_RITINT_Msk = 0x1
	// Bit RITINT.
	RITIMER_CTRL_RITINT = 0x1
	// This bit is set to 1 by hardware whenever the counter value equals the masked compare value specified by the contents of RICOMPVAL and RIMASK registers. Writing a 1 to this bit will clear it to 0. Writing a 0 has no effect.
	RITIMER_CTRL_RITINT_THIS_BIT_IS_SET_TO_1 = 0x1
	// The counter value does not equal the masked compare value.
	RITIMER_CTRL_RITINT_THE_COUNTER_VALUE_DO = 0x0
	// Position of RITENCLR field.
	RITIMER_CTRL_RITENCLR_Pos = 0x1
	// Bit mask of RITENCLR field.
	RITIMER_CTRL_RITENCLR_Msk = 0x2
	// Bit RITENCLR.
	RITIMER_CTRL_RITENCLR = 0x2
	// The timer will be cleared to 0 whenever the counter value equals the masked compare value specified by the contents of RICOMPVAL and RIMASK registers. This will occur on the same clock that sets the interrupt flag.
	RITIMER_CTRL_RITENCLR_THE_TIMER_WILL_BE_CL = 0x1
	// The timer will not be cleared to 0.
	RITIMER_CTRL_RITENCLR_THE_TIMER_WILL_NOT_B = 0x0
	// Position of RITENBR field.
	RITIMER_CTRL_RITENBR_Pos = 0x2
	// Bit mask of RITENBR field.
	RITIMER_CTRL_RITENBR_Msk = 0x4
	// Bit RITENBR.
	RITIMER_CTRL_RITENBR = 0x4
	// The timer is halted when the processor is halted for debugging.
	RITIMER_CTRL_RITENBR_THE_TIMER_IS_HALTED_ = 0x1
	// Debug has no effect on the timer operation.
	RITIMER_CTRL_RITENBR_DEBUG_HAS_NO_EFFECT_ = 0x0
	// Position of RITEN field.
	RITIMER_CTRL_RITEN_Pos = 0x3
	// Bit mask of RITEN field.
	RITIMER_CTRL_RITEN_Msk = 0x8
	// Bit RITEN.
	RITIMER_CTRL_RITEN = 0x8
	// Timer enabled. This can be overruled by a debug halt if enabled in bit 2.
	RITIMER_CTRL_RITEN_TIMER_ENABLED_THIS_ = 0x1
	// Timer disabled.
	RITIMER_CTRL_RITEN_TIMER_DISABLED_ = 0x0
	// Position of RESERVED field.
	RITIMER_CTRL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RITIMER_CTRL_RESERVED_Msk = 0xfffffff0

	// COUNTER: 32-bit counter
	// Position of RICOUNTER field.
	RITIMER_COUNTER_RICOUNTER_Pos = 0x0
	// Bit mask of RICOUNTER field.
	RITIMER_COUNTER_RICOUNTER_Msk = 0xffffffff
)

// Constants for QEI: Quadrature Encoder Interface (QEI)
const (
	// CON: Control register
	// Position of RESP field.
	QEI_CON_RESP_Pos = 0x0
	// Bit mask of RESP field.
	QEI_CON_RESP_Msk = 0x1
	// Bit RESP.
	QEI_CON_RESP = 0x1
	// Position of RESPI field.
	QEI_CON_RESPI_Pos = 0x1
	// Bit mask of RESPI field.
	QEI_CON_RESPI_Msk = 0x2
	// Bit RESPI.
	QEI_CON_RESPI = 0x2
	// Position of RESV field.
	QEI_CON_RESV_Pos = 0x2
	// Bit mask of RESV field.
	QEI_CON_RESV_Msk = 0x4
	// Bit RESV.
	QEI_CON_RESV = 0x4
	// Position of RESI field.
	QEI_CON_RESI_Pos = 0x3
	// Bit mask of RESI field.
	QEI_CON_RESI_Msk = 0x8
	// Bit RESI.
	QEI_CON_RESI = 0x8
	// Position of RESERVED field.
	QEI_CON_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	QEI_CON_RESERVED_Msk = 0xfffffff0

	// STAT: Encoder status register
	// Position of DIR field.
	QEI_STAT_DIR_Pos = 0x0
	// Bit mask of DIR field.
	QEI_STAT_DIR_Msk = 0x1
	// Bit DIR.
	QEI_STAT_DIR = 0x1
	// Position of RESERVED field.
	QEI_STAT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	QEI_STAT_RESERVED_Msk = 0xfffffffe

	// CONF: Configuration register
	// Position of DIRINV field.
	QEI_CONF_DIRINV_Pos = 0x0
	// Bit mask of DIRINV field.
	QEI_CONF_DIRINV_Msk = 0x1
	// Bit DIRINV.
	QEI_CONF_DIRINV = 0x1
	// Position of SIGMODE field.
	QEI_CONF_SIGMODE_Pos = 0x1
	// Bit mask of SIGMODE field.
	QEI_CONF_SIGMODE_Msk = 0x2
	// Bit SIGMODE.
	QEI_CONF_SIGMODE = 0x2
	// Position of CAPMODE field.
	QEI_CONF_CAPMODE_Pos = 0x2
	// Bit mask of CAPMODE field.
	QEI_CONF_CAPMODE_Msk = 0x4
	// Bit CAPMODE.
	QEI_CONF_CAPMODE = 0x4
	// Position of INVINX field.
	QEI_CONF_INVINX_Pos = 0x3
	// Bit mask of INVINX field.
	QEI_CONF_INVINX_Msk = 0x8
	// Bit INVINX.
	QEI_CONF_INVINX = 0x8
	// Position of CRESPI field.
	QEI_CONF_CRESPI_Pos = 0x4
	// Bit mask of CRESPI field.
	QEI_CONF_CRESPI_Msk = 0x10
	// Bit CRESPI.
	QEI_CONF_CRESPI = 0x10
	// Position of RESERVED field.
	QEI_CONF_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	QEI_CONF_RESERVED_Msk = 0xffe0
	// Position of INXGATE field.
	QEI_CONF_INXGATE_Pos = 0x10
	// Bit mask of INXGATE field.
	QEI_CONF_INXGATE_Msk = 0xf0000
	// Position of RESERVED field.
	QEI_CONF_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	QEI_CONF_RESERVED_Msk = 0xfff00000

	// POS: Position register
	// Position of POS field.
	QEI_POS_POS_Pos = 0x0
	// Bit mask of POS field.
	QEI_POS_POS_Msk = 0xffffffff

	// MAXPOS: Maximum position register
	// Position of MAXPOS field.
	QEI_MAXPOS_MAXPOS_Pos = 0x0
	// Bit mask of MAXPOS field.
	QEI_MAXPOS_MAXPOS_Msk = 0xffffffff

	// CMPOS0: position compare register 0
	// Position of PCMP0 field.
	QEI_CMPOS0_PCMP0_Pos = 0x0
	// Bit mask of PCMP0 field.
	QEI_CMPOS0_PCMP0_Msk = 0xffffffff

	// CMPOS1: position compare register 1
	// Position of PCMP1 field.
	QEI_CMPOS1_PCMP1_Pos = 0x0
	// Bit mask of PCMP1 field.
	QEI_CMPOS1_PCMP1_Msk = 0xffffffff

	// CMPOS2: position compare register 2
	// Position of PCMP2 field.
	QEI_CMPOS2_PCMP2_Pos = 0x0
	// Bit mask of PCMP2 field.
	QEI_CMPOS2_PCMP2_Msk = 0xffffffff

	// INXCNT: Index count register
	// Position of ENCPOS field.
	QEI_INXCNT_ENCPOS_Pos = 0x0
	// Bit mask of ENCPOS field.
	QEI_INXCNT_ENCPOS_Msk = 0xffffffff

	// INXCMP0: Index compare register 0
	// Position of ICMP0 field.
	QEI_INXCMP0_ICMP0_Pos = 0x0
	// Bit mask of ICMP0 field.
	QEI_INXCMP0_ICMP0_Msk = 0xffffffff

	// LOAD: Velocity timer reload register
	// Position of VELLOAD field.
	QEI_LOAD_VELLOAD_Pos = 0x0
	// Bit mask of VELLOAD field.
	QEI_LOAD_VELLOAD_Msk = 0xffffffff

	// TIME: Velocity timer register
	// Position of VELVAL field.
	QEI_TIME_VELVAL_Pos = 0x0
	// Bit mask of VELVAL field.
	QEI_TIME_VELVAL_Msk = 0xffffffff

	// VEL: Velocity counter register
	// Position of VELPC field.
	QEI_VEL_VELPC_Pos = 0x0
	// Bit mask of VELPC field.
	QEI_VEL_VELPC_Msk = 0xffffffff

	// CAP: Velocity capture register
	// Position of VELCAP field.
	QEI_CAP_VELCAP_Pos = 0x0
	// Bit mask of VELCAP field.
	QEI_CAP_VELCAP_Msk = 0xffffffff

	// VELCOMP: Velocity compare register
	// Position of VELCMP field.
	QEI_VELCOMP_VELCMP_Pos = 0x0
	// Bit mask of VELCMP field.
	QEI_VELCOMP_VELCMP_Msk = 0xffffffff

	// FILTERPHA: Digital filter register on input phase A (QEI_A)
	// Position of FILTA field.
	QEI_FILTERPHA_FILTA_Pos = 0x0
	// Bit mask of FILTA field.
	QEI_FILTERPHA_FILTA_Msk = 0xffffffff

	// FILTERPHB: Digital filter register on input phase B (QEI_B)
	// Position of FILTB field.
	QEI_FILTERPHB_FILTB_Pos = 0x0
	// Bit mask of FILTB field.
	QEI_FILTERPHB_FILTB_Msk = 0xffffffff

	// FILTERINX: Digital filter register on input index (QEI_IDX)
	// Position of FITLINX field.
	QEI_FILTERINX_FITLINX_Pos = 0x0
	// Bit mask of FITLINX field.
	QEI_FILTERINX_FITLINX_Msk = 0xffffffff

	// WINDOW: Index acceptance window register
	// Position of WINDOW field.
	QEI_WINDOW_WINDOW_Pos = 0x0
	// Bit mask of WINDOW field.
	QEI_WINDOW_WINDOW_Msk = 0xffffffff

	// INXCMP1: Index compare register 1
	// Position of ICMP1 field.
	QEI_INXCMP1_ICMP1_Pos = 0x0
	// Bit mask of ICMP1 field.
	QEI_INXCMP1_ICMP1_Msk = 0xffffffff

	// INXCMP2: Index compare register 2
	// Position of ICMP2 field.
	QEI_INXCMP2_ICMP2_Pos = 0x0
	// Bit mask of ICMP2 field.
	QEI_INXCMP2_ICMP2_Msk = 0xffffffff

	// IEC: Interrupt enable clear register
	// Position of INX_EN field.
	QEI_IEC_INX_EN_Pos = 0x0
	// Bit mask of INX_EN field.
	QEI_IEC_INX_EN_Msk = 0x1
	// Bit INX_EN.
	QEI_IEC_INX_EN = 0x1
	// Position of TIM_EN field.
	QEI_IEC_TIM_EN_Pos = 0x1
	// Bit mask of TIM_EN field.
	QEI_IEC_TIM_EN_Msk = 0x2
	// Bit TIM_EN.
	QEI_IEC_TIM_EN = 0x2
	// Position of VELC_EN field.
	QEI_IEC_VELC_EN_Pos = 0x2
	// Bit mask of VELC_EN field.
	QEI_IEC_VELC_EN_Msk = 0x4
	// Bit VELC_EN.
	QEI_IEC_VELC_EN = 0x4
	// Position of DIR_EN field.
	QEI_IEC_DIR_EN_Pos = 0x3
	// Bit mask of DIR_EN field.
	QEI_IEC_DIR_EN_Msk = 0x8
	// Bit DIR_EN.
	QEI_IEC_DIR_EN = 0x8
	// Position of ERR_EN field.
	QEI_IEC_ERR_EN_Pos = 0x4
	// Bit mask of ERR_EN field.
	QEI_IEC_ERR_EN_Msk = 0x10
	// Bit ERR_EN.
	QEI_IEC_ERR_EN = 0x10
	// Position of ENCLK_EN field.
	QEI_IEC_ENCLK_EN_Pos = 0x5
	// Bit mask of ENCLK_EN field.
	QEI_IEC_ENCLK_EN_Msk = 0x20
	// Bit ENCLK_EN.
	QEI_IEC_ENCLK_EN = 0x20
	// Position of POS0_Int field.
	QEI_IEC_POS0_Int_Pos = 0x6
	// Bit mask of POS0_Int field.
	QEI_IEC_POS0_Int_Msk = 0x40
	// Bit POS0_Int.
	QEI_IEC_POS0_Int = 0x40
	// Position of POS1_Int field.
	QEI_IEC_POS1_Int_Pos = 0x7
	// Bit mask of POS1_Int field.
	QEI_IEC_POS1_Int_Msk = 0x80
	// Bit POS1_Int.
	QEI_IEC_POS1_Int = 0x80
	// Position of POS2_Int field.
	QEI_IEC_POS2_Int_Pos = 0x8
	// Bit mask of POS2_Int field.
	QEI_IEC_POS2_Int_Msk = 0x100
	// Bit POS2_Int.
	QEI_IEC_POS2_Int = 0x100
	// Position of REV_Int field.
	QEI_IEC_REV_Int_Pos = 0x9
	// Bit mask of REV_Int field.
	QEI_IEC_REV_Int_Msk = 0x200
	// Bit REV_Int.
	QEI_IEC_REV_Int = 0x200
	// Position of POS0REV_Int field.
	QEI_IEC_POS0REV_Int_Pos = 0xa
	// Bit mask of POS0REV_Int field.
	QEI_IEC_POS0REV_Int_Msk = 0x400
	// Bit POS0REV_Int.
	QEI_IEC_POS0REV_Int = 0x400
	// Position of POS1REV_Int field.
	QEI_IEC_POS1REV_Int_Pos = 0xb
	// Bit mask of POS1REV_Int field.
	QEI_IEC_POS1REV_Int_Msk = 0x800
	// Bit POS1REV_Int.
	QEI_IEC_POS1REV_Int = 0x800
	// Position of POS2REV_Int field.
	QEI_IEC_POS2REV_Int_Pos = 0xc
	// Bit mask of POS2REV_Int field.
	QEI_IEC_POS2REV_Int_Msk = 0x1000
	// Bit POS2REV_Int.
	QEI_IEC_POS2REV_Int = 0x1000
	// Position of REV1_Int field.
	QEI_IEC_REV1_Int_Pos = 0xd
	// Bit mask of REV1_Int field.
	QEI_IEC_REV1_Int_Msk = 0x2000
	// Bit REV1_Int.
	QEI_IEC_REV1_Int = 0x2000
	// Position of REV2_Int field.
	QEI_IEC_REV2_Int_Pos = 0xe
	// Bit mask of REV2_Int field.
	QEI_IEC_REV2_Int_Msk = 0x4000
	// Bit REV2_Int.
	QEI_IEC_REV2_Int = 0x4000
	// Position of MAXPOS_Int field.
	QEI_IEC_MAXPOS_Int_Pos = 0xf
	// Bit mask of MAXPOS_Int field.
	QEI_IEC_MAXPOS_Int_Msk = 0x8000
	// Bit MAXPOS_Int.
	QEI_IEC_MAXPOS_Int = 0x8000
	// Position of RESERVED field.
	QEI_IEC_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_IEC_RESERVED_Msk = 0xffff0000

	// IES: Interrupt enable set register
	// Position of INX_EN field.
	QEI_IES_INX_EN_Pos = 0x0
	// Bit mask of INX_EN field.
	QEI_IES_INX_EN_Msk = 0x1
	// Bit INX_EN.
	QEI_IES_INX_EN = 0x1
	// Position of TIM_EN field.
	QEI_IES_TIM_EN_Pos = 0x1
	// Bit mask of TIM_EN field.
	QEI_IES_TIM_EN_Msk = 0x2
	// Bit TIM_EN.
	QEI_IES_TIM_EN = 0x2
	// Position of VELC_EN field.
	QEI_IES_VELC_EN_Pos = 0x2
	// Bit mask of VELC_EN field.
	QEI_IES_VELC_EN_Msk = 0x4
	// Bit VELC_EN.
	QEI_IES_VELC_EN = 0x4
	// Position of DIR_EN field.
	QEI_IES_DIR_EN_Pos = 0x3
	// Bit mask of DIR_EN field.
	QEI_IES_DIR_EN_Msk = 0x8
	// Bit DIR_EN.
	QEI_IES_DIR_EN = 0x8
	// Position of ERR_EN field.
	QEI_IES_ERR_EN_Pos = 0x4
	// Bit mask of ERR_EN field.
	QEI_IES_ERR_EN_Msk = 0x10
	// Bit ERR_EN.
	QEI_IES_ERR_EN = 0x10
	// Position of ENCLK_EN field.
	QEI_IES_ENCLK_EN_Pos = 0x5
	// Bit mask of ENCLK_EN field.
	QEI_IES_ENCLK_EN_Msk = 0x20
	// Bit ENCLK_EN.
	QEI_IES_ENCLK_EN = 0x20
	// Position of POS0_Int field.
	QEI_IES_POS0_Int_Pos = 0x6
	// Bit mask of POS0_Int field.
	QEI_IES_POS0_Int_Msk = 0x40
	// Bit POS0_Int.
	QEI_IES_POS0_Int = 0x40
	// Position of POS1_Int field.
	QEI_IES_POS1_Int_Pos = 0x7
	// Bit mask of POS1_Int field.
	QEI_IES_POS1_Int_Msk = 0x80
	// Bit POS1_Int.
	QEI_IES_POS1_Int = 0x80
	// Position of POS2_Int field.
	QEI_IES_POS2_Int_Pos = 0x8
	// Bit mask of POS2_Int field.
	QEI_IES_POS2_Int_Msk = 0x100
	// Bit POS2_Int.
	QEI_IES_POS2_Int = 0x100
	// Position of REV_Int field.
	QEI_IES_REV_Int_Pos = 0x9
	// Bit mask of REV_Int field.
	QEI_IES_REV_Int_Msk = 0x200
	// Bit REV_Int.
	QEI_IES_REV_Int = 0x200
	// Position of POS0REV_Int field.
	QEI_IES_POS0REV_Int_Pos = 0xa
	// Bit mask of POS0REV_Int field.
	QEI_IES_POS0REV_Int_Msk = 0x400
	// Bit POS0REV_Int.
	QEI_IES_POS0REV_Int = 0x400
	// Position of POS1REV_Int field.
	QEI_IES_POS1REV_Int_Pos = 0xb
	// Bit mask of POS1REV_Int field.
	QEI_IES_POS1REV_Int_Msk = 0x800
	// Bit POS1REV_Int.
	QEI_IES_POS1REV_Int = 0x800
	// Position of POS2REV_Int field.
	QEI_IES_POS2REV_Int_Pos = 0xc
	// Bit mask of POS2REV_Int field.
	QEI_IES_POS2REV_Int_Msk = 0x1000
	// Bit POS2REV_Int.
	QEI_IES_POS2REV_Int = 0x1000
	// Position of REV1_Int field.
	QEI_IES_REV1_Int_Pos = 0xd
	// Bit mask of REV1_Int field.
	QEI_IES_REV1_Int_Msk = 0x2000
	// Bit REV1_Int.
	QEI_IES_REV1_Int = 0x2000
	// Position of REV2_Int field.
	QEI_IES_REV2_Int_Pos = 0xe
	// Bit mask of REV2_Int field.
	QEI_IES_REV2_Int_Msk = 0x4000
	// Bit REV2_Int.
	QEI_IES_REV2_Int = 0x4000
	// Position of MAXPOS_Int field.
	QEI_IES_MAXPOS_Int_Pos = 0xf
	// Bit mask of MAXPOS_Int field.
	QEI_IES_MAXPOS_Int_Msk = 0x8000
	// Bit MAXPOS_Int.
	QEI_IES_MAXPOS_Int = 0x8000
	// Position of RESERVED field.
	QEI_IES_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_IES_RESERVED_Msk = 0xffff0000

	// INTSTAT: Interrupt status register
	// Position of INX_Int field.
	QEI_INTSTAT_INX_Int_Pos = 0x0
	// Bit mask of INX_Int field.
	QEI_INTSTAT_INX_Int_Msk = 0x1
	// Bit INX_Int.
	QEI_INTSTAT_INX_Int = 0x1
	// Position of TIM_Int field.
	QEI_INTSTAT_TIM_Int_Pos = 0x1
	// Bit mask of TIM_Int field.
	QEI_INTSTAT_TIM_Int_Msk = 0x2
	// Bit TIM_Int.
	QEI_INTSTAT_TIM_Int = 0x2
	// Position of VELC_Int field.
	QEI_INTSTAT_VELC_Int_Pos = 0x2
	// Bit mask of VELC_Int field.
	QEI_INTSTAT_VELC_Int_Msk = 0x4
	// Bit VELC_Int.
	QEI_INTSTAT_VELC_Int = 0x4
	// Position of DIR_Int field.
	QEI_INTSTAT_DIR_Int_Pos = 0x3
	// Bit mask of DIR_Int field.
	QEI_INTSTAT_DIR_Int_Msk = 0x8
	// Bit DIR_Int.
	QEI_INTSTAT_DIR_Int = 0x8
	// Position of ERR_Int field.
	QEI_INTSTAT_ERR_Int_Pos = 0x4
	// Bit mask of ERR_Int field.
	QEI_INTSTAT_ERR_Int_Msk = 0x10
	// Bit ERR_Int.
	QEI_INTSTAT_ERR_Int = 0x10
	// Position of ENCLK_Int field.
	QEI_INTSTAT_ENCLK_Int_Pos = 0x5
	// Bit mask of ENCLK_Int field.
	QEI_INTSTAT_ENCLK_Int_Msk = 0x20
	// Bit ENCLK_Int.
	QEI_INTSTAT_ENCLK_Int = 0x20
	// Position of POS0_Int field.
	QEI_INTSTAT_POS0_Int_Pos = 0x6
	// Bit mask of POS0_Int field.
	QEI_INTSTAT_POS0_Int_Msk = 0x40
	// Bit POS0_Int.
	QEI_INTSTAT_POS0_Int = 0x40
	// Position of POS1_Int field.
	QEI_INTSTAT_POS1_Int_Pos = 0x7
	// Bit mask of POS1_Int field.
	QEI_INTSTAT_POS1_Int_Msk = 0x80
	// Bit POS1_Int.
	QEI_INTSTAT_POS1_Int = 0x80
	// Position of POS2_Int field.
	QEI_INTSTAT_POS2_Int_Pos = 0x8
	// Bit mask of POS2_Int field.
	QEI_INTSTAT_POS2_Int_Msk = 0x100
	// Bit POS2_Int.
	QEI_INTSTAT_POS2_Int = 0x100
	// Position of REV_Int field.
	QEI_INTSTAT_REV_Int_Pos = 0x9
	// Bit mask of REV_Int field.
	QEI_INTSTAT_REV_Int_Msk = 0x200
	// Bit REV_Int.
	QEI_INTSTAT_REV_Int = 0x200
	// Position of POS0REV_Int field.
	QEI_INTSTAT_POS0REV_Int_Pos = 0xa
	// Bit mask of POS0REV_Int field.
	QEI_INTSTAT_POS0REV_Int_Msk = 0x400
	// Bit POS0REV_Int.
	QEI_INTSTAT_POS0REV_Int = 0x400
	// Position of POS1REV_Int field.
	QEI_INTSTAT_POS1REV_Int_Pos = 0xb
	// Bit mask of POS1REV_Int field.
	QEI_INTSTAT_POS1REV_Int_Msk = 0x800
	// Bit POS1REV_Int.
	QEI_INTSTAT_POS1REV_Int = 0x800
	// Position of POS2REV_Int field.
	QEI_INTSTAT_POS2REV_Int_Pos = 0xc
	// Bit mask of POS2REV_Int field.
	QEI_INTSTAT_POS2REV_Int_Msk = 0x1000
	// Bit POS2REV_Int.
	QEI_INTSTAT_POS2REV_Int = 0x1000
	// Position of REV1_Int field.
	QEI_INTSTAT_REV1_Int_Pos = 0xd
	// Bit mask of REV1_Int field.
	QEI_INTSTAT_REV1_Int_Msk = 0x2000
	// Bit REV1_Int.
	QEI_INTSTAT_REV1_Int = 0x2000
	// Position of REV2_Int field.
	QEI_INTSTAT_REV2_Int_Pos = 0xe
	// Bit mask of REV2_Int field.
	QEI_INTSTAT_REV2_Int_Msk = 0x4000
	// Bit REV2_Int.
	QEI_INTSTAT_REV2_Int = 0x4000
	// Position of MAXPOS_Int field.
	QEI_INTSTAT_MAXPOS_Int_Pos = 0xf
	// Bit mask of MAXPOS_Int field.
	QEI_INTSTAT_MAXPOS_Int_Msk = 0x8000
	// Bit MAXPOS_Int.
	QEI_INTSTAT_MAXPOS_Int = 0x8000
	// Position of RESERVED field.
	QEI_INTSTAT_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_INTSTAT_RESERVED_Msk = 0xffff0000

	// IE: Interrupt enable register
	// Position of INX_Int field.
	QEI_IE_INX_Int_Pos = 0x0
	// Bit mask of INX_Int field.
	QEI_IE_INX_Int_Msk = 0x1
	// Bit INX_Int.
	QEI_IE_INX_Int = 0x1
	// Position of TIM_Int field.
	QEI_IE_TIM_Int_Pos = 0x1
	// Bit mask of TIM_Int field.
	QEI_IE_TIM_Int_Msk = 0x2
	// Bit TIM_Int.
	QEI_IE_TIM_Int = 0x2
	// Position of VELC_Int field.
	QEI_IE_VELC_Int_Pos = 0x2
	// Bit mask of VELC_Int field.
	QEI_IE_VELC_Int_Msk = 0x4
	// Bit VELC_Int.
	QEI_IE_VELC_Int = 0x4
	// Position of DIR_Int field.
	QEI_IE_DIR_Int_Pos = 0x3
	// Bit mask of DIR_Int field.
	QEI_IE_DIR_Int_Msk = 0x8
	// Bit DIR_Int.
	QEI_IE_DIR_Int = 0x8
	// Position of ERR_Int field.
	QEI_IE_ERR_Int_Pos = 0x4
	// Bit mask of ERR_Int field.
	QEI_IE_ERR_Int_Msk = 0x10
	// Bit ERR_Int.
	QEI_IE_ERR_Int = 0x10
	// Position of ENCLK_Int field.
	QEI_IE_ENCLK_Int_Pos = 0x5
	// Bit mask of ENCLK_Int field.
	QEI_IE_ENCLK_Int_Msk = 0x20
	// Bit ENCLK_Int.
	QEI_IE_ENCLK_Int = 0x20
	// Position of POS0_Int field.
	QEI_IE_POS0_Int_Pos = 0x6
	// Bit mask of POS0_Int field.
	QEI_IE_POS0_Int_Msk = 0x40
	// Bit POS0_Int.
	QEI_IE_POS0_Int = 0x40
	// Position of POS1_Int field.
	QEI_IE_POS1_Int_Pos = 0x7
	// Bit mask of POS1_Int field.
	QEI_IE_POS1_Int_Msk = 0x80
	// Bit POS1_Int.
	QEI_IE_POS1_Int = 0x80
	// Position of POS2_Int field.
	QEI_IE_POS2_Int_Pos = 0x8
	// Bit mask of POS2_Int field.
	QEI_IE_POS2_Int_Msk = 0x100
	// Bit POS2_Int.
	QEI_IE_POS2_Int = 0x100
	// Position of REV_Int field.
	QEI_IE_REV_Int_Pos = 0x9
	// Bit mask of REV_Int field.
	QEI_IE_REV_Int_Msk = 0x200
	// Bit REV_Int.
	QEI_IE_REV_Int = 0x200
	// Position of POS0REV_Int field.
	QEI_IE_POS0REV_Int_Pos = 0xa
	// Bit mask of POS0REV_Int field.
	QEI_IE_POS0REV_Int_Msk = 0x400
	// Bit POS0REV_Int.
	QEI_IE_POS0REV_Int = 0x400
	// Position of POS1REV_Int field.
	QEI_IE_POS1REV_Int_Pos = 0xb
	// Bit mask of POS1REV_Int field.
	QEI_IE_POS1REV_Int_Msk = 0x800
	// Bit POS1REV_Int.
	QEI_IE_POS1REV_Int = 0x800
	// Position of POS2REV_Int field.
	QEI_IE_POS2REV_Int_Pos = 0xc
	// Bit mask of POS2REV_Int field.
	QEI_IE_POS2REV_Int_Msk = 0x1000
	// Bit POS2REV_Int.
	QEI_IE_POS2REV_Int = 0x1000
	// Position of REV1_Int field.
	QEI_IE_REV1_Int_Pos = 0xd
	// Bit mask of REV1_Int field.
	QEI_IE_REV1_Int_Msk = 0x2000
	// Bit REV1_Int.
	QEI_IE_REV1_Int = 0x2000
	// Position of REV2_Int field.
	QEI_IE_REV2_Int_Pos = 0xe
	// Bit mask of REV2_Int field.
	QEI_IE_REV2_Int_Msk = 0x4000
	// Bit REV2_Int.
	QEI_IE_REV2_Int = 0x4000
	// Position of MAXPOS_Int field.
	QEI_IE_MAXPOS_Int_Pos = 0xf
	// Bit mask of MAXPOS_Int field.
	QEI_IE_MAXPOS_Int_Msk = 0x8000
	// Bit MAXPOS_Int.
	QEI_IE_MAXPOS_Int = 0x8000
	// Position of RESERVED field.
	QEI_IE_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_IE_RESERVED_Msk = 0xffff0000

	// CLR: Interrupt status clear register
	// Position of INX_Int field.
	QEI_CLR_INX_Int_Pos = 0x0
	// Bit mask of INX_Int field.
	QEI_CLR_INX_Int_Msk = 0x1
	// Bit INX_Int.
	QEI_CLR_INX_Int = 0x1
	// Position of TIM_Int field.
	QEI_CLR_TIM_Int_Pos = 0x1
	// Bit mask of TIM_Int field.
	QEI_CLR_TIM_Int_Msk = 0x2
	// Bit TIM_Int.
	QEI_CLR_TIM_Int = 0x2
	// Position of VELC_Int field.
	QEI_CLR_VELC_Int_Pos = 0x2
	// Bit mask of VELC_Int field.
	QEI_CLR_VELC_Int_Msk = 0x4
	// Bit VELC_Int.
	QEI_CLR_VELC_Int = 0x4
	// Position of DIR_Int field.
	QEI_CLR_DIR_Int_Pos = 0x3
	// Bit mask of DIR_Int field.
	QEI_CLR_DIR_Int_Msk = 0x8
	// Bit DIR_Int.
	QEI_CLR_DIR_Int = 0x8
	// Position of ERR_Int field.
	QEI_CLR_ERR_Int_Pos = 0x4
	// Bit mask of ERR_Int field.
	QEI_CLR_ERR_Int_Msk = 0x10
	// Bit ERR_Int.
	QEI_CLR_ERR_Int = 0x10
	// Position of ENCLK_Int field.
	QEI_CLR_ENCLK_Int_Pos = 0x5
	// Bit mask of ENCLK_Int field.
	QEI_CLR_ENCLK_Int_Msk = 0x20
	// Bit ENCLK_Int.
	QEI_CLR_ENCLK_Int = 0x20
	// Position of POS0_Int field.
	QEI_CLR_POS0_Int_Pos = 0x6
	// Bit mask of POS0_Int field.
	QEI_CLR_POS0_Int_Msk = 0x40
	// Bit POS0_Int.
	QEI_CLR_POS0_Int = 0x40
	// Position of POS1_Int field.
	QEI_CLR_POS1_Int_Pos = 0x7
	// Bit mask of POS1_Int field.
	QEI_CLR_POS1_Int_Msk = 0x80
	// Bit POS1_Int.
	QEI_CLR_POS1_Int = 0x80
	// Position of POS2_Int field.
	QEI_CLR_POS2_Int_Pos = 0x8
	// Bit mask of POS2_Int field.
	QEI_CLR_POS2_Int_Msk = 0x100
	// Bit POS2_Int.
	QEI_CLR_POS2_Int = 0x100
	// Position of REV_Int field.
	QEI_CLR_REV_Int_Pos = 0x9
	// Bit mask of REV_Int field.
	QEI_CLR_REV_Int_Msk = 0x200
	// Bit REV_Int.
	QEI_CLR_REV_Int = 0x200
	// Position of POS0REV_Int field.
	QEI_CLR_POS0REV_Int_Pos = 0xa
	// Bit mask of POS0REV_Int field.
	QEI_CLR_POS0REV_Int_Msk = 0x400
	// Bit POS0REV_Int.
	QEI_CLR_POS0REV_Int = 0x400
	// Position of POS1REV_Int field.
	QEI_CLR_POS1REV_Int_Pos = 0xb
	// Bit mask of POS1REV_Int field.
	QEI_CLR_POS1REV_Int_Msk = 0x800
	// Bit POS1REV_Int.
	QEI_CLR_POS1REV_Int = 0x800
	// Position of REV1_Int field.
	QEI_CLR_REV1_Int_Pos = 0xd
	// Bit mask of REV1_Int field.
	QEI_CLR_REV1_Int_Msk = 0x2000
	// Bit REV1_Int.
	QEI_CLR_REV1_Int = 0x2000
	// Position of REV2_Int field.
	QEI_CLR_REV2_Int_Pos = 0xe
	// Bit mask of REV2_Int field.
	QEI_CLR_REV2_Int_Msk = 0x4000
	// Bit REV2_Int.
	QEI_CLR_REV2_Int = 0x4000
	// Position of MAXPOS_Int field.
	QEI_CLR_MAXPOS_Int_Pos = 0xf
	// Bit mask of MAXPOS_Int field.
	QEI_CLR_MAXPOS_Int_Msk = 0x8000
	// Bit MAXPOS_Int.
	QEI_CLR_MAXPOS_Int = 0x8000
	// Position of RESERVED field.
	QEI_CLR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_CLR_RESERVED_Msk = 0xffff0000

	// SET: Interrupt status set register
	// Position of INX_Int field.
	QEI_SET_INX_Int_Pos = 0x0
	// Bit mask of INX_Int field.
	QEI_SET_INX_Int_Msk = 0x1
	// Bit INX_Int.
	QEI_SET_INX_Int = 0x1
	// Position of TIM_Int field.
	QEI_SET_TIM_Int_Pos = 0x1
	// Bit mask of TIM_Int field.
	QEI_SET_TIM_Int_Msk = 0x2
	// Bit TIM_Int.
	QEI_SET_TIM_Int = 0x2
	// Position of VELC_Int field.
	QEI_SET_VELC_Int_Pos = 0x2
	// Bit mask of VELC_Int field.
	QEI_SET_VELC_Int_Msk = 0x4
	// Bit VELC_Int.
	QEI_SET_VELC_Int = 0x4
	// Position of DIR_Int field.
	QEI_SET_DIR_Int_Pos = 0x3
	// Bit mask of DIR_Int field.
	QEI_SET_DIR_Int_Msk = 0x8
	// Bit DIR_Int.
	QEI_SET_DIR_Int = 0x8
	// Position of ERR_Int field.
	QEI_SET_ERR_Int_Pos = 0x4
	// Bit mask of ERR_Int field.
	QEI_SET_ERR_Int_Msk = 0x10
	// Bit ERR_Int.
	QEI_SET_ERR_Int = 0x10
	// Position of ENCLK_Int field.
	QEI_SET_ENCLK_Int_Pos = 0x5
	// Bit mask of ENCLK_Int field.
	QEI_SET_ENCLK_Int_Msk = 0x20
	// Bit ENCLK_Int.
	QEI_SET_ENCLK_Int = 0x20
	// Position of POS0_Int field.
	QEI_SET_POS0_Int_Pos = 0x6
	// Bit mask of POS0_Int field.
	QEI_SET_POS0_Int_Msk = 0x40
	// Bit POS0_Int.
	QEI_SET_POS0_Int = 0x40
	// Position of POS1_Int field.
	QEI_SET_POS1_Int_Pos = 0x7
	// Bit mask of POS1_Int field.
	QEI_SET_POS1_Int_Msk = 0x80
	// Bit POS1_Int.
	QEI_SET_POS1_Int = 0x80
	// Position of POS2_Int field.
	QEI_SET_POS2_Int_Pos = 0x8
	// Bit mask of POS2_Int field.
	QEI_SET_POS2_Int_Msk = 0x100
	// Bit POS2_Int.
	QEI_SET_POS2_Int = 0x100
	// Position of REV_Int field.
	QEI_SET_REV_Int_Pos = 0x9
	// Bit mask of REV_Int field.
	QEI_SET_REV_Int_Msk = 0x200
	// Bit REV_Int.
	QEI_SET_REV_Int = 0x200
	// Position of POS0REV_Int field.
	QEI_SET_POS0REV_Int_Pos = 0xa
	// Bit mask of POS0REV_Int field.
	QEI_SET_POS0REV_Int_Msk = 0x400
	// Bit POS0REV_Int.
	QEI_SET_POS0REV_Int = 0x400
	// Position of POS1REV_Int field.
	QEI_SET_POS1REV_Int_Pos = 0xb
	// Bit mask of POS1REV_Int field.
	QEI_SET_POS1REV_Int_Msk = 0x800
	// Bit POS1REV_Int.
	QEI_SET_POS1REV_Int = 0x800
	// Position of POS2REV_Int field.
	QEI_SET_POS2REV_Int_Pos = 0xc
	// Bit mask of POS2REV_Int field.
	QEI_SET_POS2REV_Int_Msk = 0x1000
	// Bit POS2REV_Int.
	QEI_SET_POS2REV_Int = 0x1000
	// Position of REV1_Int field.
	QEI_SET_REV1_Int_Pos = 0xd
	// Bit mask of REV1_Int field.
	QEI_SET_REV1_Int_Msk = 0x2000
	// Bit REV1_Int.
	QEI_SET_REV1_Int = 0x2000
	// Position of REV2_Int field.
	QEI_SET_REV2_Int_Pos = 0xe
	// Bit mask of REV2_Int field.
	QEI_SET_REV2_Int_Msk = 0x4000
	// Bit REV2_Int.
	QEI_SET_REV2_Int = 0x4000
	// Position of MAXPOS_Int field.
	QEI_SET_MAXPOS_Int_Pos = 0xf
	// Bit mask of MAXPOS_Int field.
	QEI_SET_MAXPOS_Int_Msk = 0x8000
	// Bit MAXPOS_Int.
	QEI_SET_MAXPOS_Int = 0x8000
	// Position of RESERVED field.
	QEI_SET_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_SET_RESERVED_Msk = 0xffff0000
)

// Constants for GIMA: Global Input Multiplexer Array (GIMA)
const (
	// CAP0_0_IN: Timer 0 CAP0_0 capture input multiplexer (GIMA output 0)
	// Position of INV field.
	GIMA_CAP0_0_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP0_0_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP0_0_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP0_0_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP0_0_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP0_0_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP0_0_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP0_0_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP0_0_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP0_0_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP0_0_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP0_0_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP0_0_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP0_0_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP0_0_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP0_0_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP0_0_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP0_0_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP0_0_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP0_0_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP0_0_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP0_0_IN_SELECT_Msk = 0xf0
	// CTIN_0
	GIMA_CAP0_0_IN_SELECT_CTIN_0 = 0x0
	// T0_CAP0
	GIMA_CAP0_0_IN_SELECT_T0_CAP0 = 0x2
	// Position of RESERVED field.
	GIMA_CAP0_0_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP0_0_IN_RESERVED_Msk = 0xffffff00

	// CAP0_1_IN: Timer 0 CAP0_1 capture input multiplexer (GIMA output 1)
	// Position of INV field.
	GIMA_CAP0_1_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP0_1_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP0_1_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP0_1_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP0_1_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP0_1_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP0_1_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP0_1_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP0_1_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP0_1_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP0_1_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP0_1_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP0_1_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP0_1_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP0_1_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP0_1_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP0_1_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP0_1_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP0_1_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP0_1_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP0_1_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP0_1_IN_SELECT_Msk = 0xf0
	// CTIN_1
	GIMA_CAP0_1_IN_SELECT_CTIN_1 = 0x0
	// USART2 TX active
	GIMA_CAP0_1_IN_SELECT_USART2_TX_ACTIVE = 0x1
	// T0_CAP1
	GIMA_CAP0_1_IN_SELECT_T0_CAP1 = 0x2
	// Position of RESERVED field.
	GIMA_CAP0_1_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP0_1_IN_RESERVED_Msk = 0xffffff00

	// CAP0_2_IN: Timer 0 CAP0_2 capture input multiplexer (GIMA output 2)
	// Position of INV field.
	GIMA_CAP0_2_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP0_2_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP0_2_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP0_2_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP0_2_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP0_2_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP0_2_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP0_2_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP0_2_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP0_2_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP0_2_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP0_2_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP0_2_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP0_2_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP0_2_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP0_2_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP0_2_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP0_2_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP0_2_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP0_2_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP0_2_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP0_2_IN_SELECT_Msk = 0xf0
	// CTIN_2
	GIMA_CAP0_2_IN_SELECT_CTIN_2 = 0x0
	// T0_CAP2
	GIMA_CAP0_2_IN_SELECT_T0_CAP2 = 0x2
	// Position of RESERVED field.
	GIMA_CAP0_2_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP0_2_IN_RESERVED_Msk = 0xffffff00

	// CAP0_3_IN: Timer 0 CAP0_3 capture input multiplexer (GIMA output 3)
	// Position of INV field.
	GIMA_CAP0_3_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP0_3_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP0_3_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP0_3_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP0_3_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP0_3_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP0_3_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP0_3_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP0_3_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP0_3_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP0_3_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP0_3_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP0_3_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP0_3_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP0_3_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP0_3_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP0_3_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP0_3_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP0_3_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP0_3_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP0_3_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP0_3_IN_SELECT_Msk = 0xf0
	// CTOUT_15 or T3_MAT3
	GIMA_CAP0_3_IN_SELECT_CTOUT_15_OR_T3_MAT3 = 0x0
	// T0_CAP3
	GIMA_CAP0_3_IN_SELECT_T0_CAP3 = 0x1
	// T3_MAT3
	GIMA_CAP0_3_IN_SELECT_T3_MAT3 = 0x2
	// Position of RESERVED field.
	GIMA_CAP0_3_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP0_3_IN_RESERVED_Msk = 0xffffff00

	// CAP1_0_IN: Timer 1 CAP1_0 capture input multiplexer (GIMA output 4)
	// Position of INV field.
	GIMA_CAP1_0_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP1_0_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP1_0_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP1_0_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP1_0_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP1_0_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP1_0_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP1_0_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP1_0_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP1_0_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP1_0_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP1_0_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP1_0_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP1_0_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP1_0_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP1_0_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP1_0_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP1_0_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP1_0_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP1_0_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP1_0_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP1_0_IN_SELECT_Msk = 0xf0
	// CTIN_0
	GIMA_CAP1_0_IN_SELECT_CTIN_0 = 0x0
	// T1_CAP0
	GIMA_CAP1_0_IN_SELECT_T1_CAP0 = 0x2
	// Position of RESERVED field.
	GIMA_CAP1_0_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP1_0_IN_RESERVED_Msk = 0xffffff00

	// CAP1_1_IN: Timer 1 CAP1_1 capture input multiplexer (GIMA output 5)
	// Position of INV field.
	GIMA_CAP1_1_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP1_1_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP1_1_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP1_1_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP1_1_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP1_1_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP1_1_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP1_1_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP1_1_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP1_1_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP1_1_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP1_1_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP1_1_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP1_1_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP1_1_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP1_1_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP1_1_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP1_1_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP1_1_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP1_1_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP1_1_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP1_1_IN_SELECT_Msk = 0xf0
	// CTIN_3
	GIMA_CAP1_1_IN_SELECT_CTIN_3 = 0x0
	// USART0 TX active
	GIMA_CAP1_1_IN_SELECT_USART0_TX_ACTIVE = 0x1
	// T1_CAP1
	GIMA_CAP1_1_IN_SELECT_T1_CAP1 = 0x2
	// Position of RESERVED field.
	GIMA_CAP1_1_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP1_1_IN_RESERVED_Msk = 0xffffff00

	// CAP1_2_IN: Timer 1 CAP1_2 capture input multiplexer (GIMA output 6)
	// Position of INV field.
	GIMA_CAP1_2_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP1_2_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP1_2_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP1_2_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP1_2_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP1_2_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP1_2_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP1_2_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP1_2_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP1_2_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP1_2_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP1_2_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP1_2_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP1_2_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP1_2_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP1_2_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP1_2_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP1_2_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP1_2_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP1_2_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP1_2_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP1_2_IN_SELECT_Msk = 0xf0
	// CTIN_4
	GIMA_CAP1_2_IN_SELECT_CTIN_4 = 0x0
	// USART0 RX active
	GIMA_CAP1_2_IN_SELECT_USART0_RX_ACTIVE = 0x1
	// T1_CAP2
	GIMA_CAP1_2_IN_SELECT_T1_CAP2 = 0x2
	// Position of RESERVED field.
	GIMA_CAP1_2_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP1_2_IN_RESERVED_Msk = 0xffffff00

	// CAP1_3_IN: Timer 1 CAP1_3 capture input multiplexer (GIMA output 7)
	// Position of INV field.
	GIMA_CAP1_3_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP1_3_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP1_3_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP1_3_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP1_3_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP1_3_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP1_3_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP1_3_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP1_3_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP1_3_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP1_3_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP1_3_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP1_3_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP1_3_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP1_3_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP1_3_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP1_3_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP1_3_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP1_3_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP1_3_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP1_3_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP1_3_IN_SELECT_Msk = 0xf0
	// CTOUT_3 or T0_MAT3
	GIMA_CAP1_3_IN_SELECT_CTOUT_3_OR_T0_MAT3 = 0x0
	// T1_CAP3
	GIMA_CAP1_3_IN_SELECT_T1_CAP3 = 0x1
	// T0_MAT3
	GIMA_CAP1_3_IN_SELECT_T0_MAT3 = 0x2
	// Position of RESERVED field.
	GIMA_CAP1_3_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP1_3_IN_RESERVED_Msk = 0xffffff00

	// CAP2_0_IN: Timer 2 CAP2_0 capture input multiplexer (GIMA output 8)
	// Position of INV field.
	GIMA_CAP2_0_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP2_0_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP2_0_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP2_0_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP2_0_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP2_0_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP2_0_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP2_0_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP2_0_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP2_0_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP2_0_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP2_0_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP2_0_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP2_0_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP2_0_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP2_0_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP2_0_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP2_0_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP2_0_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP2_0_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP2_0_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP2_0_IN_SELECT_Msk = 0xf0
	// CTIN_0
	GIMA_CAP2_0_IN_SELECT_CTIN_0 = 0x0
	// T2_CAP0
	GIMA_CAP2_0_IN_SELECT_T2_CAP0 = 0x2
	// Position of RESERVED field.
	GIMA_CAP2_0_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP2_0_IN_RESERVED_Msk = 0xffffff00

	// CAP2_1_IN: Timer 2 CAP2_1 capture input multiplexer (GIMA output 9)
	// Position of INV field.
	GIMA_CAP2_1_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP2_1_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP2_1_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP2_1_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP2_1_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP2_1_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP2_1_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP2_1_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP2_1_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP2_1_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP2_1_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP2_1_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP2_1_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP2_1_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP2_1_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP2_1_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP2_1_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP2_1_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP2_1_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP2_1_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP2_1_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP2_1_IN_SELECT_Msk = 0xf0
	// CTIN_1
	GIMA_CAP2_1_IN_SELECT_CTIN_1 = 0x0
	// USART2 TX active
	GIMA_CAP2_1_IN_SELECT_USART2_TX_ACTIVE = 0x1
	// - I2S1_RX_MWS
	GIMA_CAP2_1_IN_SELECT__I2S1_RX_MWS = 0x2
	// T2_CAP1
	GIMA_CAP2_1_IN_SELECT_T2_CAP1 = 0x3
	// Position of RESERVED field.
	GIMA_CAP2_1_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP2_1_IN_RESERVED_Msk = 0xffffff00

	// CAP2_2_IN: Timer 2 CAP2_2 capture input multiplexer (GIMA output 10)
	// Position of INV field.
	GIMA_CAP2_2_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP2_2_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP2_2_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP2_2_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP2_2_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP2_2_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP2_2_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP2_2_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP2_2_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP2_2_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP2_2_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP2_2_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP2_2_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP2_2_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP2_2_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP2_2_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP2_2_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP2_2_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP2_2_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP2_2_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP2_2_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP2_2_IN_SELECT_Msk = 0xf0
	// CTIN_5
	GIMA_CAP2_2_IN_SELECT_CTIN_5 = 0x0
	// USART2 RX active
	GIMA_CAP2_2_IN_SELECT_USART2_RX_ACTIVE = 0x1
	// - I2S1_TX_MWS
	GIMA_CAP2_2_IN_SELECT__I2S1_TX_MWS = 0x2
	// T2_CAP2
	GIMA_CAP2_2_IN_SELECT_T2_CAP2 = 0x3
	// Position of RESERVED field.
	GIMA_CAP2_2_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP2_2_IN_RESERVED_Msk = 0xffffff00

	// CAP2_3_IN: Timer 2 CAP2_3 capture input multiplexer (GIMA output 11)
	// Position of INV field.
	GIMA_CAP2_3_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP2_3_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP2_3_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP2_3_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP2_3_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP2_3_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP2_3_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP2_3_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP2_3_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP2_3_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP2_3_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP2_3_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP2_3_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP2_3_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP2_3_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP2_3_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP2_3_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP2_3_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP2_3_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP2_3_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP2_3_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP2_3_IN_SELECT_Msk = 0xf0
	// CTOUT_7 or T1_MAT3
	GIMA_CAP2_3_IN_SELECT_CTOUT_7_OR_T1_MAT3 = 0x0
	// T2_CAP3
	GIMA_CAP2_3_IN_SELECT_T2_CAP3 = 0x1
	// T1_MAT3
	GIMA_CAP2_3_IN_SELECT_T1_MAT3 = 0x2
	// Position of RESERVED field.
	GIMA_CAP2_3_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP2_3_IN_RESERVED_Msk = 0xffffff00

	// CAP3_0_IN: Timer 3 CAP3_0 capture input multiplexer (GIMA output 12)
	// Position of INV field.
	GIMA_CAP3_0_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP3_0_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP3_0_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP3_0_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP3_0_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP3_0_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP3_0_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP3_0_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP3_0_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP3_0_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP3_0_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP3_0_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP3_0_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP3_0_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP3_0_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP3_0_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP3_0_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP3_0_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP3_0_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP3_0_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP3_0_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP3_0_IN_SELECT_Msk = 0xf0
	// CTIN_0
	GIMA_CAP3_0_IN_SELECT_CTIN_0 = 0x0
	// I2S0_RX_MWS
	GIMA_CAP3_0_IN_SELECT_I2S0_RX_MWS = 0x1
	// T3_CAP0
	GIMA_CAP3_0_IN_SELECT_T3_CAP0 = 0x2
	// Position of RESERVED field.
	GIMA_CAP3_0_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP3_0_IN_RESERVED_Msk = 0xffffff00

	// CAP3_1_IN: Timer 3 CAP3_1 capture input multiplexer (GIMA output 13)
	// Position of INV field.
	GIMA_CAP3_1_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP3_1_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP3_1_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP3_1_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP3_1_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP3_1_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP3_1_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP3_1_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP3_1_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP3_1_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP3_1_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP3_1_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP3_1_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP3_1_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP3_1_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP3_1_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP3_1_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP3_1_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP3_1_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP3_1_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP3_1_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP3_1_IN_SELECT_Msk = 0xf0
	// CTIN_6
	GIMA_CAP3_1_IN_SELECT_CTIN_6 = 0x0
	// USART3 TX active
	GIMA_CAP3_1_IN_SELECT_USART3_TX_ACTIVE = 0x1
	// TBD - I2S0_TX_MWS
	GIMA_CAP3_1_IN_SELECT_TBD__I2S0_TX_MWS = 0x2
	// T3_CAP1
	GIMA_CAP3_1_IN_SELECT_T3_CAP1 = 0x3
	// Position of RESERVED field.
	GIMA_CAP3_1_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP3_1_IN_RESERVED_Msk = 0xffffff00

	// CAP3_2_IN: Timer 3 CAP3_2 capture input multiplexer (GIMA output 14)
	// Position of INV field.
	GIMA_CAP3_2_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP3_2_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP3_2_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP3_2_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP3_2_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP3_2_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP3_2_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP3_2_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP3_2_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP3_2_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP3_2_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP3_2_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP3_2_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP3_2_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP3_2_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP3_2_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP3_2_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP3_2_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP3_2_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP3_2_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP3_2_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP3_2_IN_SELECT_Msk = 0xf0
	// CTIN_7
	GIMA_CAP3_2_IN_SELECT_CTIN_7 = 0x0
	// USART3 RX active
	GIMA_CAP3_2_IN_SELECT_USART3_RX_ACTIVE = 0x1
	// SOF0 (Start-Of-Frame USB0)
	GIMA_CAP3_2_IN_SELECT_SOF0_START_OF_FRAME = 0x2
	// T3_CAP2
	GIMA_CAP3_2_IN_SELECT_T3_CAP2 = 0x3
	// Position of RESERVED field.
	GIMA_CAP3_2_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP3_2_IN_RESERVED_Msk = 0xffffff00

	// CAP3_3_IN: Timer 3 CAP3_3 capture input multiplexer (GIMA output 15)
	// Position of INV field.
	GIMA_CAP3_3_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CAP3_3_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CAP3_3_IN_INV = 0x1
	// Not inverted.
	GIMA_CAP3_3_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CAP3_3_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CAP3_3_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CAP3_3_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CAP3_3_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CAP3_3_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CAP3_3_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CAP3_3_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CAP3_3_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CAP3_3_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CAP3_3_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CAP3_3_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CAP3_3_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CAP3_3_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CAP3_3_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CAP3_3_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CAP3_3_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CAP3_3_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CAP3_3_IN_SELECT_Msk = 0xf0
	// CTOUT11 or T2_MAT3
	GIMA_CAP3_3_IN_SELECT_CTOUT11_OR_T2_MAT3 = 0x0
	// SOF1 (Start-Of-Frame USB1)
	GIMA_CAP3_3_IN_SELECT_SOF1_START_OF_FRAME = 0x1
	// T3_CAP3
	GIMA_CAP3_3_IN_SELECT_T3_CAP3 = 0x2
	// T2_MAT3
	GIMA_CAP3_3_IN_SELECT_T2_MAT3 = 0x3
	// Position of RESERVED field.
	GIMA_CAP3_3_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CAP3_3_IN_RESERVED_Msk = 0xffffff00

	// CTIN_0_IN: SCT CTIN_0 capture input multiplexer (GIMA output 16)
	// Position of INV field.
	GIMA_CTIN_0_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CTIN_0_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CTIN_0_IN_INV = 0x1
	// Not inverted.
	GIMA_CTIN_0_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CTIN_0_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CTIN_0_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CTIN_0_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CTIN_0_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CTIN_0_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CTIN_0_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CTIN_0_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CTIN_0_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CTIN_0_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CTIN_0_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CTIN_0_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CTIN_0_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CTIN_0_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CTIN_0_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CTIN_0_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CTIN_0_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CTIN_0_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CTIN_0_IN_SELECT_Msk = 0xf0
	// CTIN_0
	GIMA_CTIN_0_IN_SELECT_CTIN_0 = 0x0
	// Position of RESERVED field.
	GIMA_CTIN_0_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CTIN_0_IN_RESERVED_Msk = 0xffffff00

	// CTIN_1_IN: SCT CTIN_1 capture input multiplexer (GIMA output 17)
	// Position of INV field.
	GIMA_CTIN_1_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CTIN_1_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CTIN_1_IN_INV = 0x1
	// Not inverted.
	GIMA_CTIN_1_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CTIN_1_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CTIN_1_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CTIN_1_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CTIN_1_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CTIN_1_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CTIN_1_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CTIN_1_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CTIN_1_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CTIN_1_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CTIN_1_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CTIN_1_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CTIN_1_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CTIN_1_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CTIN_1_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CTIN_1_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CTIN_1_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CTIN_1_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CTIN_1_IN_SELECT_Msk = 0xf0
	// CTIN_1
	GIMA_CTIN_1_IN_SELECT_CTIN_1 = 0x0
	// USART2 TX active
	GIMA_CTIN_1_IN_SELECT_USART2_TX_ACTIVE = 0x1
	// Position of RESERVED field.
	GIMA_CTIN_1_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CTIN_1_IN_RESERVED_Msk = 0xffffff00

	// CTIN_2_IN: SCT CTIN_2 capture input multiplexer (GIMA output 18)
	// Position of INV field.
	GIMA_CTIN_2_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CTIN_2_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CTIN_2_IN_INV = 0x1
	// Not inverted.
	GIMA_CTIN_2_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CTIN_2_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CTIN_2_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CTIN_2_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CTIN_2_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CTIN_2_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CTIN_2_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CTIN_2_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CTIN_2_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CTIN_2_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CTIN_2_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CTIN_2_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CTIN_2_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CTIN_2_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CTIN_2_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CTIN_2_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CTIN_2_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CTIN_2_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CTIN_2_IN_SELECT_Msk = 0xf0
	// CTIN_2
	GIMA_CTIN_2_IN_SELECT_CTIN_2 = 0x0
	// Position of RESERVED field.
	GIMA_CTIN_2_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CTIN_2_IN_RESERVED_Msk = 0xffffff00

	// CTIN_3_IN: SCT CTIN_3 capture input multiplexer (GIMA output 19)
	// Position of INV field.
	GIMA_CTIN_3_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CTIN_3_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CTIN_3_IN_INV = 0x1
	// Not inverted.
	GIMA_CTIN_3_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CTIN_3_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CTIN_3_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CTIN_3_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CTIN_3_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CTIN_3_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CTIN_3_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CTIN_3_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CTIN_3_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CTIN_3_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CTIN_3_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CTIN_3_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CTIN_3_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CTIN_3_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CTIN_3_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CTIN_3_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CTIN_3_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CTIN_3_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CTIN_3_IN_SELECT_Msk = 0xf0
	// CTIN_3
	GIMA_CTIN_3_IN_SELECT_CTIN_3 = 0x0
	// USART0 TX active
	GIMA_CTIN_3_IN_SELECT_USART0_TX_ACTIVE = 0x1
	// Position of RESERVED field.
	GIMA_CTIN_3_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CTIN_3_IN_RESERVED_Msk = 0xffffff00

	// CTIN_4_IN: SCT CTIN_4 capture input multiplexer (GIMA output 20)
	// Position of INV field.
	GIMA_CTIN_4_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CTIN_4_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CTIN_4_IN_INV = 0x1
	// Not inverted.
	GIMA_CTIN_4_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CTIN_4_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CTIN_4_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CTIN_4_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CTIN_4_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CTIN_4_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CTIN_4_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CTIN_4_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CTIN_4_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CTIN_4_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CTIN_4_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CTIN_4_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CTIN_4_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CTIN_4_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CTIN_4_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CTIN_4_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CTIN_4_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CTIN_4_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CTIN_4_IN_SELECT_Msk = 0xf0
	// CTIN_4
	GIMA_CTIN_4_IN_SELECT_CTIN_4 = 0x0
	// USART0 RX active
	GIMA_CTIN_4_IN_SELECT_USART0_RX_ACTIVE = 0x1
	// - I2S1_RX_MWS1
	GIMA_CTIN_4_IN_SELECT__I2S1_RX_MWS1 = 0x2
	// - I2S1_TX_MWS1
	GIMA_CTIN_4_IN_SELECT__I2S1_TX_MWS1 = 0x3
	// Position of RESERVED field.
	GIMA_CTIN_4_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CTIN_4_IN_RESERVED_Msk = 0xffffff00

	// CTIN_5_IN: SCT CTIN_5 capture input multiplexer (GIMA output 21)
	// Position of INV field.
	GIMA_CTIN_5_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CTIN_5_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CTIN_5_IN_INV = 0x1
	// Not inverted.
	GIMA_CTIN_5_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CTIN_5_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CTIN_5_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CTIN_5_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CTIN_5_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CTIN_5_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CTIN_5_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CTIN_5_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CTIN_5_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CTIN_5_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CTIN_5_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CTIN_5_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CTIN_5_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CTIN_5_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CTIN_5_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CTIN_5_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CTIN_5_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CTIN_5_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CTIN_5_IN_SELECT_Msk = 0xf0
	// CTIN_5
	GIMA_CTIN_5_IN_SELECT_CTIN_5 = 0x0
	// USART2 RX active
	GIMA_CTIN_5_IN_SELECT_USART2_RX_ACTIVE = 0x1
	// Position of RESERVED field.
	GIMA_CTIN_5_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CTIN_5_IN_RESERVED_Msk = 0xffffff00

	// CTIN_6_IN: SCT CTIN_6 capture input multiplexer (GIMA output 22)
	// Position of INV field.
	GIMA_CTIN_6_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CTIN_6_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CTIN_6_IN_INV = 0x1
	// Not inverted.
	GIMA_CTIN_6_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CTIN_6_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CTIN_6_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CTIN_6_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CTIN_6_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CTIN_6_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CTIN_6_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CTIN_6_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CTIN_6_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CTIN_6_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CTIN_6_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CTIN_6_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CTIN_6_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CTIN_6_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CTIN_6_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CTIN_6_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CTIN_6_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CTIN_6_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CTIN_6_IN_SELECT_Msk = 0xf0
	// CTIN_6
	GIMA_CTIN_6_IN_SELECT_CTIN_6 = 0x0
	// USART3 TX active
	GIMA_CTIN_6_IN_SELECT_USART3_TX_ACTIVE = 0x1
	// I2S0_RX_MWS
	GIMA_CTIN_6_IN_SELECT_I2S0_RX_MWS = 0x2
	// I2S0_TX_MWS
	GIMA_CTIN_6_IN_SELECT_I2S0_TX_MWS = 0x3
	// Position of RESERVED field.
	GIMA_CTIN_6_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CTIN_6_IN_RESERVED_Msk = 0xffffff00

	// CTIN_7_IN: SCT CTIN_7 capture input multiplexer (GIMA output 23)
	// Position of INV field.
	GIMA_CTIN_7_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_CTIN_7_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_CTIN_7_IN_INV = 0x1
	// Not inverted.
	GIMA_CTIN_7_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_CTIN_7_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_CTIN_7_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_CTIN_7_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_CTIN_7_IN_EDGE = 0x2
	// No edge detection.
	GIMA_CTIN_7_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_CTIN_7_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_CTIN_7_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_CTIN_7_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_CTIN_7_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_CTIN_7_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_CTIN_7_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_CTIN_7_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_CTIN_7_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_CTIN_7_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_CTIN_7_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_CTIN_7_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_CTIN_7_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_CTIN_7_IN_SELECT_Msk = 0xf0
	// CTIN_7
	GIMA_CTIN_7_IN_SELECT_CTIN_7 = 0x0
	// USART3 RX active
	GIMA_CTIN_7_IN_SELECT_USART3_RX_ACTIVE = 0x1
	// SOF0 (Start-Of-Frame USB0)
	GIMA_CTIN_7_IN_SELECT_SOF0_START_OF_FRAME = 0x2
	// SOF1 (Start-Of-Frame USB1)
	GIMA_CTIN_7_IN_SELECT_SOF1_START_OF_FRAME = 0x3
	// Position of RESERVED field.
	GIMA_CTIN_7_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_CTIN_7_IN_RESERVED_Msk = 0xffffff00

	// EVENTROUTER_13_IN: Event router input 13 multiplexer (GIMA output 25)
	// Position of INV field.
	GIMA_EVENTROUTER_13_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_EVENTROUTER_13_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_EVENTROUTER_13_IN_INV = 0x1
	// Not inverted.
	GIMA_EVENTROUTER_13_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_EVENTROUTER_13_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_EVENTROUTER_13_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_EVENTROUTER_13_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_EVENTROUTER_13_IN_EDGE = 0x2
	// No edge detection.
	GIMA_EVENTROUTER_13_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_EVENTROUTER_13_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_EVENTROUTER_13_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_EVENTROUTER_13_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_EVENTROUTER_13_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_EVENTROUTER_13_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_EVENTROUTER_13_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_EVENTROUTER_13_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_EVENTROUTER_13_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_EVENTROUTER_13_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_EVENTROUTER_13_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_EVENTROUTER_13_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_EVENTROUTER_13_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_EVENTROUTER_13_IN_SELECT_Msk = 0xf0
	// CTOUT_2 or T0_MAT2
	GIMA_EVENTROUTER_13_IN_SELECT_CTOUT_2_OR_T0_MAT2 = 0x0
	// T0_MAT2
	GIMA_EVENTROUTER_13_IN_SELECT_T0_MAT2 = 0x2
	// Position of RESERVED field.
	GIMA_EVENTROUTER_13_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_EVENTROUTER_13_IN_RESERVED_Msk = 0xffffff00

	// EVENTROUTER_14_IN: Event router input 14 multiplexer (GIMA output 26)
	// Position of INV field.
	GIMA_EVENTROUTER_14_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_EVENTROUTER_14_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_EVENTROUTER_14_IN_INV = 0x1
	// Not inverted.
	GIMA_EVENTROUTER_14_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_EVENTROUTER_14_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_EVENTROUTER_14_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_EVENTROUTER_14_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_EVENTROUTER_14_IN_EDGE = 0x2
	// No edge detection.
	GIMA_EVENTROUTER_14_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_EVENTROUTER_14_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_EVENTROUTER_14_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_EVENTROUTER_14_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_EVENTROUTER_14_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_EVENTROUTER_14_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_EVENTROUTER_14_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_EVENTROUTER_14_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_EVENTROUTER_14_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_EVENTROUTER_14_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_EVENTROUTER_14_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_EVENTROUTER_14_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_EVENTROUTER_14_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_EVENTROUTER_14_IN_SELECT_Msk = 0xf0
	// CTOUT_6 or T1_MAT2
	GIMA_EVENTROUTER_14_IN_SELECT_CTOUT_6_OR_T1_MAT2 = 0x0
	// T1_MAT2
	GIMA_EVENTROUTER_14_IN_SELECT_T1_MAT2 = 0x2
	// Position of RESERVED field.
	GIMA_EVENTROUTER_14_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_EVENTROUTER_14_IN_RESERVED_Msk = 0xffffff00

	// EVENTROUTER_16_IN: Event router input 16 multiplexer (GIMA output 27)
	// Position of INV field.
	GIMA_EVENTROUTER_16_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_EVENTROUTER_16_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_EVENTROUTER_16_IN_INV = 0x1
	// Not inverted.
	GIMA_EVENTROUTER_16_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_EVENTROUTER_16_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_EVENTROUTER_16_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_EVENTROUTER_16_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_EVENTROUTER_16_IN_EDGE = 0x2
	// No edge detection.
	GIMA_EVENTROUTER_16_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_EVENTROUTER_16_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_EVENTROUTER_16_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_EVENTROUTER_16_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_EVENTROUTER_16_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_EVENTROUTER_16_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_EVENTROUTER_16_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_EVENTROUTER_16_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_EVENTROUTER_16_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_EVENTROUTER_16_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_EVENTROUTER_16_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_EVENTROUTER_16_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_EVENTROUTER_16_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_EVENTROUTER_16_IN_SELECT_Msk = 0xf0
	// CTOUT_14 or T3_MAT2
	GIMA_EVENTROUTER_16_IN_SELECT_CTOUT_14_OR_T3_MAT2 = 0x0
	// T3_MAT2
	GIMA_EVENTROUTER_16_IN_SELECT_T3_MAT2 = 0x1
	// Position of RESERVED field.
	GIMA_EVENTROUTER_16_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_EVENTROUTER_16_IN_RESERVED_Msk = 0xffffff00

	// ADCSTART0_IN: ADC start0 input multiplexer (GIMA output 28)
	// Position of INV field.
	GIMA_ADCSTART0_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_ADCSTART0_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_ADCSTART0_IN_INV = 0x1
	// Not inverted.
	GIMA_ADCSTART0_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_ADCSTART0_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_ADCSTART0_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_ADCSTART0_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_ADCSTART0_IN_EDGE = 0x2
	// No edge detection.
	GIMA_ADCSTART0_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_ADCSTART0_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_ADCSTART0_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_ADCSTART0_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_ADCSTART0_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_ADCSTART0_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_ADCSTART0_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_ADCSTART0_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_ADCSTART0_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_ADCSTART0_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_ADCSTART0_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_ADCSTART0_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_ADCSTART0_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_ADCSTART0_IN_SELECT_Msk = 0xf0
	// CTOUT_15 or T3_MAT3
	GIMA_ADCSTART0_IN_SELECT_CTOUT_15_OR_T3_MAT3 = 0x0
	// T0_MAT0
	GIMA_ADCSTART0_IN_SELECT_T0_MAT0 = 0x1
	// Position of RESERVED field.
	GIMA_ADCSTART0_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_ADCSTART0_IN_RESERVED_Msk = 0xffffff00

	// ADCSTART1_IN: ADC start1 input multiplexer (GIMA output 29)
	// Position of INV field.
	GIMA_ADCSTART1_IN_INV_Pos = 0x0
	// Bit mask of INV field.
	GIMA_ADCSTART1_IN_INV_Msk = 0x1
	// Bit INV.
	GIMA_ADCSTART1_IN_INV = 0x1
	// Not inverted.
	GIMA_ADCSTART1_IN_INV_NOT_INVERTED = 0x0
	// Input inverted.
	GIMA_ADCSTART1_IN_INV_INPUT_INVERTED = 0x1
	// Position of EDGE field.
	GIMA_ADCSTART1_IN_EDGE_Pos = 0x1
	// Bit mask of EDGE field.
	GIMA_ADCSTART1_IN_EDGE_Msk = 0x2
	// Bit EDGE.
	GIMA_ADCSTART1_IN_EDGE = 0x2
	// No edge detection.
	GIMA_ADCSTART1_IN_EDGE_NO_EDGE_DETECTION = 0x0
	// Rising edge detection enabled.
	GIMA_ADCSTART1_IN_EDGE_RISING_EDGE_DETECTIO = 0x1
	// Position of SYNCH field.
	GIMA_ADCSTART1_IN_SYNCH_Pos = 0x2
	// Bit mask of SYNCH field.
	GIMA_ADCSTART1_IN_SYNCH_Msk = 0x4
	// Bit SYNCH.
	GIMA_ADCSTART1_IN_SYNCH = 0x4
	// Disable synchronization.
	GIMA_ADCSTART1_IN_SYNCH_DISABLE__SYNCHRONIZ = 0x0
	// Enable synchronization.
	GIMA_ADCSTART1_IN_SYNCH_ENABLE__SYNCHRONIZA = 0x1
	// Position of PULSE field.
	GIMA_ADCSTART1_IN_PULSE_Pos = 0x3
	// Bit mask of PULSE field.
	GIMA_ADCSTART1_IN_PULSE_Msk = 0x8
	// Bit PULSE.
	GIMA_ADCSTART1_IN_PULSE = 0x8
	// Disable single pulse generation.
	GIMA_ADCSTART1_IN_PULSE_DISABLE_SINGLE_PULSE = 0x0
	// Enable single pulse generation.
	GIMA_ADCSTART1_IN_PULSE_ENABLE_SINGLE_PULSE = 0x1
	// Position of SELECT field.
	GIMA_ADCSTART1_IN_SELECT_Pos = 0x4
	// Bit mask of SELECT field.
	GIMA_ADCSTART1_IN_SELECT_Msk = 0xf0
	// CTOUT_8 or T2_MAT0
	GIMA_ADCSTART1_IN_SELECT_CTOUT_8_OR_T2_MAT0 = 0x0
	// T2_MAT0
	GIMA_ADCSTART1_IN_SELECT_T2_MAT0 = 0x1
	// Position of RESERVED field.
	GIMA_ADCSTART1_IN_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GIMA_ADCSTART1_IN_RESERVED_Msk = 0xffffff00
)

// Constants for DAC: Digital-to-Analog Converter (DAC)
const (
	// CR: DAC register. Holds the conversion data.
	// Position of RESERVED field.
	DAC_CR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	DAC_CR_RESERVED_Msk = 0x3f
	// Position of VALUE field.
	DAC_CR_VALUE_Pos = 0x6
	// Bit mask of VALUE field.
	DAC_CR_VALUE_Msk = 0xffc0
	// Position of BIAS field.
	DAC_CR_BIAS_Pos = 0x10
	// Bit mask of BIAS field.
	DAC_CR_BIAS_Msk = 0x10000
	// Bit BIAS.
	DAC_CR_BIAS = 0x10000
	// The settling time of the DAC is 1 micros max, and the maximum current is 700 microA.
	DAC_CR_BIAS_SHORT = 0x0
	// The settling time of the DAC is 2.5 micros and the maximum current is 350 microA.
	DAC_CR_BIAS_LONG = 0x1
	// Position of RESERVED field.
	DAC_CR_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	DAC_CR_RESERVED_Msk = 0xfffe0000

	// CTRL: DAC control register.
	// Position of INT_DMA_REQ field.
	DAC_CTRL_INT_DMA_REQ_Pos = 0x0
	// Bit mask of INT_DMA_REQ field.
	DAC_CTRL_INT_DMA_REQ_Msk = 0x1
	// Bit INT_DMA_REQ.
	DAC_CTRL_INT_DMA_REQ = 0x1
	// This bit is cleared on any write to the DACR register.
	DAC_CTRL_INT_DMA_REQ_CLR = 0x0
	// This bit is set by hardware when the timer times out.
	DAC_CTRL_INT_DMA_REQ_SET = 0x1
	// Position of DBLBUF_ENA field.
	DAC_CTRL_DBLBUF_ENA_Pos = 0x1
	// Bit mask of DBLBUF_ENA field.
	DAC_CTRL_DBLBUF_ENA_Msk = 0x2
	// Bit DBLBUF_ENA.
	DAC_CTRL_DBLBUF_ENA = 0x2
	// DACR double-buffering is disabled.
	DAC_CTRL_DBLBUF_ENA_DISABLED = 0x0
	// When this bit and the CNT_ENA bit are both set, the double-buffering feature in the DACR register will be enabled. Writes to the DACR register are written to a pre-buffer and then transferred to the DACR on the next time-out of the counter.
	DAC_CTRL_DBLBUF_ENA_ENABLED = 0x1
	// Position of CNT_ENA field.
	DAC_CTRL_CNT_ENA_Pos = 0x2
	// Bit mask of CNT_ENA field.
	DAC_CTRL_CNT_ENA_Msk = 0x4
	// Bit CNT_ENA.
	DAC_CTRL_CNT_ENA = 0x4
	// Time-out counter operation is disabled.
	DAC_CTRL_CNT_ENA_DISABLED = 0x0
	// Time-out counter operation is enabled.
	DAC_CTRL_CNT_ENA_ENABLED = 0x1
	// Position of DMA_ENA field.
	DAC_CTRL_DMA_ENA_Pos = 0x3
	// Bit mask of DMA_ENA field.
	DAC_CTRL_DMA_ENA_Msk = 0x8
	// Bit DMA_ENA.
	DAC_CTRL_DMA_ENA = 0x8
	// DMA access is disabled.
	DAC_CTRL_DMA_ENA_DISABLED = 0x0
	// DMA Burst Request Input 15 is enabled for the DAC (see Table 136).
	DAC_CTRL_DMA_ENA_ENABLED = 0x1
	// Position of RESERVED field.
	DAC_CTRL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	DAC_CTRL_RESERVED_Msk = 0xfffffff0

	// CNTVAL: DAC counter value register.
	// Position of VALUE field.
	DAC_CNTVAL_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	DAC_CNTVAL_VALUE_Msk = 0xffff
	// Position of RESERVED field.
	DAC_CNTVAL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	DAC_CNTVAL_RESERVED_Msk = 0xffff0000
)

// Constants for ADC0: 10-bit Analog-to-Digital Converter (ADC)
const (
	// CR: A/D Control Register. The AD0CR register must be written to select the operating mode before A/D conversion can occur.
	// Position of SEL field.
	ADC_CR_SEL_Pos = 0x0
	// Bit mask of SEL field.
	ADC_CR_SEL_Msk = 0xff
	// Position of CLKDIV field.
	ADC_CR_CLKDIV_Pos = 0x8
	// Bit mask of CLKDIV field.
	ADC_CR_CLKDIV_Msk = 0xff00
	// Position of BURST field.
	ADC_CR_BURST_Pos = 0x10
	// Bit mask of BURST field.
	ADC_CR_BURST_Msk = 0x10000
	// Bit BURST.
	ADC_CR_BURST = 0x10000
	// Conversions are software controlled and require 11 clocks.
	ADC_CR_BURST_SOFTWARE = 0x0
	// The AD converter does repeated conversions at the rate selected by the CLKS field, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant 1 in the SEL field, then higher numbered 1 bits (pins) if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion that is in progress when this bit is cleared will be completed. Important: START bits must be 000 when BURST = 1 or conversions will not start.
	ADC_CR_BURST_BURST = 0x1
	// Position of CLKS field.
	ADC_CR_CLKS_Pos = 0x11
	// Bit mask of CLKS field.
	ADC_CR_CLKS_Msk = 0xe0000
	// 11 clocks / 10 bits
	ADC_CR_CLKS_11_CLOCKS_10_BITS = 0x0
	// 10 clocks / 9 bits
	ADC_CR_CLKS_10_CLOCKS_9_BITS = 0x1
	// 9 clocks / 8 bits
	ADC_CR_CLKS_9_CLOCKS_8_BITS = 0x2
	// 8 clocks / 7 bits
	ADC_CR_CLKS_8_CLOCKS_7_BITS = 0x3
	// 7 clocks / 6 bits
	ADC_CR_CLKS_7_CLOCKS_6_BITS = 0x4
	// 6 clocks / 5 bits
	ADC_CR_CLKS_6_CLOCKS_5_BITS = 0x5
	// 5 clocks / 4 bits
	ADC_CR_CLKS_5_CLOCKS_4_BITS = 0x6
	// 4 clocks / 3 bits
	ADC_CR_CLKS_4_CLOCKS_3_BITS = 0x7
	// Position of RESERVED field.
	ADC_CR_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	ADC_CR_RESERVED_Msk = 0x100000
	// Bit RESERVED.
	ADC_CR_RESERVED = 0x100000
	// Position of PDN field.
	ADC_CR_PDN_Pos = 0x15
	// Bit mask of PDN field.
	ADC_CR_PDN_Msk = 0x200000
	// Bit PDN.
	ADC_CR_PDN = 0x200000
	// The A/D converter is in Power-down mode.
	ADC_CR_PDN_POWERDOWN = 0x0
	// The A/D converter is operational.
	ADC_CR_PDN_RUNNING = 0x1
	// Position of RESERVED field.
	ADC_CR_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	ADC_CR_RESERVED_Msk = 0xc00000
	// Position of START field.
	ADC_CR_START_Pos = 0x18
	// Bit mask of START field.
	ADC_CR_START_Msk = 0x7000000
	// No start (this value should be used when clearing PDN to 0).
	ADC_CR_START_NO_START = 0x0
	// Start conversion now.
	ADC_CR_START_START_CONVERSION_NOW = 0x1
	// Start conversion when the edge selected by bit 27 occurs on CTOUT_15 (combined timer output 15).
	ADC_CR_START_CTOUT_15 = 0x2
	// Start conversion when the edge selected by bit 27 occurs on CTOUT_8 (combined timer output 8).
	ADC_CR_START_CTOUT_8 = 0x3
	// Start conversion when the edge selected by bit 27 occurs on ADCTRIG0 input.
	ADC_CR_START_ADCTRIG0 = 0x4
	// Start conversion when the edge selected by bit 27 occurs on ADCTRIG1 input.
	ADC_CR_START_ADCTRIG1 = 0x5
	// Start conversion when the edge selected by bit 27 occurs on Motocon PWM output MCOA2.
	ADC_CR_START_MCOA2 = 0x6
	// Reserved.
	ADC_CR_START_RESERVED_ = 0x7
	// Position of EDGE field.
	ADC_CR_EDGE_Pos = 0x1b
	// Bit mask of EDGE field.
	ADC_CR_EDGE_Msk = 0x8000000
	// Bit EDGE.
	ADC_CR_EDGE = 0x8000000
	// Start conversion on a rising edge on the selected signal.
	ADC_CR_EDGE_RISING = 0x0
	// Start conversion on a falling edge on the selected signal.
	ADC_CR_EDGE_FALLING = 0x1
	// Position of RESERVED field.
	ADC_CR_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	ADC_CR_RESERVED_Msk = 0xf0000000

	// GDR: A/D Global Data Register. Contains the result of the most recent A/D conversion.
	// Position of RESERVED field.
	ADC_GDR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ADC_GDR_RESERVED_Msk = 0x3f
	// Position of V_VREF field.
	ADC_GDR_V_VREF_Pos = 0x6
	// Bit mask of V_VREF field.
	ADC_GDR_V_VREF_Msk = 0xffc0
	// Position of RESERVED field.
	ADC_GDR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ADC_GDR_RESERVED_Msk = 0xff0000
	// Position of CHN field.
	ADC_GDR_CHN_Pos = 0x18
	// Bit mask of CHN field.
	ADC_GDR_CHN_Msk = 0x7000000
	// Position of RESERVED field.
	ADC_GDR_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	ADC_GDR_RESERVED_Msk = 0x38000000
	// Position of OVERRUN field.
	ADC_GDR_OVERRUN_Pos = 0x1e
	// Bit mask of OVERRUN field.
	ADC_GDR_OVERRUN_Msk = 0x40000000
	// Bit OVERRUN.
	ADC_GDR_OVERRUN = 0x40000000
	// Position of DONE field.
	ADC_GDR_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	ADC_GDR_DONE_Msk = 0x80000000
	// Bit DONE.
	ADC_GDR_DONE = 0x80000000

	// INTEN: A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
	// Position of ADINTEN field.
	ADC_INTEN_ADINTEN_Pos = 0x0
	// Bit mask of ADINTEN field.
	ADC_INTEN_ADINTEN_Msk = 0xff
	// Position of ADGINTEN field.
	ADC_INTEN_ADGINTEN_Pos = 0x8
	// Bit mask of ADGINTEN field.
	ADC_INTEN_ADGINTEN_Msk = 0x100
	// Bit ADGINTEN.
	ADC_INTEN_ADGINTEN = 0x100
	// Position of RESERVED field.
	ADC_INTEN_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	ADC_INTEN_RESERVED_Msk = 0xfffffe00

	// DR: A/D Channel Data Register. This register contains the result of the most recent conversion completed on channel n.
	// Position of RESERVED field.
	ADC_DR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ADC_DR_RESERVED_Msk = 0x3f
	// Position of V_VREF field.
	ADC_DR_V_VREF_Pos = 0x6
	// Bit mask of V_VREF field.
	ADC_DR_V_VREF_Msk = 0xffc0
	// Position of RESERVED field.
	ADC_DR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ADC_DR_RESERVED_Msk = 0x3fff0000
	// Position of OVERRUN field.
	ADC_DR_OVERRUN_Pos = 0x1e
	// Bit mask of OVERRUN field.
	ADC_DR_OVERRUN_Msk = 0x40000000
	// Bit OVERRUN.
	ADC_DR_OVERRUN = 0x40000000
	// Position of DONE field.
	ADC_DR_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	ADC_DR_DONE_Msk = 0x80000000
	// Bit DONE.
	ADC_DR_DONE = 0x80000000

	// STAT: A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag.
	// Position of DONE field.
	ADC_STAT_DONE_Pos = 0x0
	// Bit mask of DONE field.
	ADC_STAT_DONE_Msk = 0xff
	// Position of OVERUN field.
	ADC_STAT_OVERUN_Pos = 0x8
	// Bit mask of OVERUN field.
	ADC_STAT_OVERUN_Msk = 0xff00
	// Position of ADINT field.
	ADC_STAT_ADINT_Pos = 0x10
	// Bit mask of ADINT field.
	ADC_STAT_ADINT_Msk = 0x10000
	// Bit ADINT.
	ADC_STAT_ADINT = 0x10000
	// Position of RESERVED field.
	ADC_STAT_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	ADC_STAT_RESERVED_Msk = 0xfffe0000
)

// Constants for GPIO_PORT: GPIO port
const (
	// B: Byte pin registers port 0 to 5; pins PIOn_0 to PIOn_31
	// Position of PBYTE field.
	GPIO_PORT_B_PBYTE_Pos = 0x0
	// Bit mask of PBYTE field.
	GPIO_PORT_B_PBYTE_Msk = 0x1
	// Bit PBYTE.
	GPIO_PORT_B_PBYTE = 0x1

	// W: Word pin registers port 0 to 5
	// Position of PWORD field.
	GPIO_PORT_W_PWORD_Pos = 0x0
	// Bit mask of PWORD field.
	GPIO_PORT_W_PWORD_Msk = 0xffffffff

	// DIR0: Direction registers port m
	// Position of DIRP0 field.
	GPIO_PORT_DIR_DIRP0_Pos = 0x0
	// Bit mask of DIRP0 field.
	GPIO_PORT_DIR_DIRP0_Msk = 0x1
	// Bit DIRP0.
	GPIO_PORT_DIR_DIRP0 = 0x1
	// Position of DIRP1 field.
	GPIO_PORT_DIR_DIRP1_Pos = 0x1
	// Bit mask of DIRP1 field.
	GPIO_PORT_DIR_DIRP1_Msk = 0x2
	// Bit DIRP1.
	GPIO_PORT_DIR_DIRP1 = 0x2
	// Position of DIRP2 field.
	GPIO_PORT_DIR_DIRP2_Pos = 0x2
	// Bit mask of DIRP2 field.
	GPIO_PORT_DIR_DIRP2_Msk = 0x4
	// Bit DIRP2.
	GPIO_PORT_DIR_DIRP2 = 0x4
	// Position of DIRP3 field.
	GPIO_PORT_DIR_DIRP3_Pos = 0x3
	// Bit mask of DIRP3 field.
	GPIO_PORT_DIR_DIRP3_Msk = 0x8
	// Bit DIRP3.
	GPIO_PORT_DIR_DIRP3 = 0x8
	// Position of DIRP4 field.
	GPIO_PORT_DIR_DIRP4_Pos = 0x4
	// Bit mask of DIRP4 field.
	GPIO_PORT_DIR_DIRP4_Msk = 0x10
	// Bit DIRP4.
	GPIO_PORT_DIR_DIRP4 = 0x10
	// Position of DIRP5 field.
	GPIO_PORT_DIR_DIRP5_Pos = 0x5
	// Bit mask of DIRP5 field.
	GPIO_PORT_DIR_DIRP5_Msk = 0x20
	// Bit DIRP5.
	GPIO_PORT_DIR_DIRP5 = 0x20
	// Position of DIRP6 field.
	GPIO_PORT_DIR_DIRP6_Pos = 0x6
	// Bit mask of DIRP6 field.
	GPIO_PORT_DIR_DIRP6_Msk = 0x40
	// Bit DIRP6.
	GPIO_PORT_DIR_DIRP6 = 0x40
	// Position of DIRP7 field.
	GPIO_PORT_DIR_DIRP7_Pos = 0x7
	// Bit mask of DIRP7 field.
	GPIO_PORT_DIR_DIRP7_Msk = 0x80
	// Bit DIRP7.
	GPIO_PORT_DIR_DIRP7 = 0x80
	// Position of DIRP8 field.
	GPIO_PORT_DIR_DIRP8_Pos = 0x8
	// Bit mask of DIRP8 field.
	GPIO_PORT_DIR_DIRP8_Msk = 0x100
	// Bit DIRP8.
	GPIO_PORT_DIR_DIRP8 = 0x100
	// Position of DIRP9 field.
	GPIO_PORT_DIR_DIRP9_Pos = 0x9
	// Bit mask of DIRP9 field.
	GPIO_PORT_DIR_DIRP9_Msk = 0x200
	// Bit DIRP9.
	GPIO_PORT_DIR_DIRP9 = 0x200
	// Position of DIRP10 field.
	GPIO_PORT_DIR_DIRP10_Pos = 0xa
	// Bit mask of DIRP10 field.
	GPIO_PORT_DIR_DIRP10_Msk = 0x400
	// Bit DIRP10.
	GPIO_PORT_DIR_DIRP10 = 0x400
	// Position of DIRP11 field.
	GPIO_PORT_DIR_DIRP11_Pos = 0xb
	// Bit mask of DIRP11 field.
	GPIO_PORT_DIR_DIRP11_Msk = 0x800
	// Bit DIRP11.
	GPIO_PORT_DIR_DIRP11 = 0x800
	// Position of DIRP12 field.
	GPIO_PORT_DIR_DIRP12_Pos = 0xc
	// Bit mask of DIRP12 field.
	GPIO_PORT_DIR_DIRP12_Msk = 0x1000
	// Bit DIRP12.
	GPIO_PORT_DIR_DIRP12 = 0x1000
	// Position of DIRP13 field.
	GPIO_PORT_DIR_DIRP13_Pos = 0xd
	// Bit mask of DIRP13 field.
	GPIO_PORT_DIR_DIRP13_Msk = 0x2000
	// Bit DIRP13.
	GPIO_PORT_DIR_DIRP13 = 0x2000
	// Position of DIRP14 field.
	GPIO_PORT_DIR_DIRP14_Pos = 0xe
	// Bit mask of DIRP14 field.
	GPIO_PORT_DIR_DIRP14_Msk = 0x4000
	// Bit DIRP14.
	GPIO_PORT_DIR_DIRP14 = 0x4000
	// Position of DIRP15 field.
	GPIO_PORT_DIR_DIRP15_Pos = 0xf
	// Bit mask of DIRP15 field.
	GPIO_PORT_DIR_DIRP15_Msk = 0x8000
	// Bit DIRP15.
	GPIO_PORT_DIR_DIRP15 = 0x8000
	// Position of DIRP16 field.
	GPIO_PORT_DIR_DIRP16_Pos = 0x10
	// Bit mask of DIRP16 field.
	GPIO_PORT_DIR_DIRP16_Msk = 0x10000
	// Bit DIRP16.
	GPIO_PORT_DIR_DIRP16 = 0x10000
	// Position of DIRP17 field.
	GPIO_PORT_DIR_DIRP17_Pos = 0x11
	// Bit mask of DIRP17 field.
	GPIO_PORT_DIR_DIRP17_Msk = 0x20000
	// Bit DIRP17.
	GPIO_PORT_DIR_DIRP17 = 0x20000
	// Position of DIRP18 field.
	GPIO_PORT_DIR_DIRP18_Pos = 0x12
	// Bit mask of DIRP18 field.
	GPIO_PORT_DIR_DIRP18_Msk = 0x40000
	// Bit DIRP18.
	GPIO_PORT_DIR_DIRP18 = 0x40000
	// Position of DIRP19 field.
	GPIO_PORT_DIR_DIRP19_Pos = 0x13
	// Bit mask of DIRP19 field.
	GPIO_PORT_DIR_DIRP19_Msk = 0x80000
	// Bit DIRP19.
	GPIO_PORT_DIR_DIRP19 = 0x80000
	// Position of DIRP20 field.
	GPIO_PORT_DIR_DIRP20_Pos = 0x14
	// Bit mask of DIRP20 field.
	GPIO_PORT_DIR_DIRP20_Msk = 0x100000
	// Bit DIRP20.
	GPIO_PORT_DIR_DIRP20 = 0x100000
	// Position of DIRP21 field.
	GPIO_PORT_DIR_DIRP21_Pos = 0x15
	// Bit mask of DIRP21 field.
	GPIO_PORT_DIR_DIRP21_Msk = 0x200000
	// Bit DIRP21.
	GPIO_PORT_DIR_DIRP21 = 0x200000
	// Position of DIRP22 field.
	GPIO_PORT_DIR_DIRP22_Pos = 0x16
	// Bit mask of DIRP22 field.
	GPIO_PORT_DIR_DIRP22_Msk = 0x400000
	// Bit DIRP22.
	GPIO_PORT_DIR_DIRP22 = 0x400000
	// Position of DIRP23 field.
	GPIO_PORT_DIR_DIRP23_Pos = 0x17
	// Bit mask of DIRP23 field.
	GPIO_PORT_DIR_DIRP23_Msk = 0x800000
	// Bit DIRP23.
	GPIO_PORT_DIR_DIRP23 = 0x800000
	// Position of DIRP24 field.
	GPIO_PORT_DIR_DIRP24_Pos = 0x18
	// Bit mask of DIRP24 field.
	GPIO_PORT_DIR_DIRP24_Msk = 0x1000000
	// Bit DIRP24.
	GPIO_PORT_DIR_DIRP24 = 0x1000000
	// Position of DIRP25 field.
	GPIO_PORT_DIR_DIRP25_Pos = 0x19
	// Bit mask of DIRP25 field.
	GPIO_PORT_DIR_DIRP25_Msk = 0x2000000
	// Bit DIRP25.
	GPIO_PORT_DIR_DIRP25 = 0x2000000
	// Position of DIRP26 field.
	GPIO_PORT_DIR_DIRP26_Pos = 0x1a
	// Bit mask of DIRP26 field.
	GPIO_PORT_DIR_DIRP26_Msk = 0x4000000
	// Bit DIRP26.
	GPIO_PORT_DIR_DIRP26 = 0x4000000
	// Position of DIRP27 field.
	GPIO_PORT_DIR_DIRP27_Pos = 0x1b
	// Bit mask of DIRP27 field.
	GPIO_PORT_DIR_DIRP27_Msk = 0x8000000
	// Bit DIRP27.
	GPIO_PORT_DIR_DIRP27 = 0x8000000
	// Position of DIRP28 field.
	GPIO_PORT_DIR_DIRP28_Pos = 0x1c
	// Bit mask of DIRP28 field.
	GPIO_PORT_DIR_DIRP28_Msk = 0x10000000
	// Bit DIRP28.
	GPIO_PORT_DIR_DIRP28 = 0x10000000
	// Position of DIRP29 field.
	GPIO_PORT_DIR_DIRP29_Pos = 0x1d
	// Bit mask of DIRP29 field.
	GPIO_PORT_DIR_DIRP29_Msk = 0x20000000
	// Bit DIRP29.
	GPIO_PORT_DIR_DIRP29 = 0x20000000
	// Position of DIRP30 field.
	GPIO_PORT_DIR_DIRP30_Pos = 0x1e
	// Bit mask of DIRP30 field.
	GPIO_PORT_DIR_DIRP30_Msk = 0x40000000
	// Bit DIRP30.
	GPIO_PORT_DIR_DIRP30 = 0x40000000
	// Position of DIRP31 field.
	GPIO_PORT_DIR_DIRP31_Pos = 0x1f
	// Bit mask of DIRP31 field.
	GPIO_PORT_DIR_DIRP31_Msk = 0x80000000
	// Bit DIRP31.
	GPIO_PORT_DIR_DIRP31 = 0x80000000

	// MASK0: Mask register port m
	// Position of MASKP0 field.
	GPIO_PORT_MASK_MASKP0_Pos = 0x0
	// Bit mask of MASKP0 field.
	GPIO_PORT_MASK_MASKP0_Msk = 0x1
	// Bit MASKP0.
	GPIO_PORT_MASK_MASKP0 = 0x1
	// Position of MASKP1 field.
	GPIO_PORT_MASK_MASKP1_Pos = 0x1
	// Bit mask of MASKP1 field.
	GPIO_PORT_MASK_MASKP1_Msk = 0x2
	// Bit MASKP1.
	GPIO_PORT_MASK_MASKP1 = 0x2
	// Position of MASKP2 field.
	GPIO_PORT_MASK_MASKP2_Pos = 0x2
	// Bit mask of MASKP2 field.
	GPIO_PORT_MASK_MASKP2_Msk = 0x4
	// Bit MASKP2.
	GPIO_PORT_MASK_MASKP2 = 0x4
	// Position of MASKP3 field.
	GPIO_PORT_MASK_MASKP3_Pos = 0x3
	// Bit mask of MASKP3 field.
	GPIO_PORT_MASK_MASKP3_Msk = 0x8
	// Bit MASKP3.
	GPIO_PORT_MASK_MASKP3 = 0x8
	// Position of MASKP4 field.
	GPIO_PORT_MASK_MASKP4_Pos = 0x4
	// Bit mask of MASKP4 field.
	GPIO_PORT_MASK_MASKP4_Msk = 0x10
	// Bit MASKP4.
	GPIO_PORT_MASK_MASKP4 = 0x10
	// Position of MASKP5 field.
	GPIO_PORT_MASK_MASKP5_Pos = 0x5
	// Bit mask of MASKP5 field.
	GPIO_PORT_MASK_MASKP5_Msk = 0x20
	// Bit MASKP5.
	GPIO_PORT_MASK_MASKP5 = 0x20
	// Position of MASKP6 field.
	GPIO_PORT_MASK_MASKP6_Pos = 0x6
	// Bit mask of MASKP6 field.
	GPIO_PORT_MASK_MASKP6_Msk = 0x40
	// Bit MASKP6.
	GPIO_PORT_MASK_MASKP6 = 0x40
	// Position of MASKP7 field.
	GPIO_PORT_MASK_MASKP7_Pos = 0x7
	// Bit mask of MASKP7 field.
	GPIO_PORT_MASK_MASKP7_Msk = 0x80
	// Bit MASKP7.
	GPIO_PORT_MASK_MASKP7 = 0x80
	// Position of MASKP8 field.
	GPIO_PORT_MASK_MASKP8_Pos = 0x8
	// Bit mask of MASKP8 field.
	GPIO_PORT_MASK_MASKP8_Msk = 0x100
	// Bit MASKP8.
	GPIO_PORT_MASK_MASKP8 = 0x100
	// Position of MASKP9 field.
	GPIO_PORT_MASK_MASKP9_Pos = 0x9
	// Bit mask of MASKP9 field.
	GPIO_PORT_MASK_MASKP9_Msk = 0x200
	// Bit MASKP9.
	GPIO_PORT_MASK_MASKP9 = 0x200
	// Position of MASKP10 field.
	GPIO_PORT_MASK_MASKP10_Pos = 0xa
	// Bit mask of MASKP10 field.
	GPIO_PORT_MASK_MASKP10_Msk = 0x400
	// Bit MASKP10.
	GPIO_PORT_MASK_MASKP10 = 0x400
	// Position of MASKP11 field.
	GPIO_PORT_MASK_MASKP11_Pos = 0xb
	// Bit mask of MASKP11 field.
	GPIO_PORT_MASK_MASKP11_Msk = 0x800
	// Bit MASKP11.
	GPIO_PORT_MASK_MASKP11 = 0x800
	// Position of MASKP12 field.
	GPIO_PORT_MASK_MASKP12_Pos = 0xc
	// Bit mask of MASKP12 field.
	GPIO_PORT_MASK_MASKP12_Msk = 0x1000
	// Bit MASKP12.
	GPIO_PORT_MASK_MASKP12 = 0x1000
	// Position of MASKP13 field.
	GPIO_PORT_MASK_MASKP13_Pos = 0xd
	// Bit mask of MASKP13 field.
	GPIO_PORT_MASK_MASKP13_Msk = 0x2000
	// Bit MASKP13.
	GPIO_PORT_MASK_MASKP13 = 0x2000
	// Position of MASKP14 field.
	GPIO_PORT_MASK_MASKP14_Pos = 0xe
	// Bit mask of MASKP14 field.
	GPIO_PORT_MASK_MASKP14_Msk = 0x4000
	// Bit MASKP14.
	GPIO_PORT_MASK_MASKP14 = 0x4000
	// Position of MASKP15 field.
	GPIO_PORT_MASK_MASKP15_Pos = 0xf
	// Bit mask of MASKP15 field.
	GPIO_PORT_MASK_MASKP15_Msk = 0x8000
	// Bit MASKP15.
	GPIO_PORT_MASK_MASKP15 = 0x8000
	// Position of MASKP16 field.
	GPIO_PORT_MASK_MASKP16_Pos = 0x10
	// Bit mask of MASKP16 field.
	GPIO_PORT_MASK_MASKP16_Msk = 0x10000
	// Bit MASKP16.
	GPIO_PORT_MASK_MASKP16 = 0x10000
	// Position of MASKP17 field.
	GPIO_PORT_MASK_MASKP17_Pos = 0x11
	// Bit mask of MASKP17 field.
	GPIO_PORT_MASK_MASKP17_Msk = 0x20000
	// Bit MASKP17.
	GPIO_PORT_MASK_MASKP17 = 0x20000
	// Position of MASKP18 field.
	GPIO_PORT_MASK_MASKP18_Pos = 0x12
	// Bit mask of MASKP18 field.
	GPIO_PORT_MASK_MASKP18_Msk = 0x40000
	// Bit MASKP18.
	GPIO_PORT_MASK_MASKP18 = 0x40000
	// Position of MASKP19 field.
	GPIO_PORT_MASK_MASKP19_Pos = 0x13
	// Bit mask of MASKP19 field.
	GPIO_PORT_MASK_MASKP19_Msk = 0x80000
	// Bit MASKP19.
	GPIO_PORT_MASK_MASKP19 = 0x80000
	// Position of MASKP20 field.
	GPIO_PORT_MASK_MASKP20_Pos = 0x14
	// Bit mask of MASKP20 field.
	GPIO_PORT_MASK_MASKP20_Msk = 0x100000
	// Bit MASKP20.
	GPIO_PORT_MASK_MASKP20 = 0x100000
	// Position of MASKP21 field.
	GPIO_PORT_MASK_MASKP21_Pos = 0x15
	// Bit mask of MASKP21 field.
	GPIO_PORT_MASK_MASKP21_Msk = 0x200000
	// Bit MASKP21.
	GPIO_PORT_MASK_MASKP21 = 0x200000
	// Position of MASKP22 field.
	GPIO_PORT_MASK_MASKP22_Pos = 0x16
	// Bit mask of MASKP22 field.
	GPIO_PORT_MASK_MASKP22_Msk = 0x400000
	// Bit MASKP22.
	GPIO_PORT_MASK_MASKP22 = 0x400000
	// Position of MASKP23 field.
	GPIO_PORT_MASK_MASKP23_Pos = 0x17
	// Bit mask of MASKP23 field.
	GPIO_PORT_MASK_MASKP23_Msk = 0x800000
	// Bit MASKP23.
	GPIO_PORT_MASK_MASKP23 = 0x800000
	// Position of MASKP24 field.
	GPIO_PORT_MASK_MASKP24_Pos = 0x18
	// Bit mask of MASKP24 field.
	GPIO_PORT_MASK_MASKP24_Msk = 0x1000000
	// Bit MASKP24.
	GPIO_PORT_MASK_MASKP24 = 0x1000000
	// Position of MASKP25 field.
	GPIO_PORT_MASK_MASKP25_Pos = 0x19
	// Bit mask of MASKP25 field.
	GPIO_PORT_MASK_MASKP25_Msk = 0x2000000
	// Bit MASKP25.
	GPIO_PORT_MASK_MASKP25 = 0x2000000
	// Position of MASKP26 field.
	GPIO_PORT_MASK_MASKP26_Pos = 0x1a
	// Bit mask of MASKP26 field.
	GPIO_PORT_MASK_MASKP26_Msk = 0x4000000
	// Bit MASKP26.
	GPIO_PORT_MASK_MASKP26 = 0x4000000
	// Position of MASKP27 field.
	GPIO_PORT_MASK_MASKP27_Pos = 0x1b
	// Bit mask of MASKP27 field.
	GPIO_PORT_MASK_MASKP27_Msk = 0x8000000
	// Bit MASKP27.
	GPIO_PORT_MASK_MASKP27 = 0x8000000
	// Position of MASKP28 field.
	GPIO_PORT_MASK_MASKP28_Pos = 0x1c
	// Bit mask of MASKP28 field.
	GPIO_PORT_MASK_MASKP28_Msk = 0x10000000
	// Bit MASKP28.
	GPIO_PORT_MASK_MASKP28 = 0x10000000
	// Position of MASKP29 field.
	GPIO_PORT_MASK_MASKP29_Pos = 0x1d
	// Bit mask of MASKP29 field.
	GPIO_PORT_MASK_MASKP29_Msk = 0x20000000
	// Bit MASKP29.
	GPIO_PORT_MASK_MASKP29 = 0x20000000
	// Position of MASKP30 field.
	GPIO_PORT_MASK_MASKP30_Pos = 0x1e
	// Bit mask of MASKP30 field.
	GPIO_PORT_MASK_MASKP30_Msk = 0x40000000
	// Bit MASKP30.
	GPIO_PORT_MASK_MASKP30 = 0x40000000
	// Position of MASKP31 field.
	GPIO_PORT_MASK_MASKP31_Pos = 0x1f
	// Bit mask of MASKP31 field.
	GPIO_PORT_MASK_MASKP31_Msk = 0x80000000
	// Bit MASKP31.
	GPIO_PORT_MASK_MASKP31 = 0x80000000

	// PIN0: Port pin register port m
	// Position of PORT0 field.
	GPIO_PORT_PIN_PORT0_Pos = 0x0
	// Bit mask of PORT0 field.
	GPIO_PORT_PIN_PORT0_Msk = 0x1
	// Bit PORT0.
	GPIO_PORT_PIN_PORT0 = 0x1
	// Position of PORT1 field.
	GPIO_PORT_PIN_PORT1_Pos = 0x1
	// Bit mask of PORT1 field.
	GPIO_PORT_PIN_PORT1_Msk = 0x2
	// Bit PORT1.
	GPIO_PORT_PIN_PORT1 = 0x2
	// Position of PORT2 field.
	GPIO_PORT_PIN_PORT2_Pos = 0x2
	// Bit mask of PORT2 field.
	GPIO_PORT_PIN_PORT2_Msk = 0x4
	// Bit PORT2.
	GPIO_PORT_PIN_PORT2 = 0x4
	// Position of PORT3 field.
	GPIO_PORT_PIN_PORT3_Pos = 0x3
	// Bit mask of PORT3 field.
	GPIO_PORT_PIN_PORT3_Msk = 0x8
	// Bit PORT3.
	GPIO_PORT_PIN_PORT3 = 0x8
	// Position of PORT4 field.
	GPIO_PORT_PIN_PORT4_Pos = 0x4
	// Bit mask of PORT4 field.
	GPIO_PORT_PIN_PORT4_Msk = 0x10
	// Bit PORT4.
	GPIO_PORT_PIN_PORT4 = 0x10
	// Position of PORT5 field.
	GPIO_PORT_PIN_PORT5_Pos = 0x5
	// Bit mask of PORT5 field.
	GPIO_PORT_PIN_PORT5_Msk = 0x20
	// Bit PORT5.
	GPIO_PORT_PIN_PORT5 = 0x20
	// Position of PORT6 field.
	GPIO_PORT_PIN_PORT6_Pos = 0x6
	// Bit mask of PORT6 field.
	GPIO_PORT_PIN_PORT6_Msk = 0x40
	// Bit PORT6.
	GPIO_PORT_PIN_PORT6 = 0x40
	// Position of PORT7 field.
	GPIO_PORT_PIN_PORT7_Pos = 0x7
	// Bit mask of PORT7 field.
	GPIO_PORT_PIN_PORT7_Msk = 0x80
	// Bit PORT7.
	GPIO_PORT_PIN_PORT7 = 0x80
	// Position of PORT8 field.
	GPIO_PORT_PIN_PORT8_Pos = 0x8
	// Bit mask of PORT8 field.
	GPIO_PORT_PIN_PORT8_Msk = 0x100
	// Bit PORT8.
	GPIO_PORT_PIN_PORT8 = 0x100
	// Position of PORT9 field.
	GPIO_PORT_PIN_PORT9_Pos = 0x9
	// Bit mask of PORT9 field.
	GPIO_PORT_PIN_PORT9_Msk = 0x200
	// Bit PORT9.
	GPIO_PORT_PIN_PORT9 = 0x200
	// Position of PORT10 field.
	GPIO_PORT_PIN_PORT10_Pos = 0xa
	// Bit mask of PORT10 field.
	GPIO_PORT_PIN_PORT10_Msk = 0x400
	// Bit PORT10.
	GPIO_PORT_PIN_PORT10 = 0x400
	// Position of PORT11 field.
	GPIO_PORT_PIN_PORT11_Pos = 0xb
	// Bit mask of PORT11 field.
	GPIO_PORT_PIN_PORT11_Msk = 0x800
	// Bit PORT11.
	GPIO_PORT_PIN_PORT11 = 0x800
	// Position of PORT12 field.
	GPIO_PORT_PIN_PORT12_Pos = 0xc
	// Bit mask of PORT12 field.
	GPIO_PORT_PIN_PORT12_Msk = 0x1000
	// Bit PORT12.
	GPIO_PORT_PIN_PORT12 = 0x1000
	// Position of PORT13 field.
	GPIO_PORT_PIN_PORT13_Pos = 0xd
	// Bit mask of PORT13 field.
	GPIO_PORT_PIN_PORT13_Msk = 0x2000
	// Bit PORT13.
	GPIO_PORT_PIN_PORT13 = 0x2000
	// Position of PORT14 field.
	GPIO_PORT_PIN_PORT14_Pos = 0xe
	// Bit mask of PORT14 field.
	GPIO_PORT_PIN_PORT14_Msk = 0x4000
	// Bit PORT14.
	GPIO_PORT_PIN_PORT14 = 0x4000
	// Position of PORT15 field.
	GPIO_PORT_PIN_PORT15_Pos = 0xf
	// Bit mask of PORT15 field.
	GPIO_PORT_PIN_PORT15_Msk = 0x8000
	// Bit PORT15.
	GPIO_PORT_PIN_PORT15 = 0x8000
	// Position of PORT16 field.
	GPIO_PORT_PIN_PORT16_Pos = 0x10
	// Bit mask of PORT16 field.
	GPIO_PORT_PIN_PORT16_Msk = 0x10000
	// Bit PORT16.
	GPIO_PORT_PIN_PORT16 = 0x10000
	// Position of PORT17 field.
	GPIO_PORT_PIN_PORT17_Pos = 0x11
	// Bit mask of PORT17 field.
	GPIO_PORT_PIN_PORT17_Msk = 0x20000
	// Bit PORT17.
	GPIO_PORT_PIN_PORT17 = 0x20000
	// Position of PORT18 field.
	GPIO_PORT_PIN_PORT18_Pos = 0x12
	// Bit mask of PORT18 field.
	GPIO_PORT_PIN_PORT18_Msk = 0x40000
	// Bit PORT18.
	GPIO_PORT_PIN_PORT18 = 0x40000
	// Position of PORT19 field.
	GPIO_PORT_PIN_PORT19_Pos = 0x13
	// Bit mask of PORT19 field.
	GPIO_PORT_PIN_PORT19_Msk = 0x80000
	// Bit PORT19.
	GPIO_PORT_PIN_PORT19 = 0x80000
	// Position of PORT20 field.
	GPIO_PORT_PIN_PORT20_Pos = 0x14
	// Bit mask of PORT20 field.
	GPIO_PORT_PIN_PORT20_Msk = 0x100000
	// Bit PORT20.
	GPIO_PORT_PIN_PORT20 = 0x100000
	// Position of PORT21 field.
	GPIO_PORT_PIN_PORT21_Pos = 0x15
	// Bit mask of PORT21 field.
	GPIO_PORT_PIN_PORT21_Msk = 0x200000
	// Bit PORT21.
	GPIO_PORT_PIN_PORT21 = 0x200000
	// Position of PORT22 field.
	GPIO_PORT_PIN_PORT22_Pos = 0x16
	// Bit mask of PORT22 field.
	GPIO_PORT_PIN_PORT22_Msk = 0x400000
	// Bit PORT22.
	GPIO_PORT_PIN_PORT22 = 0x400000
	// Position of PORT23 field.
	GPIO_PORT_PIN_PORT23_Pos = 0x17
	// Bit mask of PORT23 field.
	GPIO_PORT_PIN_PORT23_Msk = 0x800000
	// Bit PORT23.
	GPIO_PORT_PIN_PORT23 = 0x800000
	// Position of PORT24 field.
	GPIO_PORT_PIN_PORT24_Pos = 0x18
	// Bit mask of PORT24 field.
	GPIO_PORT_PIN_PORT24_Msk = 0x1000000
	// Bit PORT24.
	GPIO_PORT_PIN_PORT24 = 0x1000000
	// Position of PORT25 field.
	GPIO_PORT_PIN_PORT25_Pos = 0x19
	// Bit mask of PORT25 field.
	GPIO_PORT_PIN_PORT25_Msk = 0x2000000
	// Bit PORT25.
	GPIO_PORT_PIN_PORT25 = 0x2000000
	// Position of PORT26 field.
	GPIO_PORT_PIN_PORT26_Pos = 0x1a
	// Bit mask of PORT26 field.
	GPIO_PORT_PIN_PORT26_Msk = 0x4000000
	// Bit PORT26.
	GPIO_PORT_PIN_PORT26 = 0x4000000
	// Position of PORT27 field.
	GPIO_PORT_PIN_PORT27_Pos = 0x1b
	// Bit mask of PORT27 field.
	GPIO_PORT_PIN_PORT27_Msk = 0x8000000
	// Bit PORT27.
	GPIO_PORT_PIN_PORT27 = 0x8000000
	// Position of PORT28 field.
	GPIO_PORT_PIN_PORT28_Pos = 0x1c
	// Bit mask of PORT28 field.
	GPIO_PORT_PIN_PORT28_Msk = 0x10000000
	// Bit PORT28.
	GPIO_PORT_PIN_PORT28 = 0x10000000
	// Position of PORT29 field.
	GPIO_PORT_PIN_PORT29_Pos = 0x1d
	// Bit mask of PORT29 field.
	GPIO_PORT_PIN_PORT29_Msk = 0x20000000
	// Bit PORT29.
	GPIO_PORT_PIN_PORT29 = 0x20000000
	// Position of PORT30 field.
	GPIO_PORT_PIN_PORT30_Pos = 0x1e
	// Bit mask of PORT30 field.
	GPIO_PORT_PIN_PORT30_Msk = 0x40000000
	// Bit PORT30.
	GPIO_PORT_PIN_PORT30 = 0x40000000
	// Position of PORT31 field.
	GPIO_PORT_PIN_PORT31_Pos = 0x1f
	// Bit mask of PORT31 field.
	GPIO_PORT_PIN_PORT31_Msk = 0x80000000
	// Bit PORT31.
	GPIO_PORT_PIN_PORT31 = 0x80000000

	// MPIN0: Masked port register port m
	// Position of MPORTP0 field.
	GPIO_PORT_MPIN_MPORTP0_Pos = 0x0
	// Bit mask of MPORTP0 field.
	GPIO_PORT_MPIN_MPORTP0_Msk = 0x1
	// Bit MPORTP0.
	GPIO_PORT_MPIN_MPORTP0 = 0x1
	// Position of MPORTP1 field.
	GPIO_PORT_MPIN_MPORTP1_Pos = 0x1
	// Bit mask of MPORTP1 field.
	GPIO_PORT_MPIN_MPORTP1_Msk = 0x2
	// Bit MPORTP1.
	GPIO_PORT_MPIN_MPORTP1 = 0x2
	// Position of MPORTP2 field.
	GPIO_PORT_MPIN_MPORTP2_Pos = 0x2
	// Bit mask of MPORTP2 field.
	GPIO_PORT_MPIN_MPORTP2_Msk = 0x4
	// Bit MPORTP2.
	GPIO_PORT_MPIN_MPORTP2 = 0x4
	// Position of MPORTP3 field.
	GPIO_PORT_MPIN_MPORTP3_Pos = 0x3
	// Bit mask of MPORTP3 field.
	GPIO_PORT_MPIN_MPORTP3_Msk = 0x8
	// Bit MPORTP3.
	GPIO_PORT_MPIN_MPORTP3 = 0x8
	// Position of MPORTP4 field.
	GPIO_PORT_MPIN_MPORTP4_Pos = 0x4
	// Bit mask of MPORTP4 field.
	GPIO_PORT_MPIN_MPORTP4_Msk = 0x10
	// Bit MPORTP4.
	GPIO_PORT_MPIN_MPORTP4 = 0x10
	// Position of MPORTP5 field.
	GPIO_PORT_MPIN_MPORTP5_Pos = 0x5
	// Bit mask of MPORTP5 field.
	GPIO_PORT_MPIN_MPORTP5_Msk = 0x20
	// Bit MPORTP5.
	GPIO_PORT_MPIN_MPORTP5 = 0x20
	// Position of MPORTP6 field.
	GPIO_PORT_MPIN_MPORTP6_Pos = 0x6
	// Bit mask of MPORTP6 field.
	GPIO_PORT_MPIN_MPORTP6_Msk = 0x40
	// Bit MPORTP6.
	GPIO_PORT_MPIN_MPORTP6 = 0x40
	// Position of MPORTP7 field.
	GPIO_PORT_MPIN_MPORTP7_Pos = 0x7
	// Bit mask of MPORTP7 field.
	GPIO_PORT_MPIN_MPORTP7_Msk = 0x80
	// Bit MPORTP7.
	GPIO_PORT_MPIN_MPORTP7 = 0x80
	// Position of MPORTP8 field.
	GPIO_PORT_MPIN_MPORTP8_Pos = 0x8
	// Bit mask of MPORTP8 field.
	GPIO_PORT_MPIN_MPORTP8_Msk = 0x100
	// Bit MPORTP8.
	GPIO_PORT_MPIN_MPORTP8 = 0x100
	// Position of MPORTP9 field.
	GPIO_PORT_MPIN_MPORTP9_Pos = 0x9
	// Bit mask of MPORTP9 field.
	GPIO_PORT_MPIN_MPORTP9_Msk = 0x200
	// Bit MPORTP9.
	GPIO_PORT_MPIN_MPORTP9 = 0x200
	// Position of MPORTP10 field.
	GPIO_PORT_MPIN_MPORTP10_Pos = 0xa
	// Bit mask of MPORTP10 field.
	GPIO_PORT_MPIN_MPORTP10_Msk = 0x400
	// Bit MPORTP10.
	GPIO_PORT_MPIN_MPORTP10 = 0x400
	// Position of MPORTP11 field.
	GPIO_PORT_MPIN_MPORTP11_Pos = 0xb
	// Bit mask of MPORTP11 field.
	GPIO_PORT_MPIN_MPORTP11_Msk = 0x800
	// Bit MPORTP11.
	GPIO_PORT_MPIN_MPORTP11 = 0x800
	// Position of MPORTP12 field.
	GPIO_PORT_MPIN_MPORTP12_Pos = 0xc
	// Bit mask of MPORTP12 field.
	GPIO_PORT_MPIN_MPORTP12_Msk = 0x1000
	// Bit MPORTP12.
	GPIO_PORT_MPIN_MPORTP12 = 0x1000
	// Position of MPORTP13 field.
	GPIO_PORT_MPIN_MPORTP13_Pos = 0xd
	// Bit mask of MPORTP13 field.
	GPIO_PORT_MPIN_MPORTP13_Msk = 0x2000
	// Bit MPORTP13.
	GPIO_PORT_MPIN_MPORTP13 = 0x2000
	// Position of MPORTP14 field.
	GPIO_PORT_MPIN_MPORTP14_Pos = 0xe
	// Bit mask of MPORTP14 field.
	GPIO_PORT_MPIN_MPORTP14_Msk = 0x4000
	// Bit MPORTP14.
	GPIO_PORT_MPIN_MPORTP14 = 0x4000
	// Position of MPORTP15 field.
	GPIO_PORT_MPIN_MPORTP15_Pos = 0xf
	// Bit mask of MPORTP15 field.
	GPIO_PORT_MPIN_MPORTP15_Msk = 0x8000
	// Bit MPORTP15.
	GPIO_PORT_MPIN_MPORTP15 = 0x8000
	// Position of MPORTP16 field.
	GPIO_PORT_MPIN_MPORTP16_Pos = 0x10
	// Bit mask of MPORTP16 field.
	GPIO_PORT_MPIN_MPORTP16_Msk = 0x10000
	// Bit MPORTP16.
	GPIO_PORT_MPIN_MPORTP16 = 0x10000
	// Position of MPORTP17 field.
	GPIO_PORT_MPIN_MPORTP17_Pos = 0x11
	// Bit mask of MPORTP17 field.
	GPIO_PORT_MPIN_MPORTP17_Msk = 0x20000
	// Bit MPORTP17.
	GPIO_PORT_MPIN_MPORTP17 = 0x20000
	// Position of MPORTP18 field.
	GPIO_PORT_MPIN_MPORTP18_Pos = 0x12
	// Bit mask of MPORTP18 field.
	GPIO_PORT_MPIN_MPORTP18_Msk = 0x40000
	// Bit MPORTP18.
	GPIO_PORT_MPIN_MPORTP18 = 0x40000
	// Position of MPORTP19 field.
	GPIO_PORT_MPIN_MPORTP19_Pos = 0x13
	// Bit mask of MPORTP19 field.
	GPIO_PORT_MPIN_MPORTP19_Msk = 0x80000
	// Bit MPORTP19.
	GPIO_PORT_MPIN_MPORTP19 = 0x80000
	// Position of MPORTP20 field.
	GPIO_PORT_MPIN_MPORTP20_Pos = 0x14
	// Bit mask of MPORTP20 field.
	GPIO_PORT_MPIN_MPORTP20_Msk = 0x100000
	// Bit MPORTP20.
	GPIO_PORT_MPIN_MPORTP20 = 0x100000
	// Position of MPORTP21 field.
	GPIO_PORT_MPIN_MPORTP21_Pos = 0x15
	// Bit mask of MPORTP21 field.
	GPIO_PORT_MPIN_MPORTP21_Msk = 0x200000
	// Bit MPORTP21.
	GPIO_PORT_MPIN_MPORTP21 = 0x200000
	// Position of MPORTP22 field.
	GPIO_PORT_MPIN_MPORTP22_Pos = 0x16
	// Bit mask of MPORTP22 field.
	GPIO_PORT_MPIN_MPORTP22_Msk = 0x400000
	// Bit MPORTP22.
	GPIO_PORT_MPIN_MPORTP22 = 0x400000
	// Position of MPORTP23 field.
	GPIO_PORT_MPIN_MPORTP23_Pos = 0x17
	// Bit mask of MPORTP23 field.
	GPIO_PORT_MPIN_MPORTP23_Msk = 0x800000
	// Bit MPORTP23.
	GPIO_PORT_MPIN_MPORTP23 = 0x800000
	// Position of MPORTP24 field.
	GPIO_PORT_MPIN_MPORTP24_Pos = 0x18
	// Bit mask of MPORTP24 field.
	GPIO_PORT_MPIN_MPORTP24_Msk = 0x1000000
	// Bit MPORTP24.
	GPIO_PORT_MPIN_MPORTP24 = 0x1000000
	// Position of MPORTP25 field.
	GPIO_PORT_MPIN_MPORTP25_Pos = 0x19
	// Bit mask of MPORTP25 field.
	GPIO_PORT_MPIN_MPORTP25_Msk = 0x2000000
	// Bit MPORTP25.
	GPIO_PORT_MPIN_MPORTP25 = 0x2000000
	// Position of MPORTP26 field.
	GPIO_PORT_MPIN_MPORTP26_Pos = 0x1a
	// Bit mask of MPORTP26 field.
	GPIO_PORT_MPIN_MPORTP26_Msk = 0x4000000
	// Bit MPORTP26.
	GPIO_PORT_MPIN_MPORTP26 = 0x4000000
	// Position of MPORTP27 field.
	GPIO_PORT_MPIN_MPORTP27_Pos = 0x1b
	// Bit mask of MPORTP27 field.
	GPIO_PORT_MPIN_MPORTP27_Msk = 0x8000000
	// Bit MPORTP27.
	GPIO_PORT_MPIN_MPORTP27 = 0x8000000
	// Position of MPORTP28 field.
	GPIO_PORT_MPIN_MPORTP28_Pos = 0x1c
	// Bit mask of MPORTP28 field.
	GPIO_PORT_MPIN_MPORTP28_Msk = 0x10000000
	// Bit MPORTP28.
	GPIO_PORT_MPIN_MPORTP28 = 0x10000000
	// Position of MPORTP29 field.
	GPIO_PORT_MPIN_MPORTP29_Pos = 0x1d
	// Bit mask of MPORTP29 field.
	GPIO_PORT_MPIN_MPORTP29_Msk = 0x20000000
	// Bit MPORTP29.
	GPIO_PORT_MPIN_MPORTP29 = 0x20000000
	// Position of MPORTP30 field.
	GPIO_PORT_MPIN_MPORTP30_Pos = 0x1e
	// Bit mask of MPORTP30 field.
	GPIO_PORT_MPIN_MPORTP30_Msk = 0x40000000
	// Bit MPORTP30.
	GPIO_PORT_MPIN_MPORTP30 = 0x40000000
	// Position of MPORTP31 field.
	GPIO_PORT_MPIN_MPORTP31_Pos = 0x1f
	// Bit mask of MPORTP31 field.
	GPIO_PORT_MPIN_MPORTP31_Msk = 0x80000000
	// Bit MPORTP31.
	GPIO_PORT_MPIN_MPORTP31 = 0x80000000

	// SET0: Write: Set register for port m Read: output bits for port m
	// Position of SETP0 field.
	GPIO_PORT_SET_SETP0_Pos = 0x0
	// Bit mask of SETP0 field.
	GPIO_PORT_SET_SETP0_Msk = 0x1
	// Bit SETP0.
	GPIO_PORT_SET_SETP0 = 0x1
	// Position of SETP1 field.
	GPIO_PORT_SET_SETP1_Pos = 0x1
	// Bit mask of SETP1 field.
	GPIO_PORT_SET_SETP1_Msk = 0x2
	// Bit SETP1.
	GPIO_PORT_SET_SETP1 = 0x2
	// Position of SETP2 field.
	GPIO_PORT_SET_SETP2_Pos = 0x2
	// Bit mask of SETP2 field.
	GPIO_PORT_SET_SETP2_Msk = 0x4
	// Bit SETP2.
	GPIO_PORT_SET_SETP2 = 0x4
	// Position of SETP3 field.
	GPIO_PORT_SET_SETP3_Pos = 0x3
	// Bit mask of SETP3 field.
	GPIO_PORT_SET_SETP3_Msk = 0x8
	// Bit SETP3.
	GPIO_PORT_SET_SETP3 = 0x8
	// Position of SETP4 field.
	GPIO_PORT_SET_SETP4_Pos = 0x4
	// Bit mask of SETP4 field.
	GPIO_PORT_SET_SETP4_Msk = 0x10
	// Bit SETP4.
	GPIO_PORT_SET_SETP4 = 0x10
	// Position of SETP5 field.
	GPIO_PORT_SET_SETP5_Pos = 0x5
	// Bit mask of SETP5 field.
	GPIO_PORT_SET_SETP5_Msk = 0x20
	// Bit SETP5.
	GPIO_PORT_SET_SETP5 = 0x20
	// Position of SETP6 field.
	GPIO_PORT_SET_SETP6_Pos = 0x6
	// Bit mask of SETP6 field.
	GPIO_PORT_SET_SETP6_Msk = 0x40
	// Bit SETP6.
	GPIO_PORT_SET_SETP6 = 0x40
	// Position of SETP7 field.
	GPIO_PORT_SET_SETP7_Pos = 0x7
	// Bit mask of SETP7 field.
	GPIO_PORT_SET_SETP7_Msk = 0x80
	// Bit SETP7.
	GPIO_PORT_SET_SETP7 = 0x80
	// Position of SETP8 field.
	GPIO_PORT_SET_SETP8_Pos = 0x8
	// Bit mask of SETP8 field.
	GPIO_PORT_SET_SETP8_Msk = 0x100
	// Bit SETP8.
	GPIO_PORT_SET_SETP8 = 0x100
	// Position of SETP9 field.
	GPIO_PORT_SET_SETP9_Pos = 0x9
	// Bit mask of SETP9 field.
	GPIO_PORT_SET_SETP9_Msk = 0x200
	// Bit SETP9.
	GPIO_PORT_SET_SETP9 = 0x200
	// Position of SETP10 field.
	GPIO_PORT_SET_SETP10_Pos = 0xa
	// Bit mask of SETP10 field.
	GPIO_PORT_SET_SETP10_Msk = 0x400
	// Bit SETP10.
	GPIO_PORT_SET_SETP10 = 0x400
	// Position of SETP11 field.
	GPIO_PORT_SET_SETP11_Pos = 0xb
	// Bit mask of SETP11 field.
	GPIO_PORT_SET_SETP11_Msk = 0x800
	// Bit SETP11.
	GPIO_PORT_SET_SETP11 = 0x800
	// Position of SETP12 field.
	GPIO_PORT_SET_SETP12_Pos = 0xc
	// Bit mask of SETP12 field.
	GPIO_PORT_SET_SETP12_Msk = 0x1000
	// Bit SETP12.
	GPIO_PORT_SET_SETP12 = 0x1000
	// Position of SETP13 field.
	GPIO_PORT_SET_SETP13_Pos = 0xd
	// Bit mask of SETP13 field.
	GPIO_PORT_SET_SETP13_Msk = 0x2000
	// Bit SETP13.
	GPIO_PORT_SET_SETP13 = 0x2000
	// Position of SETP14 field.
	GPIO_PORT_SET_SETP14_Pos = 0xe
	// Bit mask of SETP14 field.
	GPIO_PORT_SET_SETP14_Msk = 0x4000
	// Bit SETP14.
	GPIO_PORT_SET_SETP14 = 0x4000
	// Position of SETP15 field.
	GPIO_PORT_SET_SETP15_Pos = 0xf
	// Bit mask of SETP15 field.
	GPIO_PORT_SET_SETP15_Msk = 0x8000
	// Bit SETP15.
	GPIO_PORT_SET_SETP15 = 0x8000
	// Position of SETP16 field.
	GPIO_PORT_SET_SETP16_Pos = 0x10
	// Bit mask of SETP16 field.
	GPIO_PORT_SET_SETP16_Msk = 0x10000
	// Bit SETP16.
	GPIO_PORT_SET_SETP16 = 0x10000
	// Position of SETP17 field.
	GPIO_PORT_SET_SETP17_Pos = 0x11
	// Bit mask of SETP17 field.
	GPIO_PORT_SET_SETP17_Msk = 0x20000
	// Bit SETP17.
	GPIO_PORT_SET_SETP17 = 0x20000
	// Position of SETP18 field.
	GPIO_PORT_SET_SETP18_Pos = 0x12
	// Bit mask of SETP18 field.
	GPIO_PORT_SET_SETP18_Msk = 0x40000
	// Bit SETP18.
	GPIO_PORT_SET_SETP18 = 0x40000
	// Position of SETP19 field.
	GPIO_PORT_SET_SETP19_Pos = 0x13
	// Bit mask of SETP19 field.
	GPIO_PORT_SET_SETP19_Msk = 0x80000
	// Bit SETP19.
	GPIO_PORT_SET_SETP19 = 0x80000
	// Position of SETP20 field.
	GPIO_PORT_SET_SETP20_Pos = 0x14
	// Bit mask of SETP20 field.
	GPIO_PORT_SET_SETP20_Msk = 0x100000
	// Bit SETP20.
	GPIO_PORT_SET_SETP20 = 0x100000
	// Position of SETP21 field.
	GPIO_PORT_SET_SETP21_Pos = 0x15
	// Bit mask of SETP21 field.
	GPIO_PORT_SET_SETP21_Msk = 0x200000
	// Bit SETP21.
	GPIO_PORT_SET_SETP21 = 0x200000
	// Position of SETP22 field.
	GPIO_PORT_SET_SETP22_Pos = 0x16
	// Bit mask of SETP22 field.
	GPIO_PORT_SET_SETP22_Msk = 0x400000
	// Bit SETP22.
	GPIO_PORT_SET_SETP22 = 0x400000
	// Position of SETP23 field.
	GPIO_PORT_SET_SETP23_Pos = 0x17
	// Bit mask of SETP23 field.
	GPIO_PORT_SET_SETP23_Msk = 0x800000
	// Bit SETP23.
	GPIO_PORT_SET_SETP23 = 0x800000
	// Position of SETP24 field.
	GPIO_PORT_SET_SETP24_Pos = 0x18
	// Bit mask of SETP24 field.
	GPIO_PORT_SET_SETP24_Msk = 0x1000000
	// Bit SETP24.
	GPIO_PORT_SET_SETP24 = 0x1000000
	// Position of SETP25 field.
	GPIO_PORT_SET_SETP25_Pos = 0x19
	// Bit mask of SETP25 field.
	GPIO_PORT_SET_SETP25_Msk = 0x2000000
	// Bit SETP25.
	GPIO_PORT_SET_SETP25 = 0x2000000
	// Position of SETP26 field.
	GPIO_PORT_SET_SETP26_Pos = 0x1a
	// Bit mask of SETP26 field.
	GPIO_PORT_SET_SETP26_Msk = 0x4000000
	// Bit SETP26.
	GPIO_PORT_SET_SETP26 = 0x4000000
	// Position of SETP27 field.
	GPIO_PORT_SET_SETP27_Pos = 0x1b
	// Bit mask of SETP27 field.
	GPIO_PORT_SET_SETP27_Msk = 0x8000000
	// Bit SETP27.
	GPIO_PORT_SET_SETP27 = 0x8000000
	// Position of SETP28 field.
	GPIO_PORT_SET_SETP28_Pos = 0x1c
	// Bit mask of SETP28 field.
	GPIO_PORT_SET_SETP28_Msk = 0x10000000
	// Bit SETP28.
	GPIO_PORT_SET_SETP28 = 0x10000000
	// Position of SETP29 field.
	GPIO_PORT_SET_SETP29_Pos = 0x1d
	// Bit mask of SETP29 field.
	GPIO_PORT_SET_SETP29_Msk = 0x20000000
	// Bit SETP29.
	GPIO_PORT_SET_SETP29 = 0x20000000
	// Position of SETP30 field.
	GPIO_PORT_SET_SETP30_Pos = 0x1e
	// Bit mask of SETP30 field.
	GPIO_PORT_SET_SETP30_Msk = 0x40000000
	// Bit SETP30.
	GPIO_PORT_SET_SETP30 = 0x40000000
	// Position of SETP31 field.
	GPIO_PORT_SET_SETP31_Pos = 0x1f
	// Bit mask of SETP31 field.
	GPIO_PORT_SET_SETP31_Msk = 0x80000000
	// Bit SETP31.
	GPIO_PORT_SET_SETP31 = 0x80000000

	// CLR0: Clear port m
	// Position of CLRP00 field.
	GPIO_PORT_CLR_CLRP00_Pos = 0x0
	// Bit mask of CLRP00 field.
	GPIO_PORT_CLR_CLRP00_Msk = 0x1
	// Bit CLRP00.
	GPIO_PORT_CLR_CLRP00 = 0x1
	// Position of CLRP01 field.
	GPIO_PORT_CLR_CLRP01_Pos = 0x1
	// Bit mask of CLRP01 field.
	GPIO_PORT_CLR_CLRP01_Msk = 0x2
	// Bit CLRP01.
	GPIO_PORT_CLR_CLRP01 = 0x2
	// Position of CLRP02 field.
	GPIO_PORT_CLR_CLRP02_Pos = 0x2
	// Bit mask of CLRP02 field.
	GPIO_PORT_CLR_CLRP02_Msk = 0x4
	// Bit CLRP02.
	GPIO_PORT_CLR_CLRP02 = 0x4
	// Position of CLRP03 field.
	GPIO_PORT_CLR_CLRP03_Pos = 0x3
	// Bit mask of CLRP03 field.
	GPIO_PORT_CLR_CLRP03_Msk = 0x8
	// Bit CLRP03.
	GPIO_PORT_CLR_CLRP03 = 0x8
	// Position of CLRP04 field.
	GPIO_PORT_CLR_CLRP04_Pos = 0x4
	// Bit mask of CLRP04 field.
	GPIO_PORT_CLR_CLRP04_Msk = 0x10
	// Bit CLRP04.
	GPIO_PORT_CLR_CLRP04 = 0x10
	// Position of CLRP05 field.
	GPIO_PORT_CLR_CLRP05_Pos = 0x5
	// Bit mask of CLRP05 field.
	GPIO_PORT_CLR_CLRP05_Msk = 0x20
	// Bit CLRP05.
	GPIO_PORT_CLR_CLRP05 = 0x20
	// Position of CLRP06 field.
	GPIO_PORT_CLR_CLRP06_Pos = 0x6
	// Bit mask of CLRP06 field.
	GPIO_PORT_CLR_CLRP06_Msk = 0x40
	// Bit CLRP06.
	GPIO_PORT_CLR_CLRP06 = 0x40
	// Position of CLRP07 field.
	GPIO_PORT_CLR_CLRP07_Pos = 0x7
	// Bit mask of CLRP07 field.
	GPIO_PORT_CLR_CLRP07_Msk = 0x80
	// Bit CLRP07.
	GPIO_PORT_CLR_CLRP07 = 0x80
	// Position of CLRP08 field.
	GPIO_PORT_CLR_CLRP08_Pos = 0x8
	// Bit mask of CLRP08 field.
	GPIO_PORT_CLR_CLRP08_Msk = 0x100
	// Bit CLRP08.
	GPIO_PORT_CLR_CLRP08 = 0x100
	// Position of CLRP09 field.
	GPIO_PORT_CLR_CLRP09_Pos = 0x9
	// Bit mask of CLRP09 field.
	GPIO_PORT_CLR_CLRP09_Msk = 0x200
	// Bit CLRP09.
	GPIO_PORT_CLR_CLRP09 = 0x200
	// Position of CLRP010 field.
	GPIO_PORT_CLR_CLRP010_Pos = 0xa
	// Bit mask of CLRP010 field.
	GPIO_PORT_CLR_CLRP010_Msk = 0x400
	// Bit CLRP010.
	GPIO_PORT_CLR_CLRP010 = 0x400
	// Position of CLRP011 field.
	GPIO_PORT_CLR_CLRP011_Pos = 0xb
	// Bit mask of CLRP011 field.
	GPIO_PORT_CLR_CLRP011_Msk = 0x800
	// Bit CLRP011.
	GPIO_PORT_CLR_CLRP011 = 0x800
	// Position of CLRP012 field.
	GPIO_PORT_CLR_CLRP012_Pos = 0xc
	// Bit mask of CLRP012 field.
	GPIO_PORT_CLR_CLRP012_Msk = 0x1000
	// Bit CLRP012.
	GPIO_PORT_CLR_CLRP012 = 0x1000
	// Position of CLRP013 field.
	GPIO_PORT_CLR_CLRP013_Pos = 0xd
	// Bit mask of CLRP013 field.
	GPIO_PORT_CLR_CLRP013_Msk = 0x2000
	// Bit CLRP013.
	GPIO_PORT_CLR_CLRP013 = 0x2000
	// Position of CLRP014 field.
	GPIO_PORT_CLR_CLRP014_Pos = 0xe
	// Bit mask of CLRP014 field.
	GPIO_PORT_CLR_CLRP014_Msk = 0x4000
	// Bit CLRP014.
	GPIO_PORT_CLR_CLRP014 = 0x4000
	// Position of CLRP015 field.
	GPIO_PORT_CLR_CLRP015_Pos = 0xf
	// Bit mask of CLRP015 field.
	GPIO_PORT_CLR_CLRP015_Msk = 0x8000
	// Bit CLRP015.
	GPIO_PORT_CLR_CLRP015 = 0x8000
	// Position of CLRP016 field.
	GPIO_PORT_CLR_CLRP016_Pos = 0x10
	// Bit mask of CLRP016 field.
	GPIO_PORT_CLR_CLRP016_Msk = 0x10000
	// Bit CLRP016.
	GPIO_PORT_CLR_CLRP016 = 0x10000
	// Position of CLRP017 field.
	GPIO_PORT_CLR_CLRP017_Pos = 0x11
	// Bit mask of CLRP017 field.
	GPIO_PORT_CLR_CLRP017_Msk = 0x20000
	// Bit CLRP017.
	GPIO_PORT_CLR_CLRP017 = 0x20000
	// Position of CLRP018 field.
	GPIO_PORT_CLR_CLRP018_Pos = 0x12
	// Bit mask of CLRP018 field.
	GPIO_PORT_CLR_CLRP018_Msk = 0x40000
	// Bit CLRP018.
	GPIO_PORT_CLR_CLRP018 = 0x40000
	// Position of CLRP019 field.
	GPIO_PORT_CLR_CLRP019_Pos = 0x13
	// Bit mask of CLRP019 field.
	GPIO_PORT_CLR_CLRP019_Msk = 0x80000
	// Bit CLRP019.
	GPIO_PORT_CLR_CLRP019 = 0x80000
	// Position of CLRP020 field.
	GPIO_PORT_CLR_CLRP020_Pos = 0x14
	// Bit mask of CLRP020 field.
	GPIO_PORT_CLR_CLRP020_Msk = 0x100000
	// Bit CLRP020.
	GPIO_PORT_CLR_CLRP020 = 0x100000
	// Position of CLRP021 field.
	GPIO_PORT_CLR_CLRP021_Pos = 0x15
	// Bit mask of CLRP021 field.
	GPIO_PORT_CLR_CLRP021_Msk = 0x200000
	// Bit CLRP021.
	GPIO_PORT_CLR_CLRP021 = 0x200000
	// Position of CLRP022 field.
	GPIO_PORT_CLR_CLRP022_Pos = 0x16
	// Bit mask of CLRP022 field.
	GPIO_PORT_CLR_CLRP022_Msk = 0x400000
	// Bit CLRP022.
	GPIO_PORT_CLR_CLRP022 = 0x400000
	// Position of CLRP023 field.
	GPIO_PORT_CLR_CLRP023_Pos = 0x17
	// Bit mask of CLRP023 field.
	GPIO_PORT_CLR_CLRP023_Msk = 0x800000
	// Bit CLRP023.
	GPIO_PORT_CLR_CLRP023 = 0x800000
	// Position of CLRP024 field.
	GPIO_PORT_CLR_CLRP024_Pos = 0x18
	// Bit mask of CLRP024 field.
	GPIO_PORT_CLR_CLRP024_Msk = 0x1000000
	// Bit CLRP024.
	GPIO_PORT_CLR_CLRP024 = 0x1000000
	// Position of CLRP025 field.
	GPIO_PORT_CLR_CLRP025_Pos = 0x19
	// Bit mask of CLRP025 field.
	GPIO_PORT_CLR_CLRP025_Msk = 0x2000000
	// Bit CLRP025.
	GPIO_PORT_CLR_CLRP025 = 0x2000000
	// Position of CLRP026 field.
	GPIO_PORT_CLR_CLRP026_Pos = 0x1a
	// Bit mask of CLRP026 field.
	GPIO_PORT_CLR_CLRP026_Msk = 0x4000000
	// Bit CLRP026.
	GPIO_PORT_CLR_CLRP026 = 0x4000000
	// Position of CLRP027 field.
	GPIO_PORT_CLR_CLRP027_Pos = 0x1b
	// Bit mask of CLRP027 field.
	GPIO_PORT_CLR_CLRP027_Msk = 0x8000000
	// Bit CLRP027.
	GPIO_PORT_CLR_CLRP027 = 0x8000000
	// Position of CLRP028 field.
	GPIO_PORT_CLR_CLRP028_Pos = 0x1c
	// Bit mask of CLRP028 field.
	GPIO_PORT_CLR_CLRP028_Msk = 0x10000000
	// Bit CLRP028.
	GPIO_PORT_CLR_CLRP028 = 0x10000000
	// Position of CLRP029 field.
	GPIO_PORT_CLR_CLRP029_Pos = 0x1d
	// Bit mask of CLRP029 field.
	GPIO_PORT_CLR_CLRP029_Msk = 0x20000000
	// Bit CLRP029.
	GPIO_PORT_CLR_CLRP029 = 0x20000000
	// Position of CLRP030 field.
	GPIO_PORT_CLR_CLRP030_Pos = 0x1e
	// Bit mask of CLRP030 field.
	GPIO_PORT_CLR_CLRP030_Msk = 0x40000000
	// Bit CLRP030.
	GPIO_PORT_CLR_CLRP030 = 0x40000000
	// Position of CLRP031 field.
	GPIO_PORT_CLR_CLRP031_Pos = 0x1f
	// Bit mask of CLRP031 field.
	GPIO_PORT_CLR_CLRP031_Msk = 0x80000000
	// Bit CLRP031.
	GPIO_PORT_CLR_CLRP031 = 0x80000000

	// NOT0: Toggle port m
	// Position of NOTP0 field.
	GPIO_PORT_NOT_NOTP0_Pos = 0x0
	// Bit mask of NOTP0 field.
	GPIO_PORT_NOT_NOTP0_Msk = 0x1
	// Bit NOTP0.
	GPIO_PORT_NOT_NOTP0 = 0x1
	// Position of NOTP1 field.
	GPIO_PORT_NOT_NOTP1_Pos = 0x1
	// Bit mask of NOTP1 field.
	GPIO_PORT_NOT_NOTP1_Msk = 0x2
	// Bit NOTP1.
	GPIO_PORT_NOT_NOTP1 = 0x2
	// Position of NOTP2 field.
	GPIO_PORT_NOT_NOTP2_Pos = 0x2
	// Bit mask of NOTP2 field.
	GPIO_PORT_NOT_NOTP2_Msk = 0x4
	// Bit NOTP2.
	GPIO_PORT_NOT_NOTP2 = 0x4
	// Position of NOTP3 field.
	GPIO_PORT_NOT_NOTP3_Pos = 0x3
	// Bit mask of NOTP3 field.
	GPIO_PORT_NOT_NOTP3_Msk = 0x8
	// Bit NOTP3.
	GPIO_PORT_NOT_NOTP3 = 0x8
	// Position of NOTP4 field.
	GPIO_PORT_NOT_NOTP4_Pos = 0x4
	// Bit mask of NOTP4 field.
	GPIO_PORT_NOT_NOTP4_Msk = 0x10
	// Bit NOTP4.
	GPIO_PORT_NOT_NOTP4 = 0x10
	// Position of NOTP5 field.
	GPIO_PORT_NOT_NOTP5_Pos = 0x5
	// Bit mask of NOTP5 field.
	GPIO_PORT_NOT_NOTP5_Msk = 0x20
	// Bit NOTP5.
	GPIO_PORT_NOT_NOTP5 = 0x20
	// Position of NOTP6 field.
	GPIO_PORT_NOT_NOTP6_Pos = 0x6
	// Bit mask of NOTP6 field.
	GPIO_PORT_NOT_NOTP6_Msk = 0x40
	// Bit NOTP6.
	GPIO_PORT_NOT_NOTP6 = 0x40
	// Position of NOTP7 field.
	GPIO_PORT_NOT_NOTP7_Pos = 0x7
	// Bit mask of NOTP7 field.
	GPIO_PORT_NOT_NOTP7_Msk = 0x80
	// Bit NOTP7.
	GPIO_PORT_NOT_NOTP7 = 0x80
	// Position of NOTP8 field.
	GPIO_PORT_NOT_NOTP8_Pos = 0x8
	// Bit mask of NOTP8 field.
	GPIO_PORT_NOT_NOTP8_Msk = 0x100
	// Bit NOTP8.
	GPIO_PORT_NOT_NOTP8 = 0x100
	// Position of NOTP9 field.
	GPIO_PORT_NOT_NOTP9_Pos = 0x9
	// Bit mask of NOTP9 field.
	GPIO_PORT_NOT_NOTP9_Msk = 0x200
	// Bit NOTP9.
	GPIO_PORT_NOT_NOTP9 = 0x200
	// Position of NOTP10 field.
	GPIO_PORT_NOT_NOTP10_Pos = 0xa
	// Bit mask of NOTP10 field.
	GPIO_PORT_NOT_NOTP10_Msk = 0x400
	// Bit NOTP10.
	GPIO_PORT_NOT_NOTP10 = 0x400
	// Position of NOTP11 field.
	GPIO_PORT_NOT_NOTP11_Pos = 0xb
	// Bit mask of NOTP11 field.
	GPIO_PORT_NOT_NOTP11_Msk = 0x800
	// Bit NOTP11.
	GPIO_PORT_NOT_NOTP11 = 0x800
	// Position of NOTP12 field.
	GPIO_PORT_NOT_NOTP12_Pos = 0xc
	// Bit mask of NOTP12 field.
	GPIO_PORT_NOT_NOTP12_Msk = 0x1000
	// Bit NOTP12.
	GPIO_PORT_NOT_NOTP12 = 0x1000
	// Position of NOTP13 field.
	GPIO_PORT_NOT_NOTP13_Pos = 0xd
	// Bit mask of NOTP13 field.
	GPIO_PORT_NOT_NOTP13_Msk = 0x2000
	// Bit NOTP13.
	GPIO_PORT_NOT_NOTP13 = 0x2000
	// Position of NOTP14 field.
	GPIO_PORT_NOT_NOTP14_Pos = 0xe
	// Bit mask of NOTP14 field.
	GPIO_PORT_NOT_NOTP14_Msk = 0x4000
	// Bit NOTP14.
	GPIO_PORT_NOT_NOTP14 = 0x4000
	// Position of NOTP15 field.
	GPIO_PORT_NOT_NOTP15_Pos = 0xf
	// Bit mask of NOTP15 field.
	GPIO_PORT_NOT_NOTP15_Msk = 0x8000
	// Bit NOTP15.
	GPIO_PORT_NOT_NOTP15 = 0x8000
	// Position of NOTP16 field.
	GPIO_PORT_NOT_NOTP16_Pos = 0x10
	// Bit mask of NOTP16 field.
	GPIO_PORT_NOT_NOTP16_Msk = 0x10000
	// Bit NOTP16.
	GPIO_PORT_NOT_NOTP16 = 0x10000
	// Position of NOTP17 field.
	GPIO_PORT_NOT_NOTP17_Pos = 0x11
	// Bit mask of NOTP17 field.
	GPIO_PORT_NOT_NOTP17_Msk = 0x20000
	// Bit NOTP17.
	GPIO_PORT_NOT_NOTP17 = 0x20000
	// Position of NOTP18 field.
	GPIO_PORT_NOT_NOTP18_Pos = 0x12
	// Bit mask of NOTP18 field.
	GPIO_PORT_NOT_NOTP18_Msk = 0x40000
	// Bit NOTP18.
	GPIO_PORT_NOT_NOTP18 = 0x40000
	// Position of NOTP19 field.
	GPIO_PORT_NOT_NOTP19_Pos = 0x13
	// Bit mask of NOTP19 field.
	GPIO_PORT_NOT_NOTP19_Msk = 0x80000
	// Bit NOTP19.
	GPIO_PORT_NOT_NOTP19 = 0x80000
	// Position of NOTP20 field.
	GPIO_PORT_NOT_NOTP20_Pos = 0x14
	// Bit mask of NOTP20 field.
	GPIO_PORT_NOT_NOTP20_Msk = 0x100000
	// Bit NOTP20.
	GPIO_PORT_NOT_NOTP20 = 0x100000
	// Position of NOTP21 field.
	GPIO_PORT_NOT_NOTP21_Pos = 0x15
	// Bit mask of NOTP21 field.
	GPIO_PORT_NOT_NOTP21_Msk = 0x200000
	// Bit NOTP21.
	GPIO_PORT_NOT_NOTP21 = 0x200000
	// Position of NOTP22 field.
	GPIO_PORT_NOT_NOTP22_Pos = 0x16
	// Bit mask of NOTP22 field.
	GPIO_PORT_NOT_NOTP22_Msk = 0x400000
	// Bit NOTP22.
	GPIO_PORT_NOT_NOTP22 = 0x400000
	// Position of NOTP23 field.
	GPIO_PORT_NOT_NOTP23_Pos = 0x17
	// Bit mask of NOTP23 field.
	GPIO_PORT_NOT_NOTP23_Msk = 0x800000
	// Bit NOTP23.
	GPIO_PORT_NOT_NOTP23 = 0x800000
	// Position of NOTP24 field.
	GPIO_PORT_NOT_NOTP24_Pos = 0x18
	// Bit mask of NOTP24 field.
	GPIO_PORT_NOT_NOTP24_Msk = 0x1000000
	// Bit NOTP24.
	GPIO_PORT_NOT_NOTP24 = 0x1000000
	// Position of NOTP25 field.
	GPIO_PORT_NOT_NOTP25_Pos = 0x19
	// Bit mask of NOTP25 field.
	GPIO_PORT_NOT_NOTP25_Msk = 0x2000000
	// Bit NOTP25.
	GPIO_PORT_NOT_NOTP25 = 0x2000000
	// Position of NOTP26 field.
	GPIO_PORT_NOT_NOTP26_Pos = 0x1a
	// Bit mask of NOTP26 field.
	GPIO_PORT_NOT_NOTP26_Msk = 0x4000000
	// Bit NOTP26.
	GPIO_PORT_NOT_NOTP26 = 0x4000000
	// Position of NOTP27 field.
	GPIO_PORT_NOT_NOTP27_Pos = 0x1b
	// Bit mask of NOTP27 field.
	GPIO_PORT_NOT_NOTP27_Msk = 0x8000000
	// Bit NOTP27.
	GPIO_PORT_NOT_NOTP27 = 0x8000000
	// Position of NOTP28 field.
	GPIO_PORT_NOT_NOTP28_Pos = 0x1c
	// Bit mask of NOTP28 field.
	GPIO_PORT_NOT_NOTP28_Msk = 0x10000000
	// Bit NOTP28.
	GPIO_PORT_NOT_NOTP28 = 0x10000000
	// Position of NOTP29 field.
	GPIO_PORT_NOT_NOTP29_Pos = 0x1d
	// Bit mask of NOTP29 field.
	GPIO_PORT_NOT_NOTP29_Msk = 0x20000000
	// Bit NOTP29.
	GPIO_PORT_NOT_NOTP29 = 0x20000000
	// Position of NOTP30 field.
	GPIO_PORT_NOT_NOTP30_Pos = 0x1e
	// Bit mask of NOTP30 field.
	GPIO_PORT_NOT_NOTP30_Msk = 0x40000000
	// Bit NOTP30.
	GPIO_PORT_NOT_NOTP30 = 0x40000000
	// Position of NOTP31 field.
	GPIO_PORT_NOT_NOTP31_Pos = 0x1f
	// Bit mask of NOTP31 field.
	GPIO_PORT_NOT_NOTP31_Msk = 0x80000000
	// Bit NOTP31.
	GPIO_PORT_NOT_NOTP31 = 0x80000000
)
